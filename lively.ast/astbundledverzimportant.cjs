'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('events');
var require$$0$2 = require('tty');
var require$$1 = require('util');
var require$$2 = require('fs');
var require$$4 = require('net');
require('path');
require('os');
require('child_process');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);

const parameterRegex = /function[^\(]*\(([^\)]*)\)|\(?([^\)=]*)\)?\s*=>/;
class Closure {
  static fromFunction(func, varMapping) {
    return new Closure(func, varMapping || {});
  }
  static fromSource(source, varMapping) {
    return new this(null, varMapping || {}, source);
  }
  constructor(func, varMapping, source, funcProperties) {
    this.originalFunc = func;
    this.varMapping = varMapping || {};
    this.setFuncSource(source || func);
    this.setFuncProperties(func || funcProperties);
  }
  get isLivelyClosure() {
    return true;
  }
  get doNotSerialize() {
    return ["originalFunc"];
  }
  setFuncSource(src) {
    src = typeof lively !== "undefined" && lively.sourceTransform && typeof lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder === "function" ? lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder(src) : String(src);
    return this.source = src;
  }
  getFuncSource() {
    return this.source || this.setFuncSource(this.originalFunc);
  }
  hasFuncSource() {
    return this.source && true;
  }
  getFunc() {
    return this.originalFunc || this.recreateFunc();
  }
  getFuncProperties() {
    return this.funcProperties || (this.funcProperties = {});
  }
  setFuncProperties(obj) {
    const props = this.getFuncProperties();
    for (const name in obj) {
      if (obj.hasOwnProperty(name))
        props[name] = obj[name];
    }
  }
  lookup(name) {
    return this.varMapping[name];
  }
  parameterNames(methodString) {
    if (typeof lively !== "undefined" && lively.ast && lively.ast.parseFunction) {
      return (lively.ast.parseFunction(methodString).params || []).map(function (ea) {
        if (ea.type === "Identifier")
          return ea.name;
        if (ea.left && ea.left.type === "Identifier")
          return ea.left.name;
        return null;
      }).filter(Boolean);
    }
    const paramsMatch = parameterRegex.exec(methodString);
    if (!paramsMatch)
      return [];
    const paramsString = paramsMatch[1] || paramsMatch[2] || "";
    return paramsString.split(",").map(function (ea) {
      return ea.trim();
    });
  }
  firstParameter(src) {
    return this.parameterNames(src)[0] || null;
  }
  recreateFunc() {
    return this.recreateFuncFromSource(this.getFuncSource(), this.originalFunc);
  }
  recreateFuncFromSource(funcSource, optFunc) {
    const closureVars = [];
    const specificSuperHandling = this.firstParameter(funcSource) === "$super";
    for (const name in this.varMapping) {
      if (!this.varMapping.hasOwnProperty(name))
        continue;
      if (name === "this") {
        continue;
      }
      closureVars.push("var " + name + " = this.varMapping." + name + ";\n");
    }
    let src = "";
    if (closureVars.length > 0)
      src += closureVars.join("\n");
    if (specificSuperHandling)
      src += "(function superWrapperForClosure() { return ";
    src += "(" + funcSource + ")";
    if (specificSuperHandling) {
      src += ".apply(this, [$super.bind(this)]" + ".concat(Array.from(arguments))) })";
    }
    try {
      const func = evalJS.call(this, src) || this.couldNotCreateFunc(src);
      this.addFuncProperties(func);
      this.originalFunc = func;
      return func;
    } catch (e) {
      const msg = "Cannot create function " + e + " src: " + src;
      console.error(msg);
      throw new Error(msg);
    }
  }
  addFuncProperties(func) {
    const props = this.getFuncProperties();
    for (const name in props) {
      if (props.hasOwnProperty(name)) {
        func[name] = props[name];
      }
    }
    this.addClosureInformation(func);
  }
  couldNotCreateFunc(src) {
    const msg = "Could not recreate closure from source: \n" + src;
    console.error(msg);
    return function () {
      throw new Error(msg);
    };
  }
  asFunction() {
    return this.recreateFunc();
  }
  addClosureInformation(f) {
    f.hasLivelyClosure = true;
    f.livelyClosure = this;
    return f;
  }
}

function Empty() {
  return function () {
  };
}
function K() {
  return function (arg) {
    return arg;
  };
}
function Null() {
  return function () {
    return null;
  };
}
function False() {
  return function () {
    return false;
  };
}
function True() {
  return function () {
    return true;
  };
}
function notYetImplemented() {
  return function () {
    throw new Error("Not yet implemented");
  };
}
function all(object) {
  const a = [];
  for (const name in object) {
    if (!object.__lookupGetter__(name) && typeof object[name] === "function")
      a.push(name);
  }
  return a;
}
function own(object) {
  const a = [];
  for (const name in object) {
    if (!object.__lookupGetter__(name) && object.hasOwnProperty(name) && typeof object[name] === "function")
      a.push(name);
  }
  return a;
}
function argumentNames(f) {
  if (f.superclass)
    return [];
  const src = f.toString();
  let names = "";
  const arrowMatch = src.match(/(?:\(([^\)]*)\)|([^\(\)-+!]+))\s*=>/);
  if (arrowMatch)
    names = arrowMatch[1] || arrowMatch[2] || "";
  else {
    const headerMatch = src.match(/^[\s\(]*function[^(]*\(([^)]*)\)/);
    if (headerMatch && headerMatch[1])
      names = headerMatch[1];
  }
  return names.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, "").replace(/\s+/g, "").split(",").map(function (ea) {
    return ea.trim();
  }).filter(function (name) {
    return !!name;
  });
}
function qualifiedMethodName(f) {
  let objString = "";
  if (f.declaredClass) {
    objString += f.declaredClass + ">>";
  } else if (f.declaredObject) {
    objString += f.declaredObject + ".";
  }
  return objString + (f.methodName || f.displayName || f.name || "anonymous");
}
function extractBody(func) {
  const codeString = String(func).replace(/^function[^\{]+\{\s*/, "").replace(/\}$/, "").trim();
  const lines = codeString.split(/\n|\r/);
  let indent;
  for (let i = 0; i < lines.length; i++) {
    const m = lines[i].match(/^(\s+)[^\s]/);
    if (m && (indent === undefined || m[1].length < indent.length))
      indent = m[1];
  }
  return indent ? codeString.replace(new RegExp("^" + indent, "gm"), "") : codeString;
}
function timeToRun(func) {
  const startTime = Date.now();
  func();
  return Date.now() - startTime;
}
function timeToRunN(func, n) {
  const startTime = Date.now();
  for (let i = 0; i < n; i++)
    func();
  return (Date.now() - startTime) / n;
}
function delay$1(func, timeout) {
  const args = Array.prototype.slice.call(arguments);
  const __method = args.shift();
  timeout = args.shift() * 1000;
  return setTimeout(function delayed() {
    return __method.apply(__method, args);
  }, timeout);
}
function throttle(func, wait) {
  let context;
  let args;
  let timeout;
  let throttling;
  let more;
  let result;
  const whenDone = debounce(wait, function () {
    more = throttling = false;
  });
  return function () {
    context = this;
    args = arguments;
    const later = function () {
      timeout = null;
      if (more)
        func.apply(context, args);
      whenDone();
    };
    if (!timeout)
      timeout = setTimeout(later, wait);
    if (throttling) {
      more = true;
    } else {
      result = func.apply(context, args);
    }
    whenDone();
    throttling = true;
    return result;
  };
}
function debounce(wait, func, immediate) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    const later = function () {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    if (immediate && !timeout)
      func.apply(context, args);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
const _throttledByName = {};
function throttleNamed(name, wait, func) {
  const store = _throttledByName;
  if (store[name])
    return store[name];
  function throttleNamedWrapper() {
    debounceNamed(name, wait, function () {
      delete store[name];
    })();
    return func.apply(this, arguments);
  }
  return store[name] = throttle(throttleNamedWrapper, wait);
}
const _debouncedByName = {};
function debounceNamed(name, wait, func, immediate) {
  const store = _debouncedByName;
  if (store[name])
    return store[name];
  function debounceNamedWrapper() {
    delete store[name];
    return func.apply(this, arguments);
  }
  return store[name] = debounce(wait, debounceNamedWrapper, immediate);
}
const _queues = {};
function createQueue(id, workerFunc) {
  const store = _queues;
  let queue = store[id] || (store[id] = {
    _workerActive: false,
    worker: workerFunc,
    tasks: [],
    drain: null,
    push: function (task) {
      queue.tasks.push(task);
      if (!queue._workerActive)
        queue.activateWorker();
    },
    pushAll: function (tasks) {
      tasks.forEach(function (ea) {
        queue.tasks.push(ea);
      });
      if (!queue._workerActive)
        queue.activateWorker();
    },
    pushNoActivate: function (task) {
      queue.tasks.push(task);
    },
    handleError: function (err) {
      err && console.error("Error in queue: " + err);
    },
    activateWorker: function () {
      function callback(err) {
        queue.handleError(err);
        queue.activateWorker();
      }
      const tasks = queue.tasks;
      const active = queue._workerActive;
      if (tasks.length === 0) {
        if (active) {
          queue._workerActive = false;
          if (typeof queue.drain === "function")
            queue.drain();
        }
        delete store[id];
      } else {
        if (!active)
          queue._workerActive = true;
        try {
          queue.worker(tasks.shift(), callback);
        } catch (err) {
          callback(err);
        }
      }
    }
  });
  return queue;
}
const _queueUntilCallbacks = {};
function workerWithCallbackQueue(id, workerFunc, optTimeout) {
  const store = _queueUntilCallbacks;
  let queueCallbacks = store[id];
  const isRunning = !!queueCallbacks;
  if (isRunning)
    return queueCallbacks;
  let callbacksRun = false;
  let canceled = false;
  function cleanup() {
    if (timeoutProc)
      clearTimeout(timeoutProc);
    callbacksRun = true;
    delete store[id];
  }
  function runCallbacks(args) {
    if (callbacksRun)
      return;
    cleanup();
    queueCallbacks.callbacks.forEach(function (cb) {
      try {
        cb.apply(null, args);
      } catch (e) {
        console.error("Error when invoking callbacks in queueUntil [" + id + "]:\n" + String(e.stack || e));
      }
    });
  }
  let timeoutProc;
  if (optTimeout) {
    timeoutProc = setTimeout(function () {
      if (callbacksRun)
        return;
      runCallbacks([new Error("timeout")]);
    }, optTimeout);
  }
  queueCallbacks = store[id] = {
    callbacks: [],
    cancel: function () {
      canceled = true;
      cleanup();
    },
    whenDone: function (cb) {
      queueCallbacks.callbacks.push(cb);
      return queueCallbacks;
    }
  };
  setTimeout(function () {
    if (canceled)
      return;
    try {
      workerFunc(function () {
        runCallbacks(arguments);
      });
    } catch (e) {
      runCallbacks([e]);
    }
  }, 0);
  return queueCallbacks;
}
function _composeAsyncDefaultEndCallback(err, arg1) {
  if (err)
    console.error("lively.lang.composeAsync error", err);
}
function composeAsync() {
  const toArray = Array.prototype.slice;
  const functions = toArray.call(arguments);
  const defaultEndCb = _composeAsyncDefaultEndCallback;
  let endCallback = defaultEndCb;
  let endSuccess;
  let endFailure;
  const endPromise = new Promise(function (resolve, reject) {
    endSuccess = resolve;
    endFailure = reject;
  });
  return functions.reverse().reduce(function (prevFunc, funcOrPromise, i) {
    let nextActivated = false;
    return function () {
      const args = toArray.call(arguments);
      if (endCallback === defaultEndCb && i === functions.length - 1) {
        while (args.length && typeof args[args.length - 1] !== "function")
          args.pop();
        if (typeof args[args.length - 1] === "function")
          endCallback = args.pop();
      }
      function next() {
        nextActivated = true;
        const args = toArray.call(arguments);
        const err = args.shift();
        if (err) {
          endCallback(err);
          endFailure(err);
        } else
          prevFunc.apply(null, args);
      }
      if (typeof funcOrPromise === "function") {
        try {
          const result = funcOrPromise.apply(this, args.concat([next]));
          if (result && typeof result.then === "function" && typeof result.catch === "function") {
            result.then(function (value) {
              return next(null, value);
            }).catch(function (err) {
              return next(err);
            });
          }
        } catch (e) {
          console.error("composeAsync: ", e.stack || e);
          if (!nextActivated) {
            endCallback(e);
            endFailure(e);
          }
        }
      } else if (funcOrPromise && typeof funcOrPromise.then === "function" && typeof funcOrPromise.catch === "function") {
        funcOrPromise.then(function (value) {
          next(null, value);
        }).catch(function (err) {
          next(err);
        });
      } else {
        const err = new Error("Invalid argument to composeAsync: " + funcOrPromise);
        endCallback(err);
        endFailure(err);
      }
      return endPromise;
    };
  }, function () {
    const args = toArray.call(arguments);
    endCallback.apply(null, [null].concat(args));
    endSuccess(args[0]);
  });
}
function compose() {
  const functions = Array.prototype.slice.call(arguments);
  return functions.reverse().reduce(function (prevFunc, func) {
    return function () {
      return prevFunc(func.apply(this, arguments));
    };
  }, function (x) {
    return x;
  });
}
function flip(f) {
  return function flipped() {
    const args = Array.prototype.slice.call(arguments);
    const flippedArgs = [
      args[1],
      args[0]
    ].concat(args.slice(2));
    return f.apply(null, flippedArgs);
  };
}
function withNull(func) {
  func = func || function () {
  };
  return function () {
    const args = Array.from(arguments);
    func.apply(null, [null].concat(args));
  };
}
function waitFor$1(timeoutMs, waitTesterFunc, thenDo) {
  const start = Date.now();
  let timeStep = 50;
  if (!thenDo) {
    thenDo = waitTesterFunc;
    waitTesterFunc = timeoutMs;
    timeoutMs = undefined;
  }
  (function test() {
    if (waitTesterFunc())
      return thenDo();
    if (timeoutMs) {
      const duration = Date.now() - start;
      const timeLeft = timeoutMs - duration;
      if (timeLeft <= 0)
        return thenDo(new Error("timeout"));
      if (timeLeft < timeStep)
        timeStep = timeLeft;
    }
    setTimeout(test, timeStep);
  }());
}
function waitForAll(options, funcs, thenDo) {
  if (!thenDo) {
    thenDo = funcs;
    funcs = options;
    options = null;
  }
  options = options || {};
  const results = funcs.map(function () {
    return null;
  });
  if (!funcs.length) {
    thenDo(null, results);
    return;
  }
  const leftFuncs = Array.prototype.slice.call(funcs);
  funcs.forEach(function (f, i) {
    try {
      f(function () {
        const args = Array.prototype.slice.call(arguments);
        const err = args.shift();
        markAsDone(f, i, err, args);
      });
    } catch (e) {
      markAsDone(f, i, e, null);
    }
  });
  if (options.timeout) {
    setTimeout(function () {
      if (!leftFuncs.length)
        return;
      const missing = results.map(function (ea, i) {
        return ea === null && i;
      }).filter(function (ea) {
        return typeof ea === "number";
      }).join(", ");
      const err = new Error("waitForAll timed out, functions at " + missing + " not done");
      markAsDone(null, null, err, null);
    }, options.timeout);
  }
  function markAsDone(f, i, err, result) {
    if (!leftFuncs.length)
      return;
    let waitForAllErr = null;
    const fidx = leftFuncs.indexOf(f);
    fidx > -1 && leftFuncs.splice(fidx, 1);
    if (err) {
      leftFuncs.length = 0;
      waitForAllErr = new Error("in waitForAll at" + (typeof i === "number" ? " " + i : "") + ": \n" + (err.stack || String(err)));
    } else if (result)
      results[i] = result;
    if (!leftFuncs.length) {
      setTimeout(function () {
        thenDo(waitForAllErr, results);
      }, 0);
    }
  }
}
function curry(func, ...curryArgs) {
  if (arguments.length <= 1)
    return arguments[0];
  const args = Array.prototype.slice.call(arguments);
  func = args.shift();
  function wrappedFunc() {
    return func.apply(this, args.concat(Array.prototype.slice.call(arguments)));
  }
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = func;
  return wrappedFunc;
}
function wrap(func, wrapper) {
  const __method = func;
  const wrappedFunc = function wrapped() {
    const args = Array.prototype.slice.call(arguments);
    const wrapperArgs = wrapper.isWrapper ? args : [__method.bind(this)].concat(args);
    return wrapper.apply(this, wrapperArgs);
  };
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = __method;
  return wrappedFunc;
}
function getOriginal(wrappedFunc) {
  while (wrappedFunc.originalFunction)
    wrappedFunc = wrappedFunc.originalFunction;
  return wrappedFunc;
}
function wrapperChain(method) {
  const result = [];
  do {
    result.push(method);
    method = method.originalFunction;
  } while (method);
  return result;
}
function replaceMethodForOneCall(obj, methodName, replacement) {
  replacement.originalFunction = obj[methodName];
  const reinstall = obj.hasOwnProperty(methodName);
  obj[methodName] = function () {
    if (reinstall)
      obj[methodName] = replacement.originalFunction;
    else
      delete obj[methodName];
    return replacement.apply(this, arguments);
  };
  return obj;
}
function once(func) {
  if (!func)
    return undefined;
  if (typeof func !== "function") {
    throw new Error("once() expecting a function");
  }
  let invoked = false;
  let result;
  return function () {
    if (invoked)
      return result;
    invoked = true;
    return result = func.apply(this, arguments);
  };
}
function either() {
  const funcs = Array.prototype.slice.call(arguments);
  let wasCalled = false;
  return funcs.map(function (func) {
    return function () {
      if (wasCalled)
        return undefined;
      wasCalled = true;
      return func.apply(this, arguments);
    };
  });
}
const _eitherNameRegistry = {};
function eitherNamed(name, func) {
  const funcs = Array.prototype.slice.call(arguments);
  const registry = _eitherNameRegistry;
  name = funcs.shift();
  const eitherCall = registry[name] || (registry[name] = {
    wasCalled: false,
    callsLeft: 0
  });
  eitherCall.callsLeft++;
  return function () {
    eitherCall.callsLeft--;
    if (eitherCall.callsLeft <= 0)
      delete registry[name];
    if (eitherCall.wasCalled)
      return undefined;
    eitherCall.wasCalled = true;
    return func.apply(this, arguments);
  };
}
function evalJS(src) {
  return eval(src);
}
function fromString(funcOrString) {
  return evalJS("(" + funcOrString.toString() + ");");
}
function asScript(func, optVarMapping) {
  return Closure.fromFunction(func, optVarMapping).recreateFunc();
}
const binds = asScript;
function asScriptOf(f, obj, optName, optMapping) {
  const name = optName || f.name;
  if (!name) {
    throw Error("Function that wants to be a script needs a name: " + this);
  }
  const proto = Object.getPrototypeOf(obj);
  let mapping = { this: obj };
  if (optMapping)
    mapping = merge([
      mapping,
      optMapping
    ]);
  if (proto && proto[name]) {
    const superFunc = function () {
      try {
        return Object.getPrototypeOf(obj)[name].apply(obj, arguments);
      } catch (e) {
        if (typeof $world !== "undefined")
          $world.logError(e, "Error in $super call");
        else
          console.error("Error in $super call: " + e + "\n" + e.stack);
        return null;
      }
    };
    mapping.$super = Closure.fromFunction(superFunc, {
      obj,
      name
    }).recreateFunc();
  }
  return addToObject(asScript(f, mapping), obj, name);
}
function addToObject(f, obj, name) {
  f.displayName = name;
  const methodConnections = obj.attributeConnections ? obj.attributeConnections.filter(function (con) {
    return con.getSourceAttrName() === "update";
  }) : [];
  if (methodConnections) {
    methodConnections.forEach(function (ea) {
      ea.disconnect();
    });
  }
  obj[name] = f;
  if (typeof obj)
    f.declaredObject = safeToString(obj);
  if (typeof lively !== "undefined" && obj && lively.Tracing && lively.Tracing.stackTracingEnabled) {
    lively.Tracing.instrumentMethod(obj, name, { declaredObject: safeToString(obj) });
  }
  if (methodConnections) {
    methodConnections.forEach(function (ea) {
      ea.connect();
    });
  }
  return f;
}
function setLocalVarValue(f, name, value) {
  if (f.hasLivelyClosure)
    f.livelyClosure.funcProperties[name] = value;
}
function getVarMapping(f) {
  if (f.hasLivelyClosure)
    return f.livelyClosure.varMapping;
  if (f.isWrapper)
    return f.originalFunction.varMapping;
  if (f.varMapping)
    return f.varMapping;
  return {};
}
function setProperty(func, name, value) {
  func[name] = value;
  if (func.hasLivelyClosure)
    func.livelyClosure.funcProperties[name] = value;
}
function functionNames(klass) {
  let result = [];
  let lookupObj = klass.prototype;
  while (lookupObj) {
    result = Object.keys(lookupObj).reduce(function (result, name) {
      if (typeof lookupObj[name] === "function" && result.indexOf(name) === -1) {
        result.push(name);
      }
      return result;
    }, result);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}
function localFunctionNames(func) {
  return Object.keys(func.prototype).filter(function (name) {
    return typeof func.prototype[name] === "function";
  });
}
function logErrors(func, prefix) {
  const advice = function logErrorsAdvice(proceed) {
    const args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      return proceed.apply(func, args);
    } catch (er) {
      if (typeof lively !== "undefined" && lively.morphic && lively.morphic.World && lively.morphic.World.current()) {
        lively.morphic.World.current().logError(er);
        throw er;
      }
      if (prefix)
        console.warn("ERROR: %s.%s(%s): err: %s %s", func, prefix, args, er, er.stack || "");
      else
        console.warn("ERROR: %s %s", er, er.stack || "");
      throw er;
    }
  };
  advice.methodName = "$logErrorsAdvice";
  const result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logErrorsWrapper";
  return result;
}
function logCompletion(func, module) {
  const advice = function logCompletionAdvice(proceed) {
    const args = Array.prototype.slice.call(arguments);
    args.shift();
    let result;
    try {
      result = proceed.apply(func, args);
    } catch (er) {
      console.warn("failed to load " + module + ": " + er);
      if (typeof lively !== "undefined" && lively.lang.Execution) {
        lively.lang.Execution.showStack();
      }
      throw er;
    }
    console.log("completed " + module);
    return result;
  };
  advice.methodName = "$logCompletionAdvice::" + module;
  const result = wrap(func, advice);
  result.methodName = "$logCompletionWrapper::" + module;
  result.originalFunction = func;
  return result;
}
function logCalls(func, isUrgent) {
  const original = func;
  let result;
  const advice = function logCallsAdvice(proceed) {
    const args = Array.prototype.slice.call(arguments);
    args.shift(), result = proceed.apply(func, args);
    if (isUrgent) {
      console.warn("%s(%s) -> %s", qualifiedMethodName(original), args, result);
    } else {
      console.log("%s(%s) -> %s", qualifiedMethodName(original), args, result);
    }
    return result;
  };
  advice.methodName = "$logCallsAdvice::" + qualifiedMethodName(func);
  result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logCallsWrapper::" + qualifiedMethodName(func);
  return result;
}
function traceCalls(func, stack) {
  const advice = function traceCallsAdvice(proceed) {
    const args = Array.prototype.slice.call(arguments);
    args.shift();
    stack.push(args);
    const result = proceed.apply(func, args);
    stack.pop();
    return result;
  };
  return wrap(func, advice);
}
function webkitStack() {
  try {
    throw new Error();
  } catch (e) {
    return String(e.stack).split(/\n/).slice(2).map(function (line) {
      return line.replace(/^\s*at\s*([^\s]+).*/, "$1");
    }).join("\n");
  }
}

var fun = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Empty: Empty,
  K: K,
  Null: Null,
  False: False,
  True: True,
  notYetImplemented: notYetImplemented,
  withNull: withNull,
  all: all,
  own: own,
  argumentNames: argumentNames,
  qualifiedMethodName: qualifiedMethodName,
  extractBody: extractBody,
  timeToRun: timeToRun,
  timeToRunN: timeToRunN,
  delay: delay$1,
  throttle: throttle,
  debounce: debounce,
  throttleNamed: throttleNamed,
  debounceNamed: debounceNamed,
  createQueue: createQueue,
  workerWithCallbackQueue: workerWithCallbackQueue,
  composeAsync: composeAsync,
  compose: compose,
  waitFor: waitFor$1,
  waitForAll: waitForAll,
  flip: flip,
  curry: curry,
  wrap: wrap,
  binds: binds,
  getOriginal: getOriginal,
  wrapperChain: wrapperChain,
  replaceMethodForOneCall: replaceMethodForOneCall,
  once: once,
  either: either,
  eitherNamed: eitherNamed,
  evalJS: evalJS,
  fromString: fromString,
  asScript: asScript,
  asScriptOf: asScriptOf,
  addToObject: addToObject,
  setLocalVarValue: setLocalVarValue,
  getVarMapping: getVarMapping,
  setProperty: setProperty,
  functionNames: functionNames,
  localFunctionNames: localFunctionNames,
  logErrors: logErrors,
  logCompletion: logCompletion,
  logCalls: logCalls,
  traceCalls: traceCalls,
  webkitStack: webkitStack
});

class Group {
  static get by() {
    return groupBy;
  }
  static fromArray(array, hashFunc, context) {
    const grouping = new Group();
    for (let i = 0, len = array.length; i < len; i++) {
      let hash = hashFunc.call(context, array[i], i);
      if (Group.prototype.hasOwnProperty(hash))
        hash = "_" + hash;
      if (!grouping[hash])
        grouping[hash] = [];
      grouping[hash].push(array[i]);
    }
    return grouping;
  }
  toArray() {
    return this.reduceGroups(function (all, _, group) {
      return all.concat([group]);
    }, []);
  }
  forEach(iterator, context) {
    const groups = this;
    Object.keys(groups).forEach(function (groupName) {
      groups[groupName].forEach(iterator.bind(context, groupName));
    });
    return groups;
  }
  forEachGroup(iterator, context) {
    const groups = this;
    Object.keys(groups).forEach(function (groupName) {
      iterator.call(context, groupName, groups[groupName]);
    });
    return groups;
  }
  map(iterator, context) {
    const result = new Group();
    this.forEachGroup(function (groupName, group) {
      result[groupName] = group.map(iterator.bind(context, groupName));
    });
    return result;
  }
  mapGroups(iterator, context) {
    const result = new Group();
    this.forEachGroup(function (groupName, group) {
      result[groupName] = iterator.call(context, groupName, group);
    });
    return result;
  }
  keys() {
    return Object.keys(this);
  }
  reduceGroups(iterator, carryOver, context) {
    this.forEachGroup(function (groupName, group) {
      carryOver = iterator.call(context, carryOver, groupName, group);
    });
    return carryOver;
  }
  count() {
    return this.reduceGroups(function (groupCount, groupName, group) {
      groupCount[groupName] = group.length;
      return groupCount;
    }, {});
  }
}

function range(begin, end, step) {
  step = step || 0;
  const result = [];
  if (begin <= end) {
    if (step <= 0)
      step = -step || 1;
    for (let i = begin; i <= end; i += step)
      result.push(i);
  } else {
    if (step >= 0)
      step = -step || -1;
    for (let i = begin; i >= end; i += step)
      result.push(i);
  }
  return result;
}
function withN(n, obj) {
  const result = new Array(n);
  while (n > 0)
    result[--n] = obj;
  return result;
}
function genN(n, generator) {
  const result = new Array(n);
  while (n > 0)
    result[--n] = generator(n);
  return result;
}
function binarySearchFor(array, searchValue, converter, returnClosestElement = false) {
  if (!array || !Array.isArray(array))
    return;
  let leftLimit = 0;
  let rightLimit = array.length - 1;
  while (leftLimit <= rightLimit) {
    const pivot = leftLimit + Math.floor((rightLimit - leftLimit) / 2);
    const compareValue = !converter ? array[pivot] : converter(array[pivot]);
    if (compareValue === searchValue) {
      return array[pivot];
    } else {
      if (compareValue > searchValue) {
        rightLimit = pivot - 1;
      } else {
        leftLimit = pivot + 1;
      }
    }
  }
  if (returnClosestElement) {
    if (!array[leftLimit])
      return array[rightLimit];
    if (!array[rightLimit])
      return array[leftLimit];
    const compareValueL = !converter ? array[leftLimit] : converter(array[leftLimit]);
    const compareValueR = !converter ? array[rightLimit] : converter(array[rightLimit]);
    const diffOfElementL = Math.abs(compareValueL - searchValue);
    const diffOfElementR = Math.abs(compareValueR - searchValue);
    return diffOfElementL - diffOfElementR < 0 ? array[leftLimit] : array[rightLimit];
  }
  return undefined;
}
function findAndGet(arr, iterator) {
  let result;
  arr.find(function (ea, i) {
    return result = iterator(ea, i);
  });
  return result;
}
function filterByKey(arr, key) {
  return arr.filter(function (ea) {
    return !!ea[key];
  });
}
function grep(arr, test) {
  if (typeof test === "string")
    test = new RegExp(test, "i");
  return arr.filter(e => String(e).match(test));
}
function mask(array, mask) {
  return array.filter(function (_, i) {
    return !!mask[i];
  });
}
function reject(array, func, context) {
  function iterator(val, i) {
    return !func.call(context, val, i);
  }
  return array.filter(iterator);
}
function rejectByKey(array, key) {
  return array.filter(function (ea) {
    return !ea[key];
  });
}
function without(array, elem) {
  return array.filter(val => val !== elem);
}
function withoutAll(array, otherArr) {
  return array.filter(val => otherArr.indexOf(val) === -1);
}
function uniq(array, sorted) {
  if (!array.length)
    return array;
  const result = [array[0]];
  if (sorted) {
    for (let i = 1; i < array.length; i++) {
      const val = array[i];
      if (val !== result[result.length]) {
        result.push(val);
      }
    }
  } else {
    for (let i = 1; i < array.length; i++) {
      const val = array[i];
      if (result.indexOf(val) === -1) {
        result.push(val);
      }
    }
  }
  return result;
}
function uniqBy(array, comparator, context) {
  const result = array.slice();
  for (let i = result.length; i--;) {
    const item = array[i];
    for (let j = i + 1; j < result.length; j++) {
      if (comparator.call(context, item, result[j])) {
        result.splice(j--, 1);
      }
    }
  }
  return result;
}
function uniqByKey(array, key) {
  const seen = {};
  const result = [];
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (!seen[item[key]]) {
      seen[item[key]] = true;
      result.push(item);
    }
  }
  return result;
}
function compact(array) {
  return array.filter(Boolean);
}
function mutableCompact(array) {
  let i = 0;
  let j = 0;
  const len = array.length;
  while (i < len) {
    if (array.hasOwnProperty(i))
      array[j++] = array[i];
    i++;
  }
  while (j++ < len)
    array.pop();
  return array;
}
function zip() {
  const args = Array.from(arguments);
  const array = args.shift();
  const iterator = typeof last(args) === "function" ? args.pop() : function (x) {
    return x;
  };
  const collections = [array].concat(args).map(function (ea) {
    return Array.from(ea);
  });
  return array.map(function (value, index) {
    return iterator(pluck(collections, index), index);
  });
}
function interpose(array, delim) {
  return array.reduce(function (xs, x) {
    if (xs.length > 0)
      xs.push(delim);
    xs.push(x);
    return xs;
  }, []);
}
function invoke(array, method, arg1, arg2, arg3, arg4, arg5, arg6) {
  return array.map(function (ea) {
    return ea[method](arg1, arg2, arg3, arg4, arg5, arg6);
  });
}
function pluck(array, property) {
  return array.map(ea => ea[property]);
}
function equals$2(array, otherArray) {
  const len = array.length;
  if (!otherArray || len !== otherArray.length)
    return false;
  for (let i = 0; i < len; i++) {
    if (array[i] && otherArray[i] && array[i].equals && otherArray[i].equals) {
      if (!array[i].equals(otherArray[i])) {
        return false;
      } else {
        continue;
      }
    }
    if (array[i] !== otherArray[i])
      return false;
  }
  return true;
}
function deepEquals(array, otherArray) {
  const len = array.length;
  if (!otherArray || len !== otherArray.length)
    return false;
  for (let i = 0; i < len; i++) {
    if (!equals$1(array[i], otherArray[i]))
      return false;
  }
  return true;
}
function isSorted(array, descending) {
  if (descending) {
    for (let i = 1; i < array.length; i++) {
      if (array[i - 1] < array[i])
        return false;
    }
  } else {
    for (let i = 1; i < array.length; i++) {
      if (array[i - 1] > array[i])
        return false;
    }
  }
  return true;
}
function sortBy(array, iterator, context) {
  return pluck(array.map(function (value, index) {
    return {
      value: value,
      criteria: iterator.call(context, value, index)
    };
  }).sort(function (left, right) {
    const a = left.criteria;
    const b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }), "value");
}
function sortByKey(array, key) {
  return sortBy(array, ea => ea[key]);
}
function reversed(array) {
  return array.slice().reverse();
}
function reMatches$1(arr, re, stringifier) {
  stringifier = stringifier || String;
  return arr.map(ea => stringifier(ea).match(re));
}
function first(array) {
  return array[0];
}
function last(array) {
  return array[array.length - 1];
}
function intersect(array1, array2) {
  return uniq(array1).filter(item => array2.indexOf(item) > -1);
}
function union(array1, array2) {
  const result = array1.slice();
  for (let i = 0; i < array2.length; i++) {
    const item = array2[i];
    if (result.indexOf(item) === -1)
      result.push(item);
  }
  return result;
}
function pushAt(array, item, index) {
  array.splice(index, 0, item);
}
function removeAt(array, index) {
  array.splice(index, 1);
}
function remove(array, item) {
  const index = array.indexOf(item);
  if (index >= 0)
    removeAt(array, index);
  return item;
}
function pushAll(array, items) {
  array.push.apply(array, items);
  return array;
}
function pushAllAt(array, items, idx) {
  array.splice.apply(array, [
    idx,
    0
  ].concat(items));
}
function pushIfNotIncluded(array, item) {
  if (!array.includes(item))
    array.push(item);
}
function replaceAt(array, item, index) {
  array.splice(index, 1, item);
}
function clear(array) {
  array.length = 0;
  return array;
}
function isSubset(list1, list2) {
  for (let i = 0; i < list1.length; i++) {
    if (!list2.includes(list1[i])) {
      return false;
    }
  }
  return true;
}
function doAndContinue(array, iterator, endFunc, context) {
  endFunc = endFunc || Null;
  context = context;
  iterator = iterator || function (next, ea, idx) {
    ea.call(context, next, idx);
  };
  return array.reduceRight(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context, nextFunc, ea, idx);
    };
  }, endFunc)();
}
function nestedDelay(array, iterator, waitSecs, endFunc, context, optSynchronChunks) {
  endFunc = endFunc || function () {
  };
  return array.clone().reverse().reduce(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context, ea, idx);
      if (optSynchronChunks && idx % optSynchronChunks !== 0) {
        nextFunc();
      } else {
        nextFunc.delay(waitSecs);
      }
    };
  }, endFunc)();
}
function swap(array, index1, index2) {
  if (index1 < 0)
    index1 = array.length + index1;
  if (index2 < 0)
    index2 = array.length + index2;
  const temp = array[index1];
  array[index1] = array[index2];
  array[index2] = temp;
  return array;
}
function rotate(array, times) {
  times = times || 1;
  return array.slice(times).concat(array.slice(0, times));
}
function groupBy(array, iterator, context) {
  return Group.fromArray(array, iterator, context);
}
function groupByKey(array, key) {
  return groupBy(array, ea => ea[key]);
}
function partition(array, iterator, context) {
  iterator = iterator || function (x) {
    return x;
  };
  const trues = [];
  const falses = [];
  array.forEach(function (value, index) {
    (iterator.call(context, value, index) ? trues : falses).push(value);
  });
  return [
    trues,
    falses
  ];
}
function batchify(array, constrainedFunc, context) {
  return findBatches([], array);
  function extractBatch(batch, sizes) {
    if (!sizes.length)
      return [
        batch,
        []
      ];
    const first = sizes[0];
    const rest = sizes.slice(1);
    const candidate = batch.concat([first]);
    if (constrainedFunc.call(context, candidate))
      return extractBatch(candidate, rest);
    const batchAndSizes = extractBatch(batch, rest);
    return [
      batchAndSizes[0],
      [first].concat(batchAndSizes[1])
    ];
  }
  function findBatches(batches, sizes) {
    if (!sizes.length)
      return batches;
    const extracted = extractBatch([], sizes);
    if (!extracted[0].length) {
      throw new Error("Batchify constrained does not ensure consumption " + "of at least one item per batch!");
    }
    return findBatches(batches.concat([extracted[0]]), extracted[1]);
  }
}
function toTuples(array, tupleLength) {
  tupleLength = tupleLength || 1;
  return range(0, Math.ceil(array.length / tupleLength) - 1).map(function (n) {
    return array.slice(n * tupleLength, n * tupleLength + tupleLength);
  }, array);
}
const permutations = (function () {
  function computePermutations(restArray, values) {
    return !restArray.length ? [values] : restArray.flatMap(function (ea, i) {
      return computePermutations(restArray.slice(0, i).concat(restArray.slice(i + 1)), values.concat([ea]));
    });
  }
  return function (array) {
    return computePermutations(array, []);
  };
}());
function combinationsPick(listOfListsOfValues, pickIndices) {
  const values = listOfListsOfValues.map(function (subspace, i) {
    return subspace[pickIndices[i]];
  });
  let nextState = pickIndices.slice();
  for (let i = listOfListsOfValues.length; i--; i >= 0) {
    const subspace = listOfListsOfValues[i];
    const nextIndex = nextState[i] + 1;
    if (subspace[nextIndex]) {
      nextState[i] = nextIndex;
      break;
    } else if (i === 0) {
      nextState = undefined;
      break;
    } else {
      nextState[i] = 0;
    }
  }
  return [
    values,
    nextState
  ];
}
function combinations(listOfListsOfValues) {
  const size = listOfListsOfValues.reduce(function (prod, space) {
    return prod * space.length;
  }, 1);
  let searchState = listOfListsOfValues.map(function (_) {
    return 0;
  });
  const results = new Array(size);
  for (let i = 0; i < size; i++) {
    const result = combinationsPick(listOfListsOfValues, searchState);
    results[i] = result[0];
    searchState = result[1];
  }
  return results;
}
function take(arr, n) {
  return arr.slice(0, n);
}
function drop(arr, n) {
  return arr.slice(n);
}
function takeWhile(arr, fun, context) {
  let i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i))
      break;
  }
  return arr.slice(0, i);
}
function dropWhile(arr, fun, context) {
  let i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i))
      break;
  }
  return arr.slice(i);
}
function shuffle(array) {
  const unusedIndexes = range(0, array.length - 1);
  const shuffled = Array(array.length);
  for (let i = 0; i < array.length; i++) {
    const shuffledIndex = unusedIndexes.splice(Math.round(Math.random() * (unusedIndexes.length - 1)), 1);
    shuffled[shuffledIndex] = array[i];
  }
  return shuffled;
}
function max(array, iterator, context) {
  iterator = iterator || function (x) {
    return x;
  };
  let result;
  array.reduce(function (max, ea, i) {
    const val = iterator.call(context, ea, i);
    if (typeof val !== "number" || val <= max)
      return max;
    result = ea;
    return val;
  }, -Infinity);
  return result;
}
function min(array, iterator, context) {
  iterator = iterator || (x => x);
  return max(array, (ea, i) => -iterator.call(context, ea, i));
}
function sum(array) {
  let sum = 0;
  for (let i = 0; i < array.length; i++) {
    sum += array[i];
  }
  return sum;
}
function count(array, item) {
  return array.reduce(function (count, ea) {
    return ea === item ? count + 1 : count;
  }, 0);
}
function histogram(data, binSpec) {
  if (typeof binSpec === "undefined" || typeof binSpec === "number") {
    const binNumber = binSpec || function sturge() {
      return Math.ceil(Math.log(data.length) / Math.log(2) + 1);
    }();
    const binSize = Math.ceil(Math.round(data.length / binNumber));
    return range(0, binNumber - 1).map(function (i) {
      return data.slice(i * binSize, (i + 1) * binSize);
    });
  } else if (binSpec instanceof Array) {
    const thresholds = binSpec;
    return data.reduce(function (bins, d) {
      if (d < thresholds[1]) {
        bins[0].push(d);
        return bins;
      }
      for (let i = 1; i < thresholds.length; i++) {
        if (d >= thresholds[i] && (!thresholds[i + 1] || d <= thresholds[i + 1])) {
          bins[i].push(d);
          return bins;
        }
      }
      throw new Error(`Histogram creation: Cannot group data ${ d } into thresholds ${ thresholds }`);
    }, range(1, thresholds.length).map(function () {
      return [];
    }));
  }
}
function clone$1(array) {
  return [].concat(array);
}
function filter$1(array, iterator, context) {
  return array.filter(iterator, context);
}
function find(array, iterator, context) {
  return array.find(iterator, context);
}
function map$2(array, iterator, context) {
  return array.map(iterator, context);
}
function flat(array, optDepth) {
  return array.flat(optDepth);
}
function flatMap(array, iterator, context) {
  return array.flatMap(iterator, context);
}
function slice(array, start, end) {
  return array.slice(start, end);
}

var arr = /*#__PURE__*/Object.freeze({
  __proto__: null,
  range: range,
  withN: withN,
  genN: genN,
  binarySearchFor: binarySearchFor,
  findAndGet: findAndGet,
  filterByKey: filterByKey,
  grep: grep,
  mask: mask,
  reject: reject,
  rejectByKey: rejectByKey,
  without: without,
  withoutAll: withoutAll,
  uniq: uniq,
  uniqBy: uniqBy,
  uniqByKey: uniqByKey,
  compact: compact,
  mutableCompact: mutableCompact,
  zip: zip,
  interpose: interpose,
  invoke: invoke,
  pluck: pluck,
  equals: equals$2,
  deepEquals: deepEquals,
  isSorted: isSorted,
  sortBy: sortBy,
  sortByKey: sortByKey,
  reversed: reversed,
  reMatches: reMatches$1,
  first: first,
  last: last,
  intersect: intersect,
  union: union,
  pushAt: pushAt,
  removeAt: removeAt,
  remove: remove,
  pushAll: pushAll,
  pushAllAt: pushAllAt,
  pushIfNotIncluded: pushIfNotIncluded,
  replaceAt: replaceAt,
  clear: clear,
  isSubset: isSubset,
  doAndContinue: doAndContinue,
  nestedDelay: nestedDelay,
  swap: swap,
  rotate: rotate,
  groupBy: groupBy,
  groupByKey: groupByKey,
  partition: partition,
  batchify: batchify,
  toTuples: toTuples,
  permutations: permutations,
  combinationsPick: combinationsPick,
  combinations: combinations,
  take: take,
  drop: drop,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  shuffle: shuffle,
  max: max,
  min: min,
  sum: sum,
  count: count,
  histogram: histogram,
  clone: clone$1,
  flat: flat,
  filter: filter$1,
  find: find,
  map: map$2,
  flatMap: flatMap,
  slice: slice
});

function print$1(object) {
  if (object && Array.isArray(object)) {
    return "[" + object.map(print$1) + "]";
  }
  if (typeof object !== "string") {
    return String(object);
  }
  let result = String(object);
  result = result.replace(/\n/g, "\\n\\\n");
  result = result.replace(/(")/g, "\\$1");
  result = "\"" + result + "\"";
  return result;
}
function indent$1(str, indentString, depth) {
  if (!depth || depth <= 0)
    return str;
  while (depth > 0) {
    depth--;
    str = indentString + str;
  }
  return str;
}
const getOwnPropertyDescriptors = typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : function getOwnPropertyDescriptors(object) {
  const descriptors = {};
  for (const name in object) {
    if (!Object.prototype.hasOwnProperty.call(object, name))
      continue;
    Object.defineProperty(descriptors, name, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: Object.getOwnPropertyDescriptor(object, name)
    });
  }
  return descriptors;
};
function isArray(obj) {
  return Array.isArray(obj);
}
function isElement(object) {
  return object && object.nodeType === 1;
}
function isFunction(object) {
  return object instanceof Function;
}
function isBoolean(object) {
  return typeof object === "boolean";
}
function isString(object) {
  return typeof object === "string";
}
function isNumber(object) {
  return typeof object === "number";
}
function isUndefined(object) {
  return typeof object === "undefined";
}
function isRegExp(object) {
  return object instanceof RegExp;
}
function isObject(object) {
  return typeof object === "object";
}
function isPrimitive(obj) {
  if (!obj)
    return true;
  switch (typeof obj) {
  case "string":
  case "number":
  case "boolean":
    return true;
  }
  return false;
}
function isEmpty(object) {
  for (const key in object) {
    if (object.hasOwnProperty(key))
      return false;
  }
  return true;
}
function equals$1(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return a === b;
  if (Array.isArray(a))
    return deepEquals(a, b);
  switch (a.constructor) {
  case String:
  case Date:
  case Boolean:
  case Number:
    return a === b;
  }
  if (typeof a.isEqualNode === "function")
    return a.isEqualNode(b);
  if (typeof a.equals === "function")
    return a.equals(b);
  const seenInA = [];
  for (let name in a) {
    seenInA.push(name);
    if (typeof a[name] === "function")
      continue;
    if (!equals$1(a[name], b[name]))
      return false;
  }
  for (let name in b) {
    if (seenInA.indexOf(name) !== -1)
      continue;
    if (typeof b[name] === "function")
      continue;
    if (!equals$1(b[name], a[name]))
      return false;
  }
  return true;
}
const keys$2 = Object.keys;
function values(object) {
  return object ? Object.keys(object).map(function (k) {
    return object[k];
  }) : [];
}
function select(obj, keys) {
  const selected = {};
  for (let i = 0; i < keys.length; i++)
    selected[keys[i]] = obj[keys[i]];
  return selected;
}
function dissoc(object, keys) {
  object = object || {};
  const descriptors = getOwnPropertyDescriptors(object);
  for (let i = 0; i < keys.length; i++) {
    if (keys[i] in descriptors)
      delete descriptors[keys[i]];
  }
  return Object.defineProperties({}, descriptors);
}
function addScript(object, funcOrString, optName, optMapping) {
  const func = fromString(funcOrString);
  return asScriptOf(func, object, optName, optMapping);
}
function extend(destination, source) {
  let currentCategoryNames = null;
  for (let i = 1; i < arguments.length; i++) {
    if (typeof arguments[i] === "string") {
      const catName = arguments[i];
      if (!destination.categories)
        destination.categories = {};
      if (!destination.categories[catName])
        destination.categories[catName] = [];
      currentCategoryNames = destination.categories[catName];
      continue;
    }
    source = arguments[i];
    for (const property in source) {
      const getter = source.__lookupGetter__(property);
      const setter = source.__lookupSetter__(property);
      if (getter) {
        destination.__defineGetter__(property, getter);
      }
      if (setter) {
        destination.__defineSetter__(property, setter);
      }
      if (getter || setter) {
        continue;
      }
      const sourceObj = source[property];
      destination[property] = sourceObj;
      if (currentCategoryNames) {
        currentCategoryNames.push(property);
      }
      if (typeof sourceObj === "function") {
        if (!sourceObj.displayName) {
          sourceObj.displayName = property;
        }
        if (typeof lively !== "undefined" && lively.Module && lively.Module.current) {
          sourceObj.sourceModule = lively.Module.current();
        }
      }
    }
  }
  return destination;
}
function clone(object) {
  if (isPrimitive(object))
    return object;
  if (Array.isArray(object))
    return Array.prototype.slice.call(object);
  const clone = {};
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      clone[key] = object[key];
    }
  }
  clone.__proto__ = object.__proto__;
  return clone;
}
function extract(object, properties, mapFunc) {
  const copied = {};
  for (let i = 0; i < properties.length; i++) {
    if (properties[i] in object) {
      copied[properties[i]] = mapFunc ? mapFunc(properties[i], object[properties[i]]) : object[properties[i]];
    }
  }
  return copied;
}
function inspect(object, options, depth) {
  options = options || {};
  depth = depth || 0;
  if (options.customPrinter) {
    const ignoreSignal = options._ignoreSignal || (options._ignoreSignal = {});
    const continueInspectFn = obj => inspect(obj, options, depth + 1);
    const customInspected = options.customPrinter(object, ignoreSignal, continueInspectFn);
    if (customInspected !== ignoreSignal)
      return customInspected;
  }
  if (!object)
    return print$1(object);
  if (typeof object === "function") {
    return options.printFunctionSource ? String(object) : "function" + (object.name ? " " + object.name : "") + "(" + argumentNames(object).join(",") + ") {/*...*/}";
  }
  switch (object.constructor) {
  case String:
  case Boolean:
  case RegExp:
  case Number:
    return print$1(object);
  }
  if (typeof object.serializeExpr === "function") {
    return object.serializeExpr();
  }
  const isArray = object && Array.isArray(object);
  const openBr = isArray ? "[" : "{";
  const closeBr = isArray ? "]" : "}";
  if (options.maxDepth && depth >= options.maxDepth) {
    return openBr + "/*...*/" + closeBr;
  }
  let printedProps = [];
  if (isArray) {
    printedProps = object.map(function (ea) {
      return inspect(ea, options, depth + 1);
    });
  } else {
    let propsToPrint = Object.keys(object).sort(function (a, b) {
      const aIsFunc = typeof object[a] === "function";
      const bIsFunc = typeof object[b] === "function";
      if (aIsFunc === bIsFunc) {
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      }
      return aIsFunc ? 1 : -1;
    });
    if (typeof options.keySorter === "function") {
      propsToPrint = propsToPrint.sort(options.keySorter);
    }
    for (let i = 0; i < propsToPrint.length; i++) {
      if (i > (options.maxNumberOfKeys || Infinity)) {
        const hiddenEntryCount = propsToPrint.length - i;
        printedProps.push(`...${ hiddenEntryCount } hidden ${ hiddenEntryCount > 1 ? "entries" : "entry" }...`);
        break;
      }
      const key = propsToPrint[i];
      if (isArray)
        inspect(object[key], options, depth + 1);
      const printedVal = inspect(object[key], options, depth + 1);
      printedProps.push((options.escapeKeys ? JSON.stringify(key) : key) + ": " + printedVal);
    }
  }
  if (printedProps.length === 0) {
    return openBr + closeBr;
  }
  let printedPropsJoined = printedProps.join(", ");
  const useNewLines = (!isArray || options.newLineInArrays) && (!options.minLengthForNewLine || printedPropsJoined.length >= options.minLengthForNewLine);
  const ind = indent$1("", options.indent || "  ", depth);
  const propIndent = indent$1("", options.indent || "  ", depth + 1);
  const startBreak = useNewLines && !isArray ? "\n" + propIndent : "";
  const eachBreak = useNewLines ? "\n" + propIndent : "";
  const endBreak = useNewLines && !isArray ? "\n" + ind : "";
  if (useNewLines)
    printedPropsJoined = printedProps.join("," + eachBreak);
  return openBr + startBreak + printedPropsJoined + endBreak + closeBr;
}
function merge(objs) {
  if (arguments.length > 1) {
    return merge(Array.prototype.slice.call(arguments));
  }
  if (Array.isArray(objs[0])) {
    return Array.prototype.concat.apply([], objs);
  }
  return objs.reduce(function (merged, ea) {
    for (const name in ea) {
      if (ea.hasOwnProperty(name)) {
        merged[name] = ea[name];
      }
    }
    return merged;
  }, {});
}
function deepMerge(objA, objB) {
  if (!objA)
    return objB;
  if (!objB)
    return objA;
  if (Array.isArray(objA)) {
    if (!Array.isArray(objB))
      return objB;
    let merged = objA.map(function (ea, i) {
      return deepMerge(ea, objB[i]);
    });
    if (objB.length > objA.length)
      merged = merged.concat(objB.slice(objA.length));
    return merged;
  }
  if (typeof objA !== "object" || typeof objB !== "object")
    return objB;
  return Object.keys(objA).concat(Object.keys(objB)).reduce(function (merged, name) {
    if (!objA[name])
      merged[name] = objB[name];
    else if (!objB[name])
      merged[name] = objA[name];
    else if (typeof objA[name] !== "object" || typeof objB[name] !== "object")
      merged[name] = objB[name];
    else
      merged[name] = deepMerge(objA[name], objB[name]);
    return merged;
  }, {});
}
function sortKeysWithBeforeAndAfterConstraints(properties, throwErrorOnMissing = false) {
  const remaining = [];
  for (const key in properties) {
    const prop = properties[key];
    const before = prop.hasOwnProperty("before") ? prop.before : prop.before = [];
    const after = prop.hasOwnProperty("after") ? prop.after : prop.after = [];
    let stringified = "";
    try {
      stringified = String(this);
    } catch (err) {
    }
    for (let i = before.length; i--;) {
      const beforePropName = before[i];
      const beforeProp = properties[beforePropName];
      if (!beforeProp) {
        console.warn(`[initializeProperties] ${ stringified } sortProperties: ` + `Property ${ key } requires to be initialized before ${ beforePropName } ` + "but that property cannot be found.");
        before.splice(i, 1);
        continue;
      }
      if (!beforeProp.hasOwnProperty("after"))
        beforeProp.after = [];
      beforeProp.after.push(key);
    }
    for (let i = after.length; i--;) {
      const afterPropName = after[i];
      const afterProp = properties[afterPropName];
      if (!afterProp) {
        console.warn(`[initializeProperties] ${ stringified } sortProperties: ` + `Property ${ key } requires to be initialized after ${ afterPropName } ` + "but that property cannot be found.");
        after.splice(i, 1);
      }
    }
    remaining.push(key);
  }
  const resolvedGroups = [];
  const resolvedKeys = [];
  let lastLength = remaining.length + 1;
  while (remaining.length) {
    if (lastLength === remaining.length) {
      throw new Error("Circular dependencies in handler order, could not resolve properties " + remaining.map(key => {
        const before = properties[key].before;
        const after = properties[key].after;
        if ((!before || !before.length) && (!after || !after.length))
          return "";
        let report = `${ key }\n`;
        if (before && before.length)
          report += `  - before ${ before.join(",") }\n`;
        if (after && after.length)
          report += `  - after ${ after.join(",") }\n`;
        return report;
      }).join(""));
    }
    lastLength = remaining.length;
    const resolvedGroup = [];
    for (let i = remaining.length; i--;) {
      const key = remaining[i];
      if (isSubset(properties[key].after, resolvedKeys)) {
        remaining.splice(i, 1);
        resolvedKeys.push(key);
        resolvedGroup.push(key);
      }
    }
    resolvedGroups.push(resolvedGroup);
  }
  return resolvedGroups.flat();
}
function inherit(obj) {
  return Object.create(obj);
}
function valuesInPropertyHierarchy(obj, name) {
  const result = [];
  let lookupObj = obj;
  while (lookupObj) {
    if (lookupObj.hasOwnProperty(name))
      result.unshift(lookupObj[name]);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}
function mergePropertyInHierarchy(obj, propName) {
  return merge(valuesInPropertyHierarchy(obj, propName));
}
function deepCopy(object) {
  if (!object || typeof object !== "object" || object instanceof RegExp)
    return object;
  const result = Array.isArray(object) ? Array(object.length) : {};
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      result[key] = deepCopy(object[key]);
    }
  }
  return result;
}
function typeStringOf(obj) {
  if (obj === null)
    return "null";
  if (typeof obj === "undefined")
    return "undefined";
  return obj.constructor.name;
}
function isMutableType(obj) {
  const immutableTypes = [
    "null",
    "undefined",
    "Boolean",
    "Number",
    "String"
  ];
  return immutableTypes.indexOf(typeStringOf(obj)) === -1;
}
function shortPrintStringOf(obj) {
  if (!isMutableType(obj))
    return safeToString(obj);
  if (obj.constructor.name !== "Object" && !Array.isArray(obj)) {
    if (obj.constructor.name) {
      return obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).split(" ")[1].split("]")[0];
    }
  }
  let typeString = "";
  function displayTypeAndLength(obj, collectionType, firstBracket, secondBracket) {
    if (obj.constructor.name === collectionType) {
      typeString += firstBracket;
      if (obj.length || Object.keys(obj).length)
        typeString += "...";
      typeString += secondBracket;
    }
  }
  displayTypeAndLength(obj, "Object", "{", "}");
  displayTypeAndLength(obj, "Array", "[", "]");
  return typeString;
}
function safeToString(obj) {
  try {
    return (obj ? obj.toString() : String(obj)).replace("\n", "");
  } catch (e) {
    return "<error printing object>";
  }
}
function asObject(obj) {
  switch (typeof obj) {
  case "string":
    return new String(obj);
  case "boolean":
    return new Boolean(obj);
  case "number":
    return new Number(obj);
  default:
    return obj;
  }
}
function newKeyIn(obj, base = "_") {
  let i = 1;
  let key;
  do {
    key = base + "-" + i++;
  } while (key in obj);
  return key;
}
const setPrototypeOf = typeof Object.setPrototypeOf === "function" ? (obj, proto) => Object.setPrototypeOf(obj, proto) : (obj, proto) => obj.__proto__ = proto;
function adoptObject(object, newClass) {
  if (newClass === object.constructor)
    return;
  object.constructor = newClass;
  setPrototypeOf(object, newClass.prototype);
}

var obj = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isArray: isArray,
  isElement: isElement,
  isFunction: isFunction,
  isBoolean: isBoolean,
  isString: isString,
  isNumber: isNumber,
  isUndefined: isUndefined,
  isRegExp: isRegExp,
  isObject: isObject,
  isPrimitive: isPrimitive,
  isEmpty: isEmpty,
  equals: equals$1,
  keys: keys$2,
  values: values,
  select: select,
  dissoc: dissoc,
  addScript: addScript,
  extend: extend,
  clone: clone,
  extract: extract,
  inspect: inspect,
  merge: merge,
  deepMerge: deepMerge,
  inherit: inherit,
  valuesInPropertyHierarchy: valuesInPropertyHierarchy,
  mergePropertyInHierarchy: mergePropertyInHierarchy,
  sortKeysWithBeforeAndAfterConstraints: sortKeysWithBeforeAndAfterConstraints,
  deepCopy: deepCopy,
  typeStringOf: typeStringOf,
  shortPrintStringOf: shortPrintStringOf,
  isMutableType: isMutableType,
  safeToString: safeToString,
  asObject: asObject,
  newKeyIn: newKeyIn,
  getOwnPropertyDescriptors: getOwnPropertyDescriptors,
  adoptObject: adoptObject,
  setPrototypeOf: setPrototypeOf
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var Articles = {exports: {}};

(function () {
  var a, articlize, arts, find, n, slice = [].slice;
  a = "a";
  n = "an";
  arts = {
    0: {
      8: { _: n },
      9: { _: n },
      "-": {
        1: { 1: { _: n } },
        4: {
          " ": { _: a },
          _: n
        },
        6: { "-": { _: n } },
        8: { _: n }
      }
    },
    1: {
      1: {
        0: { _: a },
        1: { _: a },
        2: { _: a },
        3: { _: a },
        4: { _: a },
        5: { _: a },
        6: { _: a },
        7: { _: a },
        8: { _: a },
        9: { _: a },
        _: n,
        ".": { 4: { _: a } }
      },
      8: {
        0: {
          0: { _: n },
          1: { _: n },
          2: { _: n },
          3: { _: n },
          4: { _: n },
          5: { _: n },
          6: { _: n },
          7: { _: n },
          8: { _: n },
          9: { _: n },
          _: a
        },
        1: {
          "-": { _: a },
          " ": { _: a }
        },
        2: {
          "-": { _: a },
          " ": { _: a }
        },
        3: {
          "-": { _: a },
          " ": { _: a }
        },
        4: {
          "-": { _: a },
          " ": { _: a }
        },
        5: {
          "-": { _: a },
          " ": { _: a }
        },
        6: {
          "-": { _: a },
          " ": { _: a }
        },
        7: {
          "-": { _: a },
          " ": { _: a }
        },
        8: {
          "-": { _: a },
          " ": { _: a }
        },
        9: {
          "-": { _: a },
          " ": { _: a }
        },
        _: n
      }
    },
    8: {
      0: { 0: { x: { _: a } } },
      9: { 0: { _: a } },
      _: n,
      ",": { 1: { _: a } }
    },
    "`": { a: { _: n } },
    "\xA3": { 8: { _: n } },
    "\u221E": { _: n },
    a: {
      " ": { _: a },
      b: {
        o: {
          u: {
            t: { "-": { _: n } },
            _: a
          }
        }
      },
      g: { a: { i: { _: a } } },
      l: {
        "-": { I: { _: a } },
        g: { u: { _: a } },
        t: { h: { _: a } }
      },
      m: { o: { n: { _: a } } },
      n: {
        " ": { _: a },
        d: {
          a: { _: n },
          e: { _: n },
          r: { _: n },
          _: a
        },
        o: { t: { _: a } },
        y: { w: { _: a } }
      },
      p: { r: { e: { _: a } } },
      r: {
        e: {
          " ": { _: a },
          ":": { _: a }
        },
        t: { "í": { _: a } }
      },
      _: n
    },
    A: {
      $: { _: a },
      A: { A: { _: a } },
      n: { d: { a: { l: { u: { c: { _: a } } } } } },
      r: { m: { a: { t: { _: a } } } },
      s: { t: { u: { r: { i: { a: { s: { _: a } } } } } } },
      t: {
        h: {
          l: {
            e: { t: { i: { _: n } } },
            o: { _: n },
            _: a
          }
        }
      },
      U: {
        $: { _: a },
        D: { _: a },
        S: { C: { _: a } }
      },
      _: n
    },
    "Á": { _: n },
    "á": { ";": { _: n } },
    "à": { _: n },
    "Ä": { _: n },
    "ā": { _: n },
    "Å": { _: n },
    "æ": { _: n },
    "Æ": {
      n: { _: a },
      _: n
    },
    D: { "ú": { n: { _: a } } },
    e: {
      ".": { g: { _: a } },
      a: { c: { h: { " ": { _: a } } } },
      i: {
        t: {
          h: {
            e: {
              r: {
                " ": { _: a },
                ".": { _: a }
              }
            }
          }
        }
      },
      l: {
        "-": { _: a },
        l: { a: { _: a } }
      },
      m: { p: { e: { z: { _: a } } } },
      n: { o: { u: { g: { _: a } } } },
      u: {
        p: { " ": { _: n } },
        _: a
      },
      w: { _: a },
      x: { i: { s: { t: { s: { _: a } } } } },
      _: n
    },
    E: {
      m: { p: { e: { z: { _: a } } } },
      n: { a: { m: { _: a } } },
      s: {
        p: {
          a: { d: { _: n } },
          e: { _: n },
          o: { _: n },
          _: a
        }
      },
      u: {
        l: { _: n },
        _: a
      },
      U: { R: { _: a } },
      _: n
    },
    "é": {
      g: { _: a },
      t: {
        a: { _: n },
        u: { _: n },
        _: a
      },
      _: n
    },
    "É": { _: n },
    f: {
      "-": { _: n },
      " ": { _: n },
      "/": { _: n },
      M: { _: n },
      p: { _: n },
      t: { _: n }
    },
    F: {
      0: { _: n },
      1: { _: n },
      2: { _: n },
      3: { _: n },
      4: { _: n },
      5: { _: n },
      6: { _: n },
      9: { _: n },
      "'": { _: n },
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "#": { _: n },
      ",": { _: n },
      ".": { _: n },
      "/": { _: n },
      "\u201D": { _: n },
      A: {
        C: { _: a },
        D: { _: a },
        I: { R: { _: a } },
        L: { _: a },
        M: { _: a },
        N: { _: a },
        P: { _: a },
        Q: { _: a },
        R: { _: a },
        S: { _: a },
        T: { _: a },
        _: n
      },
      B: { _: n },
      C: { _: n },
      c: { _: n },
      D: { _: n },
      E: {
        C: { _: n },
        I: { _: n }
      },
      F: {
        " ": { _: a },
        _: n
      },
      f: { _: n },
      h: { _: n },
      H: { _: n },
      I: {
        A: {
          T: { _: a },
          _: n
        },
        D: { " ": { _: n } },
        R: { " ": { _: n } },
        S: { " ": { _: n } }
      },
      K: { _: n },
      L: {
        C: { _: n },
        N: { _: n },
        P: { _: n }
      },
      M: {
        R: { _: a },
        _: n
      },
      O: {
        " ": { _: n },
        I: { " ": { _: n } }
      },
      P: {
        ".": { _: a },
        "?": { _: a },
        C: { "?": { _: a } },
        _: n
      },
      R: {
        C: { _: n },
        S: { _: n }
      },
      S: { _: n },
      T: {
        S: { _: a },
        T: { _: a },
        _: n
      },
      U: {
        " ": { _: n },
        ",": { _: n },
        ".": { _: n }
      },
      V: { _: n },
      W: {
        D: { _: a },
        _: n
      },
      X: { _: n },
      Y: { _: n },
      "σ": { _: n }
    },
    G: {
      h: {
        a: {
          e: { _: n },
          i: { _: n }
        }
      }
    },
    h: {
      "'": { _: n },
      "-": {
        U: { _: a },
        _: n
      },
      " ": { _: n },
      "\"": { _: n },
      ",": { _: n },
      C: { _: n },
      e: {
        i: {
          r: {
            a: { _: a },
            _: n
          }
        }
      },
      i: {
        m: { s: { _: n } },
        s: { t: { o: { r: { i: { c: { _: a } } } } } }
      },
      o: {
        m: {
          a: { _: n },
          m: { _: n }
        },
        n: {
          e: { y: { _: a } },
          k: { _: a },
          v: { _: a },
          _: n
        },
        r: { s: { " ": { _: n } } },
        u: { r: { _: n } }
      },
      t: {
        t: {
          p: { " ": { _: n } },
          _: a
        },
        _: n
      }
    },
    H: {
      1: { _: n },
      2: { _: n },
      3: { _: n },
      4: { _: n },
      5: { _: n },
      "'": { _: n },
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ",": { _: n },
      ".": {
        A: { _: a },
        _: n
      },
      "+": { _: n },
      a: { b: { i: { l: { i: { t: { a: { t: { i: { o: { n: { s: { _: n } } } } } } } } } } } },
      B: { _: n },
      C: { _: n },
      D: {
        B: { _: a },
        _: n
      },
      e: { i: { r: { _: n } } },
      F: { _: n },
      G: { _: n },
      H: { _: n },
      I: {
        D: { _: a },
        G: { _: a },
        M: { _: a },
        P: { _: a },
        _: n
      },
      L: {
        A: { "-": { D: { _: a } } },
        _: n
      },
      M: { _: n },
      N: { _: n },
      o: {
        n: {
          d: { _: a },
          e: {
            s: { _: n },
            _: a
          },
          g: { _: a },
          k: { _: a },
          o: { l: { _: a } },
          _: n
        },
        u: { r: { _: n } }
      },
      O: {
        " ": { _: n },
        V: { _: n }
      },
      P: { _: n },
      Q: { _: n },
      R: {
        T: { _: a },
        _: n
      },
      S: {
        " ": { _: a },
        R: { _: a },
        T: { _: a },
        _: n
      },
      T: {
        P: { _: a },
        _: n
      },
      V: { _: n },
      W: { T: { _: n } }
    },
    i: {
      ".": { e: { _: a } },
      b: { n: { _: a } },
      f: { " ": { _: a } },
      i: { _: a },
      n: {
        c: { l: { u: { d: { i: { _: a } } } } },
        d: { i: { c: { a: { t: { e: { s: { _: a } } } } } } },
        s: {
          t: {
            e: {
              a: {
                d: { "?": { _: n } },
                _: a
              }
            }
          }
        }
      },
      s: {
        " ": { _: a },
        ".": { _: a }
      },
      t: { " ": { _: a } },
      u: { _: a },
      _: n
    },
    I: {
      "-": {
        A: { _: a },
        I: { _: a }
      },
      I: { I: { _: a } },
      l: { b: { _: a } },
      M: { H: { _: a } },
      m: { a: { m: { s: { _: a } } } },
      R: { "\xA3": { _: a } },
      s: {
        l: {
          a: {
            m: {
              " ": { _: a },
              ",": { _: a },
              ".": { _: a }
            },
            n: { d: { s: { _: a } } }
          }
        }
      },
      _: n
    },
    "İ": { _: n },
    J: {
      i: {
        a: {
          n: { _: a },
          _: n
        }
      }
    },
    k: { u: { " ": { _: n } } },
    l: {
      " ": { _: n },
      "\"": { _: n },
      p: { _: n }
    },
    L: {
      1: { _: n },
      2: { _: n },
      3: { _: n },
      5: { _: n },
      "'": {
        A: { _: a },
        _: n
      },
      "-": {
        a: { _: a },
        _: n
      },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ",": { _: n },
      ".": { _: n },
      "/": { _: n },
      a: {
        e: { _: n },
        o: { i: { g: { _: n } } }
      },
      A: {
        " ": { _: n },
        L: { _: n },
        P: { _: n }
      },
      B: { _: n },
      C: { _: n },
      D: { _: n },
      E: {
        A: { _: a },
        E: { _: a },
        G: { _: a },
        O: { _: a },
        P: { _: a },
        T: { _: a },
        _: n
      },
      F: { _: n },
      G: { _: n },
      H: { _: n },
      I: { R: { _: n } },
      L: { _: n },
      M: {
        X: { _: a },
        _: n
      },
      N: { _: n },
      o: { c: { h: { a: { _: n } } } },
      O: { E: { _: n } },
      P: { _: n },
      R: { _: n },
      S: { _: n },
      T: { _: n },
      U: { " ": { _: n } },
      V: { _: n },
      X: { _: n },
      Z: { _: n }
    },
    m: {
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      a: { k: { e: { s: { " ": { _: n } } } } },
      b: { _: n },
      e: {
        i: { n: { _: n } },
        n: { t: { i: { o: { n: { s: { _: n } } } } } }
      },
      f: { _: n },
      p: { _: n },
      R: { _: n },
      t: { _: n }
    },
    M: {
      1: {
        9: {
          0: { _: n },
          _: a
        },
        _: n
      },
      2: { _: n },
      3: { _: n },
      4: { _: n },
      5: { _: n },
      6: { _: n },
      7: { _: n },
      8: { _: n },
      9: { _: n },
      "'": { _: n },
      "-": {
        t: { _: a },
        _: n
      },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ",": { _: n },
      ".": {
        A: { ".": { S: { _: a } } },
        _: n
      },
      "/": { _: n },
      A: {
        C: { _: a },
        D: { _: a },
        F: { _: a },
        G: { _: a },
        J: { _: a },
        L: { _: a },
        M: { _: a },
        N: { _: a },
        P: { _: a },
        R: { _: a },
        S: { _: a },
        T: { _: a },
        X: { _: a },
        Y: { _: a },
        _: n
      },
      B: { _: n },
      C: { _: n },
      D: { _: n },
      e: { "-": { _: n } },
      E: {
        d: { _: n },
        n: { _: n },
        P: { _: n }
      },
      F: { _: n },
      f: { _: n },
      G: { _: n },
      H: { _: n },
      h: { _: n },
      i: { e: { _: n } },
      I: {
        5: { _: n },
        6: { _: n },
        " ": { _: n },
        A: { _: n },
        T: { _: n }
      },
      K: { _: n },
      L: { _: n },
      M: {
        T: { _: a },
        _: n
      },
      N: { _: n },
      o: { U: { _: n } },
      O: {
        " ": { _: n },
        T: { " ": { _: n } },
        U: { _: n }
      },
      P: { _: n },
      R: { _: n },
      S: { _: n },
      s: { c: { _: n } },
      T: {
        R: { _: a },
        _: n
      },
      U: { V: { _: n } },
      V: { _: n },
      X: { _: n }
    },
    N: {
      4: { _: n },
      6: { _: n },
      "'": { _: n },
      "-": {
        a: { _: a },
        S: { _: a },
        _: n
      },
      " ": { _: n },
      "\"": { _: n },
      ",": { _: n },
      ".": {
        Y: { _: a },
        _: n
      },
      "=": { _: n },
      "\xB2": { _: n },
      a: { o: { _: n } },
      A: {
        " ": { _: n },
        A: {
          F: { _: a },
          _: n
        },
        I: { _: n },
        S: { L: { _: n } }
      },
      B: { _: n },
      C: { _: n },
      D: { _: n },
      E: {
        A: { _: n },
        H: { _: n },
        S: { " ": { _: n } }
      },
      F: { _: n },
      G: { _: n },
      H: { _: n },
      I: {
        C: { _: a },
        L: { _: a },
        M: {
          H: { _: n },
          _: a
        },
        N: { _: a },
        S: { _: a },
        _: n
      },
      J: { C: { _: n } },
      K: { _: n },
      L: {
        S: { _: a },
        _: n
      },
      M: { _: n },
      N: {
        R: { _: n },
        T: { _: n }
      },
      P: {
        O: {
          V: { "-": { _: n } },
          _: a
        },
        _: n
      },
      R: {
        J: { _: a },
        T: { _: a },
        _: n
      },
      S: {
        W: { _: a },
        _: n
      },
      T: {
        $: { _: a },
        _: n
      },
      U: { S: { _: n } },
      V: { _: n },
      v: { _: n },
      W: { A: { _: n } },
      X: { _: n },
      Y: {
        P: { _: n },
        U: { _: n }
      }
    },
    n: {
      "-": { _: n },
      "\u2212": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ",": { _: n },
      "+": { _: n },
      "\xD7": { _: n },
      d: { a: { _: n } },
      p: { a: { _: n } },
      t: { _: n },
      V: { _: n },
      W: { _: n }
    },
    o: {
      b: { r: { _: a } },
      c: {
        c: { u: { r: { s: { _: a } } } },
        h: { o: { _: a } }
      },
      f: { " ": { _: a } },
      n: {
        "-": { _: n },
        "/": { _: n },
        b: { _: n },
        c: { o: { _: n } },
        d: { _: n },
        e: { r: { _: n } },
        g: { _: n },
        i: { _: n },
        l: { _: n },
        m: { _: n },
        o: { _: n },
        r: { _: n },
        s: { _: n },
        t: { _: n },
        u: { _: n },
        w: { _: n },
        y: { _: n },
        _: a
      },
      r: {
        " ": { _: a },
        ",": { _: a }
      },
      u: { i: { _: a } },
      _: n
    },
    O: {
      b: {
        e: {
          r: {
            s: {
              t: {
                " ": { _: n },
                l: { _: n }
              },
              _: a
            }
          }
        }
      },
      l: { v: { _: a } },
      n: {
        e: {
          i: { _: n },
          _: a
        }
      },
      N: { E: { _: a } },
      o: { p: { _: a } },
      u: { i: { _: a } },
      _: n
    },
    "Ó": { _: n },
    "Ö": { _: n },
    "ö": { _: n },
    "Ō": { _: n },
    "ō": { _: n },
    P: {
      h: {
        o: {
          b: { _: n },
          i: { _: n }
        }
      }
    },
    r: {
      "'": { _: n },
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ".": { _: n },
      e: { f: { e: { r: { s: { _: n } } } } },
      f: { _: n },
      m: { _: n },
      s: { _: n }
    },
    R: {
      1: {
        0: { _: a },
        _: n
      },
      2: { _: n },
      3: { _: n },
      4: { _: n },
      5: { _: n },
      6: { _: n },
      "'": { _: n },
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": { _: n },
      ",": { _: n },
      ".": {
        C: { _: a },
        _: n
      },
      "/": { _: n },
      A: {
        " ": { _: n },
        F: { _: n }
      },
      B: { _: n },
      C: { _: n },
      D: { _: n },
      E: {
        " ": { _: n },
        R: { _: n }
      },
      F: { _: n },
      f: { _: n },
      G: { _: n },
      H: { S: { _: n } },
      I: {
        A: { _: n },
        C: { " ": { _: n } }
      },
      J: { _: n },
      K: { _: n },
      L: {
        " ": { _: a },
        _: n
      },
      M: {
        1: { _: a },
        _: n
      },
      N: {
        G: { _: a },
        _: n
      },
      O: { T: { _: n } },
      P: { _: n },
      Q: { _: n },
      R: { _: n },
      S: {
        " ": { _: a },
        ")": { _: a },
        ",": { _: a },
        ".": { _: a },
        "?": { _: a },
        T: { _: a },
        _: n
      },
      T: { _: n },
      U: { _: n },
      V: { _: n },
      X: { _: n }
    },
    s: {
      "-": { _: n },
      "\"": { _: n },
      ")": { _: n },
      ",": { _: n },
      ".": { _: n },
      a: { y: { s: { _: n } } },
      i: { c: { h: { _: n } } },
      p: {
        3: { _: n },
        r: { o: { t: { _: n } } }
      },
      s: { h: { _: n } },
      t: {
        a: {
          t: {
            e: {
              s: {
                " ": { _: n },
                ":": { _: n }
              }
            }
          }
        }
      },
      v: {
        a: { _: a },
        e: { _: a },
        _: n
      }
    },
    S: {
      1: { _: n },
      2: { _: n },
      3: { _: n },
      4: { _: n },
      5: { _: n },
      6: { _: n },
      "'": { _: n },
      "-": { _: n },
      " ": { _: n },
      "\"": { _: n },
      "&": {
        W: { _: a },
        _: n
      },
      ",": { _: n },
      ".": {
        B: { _: n },
        M: { _: n },
        O: { _: n }
      },
      "\u201D": { _: n },
      A: {
        "-": {
          1: { _: a },
          _: n
        },
        " ": { _: n },
        C: { D: { _: n } },
        E: { _: n },
        S: {
          E: { _: a },
          _: n
        },
        T: {
          " ": { _: n },
          B: { _: n }
        }
      },
      B: { _: n },
      C: {
        A: { " ": { _: n } },
        C: { _: n },
        M: { _: n },
        O: { " ": { _: n } },
        R: {
          A: { _: a },
          _: n
        },
        T: { _: n }
      },
      D: { _: n },
      E: {
        " ": { _: n },
        C: {
          O: { _: a },
          R: { _: a },
          _: n
        },
        I: { _: n },
        O: { _: n }
      },
      F: { _: n },
      G: { _: n },
      H: {
        2: { _: n },
        3: { _: n },
        "-": { _: n }
      },
      I: { " ": { _: n } },
      J: { _: n },
      K: { _: n },
      L: {
        A: { _: a },
        I: { _: a },
        O: { _: a },
        _: n
      },
      M: {
        A: { _: a },
        E: {
          " ": { _: n },
          _: a
        },
        I: { _: a },
        _: n
      },
      N: {
        A: { _: a },
        E: { _: a },
        O: { _: a },
        _: n
      },
      O: {
        "(": { _: n },
        A: {
          " ": { _: n },
          I: { _: n }
        },
        E: { _: n },
        I: { _: n },
        S: { _: n },
        V: { _: n }
      },
      P: {
        A: {
          C: { _: a },
          D: { _: a },
          M: { _: a },
          N: { _: a },
          R: { _: a }
        },
        E: {
          " ": { _: n },
          _: a
        },
        I: { C: { _: a } },
        O: { _: a },
        U: { _: a },
        _: n
      },
      R: { _: n },
      S: { _: n },
      T: {
        "-": { _: n },
        A: { " ": { _: n } },
        B: { _: n },
        C: { _: n },
        D: { _: n },
        F: { _: n },
        L: { _: n },
        M: { _: n },
        S: { _: n },
        V: { _: n }
      },
      u: { r: { a: { " ": { _: n } } } },
      U: {
        B: { _: a },
        L: { _: a },
        N: { _: a },
        P: { _: a },
        S: { _: a },
        _: n
      },
      V: { _: n },
      W: {
        F: { _: n },
        P: { _: n },
        R: { _: n }
      },
      X: {
        S: { _: a },
        _: n
      }
    },
    t: {
      "-": { S: { _: n } },
      S: { _: n }
    },
    T: {
      a: { v: { e: { s: { _: n } } } },
      "à": { _: n }
    },
    u: {
      "-": { _: a },
      " ": { _: a },
      "\"": { _: a },
      ".": { _: a },
      b: {
        e: { _: n },
        _: a
      },
      f: { _: a },
      k: {
        a: { _: n },
        _: a
      },
      l: { u: { _: a } },
      m: { " ": { _: a } },
      n: {
        " ": { _: a },
        a: {
          " ": { _: a },
          n: {
            a: { _: n },
            n: { _: n },
            s: { _: n },
            t: { _: n },
            _: a
          },
          r: { y: { _: a } }
        },
        e: { " ": { _: a } },
        i: {
          c: { o: { r: { p: { _: n } } } },
          d: {
            i: { _: a },
            _: n
          },
          m: {
            o: { _: a },
            _: n
          },
          n: { _: n },
          v: { o: { _: n } },
          _: a
        },
        l: { e: { s: { _: a } } }
      },
      p: { o: { _: a } },
      r: {
        a: { _: a },
        e: { _: a },
        i: { _: a },
        l: { _: a },
        o: { _: a }
      },
      s: {
        "-": { _: n },
        " ": { _: n },
        h: { _: n },
        _: a
      },
      t: {
        m: { _: n },
        t: { _: n },
        _: a
      },
      v: { _: a },
      w: { _: a },
      _: n
    },
    U: {
      1: { _: n },
      "-": {
        B: {
          o: { _: a },
          _: n
        }
      },
      a: { _: n },
      b: {
        i: { _: a },
        _: n
      },
      D: { P: { "-": { _: n } } },
      d: { _: n },
      g: { l: { _: n } },
      h: { _: n },
      i: { _: n },
      l: {
        i: { _: a },
        _: n
      },
      m: { _: n },
      M: { N: { _: n } },
      n: {
        "-": { _: n },
        a: {
          n: { _: a },
          _: n
        },
        b: { _: n },
        c: { _: n },
        d: { _: n },
        e: {
          s: { _: a },
          _: n
        },
        f: { _: n },
        g: { _: n },
        h: { _: n },
        i: {
          d: { _: n },
          n: { _: n }
        },
        k: { _: n },
        l: { _: n },
        m: { _: n },
        n: { _: n },
        o: { _: n },
        p: { _: n },
        r: { _: n },
        s: { _: n },
        t: {
          e: { r: { s: { _: a } } },
          _: n
        },
        u: { _: n },
        w: { _: n }
      },
      p: { _: n },
      r: {
        a: { _: a },
        i: { _: a },
        u: {
          g: { u: { a: { y: { a: { n: { "-": { _: n } } } } } } },
          k: { _: n },
          _: a
        },
        _: n
      },
      s: {
        h: { _: n },
        t: { _: n }
      },
      t: {
        n: { _: n },
        o: { "-": { _: n } },
        r: { _: n },
        t: { _: n }
      },
      x: { _: n },
      z: { _: n }
    },
    "ü": { _: n },
    "Ü": { _: n },
    V: { I: { I: { _: n } } },
    x: {
      a: { _: a },
      e: { _: a },
      i: { _: a },
      o: { _: a },
      x: { _: a },
      y: { _: a },
      _: n
    },
    X: {
      a: { _: a },
      A: { _: a },
      e: { _: a },
      h: { _: a },
      i: { _: a },
      I: {
        V: { _: a },
        X: { _: a }
      },
      o: { _: a },
      u: { _: a },
      U: { _: a },
      V: { _: a },
      X: {
        " ": { _: n },
        _: a
      },
      y: { _: a },
      _: n
    },
    Y: { p: { _: n } },
    "α": { _: n },
    "ε": { _: n },
    "ω": { _: n }
  };
  find = function (word, obj, article) {
    var key;
    if (obj == null) {
      obj = arts;
    }
    if (article == null) {
      article = "a";
    }
    if (word == null) {
      return article;
    }
    key = word.slice(0, 1);
    obj = obj[key];
    if (key != null && obj != null) {
      return find(word.slice(1), obj, obj._ || article);
    } else {
      return article;
    }
  };
  articlize = function () {
    var input, inputs, out;
    inputs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    out = (function () {
      var i, len, results;
      results = [];
      for (i = 0, len = inputs.length; i < len; i++) {
        input = inputs[i];
        if (input != null) {
          results.push(find(input) + " " + input);
        }
      }
      return results;
    }());
    if (inputs.length === 1) {
      return out[0];
    } else {
      return out;
    }
  };
  Articles.exports = {
    find: find,
    articlize: articlize
  };
}.call(commonjsGlobal));

const features = {
  repeat: !!String.prototype.repeat,
  includes: !!String.prototype.includes,
  startsWith: !!String.prototype.startsWith,
  endsWith: !!String.prototype.endsWith
};
function format$1() {
  return formatFromArray(Array.prototype.slice.call(arguments));
}
function formatFromArray(objects) {
  const self = objects.shift();
  if (!self) {
    console.log("Error in Strings>>formatFromArray, first arg is undefined");
  }
  function appendText(object, string) {
    return "" + object;
  }
  function appendInteger(value, string) {
    return value.toString();
  }
  function appendFloat(value, string, precision) {
    if (precision > -1)
      return value.toFixed(precision);
    else
      return value.toString();
  }
  function appendObject(value, string) {
    return inspect(value);
  }
  const appenderMap = {
    s: appendText,
    d: appendInteger,
    i: appendInteger,
    f: appendFloat,
    o: appendObject
  };
  const reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;
  function parseFormat(fmt) {
    const parts = [];
    for (let m = reg.exec(fmt); m; m = reg.exec(fmt)) {
      const type = m[8] || m[5];
      const appender = type in appenderMap ? appenderMap[type] : appendObject;
      const precision = m[3] ? parseInt(m[3]) : m[4] == "." ? -1 : 0;
      parts.push(fmt.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
      parts.push({
        appender: appender,
        precision: precision
      });
      fmt = fmt.substr(m.index + m[0].length);
    }
    if (fmt) {
      parts.push(fmt.toString());
    }
    return parts;
  }
  const parts = parseFormat(self);
  let str = "";
  let objIndex = 0;
  for (let i = 0; i < parts.length; ++i) {
    const part = parts[i];
    if (part && typeof part === "object") {
      const object = objects[objIndex++];
      str += (part.appender || appendText)(object, str, part.precision);
    } else {
      str += appendText(part);
    }
  }
  return str;
}
function indent(str, indentString, depth) {
  if (!depth || depth <= 0)
    return str;
  let indent = "";
  while (depth > 0) {
    depth--;
    indent += indentString;
  }
  return lines(str).map(function (line) {
    return indent + line;
  }).join("\n");
}
function minIndent(str, indentString) {
  if (!indentString)
    indentString = "  ";
  const indentRe = new RegExp("^(" + indentString + ")*", "gm");
  return min(str.match(indentRe).map(ea => Math.floor(ea.length / indentString.length)));
}
function changeIndent(str, indentString, depth) {
  if (!indentString)
    indentString = "  ";
  if (!depth)
    depth = 0;
  const existingIndent = minIndent(str, indentString);
  if (existingIndent === depth)
    return str;
  if (existingIndent < depth)
    return indent(str, indentString, depth - existingIndent);
  const prefixToRemove = indentString.repeat(existingIndent - depth);
  return lines(str).map(function (line) {
    return line.slice(prefixToRemove.length);
  }).join("\n");
}
function quote(str) {
  return "\"" + str.replace(/"/g, "\\\"") + "\"";
}
function articlize(str) {
  return Articles.exports.articlize(str);
}
function findArticle(str) {
  return Articles.exports.find(str);
}
function print(obj) {
  if (obj && Array.isArray(obj))
    return "[" + obj.map(print) + "]";
  if (typeof obj !== "string")
    return String(obj);
  let result = String(obj);
  result = result.replace(/\n/g, "\\n\\\n");
  result = result.replace(/(")/g, "\\$1");
  result = "\"" + result + "\"";
  return result;
}
function printNested(list, depth) {
  depth = depth || 0;
  return list.reduce(function (s, ea) {
    return s += Array.isArray(ea) ? printNested(ea, depth + 1) : indent(ea + "\n", "  ", depth);
  }, "");
}
function pad(string, n, left) {
  return left ? " ".repeat(n) + string : string + " ".repeat(n);
}
function printTable(tableArray, options) {
  const columnWidths = [];
  const separator = options && options.separator || " ";
  const alignLeftAll = !options || !options.align || options.align === "left";
  const alignRightAll = options && options.align === "right";
  function alignRight(columnIndex) {
    if (alignLeftAll)
      return false;
    if (alignRightAll)
      return true;
    return options && Array.isArray(options.align) && options.align[columnIndex] === "right";
  }
  tableArray.forEach(function (row) {
    row.forEach(function (cellVal, i) {
      if (columnWidths[i] === undefined)
        columnWidths[i] = 0;
      columnWidths[i] = Math.max(columnWidths[i], String(cellVal).length);
    });
  });
  return tableArray.map(function (row) {
    return row.map(function (cellVal, i) {
      const cellString = String(cellVal);
      return pad(cellString, columnWidths[i] - cellString.length, alignRight(i));
    }).join(separator);
  }).join("\n");
}
function printTree(rootNode, nodePrinter, childGetter, indent) {
  const nodeList = [];
  indent = indent || "  ";
  iterator(0, 0, rootNode);
  return nodeList.join("\n");
  function iterator(depth, index, node) {
    nodeList[index] = indent.repeat(depth) + nodePrinter(node, depth);
    const children = childGetter(node, depth);
    let childIndex = index + 1;
    if (!children || !children.length)
      return childIndex;
    let lastIndex = childIndex;
    const lastI = children.length - 1;
    children.forEach(function (ea, i) {
      childIndex = iterator(depth + 1, childIndex, ea);
      const isLast = lastI === i;
      const cs = nodeList[lastIndex].split("");
      const fromSlash = depth * indent.length + 1;
      const toSlash = depth * indent.length + indent.length;
      for (var i = fromSlash; i < toSlash; i++)
        cs[i] = "-";
      if (isLast)
        cs[depth * indent.length] = "\\";
      nodeList[lastIndex] = cs.join("");
      if (!isLast) {
        nodeList.slice(lastIndex, childIndex).forEach(function (ea, i) {
          const cs2 = ea.split("");
          cs2[depth * indent.length] = "|";
          nodeList[lastIndex + i] = cs2.join("");
        });
      }
      lastIndex = childIndex;
    });
    return childIndex;
  }
}
function toArray(s) {
  return s.split("");
}
function lines(str) {
  return str.split(/\n\r?/);
}
function paragraphs(string, options) {
  const sep = options ? options.sep : "\n\n";
  if (!options || !options.keepEmptyLines)
    return string.split(new RegExp(sep + "+"));
  function isWhiteSpace(s) {
    return /^\s*$/.test(s);
  }
  return string.split("\n").concat("").reduce(function (parasAndLast, line) {
    const paras = parasAndLast[0];
    let last = parasAndLast[1];
    if (isWhiteSpace(last) === isWhiteSpace(line)) {
      last += "\n" + line;
    } else {
      last.length && paras.push(last);
      last = line;
    }
    return [
      paras,
      last
    ];
  }, [
    [],
    ""
  ])[0];
}
function nonEmptyLines(str) {
  return lines(str).compact();
}
function tokens(str, regex) {
  return str.split(regex || /\s+/).filter(function (tok) {
    return !/^\s*$/.test(tok);
  });
}
function tableize(s, options) {
  options = options || {};
  const splitter = options.cellSplitter || /\s+/;
  const emptyStringRe = /^\s*$/;
  const convertTypes = options.hasOwnProperty("convertTypes") ? !!options.convertTypes : true;
  const _lines = lines(s);
  const table = [];
  for (let i = 0; i < _lines.length; i++) {
    let _tokens = tokens(_lines[i], splitter);
    if (convertTypes) {
      _tokens = _tokens.map(function (tok) {
        if (tok.match(emptyStringRe))
          return tok;
        const num = Number(tok);
        if (!isNaN(num))
          return num;
        const date = new Date(tok);
        if (!isNaN(+date))
          return date;
        return tok.trim();
      });
    }
    if (_tokens.length > 0)
      table.push(_tokens);
  }
  return table;
}
function unescapeCharacterEntities(s) {
  if (typeof document === "undefined")
    throw new Error("Cannot unescapeCharacterEntities");
  const div = document.createElement("div");
  div.innerHTML = s;
  return div.textContent;
}
function toQueryParams(s, separator) {
  const match = s.trim().match(/([^?#]*)(#.*)?$/);
  if (!match)
    return {};
  const hash = match[1].split(separator || "&").inject({}, function (hash, pair) {
    if ((pair = pair.split("="))[0]) {
      const key = decodeURIComponent(pair.shift());
      let value = pair.length > 1 ? pair.join("=") : pair[0];
      if (value != undefined)
        value = decodeURIComponent(value);
      if (key in hash) {
        if (!Array.isArray(hash[key]))
          hash[key] = [hash[key]];
        hash[key].push(value);
      } else
        hash[key] = value;
    }
    return hash;
  });
  return hash;
}
function base64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
    return String.fromCharCode("0x" + p1);
  }));
}
function base64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split("").map(function (c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
const pathDotRe = /\/\.\//g;
const pathDoubleDotRe = /\/[^\/]+\/\.\./;
const pathDoubleSlashRe = /(^|[^:])[\/]+/g;
const urlStartRe = /^[a-z0-9-_\.]+:\/\//;
const slashEndRe = /\/+$/;
function normalizePath(pathString) {
  const urlStartMatch = pathString.match(urlStartRe);
  const urlStart = urlStartMatch ? urlStartMatch[0] : null;
  let result = urlStart ? pathString.slice(urlStart.length) : pathString;
  do {
    pathString = result;
    result = pathString.replace(pathDoubleDotRe, "");
  } while (result != pathString);
  result = result.replace(pathDoubleSlashRe, "$1/");
  result = result.replace(pathDotRe, "/");
  if (urlStart)
    result = urlStart + result;
  return result;
}
function joinPath() {
  return normalizePath(Array.prototype.slice.call(arguments).reduce((path, ea) => typeof ea === "string" ? path.replace(/\/*$/, "") + "/" + ea.replace(/^\/*/, "") : path));
}
function ensureFolder(pathString) {
  return pathString.replace(slashEndRe, "") + "/";
}
const newUUIDTemplate = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
const newUUIDRe = /[xy]/g;
const newUUIDReplacer = c => {
  const r = Math.random() * 16 | 0;
  const v = c == "x" ? r : r & 3 | 8;
  return v.toString(16);
};
function newUUID() {
  return newUUIDTemplate.replace(newUUIDRe, newUUIDReplacer).toUpperCase();
}
function createDataURI(content, mimeType) {
  mimeType = mimeType || "text/plain";
  return "data:" + mimeType + ";base64," + base64EncodeUnicode(content);
}
function hashCode(s) {
  let hash = 0;
  const len = s.length;
  if (len == 0)
    return hash;
  for (let i = 0; i < len; i++) {
    const c = s.charCodeAt(i);
    hash = (hash << 5) - hash + c;
    hash = hash & hash;
  }
  return hash;
}
function md5(string) {
  const add32 = function add32(x, y) {
    const lsw = (x & 65535) + (y & 65535);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  };
  function cmn(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32(a << s | a >>> 32 - s, b);
  }
  function ff(a, b, c, d, x, s, t) {
    return cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function gg(a, b, c, d, x, s, t) {
    return cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  function md5cycle(x, k) {
    let a = x[0];
    let b = x[1];
    let c = x[2];
    let d = x[3];
    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);
    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);
    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);
    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  }
  function md51(s) {
    const n = s.length;
    const state = [
      1732584193,
      -271733879,
      -1732584194,
      271733878
    ];
    let i;
    for (i = 64; i <= n; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    const sl = s.length;
    for (i = 0; i < sl; i++)
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      md5cycle(state, tail);
      i = 16;
      while (i--) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  }
  function md5blk(s) {
    const md5blks = [];
    let i;
    for (i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  const hex_chr = "0123456789abcdef".split("");
  function rhex(n) {
    let s = "";
    let j = 0;
    for (; j < 4; j++)
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    return s;
  }
  function hex(x) {
    const l = x.length;
    for (let i = 0; i < l; i++)
      x[i] = rhex(x[i]);
    return x.join("");
  }
  return hex(md51(string));
}
function reMatches(string, re) {
  const matches = [];
  string.replace(re, function (match, idx) {
    matches.push({
      match: match,
      start: idx,
      end: idx + match.length
    });
  });
  return matches;
}
function stringMatch(s, patternString, options) {
  options = options || {};
  if (options.normalizeWhiteSpace)
    s = s.replace(/\s+/g, " ");
  if (options.ignoreIndent) {
    s = s.replace(/^\s+/gm, "");
    patternString = patternString.replace(/^\s+/gm, "");
  }
  return s == patternString ? { matched: true } : embeddedReMatch(s, patternString);
  function splitInThree(string, start, end, startGap, endGap) {
    startGap = startGap || 0;
    endGap = endGap || 0;
    return [
      string.slice(0, start),
      string.slice(start + startGap, end - endGap),
      string.slice(end)
    ];
  }
  function matchStringForward(s, pattern) {
    if (pattern.constructor !== RegExp) {
      const idx = s.indexOf(pattern);
      if (idx === 0)
        return {
          match: pattern,
          rest: s.slice(pattern.length)
        };
      for (let i = 0; i < pattern.length; i++) {
        if (pattern[i] != s[i]) {
          return {
            match: null,
            pos: i
          };
        }
      }
      return { match: null };
    }
    const matches = reMatches(s, pattern);
    return !matches || !matches.length || matches[0].start !== 0 ? { match: null } : {
      match: matches[0].match,
      rest: s.slice(matches[0].end)
    };
  }
  function matchStringForwardWithAllPatterns(s, patterns) {
    let pos = 0;
    for (let i = 0; i < patterns.length; i++) {
      const p = patterns[i];
      const result = matchStringForward(s, p);
      if (!result.match)
        return {
          matched: false,
          pos: pos + (result.pos || 0),
          pattern: p
        };
      pos += result.match.length;
      s = result.rest;
    }
    return s.length ? {
      matched: false,
      pos: pos
    } : { matched: true };
  }
  function splitIntoPatterns(matcher) {
    const starts = reMatches(matcher, /__\//g);
    const ends = reMatches(matcher, /\/__/g);
    if (starts.length !== ends.length) {
      throw new Error("pattern invalid: " + matcher + " cannot be split into __/.../__ embedded RegExps" + "\nstarts: " + JSON.stringify(starts) + "\nvs ends:\n" + JSON.stringify(ends));
    }
    let consumed = 0;
    return starts.reduce(function (patterns, start, i) {
      const end = ends[i];
      const matcher = patterns.pop();
      const splitted = splitInThree(matcher, start.start - consumed, end.end - consumed, 3, 3);
      if (splitted[0].length) {
        patterns.push(splitted[0]);
        consumed += splitted[0].length;
      }
      try {
        if (splitted[1].length) {
          patterns.push(new RegExp(splitted[1]));
          consumed += splitted[1].length + 3 + 3;
        }
      } catch (e) {
        throw new Error("Cannot create pattern re from: " + inspect(splitted));
      }
      if (splitted[2].length) {
        patterns.push(splitted[2]);
      }
      return patterns;
    }, [matcher]);
  }
  function embeddedReMatch(s, patternString) {
    const patterns = splitIntoPatterns(patternString);
    const result = matchStringForwardWithAllPatterns(s, patterns);
    if (result.matched)
      return result;
    result.error = s.slice(0, result.pos) + "<--UNMATCHED-->" + s.slice(result.pos);
    return result;
  }
}
function peekRight(s, start, needle) {
  s = s.slice(start);
  if (typeof needle === "string") {
    const idx = s.indexOf(needle);
    return idx === -1 ? null : idx + start;
  } else if (needle.constructor === RegExp) {
    const matches = reMatches(s, needle);
    return matches[0] ? matches[0].start : null;
  }
  return null;
}
function peekLeft(s, start, needle) {
  s = s.slice(0, start);
  if (typeof needle === "string") {
    const idx = s.lastIndexOf(needle);
    return idx === -1 ? null : idx;
  } else if (needle.constructor === RegExp) {
    const matches = reMatches(s, needle);
    return last(matches) ? last(matches).start : null;
  }
  return null;
}
function lineIndexComputer(s) {
  const _lineRanges = lineRanges(s);
  return function (pos) {
    for (let line = 0; line < _lineRanges.length; line++) {
      const lineRange = _lineRanges[line];
      if (pos >= lineRange[0] && pos < lineRange[1]) {
        return line;
      }
    }
    return -1;
  };
}
function lineNumberToIndexesComputer(s) {
  return function (lineNo) {
    return lineRanges(s)[lineNo];
  };
}
function lineRanges(s) {
  let from = 0;
  let to = 0;
  const linesOfS = lines(s);
  const result = [];
  for (let i = 0; i < linesOfS.length; i++) {
    const line = linesOfS[i];
    to = from + line.length + 1;
    result.push([
      from,
      to
    ]);
    from = to;
  }
  return result;
}
function findLineWithIndexInLineRanges(lineRanges, idx) {
  const nRows = lineRanges.length;
  if (nRows === 0)
    return -1;
  let startRow = 0;
  let endRow = nRows;
  while (true) {
    const middle = startRow + Math.floor((endRow - startRow) / 2);
    const [from, to] = lineRanges[middle];
    if (idx < from) {
      if (middle === 0)
        return -1;
      endRow = middle;
      continue;
    }
    if (idx > to) {
      startRow = middle;
      continue;
    }
    return middle;
  }
  return -1;
}
function regexIndexOf(string, regex, startpos = 0) {
  const indexOf = this.substring(startpos || 0).search(regex);
  return indexOf >= 0 ? indexOf + (startpos || 0) : indexOf;
}
function regexLastIndexOf(string, regex, startpos = string.length) {
  regex = regex.global ? regex : new RegExp(regex.source, "g" + (regex.ignoreCase ? "i" : "") + (regex.multiLine ? "m" : ""));
  const stringToWorkWith = this.substring(0, startpos + 1);
  let lastIndexOf = -1;
  let nextStop = 0;
  let result;
  while ((result = regex.exec(stringToWorkWith)) != null) {
    lastIndexOf = result.index;
    regex.lastIndex = ++nextStop;
  }
  return lastIndexOf;
}
function diff(s1, s2) {
  if (typeof JsDiff === "undefined")
    return "diff not supported";
  return JsDiff.convertChangesToXML(JsDiff.diffWordsWithSpace(s1, s2));
}
function empty$1(s) {
  return s == "";
}
const includes = features.includes ? function (s, pattern) {
  return s.includes(pattern);
} : function (s, pattern) {
  return s.indexOf(pattern) > -1;
};
const include = includes;
const startsWith = features.startsWith ? function (s, pattern) {
  return s.startsWith(pattern);
} : function (s, pattern) {
  return s.indexOf(pattern) === 0;
};
function startsWithVowel(s) {
  const c = s[0];
  return c === "A" || c === "E" || c === "I" || c === "O" || c === "U" || c === "a" || c === "e" || c === "i" || c === "o" || c === "u" || false;
}
const endsWith = features.endsWith ? function (s, pattern) {
  return s.endsWith(pattern);
} : function (s, pattern) {
  const d = s.length - pattern.length;
  return d >= 0 && s.lastIndexOf(pattern) === d;
};
function withDecimalPrecision(str, precision) {
  const floatValue = parseFloat(str);
  return isNaN(floatValue) ? str : floatValue.toFixed(precision);
}
function capitalize(s) {
  return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}
function camelCaseString(s) {
  return s.split(" ").map(capitalize).join("");
}
function camelize(s) {
  const parts = s.split("-");
  const len = parts.length;
  if (len == 1)
    return parts[0];
  let camelized = s.charAt(0) == "-" ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];
  for (let i = 1; i < len; i++) {
    camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
  }
  return camelized;
}
function decamelize(s) {
  const len = s.length;
  let lastSplitAt = 0;
  const parts = [];
  for (let i = 0; i < len; i++) {
    if (s[i] != " " && s[i] == s[i].toUpperCase()) {
      parts.push(s.slice(lastSplitAt, i).toLowerCase());
      lastSplitAt = i;
    }
  }
  parts.push(s.slice(lastSplitAt).toLowerCase());
  return parts.join(" ");
}
function truncate(s, length, truncation) {
  length = length || 30;
  truncation = truncation === undefined ? "..." : truncation;
  return s.length > length ? s.slice(0, length - truncation.length) + truncation : String(s);
}
function truncateLeft(s, length, truncation) {
  length = length || 30;
  truncation = truncation === undefined ? "..." : truncation;
  return s.length > length ? truncation + s.slice(-length) : String(s);
}
function regExpEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
}
function succ(s) {
  return s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1);
}
function digitValue(s) {
  return s.charCodeAt(0) - "0".charCodeAt(0);
}
const times = features.repeat ? function (s, count) {
  return s.repeat(count);
} : function (s, count) {
  return count < 1 ? "" : new Array(count + 1).join(s);
};
function longestCommonSubstring(a, b) {
  const lcs = [];
  for (let i = 0; i < a.length; i++) {
    lcs[i] = [];
    for (let j = 0; j < b.length; j++) {
      lcs[i][j] = 0;
    }
  }
  for (let i = 0; i < a.length; i++)
    lcs[i][0] = 0;
  for (let i = 1; i < a.length; i++) {
    for (let j = 1; j < b.length; j++) {
      lcs[i][j] = a[i - 1] == b[j - 1] ? lcs[i - 1][j - 1] + 1 : 0;
    }
  }
  let maxLength = -1;
  let indexA = -1;
  let indexB = -1;
  for (let i = 0; i < a.length; i++) {
    for (let j = 0; j < b.length; j++) {
      const length = lcs[i][j];
      if (maxLength < length) {
        maxLength = length;
        indexA = i - length;
        indexB = j - length;
      }
    }
  }
  return {
    length: maxLength,
    indexA,
    indexB,
    string: maxLength > 0 ? a.slice(indexA, indexA + maxLength) : ""
  };
}
function applyChange(string, change) {
  if (change.action === "insert") {
    return string.slice(0, change.start) + change.lines.join("\n") + string.slice(change.start);
  } else if (change.action === "remove") {
    return string.slice(0, change.start) + string.slice(change.end);
  }
  return string;
}
function applyChanges(s, changes) {
  return changes.reduce(function (result, change) {
    return applyChange(result, change);
  }, s);
}
function levenshtein(a, b) {
  if (a.length === 0)
    return b.length;
  if (b.length === 0)
    return a.length;
  let tmp, i, j, prev, val, row;
  if (a.length > b.length) {
    tmp = a;
    a = b;
    b = tmp;
  }
  row = Array(a.length + 1);
  for (i = 0; i <= a.length; i++)
    row[i] = i;
  for (i = 1; i <= b.length; i++) {
    prev = i;
    for (j = 1; j <= a.length; j++) {
      if (b[i - 1] === a[j - 1]) {
        val = row[j - 1];
      } else {
        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));
      }
      row[j - 1] = prev;
      prev = val;
    }
    row[a.length] = prev;
  }
  return row[a.length];
}

var string = /*#__PURE__*/Object.freeze({
  __proto__: null,
  format: format$1,
  formatFromArray: formatFromArray,
  indent: indent,
  minIndent: minIndent,
  changeIndent: changeIndent,
  quote: quote,
  articlize: articlize,
  findArticle: findArticle,
  print: print,
  printNested: printNested,
  pad: pad,
  printTable: printTable,
  printTree: printTree,
  toArray: toArray,
  lines: lines,
  paragraphs: paragraphs,
  nonEmptyLines: nonEmptyLines,
  tokens: tokens,
  tableize: tableize,
  unescapeCharacterEntities: unescapeCharacterEntities,
  base64EncodeUnicode: base64EncodeUnicode,
  base64DecodeUnicode: base64DecodeUnicode,
  toQueryParams: toQueryParams,
  normalizePath: normalizePath,
  joinPath: joinPath,
  newUUID: newUUID,
  createDataURI: createDataURI,
  hashCode: hashCode,
  md5: md5,
  reMatches: reMatches,
  stringMatch: stringMatch,
  peekRight: peekRight,
  peekLeft: peekLeft,
  lineIndexComputer: lineIndexComputer,
  lineNumberToIndexesComputer: lineNumberToIndexesComputer,
  findLineWithIndexInLineRanges: findLineWithIndexInLineRanges,
  regexIndexOf: regexIndexOf,
  regexLastIndexOf: regexLastIndexOf,
  lineRanges: lineRanges,
  diff: diff,
  empty: empty$1,
  includes: includes,
  include: include,
  startsWith: startsWith,
  startsWithVowel: startsWithVowel,
  endsWith: endsWith,
  withDecimalPrecision: withDecimalPrecision,
  capitalize: capitalize,
  camelCaseString: camelCaseString,
  camelize: camelize,
  truncate: truncate,
  truncateLeft: truncateLeft,
  regExpEscape: regExpEscape,
  succ: succ,
  digitValue: digitValue,
  times: times,
  longestCommonSubstring: longestCommonSubstring,
  applyChange: applyChange,
  applyChanges: applyChanges,
  levenshtein: levenshtein,
  decamelize: decamelize,
  ensureFolder: ensureFolder
});

function random(min, max) {
  min = min || 0;
  max = max || 100;
  return Math.round(Math.random() * (max - min) + min);
}
function normalRandom(mean, stdDev) {
  let spare;
  let isSpareReady = false;
  return function (mean, stdDev) {
    if (isSpareReady) {
      isSpareReady = false;
      return spare * stdDev + mean;
    } else {
      let u, v, s;
      do {
        u = Math.random() * 2 - 1;
        v = Math.random() * 2 - 1;
        s = u * u + v * v;
      } while (s >= 1 || s === 0);
      const mul = Math.sqrt(-2 * Math.log(s) / s);
      spare = v * mul;
      isSpareReady = true;
      return mean + stdDev * u * mul;
    }
  };
}
function randomSmallerInteger(n) {
  return Math.floor(Math.random() * n);
}
function humanReadableByteSize(n) {
  function round(n) {
    return Math.round(n * 100) / 100;
  }
  if (n < 1000)
    return String(round(n)) + "B";
  n = n / 1024;
  if (n < 1000)
    return String(round(n)) + "KB";
  n = n / 1024;
  return String(round(n)) + "MB";
}
function average(numbers) {
  return numbers.reduce(function (sum, n) {
    return sum + n;
  }, 0) / numbers.length;
}
function averageInc(newVal, oldAvg, n) {
  return (newVal - oldAvg) / n + oldAvg;
}
function median(numbers) {
  const sorted = numbers.sort(function (a, b) {
    return b - a;
  });
  const len = numbers.length;
  return len % 2 === 0 ? 0.5 * (sorted[len / 2 - 1] + sorted[len / 2]) : sorted[(len - 1) / 2];
}
function between(x, a, b, eps) {
  eps = eps || 0;
  let min, max;
  if (a < b) {
    min = a, max = b;
  } else {
    max = a, min = b;
  }
  return max - x + eps >= 0 && min - x - eps <= 0;
}
function clamp(x, lower, upper) {
  return Math.max(lower, Math.min(upper, x));
}
function sort(arr) {
  return arr.sort(function (a, b) {
    return a - b;
  });
}
function parseLength(string, toUnit) {
  toUnit = toUnit || "px";
  const match = string.match(/([0-9\.]+)\s*(.*)/);
  if (!match || !match[1])
    return undefined;
  const length = parseFloat(match[1]);
  const fromUnit = match[2];
  return convertLength(length, fromUnit, toUnit);
}
const convertLength = (function () {
  function toCm(n, unit) {
    if (unit === "cm")
      return n;
    else if (unit === "mm")
      return n * 0.1;
    else if (unit === "in")
      return n * 2.54;
    else if (unit === "px")
      return n * toCm(1 / 96, "in");
    else if (unit === "pt")
      return n * toCm(1 / 72, "in");
    else if (unit === "pc")
      return n * toCm(12, "pt");
  }
  return function to(length, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return length;
    else if (toUnit === "cm")
      return toCm(length, fromUnit);
    else if (fromUnit === "cm")
      return length / toCm(1, toUnit);
    else
      return to(to(length, fromUnit, "cm"), "cm", toUnit);
  };
}());
function precision(f) {
  if (!isFinite(f))
    return 0;
  let e = 1;
  let p = 0;
  while (Math.round(f * e) / e !== f) {
    e *= 10;
    p++;
  }
  return p;
}
function roundTo(n, quantum) {
  quantum = 1 / quantum;
  return Math.round(n * quantum) / quantum;
}
function detent(n, detent, grid, snap) {
  const r1 = roundTo(n, grid);
  if (Math.abs(n - r1) < detent / 2)
    return r1;
  if (snap)
    return n;
  const r2 = n < r1 ? r1 - detent / 2 : r1 + detent / 2;
  return r1 + (n - r2) * grid / (grid - detent);
}
function toDegrees(n) {
  return n * 180 / Math.PI % 360;
}
function toRadians(n) {
  return n / 180 * Math.PI;
}
function backoff(attempt, base = 5, cap = 30000) {
  const temp = Math.min(cap, base * Math.pow(2, attempt));
  const sleep = temp / 2 + Math.round(Math.random() * (temp / 2));
  return Math.min(cap, base + Math.random() * (sleep * 3 - base));
}
function interpolate(i, a, b) {
  return a + i * (b - a);
}

var num = /*#__PURE__*/Object.freeze({
  __proto__: null,
  random: random,
  normalRandom: normalRandom,
  randomSmallerInteger: randomSmallerInteger,
  humanReadableByteSize: humanReadableByteSize,
  average: average,
  averageInc: averageInc,
  median: median,
  between: between,
  sort: sort,
  parseLength: parseLength,
  convertLength: convertLength,
  roundTo: roundTo,
  detent: detent,
  toDegrees: toDegrees,
  toRadians: toRadians,
  backoff: backoff,
  interpolate: interpolate,
  clamp: clamp,
  precision: precision
});

const dateFormat = function setupDateFormat() {
  var dateFormat = (function () {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
    const timezoneClip = /[^-+\dA-Z]/g;
    const pad = function (val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len)
        val = "0" + val;
      return val;
    };
    return function (date, mask, utc) {
      const dF = dateFormat;
      if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
        mask = date;
        date = undefined;
      }
      date = date ? new Date(date) : new Date();
      if (isNaN(date))
        throw SyntaxError("invalid date");
      mask = String(dF.masks[mask] || mask || dF.masks.default);
      if (mask.slice(0, 4) == "UTC:") {
        mask = mask.slice(4);
        utc = true;
      }
      const _ = utc ? "getUTC" : "get";
      const d = date[_ + "Date"]();
      const D = date[_ + "Day"]();
      const m = date[_ + "Month"]();
      const y = date[_ + "FullYear"]();
      const H = date[_ + "Hours"]();
      const M = date[_ + "Minutes"]();
      const s = date[_ + "Seconds"]();
      const L = date[_ + "Milliseconds"]();
      const o = utc ? 0 : date.getTimezoneOffset();
      const flags = {
        d: d,
        dd: pad(d),
        ddd: dF.i18n.dayNames[D],
        dddd: dF.i18n.dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: dF.i18n.monthNames[m],
        mmmm: dF.i18n.monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: [
          "th",
          "st",
          "nd",
          "rd"
        ][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
      };
      return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
      });
    };
  }());
  dateFormat.masks = {
    default: "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
  };
  dateFormat.i18n = {
    dayNames: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    monthNames: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  return dateFormat;
}();
function format(date, mask, utc) {
  return dateFormat(date, mask, utc);
}
function equals(date, otherDate) {
  return otherDate && otherDate instanceof Date && otherDate.getTime() === date.getTime();
}
function relativeTo(date, otherDate, opts = {}) {
  if (!(otherDate instanceof Date))
    return "";
  if (otherDate < date)
    return "";
  if (otherDate === date)
    return "now";
  let minuteString = "min";
  let secondString = "sec";
  let hourString = "hour";
  let dayString = "day";
  const diff = otherDate - date;
  const totalSecs = Math.round(diff / 1000);
  const secs = totalSecs % 60;
  const mins = Math.floor(totalSecs / 60) % 60;
  const hours = Math.floor(totalSecs / 60 / 60) % 24;
  const days = Math.floor(totalSecs / 60 / 60 / 24);
  const parts = [];
  if (days > 0) {
    parts.push(days);
    if (days > 1)
      dayString += "s";
    parts.push(dayString);
  }
  if (opts.forceHours || hours > 0 && days < 2) {
    parts.push(hours);
    if (hours > 1)
      hourString += "s";
    parts.push(hourString);
  }
  if (opts.forceMinutes || mins > 0 && hours < 3 && days === 0) {
    parts.push(mins);
    if (mins > 1)
      minuteString += "s";
    parts.push(minuteString);
  }
  if (opts.forceSeconds || secs > 0 && mins < 3 && hours === 0 && days === 0) {
    parts.push(secs);
    if (secs > 1)
      secondString += "s";
    parts.push(secondString);
  }
  return parts.join(" ");
}

var date = /*#__PURE__*/Object.freeze({
  __proto__: null,
  format: format,
  equals: equals,
  relativeTo: relativeTo,
  dateFormat: dateFormat
});

function promise(obj) {
  return typeof obj === "function" ? promise.convertCallbackFun(obj) : Promise.resolve(obj);
}
function delay(ms, resolveVal) {
  return new Promise(resolve => setTimeout(resolve, ms, resolveVal));
}
function delayReject(ms, rejectVal) {
  return new Promise((_, reject) => setTimeout(reject, ms, rejectVal));
}
function timeout(ms, promise) {
  return new Promise((resolve, reject) => {
    let done = false;
    setTimeout(() => !done && (done = true) && reject(new Error("Promise timed out")), ms);
    promise.then(val => !done && (done = true) && resolve(val), err => !done && (done = true) && reject(err));
  });
}
const waitForClosures = {};
function waitFor(ms, tester, timeoutObj) {
  if (typeof ms === "function") {
    tester = ms;
    ms = undefined;
  }
  let value;
  if (value = tester())
    return Promise.resolve(value);
  return new Promise((resolve, reject) => {
    let stopped = false;
    let timedout = false;
    let error;
    let value;
    const stopWaiting = i => {
      clearInterval(i);
      delete waitForClosures[i];
    };
    const i = setInterval(() => {
      if (stopped)
        return stopWaiting(i);
      try {
        value = tester();
      } catch (e) {
        error = e;
      }
      if (!value && !error && !timedout)
        return;
      stopped = true;
      stopWaiting(i);
      if (error)
        return reject(error);
      if (timedout) {
        return typeof timeoutObj === "undefined" ? reject(new Error("timeout")) : resolve(timeoutObj);
      }
      return resolve(value);
    }, 10);
    waitForClosures[i] = i;
    if (typeof ms === "number")
      setTimeout(() => timedout = true, ms);
  });
}
function deferred() {
  let resolve;
  let reject;
  const promise = new Promise(function (_resolve, _reject) {
    resolve = _resolve;
    reject = _reject;
  });
  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  };
}
function convertCallbackFun(func) {
  return function promiseGenerator() {
    const args = Array.from(arguments);
    const self = this;
    return new Promise(function (resolve, reject) {
      args.push(function (err, result) {
        return err ? reject(err) : resolve(result);
      });
      func.apply(self, args);
    });
  };
}
function convertCallbackFunWithManyArgs(func) {
  return function promiseGenerator() {
    const args = Array.from(arguments);
    const self = this;
    return new Promise(function (resolve, reject) {
      args.push(function () {
        const args = Array.from(arguments);
        const err = args.shift();
        return err ? reject(err) : resolve(args);
      });
      func.apply(self, args);
    });
  };
}
function _chainResolveNext(promiseFuncs, prevResult, akku, resolve, reject) {
  const next = promiseFuncs.shift();
  if (!next)
    resolve(prevResult);
  else {
    try {
      Promise.resolve(next(prevResult, akku)).then(result => _chainResolveNext(promiseFuncs, result, akku, resolve, reject)).catch(function (err) {
        reject(err);
      });
    } catch (err) {
      reject(err);
    }
  }
}
function chain$1(promiseFuncs) {
  return new Promise((resolve, reject) => _chainResolveNext(promiseFuncs.slice(), undefined, {}, resolve, reject));
}
function promise_finally(promise, finallyFn) {
  return Promise.resolve(promise).then(result => {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }
    return result;
  }).catch(err => {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }
    throw err;
  });
}
function parallel(promiseGenFns, parallelLimit = Infinity) {
  if (!promiseGenFns.length)
    return Promise.resolve([]);
  const results = [];
  let error = null;
  let index = 0;
  let left = promiseGenFns.length;
  let resolve;
  let reject;
  return new Promise((res, rej) => {
    resolve = () => res(results);
    reject = err => rej(error = err);
    spawnMore();
  });
  function spawn() {
    parallelLimit--;
    try {
      const i = index++;
      const prom = promiseGenFns[i]();
      prom.then(result => {
        parallelLimit++;
        results[i] = result;
        if (--left === 0)
          resolve();
        else
          spawnMore();
      }).catch(err => reject(err));
    } catch (err) {
      reject(err);
    }
  }
  function spawnMore() {
    while (!error && left > 0 && index < promiseGenFns.length && parallelLimit > 0) {
      spawn();
    }
  }
}
Object.assign(promise, {
  delay,
  delayReject,
  timeout,
  waitFor,
  deferred,
  convertCallbackFun,
  convertCallbackFunWithManyArgs,
  chain: chain$1,
  finally: promise_finally,
  parallel
});

function Path(p, splitter) {
  if (p instanceof Path)
    return p;
  if (!(this instanceof Path))
    return new Path(p, splitter);
  this.setSplitter(splitter || ".");
  this.fromPath(p);
}
Object.assign(Path.prototype, {
  get isPathAccessor() {
    return true;
  },
  fromPath(path) {
    if (typeof path === "string" && path !== "" && path !== this.splitter) {
      this._parts = path.split(this.splitter);
      this._path = path;
    } else if (Array.isArray(path)) {
      this._parts = [].concat(path);
      this._path = path.join(this.splitter);
    } else {
      this._parts = [];
      this._path = "";
    }
    return this;
  },
  setSplitter(splitter) {
    if (splitter)
      this.splitter = splitter;
    return this;
  },
  map(fn) {
    this._mapper = fn;
    return this;
  },
  parts() {
    return this._parts;
  },
  size() {
    return this._parts.length;
  },
  slice(n, m) {
    return Path(this.parts().slice(n, m));
  },
  normalizePath() {
    return this._path;
  },
  isRoot(obj) {
    return this._parts.length === 0;
  },
  isIn(obj) {
    if (this.isRoot())
      return true;
    const parent = this.get(obj, -1);
    return parent && parent.hasOwnProperty(this._parts[this._parts.length - 1]);
  },
  equals(obj) {
    return obj && obj.isPathAccessor && this.parts().equals(obj.parts());
  },
  isParentPathOf(otherPath) {
    otherPath = otherPath && otherPath.isPathAccessor ? otherPath : Path(otherPath);
    const parts = this.parts();
    const otherParts = otherPath.parts();
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] != otherParts[i])
        return false;
    }
    return true;
  },
  relativePathTo(otherPath) {
    otherPath = Path(otherPath);
    return this.isParentPathOf(otherPath) ? otherPath.slice(this.size(), otherPath.size()) : undefined;
  },
  del(obj) {
    if (this.isRoot())
      return false;
    let parent = obj;
    for (let i = 0; i < this._parts.length - 1; i++) {
      const part = this._parts[i];
      if (parent.hasOwnProperty(part)) {
        parent = parent[part];
      } else
        return false;
    }
    return delete parent[this._parts[this._parts.length - 1]];
  },
  withParentAndKeyDo(obj, ensure, doFunc) {
    if (this.isRoot())
      return doFunc(null, null);
    let parent = obj;
    for (let i = 0; i < this._parts.length - 1; i++) {
      const part = this._parts[i];
      if (parent.hasOwnProperty(part) && (typeof parent[part] === "object" || typeof parent[part] === "function")) {
        parent = parent[part];
      } else if (ensure) {
        parent = parent[part] = {};
      } else {
        return doFunc(null, part);
      }
    }
    return doFunc(parent, this._parts[this._parts.length - 1]);
  },
  set(obj, val, ensure) {
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? parent[key] = val : undefined;
    });
  },
  defineProperty(obj, propertySpec, ensure) {
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? Object.defineProperty(parent, key, propertySpec) : undefined;
    });
  },
  get(obj, n) {
    const parts = n ? this._parts.slice(0, n) : this._parts;
    const self = this;
    return parts.reduce(function (current, pathPart) {
      return current ? self._mapper ? self._mapper(pathPart, current[pathPart]) : current[pathPart] : current;
    }, obj);
  },
  concat(p, splitter) {
    return Path(this.parts().concat(Path(p, splitter).parts()));
  },
  toString() {
    return this.normalizePath();
  },
  serializeExpr() {
    return "lively.lang.Path(" + inspect(this.parts()) + ")";
  },
  watch(options) {
    if (!options || this.isRoot())
      return;
    const target = options.target;
    const parent = this.get(target, -1);
    const propName = this.parts().slice(-1)[0];
    const newPropName = "propertyWatcher$" + propName;
    const watcherIsInstalled = parent && parent.hasOwnProperty(newPropName);
    const uninstall = options.uninstall;
    const haltWhenChanged = options.haltWhenChanged;
    const showStack = options.showStack;
    const getter = parent.__lookupGetter__(propName);
    const setter = parent.__lookupSetter__(propName);
    if (!target || !propName || !parent)
      return;
    if (uninstall) {
      if (!watcherIsInstalled)
        return;
      delete parent[propName];
      parent[propName] = parent[newPropName];
      delete parent[newPropName];
      var msg = "Watcher for " + parent + "." + propName + " uninstalled";
      return;
    }
    if (watcherIsInstalled) {
      var msg = "Watcher for " + parent + "." + propName + " already installed";
      return;
    }
    if (getter || setter) {
      var msg = parent + "[\"" + propName + "\"] is a getter/setter, watching not support";
      console.log(msg);
      return;
    }
    parent[newPropName] = parent[propName];
    parent.__defineSetter__(propName, function (v) {
      const oldValue = parent[newPropName];
      if (options.onSet)
        options.onSet(v, oldValue);
      let msg = parent + "." + propName + " changed: " + oldValue + " -> " + v;
      if (showStack) {
        msg += "\n" + (typeof lively !== "undefined" ? lively.printStack() : console.trace());
      }
      if (options.verbose) {
        console.log(msg);
      }
      if (haltWhenChanged)
        debugger;
      return parent[newPropName] = v;
    });
    parent.__defineGetter__(propName, function () {
      if (options.onGet)
        options.onGet(parent[newPropName]);
      return parent[newPropName];
    });
    var msg = "Watcher for " + parent + "." + propName + " installed";
    console.log(msg);
  },
  debugFunctionWrapper(options) {
    const target = options.target;
    const parent = this.get(target, -1);
    const funcName = this.parts().slice(-1)[0];
    const uninstall = options.uninstall;
    const haltWhenChanged = options.haltWhenChanged === undefined ? true : options.haltWhenChanged;
    options.showStack;
    const func = parent && funcName && parent[funcName];
    const debuggerInstalled = func && func.isDebugFunctionWrapper;
    if (!target || !funcName || !func || !parent)
      return;
    if (uninstall) {
      if (!debuggerInstalled)
        return;
      parent[funcName] = parent[funcName].debugTargetFunction;
      var msg = "Uninstalled debugFunctionWrapper for " + parent + "." + funcName;
      console.log(msg);
      return;
    }
    if (debuggerInstalled) {
      var msg = "debugFunctionWrapper for " + parent + "." + funcName + " already installed";
      console.log(msg);
      return;
    }
    const debugFunc = parent[funcName] = func.wrap(function (proceed) {
      const args = Array.from(arguments);
      if (haltWhenChanged)
        debugger;
      return args.shift().apply(parent, args);
    });
    debugFunc.isDebugFunctionWrapper = true;
    debugFunc.debugTargetFunction = func;
    var msg = "debugFunctionWrapper for " + parent + "." + funcName + " installed";
    console.log(msg);
  }
});

typeof System !== "undefined" ? System.global : typeof window !== "undefined" ? window : global;

function filter(treeNode, testFunc, childGetter) {
  let result = [];
  if (testFunc(treeNode))
    result.push(treeNode);
  return result.concat((childGetter(treeNode) || []).map(function (n) {
    return filter(n, testFunc, childGetter);
  }).flat());
}

typeof process !== "undefined" && process.versions && process.versions.node;

var lib$7 = {exports: {}};

var es6_object_create = {};

var _global = {exports: {}};

var hasRequired_global;
function require_global() {
  if (hasRequired_global)
    return _global.exports;
  hasRequired_global = 1;
  var global = _global.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
  if (typeof __g == "number")
    __g = global;
  return _global.exports;
}

var _core = {exports: {}};

var hasRequired_core;
function require_core() {
  if (hasRequired_core)
    return _core.exports;
  hasRequired_core = 1;
  var core = _core.exports = { version: "2.4.0" };
  if (typeof __e == "number")
    __e = core;
  return _core.exports;
}

var _aFunction;
var hasRequired_aFunction;
function require_aFunction() {
  if (hasRequired_aFunction)
    return _aFunction;
  hasRequired_aFunction = 1;
  _aFunction = function (it) {
    if (typeof it != "function")
      throw TypeError(it + " is not a function!");
    return it;
  };
  return _aFunction;
}

var _ctx;
var hasRequired_ctx;
function require_ctx() {
  if (hasRequired_ctx)
    return _ctx;
  hasRequired_ctx = 1;
  var aFunction = require_aFunction();
  _ctx = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
  return _ctx;
}

var _objectDp = {};

var _isObject;
var hasRequired_isObject;
function require_isObject() {
  if (hasRequired_isObject)
    return _isObject;
  hasRequired_isObject = 1;
  _isObject = function (it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  return _isObject;
}

var _anObject;
var hasRequired_anObject;
function require_anObject() {
  if (hasRequired_anObject)
    return _anObject;
  hasRequired_anObject = 1;
  var isObject = require_isObject();
  _anObject = function (it) {
    if (!isObject(it))
      throw TypeError(it + " is not an object!");
    return it;
  };
  return _anObject;
}

var _fails;
var hasRequired_fails;
function require_fails() {
  if (hasRequired_fails)
    return _fails;
  hasRequired_fails = 1;
  _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return _fails;
}

var _descriptors;
var hasRequired_descriptors;
function require_descriptors() {
  if (hasRequired_descriptors)
    return _descriptors;
  hasRequired_descriptors = 1;
  _descriptors = !require_fails()(function () {
    return Object.defineProperty({}, "a", {
      get: function () {
        return 7;
      }
    }).a != 7;
  });
  return _descriptors;
}

var _domCreate;
var hasRequired_domCreate;
function require_domCreate() {
  if (hasRequired_domCreate)
    return _domCreate;
  hasRequired_domCreate = 1;
  var isObject = require_isObject(), document = require_global().document, is = isObject(document) && isObject(document.createElement);
  _domCreate = function (it) {
    return is ? document.createElement(it) : {};
  };
  return _domCreate;
}

var _ie8DomDefine;
var hasRequired_ie8DomDefine;
function require_ie8DomDefine() {
  if (hasRequired_ie8DomDefine)
    return _ie8DomDefine;
  hasRequired_ie8DomDefine = 1;
  _ie8DomDefine = !require_descriptors() && !require_fails()(function () {
    return Object.defineProperty(require_domCreate()("div"), "a", {
      get: function () {
        return 7;
      }
    }).a != 7;
  });
  return _ie8DomDefine;
}

var _toPrimitive;
var hasRequired_toPrimitive;
function require_toPrimitive() {
  if (hasRequired_toPrimitive)
    return _toPrimitive;
  hasRequired_toPrimitive = 1;
  var isObject = require_isObject();
  _toPrimitive = function (it, S) {
    if (!isObject(it))
      return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
      return val;
    if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
      return val;
    if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
      return val;
    throw TypeError("Can't convert object to primitive value");
  };
  return _toPrimitive;
}

var hasRequired_objectDp;
function require_objectDp() {
  if (hasRequired_objectDp)
    return _objectDp;
  hasRequired_objectDp = 1;
  var anObject = require_anObject(), IE8_DOM_DEFINE = require_ie8DomDefine(), toPrimitive = require_toPrimitive(), dP = Object.defineProperty;
  _objectDp.f = require_descriptors() ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE)
      try {
        return dP(O, P, Attributes);
      } catch (e) {
      }
    if ("get" in Attributes || "set" in Attributes)
      throw TypeError("Accessors not supported!");
    if ("value" in Attributes)
      O[P] = Attributes.value;
    return O;
  };
  return _objectDp;
}

var _propertyDesc;
var hasRequired_propertyDesc;
function require_propertyDesc() {
  if (hasRequired_propertyDesc)
    return _propertyDesc;
  hasRequired_propertyDesc = 1;
  _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return _propertyDesc;
}

var _hide;
var hasRequired_hide;
function require_hide() {
  if (hasRequired_hide)
    return _hide;
  hasRequired_hide = 1;
  var dP = require_objectDp(), createDesc = require_propertyDesc();
  _hide = require_descriptors() ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
  return _hide;
}

var _export;
var hasRequired_export;
function require_export() {
  if (hasRequired_export)
    return _export;
  hasRequired_export = 1;
  var global = require_global(), core = require_core(), ctx = require_ctx(), hide = require_hide(), PROTOTYPE = "prototype";
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE], key, own, out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
            }
            return new C(a, b, c);
          }
          return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key])
          hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  _export = $export;
  return _export;
}

var _has;
var hasRequired_has;
function require_has() {
  if (hasRequired_has)
    return _has;
  hasRequired_has = 1;
  var hasOwnProperty = {}.hasOwnProperty;
  _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
  return _has;
}

var _cof;
var hasRequired_cof;
function require_cof() {
  if (hasRequired_cof)
    return _cof;
  hasRequired_cof = 1;
  var toString = {}.toString;
  _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };
  return _cof;
}

var _iobject;
var hasRequired_iobject;
function require_iobject() {
  if (hasRequired_iobject)
    return _iobject;
  hasRequired_iobject = 1;
  var cof = require_cof();
  _iobject = Object("z").propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == "String" ? it.split("") : Object(it);
  };
  return _iobject;
}

var _defined;
var hasRequired_defined;
function require_defined() {
  if (hasRequired_defined)
    return _defined;
  hasRequired_defined = 1;
  _defined = function (it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return _defined;
}

var _toIobject;
var hasRequired_toIobject;
function require_toIobject() {
  if (hasRequired_toIobject)
    return _toIobject;
  hasRequired_toIobject = 1;
  var IObject = require_iobject(), defined = require_defined();
  _toIobject = function (it) {
    return IObject(defined(it));
  };
  return _toIobject;
}

var _toInteger;
var hasRequired_toInteger;
function require_toInteger() {
  if (hasRequired_toInteger)
    return _toInteger;
  hasRequired_toInteger = 1;
  var ceil = Math.ceil, floor = Math.floor;
  _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return _toInteger;
}

var _toLength;
var hasRequired_toLength;
function require_toLength() {
  if (hasRequired_toLength)
    return _toLength;
  hasRequired_toLength = 1;
  var toInteger = require_toInteger(), min = Math.min;
  _toLength = function (it) {
    return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
  };
  return _toLength;
}

var _toIndex;
var hasRequired_toIndex;
function require_toIndex() {
  if (hasRequired_toIndex)
    return _toIndex;
  hasRequired_toIndex = 1;
  var toInteger = require_toInteger(), max = Math.max, min = Math.min;
  _toIndex = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  return _toIndex;
}

var _arrayIncludes$1;
var hasRequired_arrayIncludes$1;
function require_arrayIncludes$1() {
  if (hasRequired_arrayIncludes$1)
    return _arrayIncludes$1;
  hasRequired_arrayIncludes$1 = 1;
  var toIObject = require_toIobject(), toLength = require_toLength(), toIndex = require_toIndex();
  _arrayIncludes$1 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this), length = toLength(O.length), index = toIndex(fromIndex, length), value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) {
            if (O[index] === el)
              return IS_INCLUDES || index || 0;
          }
      return !IS_INCLUDES && -1;
    };
  };
  return _arrayIncludes$1;
}

var _shared;
var hasRequired_shared;
function require_shared() {
  if (hasRequired_shared)
    return _shared;
  hasRequired_shared = 1;
  var global = require_global(), SHARED = "__core-js_shared__", store = global[SHARED] || (global[SHARED] = {});
  _shared = function (key) {
    return store[key] || (store[key] = {});
  };
  return _shared;
}

var _uid;
var hasRequired_uid;
function require_uid() {
  if (hasRequired_uid)
    return _uid;
  hasRequired_uid = 1;
  var id = 0, px = Math.random();
  _uid = function (key) {
    return "Symbol(".concat(key === undefined ? "" : key, ")_", (++id + px).toString(36));
  };
  return _uid;
}

var _sharedKey;
var hasRequired_sharedKey;
function require_sharedKey() {
  if (hasRequired_sharedKey)
    return _sharedKey;
  hasRequired_sharedKey = 1;
  var shared = require_shared()("keys"), uid = require_uid();
  _sharedKey = function (key) {
    return shared[key] || (shared[key] = uid(key));
  };
  return _sharedKey;
}

var _objectKeysInternal;
var hasRequired_objectKeysInternal;
function require_objectKeysInternal() {
  if (hasRequired_objectKeysInternal)
    return _objectKeysInternal;
  hasRequired_objectKeysInternal = 1;
  var has = require_has(), toIObject = require_toIobject(), arrayIndexOf = require_arrayIncludes$1()(false), IE_PROTO = require_sharedKey()("IE_PROTO");
  _objectKeysInternal = function (object, names) {
    var O = toIObject(object), i = 0, result = [], key;
    for (key in O)
      if (key != IE_PROTO)
        has(O, key) && result.push(key);
    while (names.length > i)
      if (has(O, key = names[i++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
    return result;
  };
  return _objectKeysInternal;
}

var _enumBugKeys;
var hasRequired_enumBugKeys;
function require_enumBugKeys() {
  if (hasRequired_enumBugKeys)
    return _enumBugKeys;
  hasRequired_enumBugKeys = 1;
  _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  return _enumBugKeys;
}

var _objectKeys;
var hasRequired_objectKeys;
function require_objectKeys() {
  if (hasRequired_objectKeys)
    return _objectKeys;
  hasRequired_objectKeys = 1;
  var $keys = require_objectKeysInternal(), enumBugKeys = require_enumBugKeys();
  _objectKeys = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
  };
  return _objectKeys;
}

var _objectDps;
var hasRequired_objectDps;
function require_objectDps() {
  if (hasRequired_objectDps)
    return _objectDps;
  hasRequired_objectDps = 1;
  var dP = require_objectDp(), anObject = require_anObject(), getKeys = require_objectKeys();
  _objectDps = require_descriptors() ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties), length = keys.length, i = 0, P;
    while (length > i)
      dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  return _objectDps;
}

var _html;
var hasRequired_html;
function require_html() {
  if (hasRequired_html)
    return _html;
  hasRequired_html = 1;
  _html = require_global().document && document.documentElement;
  return _html;
}

var _objectCreate;
var hasRequired_objectCreate;
function require_objectCreate() {
  if (hasRequired_objectCreate)
    return _objectCreate;
  hasRequired_objectCreate = 1;
  var anObject = require_anObject(), dPs = require_objectDps(), enumBugKeys = require_enumBugKeys(), IE_PROTO = require_sharedKey()("IE_PROTO"), Empty = function () {
    }, PROTOTYPE = "prototype";
  var createDict = function () {
    var iframe = require_domCreate()("iframe"), i = enumBugKeys.length, gt = ">", iframeDocument;
    iframe.style.display = "none";
    require_html().appendChild(iframe);
    iframe.src = "javascript:";
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write("<script>document.F=Object</script" + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--)
      delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };
  _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else
      result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };
  return _objectCreate;
}

var hasRequiredEs6_object_create;
function requireEs6_object_create() {
  if (hasRequiredEs6_object_create)
    return es6_object_create;
  hasRequiredEs6_object_create = 1;
  var $export = require_export();
  $export($export.S, "Object", { create: require_objectCreate() });
  return es6_object_create;
}

var create$1;
var hasRequiredCreate$1;
function requireCreate$1() {
  if (hasRequiredCreate$1)
    return create$1;
  hasRequiredCreate$1 = 1;
  requireEs6_object_create();
  var $Object = require_core().Object;
  create$1 = function create(P, D) {
    return $Object.create(P, D);
  };
  return create$1;
}

var create;
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate)
    return create;
  hasRequiredCreate = 1;
  create = {
    "default": requireCreate$1(),
    __esModule: true
  };
  return create;
}

var web_dom_iterable = {};

var _addToUnscopables;
var hasRequired_addToUnscopables;
function require_addToUnscopables() {
  if (hasRequired_addToUnscopables)
    return _addToUnscopables;
  hasRequired_addToUnscopables = 1;
  _addToUnscopables = function () {
  };
  return _addToUnscopables;
}

var _iterStep;
var hasRequired_iterStep;
function require_iterStep() {
  if (hasRequired_iterStep)
    return _iterStep;
  hasRequired_iterStep = 1;
  _iterStep = function (done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  return _iterStep;
}

var _iterators;
var hasRequired_iterators;
function require_iterators() {
  if (hasRequired_iterators)
    return _iterators;
  hasRequired_iterators = 1;
  _iterators = {};
  return _iterators;
}

var _library;
var hasRequired_library;
function require_library() {
  if (hasRequired_library)
    return _library;
  hasRequired_library = 1;
  _library = true;
  return _library;
}

var _redefine;
var hasRequired_redefine;
function require_redefine() {
  if (hasRequired_redefine)
    return _redefine;
  hasRequired_redefine = 1;
  _redefine = require_hide();
  return _redefine;
}

var _wks = {exports: {}};

var hasRequired_wks;
function require_wks() {
  if (hasRequired_wks)
    return _wks.exports;
  hasRequired_wks = 1;
  var store = require_shared()("wks"), uid = require_uid(), Symbol = require_global().Symbol, USE_SYMBOL = typeof Symbol == "function";
  var $exports = _wks.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name));
  };
  $exports.store = store;
  return _wks.exports;
}

var _setToStringTag;
var hasRequired_setToStringTag;
function require_setToStringTag() {
  if (hasRequired_setToStringTag)
    return _setToStringTag;
  hasRequired_setToStringTag = 1;
  var def = require_objectDp().f, has = require_has(), TAG = require_wks()("toStringTag");
  _setToStringTag = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  return _setToStringTag;
}

var _iterCreate;
var hasRequired_iterCreate;
function require_iterCreate() {
  if (hasRequired_iterCreate)
    return _iterCreate;
  hasRequired_iterCreate = 1;
  var create = require_objectCreate(), descriptor = require_propertyDesc(), setToStringTag = require_setToStringTag(), IteratorPrototype = {};
  require_hide()(IteratorPrototype, require_wks()("iterator"), function () {
    return this;
  });
  _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + " Iterator");
  };
  return _iterCreate;
}

var _toObject;
var hasRequired_toObject;
function require_toObject() {
  if (hasRequired_toObject)
    return _toObject;
  hasRequired_toObject = 1;
  var defined = require_defined();
  _toObject = function (it) {
    return Object(defined(it));
  };
  return _toObject;
}

var _objectGpo;
var hasRequired_objectGpo;
function require_objectGpo() {
  if (hasRequired_objectGpo)
    return _objectGpo;
  hasRequired_objectGpo = 1;
  var has = require_has(), toObject = require_toObject(), IE_PROTO = require_sharedKey()("IE_PROTO"), ObjectProto = Object.prototype;
  _objectGpo = Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO))
      return O[IE_PROTO];
    if (typeof O.constructor == "function" && O instanceof O.constructor) {
      return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectProto : null;
  };
  return _objectGpo;
}

var _iterDefine;
var hasRequired_iterDefine;
function require_iterDefine() {
  if (hasRequired_iterDefine)
    return _iterDefine;
  hasRequired_iterDefine = 1;
  var LIBRARY = require_library(), $export = require_export(), redefine = require_redefine(), hide = require_hide(), has = require_has(), Iterators = require_iterators(), $iterCreate = require_iterCreate(), setToStringTag = require_setToStringTag(), getPrototypeOf = require_objectGpo(), ITERATOR = require_wks()("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values";
  var returnThis = function () {
    return this;
  };
  _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = false, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : undefined, $anyNative = NAME == "Array" ? proto.entries || $native : $native, methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype) {
        setToStringTag(IteratorPrototype, TAG, true);
        if (!LIBRARY && !has(IteratorPrototype, ITERATOR))
          hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() {
        return $native.call(this);
      };
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return _iterDefine;
}

var es6_array_iterator;
var hasRequiredEs6_array_iterator;
function requireEs6_array_iterator() {
  if (hasRequiredEs6_array_iterator)
    return es6_array_iterator;
  hasRequiredEs6_array_iterator = 1;
  var addToUnscopables = require_addToUnscopables(), step = require_iterStep(), Iterators = require_iterators(), toIObject = require_toIobject();
  es6_array_iterator = require_iterDefine()(Array, "Array", function (iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t, kind = this._k, index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == "keys")
      return step(0, index);
    if (kind == "values")
      return step(0, O[index]);
    return step(0, [
      index,
      O[index]
    ]);
  }, "values");
  Iterators.Arguments = Iterators.Array;
  addToUnscopables("keys");
  addToUnscopables("values");
  addToUnscopables("entries");
  return es6_array_iterator;
}

var hasRequiredWeb_dom_iterable;
function requireWeb_dom_iterable() {
  if (hasRequiredWeb_dom_iterable)
    return web_dom_iterable;
  hasRequiredWeb_dom_iterable = 1;
  requireEs6_array_iterator();
  var global = require_global(), hide = require_hide(), Iterators = require_iterators(), TO_STRING_TAG = require_wks()("toStringTag");
  for (var collections = [
        "NodeList",
        "DOMTokenList",
        "MediaList",
        "StyleSheetList",
        "CSSRuleList"
      ], i = 0; i < 5; i++) {
    var NAME = collections[i], Collection = global[NAME], proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG])
      hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = Iterators.Array;
  }
  return web_dom_iterable;
}

var es6_string_iterator = {};

var _stringAt;
var hasRequired_stringAt;
function require_stringAt() {
  if (hasRequired_stringAt)
    return _stringAt;
  hasRequired_stringAt = 1;
  var toInteger = require_toInteger(), defined = require_defined();
  _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)), i = toInteger(pos), l = s.length, a, b;
      if (i < 0 || i >= l)
        return TO_STRING ? "" : undefined;
      a = s.charCodeAt(i);
      return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
    };
  };
  return _stringAt;
}

var hasRequiredEs6_string_iterator;
function requireEs6_string_iterator() {
  if (hasRequiredEs6_string_iterator)
    return es6_string_iterator;
  hasRequiredEs6_string_iterator = 1;
  var $at = require_stringAt()(true);
  require_iterDefine()(String, "String", function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t, index = this._i, point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  return es6_string_iterator;
}

var _classof;
var hasRequired_classof;
function require_classof() {
  if (hasRequired_classof)
    return _classof;
  hasRequired_classof = 1;
  var cof = require_cof(), TAG = require_wks()("toStringTag"), ARG = cof((function () {
      return arguments;
    }())) == "Arguments";
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {
    }
  };
  _classof = function (it) {
    var O, T, B;
    return it === undefined ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
  };
  return _classof;
}

var core_getIteratorMethod;
var hasRequiredCore_getIteratorMethod;
function requireCore_getIteratorMethod() {
  if (hasRequiredCore_getIteratorMethod)
    return core_getIteratorMethod;
  hasRequiredCore_getIteratorMethod = 1;
  var classof = require_classof(), ITERATOR = require_wks()("iterator"), Iterators = require_iterators();
  core_getIteratorMethod = require_core().getIteratorMethod = function (it) {
    if (it != undefined)
      return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
  };
  return core_getIteratorMethod;
}

var core_getIterator;
var hasRequiredCore_getIterator;
function requireCore_getIterator() {
  if (hasRequiredCore_getIterator)
    return core_getIterator;
  hasRequiredCore_getIterator = 1;
  var anObject = require_anObject(), get = requireCore_getIteratorMethod();
  core_getIterator = require_core().getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != "function")
      throw TypeError(it + " is not iterable!");
    return anObject(iterFn.call(it));
  };
  return core_getIterator;
}

var getIterator$1;
var hasRequiredGetIterator$1;
function requireGetIterator$1() {
  if (hasRequiredGetIterator$1)
    return getIterator$1;
  hasRequiredGetIterator$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_string_iterator();
  getIterator$1 = requireCore_getIterator();
  return getIterator$1;
}

var getIterator;
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator)
    return getIterator;
  hasRequiredGetIterator = 1;
  getIterator = {
    "default": requireGetIterator$1(),
    __esModule: true
  };
  return getIterator;
}

var es6_symbol = {};

var _meta = {exports: {}};

var hasRequired_meta;
function require_meta() {
  if (hasRequired_meta)
    return _meta.exports;
  hasRequired_meta = 1;
  var META = require_uid()("meta"), isObject = require_isObject(), has = require_has(), setDesc = require_objectDp().f, id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !require_fails()(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, {
      value: {
        i: "O" + ++id,
        w: {}
      }
    });
  };
  var fastKey = function (it, create) {
    if (!isObject(it))
      return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
    if (!has(it, META)) {
      if (!isExtensible(it))
        return "F";
      if (!create)
        return "E";
      setMeta(it);
    }
    return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!has(it, META)) {
      if (!isExtensible(it))
        return true;
      if (!create)
        return false;
      setMeta(it);
    }
    return it[META].w;
  };
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
      setMeta(it);
    return it;
  };
  var meta = _meta.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  return _meta.exports;
}

var _wksExt = {};

var hasRequired_wksExt;
function require_wksExt() {
  if (hasRequired_wksExt)
    return _wksExt;
  hasRequired_wksExt = 1;
  _wksExt.f = require_wks();
  return _wksExt;
}

var _wksDefine;
var hasRequired_wksDefine;
function require_wksDefine() {
  if (hasRequired_wksDefine)
    return _wksDefine;
  hasRequired_wksDefine = 1;
  var global = require_global(), core = require_core(), LIBRARY = require_library(), wksExt = require_wksExt(), defineProperty = require_objectDp().f;
  _wksDefine = function (name) {
    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
    if (name.charAt(0) != "_" && !(name in $Symbol))
      defineProperty($Symbol, name, { value: wksExt.f(name) });
  };
  return _wksDefine;
}

var _keyof;
var hasRequired_keyof;
function require_keyof() {
  if (hasRequired_keyof)
    return _keyof;
  hasRequired_keyof = 1;
  var getKeys = require_objectKeys(), toIObject = require_toIobject();
  _keyof = function (object, el) {
    var O = toIObject(object), keys = getKeys(O), length = keys.length, index = 0, key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  return _keyof;
}

var _objectGops = {};

var hasRequired_objectGops;
function require_objectGops() {
  if (hasRequired_objectGops)
    return _objectGops;
  hasRequired_objectGops = 1;
  _objectGops.f = Object.getOwnPropertySymbols;
  return _objectGops;
}

var _objectPie = {};

var hasRequired_objectPie;
function require_objectPie() {
  if (hasRequired_objectPie)
    return _objectPie;
  hasRequired_objectPie = 1;
  _objectPie.f = {}.propertyIsEnumerable;
  return _objectPie;
}

var _enumKeys;
var hasRequired_enumKeys;
function require_enumKeys() {
  if (hasRequired_enumKeys)
    return _enumKeys;
  hasRequired_enumKeys = 1;
  var getKeys = require_objectKeys(), gOPS = require_objectGops(), pIE = require_objectPie();
  _enumKeys = function (it) {
    var result = getKeys(it), getSymbols = gOPS.f;
    if (getSymbols) {
      var symbols = getSymbols(it), isEnum = pIE.f, i = 0, key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          result.push(key);
    }
    return result;
  };
  return _enumKeys;
}

var _isArray;
var hasRequired_isArray;
function require_isArray() {
  if (hasRequired_isArray)
    return _isArray;
  hasRequired_isArray = 1;
  var cof = require_cof();
  _isArray = Array.isArray || function isArray(arg) {
    return cof(arg) == "Array";
  };
  return _isArray;
}

var _objectGopnExt = {};

var _objectGopn = {};

var hasRequired_objectGopn;
function require_objectGopn() {
  if (hasRequired_objectGopn)
    return _objectGopn;
  hasRequired_objectGopn = 1;
  var $keys = require_objectKeysInternal(), hiddenKeys = require_enumBugKeys().concat("length", "prototype");
  _objectGopn.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return $keys(O, hiddenKeys);
  };
  return _objectGopn;
}

var hasRequired_objectGopnExt;
function require_objectGopnExt() {
  if (hasRequired_objectGopnExt)
    return _objectGopnExt;
  hasRequired_objectGopnExt = 1;
  var toIObject = require_toIobject(), gOPN = require_objectGopn().f, toString = {}.toString;
  var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  _objectGopnExt.f = function getOwnPropertyNames(it) {
    return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
  };
  return _objectGopnExt;
}

var _objectGopd = {};

var hasRequired_objectGopd;
function require_objectGopd() {
  if (hasRequired_objectGopd)
    return _objectGopd;
  hasRequired_objectGopd = 1;
  var pIE = require_objectPie(), createDesc = require_propertyDesc(), toIObject = require_toIobject(), toPrimitive = require_toPrimitive(), has = require_has(), IE8_DOM_DEFINE = require_ie8DomDefine(), gOPD = Object.getOwnPropertyDescriptor;
  _objectGopd.f = require_descriptors() ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = toIObject(O);
    P = toPrimitive(P, true);
    if (IE8_DOM_DEFINE)
      try {
        return gOPD(O, P);
      } catch (e) {
      }
    if (has(O, P))
      return createDesc(!pIE.f.call(O, P), O[P]);
  };
  return _objectGopd;
}

var hasRequiredEs6_symbol;
function requireEs6_symbol() {
  if (hasRequiredEs6_symbol)
    return es6_symbol;
  hasRequiredEs6_symbol = 1;
  var global = require_global(), has = require_has(), DESCRIPTORS = require_descriptors(), $export = require_export(), redefine = require_redefine(), META = require_meta().KEY, $fails = require_fails(), shared = require_shared(), setToStringTag = require_setToStringTag(), uid = require_uid(), wks = require_wks(), wksExt = require_wksExt(), wksDefine = require_wksDefine(), keyOf = require_keyof(), enumKeys = require_enumKeys(), isArray = require_isArray(), anObject = require_anObject(), toIObject = require_toIobject(), toPrimitive = require_toPrimitive(), createDesc = require_propertyDesc(), _create = require_objectCreate(), gOPNExt = require_objectGopnExt(), $GOPD = require_objectGopd(), $DP = require_objectDp(), $keys = require_objectKeys(), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, PROTOTYPE = "prototype", HIDDEN = wks("_hidden"), TO_PRIMITIVE = wks("toPrimitive"), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), OPSymbols = shared("op-symbols"), ObjectProto = Object[PROTOTYPE], USE_NATIVE = typeof $Symbol == "function", QObject = global.QObject;
  var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
  var setSymbolDesc = DESCRIPTORS && $fails(function () {
    return _create(dP({}, "a", {
      get: function () {
        return dP(this, "a", { value: 7 }).a;
      }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    dP(it, key, D);
    if (protoDesc && it !== ObjectProto)
      dP(ObjectProto, key, protoDesc);
  } : dP;
  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    sym._k = tag;
    return sym;
  };
  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function (it) {
    return typeof it == "symbol";
  } : function (it) {
    return it instanceof $Symbol;
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto)
      $defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);
    if (has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          dP(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, { enumerable: createDesc(0, false) });
      }
      return setSymbolDesc(it, key, D);
    }
    return dP(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length, key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = toPrimitive(key, true));
    if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
      return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = toIObject(it);
    key = toPrimitive(key, true);
    if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
      return;
    var D = gOPD(it, key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN(toIObject(it)), result = [], i = 0, key;
    while (names.length > i) {
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
        result.push(key);
    }
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0, key;
    while (names.length > i) {
      if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
        result.push(AllSymbols[key]);
    }
    return result;
  };
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol)
        throw TypeError("Symbol is not a constructor!");
      var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto)
          $set.call(OPSymbols, value);
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      };
      if (DESCRIPTORS && setter)
        setSymbolDesc(ObjectProto, tag, {
          configurable: true,
          set: $set
        });
      return wrap(tag);
    };
    redefine($Symbol[PROTOTYPE], "toString", function toString() {
      return this._k;
    });
    $GOPD.f = $getOwnPropertyDescriptor;
    $DP.f = $defineProperty;
    require_objectGopn().f = gOPNExt.f = $getOwnPropertyNames;
    require_objectPie().f = $propertyIsEnumerable;
    require_objectGops().f = $getOwnPropertySymbols;
    if (DESCRIPTORS && !require_library()) {
      redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
    }
    wksExt.f = function (name) {
      return wrap(wks(name));
    };
  }
  $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
  for (var symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), i = 0; symbols.length > i;)
    wks(symbols[i++]);
  for (var symbols = $keys(wks.store), i = 0; symbols.length > i;)
    wksDefine(symbols[i++]);
  $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
    "for": function (key) {
      return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      if (isSymbol(key))
        return keyOf(SymbolRegistry, key);
      throw TypeError(key + " is not a symbol!");
    },
    useSetter: function () {
      setter = true;
    },
    useSimple: function () {
      setter = false;
    }
  });
  $export($export.S + $export.F * !USE_NATIVE, "Object", {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
    var S = $Symbol();
    return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
  })), "JSON", {
    stringify: function stringify(it) {
      if (it === undefined || isSymbol(it))
        return;
      var args = [it], i = 1, replacer, $replacer;
      while (arguments.length > i)
        args.push(arguments[i++]);
      replacer = args[1];
      if (typeof replacer == "function")
        $replacer = replacer;
      if ($replacer || !isArray(replacer))
        replacer = function (key, value) {
          if ($replacer)
            value = $replacer.call(this, key, value);
          if (!isSymbol(value))
            return value;
        };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });
  $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
  setToStringTag($Symbol, "Symbol");
  setToStringTag(Math, "Math", true);
  setToStringTag(global.JSON, "JSON", true);
  return es6_symbol;
}

var es7_symbol_asyncIterator = {};

var hasRequiredEs7_symbol_asyncIterator;
function requireEs7_symbol_asyncIterator() {
  if (hasRequiredEs7_symbol_asyncIterator)
    return es7_symbol_asyncIterator;
  hasRequiredEs7_symbol_asyncIterator = 1;
  require_wksDefine()("asyncIterator");
  return es7_symbol_asyncIterator;
}

var es7_symbol_observable = {};

var hasRequiredEs7_symbol_observable;
function requireEs7_symbol_observable() {
  if (hasRequiredEs7_symbol_observable)
    return es7_symbol_observable;
  hasRequiredEs7_symbol_observable = 1;
  require_wksDefine()("observable");
  return es7_symbol_observable;
}

var symbol$1;
var hasRequiredSymbol$1;
function requireSymbol$1() {
  if (hasRequiredSymbol$1)
    return symbol$1;
  hasRequiredSymbol$1 = 1;
  requireEs6_symbol();
  requireEs7_symbol_asyncIterator();
  requireEs7_symbol_observable();
  symbol$1 = require_core().Symbol;
  return symbol$1;
}

var symbol;
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol)
    return symbol;
  hasRequiredSymbol = 1;
  symbol = {
    "default": requireSymbol$1(),
    __esModule: true
  };
  return symbol;
}

var lib$6 = {exports: {}};

var lib$5 = {};

var getOwnPropertySymbols$1;
var hasRequiredGetOwnPropertySymbols$1;
function requireGetOwnPropertySymbols$1() {
  if (hasRequiredGetOwnPropertySymbols$1)
    return getOwnPropertySymbols$1;
  hasRequiredGetOwnPropertySymbols$1 = 1;
  requireEs6_symbol();
  getOwnPropertySymbols$1 = require_core().Object.getOwnPropertySymbols;
  return getOwnPropertySymbols$1;
}

var getOwnPropertySymbols;
var hasRequiredGetOwnPropertySymbols;
function requireGetOwnPropertySymbols() {
  if (hasRequiredGetOwnPropertySymbols)
    return getOwnPropertySymbols;
  hasRequiredGetOwnPropertySymbols = 1;
  getOwnPropertySymbols = {
    "default": requireGetOwnPropertySymbols$1(),
    __esModule: true
  };
  return getOwnPropertySymbols;
}

var es6_object_keys = {};

var _objectSap;
var hasRequired_objectSap;
function require_objectSap() {
  if (hasRequired_objectSap)
    return _objectSap;
  hasRequired_objectSap = 1;
  var $export = require_export(), core = require_core(), fails = require_fails();
  _objectSap = function (KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function () {
      fn(1);
    }), "Object", exp);
  };
  return _objectSap;
}

var hasRequiredEs6_object_keys;
function requireEs6_object_keys() {
  if (hasRequiredEs6_object_keys)
    return es6_object_keys;
  hasRequiredEs6_object_keys = 1;
  var toObject = require_toObject(), $keys = require_objectKeys();
  require_objectSap()("keys", function () {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  return es6_object_keys;
}

var keys$1;
var hasRequiredKeys$2;
function requireKeys$2() {
  if (hasRequiredKeys$2)
    return keys$1;
  hasRequiredKeys$2 = 1;
  requireEs6_object_keys();
  keys$1 = require_core().Object.keys;
  return keys$1;
}

var keys;
var hasRequiredKeys$1;
function requireKeys$1() {
  if (hasRequiredKeys$1)
    return keys;
  hasRequiredKeys$1 = 1;
  keys = {
    "default": requireKeys$2(),
    __esModule: true
  };
  return keys;
}

var stringify$2;
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1)
    return stringify$2;
  hasRequiredStringify$1 = 1;
  var core = require_core(), $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
  stringify$2 = function stringify(it) {
    return $JSON.stringify.apply($JSON, arguments);
  };
  return stringify$2;
}

var stringify$1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify)
    return stringify$1;
  hasRequiredStringify = 1;
  stringify$1 = {
    "default": requireStringify$1(),
    __esModule: true
  };
  return stringify$1;
}

var constants = {};

var _for$1;
var hasRequired_for$1;
function require_for$1() {
  if (hasRequired_for$1)
    return _for$1;
  hasRequired_for$1 = 1;
  requireEs6_symbol();
  _for$1 = require_core().Symbol["for"];
  return _for$1;
}

var _for;
var hasRequired_for;
function require_for() {
  if (hasRequired_for)
    return _for;
  hasRequired_for = 1;
  _for = {
    "default": require_for$1(),
    __esModule: true
  };
  return _for;
}

var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  constants.__esModule = true;
  constants.NOT_LOCAL_BINDING = constants.BLOCK_SCOPED_SYMBOL = constants.INHERIT_KEYS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = constants.BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.UPDATE_OPERATORS = constants.LOGICAL_OPERATORS = constants.COMMENT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.STATEMENT_OR_BLOCK_KEYS = undefined;
  var _for = require_for();
  var _for2 = _interopRequireDefault(_for);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  constants.STATEMENT_OR_BLOCK_KEYS = [
    "consequent",
    "body",
    "alternate"
  ];
  constants.FLATTENABLE_KEYS = [
    "body",
    "expressions"
  ];
  constants.FOR_INIT_KEYS = [
    "left",
    "init"
  ];
  constants.COMMENT_KEYS = [
    "leadingComments",
    "trailingComments",
    "innerComments"
  ];
  constants.LOGICAL_OPERATORS = [
    "||",
    "&&"
  ];
  constants.UPDATE_OPERATORS = [
    "++",
    "--"
  ];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [
    ">",
    "<",
    ">=",
    "<="
  ];
  var EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = [
    "==",
    "===",
    "!=",
    "!=="
  ];
  var COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, [
    "in",
    "instanceof"
  ]);
  var BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
  var NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^"
  ];
  constants.BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
  var BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = [
    "delete",
    "!"
  ];
  var NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = [
    "+",
    "-",
    "++",
    "--",
    "~"
  ];
  var STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
  constants.UNARY_OPERATORS = ["void"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
  constants.INHERIT_KEYS = {
    optional: [
      "typeAnnotation",
      "typeParameters",
      "returnType"
    ],
    force: [
      "start",
      "loc",
      "end"
    ]
  };
  constants.BLOCK_SCOPED_SYMBOL = (0, _for2.default)("var used to be block scoped");
  constants.NOT_LOCAL_BINDING = (0, _for2.default)("should not be considered a local binding");
  return constants;
}

var retrievers = {};

var hasRequiredRetrievers;
function requireRetrievers() {
  if (hasRequiredRetrievers)
    return retrievers;
  hasRequiredRetrievers = 1;
  retrievers.__esModule = true;
  var _create = requireCreate();
  var _create2 = _interopRequireDefault(_create);
  retrievers.getBindingIdentifiers = getBindingIdentifiers;
  retrievers.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function getBindingIdentifiers(node, duplicates, outerOnly) {
    var search = [].concat(node);
    var ids = (0, _create2.default)(null);
    while (search.length) {
      var id = search.shift();
      if (!id)
        continue;
      var keys = t.getBindingIdentifiers.keys[id.type];
      if (t.isIdentifier(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if (t.isExportDeclaration(id)) {
        if (t.isDeclaration(node.declaration)) {
          search.push(node.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (t.isFunctionDeclaration(id)) {
          search.push(id.id);
          continue;
        }
        if (t.isFunctionExpression(id)) {
          continue;
        }
      }
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }
    return ids;
  }
  getBindingIdentifiers.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: [
      "id",
      "params"
    ],
    FunctionExpression: [
      "id",
      "params"
    ],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    RestProperty: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  function getOuterBindingIdentifiers(node, duplicates) {
    return getBindingIdentifiers(node, duplicates, true);
  }
  return retrievers;
}

var validators = {};

var _typeof = {};

var iterator$1;
var hasRequiredIterator$1;
function requireIterator$1() {
  if (hasRequiredIterator$1)
    return iterator$1;
  hasRequiredIterator$1 = 1;
  requireEs6_string_iterator();
  requireWeb_dom_iterable();
  iterator$1 = require_wksExt().f("iterator");
  return iterator$1;
}

var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = {
    "default": requireIterator$1(),
    __esModule: true
  };
  return iterator;
}

var hasRequired_typeof;
function require_typeof() {
  if (hasRequired_typeof)
    return _typeof;
  hasRequired_typeof = 1;
  _typeof.__esModule = true;
  var _iterator = requireIterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _symbol = requireSymbol();
  var _symbol2 = _interopRequireDefault(_symbol);
  var _typeof$1 = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
  };
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  _typeof.default = typeof _symbol2.default === "function" && _typeof$1(_iterator2.default) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof$1(obj);
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof$1(obj);
  };
  return _typeof;
}

var utils = {};

var ast = {exports: {}};

(function () {
  function isExpression(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "CallExpression":
    case "ConditionalExpression":
    case "FunctionExpression":
    case "Identifier":
    case "Literal":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "SequenceExpression":
    case "ThisExpression":
    case "UnaryExpression":
    case "UpdateExpression":
      return true;
    }
    return false;
  }
  function isIterationStatement(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "WhileStatement":
      return true;
    }
    return false;
  }
  function isStatement(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
    case "BlockStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "ForInStatement":
    case "ForStatement":
    case "IfStatement":
    case "LabeledStatement":
    case "ReturnStatement":
    case "SwitchStatement":
    case "ThrowStatement":
    case "TryStatement":
    case "VariableDeclaration":
    case "WhileStatement":
    case "WithStatement":
      return true;
    }
    return false;
  }
  function isSourceElement(node) {
    return isStatement(node) || node != null && node.type === "FunctionDeclaration";
  }
  function trailingStatement(node) {
    switch (node.type) {
    case "IfStatement":
      if (node.alternate != null) {
        return node.alternate;
      }
      return node.consequent;
    case "LabeledStatement":
    case "ForStatement":
    case "ForInStatement":
    case "WhileStatement":
    case "WithStatement":
      return node.body;
    }
    return null;
  }
  function isProblematicIfStatement(node) {
    var current;
    if (node.type !== "IfStatement") {
      return false;
    }
    if (node.alternate == null) {
      return false;
    }
    current = node.consequent;
    do {
      if (current.type === "IfStatement") {
        if (current.alternate == null) {
          return true;
        }
      }
      current = trailingStatement(current);
    } while (current);
    return false;
  }
  ast.exports = {
    isExpression: isExpression,
    isStatement: isStatement,
    isIterationStatement: isIterationStatement,
    isSourceElement: isSourceElement,
    isProblematicIfStatement: isProblematicIfStatement,
    trailingStatement: trailingStatement
  };
}());

var code = {exports: {}};

(function () {
  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
  ES5Regex = {
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };
  function isDecimalDigit(ch) {
    return 48 <= ch && ch <= 57;
  }
  function isHexDigit(ch) {
    return 48 <= ch && ch <= 57 || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
  }
  function isOctalDigit(ch) {
    return ch >= 48 && ch <= 55;
  }
  NON_ASCII_WHITESPACES = [
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  function isWhiteSpace(ch) {
    return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
  }
  function isLineTerminator(ch) {
    return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
  }
  function fromCodePoint(cp) {
    if (cp <= 65535) {
      return String.fromCharCode(cp);
    }
    var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
    var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
    return cu1 + cu2;
  }
  IDENTIFIER_START = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
  }
  IDENTIFIER_PART = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
  }
  function isIdentifierStartES5(ch) {
    return ch < 128 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }
  function isIdentifierPartES5(ch) {
    return ch < 128 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }
  function isIdentifierStartES6(ch) {
    return ch < 128 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }
  function isIdentifierPartES6(ch) {
    return ch < 128 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }
  code.exports = {
    isDecimalDigit: isDecimalDigit,
    isHexDigit: isHexDigit,
    isOctalDigit: isOctalDigit,
    isWhiteSpace: isWhiteSpace,
    isLineTerminator: isLineTerminator,
    isIdentifierStartES5: isIdentifierStartES5,
    isIdentifierPartES5: isIdentifierPartES5,
    isIdentifierStartES6: isIdentifierStartES6,
    isIdentifierPartES6: isIdentifierPartES6
  };
}());

var keyword = {exports: {}};

(function () {
  var code$1 = code.exports;
  function isStrictModeReservedWordES6(id) {
    switch (id) {
    case "implements":
    case "interface":
    case "package":
    case "private":
    case "protected":
    case "public":
    case "static":
    case "let":
      return true;
    default:
      return false;
    }
  }
  function isKeywordES5(id, strict) {
    if (!strict && id === "yield") {
      return false;
    }
    return isKeywordES6(id, strict);
  }
  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }
    switch (id.length) {
    case 2:
      return id === "if" || id === "in" || id === "do";
    case 3:
      return id === "var" || id === "for" || id === "new" || id === "try";
    case 4:
      return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
    case 5:
      return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
    case 6:
      return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
    case 7:
      return id === "default" || id === "finally" || id === "extends";
    case 8:
      return id === "function" || id === "continue" || id === "debugger";
    case 10:
      return id === "instanceof";
    default:
      return false;
    }
  }
  function isReservedWordES5(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
  }
  function isReservedWordES6(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
  }
  function isRestrictedWord(id) {
    return id === "eval" || id === "arguments";
  }
  function isIdentifierNameES5(id) {
    var i, iz, ch;
    if (id.length === 0) {
      return false;
    }
    ch = id.charCodeAt(0);
    if (!code$1.isIdentifierStartES5(ch)) {
      return false;
    }
    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (!code$1.isIdentifierPartES5(ch)) {
        return false;
      }
    }
    return true;
  }
  function decodeUtf16(lead, trail) {
    return (lead - 55296) * 1024 + (trail - 56320) + 65536;
  }
  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;
    if (id.length === 0) {
      return false;
    }
    check = code$1.isIdentifierStartES6;
    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (55296 <= ch && ch <= 56319) {
        ++i;
        if (i >= iz) {
          return false;
        }
        lowCh = id.charCodeAt(i);
        if (!(56320 <= lowCh && lowCh <= 57343)) {
          return false;
        }
        ch = decodeUtf16(ch, lowCh);
      }
      if (!check(ch)) {
        return false;
      }
      check = code$1.isIdentifierPartES6;
    }
    return true;
  }
  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }
  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }
  keyword.exports = {
    isKeywordES5: isKeywordES5,
    isKeywordES6: isKeywordES6,
    isReservedWordES5: isReservedWordES5,
    isReservedWordES6: isReservedWordES6,
    isRestrictedWord: isRestrictedWord,
    isIdentifierNameES5: isIdentifierNameES5,
    isIdentifierNameES6: isIdentifierNameES6,
    isIdentifierES5: isIdentifierES5,
    isIdentifierES6: isIdentifierES6
  };
}());

(function () {
  utils.ast = ast.exports;
  utils.code = code.exports;
  utils.keyword = keyword.exports;
}());

var hasRequiredValidators;
function requireValidators() {
  if (hasRequiredValidators)
    return validators;
  hasRequiredValidators = 1;
  validators.__esModule = true;
  var _keys = requireKeys$1();
  var _keys2 = _interopRequireDefault(_keys);
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  validators.isBinding = isBinding;
  validators.isReferenced = isReferenced;
  validators.isValidIdentifier = isValidIdentifier;
  validators.isLet = isLet;
  validators.isBlockScoped = isBlockScoped;
  validators.isVar = isVar;
  validators.isSpecifierDefault = isSpecifierDefault;
  validators.isScope = isScope;
  validators.isImmutable = isImmutable;
  validators.isNodesEquivalent = isNodesEquivalent;
  var _retrievers = requireRetrievers();
  var _esutils = utils;
  var _esutils2 = _interopRequireDefault(_esutils);
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  var _constants = requireConstants();
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isBinding(node, parent) {
    var keys = _retrievers.getBindingIdentifiers.keys[parent.type];
    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];
        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0)
            return true;
        } else {
          if (val === node)
            return true;
        }
      }
    }
    return false;
  }
  function isReferenced(node, parent) {
    switch (parent.type) {
    case "BindExpression":
      return parent.object === node || parent.callee === node;
    case "MemberExpression":
    case "JSXMemberExpression":
      if (parent.property === node && parent.computed) {
        return true;
      } else if (parent.object === node) {
        return true;
      } else {
        return false;
      }
    case "MetaProperty":
      return false;
    case "ObjectProperty":
      if (parent.key === node) {
        return parent.computed;
      }
    case "VariableDeclarator":
      return parent.id !== node;
    case "ArrowFunctionExpression":
    case "FunctionDeclaration":
    case "FunctionExpression":
      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var param = _ref;
        if (param === node)
          return false;
      }
      return parent.id !== node;
    case "ExportSpecifier":
      if (parent.source) {
        return false;
      } else {
        return parent.local === node;
      }
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;
    case "JSXAttribute":
      return parent.name !== node;
    case "ClassProperty":
      if (parent.key === node) {
        return parent.computed;
      } else {
        return parent.value === node;
      }
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;
    case "ClassDeclaration":
    case "ClassExpression":
      return parent.id !== node;
    case "ClassMethod":
    case "ObjectMethod":
      return parent.key === node && parent.computed;
    case "LabeledStatement":
      return false;
    case "CatchClause":
      return parent.param !== node;
    case "RestElement":
      return false;
    case "AssignmentExpression":
      return parent.right === node;
    case "AssignmentPattern":
      return parent.right === node;
    case "ObjectPattern":
    case "ArrayPattern":
      return false;
    }
    return true;
  }
  function isValidIdentifier(name) {
    if (typeof name !== "string" || _esutils2.default.keyword.isReservedWordES6(name, true)) {
      return false;
    } else {
      return _esutils2.default.keyword.isIdentifierNameES6(name);
    }
  }
  function isLet(node) {
    return t.isVariableDeclaration(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
  }
  function isBlockScoped(node) {
    return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
  }
  function isVar(node) {
    return t.isVariableDeclaration(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
  }
  function isSpecifierDefault(specifier) {
    return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
  }
  function isScope(node, parent) {
    if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {
      return false;
    }
    return t.isScopable(node);
  }
  function isImmutable(node) {
    if (t.isType(node.type, "Immutable"))
      return true;
    if (t.isIdentifier(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
  function isNodesEquivalent(a, b) {
    if ((typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type);
    for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref2 = _i2.value;
      }
      var field = _ref2;
      if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {
        return false;
      }
      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }
        if (a[field].length !== b[field].length) {
          return false;
        }
        for (var i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }
    return true;
  }
  return validators;
}

var converters = {};

var es6_number_maxSafeInteger = {};

var hasRequiredEs6_number_maxSafeInteger;
function requireEs6_number_maxSafeInteger() {
  if (hasRequiredEs6_number_maxSafeInteger)
    return es6_number_maxSafeInteger;
  hasRequiredEs6_number_maxSafeInteger = 1;
  var $export = require_export();
  $export($export.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
  return es6_number_maxSafeInteger;
}

var maxSafeInteger$1;
var hasRequiredMaxSafeInteger$1;
function requireMaxSafeInteger$1() {
  if (hasRequiredMaxSafeInteger$1)
    return maxSafeInteger$1;
  hasRequiredMaxSafeInteger$1 = 1;
  requireEs6_number_maxSafeInteger();
  maxSafeInteger$1 = 9007199254740991;
  return maxSafeInteger$1;
}

var maxSafeInteger;
var hasRequiredMaxSafeInteger;
function requireMaxSafeInteger() {
  if (hasRequiredMaxSafeInteger)
    return maxSafeInteger;
  hasRequiredMaxSafeInteger = 1;
  maxSafeInteger = {
    "default": requireMaxSafeInteger$1(),
    __esModule: true
  };
  return maxSafeInteger;
}

var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal)
    return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}

var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root)
    return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}

var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol = root.Symbol;
  _Symbol = Symbol;
  return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag)
    return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}

var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString)
    return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag)
    return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}

var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg)
    return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}

var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype)
    return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}

var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike)
    return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}

var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject)
    return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject;
  return isPlainObject_1;
}

var isNumber_1;
var hasRequiredIsNumber;
function requireIsNumber() {
  if (hasRequiredIsNumber)
    return isNumber_1;
  hasRequiredIsNumber = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var numberTag = "[object Number]";
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  isNumber_1 = isNumber;
  return isNumber_1;
}

var _baseIsRegExp;
var hasRequired_baseIsRegExp;
function require_baseIsRegExp() {
  if (hasRequired_baseIsRegExp)
    return _baseIsRegExp;
  hasRequired_baseIsRegExp = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var regexpTag = "[object RegExp]";
  function baseIsRegExp(value) {
    return isObjectLike(value) && baseGetTag(value) == regexpTag;
  }
  _baseIsRegExp = baseIsRegExp;
  return _baseIsRegExp;
}

var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary)
    return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}

var _nodeUtil = {exports: {}};

var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil)
    return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function (module, exports) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function () {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }());
    module.exports = nodeUtil;
  }(_nodeUtil, _nodeUtil.exports));
  return _nodeUtil.exports;
}

var isRegExp_1;
var hasRequiredIsRegExp;
function requireIsRegExp() {
  if (hasRequiredIsRegExp)
    return isRegExp_1;
  hasRequiredIsRegExp = 1;
  var baseIsRegExp = require_baseIsRegExp(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
  isRegExp_1 = isRegExp;
  return isRegExp_1;
}

var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}

var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag(), isArray = requireIsArray(), isObjectLike = requireIsObjectLike();
  var stringTag = "[object String]";
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString;
  return isString_1;
}

var hasRequiredConverters;
function requireConverters() {
  if (hasRequiredConverters)
    return converters;
  hasRequiredConverters = 1;
  converters.__esModule = true;
  var _maxSafeInteger = requireMaxSafeInteger();
  var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);
  var _stringify = requireStringify();
  var _stringify2 = _interopRequireDefault(_stringify);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  converters.toComputedKey = toComputedKey;
  converters.toSequenceExpression = toSequenceExpression;
  converters.toKeyAlias = toKeyAlias;
  converters.toIdentifier = toIdentifier;
  converters.toBindingIdentifierName = toBindingIdentifierName;
  converters.toStatement = toStatement;
  converters.toExpression = toExpression;
  converters.toBlock = toBlock;
  converters.valueToNode = valueToNode;
  var _isPlainObject = requireIsPlainObject();
  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _isRegExp = requireIsRegExp();
  var _isRegExp2 = _interopRequireDefault(_isRegExp);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toComputedKey(node) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;
    if (!node.computed) {
      if (t.isIdentifier(key))
        key = t.stringLiteral(key.name);
    }
    return key;
  }
  function toSequenceExpression(nodes, scope) {
    if (!nodes || !nodes.length)
      return;
    var declars = [];
    var bailed = false;
    var result = convert(nodes);
    if (bailed)
      return;
    for (var i = 0; i < declars.length; i++) {
      scope.push(declars[i]);
    }
    return result;
    function convert(nodes) {
      var ensureLastUndefined = false;
      var exprs = [];
      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var node = _ref;
        if (t.isExpression(node)) {
          exprs.push(node);
        } else if (t.isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (t.isVariableDeclaration(node)) {
          if (node.kind !== "var")
            return bailed = true;
          for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var declar = _ref2;
            var bindings = t.getBindingIdentifiers(declar);
            for (var key in bindings) {
              declars.push({
                kind: node.kind,
                id: bindings[key]
              });
            }
            if (declar.init) {
              exprs.push(t.assignmentExpression("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
          continue;
        } else if (t.isIfStatement(node)) {
          var consequent = node.consequent ? convert([node.consequent]) : scope.buildUndefinedNode();
          var alternate = node.alternate ? convert([node.alternate]) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return bailed = true;
          exprs.push(t.conditionalExpression(node.test, consequent, alternate));
        } else if (t.isBlockStatement(node)) {
          exprs.push(convert(node.body));
        } else if (t.isEmptyStatement(node)) {
          ensureLastUndefined = true;
          continue;
        } else {
          return bailed = true;
        }
        ensureLastUndefined = false;
      }
      if (ensureLastUndefined || exprs.length === 0) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return t.sequenceExpression(exprs);
      }
    }
  }
  function toKeyAlias(node) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;
    var alias = void 0;
    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if (t.isIdentifier(key)) {
      alias = key.name;
    } else if (t.isStringLiteral(key)) {
      alias = (0, _stringify2.default)(key.value);
    } else {
      alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));
    }
    if (node.computed) {
      alias = "[" + alias + "]";
    }
    if (node.static) {
      alias = "static:" + alias;
    }
    return alias;
  }
  toKeyAlias.uid = 0;
  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= _maxSafeInteger2.default) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };
  function toIdentifier(name) {
    name = name + "";
    name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!t.isValidIdentifier(name)) {
      name = "_" + name;
    }
    return name || "_";
  }
  function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    if (name === "eval" || name === "arguments")
      name = "_" + name;
    return name;
  }
  function toStatement(node, ignore) {
    if (t.isStatement(node)) {
      return node;
    }
    var mustHaveId = false;
    var newType = void 0;
    if (t.isClass(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if (t.isFunction(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if (t.isAssignmentExpression(node)) {
      return t.expressionStatement(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn " + node.type + " to a statement");
      }
    }
    node.type = newType;
    return node;
  }
  function toExpression(node) {
    if (t.isExpressionStatement(node)) {
      node = node.expression;
    }
    if (t.isExpression(node)) {
      return node;
    }
    if (t.isClass(node)) {
      node.type = "ClassExpression";
    } else if (t.isFunction(node)) {
      node.type = "FunctionExpression";
    }
    if (!t.isExpression(node)) {
      throw new Error("cannot turn " + node.type + " to an expression");
    }
    return node;
  }
  function toBlock(node, parent) {
    if (t.isBlockStatement(node)) {
      return node;
    }
    if (t.isEmptyStatement(node)) {
      node = [];
    }
    if (!Array.isArray(node)) {
      if (!t.isStatement(node)) {
        if (t.isFunction(parent)) {
          node = t.returnStatement(node);
        } else {
          node = t.expressionStatement(node);
        }
      }
      node = [node];
    }
    return t.blockStatement(node);
  }
  function valueToNode(value) {
    if (value === undefined) {
      return t.identifier("undefined");
    }
    if (value === true || value === false) {
      return t.booleanLiteral(value);
    }
    if (value === null) {
      return t.nullLiteral();
    }
    if ((0, _isString2.default)(value)) {
      return t.stringLiteral(value);
    }
    if ((0, _isNumber2.default)(value)) {
      return t.numericLiteral(value);
    }
    if ((0, _isRegExp2.default)(value)) {
      var pattern = value.source;
      var flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return t.regExpLiteral(pattern, flags);
    }
    if (Array.isArray(value)) {
      return t.arrayExpression(value.map(t.valueToNode));
    }
    if ((0, _isPlainObject2.default)(value)) {
      var props = [];
      for (var key in value) {
        var nodeKey = void 0;
        if (t.isValidIdentifier(key)) {
          nodeKey = t.identifier(key);
        } else {
          nodeKey = t.stringLiteral(key);
        }
        props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));
      }
      return t.objectExpression(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return converters;
}

var flow$2 = {};

var hasRequiredFlow$2;
function requireFlow$2() {
  if (hasRequiredFlow$2)
    return flow$2;
  hasRequiredFlow$2 = 1;
  flow$2.__esModule = true;
  flow$2.createUnionTypeAnnotation = createUnionTypeAnnotation;
  flow$2.removeTypeDuplicates = removeTypeDuplicates;
  flow$2.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function createUnionTypeAnnotation(types) {
    var flattened = removeTypeDuplicates(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return t.unionTypeAnnotation(flattened);
    }
  }
  function removeTypeDuplicates(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node)
        continue;
      if (types.indexOf(node) >= 0) {
        continue;
      }
      if (t.isAnyTypeAnnotation(node)) {
        return [node];
      }
      if (t.isFlowBaseAnnotation(node)) {
        bases[node.type] = node;
        continue;
      }
      if (t.isUnionTypeAnnotation(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }
        continue;
      }
      if (t.isGenericTypeAnnotation(node)) {
        var name = node.id.name;
        if (generics[name]) {
          var existing = generics[name];
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }
        continue;
      }
      types.push(node);
    }
    for (var type in bases) {
      types.push(bases[type]);
    }
    for (var _name in generics) {
      types.push(generics[_name]);
    }
    return types;
  }
  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === "string") {
      return t.stringTypeAnnotation();
    } else if (type === "number") {
      return t.numberTypeAnnotation();
    } else if (type === "undefined") {
      return t.voidTypeAnnotation();
    } else if (type === "boolean") {
      return t.booleanTypeAnnotation();
    } else if (type === "function") {
      return t.genericTypeAnnotation(t.identifier("Function"));
    } else if (type === "object") {
      return t.genericTypeAnnotation(t.identifier("Object"));
    } else if (type === "symbol") {
      return t.genericTypeAnnotation(t.identifier("Symbol"));
    } else {
      throw new Error("Invalid typeof value");
    }
  }
  return flow$2;
}

var _1_0_1;
var hasRequired_1_0_1;
function require_1_0_1() {
  if (hasRequired_1_0_1)
    return _1_0_1;
  hasRequired_1_0_1 = 1;
  _1_0_1 = function toFastProperties(obj) {
    return;
  };
  return _1_0_1;
}

var compact_1;
var hasRequiredCompact;
function requireCompact() {
  if (hasRequiredCompact)
    return compact_1;
  hasRequiredCompact = 1;
  function compact(array) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  compact_1 = compact;
  return compact_1;
}

var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear)
    return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}

var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf)
    return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete)
    return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet)
    return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas)
    return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet)
    return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([
        key,
        value
      ]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache)
    return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}

var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear)
    return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}

var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete)
    return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}

var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet)
    return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}

var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas)
    return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}

var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject)
    return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData)
    return _coreJsData;
  hasRequired_coreJsData = 1;
  var root = require_root();
  var coreJsData = root["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked)
    return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }());
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}

var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource)
    return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative)
    return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}

var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue)
    return _getValue;
  hasRequired_getValue = 1;
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  _getValue = getValue;
  return _getValue;
}

var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative)
    return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue = require_getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  _getNative = getNative;
  return _getNative;
}

var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root = require_root();
  var Map = getNative(root, "Map");
  _Map = Map;
  return _Map;
}

var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate)
    return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear)
    return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}

var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete)
    return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet)
    return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  _hashGet = hashGet;
  return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas)
    return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet)
    return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}

var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash)
    return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear)
    return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}

var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable)
    return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData)
    return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete)
    return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet)
    return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas)
    return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet)
    return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache)
    return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}

var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet)
    return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([
          key,
          value
        ]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}

var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack)
    return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}

var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach)
    return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}

var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty)
    return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = (function () {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }());
  _defineProperty = defineProperty;
  return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue)
    return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}

var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue)
    return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}

var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject)
    return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  _copyObject = copyObject;
  return _copyObject;
}

var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes)
    return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments)
    return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments((function () {
    return arguments;
  }())) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}

var isBuffer = {exports: {}};

var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse)
    return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}

var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer)
    return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function (module, exports) {
    var root = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : undefined;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }(isBuffer, isBuffer.exports));
  return isBuffer.exports;
}

var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex)
    return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  _isIndex = isIndex;
  return _isIndex;
}

var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength)
    return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray)
    return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys)
    return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray = requireIsArray(), isBuffer = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}

var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype)
    return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}

var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys)
    return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys)
    return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}

var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  keys_1 = keys;
  return keys_1;
}

var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign)
    return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject = require_copyObject(), keys = requireKeys();
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  _baseAssign = baseAssign;
  return _baseAssign;
}

var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn)
    return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}

var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn)
    return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}

var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn)
    return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}

var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn)
    return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  _baseAssignIn = baseAssignIn;
  return _baseAssignIn;
}

var _cloneBuffer = {exports: {}};

var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer)
    return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function (module, exports) {
    var root = require_root();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }(_cloneBuffer, _cloneBuffer.exports));
  return _cloneBuffer.exports;
}

var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray)
    return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  _copyArray = copyArray;
  return _copyArray;
}

var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter)
    return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}

var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray)
    return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols)
    return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}

var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols)
    return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject = require_copyObject(), getSymbols = require_getSymbols();
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  _copySymbols = copySymbols;
  return _copySymbols;
}

var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush)
    return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}

var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn)
    return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush = require_arrayPush(), getPrototype = require_getPrototype(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn;
  return _getSymbolsIn;
}

var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn)
    return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  _copySymbolsIn = copySymbolsIn;
  return _copySymbolsIn;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys)
    return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray = requireIsArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}

var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys)
    return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}

var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn)
    return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn();
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  _getAllKeysIn = getAllKeysIn;
  return _getAllKeysIn;
}

var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root = require_root();
  var DataView = getNative(root, "DataView");
  _DataView = DataView;
  return _DataView;
}

var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise)
    return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root = require_root();
  var Promise = getNative(root, "Promise");
  _Promise = Promise;
  return _Promise;
}

var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set)
    return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root = require_root();
  var Set = getNative(root, "Set");
  _Set = Set;
  return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap)
    return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root = require_root();
  var WeakMap = getNative(root, "WeakMap");
  _WeakMap = WeakMap;
  return _WeakMap;
}

var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag)
    return _getTag;
  hasRequired_getTag = 1;
  var DataView = require_DataView(), Map = require_Map(), Promise = require_Promise(), Set = require_Set(), WeakMap = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}

var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray)
    return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray;
  return _initCloneArray;
}

var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array)
    return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root = require_root();
  var Uint8Array = root.Uint8Array;
  _Uint8Array = Uint8Array;
  return _Uint8Array;
}

var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer)
    return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}

var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView)
    return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView;
  return _cloneDataView;
}

var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp)
    return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp;
  return _cloneRegExp;
}

var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol)
    return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol = require_Symbol();
  var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  _cloneSymbol = cloneSymbol;
  return _cloneSymbol;
}

var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray)
    return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}

var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag)
    return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
  var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);
    case boolTag:
    case dateTag:
      return new Ctor(+object);
    case dataViewTag:
      return cloneDataView(object, isDeep);
    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);
    case mapTag:
      return new Ctor();
    case numberTag:
    case stringTag:
      return new Ctor(object);
    case regexpTag:
      return cloneRegExp(object);
    case setTag:
      return new Ctor();
    case symbolTag:
      return cloneSymbol(object);
    }
  }
  _initCloneByTag = initCloneByTag;
  return _initCloneByTag;
}

var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate)
    return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject = requireIsObject();
  var objectCreate = Object.create;
  var baseCreate = (function () {
    function object() {
    }
    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }());
  _baseCreate = baseCreate;
  return _baseCreate;
}

var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject)
    return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype = require_isPrototype();
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}

var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap)
    return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
  var mapTag = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  _baseIsMap = baseIsMap;
  return _baseIsMap;
}

var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap)
    return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  isMap_1 = isMap;
  return isMap_1;
}

var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet)
    return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
  var setTag = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  _baseIsSet = baseIsSet;
  return _baseIsSet;
}

var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet)
    return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  isSet_1 = isSet;
  return isSet_1;
}

var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone)
    return _baseClone;
  hasRequired_baseClone = 1;
  var Stack = require_Stack(), arrayEach = require_arrayEach(), assignValue = require_assignValue(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray = requireIsArray(), isBuffer = requireIsBuffer(), isMap = requireIsMap(), isObject = requireIsObject(), isSet = requireIsSet(), keys = requireKeys(), keysIn = requireKeysIn();
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }
  _baseClone = baseClone;
  return _baseClone;
}

var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone_1;
  hasRequiredClone = 1;
  var baseClone = require_baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  clone_1 = clone;
  return clone_1;
}

var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor)
    return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor)
    return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}

var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn)
    return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys = requireKeys();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}

var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach)
    return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}

var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach)
    return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}

var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity_1;
  hasRequiredIdentity = 1;
  function identity(value) {
    return value;
  }
  identity_1 = identity;
  return identity_1;
}

var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction)
    return _castFunction;
  hasRequired_castFunction = 1;
  var identity = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity;
  }
  _castFunction = castFunction;
  return _castFunction;
}

var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}

var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach)
    return each;
  hasRequiredEach = 1;
  each = requireForEach();
  return each;
}

var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd)
    return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}

var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas)
    return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}

var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache)
    return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}

var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex)
    return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}

var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN)
    return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}

var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf)
    return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}

var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf)
    return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}

var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes)
    return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}

var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith)
    return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}

var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas)
    return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}

var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop_1;
  hasRequiredNoop = 1;
  function noop() {
  }
  noop_1 = noop;
  return noop_1;
}

var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray)
    return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}

var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet)
    return _createSet;
  hasRequired_createSet = 1;
  var Set = require_Set(), noop = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
  ]))[1] == INFINITY) ? noop : function (values) {
    return new Set(values);
  };
  _createSet = createSet;
  return _createSet;
}

var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq)
    return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}

var uniq_1;
var hasRequiredUniq;
function requireUniq() {
  if (hasRequiredUniq)
    return uniq_1;
  hasRequiredUniq = 1;
  var baseUniq = require_baseUniq();
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  uniq_1 = uniq;
  return uniq_1;
}

var init = {};

var definitions = {};

var hasRequiredDefinitions;
function requireDefinitions() {
  if (hasRequiredDefinitions)
    return definitions;
  hasRequiredDefinitions = 1;
  definitions.__esModule = true;
  definitions.DEPRECATED_KEYS = definitions.BUILDER_KEYS = definitions.NODE_FIELDS = definitions.ALIAS_KEYS = definitions.VISITOR_KEYS = undefined;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  var _stringify = requireStringify();
  var _stringify2 = _interopRequireDefault(_stringify);
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  definitions.assertEach = assertEach;
  definitions.assertOneOf = assertOneOf;
  definitions.assertNodeType = assertNodeType;
  definitions.assertNodeOrValueType = assertNodeOrValueType;
  definitions.assertValueType = assertValueType;
  definitions.chain = chain;
  definitions.default = defineType;
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var VISITOR_KEYS = definitions.VISITOR_KEYS = {};
  var ALIAS_KEYS = definitions.ALIAS_KEYS = {};
  var NODE_FIELDS = definitions.NODE_FIELDS = {};
  var BUILDER_KEYS = definitions.BUILDER_KEYS = {};
  var DEPRECATED_KEYS = definitions.DEPRECATED_KEYS = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else if (val === undefined) {
      return "undefined";
    } else {
      return typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val);
    }
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val))
        return;
      for (var i = 0; i < val.length; i++) {
        callback(node, key + "[" + i + "]", val[i]);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {
      vals[_key] = arguments[_key];
    }
    function validate(node, key, val) {
      if (vals.indexOf(val) < 0) {
        throw new TypeError("Property " + key + " expected value to be one of " + (0, _stringify2.default)(vals) + " but got " + (0, _stringify2.default)(val));
      }
    }
    validate.oneOf = vals;
    return validate;
  }
  function assertNodeType() {
    for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }
    function validate(node, key, val) {
      var valid = false;
      for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var type = _ref;
        if (t.is(type, val)) {
          valid = true;
          break;
        }
      }
      if (!valid) {
        throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
      }
    }
    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }
    function validate(node, key, val) {
      var valid = false;
      for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var type = _ref2;
        if (getType(val) === type || t.is(type, val)) {
          valid = true;
          break;
        }
      }
      if (!valid) {
        throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
      }
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      var valid = getType(val) === type;
      if (!valid) {
        throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
      }
    }
    validate.type = type;
    return validate;
  }
  function chain() {
    for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }
    function validate() {
      for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var fn = _ref3;
        fn.apply(undefined, arguments);
      }
    }
    validate.chainOf = fns;
    return validate;
  }
  function defineType(type) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var inherits = opts.inherits && store[opts.inherits] || {};
    opts.fields = opts.fields || inherits.fields || {};
    opts.visitor = opts.visitor || inherits.visitor || [];
    opts.aliases = opts.aliases || inherits.aliases || [];
    opts.builder = opts.builder || inherits.builder || opts.visitor || [];
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref4;
      if (_isArray4) {
        if (_i4 >= _iterator4.length)
          break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done)
          break;
        _ref4 = _i4.value;
      }
      var _key5 = _ref4;
      opts.fields[_key5] = opts.fields[_key5] || {};
    }
    for (var key in opts.fields) {
      var field = opts.fields[key];
      if (opts.builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate) {
        field.validate = assertValueType(getType(field.default));
      }
    }
    VISITOR_KEYS[type] = opts.visitor;
    BUILDER_KEYS[type] = opts.builder;
    NODE_FIELDS[type] = opts.fields;
    ALIAS_KEYS[type] = opts.aliases;
    store[type] = opts;
  }
  var store = {};
  return definitions;
}

var core = {};

var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core;
  hasRequiredCore = 1;
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  var _constants = requireConstants();
  var _index2 = requireDefinitions();
  var _index3 = _interopRequireDefault(_index2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  (0, _index3.default)("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _index3.default)("AssignmentExpression", {
    fields: {
      operator: { validate: (0, _index2.assertValueType)("string") },
      left: { validate: (0, _index2.assertNodeType)("LVal") },
      right: { validate: (0, _index2.assertNodeType)("Expression") }
    },
    builder: [
      "operator",
      "left",
      "right"
    ],
    visitor: [
      "left",
      "right"
    ],
    aliases: ["Expression"]
  });
  (0, _index3.default)("BinaryExpression", {
    builder: [
      "operator",
      "left",
      "right"
    ],
    fields: {
      operator: { validate: _index2.assertOneOf.apply(undefined, _constants.BINARY_OPERATORS) },
      left: { validate: (0, _index2.assertNodeType)("Expression") },
      right: { validate: (0, _index2.assertNodeType)("Expression") }
    },
    visitor: [
      "left",
      "right"
    ],
    aliases: [
      "Binary",
      "Expression"
    ]
  });
  (0, _index3.default)("Directive", {
    visitor: ["value"],
    fields: { value: { validate: (0, _index2.assertNodeType)("DirectiveLiteral") } }
  });
  (0, _index3.default)("DirectiveLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _index2.assertValueType)("string") } }
  });
  (0, _index3.default)("BlockStatement", {
    builder: [
      "body",
      "directives"
    ],
    visitor: [
      "directives",
      "body"
    ],
    fields: {
      directives: {
        validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
        default: []
      },
      body: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement"))) }
    },
    aliases: [
      "Scopable",
      "BlockParent",
      "Block",
      "Statement"
    ]
  });
  (0, _index3.default)("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _index2.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: [
      "Statement",
      "Terminatorless",
      "CompletionStatement"
    ]
  });
  (0, _index3.default)("CallExpression", {
    visitor: [
      "callee",
      "arguments"
    ],
    fields: {
      callee: { validate: (0, _index2.assertNodeType)("Expression") },
      arguments: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement"))) }
    },
    aliases: ["Expression"]
  });
  (0, _index3.default)("CatchClause", {
    visitor: [
      "param",
      "body"
    ],
    fields: {
      param: { validate: (0, _index2.assertNodeType)("Identifier") },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement") }
    },
    aliases: ["Scopable"]
  });
  (0, _index3.default)("ConditionalExpression", {
    visitor: [
      "test",
      "consequent",
      "alternate"
    ],
    fields: {
      test: { validate: (0, _index2.assertNodeType)("Expression") },
      consequent: { validate: (0, _index2.assertNodeType)("Expression") },
      alternate: { validate: (0, _index2.assertNodeType)("Expression") }
    },
    aliases: [
      "Expression",
      "Conditional"
    ]
  });
  (0, _index3.default)("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _index2.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: [
      "Statement",
      "Terminatorless",
      "CompletionStatement"
    ]
  });
  (0, _index3.default)("DebuggerStatement", { aliases: ["Statement"] });
  (0, _index3.default)("DoWhileStatement", {
    visitor: [
      "test",
      "body"
    ],
    fields: {
      test: { validate: (0, _index2.assertNodeType)("Expression") },
      body: { validate: (0, _index2.assertNodeType)("Statement") }
    },
    aliases: [
      "Statement",
      "BlockParent",
      "Loop",
      "While",
      "Scopable"
    ]
  });
  (0, _index3.default)("EmptyStatement", { aliases: ["Statement"] });
  (0, _index3.default)("ExpressionStatement", {
    visitor: ["expression"],
    fields: { expression: { validate: (0, _index2.assertNodeType)("Expression") } },
    aliases: [
      "Statement",
      "ExpressionWrapper"
    ]
  });
  (0, _index3.default)("File", {
    builder: [
      "program",
      "comments",
      "tokens"
    ],
    visitor: ["program"],
    fields: { program: { validate: (0, _index2.assertNodeType)("Program") } }
  });
  (0, _index3.default)("ForInStatement", {
    visitor: [
      "left",
      "right",
      "body"
    ],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement"
    ],
    fields: {
      left: { validate: (0, _index2.assertNodeType)("VariableDeclaration", "LVal") },
      right: { validate: (0, _index2.assertNodeType)("Expression") },
      body: { validate: (0, _index2.assertNodeType)("Statement") }
    }
  });
  (0, _index3.default)("ForStatement", {
    visitor: [
      "init",
      "test",
      "update",
      "body"
    ],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop"
    ],
    fields: {
      init: {
        validate: (0, _index2.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _index2.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _index2.assertNodeType)("Expression"),
        optional: true
      },
      body: { validate: (0, _index2.assertNodeType)("Statement") }
    }
  });
  (0, _index3.default)("FunctionDeclaration", {
    builder: [
      "id",
      "params",
      "body",
      "generator",
      "async"
    ],
    visitor: [
      "id",
      "params",
      "body",
      "returnType",
      "typeParameters"
    ],
    fields: {
      id: { validate: (0, _index2.assertNodeType)("Identifier") },
      params: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal"))) },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement") },
      generator: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      },
      async: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      }
    },
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Statement",
      "Pureish",
      "Declaration"
    ]
  });
  (0, _index3.default)("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish"
    ],
    fields: {
      id: {
        validate: (0, _index2.assertNodeType)("Identifier"),
        optional: true
      },
      params: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal"))) },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement") },
      generator: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      },
      async: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      }
    }
  });
  (0, _index3.default)("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation"],
    aliases: [
      "Expression",
      "LVal"
    ],
    fields: {
      name: {
        validate: function validate(node, key, val) {
          if (!t.isValidIdentifier(val)) ;
        }
      },
      decorators: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index3.default)("IfStatement", {
    visitor: [
      "test",
      "consequent",
      "alternate"
    ],
    aliases: [
      "Statement",
      "Conditional"
    ],
    fields: {
      test: { validate: (0, _index2.assertNodeType)("Expression") },
      consequent: { validate: (0, _index2.assertNodeType)("Statement") },
      alternate: {
        optional: true,
        validate: (0, _index2.assertNodeType)("Statement")
      }
    }
  });
  (0, _index3.default)("LabeledStatement", {
    visitor: [
      "label",
      "body"
    ],
    aliases: ["Statement"],
    fields: {
      label: { validate: (0, _index2.assertNodeType)("Identifier") },
      body: { validate: (0, _index2.assertNodeType)("Statement") }
    }
  });
  (0, _index3.default)("StringLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _index2.assertValueType)("string") } },
    aliases: [
      "Expression",
      "Pureish",
      "Literal",
      "Immutable"
    ]
  });
  (0, _index3.default)("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: { value: { validate: (0, _index2.assertValueType)("number") } },
    aliases: [
      "Expression",
      "Pureish",
      "Literal",
      "Immutable"
    ]
  });
  (0, _index3.default)("NullLiteral", {
    aliases: [
      "Expression",
      "Pureish",
      "Literal",
      "Immutable"
    ]
  });
  (0, _index3.default)("BooleanLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _index2.assertValueType)("boolean") } },
    aliases: [
      "Expression",
      "Pureish",
      "Literal",
      "Immutable"
    ]
  });
  (0, _index3.default)("RegExpLiteral", {
    builder: [
      "pattern",
      "flags"
    ],
    deprecatedAlias: "RegexLiteral",
    aliases: [
      "Expression",
      "Literal"
    ],
    fields: {
      pattern: { validate: (0, _index2.assertValueType)("string") },
      flags: {
        validate: (0, _index2.assertValueType)("string"),
        default: ""
      }
    }
  });
  (0, _index3.default)("LogicalExpression", {
    builder: [
      "operator",
      "left",
      "right"
    ],
    visitor: [
      "left",
      "right"
    ],
    aliases: [
      "Binary",
      "Expression"
    ],
    fields: {
      operator: { validate: _index2.assertOneOf.apply(undefined, _constants.LOGICAL_OPERATORS) },
      left: { validate: (0, _index2.assertNodeType)("Expression") },
      right: { validate: (0, _index2.assertNodeType)("Expression") }
    }
  });
  (0, _index3.default)("MemberExpression", {
    builder: [
      "object",
      "property",
      "computed"
    ],
    visitor: [
      "object",
      "property"
    ],
    aliases: [
      "Expression",
      "LVal"
    ],
    fields: {
      object: { validate: (0, _index2.assertNodeType)("Expression") },
      property: {
        validate: function validate(node, key, val) {
          var expectedType = node.computed ? "Expression" : "Identifier";
          (0, _index2.assertNodeType)(expectedType)(node, key, val);
        }
      },
      computed: { default: false }
    }
  });
  (0, _index3.default)("NewExpression", {
    visitor: [
      "callee",
      "arguments"
    ],
    aliases: ["Expression"],
    fields: {
      callee: { validate: (0, _index2.assertNodeType)("Expression") },
      arguments: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement"))) }
    }
  });
  (0, _index3.default)("Program", {
    visitor: [
      "directives",
      "body"
    ],
    builder: [
      "body",
      "directives"
    ],
    fields: {
      directives: {
        validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
        default: []
      },
      body: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement"))) }
    },
    aliases: [
      "Scopable",
      "BlockParent",
      "Block",
      "FunctionParent"
    ]
  });
  (0, _index3.default)("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: { properties: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadProperty"))) } }
  });
  (0, _index3.default)("ObjectMethod", {
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed"
    ],
    fields: {
      kind: {
        validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("method", "get", "set")),
        default: "method"
      },
      computed: {
        validate: (0, _index2.assertValueType)("boolean"),
        default: false
      },
      key: {
        validate: function validate(node, key, val) {
          var expectedTypes = node.computed ? ["Expression"] : [
            "Identifier",
            "StringLiteral",
            "NumericLiteral"
          ];
          _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
        }
      },
      decorators: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))) },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement") },
      generator: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      },
      async: {
        default: false,
        validate: (0, _index2.assertValueType)("boolean")
      }
    },
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters"
    ],
    aliases: [
      "UserWhitespacable",
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
      "ObjectMember"
    ]
  });
  (0, _index3.default)("ObjectProperty", {
    builder: [
      "key",
      "value",
      "computed",
      "shorthand",
      "decorators"
    ],
    fields: {
      computed: {
        validate: (0, _index2.assertValueType)("boolean"),
        default: false
      },
      key: {
        validate: function validate(node, key, val) {
          var expectedTypes = node.computed ? ["Expression"] : [
            "Identifier",
            "StringLiteral",
            "NumericLiteral"
          ];
          _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
        }
      },
      value: { validate: (0, _index2.assertNodeType)("Expression") },
      shorthand: {
        validate: (0, _index2.assertValueType)("boolean"),
        default: false
      },
      decorators: {
        validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))),
        optional: true
      }
    },
    visitor: [
      "key",
      "value",
      "decorators"
    ],
    aliases: [
      "UserWhitespacable",
      "Property",
      "ObjectMember"
    ]
  });
  (0, _index3.default)("RestElement", {
    visitor: [
      "argument",
      "typeAnnotation"
    ],
    aliases: ["LVal"],
    fields: {
      argument: { validate: (0, _index2.assertNodeType)("LVal") },
      decorators: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index3.default)("ReturnStatement", {
    visitor: ["argument"],
    aliases: [
      "Statement",
      "Terminatorless",
      "CompletionStatement"
    ],
    fields: {
      argument: {
        validate: (0, _index2.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  (0, _index3.default)("SequenceExpression", {
    visitor: ["expressions"],
    fields: { expressions: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression"))) } },
    aliases: ["Expression"]
  });
  (0, _index3.default)("SwitchCase", {
    visitor: [
      "test",
      "consequent"
    ],
    fields: {
      test: {
        validate: (0, _index2.assertNodeType)("Expression"),
        optional: true
      },
      consequent: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement"))) }
    }
  });
  (0, _index3.default)("SwitchStatement", {
    visitor: [
      "discriminant",
      "cases"
    ],
    aliases: [
      "Statement",
      "BlockParent",
      "Scopable"
    ],
    fields: {
      discriminant: { validate: (0, _index2.assertNodeType)("Expression") },
      cases: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("SwitchCase"))) }
    }
  });
  (0, _index3.default)("ThisExpression", { aliases: ["Expression"] });
  (0, _index3.default)("ThrowStatement", {
    visitor: ["argument"],
    aliases: [
      "Statement",
      "Terminatorless",
      "CompletionStatement"
    ],
    fields: { argument: { validate: (0, _index2.assertNodeType)("Expression") } }
  });
  (0, _index3.default)("TryStatement", {
    visitor: [
      "block",
      "handler",
      "finalizer"
    ],
    aliases: ["Statement"],
    fields: {
      body: { validate: (0, _index2.assertNodeType)("BlockStatement") },
      handler: {
        optional: true,
        handler: (0, _index2.assertNodeType)("BlockStatement")
      },
      finalizer: {
        optional: true,
        validate: (0, _index2.assertNodeType)("BlockStatement")
      }
    }
  });
  (0, _index3.default)("UnaryExpression", {
    builder: [
      "operator",
      "argument",
      "prefix"
    ],
    fields: {
      prefix: { default: true },
      argument: { validate: (0, _index2.assertNodeType)("Expression") },
      operator: { validate: _index2.assertOneOf.apply(undefined, _constants.UNARY_OPERATORS) }
    },
    visitor: ["argument"],
    aliases: [
      "UnaryLike",
      "Expression"
    ]
  });
  (0, _index3.default)("UpdateExpression", {
    builder: [
      "operator",
      "argument",
      "prefix"
    ],
    fields: {
      prefix: { default: false },
      argument: { validate: (0, _index2.assertNodeType)("Expression") },
      operator: { validate: _index2.assertOneOf.apply(undefined, _constants.UPDATE_OPERATORS) }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  (0, _index3.default)("VariableDeclaration", {
    builder: [
      "kind",
      "declarations"
    ],
    visitor: ["declarations"],
    aliases: [
      "Statement",
      "Declaration"
    ],
    fields: {
      kind: { validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("var", "let", "const")) },
      declarations: { validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("VariableDeclarator"))) }
    }
  });
  (0, _index3.default)("VariableDeclarator", {
    visitor: [
      "id",
      "init"
    ],
    fields: {
      id: { validate: (0, _index2.assertNodeType)("LVal") },
      init: {
        optional: true,
        validate: (0, _index2.assertNodeType)("Expression")
      }
    }
  });
  (0, _index3.default)("WhileStatement", {
    visitor: [
      "test",
      "body"
    ],
    aliases: [
      "Statement",
      "BlockParent",
      "Loop",
      "While",
      "Scopable"
    ],
    fields: {
      test: { validate: (0, _index2.assertNodeType)("Expression") },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement", "Statement") }
    }
  });
  (0, _index3.default)("WithStatement", {
    visitor: [
      "object",
      "body"
    ],
    aliases: ["Statement"],
    fields: {
      object: { object: (0, _index2.assertNodeType)("Expression") },
      body: { validate: (0, _index2.assertNodeType)("BlockStatement", "Statement") }
    }
  });
  return core;
}

var es2015 = {};

var hasRequiredEs2015;
function requireEs2015() {
  if (hasRequiredEs2015)
    return es2015;
  hasRequiredEs2015 = 1;
  var _index = requireDefinitions();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  (0, _index2.default)("AssignmentPattern", {
    visitor: [
      "left",
      "right"
    ],
    aliases: [
      "Pattern",
      "LVal"
    ],
    fields: {
      left: { validate: (0, _index.assertNodeType)("Identifier") },
      right: { validate: (0, _index.assertNodeType)("Expression") },
      decorators: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index2.default)("ArrayPattern", {
    visitor: [
      "elements",
      "typeAnnotation"
    ],
    aliases: [
      "Pattern",
      "LVal"
    ],
    fields: {
      elements: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression"))) },
      decorators: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index2.default)("ArrowFunctionExpression", {
    builder: [
      "params",
      "body",
      "async"
    ],
    visitor: [
      "params",
      "body",
      "returnType",
      "typeParameters"
    ],
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish"
    ],
    fields: {
      params: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal"))) },
      body: { validate: (0, _index.assertNodeType)("BlockStatement", "Expression") },
      async: {
        validate: (0, _index.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _index2.default)("ClassBody", {
    visitor: ["body"],
    fields: { body: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ClassMethod", "ClassProperty"))) } }
  });
  (0, _index2.default)("ClassDeclaration", {
    builder: [
      "id",
      "superClass",
      "body",
      "decorators"
    ],
    visitor: [
      "id",
      "body",
      "superClass",
      "mixins",
      "typeParameters",
      "superTypeParameters",
      "implements",
      "decorators"
    ],
    aliases: [
      "Scopable",
      "Class",
      "Statement",
      "Declaration",
      "Pureish"
    ],
    fields: {
      id: { validate: (0, _index.assertNodeType)("Identifier") },
      body: { validate: (0, _index.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _index.assertNodeType)("Expression")
      },
      decorators: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index2.default)("ClassExpression", {
    inherits: "ClassDeclaration",
    aliases: [
      "Scopable",
      "Class",
      "Expression",
      "Pureish"
    ],
    fields: {
      id: {
        optional: true,
        validate: (0, _index.assertNodeType)("Identifier")
      },
      body: { validate: (0, _index.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _index.assertNodeType)("Expression")
      },
      decorators: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index2.default)("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration"
    ],
    fields: { source: { validate: (0, _index.assertNodeType)("StringLiteral") } }
  });
  (0, _index2.default)("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration"
    ],
    fields: { declaration: { validate: (0, _index.assertNodeType)("FunctionDeclaration", "ClassDeclaration", "Expression") } }
  });
  (0, _index2.default)("ExportNamedDeclaration", {
    visitor: [
      "declaration",
      "specifiers",
      "source"
    ],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration"
    ],
    fields: {
      declaration: {
        validate: (0, _index.assertNodeType)("Declaration"),
        optional: true
      },
      specifiers: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ExportSpecifier"))) },
      source: {
        validate: (0, _index.assertNodeType)("StringLiteral"),
        optional: true
      }
    }
  });
  (0, _index2.default)("ExportSpecifier", {
    visitor: [
      "local",
      "exported"
    ],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _index.assertNodeType)("Identifier") },
      exported: { validate: (0, _index.assertNodeType)("Identifier") }
    }
  });
  (0, _index2.default)("ForOfStatement", {
    visitor: [
      "left",
      "right",
      "body"
    ],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement"
    ],
    fields: {
      left: { validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal") },
      right: { validate: (0, _index.assertNodeType)("Expression") },
      body: { validate: (0, _index.assertNodeType)("Statement") }
    }
  });
  (0, _index2.default)("ImportDeclaration", {
    visitor: [
      "specifiers",
      "source"
    ],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration"
    ],
    fields: {
      specifiers: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) },
      source: { validate: (0, _index.assertNodeType)("StringLiteral") }
    }
  });
  (0, _index2.default)("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _index.assertNodeType)("Identifier") } }
  });
  (0, _index2.default)("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _index.assertNodeType)("Identifier") } }
  });
  (0, _index2.default)("ImportSpecifier", {
    visitor: [
      "local",
      "imported"
    ],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _index.assertNodeType)("Identifier") },
      imported: { validate: (0, _index.assertNodeType)("Identifier") }
    }
  });
  (0, _index2.default)("MetaProperty", {
    visitor: [
      "meta",
      "property"
    ],
    aliases: ["Expression"],
    fields: {
      meta: { validate: (0, _index.assertValueType)("string") },
      property: { validate: (0, _index.assertValueType)("string") }
    }
  });
  (0, _index2.default)("ClassMethod", {
    aliases: [
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method"
    ],
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed",
      "static"
    ],
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters"
    ],
    fields: {
      kind: {
        validate: (0, _index.chain)((0, _index.assertValueType)("string"), (0, _index.assertOneOf)("get", "set", "method", "constructor")),
        default: "method"
      },
      computed: {
        default: false,
        validate: (0, _index.assertValueType)("boolean")
      },
      static: {
        default: false,
        validate: (0, _index.assertValueType)("boolean")
      },
      key: {
        validate: function validate(node, key, val) {
          var expectedTypes = node.computed ? ["Expression"] : [
            "Identifier",
            "StringLiteral",
            "NumericLiteral"
          ];
          _index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
        }
      },
      params: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal"))) },
      body: { validate: (0, _index.assertNodeType)("BlockStatement") },
      generator: {
        default: false,
        validate: (0, _index.assertValueType)("boolean")
      },
      async: {
        default: false,
        validate: (0, _index.assertValueType)("boolean")
      }
    }
  });
  (0, _index2.default)("ObjectPattern", {
    visitor: [
      "properties",
      "typeAnnotation"
    ],
    aliases: [
      "Pattern",
      "LVal"
    ],
    fields: {
      properties: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("RestProperty", "Property"))) },
      decorators: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator"))) }
    }
  });
  (0, _index2.default)("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    fields: { argument: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("Super", { aliases: ["Expression"] });
  (0, _index2.default)("TaggedTemplateExpression", {
    visitor: [
      "tag",
      "quasi"
    ],
    aliases: ["Expression"],
    fields: {
      tag: { validate: (0, _index.assertNodeType)("Expression") },
      quasi: { validate: (0, _index.assertNodeType)("TemplateLiteral") }
    }
  });
  (0, _index2.default)("TemplateElement", {
    builder: [
      "value",
      "tail"
    ],
    fields: {
      value: {},
      tail: {
        validate: (0, _index.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _index2.default)("TemplateLiteral", {
    visitor: [
      "quasis",
      "expressions"
    ],
    aliases: [
      "Expression",
      "Literal"
    ],
    fields: {
      quasis: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("TemplateElement"))) },
      expressions: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression"))) }
    }
  });
  (0, _index2.default)("YieldExpression", {
    builder: [
      "argument",
      "delegate"
    ],
    visitor: ["argument"],
    aliases: [
      "Expression",
      "Terminatorless"
    ],
    fields: {
      delegate: {
        validate: (0, _index.assertValueType)("boolean"),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _index.assertNodeType)("Expression")
      }
    }
  });
  return es2015;
}

var flow$1 = {};

var hasRequiredFlow$1;
function requireFlow$1() {
  if (hasRequiredFlow$1)
    return flow$1;
  hasRequiredFlow$1 = 1;
  var _index = requireDefinitions();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  (0, _index2.default)("AnyTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("BooleanTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("BooleanLiteralTypeAnnotation", {
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("NullLiteralTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("ClassImplements", {
    visitor: [
      "id",
      "typeParameters"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("ClassProperty", {
    visitor: [
      "key",
      "value",
      "typeAnnotation",
      "decorators"
    ],
    builder: [
      "key",
      "value",
      "typeAnnotation",
      "decorators",
      "computed"
    ],
    aliases: ["Property"],
    fields: {
      computed: {
        validate: (0, _index.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _index2.default)("DeclareClass", {
    visitor: [
      "id",
      "typeParameters",
      "extends",
      "body"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareFunction", {
    visitor: ["id"],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareInterface", {
    visitor: [
      "id",
      "typeParameters",
      "extends",
      "body"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareModule", {
    visitor: [
      "id",
      "body"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareTypeAlias", {
    visitor: [
      "id",
      "typeParameters",
      "right"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("DeclareVariable", {
    visitor: ["id"],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("ExistentialTypeParam", { aliases: ["Flow"] });
  (0, _index2.default)("FunctionTypeAnnotation", {
    visitor: [
      "typeParameters",
      "params",
      "rest",
      "returnType"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("FunctionTypeParam", {
    visitor: [
      "name",
      "typeAnnotation"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("GenericTypeAnnotation", {
    visitor: [
      "id",
      "typeParameters"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("InterfaceExtends", {
    visitor: [
      "id",
      "typeParameters"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("InterfaceDeclaration", {
    visitor: [
      "id",
      "typeParameters",
      "extends",
      "body"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("MixedTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ]
  });
  (0, _index2.default)("EmptyTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ]
  });
  (0, _index2.default)("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("NumericLiteralTypeAnnotation", {
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("NumberTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("StringLiteralTypeAnnotation", {
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("StringTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("ThisTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  (0, _index2.default)("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("TypeAlias", {
    visitor: [
      "id",
      "typeParameters",
      "right"
    ],
    aliases: [
      "Flow",
      "FlowDeclaration",
      "Statement",
      "Declaration"
    ],
    fields: {}
  });
  (0, _index2.default)("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("TypeCastExpression", {
    visitor: [
      "expression",
      "typeAnnotation"
    ],
    aliases: [
      "Flow",
      "ExpressionWrapper",
      "Expression"
    ],
    fields: {}
  });
  (0, _index2.default)("TypeParameter", {
    visitor: ["bound"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("TypeParameterDeclaration", {
    visitor: ["params"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("TypeParameterInstantiation", {
    visitor: ["params"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("ObjectTypeAnnotation", {
    visitor: [
      "properties",
      "indexers",
      "callProperties"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: [
      "Flow",
      "UserWhitespacable"
    ],
    fields: {}
  });
  (0, _index2.default)("ObjectTypeIndexer", {
    visitor: [
      "id",
      "key",
      "value"
    ],
    aliases: [
      "Flow",
      "UserWhitespacable"
    ],
    fields: {}
  });
  (0, _index2.default)("ObjectTypeProperty", {
    visitor: [
      "key",
      "value"
    ],
    aliases: [
      "Flow",
      "UserWhitespacable"
    ],
    fields: {}
  });
  (0, _index2.default)("QualifiedTypeIdentifier", {
    visitor: [
      "id",
      "qualification"
    ],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow"],
    fields: {}
  });
  (0, _index2.default)("VoidTypeAnnotation", {
    aliases: [
      "Flow",
      "FlowBaseAnnotation"
    ],
    fields: {}
  });
  return flow$1;
}

var jsx$1 = {};

var hasRequiredJsx$1;
function requireJsx$1() {
  if (hasRequiredJsx$1)
    return jsx$1;
  hasRequiredJsx$1 = 1;
  var _index = requireDefinitions();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  (0, _index2.default)("JSXAttribute", {
    visitor: [
      "name",
      "value"
    ],
    aliases: [
      "JSX",
      "Immutable"
    ],
    fields: {
      name: { validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXNamespacedName") },
      value: {
        optional: true,
        validate: (0, _index.assertNodeType)("JSXElement", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  (0, _index2.default)("JSXClosingElement", {
    visitor: ["name"],
    aliases: [
      "JSX",
      "Immutable"
    ],
    fields: { name: { validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression") } }
  });
  (0, _index2.default)("JSXElement", {
    builder: [
      "openingElement",
      "closingElement",
      "children",
      "selfClosing"
    ],
    visitor: [
      "openingElement",
      "children",
      "closingElement"
    ],
    aliases: [
      "JSX",
      "Immutable",
      "Expression"
    ],
    fields: {
      openingElement: { validate: (0, _index.assertNodeType)("JSXOpeningElement") },
      closingElement: {
        optional: true,
        validate: (0, _index.assertNodeType)("JSXClosingElement")
      },
      children: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement"))) }
    }
  });
  (0, _index2.default)("JSXEmptyExpression", {
    aliases: [
      "JSX",
      "Expression"
    ]
  });
  (0, _index2.default)("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: [
      "JSX",
      "Immutable"
    ],
    fields: { expression: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: [
      "JSX",
      "Immutable"
    ],
    fields: { expression: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("JSXIdentifier", {
    builder: ["name"],
    aliases: [
      "JSX",
      "Expression"
    ],
    fields: { name: { validate: (0, _index.assertValueType)("string") } }
  });
  (0, _index2.default)("JSXMemberExpression", {
    visitor: [
      "object",
      "property"
    ],
    aliases: [
      "JSX",
      "Expression"
    ],
    fields: {
      object: { validate: (0, _index.assertNodeType)("JSXMemberExpression", "JSXIdentifier") },
      property: { validate: (0, _index.assertNodeType)("JSXIdentifier") }
    }
  });
  (0, _index2.default)("JSXNamespacedName", {
    visitor: [
      "namespace",
      "name"
    ],
    aliases: ["JSX"],
    fields: {
      namespace: { validate: (0, _index.assertNodeType)("JSXIdentifier") },
      name: { validate: (0, _index.assertNodeType)("JSXIdentifier") }
    }
  });
  (0, _index2.default)("JSXOpeningElement", {
    builder: [
      "name",
      "attributes",
      "selfClosing"
    ],
    visitor: [
      "name",
      "attributes"
    ],
    aliases: [
      "JSX",
      "Immutable"
    ],
    fields: {
      name: { validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression") },
      selfClosing: {
        default: false,
        validate: (0, _index.assertValueType)("boolean")
      },
      attributes: { validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }
    }
  });
  (0, _index2.default)("JSXSpreadAttribute", {
    visitor: ["argument"],
    aliases: ["JSX"],
    fields: { argument: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("JSXText", {
    aliases: [
      "JSX",
      "Immutable"
    ],
    builder: ["value"],
    fields: { value: { validate: (0, _index.assertValueType)("string") } }
  });
  return jsx$1;
}

var misc = {};

var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  var _index = requireDefinitions();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  (0, _index2.default)("Noop", { visitor: [] });
  (0, _index2.default)("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: [
      "Expression",
      "ExpressionWrapper"
    ],
    fields: { expression: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  return misc;
}

var experimental = {};

var hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental)
    return experimental;
  hasRequiredExperimental = 1;
  var _index = requireDefinitions();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  (0, _index2.default)("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: [
      "Expression",
      "Terminatorless"
    ],
    fields: { argument: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("ForAwaitStatement", {
    visitor: [
      "left",
      "right",
      "body"
    ],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement"
    ],
    fields: {
      left: { validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal") },
      right: { validate: (0, _index.assertNodeType)("Expression") },
      body: { validate: (0, _index.assertNodeType)("Statement") }
    }
  });
  (0, _index2.default)("BindExpression", {
    visitor: [
      "object",
      "callee"
    ],
    aliases: ["Expression"],
    fields: {}
  });
  (0, _index2.default)("Import", { aliases: ["Expression"] });
  (0, _index2.default)("Decorator", {
    visitor: ["expression"],
    fields: { expression: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  (0, _index2.default)("DoExpression", {
    visitor: ["body"],
    aliases: ["Expression"],
    fields: { body: { validate: (0, _index.assertNodeType)("BlockStatement") } }
  });
  (0, _index2.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: { exported: { validate: (0, _index.assertNodeType)("Identifier") } }
  });
  (0, _index2.default)("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: { exported: { validate: (0, _index.assertNodeType)("Identifier") } }
  });
  (0, _index2.default)("RestProperty", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    fields: { argument: { validate: (0, _index.assertNodeType)("LVal") } }
  });
  (0, _index2.default)("SpreadProperty", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    fields: { argument: { validate: (0, _index.assertNodeType)("Expression") } }
  });
  return experimental;
}

var hasRequiredInit;
function requireInit() {
  if (hasRequiredInit)
    return init;
  hasRequiredInit = 1;
  requireDefinitions();
  requireCore();
  requireEs2015();
  requireFlow$1();
  requireJsx$1();
  requireMisc();
  requireExperimental();
  return init;
}

var react = {};

var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact)
    return react;
  hasRequiredReact = 1;
  react.__esModule = true;
  react.isReactComponent = undefined;
  react.isCompatTag = isCompatTag;
  react.buildChildren = buildChildren;
  var _index = requireLib$7();
  var t = _interopRequireWildcard(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  react.isReactComponent = t.buildMatchMemberExpression("React.Component");
  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]|\-/.test(tagName);
  }
  function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }
    var str = "";
    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str)
      args.push(t.stringLiteral(str));
  }
  function buildChildren(node) {
    var elems = [];
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (t.isJSXText(child)) {
        cleanJSXElementLiteralChild(child, elems);
        continue;
      }
      if (t.isJSXExpressionContainer(child))
        child = child.expression;
      if (t.isJSXEmptyExpression(child))
        continue;
      elems.push(child);
    }
    return elems;
  }
  return react;
}

var hasRequiredLib$7;
function requireLib$7() {
  if (hasRequiredLib$7)
    return lib$5;
  hasRequiredLib$7 = 1;
  (function (exports) {
    exports.__esModule = true;
    exports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;
    var _getOwnPropertySymbols = requireGetOwnPropertySymbols();
    var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _keys = requireKeys$1();
    var _keys2 = _interopRequireDefault(_keys);
    var _stringify = requireStringify();
    var _stringify2 = _interopRequireDefault(_stringify);
    var _constants = requireConstants();
    Object.defineProperty(exports, "STATEMENT_OR_BLOCK_KEYS", {
      enumerable: true,
      get: function get() {
        return _constants.STATEMENT_OR_BLOCK_KEYS;
      }
    });
    Object.defineProperty(exports, "FLATTENABLE_KEYS", {
      enumerable: true,
      get: function get() {
        return _constants.FLATTENABLE_KEYS;
      }
    });
    Object.defineProperty(exports, "FOR_INIT_KEYS", {
      enumerable: true,
      get: function get() {
        return _constants.FOR_INIT_KEYS;
      }
    });
    Object.defineProperty(exports, "COMMENT_KEYS", {
      enumerable: true,
      get: function get() {
        return _constants.COMMENT_KEYS;
      }
    });
    Object.defineProperty(exports, "LOGICAL_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.LOGICAL_OPERATORS;
      }
    });
    Object.defineProperty(exports, "UPDATE_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.UPDATE_OPERATORS;
      }
    });
    Object.defineProperty(exports, "BOOLEAN_NUMBER_BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "EQUALITY_BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.EQUALITY_BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "COMPARISON_BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.COMPARISON_BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "BOOLEAN_BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.BOOLEAN_BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "NUMBER_BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.NUMBER_BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "BINARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.BINARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "BOOLEAN_UNARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.BOOLEAN_UNARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "NUMBER_UNARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.NUMBER_UNARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "STRING_UNARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.STRING_UNARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "UNARY_OPERATORS", {
      enumerable: true,
      get: function get() {
        return _constants.UNARY_OPERATORS;
      }
    });
    Object.defineProperty(exports, "INHERIT_KEYS", {
      enumerable: true,
      get: function get() {
        return _constants.INHERIT_KEYS;
      }
    });
    Object.defineProperty(exports, "BLOCK_SCOPED_SYMBOL", {
      enumerable: true,
      get: function get() {
        return _constants.BLOCK_SCOPED_SYMBOL;
      }
    });
    Object.defineProperty(exports, "NOT_LOCAL_BINDING", {
      enumerable: true,
      get: function get() {
        return _constants.NOT_LOCAL_BINDING;
      }
    });
    exports.is = is;
    exports.isType = isType;
    exports.validate = validate;
    exports.shallowEqual = shallowEqual;
    exports.appendToMemberExpression = appendToMemberExpression;
    exports.prependToMemberExpression = prependToMemberExpression;
    exports.ensureBlock = ensureBlock;
    exports.clone = clone;
    exports.cloneWithoutLoc = cloneWithoutLoc;
    exports.cloneDeep = cloneDeep;
    exports.buildMatchMemberExpression = buildMatchMemberExpression;
    exports.removeComments = removeComments;
    exports.inheritsComments = inheritsComments;
    exports.inheritTrailingComments = inheritTrailingComments;
    exports.inheritLeadingComments = inheritLeadingComments;
    exports.inheritInnerComments = inheritInnerComments;
    exports.inherits = inherits;
    exports.assertNode = assertNode;
    exports.isNode = isNode;
    exports.traverseFast = traverseFast;
    exports.removeProperties = removeProperties;
    exports.removePropertiesDeep = removePropertiesDeep;
    var _retrievers = requireRetrievers();
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function get() {
        return _retrievers.getBindingIdentifiers;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function get() {
        return _retrievers.getOuterBindingIdentifiers;
      }
    });
    var _validators = requireValidators();
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function get() {
        return _validators.isBinding;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function get() {
        return _validators.isReferenced;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function get() {
        return _validators.isValidIdentifier;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function get() {
        return _validators.isLet;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function get() {
        return _validators.isBlockScoped;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function get() {
        return _validators.isVar;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function get() {
        return _validators.isSpecifierDefault;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function get() {
        return _validators.isScope;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function get() {
        return _validators.isImmutable;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function get() {
        return _validators.isNodesEquivalent;
      }
    });
    var _converters = requireConverters();
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function get() {
        return _converters.toComputedKey;
      }
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function get() {
        return _converters.toSequenceExpression;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function get() {
        return _converters.toKeyAlias;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function get() {
        return _converters.toIdentifier;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function get() {
        return _converters.toBindingIdentifierName;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function get() {
        return _converters.toStatement;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function get() {
        return _converters.toExpression;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function get() {
        return _converters.toBlock;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function get() {
        return _converters.valueToNode;
      }
    });
    var _flow = requireFlow$2();
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _flow.createUnionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function get() {
        return _flow.removeTypeDuplicates;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function get() {
        return _flow.createTypeAnnotationBasedOnTypeof;
      }
    });
    var _toFastProperties = require_1_0_1();
    var _toFastProperties2 = _interopRequireDefault(_toFastProperties);
    var _compact = requireCompact();
    var _compact2 = _interopRequireDefault(_compact);
    var _clone = requireClone();
    var _clone2 = _interopRequireDefault(_clone);
    var _each = requireEach();
    var _each2 = _interopRequireDefault(_each);
    var _uniq = requireUniq();
    var _uniq2 = _interopRequireDefault(_uniq);
    requireInit();
    var _definitions = requireDefinitions();
    var _react2 = requireReact();
    var _react = _interopRequireWildcard(_react2);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var t = exports;
    function registerType(type) {
      var is = t["is" + type];
      if (!is) {
        is = t["is" + type] = function (node, opts) {
          return t.is(type, node, opts);
        };
      }
      t["assert" + type] = function (node, opts) {
        opts = opts || {};
        if (!is(node, opts)) {
          throw new Error("Expected type " + (0, _stringify2.default)(type) + " with option " + (0, _stringify2.default)(opts));
        }
      };
    }
    exports.VISITOR_KEYS = _definitions.VISITOR_KEYS;
    exports.ALIAS_KEYS = _definitions.ALIAS_KEYS;
    exports.NODE_FIELDS = _definitions.NODE_FIELDS;
    exports.BUILDER_KEYS = _definitions.BUILDER_KEYS;
    exports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;
    exports.react = _react;
    for (var type in t.VISITOR_KEYS) {
      registerType(type);
    }
    t.FLIPPED_ALIAS_KEYS = {};
    (0, _each2.default)(t.ALIAS_KEYS, function (aliases, type) {
      (0, _each2.default)(aliases, function (alias) {
        var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
        types.push(type);
      });
    });
    (0, _each2.default)(t.FLIPPED_ALIAS_KEYS, function (types, type) {
      t[type.toUpperCase() + "_TYPES"] = types;
      registerType(type);
    });
    exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS));
    function is(type, node, opts) {
      if (!node)
        return false;
      var matches = isType(node.type, type);
      if (!matches)
        return false;
      if (typeof opts === "undefined") {
        return true;
      } else {
        return t.shallowEqual(node, opts);
      }
    }
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (t.ALIAS_KEYS[targetType])
        return false;
      var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var alias = _ref;
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
    (0, _each2.default)(t.BUILDER_KEYS, function (keys, type) {
      function builder() {
        if (arguments.length > keys.length) {
          throw new Error("t." + type + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length));
        }
        var node = {};
        node.type = type;
        var i = 0;
        for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var _key = _ref2;
          var field = t.NODE_FIELDS[type][_key];
          var arg = arguments[i++];
          if (arg === undefined)
            arg = (0, _clone2.default)(field.default);
          node[_key] = arg;
        }
        for (var key in node) {
          validate(node, key, node[key]);
        }
        return node;
      }
      t[type] = builder;
      t[type[0].toLowerCase() + type.slice(1)] = builder;
    });
    var _loop = function _loop(_type) {
      var newType = t.DEPRECATED_KEYS[_type];
      function proxy(fn) {
        return function () {
          console.trace("The node type " + _type + " has been renamed to " + newType);
          return fn.apply(this, arguments);
        };
      }
      t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]);
      t["is" + _type] = proxy(t["is" + newType]);
      t["assert" + _type] = proxy(t["assert" + newType]);
    };
    for (var _type in t.DEPRECATED_KEYS) {
      _loop(_type);
    }
    function validate(node, key, val) {
      if (!node)
        return;
      var fields = t.NODE_FIELDS[node.type];
      if (!fields)
        return;
      var field = fields[key];
      if (!field || !field.validate)
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    function shallowEqual(actual, expected) {
      var keys = (0, _keys2.default)(expected);
      for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var key = _ref3;
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
    function appendToMemberExpression(member, append, computed) {
      member.object = t.memberExpression(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
    function prependToMemberExpression(member, prepend) {
      member.object = t.memberExpression(prepend, member.object);
      return member;
    }
    function ensureBlock(node) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body";
      return node[key] = t.toBlock(node[key], node);
    }
    function clone(node) {
      if (!node)
        return node;
      var newNode = {};
      for (var key in node) {
        if (key[0] === "_")
          continue;
        newNode[key] = node[key];
      }
      return newNode;
    }
    function cloneWithoutLoc(node) {
      var newNode = clone(node);
      delete newNode.loc;
      return newNode;
    }
    function cloneDeep(node) {
      if (!node)
        return node;
      var newNode = {};
      for (var key in node) {
        if (key[0] === "_")
          continue;
        var val = node[key];
        if (val) {
          if (val.type) {
            val = t.cloneDeep(val);
          } else if (Array.isArray(val)) {
            val = val.map(t.cloneDeep);
          }
        }
        newNode[key] = val;
      }
      return newNode;
    }
    function buildMatchMemberExpression(match, allowPartial) {
      var parts = match.split(".");
      return function (member) {
        if (!t.isMemberExpression(member))
          return false;
        var search = [member];
        var i = 0;
        while (search.length) {
          var node = search.shift();
          if (allowPartial && i === parts.length) {
            return true;
          }
          if (t.isIdentifier(node)) {
            if (parts[i] !== node.name)
              return false;
          } else if (t.isStringLiteral(node)) {
            if (parts[i] !== node.value)
              return false;
          } else if (t.isMemberExpression(node)) {
            if (node.computed && !t.isStringLiteral(node.property)) {
              return false;
            } else {
              search.push(node.object);
              search.push(node.property);
              continue;
            }
          } else {
            return false;
          }
          if (++i > parts.length) {
            return false;
          }
        }
        return true;
      };
    }
    function removeComments(node) {
      for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
        var _ref4;
        if (_isArray4) {
          if (_i4 >= _iterator4.length)
            break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done)
            break;
          _ref4 = _i4.value;
        }
        var key = _ref4;
        delete node[key];
      }
      return node;
    }
    function inheritsComments(child, parent) {
      inheritTrailingComments(child, parent);
      inheritLeadingComments(child, parent);
      inheritInnerComments(child, parent);
      return child;
    }
    function inheritTrailingComments(child, parent) {
      _inheritComments("trailingComments", child, parent);
    }
    function inheritLeadingComments(child, parent) {
      _inheritComments("leadingComments", child, parent);
    }
    function inheritInnerComments(child, parent) {
      _inheritComments("innerComments", child, parent);
    }
    function _inheritComments(key, child, parent) {
      if (child && parent) {
        child[key] = (0, _uniq2.default)((0, _compact2.default)([].concat(child[key], parent[key])));
      }
    }
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
        var _ref5;
        if (_isArray5) {
          if (_i5 >= _iterator5.length)
            break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done)
            break;
          _ref5 = _i5.value;
        }
        var _key2 = _ref5;
        if (child[_key2] == null) {
          child[_key2] = parent[_key2];
        }
      }
      for (var key in parent) {
        if (key[0] === "_")
          child[key] = parent[key];
      }
      for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
        var _ref6;
        if (_isArray6) {
          if (_i6 >= _iterator6.length)
            break;
          _ref6 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done)
            break;
          _ref6 = _i6.value;
        }
        var _key3 = _ref6;
        child[_key3] = parent[_key3];
      }
      t.inheritsComments(child, parent);
      return child;
    }
    function assertNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Not a valid node " + (node && node.type));
      }
    }
    function isNode(node) {
      return !!(node && _definitions.VISITOR_KEYS[node.type]);
    }
    (0, _toFastProperties2.default)(t);
    (0, _toFastProperties2.default)(t.VISITOR_KEYS);
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      var keys = t.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      opts = opts || {};
      enter(node, opts);
      for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
        var _ref7;
        if (_isArray7) {
          if (_i7 >= _iterator7.length)
            break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done)
            break;
          _ref7 = _i7.value;
        }
        var key = _ref7;
        var subNode = node[key];
        if (Array.isArray(subNode)) {
          for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
            var _ref8;
            if (_isArray8) {
              if (_i8 >= _iterator8.length)
                break;
              _ref8 = _iterator8[_i8++];
            } else {
              _i8 = _iterator8.next();
              if (_i8.done)
                break;
              _ref8 = _i8.value;
            }
            var _node = _ref8;
            traverseFast(_node, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
    var CLEAR_KEYS = [
      "tokens",
      "start",
      "end",
      "loc",
      "raw",
      "rawValue"
    ];
    var CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
    function removeProperties(node, opts) {
      opts = opts || {};
      var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
        var _ref9;
        if (_isArray9) {
          if (_i9 >= _iterator9.length)
            break;
          _ref9 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done)
            break;
          _ref9 = _i9.value;
        }
        var _key4 = _ref9;
        if (node[_key4] != null)
          node[_key4] = undefined;
      }
      for (var key in node) {
        if (key[0] === "_" && node[key] != null)
          node[key] = undefined;
      }
      var syms = (0, _getOwnPropertySymbols2.default)(node);
      for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
        var _ref10;
        if (_isArray10) {
          if (_i10 >= _iterator10.length)
            break;
          _ref10 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done)
            break;
          _ref10 = _i10.value;
        }
        var sym = _ref10;
        node[sym] = null;
      }
    }
    function removePropertiesDeep(tree, opts) {
      traverseFast(tree, removeProperties, opts);
      return tree;
    }
  }(lib$5));
  return lib$5;
}

var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6)
    return lib$6.exports;
  hasRequiredLib$6 = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports.default = function (path, emit) {
      var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "var";
      path.traverse(visitor, {
        kind: kind,
        emit: emit
      });
    };
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var visitor = {
      Scope: function Scope(path, state) {
        if (state.kind === "let")
          path.skip();
      },
      Function: function Function(path) {
        path.skip();
      },
      VariableDeclaration: function VariableDeclaration(path, state) {
        if (state.kind && path.node.kind !== state.kind)
          return;
        var nodes = [];
        var declarations = path.get("declarations");
        var firstId = void 0;
        for (var _iterator = declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var declar = _ref;
          firstId = declar.node.id;
          if (declar.node.init) {
            nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.node.id, declar.node.init)));
          }
          for (var name in declar.getBindingIdentifiers()) {
            state.emit(t.identifier(name), name);
          }
        }
        if (path.parentPath.isFor({ left: path.node })) {
          path.replaceWith(firstId);
        } else {
          path.replaceWithMultiple(nodes);
        }
      }
    };
    module.exports = exports["default"];
  }(lib$6, lib$6.exports));
  return lib$6.exports;
}

var lib$4 = {exports: {}};

var cloneDeep_1;
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep)
    return cloneDeep_1;
  hasRequiredCloneDeep = 1;
  var baseClone = require_baseClone();
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  cloneDeep_1 = cloneDeep;
  return cloneDeep_1;
}

var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply)
    return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply;
  return _apply;
}

var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest)
    return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}

var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant)
    return constant_1;
  hasRequiredConstant = 1;
  function constant(value) {
    return function () {
      return value;
    };
  }
  constant_1 = constant;
  return constant_1;
}

var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString)
    return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant = requireConstant(), defineProperty = require_defineProperty(), identity = requireIdentity();
  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}

var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut)
    return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function () {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}

var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString)
    return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}

var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest)
    return _baseRest;
  hasRequired_baseRest = 1;
  var identity = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}

var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall)
    return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject = requireIsObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}

var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner)
    return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}

var assign_1;
var hasRequiredAssign;
function requireAssign() {
  if (hasRequiredAssign)
    return assign_1;
  hasRequiredAssign = 1;
  var assignValue = require_assignValue(), copyObject = require_copyObject(), createAssigner = require_createAssigner(), isArrayLike = requireIsArrayLike(), isPrototype = require_isPrototype(), keys = requireKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var assign = createAssigner(function (object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });
  assign_1 = assign;
  return assign_1;
}

var _baseHas;
var hasRequired_baseHas;
function require_baseHas() {
  if (hasRequired_baseHas)
    return _baseHas;
  hasRequired_baseHas = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseHas(object, key) {
    return object != null && hasOwnProperty.call(object, key);
  }
  _baseHas = baseHas;
  return _baseHas;
}

var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey)
    return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  _isKey = isKey;
  return _isKey;
}

var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize)
    return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  memoize_1 = memoize;
  return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped)
    return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath)
    return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}

var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap)
    return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString)
    return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}

var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}

var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath)
    return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  _castPath = castPath;
  return _castPath;
}

var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey)
    return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}

var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath)
    return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  _hasPath = hasPath;
  return _hasPath;
}

var has_1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has_1;
  hasRequiredHas = 1;
  var baseHas = require_baseHas(), hasPath = require_hasPath();
  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }
  has_1 = has;
  return has_1;
}

var lib$3 = {};

var path = {exports: {}};

var classCallCheck = {};

var hasRequiredClassCallCheck;
function requireClassCallCheck() {
  if (hasRequiredClassCallCheck)
    return classCallCheck;
  hasRequiredClassCallCheck = 1;
  classCallCheck.__esModule = true;
  classCallCheck.default = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  return classCallCheck;
}

var virtualTypes = {};

var hasRequiredVirtualTypes;
function requireVirtualTypes() {
  if (hasRequiredVirtualTypes)
    return virtualTypes;
  hasRequiredVirtualTypes = 1;
  virtualTypes.__esModule = true;
  virtualTypes.Flow = virtualTypes.Pure = virtualTypes.Generated = virtualTypes.User = virtualTypes.Var = virtualTypes.BlockScoped = virtualTypes.Referenced = virtualTypes.Scope = virtualTypes.Expression = virtualTypes.Statement = virtualTypes.BindingIdentifier = virtualTypes.ReferencedMemberExpression = virtualTypes.ReferencedIdentifier = undefined;
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  virtualTypes.ReferencedIdentifier = {
    types: [
      "Identifier",
      "JSXIdentifier"
    ],
    checkPath: function checkPath(_ref, opts) {
      var node = _ref.node, parent = _ref.parent;
      if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
        if (t.isJSXIdentifier(node, opts)) {
          if (_babelTypes.react.isCompatTag(node.name))
            return false;
        } else {
          return false;
        }
      }
      return t.isReferenced(node, parent);
    }
  };
  virtualTypes.ReferencedMemberExpression = {
    types: ["MemberExpression"],
    checkPath: function checkPath(_ref2) {
      var node = _ref2.node, parent = _ref2.parent;
      return t.isMemberExpression(node) && t.isReferenced(node, parent);
    }
  };
  virtualTypes.BindingIdentifier = {
    types: ["Identifier"],
    checkPath: function checkPath(_ref3) {
      var node = _ref3.node, parent = _ref3.parent;
      return t.isIdentifier(node) && t.isBinding(node, parent);
    }
  };
  virtualTypes.Statement = {
    types: ["Statement"],
    checkPath: function checkPath(_ref4) {
      var node = _ref4.node, parent = _ref4.parent;
      if (t.isStatement(node)) {
        if (t.isVariableDeclaration(node)) {
          if (t.isForXStatement(parent, { left: node }))
            return false;
          if (t.isForStatement(parent, { init: node }))
            return false;
        }
        return true;
      } else {
        return false;
      }
    }
  };
  virtualTypes.Expression = {
    types: ["Expression"],
    checkPath: function checkPath(path) {
      if (path.isIdentifier()) {
        return path.isReferencedIdentifier();
      } else {
        return t.isExpression(path.node);
      }
    }
  };
  virtualTypes.Scope = {
    types: ["Scopable"],
    checkPath: function checkPath(path) {
      return t.isScope(path.node, path.parent);
    }
  };
  virtualTypes.Referenced = {
    checkPath: function checkPath(path) {
      return t.isReferenced(path.node, path.parent);
    }
  };
  virtualTypes.BlockScoped = {
    checkPath: function checkPath(path) {
      return t.isBlockScoped(path.node);
    }
  };
  virtualTypes.Var = {
    types: ["VariableDeclaration"],
    checkPath: function checkPath(path) {
      return t.isVar(path.node);
    }
  };
  virtualTypes.User = {
    checkPath: function checkPath(path) {
      return path.node && !!path.node.loc;
    }
  };
  virtualTypes.Generated = {
    checkPath: function checkPath(path) {
      return !path.isUser();
    }
  };
  virtualTypes.Pure = {
    checkPath: function checkPath(path, opts) {
      return path.scope.isPure(path.node, opts);
    }
  };
  virtualTypes.Flow = {
    types: [
      "Flow",
      "ImportDeclaration",
      "ExportDeclaration"
    ],
    checkPath: function checkPath(_ref5) {
      var node = _ref5.node;
      if (t.isFlow(node)) {
        return true;
      } else if (t.isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (t.isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else {
        return false;
      }
    }
  };
  return virtualTypes;
}

var node$2 = {exports: {}};

var debug = {exports: {}};

var _0_7_1;
var hasRequired_0_7_1;
function require_0_7_1() {
  if (hasRequired_0_7_1)
    return _0_7_1;
  hasRequired_0_7_1 = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  _0_7_1 = function (val, options) {
    options = options || {};
    if ("string" == typeof val)
      return parse(val);
    return options.long ? long(val) : short(val);
  };
  function parse(str) {
    str = "" + str;
    if (str.length > 10000)
      return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return;
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    }
  }
  function short(ms) {
    if (ms >= d)
      return Math.round(ms / d) + "d";
    if (ms >= h)
      return Math.round(ms / h) + "h";
    if (ms >= m)
      return Math.round(ms / m) + "m";
    if (ms >= s)
      return Math.round(ms / s) + "s";
    return ms + "ms";
  }
  function long(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n)
      return;
    if (ms < n * 1.5)
      return Math.floor(ms / n) + " " + name;
    return Math.ceil(ms / n) + " " + name + "s";
  }
  return _0_7_1;
}

var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug.exports;
  hasRequiredDebug = 1;
  (function (module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_0_7_1();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {
      }
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors)
          self.useColors = exports.useColors();
        if (null == self.color && self.useColors)
          self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args = ["%o"].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        if ("function" === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }(debug, debug.exports));
  return debug.exports;
}

var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return node$2.exports;
  hasRequiredNode$1 = 1;
  (function (module, exports) {
    var tty = require$$0__default["default"];
    var util = require$$1__default["default"];
    exports = module.exports = requireDebug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || "").trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return "0" !== debugColors && "no" !== debugColors && "false" !== debugColors && "disabled" !== debugColors;
      }
    }
    var inspect = 4 === util.inspect.length ? function (v, colors) {
      return util.inspect(v, void 0, void 0, colors);
    } : function (v, colors) {
      return util.inspect(v, { colors: colors });
    };
    exports.formatters.o = function (v) {
      return inspect(v, this.useColors).replace(/\s*\n\s*/g, " ");
    };
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
      if (useColors) {
        var c = this.color;
        args[0] = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m" + args[0] + "\x1B[3" + c + "m" + " +" + exports.humanize(this.diff) + "\x1B[0m";
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
      return args;
    }
    function log() {
      return stream.write(util.format.apply(this, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd) {
      var stream;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd)) {
      case "TTY":
        stream = new tty.WriteStream(fd);
        stream._type = "tty";
        if (stream._handle && stream._handle.unref) {
          stream._handle.unref();
        }
        break;
      case "FILE":
        var fs = require$$2__default["default"];
        stream = new fs.SyncWriteStream(fd, { autoClose: false });
        stream._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = require$$4__default["default"];
        stream = new net.Socket({
          fd: fd,
          readable: false,
          writable: true
        });
        stream.readable = false;
        stream.read = null;
        stream._type = "pipe";
        if (stream._handle && stream._handle.unref) {
          stream._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
      }
      stream.fd = fd;
      stream._isStdio = true;
      return stream;
    }
    exports.enable(load());
  }(node$2, node$2.exports));
  return node$2.exports;
}

var invariant_1;
var hasRequiredInvariant;
function requireInvariant() {
  if (hasRequiredInvariant)
    return invariant_1;
  hasRequiredInvariant = 1;
  var __DEV__ = process.env.NODE_ENV !== "production";
  var invariant = function (condition, format, a, b, c, d, e, f) {
    if (__DEV__) {
      if (format === undefined) {
        throw new Error("invariant requires an error message argument");
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
      } else {
        var args = [
          a,
          b,
          c,
          d,
          e,
          f
        ];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = "Invariant Violation";
      }
      error.framesToPop = 1;
      throw error;
    }
  };
  invariant_1 = invariant;
  return invariant_1;
}

var scope = {exports: {}};

var _redefineAll;
var hasRequired_redefineAll;
function require_redefineAll() {
  if (hasRequired_redefineAll)
    return _redefineAll;
  hasRequired_redefineAll = 1;
  var hide = require_hide();
  _redefineAll = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key])
        target[key] = src[key];
      else
        hide(target, key, src[key]);
    }
    return target;
  };
  return _redefineAll;
}

var _anInstance;
var hasRequired_anInstance;
function require_anInstance() {
  if (hasRequired_anInstance)
    return _anInstance;
  hasRequired_anInstance = 1;
  _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
      throw TypeError(name + ": incorrect invocation!");
    }
    return it;
  };
  return _anInstance;
}

var _forOf = {exports: {}};

var _iterCall;
var hasRequired_iterCall;
function require_iterCall() {
  if (hasRequired_iterCall)
    return _iterCall;
  hasRequired_iterCall = 1;
  var anObject = require_anObject();
  _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator["return"];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  return _iterCall;
}

var _isArrayIter;
var hasRequired_isArrayIter;
function require_isArrayIter() {
  if (hasRequired_isArrayIter)
    return _isArrayIter;
  hasRequired_isArrayIter = 1;
  var Iterators = require_iterators(), ITERATOR = require_wks()("iterator"), ArrayProto = Array.prototype;
  _isArrayIter = function (it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return _isArrayIter;
}

var hasRequired_forOf;
function require_forOf() {
  if (hasRequired_forOf)
    return _forOf.exports;
  hasRequired_forOf = 1;
  var ctx = require_ctx(), call = require_iterCall(), isArrayIter = require_isArrayIter(), anObject = require_anObject(), toLength = require_toLength(), getIterFn = requireCore_getIteratorMethod(), BREAK = {}, RETURN = {};
  var exports = _forOf.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () {
        return iterable;
      } : getIterFn(iterable), f = ctx(fn, that, entries ? 2 : 1), index = 0, length, step, iterator, result;
    if (typeof iterFn != "function")
      throw TypeError(iterable + " is not iterable!");
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
        if (result === BREAK || result === RETURN)
          return result;
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
        result = call(iterator, f, step.value, entries);
        if (result === BREAK || result === RETURN)
          return result;
      }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  return _forOf.exports;
}

var _setSpecies;
var hasRequired_setSpecies;
function require_setSpecies() {
  if (hasRequired_setSpecies)
    return _setSpecies;
  hasRequired_setSpecies = 1;
  var global = require_global(), core = require_core(), dP = require_objectDp(), DESCRIPTORS = require_descriptors(), SPECIES = require_wks()("species");
  _setSpecies = function (KEY) {
    var C = typeof core[KEY] == "function" ? core[KEY] : global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      dP.f(C, SPECIES, {
        configurable: true,
        get: function () {
          return this;
        }
      });
  };
  return _setSpecies;
}

var _collectionStrong;
var hasRequired_collectionStrong;
function require_collectionStrong() {
  if (hasRequired_collectionStrong)
    return _collectionStrong;
  hasRequired_collectionStrong = 1;
  var dP = require_objectDp().f, create = require_objectCreate(); require_hide(); var redefineAll = require_redefineAll(), ctx = require_ctx(), anInstance = require_anInstance(), defined = require_defined(), forOf = require_forOf(), $iterDefine = require_iterDefine(), step = require_iterStep(), setSpecies = require_setSpecies(), DESCRIPTORS = require_descriptors(), fastKey = require_meta().fastKey, SIZE = DESCRIPTORS ? "_s" : "size";
  var getEntry = function (that, key) {
    var index = fastKey(key), entry;
    if (index !== "F")
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, NAME, "_i");
        that._i = create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        "delete": function (key) {
          var that = this, entry = getEntry(that, key);
          if (entry) {
            var next = entry.n, prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          anInstance(this, C, "forEach");
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3), entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        dP(C.prototype, "size", {
          get: function () {
            return defined(this[SIZE]);
          }
        });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key), prev, index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== "F")
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function (iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this, kind = that._k, entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == "keys")
          return step(0, entry.k);
        if (kind == "values")
          return step(0, entry.v);
        return step(0, [
          entry.k,
          entry.v
        ]);
      }, IS_MAP ? "entries" : "values", !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  return _collectionStrong;
}

var _arraySpeciesConstructor;
var hasRequired_arraySpeciesConstructor;
function require_arraySpeciesConstructor() {
  if (hasRequired_arraySpeciesConstructor)
    return _arraySpeciesConstructor;
  hasRequired_arraySpeciesConstructor = 1;
  var isObject = require_isObject(), isArray = require_isArray(), SPECIES = require_wks()("species");
  _arraySpeciesConstructor = function (original) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == "function" && (C === Array || isArray(C.prototype)))
        C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null)
          C = undefined;
      }
    }
    return C === undefined ? Array : C;
  };
  return _arraySpeciesConstructor;
}

var _arraySpeciesCreate;
var hasRequired_arraySpeciesCreate;
function require_arraySpeciesCreate() {
  if (hasRequired_arraySpeciesCreate)
    return _arraySpeciesCreate;
  hasRequired_arraySpeciesCreate = 1;
  var speciesConstructor = require_arraySpeciesConstructor();
  _arraySpeciesCreate = function (original, length) {
    return new (speciesConstructor(original))(length);
  };
  return _arraySpeciesCreate;
}

var _arrayMethods;
var hasRequired_arrayMethods;
function require_arrayMethods() {
  if (hasRequired_arrayMethods)
    return _arrayMethods;
  hasRequired_arrayMethods = 1;
  var ctx = require_ctx(), IObject = require_iobject(), toObject = require_toObject(), toLength = require_toLength(), asc = require_arraySpeciesCreate();
  _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1, IS_FILTER = TYPE == 2, IS_SOME = TYPE == 3, IS_EVERY = TYPE == 4, IS_FIND_INDEX = TYPE == 6, NO_HOLES = TYPE == 5 || IS_FIND_INDEX, create = $create || asc;
    return function ($this, callbackfn, that) {
      var O = toObject($this), self = IObject(O), f = ctx(callbackfn, that, 3), length = toLength(self.length), index = 0, result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined, val, res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
              case 3:
                return true;
              case 5:
                return val;
              case 6:
                return index;
              case 2:
                result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return _arrayMethods;
}

var _collection;
var hasRequired_collection;
function require_collection() {
  if (hasRequired_collection)
    return _collection;
  hasRequired_collection = 1;
  var global = require_global(), $export = require_export(), meta = require_meta(), fails = require_fails(), hide = require_hide(), redefineAll = require_redefineAll(), forOf = require_forOf(), anInstance = require_anInstance(), isObject = require_isObject(), setToStringTag = require_setToStringTag(), dP = require_objectDp().f, each = require_arrayMethods()(0), DESCRIPTORS = require_descriptors();
  _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME], C = Base, ADDER = IS_MAP ? "set" : "add", proto = C && C.prototype, O = {};
    if (!DESCRIPTORS || typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function () {
        new C().entries().next();
      }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
      meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME, "_c");
        target._c = new Base();
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function (KEY) {
        var IS_ADDER = KEY == "add" || KEY == "set";
        if (KEY in proto && !(IS_WEAK && KEY == "clear"))
          hide(C.prototype, KEY, function (a, b) {
            anInstance(this, C, KEY);
            if (!IS_ADDER && IS_WEAK && !isObject(a))
              return KEY == "get" ? undefined : false;
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      if ("size" in proto)
        dP(C.prototype, "size", {
          get: function () {
            return this._c.size;
          }
        });
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  return _collection;
}

var es6_map;
var hasRequiredEs6_map;
function requireEs6_map() {
  if (hasRequiredEs6_map)
    return es6_map;
  hasRequiredEs6_map = 1;
  var strong = require_collectionStrong();
  es6_map = require_collection()("Map", function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  return es6_map;
}

var es7_map_toJson = {};

var _arrayFromIterable;
var hasRequired_arrayFromIterable;
function require_arrayFromIterable() {
  if (hasRequired_arrayFromIterable)
    return _arrayFromIterable;
  hasRequired_arrayFromIterable = 1;
  var forOf = require_forOf();
  _arrayFromIterable = function (iter, ITERATOR) {
    var result = [];
    forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };
  return _arrayFromIterable;
}

var _collectionToJson;
var hasRequired_collectionToJson;
function require_collectionToJson() {
  if (hasRequired_collectionToJson)
    return _collectionToJson;
  hasRequired_collectionToJson = 1;
  var classof = require_classof(), from = require_arrayFromIterable();
  _collectionToJson = function (NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      return from(this);
    };
  };
  return _collectionToJson;
}

var hasRequiredEs7_map_toJson;
function requireEs7_map_toJson() {
  if (hasRequiredEs7_map_toJson)
    return es7_map_toJson;
  hasRequiredEs7_map_toJson = 1;
  var $export = require_export();
  $export($export.P + $export.R, "Map", { toJSON: require_collectionToJson()("Map") });
  return es7_map_toJson;
}

var map$1;
var hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1)
    return map$1;
  hasRequiredMap$1 = 1;
  requireEs6_string_iterator();
  requireWeb_dom_iterable();
  requireEs6_map();
  requireEs7_map_toJson();
  map$1 = require_core().Map;
  return map$1;
}

var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map;
  hasRequiredMap = 1;
  map = {
    "default": requireMap$1(),
    __esModule: true
  };
  return map;
}

var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber)
    return toNumber_1;
  hasRequiredToNumber = 1;
  var isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}

var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite)
    return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}

var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger)
    return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}

var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues)
    return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap = require_arrayMap();
  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}

var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues)
    return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys = requireKeys();
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }
  values_1 = values;
  return values_1;
}

var includes_1;
var hasRequiredIncludes;
function requireIncludes() {
  if (hasRequiredIncludes)
    return includes_1;
  hasRequiredIncludes = 1;
  var baseIndexOf = require_baseIndexOf(), isArrayLike = requireIsArrayLike(), isString = requireIsString(), toInteger = requireToInteger(), values = requireValues();
  var nativeMax = Math.max;
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  includes_1 = includes;
  return includes_1;
}

var _baseRepeat;
var hasRequired_baseRepeat;
function require_baseRepeat() {
  if (hasRequired_baseRepeat)
    return _baseRepeat;
  hasRequired_baseRepeat = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var nativeFloor = Math.floor;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }
  _baseRepeat = baseRepeat;
  return _baseRepeat;
}

var repeat_1;
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat)
    return repeat_1;
  hasRequiredRepeat = 1;
  var baseRepeat = require_baseRepeat(), isIterateeCall = require_isIterateeCall(), toInteger = requireToInteger(), toString = requireToString();
  function repeat(string, n, guard) {
    if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
  }
  repeat_1 = repeat;
  return repeat_1;
}

var renamer = {exports: {}};

var binding = {exports: {}};

var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding)
    return binding.exports;
  hasRequiredBinding = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Binding = (function () {
      function Binding(_ref) {
        var existing = _ref.existing, identifier = _ref.identifier, scope = _ref.scope, path = _ref.path, kind = _ref.kind;
        (0, _classCallCheck3.default)(this, Binding);
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.clearValue();
        if (existing) {
          this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
        }
      }
      Binding.prototype.deoptValue = function deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      };
      Binding.prototype.setValue = function setValue(value) {
        if (this.hasDeoptedValue)
          return;
        this.hasValue = true;
        this.value = value;
      };
      Binding.prototype.clearValue = function clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      };
      Binding.prototype.reassign = function reassign(path) {
        this.constant = false;
        if (this.constantViolations.indexOf(path) !== -1) {
          return;
        }
        this.constantViolations.push(path);
      };
      Binding.prototype.reference = function reference(path) {
        if (this.referencePaths.indexOf(path) !== -1) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      };
      Binding.prototype.dereference = function dereference() {
        this.references--;
        this.referenced = !!this.references;
      };
      return Binding;
    }());
    exports.default = Binding;
    module.exports = exports["default"];
  }(binding, binding.exports));
  return binding.exports;
}

var hasRequiredRenamer;
function requireRenamer() {
  if (hasRequiredRenamer)
    return renamer.exports;
  hasRequiredRenamer = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _binding = requireBinding();
    _interopRequireDefault(_binding);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var renameVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
        var node = _ref.node;
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope: function Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
        }
      },
      "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
        var ids = path.getOuterBindingIdentifiers();
        for (var name in ids) {
          if (name === state.oldName)
            ids[name].name = state.newName;
        }
      }
    };
    var Renamer = (function () {
      function Renamer(binding, oldName, newName) {
        (0, _classCallCheck3.default)(this, Renamer);
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
        var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;
        if (!exportDeclar)
          return;
        var isDefault = exportDeclar.isExportDefaultDeclaration();
        if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
          parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier("default");
        }
        var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
        var specifiers = [];
        for (var name in bindingIdentifiers) {
          var localName = name === this.oldName ? this.newName : name;
          var exportedName = isDefault ? "default" : name;
          specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));
        }
        if (specifiers.length) {
          var aliasDeclar = t.exportNamedDeclaration(null, specifiers);
          if (parentDeclar.isFunctionDeclaration()) {
            aliasDeclar._blockHoist = 3;
          }
          exportDeclar.insertAfter(aliasDeclar);
          exportDeclar.replaceWith(parentDeclar.node);
        }
      };
      Renamer.prototype.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
        return;
      };
      Renamer.prototype.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
        return;
      };
      Renamer.prototype.rename = function rename(block) {
        var binding = this.binding, oldName = this.oldName, newName = this.newName;
        var scope = binding.scope, path = binding.path;
        var parentDeclar = path.find(function (path) {
          return path.isDeclaration() || path.isFunctionExpression();
        });
        if (parentDeclar) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
        scope.traverse(block || scope.block, renameVisitor, this);
        if (!block) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (binding.type === "hoisted") ;
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
          this.maybeConvertFromClassFunctionExpression(parentDeclar);
        }
      };
      return Renamer;
    }());
    exports.default = Renamer;
    module.exports = exports["default"];
  }(renamer, renamer.exports));
  return renamer.exports;
}

var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var baseRest = require_baseRest(), eq = requireEq(), isIterateeCall = require_isIterateeCall(), keysIn = requireKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var defaults = baseRest(function (object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];
        if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          object[key] = source[key];
        }
      }
    }
    return object;
  });
  defaults_1 = defaults;
  return defaults_1;
}

var lib$2 = {};

var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5)
    return lib$2;
  hasRequiredLib$5 = 1;
  lib$2.__esModule = true;
  lib$2.MESSAGES = undefined;
  var _stringify = requireStringify();
  var _stringify2 = _interopRequireDefault(_stringify);
  lib$2.get = get;
  lib$2.parseArgs = parseArgs;
  var _util = require$$1__default["default"];
  var util = _interopRequireWildcard(_util);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MESSAGES = lib$2.MESSAGES = {
    tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
    classesIllegalBareSuper: "Illegal use of bare super",
    classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
    scopeDuplicateDeclaration: "Duplicate declaration $1",
    settersNoRest: "Setters aren't allowed to have a rest",
    noAssignmentsInForHead: "No assignments allowed in for-in/of head",
    expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
    invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
    readOnly: "$1 is read-only",
    unknownForHead: "Unknown node type $1 in ForStatement",
    didYouMean: "Did you mean $1?",
    codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
    missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
    unsupportedOutputType: "Unsupported output type $1",
    illegalMethodName: "Illegal method name $1",
    lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",
    modulesIllegalExportName: "Illegal export $1",
    modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",
    undeclaredVariable: "Reference to undeclared variable $1",
    undeclaredVariableType: "Referencing a type alias outside of a type annotation",
    undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
    traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",
    traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
    traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
    traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",
    pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",
    pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3",
    pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",
    pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3"
  };
  function get(key) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var msg = MESSAGES[key];
    if (!msg)
      throw new ReferenceError("Unknown message " + (0, _stringify2.default)(key));
    args = parseArgs(args);
    return msg.replace(/\$(\d+)/g, function (str, i) {
      return args[i - 1];
    });
  }
  function parseArgs(args) {
    return args.map(function (val) {
      if (val != null && val.inspect) {
        return val.inspect();
      } else {
        try {
          return (0, _stringify2.default)(val) || val + "";
        } catch (e) {
          return util.inspect(val);
        }
      }
    });
  }
  return lib$2;
}

var builtin = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	System: false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es5 = {
	"Array": false,
	"Boolean": false,
	constructor: false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	propertyIsEnumerable: false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false
};
var es6 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	System: false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var browser = {
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	AnimationEvent: false,
	applicationCache: false,
	ApplicationCache: false,
	ApplicationCacheErrorEvent: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioDestinationNode: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioProcessingEvent: false,
	AutocompleteErrorEvent: false,
	BarProp: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	blur: false,
	btoa: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	CDATASection: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	ClientRect: false,
	ClientRectList: false,
	ClipboardEvent: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	confirm: false,
	console: false,
	ConvolverNode: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSFontFaceRule: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSMediaRule: false,
	CSSPageRule: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSSupportsRule: false,
	CSSUnknownRule: false,
	CSSViewportRule: false,
	CustomEvent: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	Debug: false,
	defaultStatus: false,
	defaultstatus: false,
	DelayNode: false,
	DeviceMotionEvent: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMParser: false,
	DOMSettableTokenList: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	Element: false,
	ElementTimeControl: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	fetch: false,
	File: false,
	FileError: false,
	FileList: false,
	FileReader: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontFace: false,
	FormData: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadButton: false,
	GamepadEvent: false,
	getComputedStyle: false,
	getSelection: false,
	HashChangeEvent: false,
	Headers: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAppletElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBlockquoteElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLContentElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLIsIndexElement: false,
	HTMLKeygenElement: false,
	HTMLLabelElement: false,
	HTMLLayerElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLShadowElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBEnvironment: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	Image: false,
	ImageBitmap: false,
	ImageData: false,
	indexedDB: false,
	innerHeight: false,
	innerWidth: false,
	InputEvent: false,
	InputMethodContext: false,
	"Intl": false,
	KeyboardEvent: false,
	length: false,
	localStorage: false,
	location: false,
	Location: false,
	locationbar: false,
	matchMedia: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyError: false,
	MediaKeyEvent: false,
	MediaKeyMessageEvent: false,
	MediaKeys: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaSource: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	navigator: false,
	Navigator: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	onbeforeunload: true,
	onblur: true,
	onerror: true,
	onfocus: true,
	onload: true,
	onresize: true,
	onunload: true,
	open: false,
	openDatabase: false,
	opener: false,
	opera: false,
	Option: false,
	OscillatorNode: false,
	outerHeight: false,
	outerWidth: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	parent: false,
	Path2D: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	personalbar: false,
	Plugin: false,
	PluginArray: false,
	PopStateEvent: false,
	postMessage: false,
	print: false,
	ProcessingInstruction: false,
	ProgressEvent: false,
	prompt: false,
	PushManager: false,
	PushSubscription: false,
	RadioNodeList: false,
	Range: false,
	ReadableByteStream: false,
	ReadableStream: false,
	removeEventListener: false,
	Request: false,
	requestAnimationFrame: false,
	resizeBy: false,
	resizeTo: false,
	Response: false,
	RTCIceCandidate: false,
	RTCSessionDescription: false,
	screen: false,
	Screen: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	showModalDialog: false,
	speechSynthesis: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	status: false,
	statusbar: false,
	stop: false,
	Storage: false,
	StorageEvent: false,
	styleMedia: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAltGlyphDefElement: false,
	SVGAltGlyphElement: false,
	SVGAltGlyphItemElement: false,
	SVGAngle: false,
	SVGAnimateColorElement: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPathData: false,
	SVGAnimatedPoints: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGColor: false,
	SVGColorProfileElement: false,
	SVGColorProfileRule: false,
	SVGComponentTransferFunctionElement: false,
	SVGCSSRule: false,
	SVGCursorElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGDiscardElement: false,
	SVGDocument: false,
	SVGElement: false,
	SVGElementInstance: false,
	SVGElementInstanceList: false,
	SVGEllipseElement: false,
	SVGEvent: false,
	SVGExternalResourcesRequired: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGFilterPrimitiveStandardAttributes: false,
	SVGFitToViewBox: false,
	SVGFontElement: false,
	SVGFontFaceElement: false,
	SVGFontFaceFormatElement: false,
	SVGFontFaceNameElement: false,
	SVGFontFaceSrcElement: false,
	SVGFontFaceUriElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGlyphElement: false,
	SVGGlyphRefElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGHKernElement: false,
	SVGICCColor: false,
	SVGImageElement: false,
	SVGLangSpace: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGLocatable: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMissingGlyphElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPaint: false,
	SVGPathElement: false,
	SVGPathSeg: false,
	SVGPathSegArcAbs: false,
	SVGPathSegArcRel: false,
	SVGPathSegClosePath: false,
	SVGPathSegCurvetoCubicAbs: false,
	SVGPathSegCurvetoCubicRel: false,
	SVGPathSegCurvetoCubicSmoothAbs: false,
	SVGPathSegCurvetoCubicSmoothRel: false,
	SVGPathSegCurvetoQuadraticAbs: false,
	SVGPathSegCurvetoQuadraticRel: false,
	SVGPathSegCurvetoQuadraticSmoothAbs: false,
	SVGPathSegCurvetoQuadraticSmoothRel: false,
	SVGPathSegLinetoAbs: false,
	SVGPathSegLinetoHorizontalAbs: false,
	SVGPathSegLinetoHorizontalRel: false,
	SVGPathSegLinetoRel: false,
	SVGPathSegLinetoVerticalAbs: false,
	SVGPathSegLinetoVerticalRel: false,
	SVGPathSegList: false,
	SVGPathSegMovetoAbs: false,
	SVGPathSegMovetoRel: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGRenderingIntent: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStylable: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTests: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformable: false,
	SVGTransformList: false,
	SVGTRefElement: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGURIReference: false,
	SVGUseElement: false,
	SVGViewElement: false,
	SVGViewSpec: false,
	SVGVKernElement: false,
	SVGZoomAndPan: false,
	SVGZoomEvent: false,
	Text: false,
	TextDecoder: false,
	TextEncoder: false,
	TextEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TimeEvent: false,
	TimeRanges: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransitionEvent: false,
	TreeWalker: false,
	UIEvent: false,
	URL: false,
	ValidityState: false,
	VTTCue: false,
	WaveShaperNode: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLTexture: false,
	WebGLUniformLocation: false,
	WebSocket: false,
	WheelEvent: false,
	window: false,
	Window: false,
	Worker: false,
	XDomainRequest: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestProgressEvent: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathException: false,
	XPathExpression: false,
	XPathNamespace: false,
	XPathNSResolver: false,
	XPathResult: false,
	XSLTProcessor: false
};
var worker = {
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	clearInterval: false,
	clearTimeout: false,
	close: true,
	console: false,
	fetch: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: true,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onoffline: true,
	ononline: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	Request: false,
	Response: false,
	self: true,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	WebSocket: false,
	Worker: false,
	XMLHttpRequest: false
};
var node$1 = {
	__dirname: false,
	__filename: false,
	"arguments": false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	exports: true,
	GLOBAL: false,
	global: false,
	module: false,
	process: false,
	require: false,
	root: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false
};
var commonjs = {
	exports: true,
	module: false,
	require: false,
	global: false
};
var amd = {
	define: false,
	require: false
};
var mocha = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest = {
	afterEach: false,
	beforeEach: false,
	describe: false,
	expect: false,
	it: false,
	jest: false,
	pit: false,
	require: false,
	xdescribe: false,
	xit: false
};
var qunit = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	Java: false,
	java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh = {
	ActiveXObject: true,
	Enumerator: true,
	GetObject: true,
	ScriptEngine: true,
	ScriptEngineBuildVersion: true,
	ScriptEngineMajorVersion: true,
	ScriptEngineMinorVersion: true,
	VBArray: true,
	WScript: true,
	WSH: true,
	XDomainRequest: true
};
var jquery = {
	$: false,
	jQuery: false
};
var yui = {
	Y: false,
	YUI: false,
	YUI_config: false
};
var shelljs = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	ls: false,
	ln: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	target: false,
	tempdir: false,
	test: false,
	which: false
};
var prototypejs = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor = {
	$: false,
	_: false,
	Accounts: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker = {
	caches: false,
	Cache: false,
	CacheStorage: false,
	Client: false,
	clients: false,
	Clients: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	FetchEvent: false,
	importScripts: false,
	registration: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	skipWaiting: false,
	WindowClient: false
};
var atomtest = {
	advanceClock: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	triggerEvent: false,
	visit: false
};
var protractor = {
	$: false,
	$$: false,
	browser: false,
	By: false,
	by: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey = {
	GM_addStyle: false,
	GM_deleteValue: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var require$$0$1 = {
	builtin: builtin,
	es5: es5,
	es6: es6,
	browser: browser,
	worker: worker,
	node: node$1,
	commonjs: commonjs,
	amd: amd,
	mocha: mocha,
	jasmine: jasmine,
	jest: jest,
	qunit: qunit,
	phantomjs: phantomjs,
	couch: couch,
	rhino: rhino,
	nashorn: nashorn,
	wsh: wsh,
	jquery: jquery,
	yui: yui,
	shelljs: shelljs,
	prototypejs: prototypejs,
	meteor: meteor,
	mongo: mongo,
	applescript: applescript,
	serviceworker: serviceworker,
	atomtest: atomtest,
	embertest: embertest,
	protractor: protractor,
	"shared-node-browser": {
	clearInterval: false,
	clearTimeout: false,
	console: false,
	setInterval: false,
	setTimeout: false
},
	webextensions: webextensions,
	greasemonkey: greasemonkey
};

var _9_0_0;
var hasRequired_9_0_0;
function require_9_0_0() {
  if (hasRequired_9_0_0)
    return _9_0_0;
  hasRequired_9_0_0 = 1;
  _9_0_0 = require$$0$1;
  return _9_0_0;
}

var cache = {};

var es6_weakMap = {exports: {}};

var _objectAssign;
var hasRequired_objectAssign;
function require_objectAssign() {
  if (hasRequired_objectAssign)
    return _objectAssign;
  hasRequired_objectAssign = 1;
  var getKeys = require_objectKeys(), gOPS = require_objectGops(), pIE = require_objectPie(), toObject = require_toObject(), IObject = require_iobject(), $assign = Object.assign;
  _objectAssign = !$assign || require_fails()(function () {
    var A = {}, B = {}, S = Symbol(), K = "abcdefghijklmnopqrst";
    A[S] = 7;
    K.split("").forEach(function (k) {
      B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
  }) ? function assign(target, source) {
    var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f;
    while (aLen > index) {
      var S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0, key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : $assign;
  return _objectAssign;
}

var _collectionWeak;
var hasRequired_collectionWeak;
function require_collectionWeak() {
  if (hasRequired_collectionWeak)
    return _collectionWeak;
  hasRequired_collectionWeak = 1;
  var redefineAll = require_redefineAll(), getWeak = require_meta().getWeak, anObject = require_anObject(), isObject = require_isObject(), anInstance = require_anInstance(), forOf = require_forOf(), createArrayMethod = require_arrayMethods(), $has = require_has(), arrayFind = createArrayMethod(5), arrayFindIndex = createArrayMethod(6), id = 0;
  var uncaughtFrozenStore = function (that) {
    return that._l || (that._l = new UncaughtFrozenStore());
  };
  var UncaughtFrozenStore = function () {
    this.a = [];
  };
  var findUncaughtFrozen = function (store, key) {
    return arrayFind(store.a, function (it) {
      return it[0] === key;
    });
  };
  UncaughtFrozenStore.prototype = {
    get: function (key) {
      var entry = findUncaughtFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function (key) {
      return !!findUncaughtFrozen(this, key);
    },
    set: function (key, value) {
      var entry = findUncaughtFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([
          key,
          value
        ]);
    },
    "delete": function (key) {
      var index = arrayFindIndex(this.a, function (it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  _collectionWeak = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, NAME, "_i");
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        "delete": function (key) {
          if (!isObject(key))
            return false;
          var data = getWeak(key);
          if (data === true)
            return uncaughtFrozenStore(this)["delete"](key);
          return data && $has(data, this._i) && delete data[this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          var data = getWeak(key);
          if (data === true)
            return uncaughtFrozenStore(this).has(key);
          return data && $has(data, this._i);
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var data = getWeak(anObject(key), true);
      if (data === true)
        uncaughtFrozenStore(that).set(key, value);
      else
        data[that._i] = value;
      return that;
    },
    ufstore: uncaughtFrozenStore
  };
  return _collectionWeak;
}

var hasRequiredEs6_weakMap;
function requireEs6_weakMap() {
  if (hasRequiredEs6_weakMap)
    return es6_weakMap.exports;
  hasRequiredEs6_weakMap = 1;
  var each = require_arrayMethods()(0), redefine = require_redefine(), meta = require_meta(), assign = require_objectAssign(), weak = require_collectionWeak(), isObject = require_isObject(); require_has(); var getWeak = meta.getWeak, isExtensible = Object.isExtensible, uncaughtFrozenStore = weak.ufstore, tmp = {}, InternalMap;
  var wrapper = function (get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  };
  var methods = {
    get: function get(key) {
      if (isObject(key)) {
        var data = getWeak(key);
        if (data === true)
          return uncaughtFrozenStore(this).get(key);
        return data ? data[this._i] : undefined;
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  };
  var $WeakMap = es6_weakMap.exports = require_collection()("WeakMap", wrapper, methods, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    InternalMap = weak.getConstructor(wrapper);
    assign(InternalMap.prototype, methods);
    meta.NEED = true;
    each([
      "delete",
      "has",
      "get",
      "set"
    ], function (key) {
      var proto = $WeakMap.prototype, method = proto[key];
      redefine(proto, key, function (a, b) {
        if (isObject(a) && !isExtensible(a)) {
          if (!this._f)
            this._f = new InternalMap();
          var result = this._f[key](a, b);
          return key == "set" ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  return es6_weakMap.exports;
}

var weakMap$1;
var hasRequiredWeakMap$1;
function requireWeakMap$1() {
  if (hasRequiredWeakMap$1)
    return weakMap$1;
  hasRequiredWeakMap$1 = 1;
  requireWeb_dom_iterable();
  requireEs6_weakMap();
  weakMap$1 = require_core().WeakMap;
  return weakMap$1;
}

var weakMap;
var hasRequiredWeakMap;
function requireWeakMap() {
  if (hasRequiredWeakMap)
    return weakMap;
  hasRequiredWeakMap = 1;
  weakMap = {
    "default": requireWeakMap$1(),
    __esModule: true
  };
  return weakMap;
}

var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache)
    return cache;
  hasRequiredCache = 1;
  cache.__esModule = true;
  cache.scope = cache.path = undefined;
  var _weakMap = requireWeakMap();
  var _weakMap2 = _interopRequireDefault(_weakMap);
  cache.clear = clear;
  cache.clearPath = clearPath;
  cache.clearScope = clearScope;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  cache.path = new _weakMap2.default();
  cache.scope = new _weakMap2.default();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    cache.path = new _weakMap2.default();
  }
  function clearScope() {
    cache.scope = new _weakMap2.default();
  }
  return cache;
}

var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope)
    return scope.exports;
  hasRequiredScope = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _keys = requireKeys$1();
    var _keys2 = _interopRequireDefault(_keys);
    var _create = requireCreate();
    var _create2 = _interopRequireDefault(_create);
    var _map = requireMap();
    var _map2 = _interopRequireDefault(_map);
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _includes = requireIncludes();
    var _includes2 = _interopRequireDefault(_includes);
    var _repeat = requireRepeat();
    var _repeat2 = _interopRequireDefault(_repeat);
    var _renamer = requireRenamer();
    var _renamer2 = _interopRequireDefault(_renamer);
    var _index = requireLib$2();
    var _index2 = _interopRequireDefault(_index);
    var _defaults = requireDefaults();
    var _defaults2 = _interopRequireDefault(_defaults);
    var _babelMessages = requireLib$5();
    var messages = _interopRequireWildcard(_babelMessages);
    var _binding2 = requireBinding();
    var _binding3 = _interopRequireDefault(_binding2);
    var _globals = require_9_0_0();
    var _globals2 = _interopRequireDefault(_globals);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    var _cache = requireCache();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _crawlCallsCount = 0;
    function getCache(path, parentScope, self) {
      var scopes = _cache.scope.get(path.node) || [];
      for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var scope = _ref;
        if (scope.parent === parentScope && scope.path === path)
          return scope;
      }
      scopes.push(self);
      if (!_cache.scope.has(path.node)) {
        _cache.scope.set(path.node, scopes);
      }
    }
    function gatherNodeParts(node, parts) {
      if (t.isModuleDeclaration(node)) {
        if (node.source) {
          gatherNodeParts(node.source, parts);
        } else if (node.specifiers && node.specifiers.length) {
          for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var specifier = _ref2;
            gatherNodeParts(specifier, parts);
          }
        } else if (node.declaration) {
          gatherNodeParts(node.declaration, parts);
        }
      } else if (t.isModuleSpecifier(node)) {
        gatherNodeParts(node.local, parts);
      } else if (t.isMemberExpression(node)) {
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
      } else if (t.isIdentifier(node)) {
        parts.push(node.name);
      } else if (t.isLiteral(node)) {
        parts.push(node.value);
      } else if (t.isCallExpression(node)) {
        gatherNodeParts(node.callee, parts);
      } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
        for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var prop = _ref3;
          gatherNodeParts(prop.key || prop.argument, parts);
        }
      }
    }
    var collectorVisitor = {
      For: function For(path) {
        for (var _iterator4 = t.FOR_INIT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
          var _ref4;
          if (_isArray4) {
            if (_i4 >= _iterator4.length)
              break;
            _ref4 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done)
              break;
            _ref4 = _i4.value;
          }
          var key = _ref4;
          var declar = path.get(key);
          if (declar.isVar())
            path.scope.getFunctionParent().registerBinding("var", declar);
        }
      },
      Declaration: function Declaration(path) {
        if (path.isBlockScoped())
          return;
        if (path.isExportDeclaration() && path.get("declaration").isDeclaration())
          return;
        path.scope.getFunctionParent().registerDeclaration(path);
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        state.references.push(path);
      },
      ForXStatement: function ForXStatement(path, state) {
        var left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(left);
        }
      },
      ExportDeclaration: {
        exit: function exit(path) {
          var node = path.node, scope = path.scope;
          var declar = node.declaration;
          if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
            var _id = declar.id;
            if (!_id)
              return;
            var binding = scope.getBinding(_id.name);
            if (binding)
              binding.reference(path);
          } else if (t.isVariableDeclaration(declar)) {
            for (var _iterator5 = declar.declarations, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
              var _ref5;
              if (_isArray5) {
                if (_i5 >= _iterator5.length)
                  break;
                _ref5 = _iterator5[_i5++];
              } else {
                _i5 = _iterator5.next();
                if (_i5.done)
                  break;
                _ref5 = _i5.value;
              }
              var decl = _ref5;
              var ids = t.getBindingIdentifiers(decl);
              for (var name in ids) {
                var _binding = scope.getBinding(name);
                if (_binding)
                  _binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement: function LabeledStatement(path) {
        path.scope.getProgramParent().addGlobal(path.node);
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression: function AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression: function UpdateExpression(path, state) {
        state.constantViolations.push(path.get("argument"));
      },
      UnaryExpression: function UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path.get("argument"));
        }
      },
      BlockScoped: function BlockScoped(path) {
        var scope = path.scope;
        if (scope.path === path)
          scope = scope.parent;
        scope.getBlockParent().registerDeclaration(path);
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var id = path.node.id;
        if (!id)
          return;
        var name = id.name;
        path.scope.bindings[name] = path.scope.getBinding(name);
      },
      Block: function Block(path) {
        var paths = path.get("body");
        for (var _iterator6 = paths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
          var _ref6;
          if (_isArray6) {
            if (_i6 >= _iterator6.length)
              break;
            _ref6 = _iterator6[_i6++];
          } else {
            _i6 = _iterator6.next();
            if (_i6.done)
              break;
            _ref6 = _i6.value;
          }
          var bodyPath = _ref6;
          if (bodyPath.isFunctionDeclaration()) {
            path.scope.getBlockParent().registerDeclaration(bodyPath);
          }
        }
      }
    };
    var uid = 0;
    var Scope = (function () {
      function Scope(path, parentScope) {
        (0, _classCallCheck3.default)(this, Scope);
        if (parentScope && parentScope.block === path.node) {
          return parentScope;
        }
        var cached = getCache(path, parentScope, this);
        if (cached)
          return cached;
        this.uid = uid++;
        this.parent = parentScope;
        this.hub = path.hub;
        this.parentBlock = path.parent;
        this.block = path.node;
        this.path = path;
        this.labels = new _map2.default();
      }
      Scope.prototype.traverse = function traverse(node, opts, state) {
        (0, _index2.default)(node, opts, this, state, this.path);
      };
      Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
        var id = this.generateUidIdentifier(name);
        this.push({ id: id });
        return id;
      };
      Scope.prototype.generateUidIdentifier = function generateUidIdentifier() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
        return t.identifier(this.generateUid(name));
      };
      Scope.prototype.generateUid = function generateUid() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
        name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
        var uid = void 0;
        var i = 0;
        do {
          uid = this._generateUid(name, i);
          i++;
        } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
        var program = this.getProgramParent();
        program.references[uid] = true;
        program.uids[uid] = true;
        return uid;
      };
      Scope.prototype._generateUid = function _generateUid(name, i) {
        var id = name;
        if (i > 1)
          id += i;
        return "_" + id;
      };
      Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
        var node = parent;
        if (t.isAssignmentExpression(parent)) {
          node = parent.left;
        } else if (t.isVariableDeclarator(parent)) {
          node = parent.id;
        } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
          node = node.key;
        }
        var parts = [];
        gatherNodeParts(node, parts);
        var id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUidIdentifier(id.slice(0, 20));
      };
      Scope.prototype.isStatic = function isStatic(node) {
        if (t.isThisExpression(node) || t.isSuper(node)) {
          return true;
        }
        if (t.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      };
      Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          var _id2 = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush)
            this.push({ id: _id2 });
          return _id2;
        }
      };
      Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param")
          return;
        if (kind === "hoisted" && local.kind === "let")
          return;
        var duplicate = false;
        if (!duplicate)
          duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module";
        if (!duplicate)
          duplicate = local.kind === "param" && (kind === "let" || kind === "const");
        if (duplicate) {
          throw this.hub.file.buildCodeFrameError(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
        }
      };
      Scope.prototype.rename = function rename(oldName, newName, block) {
        var binding = this.getBinding(oldName);
        if (binding) {
          newName = newName || this.generateUidIdentifier(oldName).name;
          return new _renamer2.default(binding, oldName, newName).rename(block);
        }
      };
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };
      Scope.prototype.dump = function dump() {
        var sep = (0, _repeat2.default)("-", 60);
        console.log(sep);
        var scope = this;
        do {
          console.log("#", scope.block.type);
          for (var name in scope.bindings) {
            var binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      };
      Scope.prototype.toArray = function toArray(node, i) {
        var file = this.hub.file;
        if (t.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (binding && binding.constant && binding.path.isGenericType("Array"))
            return node;
        }
        if (t.isArrayExpression(node)) {
          return node;
        }
        if (t.isIdentifier(node, { name: "arguments" })) {
          return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [node]);
        }
        var helperName = "toArray";
        var args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (i) {
          args.push(t.numericLiteral(i));
          helperName = "slicedToArray";
        }
        return t.callExpression(file.addHelper(helperName), args);
      };
      Scope.prototype.hasLabel = function hasLabel(name) {
        return !!this.getLabel(name);
      };
      Scope.prototype.getLabel = function getLabel(name) {
        return this.labels.get(name);
      };
      Scope.prototype.registerLabel = function registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      };
      Scope.prototype.registerDeclaration = function registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          var declarations = path.get("declarations");
          for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
            var _ref7;
            if (_isArray7) {
              if (_i7 >= _iterator7.length)
                break;
              _ref7 = _iterator7[_i7++];
            } else {
              _i7 = _iterator7.next();
              if (_i7.done)
                break;
              _ref7 = _i7.value;
            }
            var declar = _ref7;
            this.registerBinding(path.node.kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          var specifiers = path.get("specifiers");
          for (var _iterator8 = specifiers, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
            var _ref8;
            if (_isArray8) {
              if (_i8 >= _iterator8.length)
                break;
              _ref8 = _iterator8[_i8++];
            } else {
              _i8 = _iterator8.next();
              if (_i8.done)
                break;
              _ref8 = _i8.value;
            }
            var specifier = _ref8;
            this.registerBinding("module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          var _declar = path.get("declaration");
          if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
            this.registerDeclaration(_declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      };
      Scope.prototype.buildUndefinedNode = function buildUndefinedNode() {
        if (this.hasBinding("undefined")) {
          return t.unaryExpression("void", t.numericLiteral(0), true);
        } else {
          return t.identifier("undefined");
        }
      };
      Scope.prototype.registerConstantViolation = function registerConstantViolation(path) {
        var ids = path.getBindingIdentifiers();
        for (var name in ids) {
          var binding = this.getBinding(name);
          if (binding)
            binding.reassign(path);
        }
      };
      Scope.prototype.registerBinding = function registerBinding(kind, path) {
        var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;
        if (!kind)
          throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          var declarators = path.get("declarations");
          for (var _iterator9 = declarators, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
            var _ref9;
            if (_isArray9) {
              if (_i9 >= _iterator9.length)
                break;
              _ref9 = _iterator9[_i9++];
            } else {
              _i9 = _iterator9.next();
              if (_i9.done)
                break;
              _ref9 = _i9.value;
            }
            var declar = _ref9;
            this.registerBinding(kind, declar);
          }
          return;
        }
        var parent = this.getProgramParent();
        var ids = path.getBindingIdentifiers(true);
        for (var name in ids) {
          for (var _iterator10 = ids[name], _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
            var _ref10;
            if (_isArray10) {
              if (_i10 >= _iterator10.length)
                break;
              _ref10 = _iterator10[_i10++];
            } else {
              _i10 = _iterator10.next();
              if (_i10.done)
                break;
              _ref10 = _i10.value;
            }
            var _id3 = _ref10;
            var local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === _id3)
                continue;
              this.checkBlockScopedCollisions(local, kind, name, _id3);
            }
            if (local && local.path.isFlow())
              local = null;
            parent.references[name] = true;
            this.bindings[name] = new _binding3.default({
              identifier: _id3,
              existing: local,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      };
      Scope.prototype.addGlobal = function addGlobal(node) {
        this.globals[node.name] = node;
      };
      Scope.prototype.hasUid = function hasUid(name) {
        var scope = this;
        do {
          if (scope.uids[name])
            return true;
        } while (scope = scope.parent);
        return false;
      };
      Scope.prototype.hasGlobal = function hasGlobal(name) {
        var scope = this;
        do {
          if (scope.globals[name])
            return true;
        } while (scope = scope.parent);
        return false;
      };
      Scope.prototype.hasReference = function hasReference(name) {
        var scope = this;
        do {
          if (scope.references[name])
            return true;
        } while (scope = scope.parent);
        return false;
      };
      Scope.prototype.isPure = function isPure(node, constantsOnly) {
        if (t.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (!binding)
            return false;
          if (constantsOnly)
            return binding.constant;
          return true;
        } else if (t.isClass(node)) {
          if (node.superClass && !this.isPure(node.superClass, constantsOnly))
            return false;
          return this.isPure(node.body, constantsOnly);
        } else if (t.isClassBody(node)) {
          for (var _iterator11 = node.body, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : (0, _getIterator3.default)(_iterator11);;) {
            var _ref11;
            if (_isArray11) {
              if (_i11 >= _iterator11.length)
                break;
              _ref11 = _iterator11[_i11++];
            } else {
              _i11 = _iterator11.next();
              if (_i11.done)
                break;
              _ref11 = _i11.value;
            }
            var method = _ref11;
            if (!this.isPure(method, constantsOnly))
              return false;
          }
          return true;
        } else if (t.isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (t.isArrayExpression(node)) {
          for (var _iterator12 = node.elements, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : (0, _getIterator3.default)(_iterator12);;) {
            var _ref12;
            if (_isArray12) {
              if (_i12 >= _iterator12.length)
                break;
              _ref12 = _iterator12[_i12++];
            } else {
              _i12 = _iterator12.next();
              if (_i12.done)
                break;
              _ref12 = _i12.value;
            }
            var elem = _ref12;
            if (!this.isPure(elem, constantsOnly))
              return false;
          }
          return true;
        } else if (t.isObjectExpression(node)) {
          for (var _iterator13 = node.properties, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : (0, _getIterator3.default)(_iterator13);;) {
            var _ref13;
            if (_isArray13) {
              if (_i13 >= _iterator13.length)
                break;
              _ref13 = _iterator13[_i13++];
            } else {
              _i13 = _iterator13.next();
              if (_i13.done)
                break;
              _ref13 = _i13.value;
            }
            var prop = _ref13;
            if (!this.isPure(prop, constantsOnly))
              return false;
          }
          return true;
        } else if (t.isClassMethod(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          if (node.kind === "get" || node.kind === "set")
            return false;
          return true;
        } else if (t.isClassProperty(node) || t.isObjectProperty(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          return this.isPure(node.value, constantsOnly);
        } else if (t.isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else {
          return t.isPureish(node);
        }
      };
      Scope.prototype.setData = function setData(key, val) {
        return this.data[key] = val;
      };
      Scope.prototype.getData = function getData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null)
            return data;
        } while (scope = scope.parent);
      };
      Scope.prototype.removeData = function removeData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null)
            scope.data[key] = null;
        } while (scope = scope.parent);
      };
      Scope.prototype.init = function init() {
        if (!this.references)
          this.crawl();
      };
      Scope.prototype.crawl = function crawl() {
        _crawlCallsCount++;
        this._crawl();
        _crawlCallsCount--;
      };
      Scope.prototype._crawl = function _crawl() {
        var path = this.path;
        this.references = (0, _create2.default)(null);
        this.bindings = (0, _create2.default)(null);
        this.globals = (0, _create2.default)(null);
        this.uids = (0, _create2.default)(null);
        this.data = (0, _create2.default)(null);
        if (path.isLoop()) {
          for (var _iterator14 = t.FOR_INIT_KEYS, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : (0, _getIterator3.default)(_iterator14);;) {
            var _ref14;
            if (_isArray14) {
              if (_i14 >= _iterator14.length)
                break;
              _ref14 = _iterator14[_i14++];
            } else {
              _i14 = _iterator14.next();
              if (_i14.done)
                break;
              _ref14 = _i14.value;
            }
            var key = _ref14;
            var node = path.get(key);
            if (node.isBlockScoped())
              this.registerBinding(node.node.kind, node);
          }
        }
        if (path.isFunctionExpression() && path.has("id")) {
          if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
            this.registerBinding("local", path.get("id"), path);
          }
        }
        if (path.isClassExpression() && path.has("id")) {
          if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
            this.registerBinding("local", path);
          }
        }
        if (path.isFunction()) {
          var params = path.get("params");
          for (var _iterator15 = params, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : (0, _getIterator3.default)(_iterator15);;) {
            var _ref15;
            if (_isArray15) {
              if (_i15 >= _iterator15.length)
                break;
              _ref15 = _iterator15[_i15++];
            } else {
              _i15 = _iterator15.next();
              if (_i15.done)
                break;
              _ref15 = _i15.value;
            }
            var param = _ref15;
            this.registerBinding("param", param);
          }
        }
        if (path.isCatchClause()) {
          this.registerBinding("let", path);
        }
        var parent = this.getProgramParent();
        if (parent.crawling)
          return;
        var state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        path.traverse(collectorVisitor, state);
        this.crawling = false;
        for (var _iterator16 = state.assignments, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : (0, _getIterator3.default)(_iterator16);;) {
          var _ref16;
          if (_isArray16) {
            if (_i16 >= _iterator16.length)
              break;
            _ref16 = _iterator16[_i16++];
          } else {
            _i16 = _iterator16.next();
            if (_i16.done)
              break;
            _ref16 = _i16.value;
          }
          var _path = _ref16;
          var ids = _path.getBindingIdentifiers();
          var programParent = void 0;
          for (var name in ids) {
            if (_path.scope.getBinding(name))
              continue;
            programParent = programParent || _path.scope.getProgramParent();
            programParent.addGlobal(ids[name]);
          }
          _path.scope.registerConstantViolation(_path);
        }
        for (var _iterator17 = state.references, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : (0, _getIterator3.default)(_iterator17);;) {
          var _ref17;
          if (_isArray17) {
            if (_i17 >= _iterator17.length)
              break;
            _ref17 = _iterator17[_i17++];
          } else {
            _i17 = _iterator17.next();
            if (_i17.done)
              break;
            _ref17 = _i17.value;
          }
          var ref = _ref17;
          var binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            ref.scope.getProgramParent().addGlobal(ref.node);
          }
        }
        for (var _iterator18 = state.constantViolations, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : (0, _getIterator3.default)(_iterator18);;) {
          var _ref18;
          if (_isArray18) {
            if (_i18 >= _iterator18.length)
              break;
            _ref18 = _iterator18[_i18++];
          } else {
            _i18 = _iterator18.next();
            if (_i18.done)
              break;
            _ref18 = _i18.value;
          }
          var _path2 = _ref18;
          _path2.scope.registerConstantViolation(_path2);
        }
      };
      Scope.prototype.push = function push(opts) {
        var path = this.path;
        if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = this.getFunctionParent().path;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          t.ensureBlock(path.node);
          path = path.get("body");
        }
        var unique = opts.unique;
        var kind = opts.kind || "var";
        var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        var dataKey = "declaration:" + kind + ":" + blockHoist;
        var declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          var declar = t.variableDeclaration(kind, []);
          declar._generated = true;
          declar._blockHoist = blockHoist;
          var _path$unshiftContaine = path.unshiftContainer("body", [declar]);
          declarPath = _path$unshiftContaine[0];
          if (!unique)
            path.setData(dataKey, declarPath);
        }
        var declarator = t.variableDeclarator(opts.id, opts.init);
        declarPath.node.declarations.push(declarator);
        this.registerBinding(kind, declarPath.get("declarations").pop());
      };
      Scope.prototype.getProgramParent = function getProgramParent() {
        var scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a Function or Program...");
      };
      Scope.prototype.getFunctionParent = function getFunctionParent() {
        var scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a Function or Program...");
      };
      Scope.prototype.getBlockParent = function getBlockParent() {
        var scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      };
      Scope.prototype.getAllBindings = function getAllBindings() {
        var ids = (0, _create2.default)(null);
        var scope = this;
        do {
          (0, _defaults2.default)(ids, scope.bindings);
          scope = scope.parent;
        } while (scope);
        return ids;
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
        var ids = (0, _create2.default)(null);
        for (var _iterator19 = arguments, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : (0, _getIterator3.default)(_iterator19);;) {
          var _ref19;
          if (_isArray19) {
            if (_i19 >= _iterator19.length)
              break;
            _ref19 = _iterator19[_i19++];
          } else {
            _i19 = _iterator19.next();
            if (_i19.done)
              break;
            _ref19 = _i19.value;
          }
          var kind = _ref19;
          var scope = this;
          do {
            for (var name in scope.bindings) {
              var binding = scope.bindings[name];
              if (binding.kind === kind)
                ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      };
      Scope.prototype.warnOnFlowBinding = function warnOnFlowBinding(binding) {
        if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {
          console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 6.8. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      ");
        }
        return binding;
      };
      Scope.prototype.getBinding = function getBinding(name) {
        var scope = this;
        do {
          var binding = scope.getOwnBinding(name);
          if (binding)
            return this.warnOnFlowBinding(binding);
        } while (scope = scope.parent);
      };
      Scope.prototype.getOwnBinding = function getOwnBinding(name) {
        return this.warnOnFlowBinding(this.bindings[name]);
      };
      Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
        var info = this.getBinding(name);
        return info && info.identifier;
      };
      Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
        var binding = this.bindings[name];
        return binding && binding.identifier;
      };
      Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      };
      Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
        if (!name)
          return false;
        if (this.hasOwnBinding(name))
          return true;
        if (this.parentHasBinding(name, noGlobals))
          return true;
        if (this.hasUid(name))
          return true;
        if (!noGlobals && (0, _includes2.default)(Scope.globals, name))
          return true;
        if (!noGlobals && (0, _includes2.default)(Scope.contextVariables, name))
          return true;
        return false;
      };
      Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {
        return this.parent && this.parent.hasBinding(name, noGlobals);
      };
      Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
        var info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      };
      Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
        delete this.bindings[name];
      };
      Scope.prototype.removeBinding = function removeBinding(name) {
        var info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
        }
        var scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      };
      return Scope;
    }());
    Scope.globals = (0, _keys2.default)(_globals2.default.builtin);
    Scope.contextVariables = [
      "arguments",
      "undefined",
      "Infinity",
      "NaN"
    ];
    exports.default = Scope;
    module.exports = exports["default"];
  }(scope, scope.exports));
  return scope.exports;
}

var ancestry = {};

var hasRequiredAncestry;
function requireAncestry() {
  if (hasRequiredAncestry)
    return ancestry;
  hasRequiredAncestry = 1;
  ancestry.__esModule = true;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  ancestry.findParent = findParent;
  ancestry.find = find;
  ancestry.getFunctionParent = getFunctionParent;
  ancestry.getStatementParent = getStatementParent;
  ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  ancestry.getAncestry = getAncestry;
  ancestry.isAncestor = isAncestor;
  ancestry.isDescendant = isDescendant;
  ancestry.inType = inType;
  ancestry.inShadow = inShadow;
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  var _index = requirePath();
  _interopRequireDefault(_index);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function findParent(callback) {
    var path = this;
    while (path = path.parentPath) {
      if (callback(path))
        return path;
    }
    return null;
  }
  function find(callback) {
    var path = this;
    do {
      if (callback(path))
        return path;
    } while (path = path.parentPath);
    return null;
  }
  function getFunctionParent() {
    return this.findParent(function (path) {
      return path.isFunction() || path.isProgram();
    });
  }
  function getStatementParent() {
    var path = this;
    do {
      if (Array.isArray(path.container)) {
        return path;
      }
    } while (path = path.parentPath);
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      var earliest = void 0;
      var keys = t.VISITOR_KEYS[deepest.type];
      for (var _iterator = ancestries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var ancestry = _ref;
        var path = ancestry[i + 1];
        if (!earliest) {
          earliest = path;
          continue;
        }
        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }
        var earliestKeyIndex = keys.indexOf(earliest.parentKey);
        var currentKeyIndex = keys.indexOf(path.parentKey);
        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }
      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    var _this = this;
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    var minDepth = Infinity;
    var lastCommonIndex = void 0, lastCommon = void 0;
    var ancestries = paths.map(function (path) {
      var ancestry = [];
      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== _this);
      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }
      return ancestry;
    });
    var first = ancestries[0];
    depthLoop:
      for (var i = 0; i < minDepth; i++) {
        var shouldMatch = first[i];
        for (var _iterator2 = ancestries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var ancestry = _ref2;
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    var path = this;
    var paths = [];
    do {
      paths.push(path);
    } while (path = path.parentPath);
    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent(function (parent) {
      return parent === maybeAncestor;
    });
  }
  function inType() {
    var path = this;
    while (path) {
      for (var _iterator3 = arguments, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var type = _ref3;
        if (path.node.type === type)
          return true;
      }
      path = path.parentPath;
    }
    return false;
  }
  function inShadow(key) {
    var parentFn = this.isFunction() ? this : this.findParent(function (p) {
      return p.isFunction();
    });
    if (!parentFn)
      return;
    if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {
      var shadow = parentFn.node.shadow;
      if (shadow && (!key || shadow[key] !== false)) {
        return parentFn;
      }
    } else if (parentFn.isArrowFunctionExpression()) {
      return parentFn;
    }
    return null;
  }
  return ancestry;
}

var inference = {};

var inferers = {};

var infererReference = {exports: {}};

var hasRequiredInfererReference;
function requireInfererReference() {
  if (hasRequiredInfererReference)
    return infererReference.exports;
  hasRequiredInfererReference = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports.default = function (node) {
      if (!this.isReferenced())
        return;
      var binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(this, node.name);
        }
      }
      if (node.name === "undefined") {
        return t.voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return t.numberTypeAnnotation();
      } else if (node.name === "arguments") ;
    };
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getTypeAnnotationBindingConstantViolations(path, name) {
      var binding = path.scope.getBinding(name);
      var types = [];
      path.typeAnnotation = t.unionTypeAnnotation(types);
      var functionConstantViolations = [];
      var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      var testType = getConditionalAnnotation(path, name);
      if (testType) {
        (function () {
          var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
          constantViolations = constantViolations.filter(function (path) {
            return testConstantViolations.indexOf(path) < 0;
          });
          types.push(testType.typeAnnotation);
        }());
      }
      if (constantViolations.length) {
        constantViolations = constantViolations.concat(functionConstantViolations);
        for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var violation = _ref;
          types.push(violation.getTypeAnnotation());
        }
      }
      if (types.length) {
        return t.createUnionTypeAnnotation(types);
      }
    }
    function getConstantViolationsBefore(binding, path, functions) {
      var violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter(function (violation) {
        violation = violation.resolve();
        var status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "function")
          functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path) {
      var operator = path.node.operator;
      var right = path.get("right").resolve();
      var left = path.get("left").resolve();
      var target = void 0;
      if (left.isIdentifier({ name: name })) {
        target = right;
      } else if (right.isIdentifier({ name: name })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return t.numberTypeAnnotation();
        } else {
          return;
        }
      } else {
        if (operator !== "===")
          return;
      }
      var typeofPath = void 0;
      var typePath = void 0;
      if (left.isUnaryExpression({ operator: "typeof" })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({ operator: "typeof" })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typePath && !typeofPath)
        return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral())
        return;
      var typeValue = typePath.node.value;
      if (typeof typeValue !== "string")
        return;
      if (!typeofPath.get("argument").isIdentifier({ name: name }))
        return;
      return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);
    }
    function getParentConditionalPath(path) {
      var parentPath = void 0;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          } else {
            return parentPath;
          }
        } else {
          path = parentPath;
        }
      }
    }
    function getConditionalAnnotation(path, name) {
      var ifStatement = getParentConditionalPath(path);
      if (!ifStatement)
        return;
      var test = ifStatement.get("test");
      var paths = [test];
      var types = [];
      do {
        var _path = paths.shift().resolve();
        if (_path.isLogicalExpression()) {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
        if (_path.isBinaryExpression()) {
          var type = inferAnnotationFromBinaryExpression(name, _path);
          if (type)
            types.push(type);
        }
      } while (paths.length);
      if (types.length) {
        return {
          typeAnnotation: t.createUnionTypeAnnotation(types),
          ifStatement: ifStatement
        };
      } else {
        return getConditionalAnnotation(ifStatement, name);
      }
    }
    module.exports = exports["default"];
  }(infererReference, infererReference.exports));
  return infererReference.exports;
}

var hasRequiredInferers;
function requireInferers() {
  if (hasRequiredInferers)
    return inferers;
  hasRequiredInferers = 1;
  (function (exports) {
    exports.__esModule = true;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = exports.Identifier = undefined;
    var _infererReference = requireInfererReference();
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_infererReference).default;
      }
    });
    exports.VariableDeclarator = VariableDeclarator;
    exports.TypeCastExpression = TypeCastExpression;
    exports.NewExpression = NewExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.UnaryExpression = UnaryExpression;
    exports.BinaryExpression = BinaryExpression;
    exports.LogicalExpression = LogicalExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.StringLiteral = StringLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.NullLiteral = NullLiteral;
    exports.RegExpLiteral = RegExpLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ArrayExpression = ArrayExpression;
    exports.RestElement = RestElement;
    exports.CallExpression = CallExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function VariableDeclarator() {
      var id = this.get("id");
      if (id.isIdentifier()) {
        return this.get("init").getTypeAnnotation();
      } else {
        return;
      }
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function NewExpression(node) {
      if (this.get("callee").isIdentifier()) {
        return t.genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return t.stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      var operator = node.operator;
      if (operator === "void") {
        return t.voidTypeAnnotation();
      } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.numberTypeAnnotation();
      } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.stringTypeAnnotation();
      } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      var operator = node.operator;
      if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t.numberTypeAnnotation();
      } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t.booleanTypeAnnotation();
      } else if (operator === "+") {
        var right = this.get("right");
        var left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return t.numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return t.stringTypeAnnotation();
        }
        return t.unionTypeAnnotation([
          t.stringTypeAnnotation(),
          t.numberTypeAnnotation()
        ]);
      }
    }
    function LogicalExpression() {
      return t.createUnionTypeAnnotation([
        this.get("left").getTypeAnnotation(),
        this.get("right").getTypeAnnotation()
      ]);
    }
    function ConditionalExpression() {
      return t.createUnionTypeAnnotation([
        this.get("consequent").getTypeAnnotation(),
        this.get("alternate").getTypeAnnotation()
      ]);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      var operator = node.operator;
      if (operator === "++" || operator === "--") {
        return t.numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return t.stringTypeAnnotation();
    }
    function NumericLiteral() {
      return t.numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return t.booleanTypeAnnotation();
    }
    function NullLiteral() {
      return t.nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return t.genericTypeAnnotation(t.identifier("RegExp"));
    }
    function ObjectExpression() {
      return t.genericTypeAnnotation(t.identifier("Object"));
    }
    function ArrayExpression() {
      return t.genericTypeAnnotation(t.identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return t.genericTypeAnnotation(t.identifier("Function"));
    }
    exports.FunctionExpression = Func;
    exports.ArrowFunctionExpression = Func;
    exports.FunctionDeclaration = Func;
    exports.ClassExpression = Func;
    exports.ClassDeclaration = Func;
    function CallExpression() {
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        if (callee.is("async")) {
          if (callee.is("generator")) {
            return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
          } else {
            return t.genericTypeAnnotation(t.identifier("Promise"));
          }
        } else {
          if (callee.node.returnType) {
            return callee.node.returnType;
          }
        }
      }
    }
  }(inferers));
  return inferers;
}

var hasRequiredInference;
function requireInference() {
  if (hasRequiredInference)
    return inference;
  hasRequiredInference = 1;
  inference.__esModule = true;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  inference.getTypeAnnotation = getTypeAnnotation;
  inference._getTypeAnnotation = _getTypeAnnotation;
  inference.isBaseType = isBaseType;
  inference.couldBeBaseType = couldBeBaseType;
  inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  inference.isGenericType = isGenericType;
  var _inferers = requireInferers();
  var inferers = _interopRequireWildcard(_inferers);
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function getTypeAnnotation() {
    if (this.typeAnnotation)
      return this.typeAnnotation;
    var type = this._getTypeAnnotation() || t.anyTypeAnnotation();
    if (t.isTypeAnnotation(type))
      type = type.typeAnnotation;
    return this.typeAnnotation = type;
  }
  function _getTypeAnnotation() {
    var node = this.node;
    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        var declar = this.parentPath.parentPath;
        var declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return t.stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return t.anyTypeAnnotation();
        }
        return t.voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }
    var inferer = inferers[node.type];
    if (inferer) {
      return inferer.call(this, node);
    }
    inferer = inferers[this.parentPath.type];
    if (inferer && inferer.validParent) {
      return this.parentPath.getTypeAnnotation();
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }
  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return t.isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return t.isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return t.isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return t.isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return t.isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return t.isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return t.isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error("Unknown base type " + baseName);
      }
    }
  }
  function couldBeBaseType(name) {
    var type = this.getTypeAnnotation();
    if (t.isAnyTypeAnnotation(type))
      return true;
    if (t.isUnionTypeAnnotation(type)) {
      for (var _iterator = type.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var type2 = _ref;
        if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(right) {
    var left = this.getTypeAnnotation();
    right = right.getTypeAnnotation();
    if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
  }
  function isGenericType(genericName) {
    var type = this.getTypeAnnotation();
    return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });
  }
  return inference;
}

var replacement = {};

var lib$1 = {exports: {}};

var _2_0_0$3 = {exports: {}};

var hasRequired_2_0_0$3;
function require_2_0_0$3() {
  if (hasRequired_2_0_0$3)
    return _2_0_0$3.exports;
  hasRequired_2_0_0$3 = 1;
  _2_0_0$3.exports = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  _2_0_0$3.exports.matchToToken = function (match) {
    var token = {
      type: "invalid",
      value: match[0]
    };
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
  return _2_0_0$3.exports;
}

var _1_1_0 = {exports: {}};

var _1_0_2;
var hasRequired_1_0_2;
function require_1_0_2() {
  if (hasRequired_1_0_2)
    return _1_0_2;
  hasRequired_1_0_2 = 1;
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  _1_0_2 = function (str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  return _1_0_2;
}

var _2_1_0 = {exports: {}};

var hasRequired_2_1_0;
function require_2_1_0() {
  if (hasRequired_2_1_0)
    return _2_1_0.exports;
  hasRequired_2_1_0 = 1;
  (function (module) {
    function assembleStyles() {
      var styles = {
        modifiers: {
          reset: [
            0,
            0
          ],
          bold: [
            1,
            22
          ],
          dim: [
            2,
            22
          ],
          italic: [
            3,
            23
          ],
          underline: [
            4,
            24
          ],
          inverse: [
            7,
            27
          ],
          hidden: [
            8,
            28
          ],
          strikethrough: [
            9,
            29
          ]
        },
        colors: {
          black: [
            30,
            39
          ],
          red: [
            31,
            39
          ],
          green: [
            32,
            39
          ],
          yellow: [
            33,
            39
          ],
          blue: [
            34,
            39
          ],
          magenta: [
            35,
            39
          ],
          cyan: [
            36,
            39
          ],
          white: [
            37,
            39
          ],
          gray: [
            90,
            39
          ]
        },
        bgColors: {
          bgBlack: [
            40,
            49
          ],
          bgRed: [
            41,
            49
          ],
          bgGreen: [
            42,
            49
          ],
          bgYellow: [
            43,
            49
          ],
          bgBlue: [
            44,
            49
          ],
          bgMagenta: [
            45,
            49
          ],
          bgCyan: [
            46,
            49
          ],
          bgWhite: [
            47,
            49
          ]
        }
      };
      styles.colors.grey = styles.colors.gray;
      Object.keys(styles).forEach(function (groupName) {
        var group = styles[groupName];
        Object.keys(group).forEach(function (styleName) {
          var style = group[styleName];
          styles[styleName] = group[styleName] = {
            open: "\x1B[" + style[0] + "m",
            close: "\x1B[" + style[1] + "m"
          };
        });
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      });
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }(_2_1_0));
  return _2_1_0.exports;
}

var _2_0_0$2;
var hasRequired_2_0_0$2;
function require_2_0_0$2() {
  if (hasRequired_2_0_0$2)
    return _2_0_0$2;
  hasRequired_2_0_0$2 = 1;
  _2_0_0$2 = function () {
    return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
  };
  return _2_0_0$2;
}

var _3_0_0;
var hasRequired_3_0_0;
function require_3_0_0() {
  if (hasRequired_3_0_0)
    return _3_0_0;
  hasRequired_3_0_0 = 1;
  var ansiRegex = require_2_0_0$2()();
  _3_0_0 = function (str) {
    return typeof str === "string" ? str.replace(ansiRegex, "") : str;
  };
  return _3_0_0;
}

var _2_0_0$1;
var hasRequired_2_0_0$1;
function require_2_0_0$1() {
  if (hasRequired_2_0_0$1)
    return _2_0_0$1;
  hasRequired_2_0_0$1 = 1;
  var ansiRegex = require_2_0_0$2();
  var re = new RegExp(ansiRegex().source);
  _2_0_0$1 = re.test.bind(re);
  return _2_0_0$1;
}

var _2_0_0;
var hasRequired_2_0_0;
function require_2_0_0() {
  if (hasRequired_2_0_0)
    return _2_0_0;
  hasRequired_2_0_0 = 1;
  var argv = process.argv;
  var terminator = argv.indexOf("--");
  var hasFlag = function (flag) {
    flag = "--" + flag;
    var pos = argv.indexOf(flag);
    return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
  };
  _2_0_0 = (function () {
    if ("FORCE_COLOR" in process.env) {
      return true;
    }
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      return false;
    }
    if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      return true;
    }
    if (process.stdout && !process.stdout.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return true;
    }
    if ("COLORTERM" in process.env) {
      return true;
    }
    if (process.env.TERM === "dumb") {
      return false;
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
      return true;
    }
    return false;
  }());
  return _2_0_0;
}

var hasRequired_1_1_0;
function require_1_1_0() {
  if (hasRequired_1_1_0)
    return _1_1_0.exports;
  hasRequired_1_1_0 = 1;
  var escapeStringRegexp = require_1_0_2();
  var ansiStyles = require_2_1_0();
  var stripAnsi = require_3_0_0();
  var hasAnsi = require_2_0_0$1();
  var supportsColor = require_2_0_0();
  var defineProps = Object.defineProperties;
  var isSimpleWindowsTerm = process.platform === "win32" && !/^xterm/i.test(process.env.TERM);
  function Chalk(options) {
    this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "\x1B[94m";
  }
  var styles = (function () {
    var ret = {};
    Object.keys(ansiStyles).forEach(function (key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function () {
          return build.call(this, this._styles.concat(key));
        }
      };
    });
    return ret;
  }());
  var proto = defineProps(function chalk() {
  }, styles);
  function build(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.enabled = this.enabled;
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    var args = arguments;
    var argsLen = args.length;
    var str = argsLen !== 0 && String(arguments[0]);
    if (argsLen > 1) {
      for (var a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || !str) {
      return str;
    }
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    var originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && (nestedStyles.indexOf("gray") !== -1 || nestedStyles.indexOf("grey") !== -1)) {
      ansiStyles.dim.open = "";
    }
    while (i--) {
      var code = ansiStyles[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function init() {
    var ret = {};
    Object.keys(styles).forEach(function (name) {
      ret[name] = {
        get: function () {
          return build.call(this, [name]);
        }
      };
    });
    return ret;
  }
  defineProps(Chalk.prototype, init());
  _1_1_0.exports = new Chalk();
  _1_1_0.exports.styles = ansiStyles;
  _1_1_0.exports.hasColor = hasAnsi;
  _1_1_0.exports.stripColor = stripAnsi;
  _1_1_0.exports.supportsColor = supportsColor;
  return _1_1_0.exports;
}

var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4)
    return lib$1.exports;
  hasRequiredLib$4 = 1;
  (function (module, exports) {
    exports.__esModule = true;
    exports.default = function (rawLines, lineNumber, colNumber) {
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      colNumber = Math.max(colNumber, 0);
      var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
      var chalk = _chalk2.default;
      if (opts.forceColor) {
        chalk = new _chalk2.default.constructor({ enabled: true });
      }
      var maybeHighlight = function maybeHighlight(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      };
      var defs = getDefs(chalk);
      if (highlighted)
        rawLines = highlight(defs, rawLines);
      var linesAbove = opts.linesAbove || 2;
      var linesBelow = opts.linesBelow || 3;
      var lines = rawLines.split(NEWLINE);
      var start = Math.max(lineNumber - (linesAbove + 1), 0);
      var end = Math.min(lines.length, lineNumber + linesBelow);
      if (!lineNumber && !colNumber) {
        start = 0;
        end = lines.length;
      }
      var numberMaxWidth = String(end).length;
      var frame = lines.slice(start, end).map(function (line, index) {
        var number = start + 1 + index;
        var paddedNumber = (" " + number).slice(-numberMaxWidth);
        var gutter = " " + paddedNumber + " | ";
        if (number === lineNumber) {
          var markerLine = "";
          if (colNumber) {
            var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
            markerLine = [
              "\n ",
              maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")),
              markerSpacing,
              maybeHighlight(defs.marker, "^")
            ].join("");
          }
          return [
            maybeHighlight(defs.marker, ">"),
            maybeHighlight(defs.gutter, gutter),
            line,
            markerLine
          ].join("");
        } else {
          return " " + maybeHighlight(defs.gutter, gutter) + line;
        }
      }).join("\n");
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    };
    var _jsTokens = require_2_0_0$3();
    var _jsTokens2 = _interopRequireDefault(_jsTokens);
    var _esutils = utils;
    var _esutils2 = _interopRequireDefault(_esutils);
    var _chalk = require_1_1_0();
    var _chalk2 = _interopRequireDefault(_chalk);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsx_tag: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold,
        gutter: chalk.grey,
        marker: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var BRACKET = /^[()\[\]{}]$/;
    function getTokenType(match) {
      var _match$slice = match.slice(-2), offset = _match$slice[0], text = _match$slice[1];
      var token = _jsTokens2.default.matchToToken(match);
      if (token.type === "name") {
        if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsx_tag";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      return token.type;
    }
    function highlight(defs, text) {
      return text.replace(_jsTokens2.default, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var type = getTokenType(args);
        var colorize = defs[type];
        if (colorize) {
          return args[0].split(NEWLINE).map(function (str) {
            return colorize(str);
          }).join("\n");
        } else {
          return args[0];
        }
      });
    }
    module.exports = exports["default"];
  }(lib$1, lib$1.exports));
  return lib$1.exports;
}

var lib = {};

var parser$1 = {};

var identifier = {};

var hasRequiredIdentifier;
function requireIdentifier() {
  if (hasRequiredIdentifier)
    return identifier;
  hasRequiredIdentifier = 1;
  identifier.__esModule = true;
  identifier.isIdentifierStart = isIdentifierStart;
  identifier.isIdentifierChar = isIdentifierChar;
  function makePredicate(words) {
    words = words.split(" ");
    return function (str) {
      return words.indexOf(str) >= 0;
    };
  }
  identifier.reservedWords = {
    6: makePredicate("enum await"),
    strict: makePredicate("implements interface let package private protected public static yield"),
    strictBind: makePredicate("eval arguments")
  };
  identifier.isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");
  var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ\u2118-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ\u309B-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞮꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
  var nonASCIIidentifierChars = "‌‍\xB7̀-ͯ\u0387҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣔ-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟\u1369-\u1371ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-\u19DAᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    17,
    26,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    26,
    45,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    785,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    42,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    54,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    86,
    25,
    391,
    63,
    32,
    0,
    449,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    881,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    881,
    68,
    12,
    0,
    67,
    12,
    65,
    0,
    32,
    6124,
    20,
    754,
    9486,
    1,
    3071,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    4149,
    196,
    60,
    67,
    1213,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42710,
    42,
    4148,
    12,
    221,
    3,
    5761,
    10591,
    541
  ];
  var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    1306,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    52,
    0,
    13,
    2,
    49,
    13,
    10,
    2,
    4,
    9,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    57,
    0,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    87,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    423,
    9,
    838,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    19882,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1016,
    45,
    17,
    3,
    19723,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    2214,
    6,
    110,
    6,
    6,
    9,
    792487,
    239
  ];
  function isInAstralSet(code, set) {
    var pos = 65536;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code < 91)
      return true;
    if (code < 97)
      return code === 95;
    if (code < 123)
      return true;
    if (code <= 65535)
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code < 91)
      return true;
    if (code < 97)
      return code === 95;
    if (code < 123)
      return true;
    if (code <= 65535)
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  return identifier;
}

var options = {};

var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions)
    return options;
  hasRequiredOptions = 1;
  options.__esModule = true;
  options.getOptions = getOptions;
  var defaultOptions = options.defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    plugins: [],
    strictMode: null
  };
  function getOptions(opts) {
    var options = {};
    for (var key in defaultOptions) {
      options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
    }
    return options;
  }
  return options;
}

var tokenizer = {};

var types = {};

var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types;
  hasRequiredTypes = 1;
  types.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var TokenType = types.TokenType = function TokenType(label) {
    var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    _classCallCheck(this, TokenType);
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name, prec) {
    return new TokenType(name, {
      beforeExpr: true,
      binop: prec
    });
  }
  var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
  var types$1 = types.types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: true,
      startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceR: new TokenType("}"),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr: true,
      startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    doubleColon: new TokenType("::", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: true,
      startsExpr: true
    }),
    at: new TokenType("@"),
    eq: new TokenType("=", {
      beforeExpr: true,
      isAssign: true
    }),
    assign: new TokenType("_=", {
      beforeExpr: true,
      isAssign: true
    }),
    incDec: new TokenType("++/--", {
      prefix: true,
      postfix: true,
      startsExpr: true
    }),
    prefix: new TokenType("prefix", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=", 6),
    relational: binop("</>", 7),
    bitShift: binop("<</>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: true,
      binop: 9,
      prefix: true,
      startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr: true,
      binop: 11,
      rightAssociative: true
    })
  };
  var keywords = types.keywords = {};
  function kw(name) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    options.keyword = name;
    keywords[name] = types$1["_" + name] = new TokenType(name, options);
  }
  kw("break");
  kw("case", beforeExpr);
  kw("catch");
  kw("continue");
  kw("debugger");
  kw("default", beforeExpr);
  kw("do", {
    isLoop: true,
    beforeExpr: true
  });
  kw("else", beforeExpr);
  kw("finally");
  kw("for", { isLoop: true });
  kw("function", startsExpr);
  kw("if");
  kw("return", beforeExpr);
  kw("switch");
  kw("throw", beforeExpr);
  kw("try");
  kw("var");
  kw("let");
  kw("const");
  kw("while", { isLoop: true });
  kw("with");
  kw("new", {
    beforeExpr: true,
    startsExpr: true
  });
  kw("this", startsExpr);
  kw("super", startsExpr);
  kw("class");
  kw("extends", beforeExpr);
  kw("export");
  kw("import");
  kw("yield", {
    beforeExpr: true,
    startsExpr: true
  });
  kw("null", startsExpr);
  kw("true", startsExpr);
  kw("false", startsExpr);
  kw("in", {
    beforeExpr: true,
    binop: 7
  });
  kw("instanceof", {
    beforeExpr: true,
    binop: 7
  });
  kw("typeof", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  });
  kw("void", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  });
  kw("delete", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  });
  return types;
}

var context$2 = {};

var whitespace = {};

var hasRequiredWhitespace;
function requireWhitespace() {
  if (hasRequiredWhitespace)
    return whitespace;
  hasRequiredWhitespace = 1;
  whitespace.__esModule = true;
  whitespace.isNewLine = isNewLine;
  var lineBreak = whitespace.lineBreak = /\r\n?|\n|\u2028|\u2029/;
  whitespace.lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    return code === 10 || code === 13 || code === 8232 || code === 8233;
  }
  whitespace.nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  return whitespace;
}

var hasRequiredContext$2;
function requireContext$2() {
  if (hasRequiredContext$2)
    return context$2;
  hasRequiredContext$2 = 1;
  context$2.__esModule = true;
  context$2.types = context$2.TokContext = undefined;
  var _types = requireTypes();
  var _whitespace = requireWhitespace();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var TokContext = context$2.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
    _classCallCheck(this, TokContext);
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  };
  var types = context$2.types = {
    braceStatement: new TokContext("{", false),
    braceExpression: new TokContext("{", true),
    templateQuasi: new TokContext("${", true),
    parenStatement: new TokContext("(", false),
    parenExpression: new TokContext("(", true),
    template: new TokContext("`", true, true, function (p) {
      return p.readTmplToken();
    }),
    functionExpression: new TokContext("function", true)
  };
  _types.types.parenR.updateContext = _types.types.braceR.updateContext = function () {
    if (this.state.context.length === 1) {
      this.state.exprAllowed = true;
      return;
    }
    var out = this.state.context.pop();
    if (out === types.braceStatement && this.curContext() === types.functionExpression) {
      this.state.context.pop();
      this.state.exprAllowed = false;
    } else if (out === types.templateQuasi) {
      this.state.exprAllowed = true;
    } else {
      this.state.exprAllowed = !out.isExpr;
    }
  };
  _types.types.name.updateContext = function (prevType) {
    this.state.exprAllowed = false;
    if (prevType === _types.types._let || prevType === _types.types._const || prevType === _types.types._var) {
      if (_whitespace.lineBreak.test(this.input.slice(this.state.end))) {
        this.state.exprAllowed = true;
      }
    }
  };
  _types.types.braceL.updateContext = function (prevType) {
    this.state.context.push(this.braceIsBlock(prevType) ? types.braceStatement : types.braceExpression);
    this.state.exprAllowed = true;
  };
  _types.types.dollarBraceL.updateContext = function () {
    this.state.context.push(types.templateQuasi);
    this.state.exprAllowed = true;
  };
  _types.types.parenL.updateContext = function (prevType) {
    var statementParens = prevType === _types.types._if || prevType === _types.types._for || prevType === _types.types._with || prevType === _types.types._while;
    this.state.context.push(statementParens ? types.parenStatement : types.parenExpression);
    this.state.exprAllowed = true;
  };
  _types.types.incDec.updateContext = function () {
  };
  _types.types._function.updateContext = function () {
    if (this.curContext() !== types.braceStatement) {
      this.state.context.push(types.functionExpression);
    }
    this.state.exprAllowed = false;
  };
  _types.types.backQuote.updateContext = function () {
    if (this.curContext() === types.template) {
      this.state.context.pop();
    } else {
      this.state.context.push(types.template);
    }
    this.state.exprAllowed = false;
  };
  return context$2;
}

var location$1 = {};

var hasRequiredLocation$1;
function requireLocation$1() {
  if (hasRequiredLocation$1)
    return location$1;
  hasRequiredLocation$1 = 1;
  location$1.__esModule = true;
  location$1.SourceLocation = location$1.Position = undefined;
  location$1.getLineInfo = getLineInfo;
  var _whitespace = requireWhitespace();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Position = location$1.Position = function Position(line, col) {
    _classCallCheck(this, Position);
    this.line = line;
    this.column = col;
  };
  location$1.SourceLocation = function SourceLocation(start, end) {
    _classCallCheck(this, SourceLocation);
    this.start = start;
    this.end = end;
  };
  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      _whitespace.lineBreakG.lastIndex = cur;
      var match = _whitespace.lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur);
      }
    }
  }
  return location$1;
}

var state = {};

var hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  state.__esModule = true;
  var _location = requireLocation$1();
  var _context = requireContext$2();
  var _types = requireTypes();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var State = (function () {
    function State() {
      _classCallCheck(this, State);
    }
    State.prototype.init = function init(options, input) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.input = input;
      this.potentialArrowAt = -1;
      this.inMethod = this.inFunction = this.inGenerator = this.inAsync = false;
      this.labels = [];
      this.decorators = [];
      this.tokens = [];
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.pos = this.lineStart = 0;
      this.curLine = 1;
      this.type = _types.types.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = [_context.types.braceStatement];
      this.exprAllowed = true;
      this.containsEsc = this.containsOctal = false;
      this.octalPosition = null;
      this.exportedIdentifiers = {};
      return this;
    };
    State.prototype.curPosition = function curPosition() {
      return new _location.Position(this.curLine, this.pos - this.lineStart);
    };
    State.prototype.clone = function clone(skipArrays) {
      var state = new State();
      for (var key in this) {
        var val = this[key];
        if ((!skipArrays || key === "context") && Array.isArray(val)) {
          val = val.slice();
        }
        state[key] = val;
      }
      return state;
    };
    return State;
  }());
  state.default = State;
  return state;
}

var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer)
    return tokenizer;
  hasRequiredTokenizer = 1;
  tokenizer.__esModule = true;
  tokenizer.Token = undefined;
  var _identifier = requireIdentifier();
  var _types = requireTypes();
  var _context = requireContext$2();
  var _location = requireLocation$1();
  var _whitespace = requireWhitespace();
  var _state = requireState();
  var _state2 = _interopRequireDefault(_state);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Token = tokenizer.Token = function Token(state) {
    _classCallCheck(this, Token);
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new _location.SourceLocation(state.startLoc, state.endLoc);
  };
  function codePointToString(code) {
    if (code <= 65535) {
      return String.fromCharCode(code);
    } else {
      return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
    }
  }
  var Tokenizer = (function () {
    function Tokenizer(options, input) {
      _classCallCheck(this, Tokenizer);
      this.state = new _state2.default();
      this.state.init(options, input);
    }
    Tokenizer.prototype.next = function next() {
      if (!this.isLookahead) {
        this.state.tokens.push(new Token(this.state));
      }
      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    };
    Tokenizer.prototype.eat = function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    Tokenizer.prototype.match = function match(type) {
      return this.state.type === type;
    };
    Tokenizer.prototype.isKeyword = function isKeyword(word) {
      return (0, _identifier.isKeyword)(word);
    };
    Tokenizer.prototype.lookahead = function lookahead() {
      var old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      var curr = this.state.clone(true);
      this.state = old;
      return curr;
    };
    Tokenizer.prototype.setStrict = function setStrict(strict) {
      this.state.strict = strict;
      if (!this.match(_types.types.num) && !this.match(_types.types.string))
        return;
      this.state.pos = this.state.start;
      while (this.state.pos < this.state.lineStart) {
        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
        --this.state.curLine;
      }
      this.nextToken();
    };
    Tokenizer.prototype.curContext = function curContext() {
      return this.state.context[this.state.context.length - 1];
    };
    Tokenizer.prototype.nextToken = function nextToken() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace)
        this.skipSpace();
      this.state.containsOctal = false;
      this.state.octalPosition = null;
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.input.length)
        return this.finishToken(_types.types.eof);
      if (curContext.override) {
        return curContext.override(this);
      } else {
        return this.readToken(this.fullCharCodeAtPos());
      }
    };
    Tokenizer.prototype.readToken = function readToken(code) {
      if ((0, _identifier.isIdentifierStart)(code) || code === 92) {
        return this.readWord();
      } else {
        return this.getTokenFromCode(code);
      }
    };
    Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
      var code = this.input.charCodeAt(this.state.pos);
      if (code <= 55295 || code >= 57344)
        return code;
      var next = this.input.charCodeAt(this.state.pos + 1);
      return (code << 10) + next - 56613888;
    };
    Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new _location.SourceLocation(startLoc, endLoc)
      };
      if (!this.isLookahead) {
        this.state.tokens.push(comment);
        this.state.comments.push(comment);
        this.addComment(comment);
      }
    };
    Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
      var startLoc = this.state.curPosition();
      var start = this.state.pos, end = this.input.indexOf("*/", this.state.pos += 2);
      if (end === -1)
        this.raise(this.state.pos - 2, "Unterminated comment");
      this.state.pos = end + 2;
      _whitespace.lineBreakG.lastIndex = start;
      var match = void 0;
      while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    };
    Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);
      while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
        ++this.state.pos;
        ch = this.input.charCodeAt(this.state.pos);
      }
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    };
    Tokenizer.prototype.skipSpace = function skipSpace() {
      loop:
        while (this.state.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
          case 32:
          case 160:
            ++this.state.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
            }
            break;
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++this.state.pos;
            } else {
              break loop;
            }
          }
        }
    };
    Tokenizer.prototype.finishToken = function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      this.updateContext(prevType);
    };
    Tokenizer.prototype.readToken_dot = function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 46 && next2 === 46) {
        this.state.pos += 3;
        return this.finishToken(_types.types.ellipsis);
      } else {
        ++this.state.pos;
        return this.finishToken(_types.types.dot);
      }
    };
    Tokenizer.prototype.readToken_slash = function readToken_slash() {
      if (this.state.exprAllowed) {
        ++this.state.pos;
        return this.readRegexp();
      }
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        return this.finishOp(_types.types.assign, 2);
      } else {
        return this.finishOp(_types.types.slash, 1);
      }
    };
    Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
      var type = code === 42 ? _types.types.star : _types.types.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = _types.types.exponent;
      }
      if (next === 61) {
        width++;
        type = _types.types.assign;
      }
      return this.finishOp(type, width);
    };
    Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code)
        return this.finishOp(code === 124 ? _types.types.logicalOR : _types.types.logicalAND, 2);
      if (next === 61)
        return this.finishOp(_types.types.assign, 2);
      if (code === 124 && next === 125 && this.hasPlugin("flow"))
        return this.finishOp(_types.types.braceBarR, 2);
      return this.finishOp(code === 124 ? _types.types.bitwiseOR : _types.types.bitwiseAND, 1);
    };
    Tokenizer.prototype.readToken_caret = function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        return this.finishOp(_types.types.assign, 2);
      } else {
        return this.finishOp(_types.types.bitwiseXOR, 1);
      }
    };
    Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) {
        if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && _whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(_types.types.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(_types.types.assign, 2);
      } else {
        return this.finishOp(_types.types.plusMin, 1);
      }
    };
    Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.state.pos + size) === 61)
          return this.finishOp(_types.types.assign, size + 1);
        return this.finishOp(_types.types.bitShift, size);
      }
      if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        if (this.inModule)
          this.unexpected();
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(_types.types.relational, size);
    };
    Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61)
        return this.finishOp(_types.types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      if (code === 61 && next === 62) {
        this.state.pos += 2;
        return this.finishToken(_types.types.arrow);
      }
      return this.finishOp(code === 61 ? _types.types.eq : _types.types.prefix, 1);
    };
    Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
      switch (code) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.state.pos;
        return this.finishToken(_types.types.parenL);
      case 41:
        ++this.state.pos;
        return this.finishToken(_types.types.parenR);
      case 59:
        ++this.state.pos;
        return this.finishToken(_types.types.semi);
      case 44:
        ++this.state.pos;
        return this.finishToken(_types.types.comma);
      case 91:
        ++this.state.pos;
        return this.finishToken(_types.types.bracketL);
      case 93:
        ++this.state.pos;
        return this.finishToken(_types.types.bracketR);
      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(_types.types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(_types.types.braceL);
        }
      case 125:
        ++this.state.pos;
        return this.finishToken(_types.types.braceR);
      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(_types.types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(_types.types.colon);
        }
      case 63:
        ++this.state.pos;
        return this.finishToken(_types.types.question);
      case 64:
        ++this.state.pos;
        return this.finishToken(_types.types.at);
      case 96:
        ++this.state.pos;
        return this.finishToken(_types.types.backQuote);
      case 48:
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88)
          return this.readRadixNumber(16);
        if (next === 111 || next === 79)
          return this.readRadixNumber(8);
        if (next === 98 || next === 66)
          return this.readRadixNumber(2);
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(false);
      case 34:
      case 39:
        return this.readString(code);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo(code);
      case 124:
      case 38:
        return this.readToken_pipe_amp(code);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(code);
      case 60:
      case 62:
        return this.readToken_lt_gt(code);
      case 61:
      case 33:
        return this.readToken_eq_excl(code);
      case 126:
        return this.finishOp(_types.types.prefix, 1);
      }
      this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    Tokenizer.prototype.finishOp = function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      return this.finishToken(type, str);
    };
    Tokenizer.prototype.readRegexp = function readRegexp() {
      var escaped = void 0, inClass = void 0, start = this.state.pos;
      for (;;) {
        if (this.state.pos >= this.input.length)
          this.raise(start, "Unterminated regular expression");
        var ch = this.input.charAt(this.state.pos);
        if (_whitespace.lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped = ch === "\\";
        }
        ++this.state.pos;
      }
      var content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      var mods = this.readWord1();
      if (mods) {
        var validFlags = /^[gmsiyu]*$/;
        if (!validFlags.test(mods))
          this.raise(start, "Invalid regular expression flag");
      }
      return this.finishToken(_types.types.regexp, {
        pattern: content,
        flags: mods
      });
    };
    Tokenizer.prototype.readInt = function readInt(radix, len) {
      var start = this.state.pos, total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos), val = void 0;
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix)
          break;
        ++this.state.pos;
        total = total * radix + val;
      }
      if (this.state.pos === start || len != null && this.state.pos - start !== len)
        return null;
      return total;
    };
    Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
      this.state.pos += 2;
      var val = this.readInt(radix);
      if (val == null)
        this.raise(this.state.start + 2, "Expected number in radix " + radix);
      if ((0, _identifier.isIdentifierStart)(this.fullCharCodeAtPos()))
        this.raise(this.state.pos, "Identifier directly after number");
      return this.finishToken(_types.types.num, val);
    };
    Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
      var start = this.state.pos, isFloat = false, octal = this.input.charCodeAt(this.state.pos) === 48;
      if (!startsWithDot && this.readInt(10) === null)
        this.raise(start, "Invalid number");
      var next = this.input.charCodeAt(this.state.pos);
      if (next === 46) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 69 || next === 101) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45)
          ++this.state.pos;
        if (this.readInt(10) === null)
          this.raise(start, "Invalid number");
        isFloat = true;
      }
      if ((0, _identifier.isIdentifierStart)(this.fullCharCodeAtPos()))
        this.raise(this.state.pos, "Identifier directly after number");
      var str = this.input.slice(start, this.state.pos), val = void 0;
      if (isFloat) {
        val = parseFloat(str);
      } else if (!octal || str.length === 1) {
        val = parseInt(str, 10);
      } else if (/[89]/.test(str) || this.state.strict) {
        this.raise(start, "Invalid number");
      } else {
        val = parseInt(str, 8);
      }
      return this.finishToken(_types.types.num, val);
    };
    Tokenizer.prototype.readCodePoint = function readCodePoint() {
      var ch = this.input.charCodeAt(this.state.pos), code = void 0;
      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos);
        ++this.state.pos;
        if (code > 1114111)
          this.raise(codePos, "Code point out of bounds");
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    Tokenizer.prototype.readString = function readString(quote) {
      var out = "", chunkStart = ++this.state.pos;
      for (;;) {
        if (this.state.pos >= this.input.length)
          this.raise(this.state.start, "Unterminated string constant");
        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else {
          if ((0, _whitespace.isNewLine)(ch))
            this.raise(this.state.start, "Unterminated string constant");
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(_types.types.string, out);
    };
    Tokenizer.prototype.readTmplToken = function readTmplToken() {
      var out = "", chunkStart = this.state.pos;
      for (;;) {
        if (this.state.pos >= this.input.length)
          this.raise(this.state.start, "Unterminated template");
        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(_types.types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              return this.finishToken(_types.types.dollarBraceL);
            } else {
              ++this.state.pos;
              return this.finishToken(_types.types.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.state.pos);
          return this.finishToken(_types.types.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.state.pos;
        } else if ((0, _whitespace.isNewLine)(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;
          switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10)
              ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    };
    Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;
      switch (ch) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return codePointToString(this.readCodePoint());
      case 116:
        return "\t";
      case 98:
        return "\b";
      case 118:
        return "\x0B";
      case 102:
        return "\f";
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10)
          ++this.state.pos;
      case 10:
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (!this.state.containsOctal) {
              this.state.containsOctal = true;
              this.state.octalPosition = this.state.pos - 2;
            }
            if (this.state.strict || inTemplate) {
              this.raise(this.state.pos - 2, "Octal literal in strict mode");
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
      }
    };
    Tokenizer.prototype.readHexChar = function readHexChar(len) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len);
      if (n === null)
        this.raise(codePos, "Bad character escape sequence");
      return n;
    };
    Tokenizer.prototype.readWord1 = function readWord1() {
      this.state.containsEsc = false;
      var word = "", first = true, chunkStart = this.state.pos;
      while (this.state.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if ((0, _identifier.isIdentifierChar)(ch)) {
          this.state.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.state.pos;
          var esc = this.readCodePoint();
          if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, true)) {
            this.raise(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.state.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    };
    Tokenizer.prototype.readWord = function readWord() {
      var word = this.readWord1();
      var type = _types.types.name;
      if (!this.state.containsEsc && this.isKeyword(word)) {
        type = _types.keywords[word];
      }
      return this.finishToken(type, word);
    };
    Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
      if (prevType === _types.types.colon) {
        var parent = this.curContext();
        if (parent === _context.types.braceStatement || parent === _context.types.braceExpression) {
          return !parent.isExpr;
        }
      }
      if (prevType === _types.types._return) {
        return _whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      }
      if (prevType === _types.types._else || prevType === _types.types.semi || prevType === _types.types.eof || prevType === _types.types.parenR) {
        return true;
      }
      if (prevType === _types.types.braceL) {
        return this.curContext() === _context.types.braceStatement;
      }
      return !this.state.exprAllowed;
    };
    Tokenizer.prototype.updateContext = function updateContext(prevType) {
      var update = void 0, type = this.state.type;
      if (type.keyword && prevType === _types.types.dot) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    };
    return Tokenizer;
  }());
  tokenizer.default = Tokenizer;
  return tokenizer;
}

var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser)
    return parser$1;
  hasRequiredParser = 1;
  (function (exports) {
    exports.__esModule = true;
    exports.plugins = undefined;
    var _identifier = requireIdentifier();
    var _options = requireOptions();
    var _tokenizer = requireTokenizer();
    var _tokenizer2 = _interopRequireDefault(_tokenizer);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    exports.plugins = {};
    var Parser = function (_Tokenizer) {
      _inherits(Parser, _Tokenizer);
      function Parser(options, input) {
        _classCallCheck(this, Parser);
        options = (0, _options.getOptions)(options);
        var _this = _possibleConstructorReturn(this, _Tokenizer.call(this, options, input));
        _this.options = options;
        _this.inModule = _this.options.sourceType === "module";
        _this.isReservedWord = _identifier.reservedWords[6];
        _this.input = input;
        _this.plugins = _this.loadPlugins(_this.options.plugins);
        _this.filename = options.sourceFilename;
        if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
          _this.skipLineComment(2);
        }
        return _this;
      }
      Parser.prototype.hasPlugin = function hasPlugin(name) {
        return !!(this.plugins["*"] || this.plugins[name]);
      };
      Parser.prototype.extend = function extend(name, f) {
        this[name] = f(this[name]);
      };
      Parser.prototype.loadPlugins = function loadPlugins(plugins) {
        var pluginMap = {};
        if (plugins.indexOf("flow") >= 0) {
          plugins = plugins.filter(function (plugin) {
            return plugin !== "flow";
          });
          plugins.push("flow");
        }
        for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var name = _ref;
          if (!pluginMap[name]) {
            pluginMap[name] = true;
            var plugin = exports.plugins[name];
            if (plugin)
              plugin(this);
          }
        }
        return pluginMap;
      };
      Parser.prototype.parse = function parse() {
        var file = this.startNode();
        var program = this.startNode();
        this.nextToken();
        return this.parseTopLevel(file, program);
      };
      return Parser;
    }(_tokenizer2.default);
    exports.default = Parser;
  }(parser$1));
  return parser$1;
}

var util$1 = {};

var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1)
    return util$1;
  hasRequiredUtil$1 = 1;
  var _types = requireTypes();
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  var _whitespace = requireWhitespace();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _index2.default.prototype;
  pp.addExtra = function (node, key, val) {
    if (!node)
      return;
    var extra = node.extra = node.extra || {};
    extra[key] = val;
  };
  pp.isRelational = function (op) {
    return this.match(_types.types.relational) && this.state.value === op;
  };
  pp.expectRelational = function (op) {
    if (this.isRelational(op)) {
      this.next();
    } else {
      this.unexpected();
    }
  };
  pp.isContextual = function (name) {
    return this.match(_types.types.name) && this.state.value === name;
  };
  pp.eatContextual = function (name) {
    return this.state.value === name && this.eat(_types.types.name);
  };
  pp.expectContextual = function (name, message) {
    if (!this.eatContextual(name))
      this.unexpected(null, message);
  };
  pp.canInsertSemicolon = function () {
    return this.match(_types.types.eof) || this.match(_types.types.braceR) || _whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
  };
  pp.isLineTerminator = function () {
    return this.eat(_types.types.semi) || this.canInsertSemicolon();
  };
  pp.semicolon = function () {
    if (!this.isLineTerminator())
      this.unexpected();
  };
  pp.expect = function (type, pos) {
    return this.eat(type) || this.unexpected(pos);
  };
  pp.unexpected = function (pos) {
    var message = arguments.length <= 1 || arguments[1] === undefined ? "Unexpected token" : arguments[1];
    this.raise(pos != null ? pos : this.state.start, message);
  };
  return util$1;
}

var statement = {};

var hasRequiredStatement;
function requireStatement() {
  if (hasRequiredStatement)
    return statement;
  hasRequiredStatement = 1;
  var _types = requireTypes();
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  var _whitespace = requireWhitespace();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _index2.default.prototype;
  pp.parseTopLevel = function (file, program) {
    program.sourceType = this.options.sourceType;
    this.parseBlockBody(program, true, true, _types.types.eof);
    file.program = this.finishNode(program, "Program");
    file.comments = this.state.comments;
    file.tokens = this.state.tokens;
    return this.finishNode(file, "File");
  };
  var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
  pp.stmtToDirective = function (stmt) {
    var expr = stmt.expression;
    var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
    var directive = this.startNodeAt(stmt.start, stmt.loc.start);
    var raw = this.input.slice(expr.start, expr.end);
    var val = directiveLiteral.value = raw.slice(1, -1);
    this.addExtra(directiveLiteral, "raw", raw);
    this.addExtra(directiveLiteral, "rawValue", val);
    directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
    return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
  };
  pp.parseStatement = function (declaration, topLevel) {
    if (this.match(_types.types.at)) {
      this.parseDecorators(true);
    }
    var starttype = this.state.type, node = this.startNode();
    switch (starttype) {
    case _types.types._break:
    case _types.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _types.types._debugger:
      return this.parseDebuggerStatement(node);
    case _types.types._do:
      return this.parseDoStatement(node);
    case _types.types._for:
      return this.parseForStatement(node);
    case _types.types._function:
      if (!declaration)
        this.unexpected();
      return this.parseFunctionStatement(node);
    case _types.types._class:
      if (!declaration)
        this.unexpected();
      this.takeDecorators(node);
      return this.parseClass(node, true);
    case _types.types._if:
      return this.parseIfStatement(node);
    case _types.types._return:
      return this.parseReturnStatement(node);
    case _types.types._switch:
      return this.parseSwitchStatement(node);
    case _types.types._throw:
      return this.parseThrowStatement(node);
    case _types.types._try:
      return this.parseTryStatement(node);
    case _types.types._let:
    case _types.types._const:
      if (!declaration)
        this.unexpected();
    case _types.types._var:
      return this.parseVarStatement(node, starttype);
    case _types.types._while:
      return this.parseWhileStatement(node);
    case _types.types._with:
      return this.parseWithStatement(node);
    case _types.types.braceL:
      return this.parseBlock();
    case _types.types.semi:
      return this.parseEmptyStatement(node);
    case _types.types._export:
    case _types.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === _types.types._import ? this.parseImport(node) : this.parseExport(node);
    case _types.types.name:
      if (this.state.value === "async") {
        var state = this.state.clone();
        this.next();
        if (this.match(_types.types._function) && !this.canInsertSemicolon()) {
          this.expect(_types.types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
    }
    var maybeName = this.state.value;
    var expr = this.parseExpression();
    if (starttype === _types.types.name && expr.type === "Identifier" && this.eat(_types.types.colon)) {
      return this.parseLabeledStatement(node, maybeName, expr);
    } else {
      return this.parseExpressionStatement(node, expr);
    }
  };
  pp.takeDecorators = function (node) {
    if (this.state.decorators.length) {
      node.decorators = this.state.decorators;
      this.state.decorators = [];
    }
  };
  pp.parseDecorators = function (allowExport) {
    while (this.match(_types.types.at)) {
      this.state.decorators.push(this.parseDecorator());
    }
    if (allowExport && this.match(_types.types._export)) {
      return;
    }
    if (!this.match(_types.types._class)) {
      this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
    }
  };
  pp.parseDecorator = function () {
    if (!this.hasPlugin("decorators")) {
      this.unexpected();
    }
    var node = this.startNode();
    this.next();
    node.expression = this.parseMaybeAssign();
    return this.finishNode(node, "Decorator");
  };
  pp.parseBreakContinueStatement = function (node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.isLineTerminator()) {
      node.label = null;
    } else if (!this.match(_types.types.name)) {
      this.unexpected();
    } else {
      node.label = this.parseIdentifier();
      this.semicolon();
    }
    var i = void 0;
    for (i = 0; i < this.state.labels.length; ++i) {
      var lab = this.state.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop"))
          break;
        if (node.label && isBreak)
          break;
      }
    }
    if (i === this.state.labels.length)
      this.raise(node.start, "Unsyntactic " + keyword);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp.parseDebuggerStatement = function (node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  };
  pp.parseDoStatement = function (node) {
    this.next();
    this.state.labels.push(loopLabel);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    this.expect(_types.types._while);
    node.test = this.parseParenExpression();
    this.eat(_types.types.semi);
    return this.finishNode(node, "DoWhileStatement");
  };
  pp.parseForStatement = function (node) {
    this.next();
    this.state.labels.push(loopLabel);
    var forAwait = false;
    if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
      forAwait = true;
      this.next();
    }
    this.expect(_types.types.parenL);
    if (this.match(_types.types.semi)) {
      if (forAwait) {
        this.unexpected();
      }
      return this.parseFor(node, null);
    }
    if (this.match(_types.types._var) || this.match(_types.types._let) || this.match(_types.types._const)) {
      var _init = this.startNode(), varKind = this.state.type;
      this.next();
      this.parseVar(_init, true, varKind);
      this.finishNode(_init, "VariableDeclaration");
      if (this.match(_types.types._in) || this.isContextual("of")) {
        if (_init.declarations.length === 1 && !_init.declarations[0].init) {
          return this.parseForIn(node, _init, forAwait);
        }
      }
      if (forAwait) {
        this.unexpected();
      }
      return this.parseFor(node, _init);
    }
    var refShorthandDefaultPos = { start: 0 };
    var init = this.parseExpression(true, refShorthandDefaultPos);
    if (this.match(_types.types._in) || this.isContextual("of")) {
      var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
      this.toAssignable(init, undefined, description);
      this.checkLVal(init, undefined, undefined, description);
      return this.parseForIn(node, init, forAwait);
    } else if (refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, init);
  };
  pp.parseFunctionStatement = function (node) {
    this.next();
    return this.parseFunction(node, true);
  };
  pp.parseIfStatement = function (node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement(false);
    node.alternate = this.eat(_types.types._else) ? this.parseStatement(false) : null;
    return this.finishNode(node, "IfStatement");
  };
  pp.parseReturnStatement = function (node) {
    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.state.start, "'return' outside of function");
    }
    this.next();
    if (this.isLineTerminator()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
  };
  pp.parseSwitchStatement = function (node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(_types.types.braceL);
    this.state.labels.push(switchLabel);
    var cur = void 0;
    for (var sawDefault; !this.match(_types.types.braceR);) {
      if (this.match(_types.types._case) || this.match(_types.types._default)) {
        var isCase = this.match(_types.types._case);
        if (cur)
          this.finishNode(cur, "SwitchCase");
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault)
            this.raise(this.state.lastTokStart, "Multiple default clauses");
          sawDefault = true;
          cur.test = null;
        }
        this.expect(_types.types.colon);
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(true));
        } else {
          this.unexpected();
        }
      }
    }
    if (cur)
      this.finishNode(cur, "SwitchCase");
    this.next();
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  };
  pp.parseThrowStatement = function (node) {
    this.next();
    if (_whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)))
      this.raise(this.state.lastTokEnd, "Illegal newline after throw");
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  };
  var empty = [];
  pp.parseTryStatement = function (node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.match(_types.types._catch)) {
      var clause = this.startNode();
      this.next();
      this.expect(_types.types.parenL);
      clause.param = this.parseBindingAtom();
      this.checkLVal(clause.param, true, Object.create(null), "catch clause");
      this.expect(_types.types.parenR);
      clause.body = this.parseBlock();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.guardedHandlers = empty;
    node.finalizer = this.eat(_types.types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) {
      this.raise(node.start, "Missing catch or finally clause");
    }
    return this.finishNode(node, "TryStatement");
  };
  pp.parseVarStatement = function (node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  };
  pp.parseWhileStatement = function (node) {
    this.next();
    node.test = this.parseParenExpression();
    this.state.labels.push(loopLabel);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  };
  pp.parseWithStatement = function (node) {
    if (this.state.strict)
      this.raise(this.state.start, "'with' in strict mode");
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement(false);
    return this.finishNode(node, "WithStatement");
  };
  pp.parseEmptyStatement = function (node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  };
  pp.parseLabeledStatement = function (node, maybeName, expr) {
    for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var _label = _ref;
      if (_label.name === maybeName) {
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }
    }
    var kind = this.state.type.isLoop ? "loop" : this.match(_types.types._switch) ? "switch" : null;
    for (var i = this.state.labels.length - 1; i >= 0; i--) {
      var label = this.state.labels[i];
      if (label.statementStart === node.start) {
        label.statementStart = this.state.start;
        label.kind = kind;
      } else {
        break;
      }
    }
    this.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.state.start
    });
    node.body = this.parseStatement(true);
    this.state.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  };
  pp.parseExpressionStatement = function (node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  };
  pp.parseBlock = function (allowDirectives) {
    var node = this.startNode();
    this.expect(_types.types.braceL);
    this.parseBlockBody(node, allowDirectives, false, _types.types.braceR);
    return this.finishNode(node, "BlockStatement");
  };
  pp.parseBlockBody = function (node, allowDirectives, topLevel, end) {
    node.body = [];
    node.directives = [];
    var parsedNonDirective = false;
    var oldStrict = void 0;
    var octalPosition = void 0;
    while (!this.eat(end)) {
      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
        octalPosition = this.state.octalPosition;
      }
      var stmt = this.parseStatement(true, topLevel);
      if (allowDirectives && !parsedNonDirective && stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized) {
        var directive = this.stmtToDirective(stmt);
        node.directives.push(directive);
        if (oldStrict === undefined && directive.value.value === "use strict") {
          oldStrict = this.state.strict;
          this.setStrict(true);
          if (octalPosition) {
            this.raise(octalPosition, "Octal literal in strict mode");
          }
        }
        continue;
      }
      parsedNonDirective = true;
      node.body.push(stmt);
    }
    if (oldStrict === false) {
      this.setStrict(false);
    }
  };
  pp.parseFor = function (node, init) {
    node.init = init;
    this.expect(_types.types.semi);
    node.test = this.match(_types.types.semi) ? null : this.parseExpression();
    this.expect(_types.types.semi);
    node.update = this.match(_types.types.parenR) ? null : this.parseExpression();
    this.expect(_types.types.parenR);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  };
  pp.parseForIn = function (node, init, forAwait) {
    var type = void 0;
    if (forAwait) {
      this.eatContextual("of");
      type = "ForAwaitStatement";
    } else {
      type = this.match(_types.types._in) ? "ForInStatement" : "ForOfStatement";
      this.next();
    }
    node.left = init;
    node.right = this.parseExpression();
    this.expect(_types.types.parenR);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, type);
  };
  pp.parseVar = function (node, isFor, kind) {
    node.declarations = [];
    node.kind = kind.keyword;
    for (;;) {
      var decl = this.startNode();
      this.parseVarHead(decl);
      if (this.eat(_types.types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === _types.types._const && !(this.match(_types.types._in) || this.isContextual("of"))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(_types.types._in) || this.isContextual("of")))) {
        this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(_types.types.comma))
        break;
    }
    return node;
  };
  pp.parseVarHead = function (decl) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, true, undefined, "variable declaration");
  };
  pp.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
    var oldInMethod = this.state.inMethod;
    this.state.inMethod = false;
    this.initFunction(node, isAsync);
    if (this.match(_types.types.star)) {
      if (node.async && !this.hasPlugin("asyncGenerators")) {
        this.unexpected();
      } else {
        node.generator = true;
        this.next();
      }
    }
    if (isStatement && !optionalId && !this.match(_types.types.name) && !this.match(_types.types._yield)) {
      this.unexpected();
    }
    if (this.match(_types.types.name) || this.match(_types.types._yield)) {
      node.id = this.parseBindingIdentifier();
    }
    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody);
    this.state.inMethod = oldInMethod;
    return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp.parseFunctionParams = function (node) {
    this.expect(_types.types.parenL);
    node.params = this.parseBindingList(_types.types.parenR);
  };
  pp.parseClass = function (node, isStatement, optionalId) {
    this.next();
    this.parseClassId(node, isStatement, optionalId);
    this.parseClassSuper(node);
    this.parseClassBody(node);
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp.isClassProperty = function () {
    return this.match(_types.types.eq) || this.isLineTerminator();
  };
  pp.isClassMutatorStarter = function () {
    return false;
  };
  pp.parseClassBody = function (node) {
    var oldStrict = this.state.strict;
    this.state.strict = true;
    var hadConstructorCall = false;
    var hadConstructor = false;
    var decorators = [];
    var classBody = this.startNode();
    classBody.body = [];
    this.expect(_types.types.braceL);
    while (!this.eat(_types.types.braceR)) {
      if (this.eat(_types.types.semi)) {
        continue;
      }
      if (this.match(_types.types.at)) {
        decorators.push(this.parseDecorator());
        continue;
      }
      var method = this.startNode();
      if (decorators.length) {
        method.decorators = decorators;
        decorators = [];
      }
      var isConstructorCall = false;
      var isMaybeStatic = this.match(_types.types.name) && this.state.value === "static";
      var isGenerator = this.eat(_types.types.star);
      var isGetSet = false;
      var isAsync = false;
      this.parsePropertyName(method);
      method.static = isMaybeStatic && !this.match(_types.types.parenL);
      if (method.static) {
        if (isGenerator)
          this.unexpected();
        isGenerator = this.eat(_types.types.star);
        this.parsePropertyName(method);
      }
      if (!isGenerator) {
        if (this.isClassProperty()) {
          classBody.body.push(this.parseClassProperty(method));
          continue;
        }
        if (method.key.type === "Identifier" && !method.computed && this.hasPlugin("classConstructorCall") && method.key.name === "call" && this.match(_types.types.name) && this.state.value === "constructor") {
          isConstructorCall = true;
          this.parsePropertyName(method);
        }
      }
      var isAsyncMethod = !this.match(_types.types.parenL) && !method.computed && method.key.type === "Identifier" && method.key.name === "async";
      if (isAsyncMethod) {
        if (this.hasPlugin("asyncGenerators") && this.eat(_types.types.star))
          isGenerator = true;
        isAsync = true;
        this.parsePropertyName(method);
      }
      method.kind = "method";
      if (!method.computed) {
        var key = method.key;
        if (!isAsync && !isGenerator && !this.isClassMutatorStarter() && key.type === "Identifier" && !this.match(_types.types.parenL) && (key.name === "get" || key.name === "set")) {
          isGetSet = true;
          method.kind = key.name;
          key = this.parsePropertyName(method);
        }
        var isConstructor = !isConstructorCall && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor");
        if (isConstructor) {
          if (hadConstructor)
            this.raise(key.start, "Duplicate constructor in the same class");
          if (isGetSet)
            this.raise(key.start, "Constructor can't have get/set modifier");
          if (isGenerator)
            this.raise(key.start, "Constructor can't be a generator");
          if (isAsync)
            this.raise(key.start, "Constructor can't be an async function");
          method.kind = "constructor";
          hadConstructor = true;
        }
        var isStaticPrototype = method.static && (key.type === "Identifier" && key.name === "prototype" || key.type === "StringLiteral" && key.value === "prototype");
        if (isStaticPrototype) {
          this.raise(key.start, "Classes may not have static property named prototype");
        }
      }
      if (isConstructorCall) {
        if (hadConstructorCall)
          this.raise(method.start, "Duplicate constructor call in the same class");
        method.kind = "constructorCall";
        hadConstructorCall = true;
      }
      if ((method.kind === "constructor" || method.kind === "constructorCall") && method.decorators) {
        this.raise(method.start, "You can't attach decorators to a class constructor");
      }
      this.parseClassMethod(classBody, method, isGenerator, isAsync);
      if (isGetSet) {
        var paramCount = method.kind === "get" ? 0 : 1;
        if (method.params.length !== paramCount) {
          var start = method.start;
          if (method.kind === "get") {
            this.raise(start, "getter should have no params");
          } else {
            this.raise(start, "setter should have exactly one param");
          }
        }
      }
    }
    if (decorators.length) {
      this.raise(this.state.start, "You have trailing decorators with no method");
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.state.strict = oldStrict;
  };
  pp.parseClassProperty = function (node) {
    if (this.match(_types.types.eq)) {
      if (!this.hasPlugin("classProperties"))
        this.unexpected();
      this.next();
      node.value = this.parseMaybeAssign();
    } else {
      node.value = null;
    }
    this.semicolon();
    return this.finishNode(node, "ClassProperty");
  };
  pp.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
    this.parseMethod(method, isGenerator, isAsync);
    classBody.body.push(this.finishNode(method, "ClassMethod"));
  };
  pp.parseClassId = function (node, isStatement, optionalId) {
    if (this.match(_types.types.name)) {
      node.id = this.parseIdentifier();
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        this.unexpected();
      }
    }
  };
  pp.parseClassSuper = function (node) {
    node.superClass = this.eat(_types.types._extends) ? this.parseExprSubscripts() : null;
  };
  pp.parseExport = function (node) {
    this.next();
    if (this.match(_types.types.star)) {
      var specifier = this.startNode();
      this.next();
      if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
        specifier.exported = this.parseIdentifier();
        node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
        this.parseExportSpecifiersMaybe(node);
        this.parseExportFrom(node, true);
      } else {
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }
    } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
      var _specifier = this.startNode();
      _specifier.exported = this.parseIdentifier(true);
      node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
      if (this.match(_types.types.comma) && this.lookahead().type === _types.types.star) {
        this.expect(_types.types.comma);
        var _specifier2 = this.startNode();
        this.expect(_types.types.star);
        this.expectContextual("as");
        _specifier2.exported = this.parseIdentifier();
        node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
      } else {
        this.parseExportSpecifiersMaybe(node);
      }
      this.parseExportFrom(node, true);
    } else if (this.eat(_types.types._default)) {
      var expr = this.startNode();
      var needsSemi = false;
      if (this.eat(_types.types._function)) {
        expr = this.parseFunction(expr, true, false, false, true);
      } else if (this.match(_types.types._class)) {
        expr = this.parseClass(expr, true, true);
      } else {
        needsSemi = true;
        expr = this.parseMaybeAssign();
      }
      node.declaration = expr;
      if (needsSemi)
        this.semicolon();
      this.checkExport(node, true, true);
      return this.finishNode(node, "ExportDefaultDeclaration");
    } else if (this.state.type.keyword || this.shouldParseExportDeclaration()) {
      node.specifiers = [];
      node.source = null;
      node.declaration = this.parseExportDeclaration(node);
    } else {
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers();
      this.parseExportFrom(node);
    }
    this.checkExport(node, true);
    return this.finishNode(node, "ExportNamedDeclaration");
  };
  pp.parseExportDeclaration = function () {
    return this.parseStatement(true);
  };
  pp.isExportDefaultSpecifier = function () {
    if (this.match(_types.types.name)) {
      return this.state.value !== "type" && this.state.value !== "async" && this.state.value !== "interface";
    }
    if (!this.match(_types.types._default)) {
      return false;
    }
    var lookahead = this.lookahead();
    return lookahead.type === _types.types.comma || lookahead.type === _types.types.name && lookahead.value === "from";
  };
  pp.parseExportSpecifiersMaybe = function (node) {
    if (this.eat(_types.types.comma)) {
      node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
    }
  };
  pp.parseExportFrom = function (node, expect) {
    if (this.eatContextual("from")) {
      node.source = this.match(_types.types.string) ? this.parseExprAtom() : this.unexpected();
      this.checkExport(node);
    } else {
      if (expect) {
        this.unexpected();
      } else {
        node.source = null;
      }
    }
    this.semicolon();
  };
  pp.shouldParseExportDeclaration = function () {
    return this.isContextual("async");
  };
  pp.checkExport = function (node, checkNames, isDefault) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default", isDefault);
      } else if (node.specifiers && node.specifiers.length) {
        for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var specifier = _ref2;
          var name = specifier.exported.name;
          if (name === "default")
            isDefault = true;
          this.checkDuplicateExports(specifier, name, isDefault);
        }
      } else if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          this.checkDuplicateExports(node, node.declaration.id.name, isDefault);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref3 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref3 = _i3.value;
            }
            var declaration = _ref3;
            this.checkDuplicateExports(declaration, declaration.id.name, isDefault);
          }
        }
      }
    }
    if (this.state.decorators.length) {
      var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
      if (!node.declaration || !isClass) {
        this.raise(node.start, "You can only use decorators on an export when exporting a class");
      }
      this.takeDecorators(node.declaration);
    }
  };
  pp.checkDuplicateExports = function (node, name, isDefault) {
    if (this.state.exportedIdentifiers[name]) {
      this.raiseDuplicateExportError(node, name, isDefault);
    }
    this.state.exportedIdentifiers[name] = true;
  };
  pp.raiseDuplicateExportError = function (node, name, isDefault) {
    this.raise(node.start, isDefault ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
  };
  pp.parseExportSpecifiers = function () {
    var nodes = [];
    var first = true;
    var needsFrom = void 0;
    this.expect(_types.types.braceL);
    while (!this.eat(_types.types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
        if (this.eat(_types.types.braceR))
          break;
      }
      var isDefault = this.match(_types.types._default);
      if (isDefault && !needsFrom)
        needsFrom = true;
      var node = this.startNode();
      node.local = this.parseIdentifier(isDefault);
      node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    if (needsFrom && !this.isContextual("from")) {
      this.unexpected();
    }
    return nodes;
  };
  pp.parseImport = function (node) {
    this.next();
    if (this.match(_types.types.string)) {
      node.specifiers = [];
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = [];
      this.parseImportSpecifiers(node);
      this.expectContextual("from");
      node.source = this.match(_types.types.string) ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  };
  pp.parseImportSpecifiers = function (node) {
    var first = true;
    if (this.match(_types.types.name)) {
      var startPos = this.state.start, startLoc = this.state.startLoc;
      node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
      if (!this.eat(_types.types.comma))
        return;
    }
    if (this.match(_types.types.star)) {
      var specifier = this.startNode();
      this.next();
      this.expectContextual("as");
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
      return;
    }
    this.expect(_types.types.braceL);
    while (!this.eat(_types.types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
        if (this.eat(_types.types.braceR))
          break;
      }
      var _specifier3 = this.startNode();
      _specifier3.imported = this.parseIdentifier(true);
      _specifier3.local = this.eatContextual("as") ? this.parseIdentifier() : _specifier3.imported.__clone();
      this.checkLVal(_specifier3.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(_specifier3, "ImportSpecifier"));
    }
  };
  pp.parseImportSpecifierDefault = function (id, startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.local = id;
    this.checkLVal(node.local, true, undefined, "default import specifier");
    return this.finishNode(node, "ImportDefaultSpecifier");
  };
  return statement;
}

var lval = {};

var hasRequiredLval;
function requireLval() {
  if (hasRequiredLval)
    return lval;
  hasRequiredLval = 1;
  var _types = requireTypes();
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  var _identifier = requireIdentifier();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _index2.default.prototype;
  pp.toAssignable = function (node, isBinding, contextDescription) {
    if (node) {
      switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var prop = _ref;
          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;
      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;
      case "SpreadProperty":
        node.type = "RestProperty";
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;
      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;
      case "MemberExpression":
        if (!isBinding)
          break;
      default: {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
          this.raise(node.start, message);
        }
      }
    }
    return node;
  };
  pp.toAssignableList = function (exprList, isBinding, contextDescription) {
    var end = exprList.length;
    if (end) {
      var last = exprList[end - 1];
      if (last && last.type === "RestElement") {
        --end;
      } else if (last && last.type === "SpreadElement") {
        last.type = "RestElement";
        var arg = last.argument;
        this.toAssignable(arg, isBinding, contextDescription);
        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
          this.unexpected(arg.start);
        }
        --end;
      }
    }
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt)
        this.toAssignable(elt, isBinding, contextDescription);
    }
    return exprList;
  };
  pp.toReferencedList = function (exprList) {
    return exprList;
  };
  pp.parseSpread = function (refShorthandDefaultPos) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
    return this.finishNode(node, "SpreadElement");
  };
  pp.parseRest = function () {
    var node = this.startNode();
    this.next();
    node.argument = this.parseBindingIdentifier();
    return this.finishNode(node, "RestElement");
  };
  pp.shouldAllowYieldIdentifier = function () {
    return this.match(_types.types._yield) && !this.state.strict && !this.state.inGenerator;
  };
  pp.parseBindingIdentifier = function () {
    return this.parseIdentifier(this.shouldAllowYieldIdentifier());
  };
  pp.parseBindingAtom = function () {
    switch (this.state.type) {
    case _types.types._yield:
      if (this.state.strict || this.state.inGenerator)
        this.unexpected();
    case _types.types.name:
      return this.parseIdentifier(true);
    case _types.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_types.types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");
    case _types.types.braceL:
      return this.parseObj(true);
    default:
      this.unexpected();
    }
  };
  pp.parseBindingList = function (close, allowEmpty) {
    var elts = [];
    var first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
      }
      if (allowEmpty && this.match(_types.types.comma)) {
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(_types.types.ellipsis)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRest()));
        this.expect(close);
        break;
      } else {
        var decorators = [];
        while (this.match(_types.types.at)) {
          decorators.push(this.parseDecorator());
        }
        var left = this.parseMaybeDefault();
        if (decorators.length) {
          left.decorators = decorators;
        }
        this.parseAssignableListItemTypes(left);
        elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
      }
    }
    return elts;
  };
  pp.parseAssignableListItemTypes = function (param) {
    return param;
  };
  pp.parseMaybeDefault = function (startPos, startLoc, left) {
    startLoc = startLoc || this.state.startLoc;
    startPos = startPos || this.state.start;
    left = left || this.parseBindingAtom();
    if (!this.eat(_types.types.eq))
      return left;
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
  };
  pp.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
    switch (expr.type) {
    case "Identifier":
      if (this.state.strict && (_identifier.reservedWords.strictBind(expr.name) || _identifier.reservedWords.strict(expr.name))) {
        this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (checkClashes) {
        var key = "_" + expr.name;
        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;
    case "MemberExpression":
      if (isBinding)
        this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;
    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var prop = _ref2;
        if (prop.type === "ObjectProperty")
          prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;
    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var elem = _ref3;
        if (elem)
          this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;
    case "RestProperty":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
      break;
    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;
    default: {
        var message = (isBinding ? "Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
        this.raise(expr.start, message);
      }
    }
  };
  return lval;
}

var expression = {};

var hasRequiredExpression;
function requireExpression() {
  if (hasRequiredExpression)
    return expression;
  hasRequiredExpression = 1;
  var _types = requireTypes();
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  var _identifier = requireIdentifier();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _index2.default.prototype;
  pp.checkPropClash = function (prop, propHash) {
    if (prop.computed)
      return;
    var key = prop.key;
    var name = void 0;
    switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "StringLiteral":
    case "NumericLiteral":
      name = String(key.value);
      break;
    default:
      return;
    }
    if (name === "__proto__" && prop.kind === "init") {
      if (propHash.proto)
        this.raise(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
  };
  pp.parseExpression = function (noIn, refShorthandDefaultPos) {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
    if (this.match(_types.types.comma)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(_types.types.comma)) {
        node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
      }
      this.toReferencedList(node.expressions);
      return this.finishNode(node, "SequenceExpression");
    }
    return expr;
  };
  pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    if (this.match(_types.types._yield) && this.state.inGenerator) {
      return this.parseYield();
    }
    var failOnShorthandAssign = void 0;
    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = { start: 0 };
      failOnShorthandAssign = true;
    }
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    if (this.match(_types.types.parenL) || this.match(_types.types.name)) {
      this.state.potentialArrowAt = this.state.start;
    }
    var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
    if (afterLeftParse)
      left = afterLeftParse.call(this, left, startPos, startLoc);
    if (this.state.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.state.value;
      node.left = this.match(_types.types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
      refShorthandDefaultPos.start = 0;
      this.checkLVal(left, undefined, undefined, "assignment expression");
      if (left.extra && left.extra.parenthesized) {
        var errorMsg = void 0;
        if (left.type === "ObjectPattern") {
          errorMsg = "`({a}) = 0` use `({a} = 0)`";
        } else if (left.type === "ArrayPattern") {
          errorMsg = "`([a]) = 0` use `([a] = 0)`";
        }
        if (errorMsg) {
          this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
        }
      }
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression");
    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }
    return left;
  };
  pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start)
      return expr;
    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
  };
  pp.parseConditional = function (expr, noIn, startPos, startLoc) {
    if (this.eat(_types.types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(_types.types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
  };
  pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var expr = this.parseMaybeUnary(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    } else {
      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    }
  };
  pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.state.type.binop;
    if (prec != null && (!noIn || !this.match(_types.types._in))) {
      if (prec > minPrec) {
        var node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.left = left;
        node.operator = this.state.value;
        if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
          this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
        }
        var op = this.state.type;
        this.next();
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
        this.finishNode(node, op === _types.types.logicalOR || op === _types.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
      }
    }
    return left;
  };
  pp.parseMaybeUnary = function (refShorthandDefaultPos) {
    if (this.state.type.prefix) {
      var node = this.startNode();
      var update = this.match(_types.types.incDec);
      node.operator = this.state.value;
      node.prefix = true;
      this.next();
      var argType = this.state.type;
      node.argument = this.parseMaybeUnary();
      this.addExtra(node, "parenthesizedArgument", argType === _types.types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      if (update) {
        this.checkLVal(node.argument, undefined, undefined, "prefix operation");
      } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
        this.raise(node.start, "Deleting local variable in strict mode");
      }
      return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var expr = this.parseExprSubscripts(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start)
      return expr;
    while (this.state.type.postfix && !this.canInsertSemicolon()) {
      var _node = this.startNodeAt(startPos, startLoc);
      _node.operator = this.state.value;
      _node.prefix = false;
      _node.argument = expr;
      this.checkLVal(expr, undefined, undefined, "postfix operation");
      this.next();
      expr = this.finishNode(_node, "UpdateExpression");
    }
    return expr;
  };
  pp.parseExprSubscripts = function (refShorthandDefaultPos) {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var potentialArrowAt = this.state.potentialArrowAt;
    var expr = this.parseExprAtom(refShorthandDefaultPos);
    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    }
    return this.parseSubscripts(expr, startPos, startLoc);
  };
  pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
    for (;;) {
      if (!noCalls && this.eat(_types.types.doubleColon)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.callee = this.parseNoCallExpr();
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      } else if (this.eat(_types.types.dot)) {
        var _node2 = this.startNodeAt(startPos, startLoc);
        _node2.object = base;
        _node2.property = this.parseIdentifier(true);
        _node2.computed = false;
        base = this.finishNode(_node2, "MemberExpression");
      } else if (this.eat(_types.types.bracketL)) {
        var _node3 = this.startNodeAt(startPos, startLoc);
        _node3.object = base;
        _node3.property = this.parseExpression();
        _node3.computed = true;
        this.expect(_types.types.bracketR);
        base = this.finishNode(_node3, "MemberExpression");
      } else if (!noCalls && this.match(_types.types.parenL)) {
        var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
        this.next();
        var _node4 = this.startNodeAt(startPos, startLoc);
        _node4.callee = base;
        _node4.arguments = this.parseCallExpressionArguments(_types.types.parenR, possibleAsync);
        base = this.finishNode(_node4, "CallExpression");
        if (possibleAsync && this.shouldParseAsyncArrow()) {
          return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
        } else {
          this.toReferencedList(_node4.arguments);
        }
      } else if (this.match(_types.types.backQuote)) {
        var _node5 = this.startNodeAt(startPos, startLoc);
        _node5.tag = base;
        _node5.quasi = this.parseTemplate();
        base = this.finishNode(_node5, "TaggedTemplateExpression");
      } else {
        return base;
      }
    }
  };
  pp.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
    var innerParenStart = void 0;
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
        if (this.eat(close))
          break;
      }
      if (this.match(_types.types.parenL) && !innerParenStart) {
        innerParenStart = this.state.start;
      }
      elts.push(this.parseExprListItem(undefined, possibleAsyncArrow ? { start: 0 } : undefined));
    }
    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
      this.unexpected();
    }
    return elts;
  };
  pp.shouldParseAsyncArrow = function () {
    return this.match(_types.types.arrow);
  };
  pp.parseAsyncArrowFromCallExpression = function (node, call) {
    this.expect(_types.types.arrow);
    return this.parseArrowExpression(node, call.arguments, true);
  };
  pp.parseNoCallExpr = function () {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  };
  pp.parseExprAtom = function (refShorthandDefaultPos) {
    var node = void 0, canBeArrow = this.state.potentialArrowAt === this.state.start;
    switch (this.state.type) {
    case _types.types._super:
      if (!this.state.inMethod && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }
      node = this.startNode();
      this.next();
      if (!this.match(_types.types.parenL) && !this.match(_types.types.bracketL) && !this.match(_types.types.dot)) {
        this.unexpected();
      }
      if (this.match(_types.types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() outside of class constructor");
      }
      return this.finishNode(node, "Super");
    case _types.types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case _types.types._yield:
      if (this.state.inGenerator)
        this.unexpected();
    case _types.types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);
      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(_types.types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(_types.types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(_types.types.arrow);
        return this.parseArrowExpression(node, params, true);
      }
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_types.types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }
      return id;
    case _types.types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }
    case _types.types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    case _types.types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");
    case _types.types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");
    case _types.types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    case _types.types._true:
    case _types.types._false:
      node = this.startNode();
      node.value = this.match(_types.types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    case _types.types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);
    case _types.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_types.types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");
    case _types.types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);
    case _types.types._function:
      return this.parseFunctionExpression();
    case _types.types.at:
      this.parseDecorators();
    case _types.types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);
    case _types.types._new:
      return this.parseNew();
    case _types.types.backQuote:
      return this.parseTemplate();
    case _types.types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }
    default:
      this.unexpected();
    }
  };
  pp.parseFunctionExpression = function () {
    var node = this.startNode();
    var meta = this.parseIdentifier(true);
    if (this.state.inGenerator && this.eat(_types.types.dot) && this.hasPlugin("functionSent")) {
      return this.parseMetaProperty(node, meta, "sent");
    } else {
      return this.parseFunction(node, false);
    }
  };
  pp.parseMetaProperty = function (node, meta, propertyName) {
    node.meta = meta;
    node.property = this.parseIdentifier(true);
    if (node.property.name !== propertyName) {
      this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
    }
    return this.finishNode(node, "MetaProperty");
  };
  pp.parseLiteral = function (value, type) {
    var node = this.startNode();
    this.addExtra(node, "rawValue", value);
    this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
    node.value = value;
    this.next();
    return this.finishNode(node, type);
  };
  pp.parseParenExpression = function () {
    this.expect(_types.types.parenL);
    var val = this.parseExpression();
    this.expect(_types.types.parenR);
    return val;
  };
  pp.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow, isAsync) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    var val = void 0;
    this.expect(_types.types.parenL);
    var innerStartPos = this.state.start, innerStartLoc = this.state.startLoc;
    var exprList = [], first = true;
    var refShorthandDefaultPos = { start: 0 }, spreadStart = void 0, optionalCommaStart = void 0;
    var refNeedsArrowPos = { start: 0 };
    while (!this.match(_types.types.parenR)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma, refNeedsArrowPos.start || null);
        if (this.match(_types.types.parenR)) {
          optionalCommaStart = this.state.start;
          break;
        }
      }
      if (this.match(_types.types.ellipsis)) {
        var spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
        spreadStart = this.state.start;
        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartLoc, spreadNodeStartPos));
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
      }
    }
    var innerEndPos = this.state.start;
    var innerEndLoc = this.state.startLoc;
    this.expect(_types.types.parenR);
    var arrowNode = this.startNodeAt(startPos, startLoc);
    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
      for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var param = _ref;
        if (param.extra && param.extra.parenthesized)
          this.unexpected(param.extra.parenStart);
      }
      return this.parseArrowExpression(arrowNode, exprList, isAsync);
    }
    if (!exprList.length) {
      if (isAsync) {
        return;
      } else {
        this.unexpected(this.state.lastTokStart);
      }
    }
    if (optionalCommaStart)
      this.unexpected(optionalCommaStart);
    if (spreadStart)
      this.unexpected(spreadStart);
    if (refShorthandDefaultPos.start)
      this.unexpected(refShorthandDefaultPos.start);
    if (refNeedsArrowPos.start)
      this.unexpected(refNeedsArrowPos.start);
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.toReferencedList(val.expressions);
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
    this.addExtra(val, "parenthesized", true);
    this.addExtra(val, "parenStart", startPos);
    return val;
  };
  pp.shouldParseArrow = function () {
    return !this.canInsertSemicolon();
  };
  pp.parseArrow = function (node) {
    if (this.eat(_types.types.arrow)) {
      return node;
    }
  };
  pp.parseParenItem = function (node) {
    return node;
  };
  pp.parseNew = function () {
    var node = this.startNode();
    var meta = this.parseIdentifier(true);
    if (this.eat(_types.types.dot)) {
      return this.parseMetaProperty(node, meta, "target");
    }
    node.callee = this.parseNoCallExpr();
    if (this.eat(_types.types.parenL)) {
      node.arguments = this.parseExprList(_types.types.parenR);
      this.toReferencedList(node.arguments);
    } else {
      node.arguments = [];
    }
    return this.finishNode(node, "NewExpression");
  };
  pp.parseTemplateElement = function () {
    var elem = this.startNode();
    elem.value = {
      raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
      cooked: this.state.value
    };
    this.next();
    elem.tail = this.match(_types.types.backQuote);
    return this.finishNode(elem, "TemplateElement");
  };
  pp.parseTemplate = function () {
    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement();
    node.quasis = [curElt];
    while (!curElt.tail) {
      this.expect(_types.types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(_types.types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement());
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral");
  };
  pp.parseObj = function (isPattern, refShorthandDefaultPos) {
    var decorators = [];
    var propHash = Object.create(null);
    var first = true;
    var node = this.startNode();
    node.properties = [];
    this.next();
    while (!this.eat(_types.types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
        if (this.eat(_types.types.braceR))
          break;
      }
      while (this.match(_types.types.at)) {
        decorators.push(this.parseDecorator());
      }
      var prop = this.startNode(), isGenerator = false, isAsync = false, startPos = void 0, startLoc = void 0;
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      if (this.hasPlugin("objectRestSpread") && this.match(_types.types.ellipsis)) {
        prop = this.parseSpread();
        prop.type = isPattern ? "RestProperty" : "SpreadProperty";
        node.properties.push(prop);
        continue;
      }
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refShorthandDefaultPos) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(_types.types.star);
      }
      if (!isPattern && this.isContextual("async")) {
        if (isGenerator)
          this.unexpected();
        var asyncId = this.parseIdentifier();
        if (this.match(_types.types.colon) || this.match(_types.types.parenL) || this.match(_types.types.braceR)) {
          prop.key = asyncId;
        } else {
          isAsync = true;
          if (this.hasPlugin("asyncGenerators"))
            isGenerator = this.eat(_types.types.star);
          this.parsePropertyName(prop);
        }
      } else {
        this.parsePropertyName(prop);
      }
      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
      this.checkPropClash(prop, propHash);
      if (prop.shorthand) {
        this.addExtra(prop, "shorthand", true);
      }
      node.properties.push(prop);
    }
    if (decorators.length) {
      this.raise(this.state.start, "You have trailing decorators with no property");
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
    if (isAsync || isGenerator || this.match(_types.types.parenL)) {
      if (isPattern)
        this.unexpected();
      prop.kind = "method";
      prop.method = true;
      this.parseMethod(prop, isGenerator, isAsync);
      return this.finishNode(prop, "ObjectMethod");
    }
    if (this.eat(_types.types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
      return this.finishNode(prop, "ObjectProperty");
    }
    if (!prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && !this.match(_types.types.comma) && !this.match(_types.types.braceR)) {
      if (isGenerator || isAsync || isPattern)
        this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      this.parseMethod(prop, false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.params.length !== paramCount) {
        var start = prop.start;
        if (prop.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
      return this.finishNode(prop, "ObjectMethod");
    }
    if (!prop.computed && prop.key.type === "Identifier") {
      if (isPattern) {
        var illegalBinding = this.isKeyword(prop.key.name);
        if (!illegalBinding && this.state.strict) {
          illegalBinding = _identifier.reservedWords.strictBind(prop.key.name) || _identifier.reservedWords.strict(prop.key.name);
        }
        if (illegalBinding) {
          this.raise(prop.key.start, "Binding " + prop.key.name);
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else if (this.match(_types.types.eq) && refShorthandDefaultPos) {
        if (!refShorthandDefaultPos.start) {
          refShorthandDefaultPos.start = this.state.start;
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else {
        prop.value = prop.key.__clone();
      }
      prop.shorthand = true;
      return this.finishNode(prop, "ObjectProperty");
    }
    this.unexpected();
  };
  pp.parsePropertyName = function (prop) {
    if (this.eat(_types.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_types.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
      return prop.key = this.match(_types.types.num) || this.match(_types.types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
  };
  pp.initFunction = function (node, isAsync) {
    node.id = null;
    node.generator = false;
    node.expression = false;
    node.async = !!isAsync;
  };
  pp.parseMethod = function (node, isGenerator, isAsync) {
    var oldInMethod = this.state.inMethod;
    this.state.inMethod = node.kind || true;
    this.initFunction(node, isAsync);
    this.expect(_types.types.parenL);
    node.params = this.parseBindingList(_types.types.parenR);
    node.generator = isGenerator;
    this.parseFunctionBody(node);
    this.state.inMethod = oldInMethod;
    return node;
  };
  pp.parseArrowExpression = function (node, params, isAsync) {
    this.initFunction(node, isAsync);
    node.params = this.toAssignableList(params, true, "arrow function parameters");
    this.parseFunctionBody(node, true);
    return this.finishNode(node, "ArrowFunctionExpression");
  };
  pp.parseFunctionBody = function (node, allowExpression) {
    var isExpression = allowExpression && !this.match(_types.types.braceL);
    var oldInAsync = this.state.inAsync;
    this.state.inAsync = node.async;
    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
    } else {
      var oldInFunc = this.state.inFunction, oldInGen = this.state.inGenerator, oldLabels = this.state.labels;
      this.state.inFunction = true;
      this.state.inGenerator = node.generator;
      this.state.labels = [];
      node.body = this.parseBlock(true);
      node.expression = false;
      this.state.inFunction = oldInFunc;
      this.state.inGenerator = oldInGen;
      this.state.labels = oldLabels;
    }
    this.state.inAsync = oldInAsync;
    var checkLVal = this.state.strict;
    var isStrict = false;
    if (allowExpression)
      checkLVal = true;
    if (!isExpression && node.body.directives.length) {
      for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var directive = _ref2;
        if (directive.value.value === "use strict") {
          isStrict = true;
          checkLVal = true;
          break;
        }
      }
    }
    if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
      this.raise(node.id.start, "Binding yield in strict mode");
    }
    if (checkLVal) {
      var nameHash = Object.create(null);
      var oldStrict = this.state.strict;
      if (isStrict)
        this.state.strict = true;
      if (node.id) {
        this.checkLVal(node.id, true, undefined, "function name");
      }
      for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var param = _ref3;
        if (isStrict && param.type !== "Identifier") {
          this.raise(param.start, "Non-simple parameter in strict mode");
        }
        this.checkLVal(param, true, nameHash, "function parameter list");
      }
      this.state.strict = oldStrict;
    }
  };
  pp.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(_types.types.comma);
        if (this.eat(close))
          break;
      }
      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
    }
    return elts;
  };
  pp.parseExprListItem = function (allowEmpty, refShorthandDefaultPos) {
    var elt = void 0;
    if (allowEmpty && this.match(_types.types.comma)) {
      elt = null;
    } else if (this.match(_types.types.ellipsis)) {
      elt = this.parseSpread(refShorthandDefaultPos);
    } else {
      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem);
    }
    return elt;
  };
  pp.parseIdentifier = function (liberal) {
    var node = this.startNode();
    if (this.match(_types.types.name)) {
      if (!liberal && this.state.strict && _identifier.reservedWords.strict(this.state.value)) {
        this.raise(this.state.start, "The keyword '" + this.state.value + "' is reserved");
      }
      node.name = this.state.value;
    } else if (liberal && this.state.type.keyword) {
      node.name = this.state.type.keyword;
    } else {
      this.unexpected();
    }
    if (!liberal && node.name === "await" && this.state.inAsync) {
      this.raise(node.start, "invalid use of await inside of an async function");
    }
    node.loc.identifierName = node.name;
    this.next();
    return this.finishNode(node, "Identifier");
  };
  pp.parseAwait = function (node) {
    if (!this.state.inAsync) {
      this.unexpected();
    }
    if (this.match(_types.types.star)) {
      this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
    }
    node.argument = this.parseMaybeUnary();
    return this.finishNode(node, "AwaitExpression");
  };
  pp.parseYield = function () {
    var node = this.startNode();
    this.next();
    if (this.match(_types.types.semi) || this.canInsertSemicolon() || !this.match(_types.types.star) && !this.state.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(_types.types.star);
      node.argument = this.parseMaybeAssign();
    }
    return this.finishNode(node, "YieldExpression");
  };
  return expression;
}

var node = {};

var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  var _location = requireLocation$1();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var pp = _index2.default.prototype;
  var commentKeys = [
    "leadingComments",
    "trailingComments",
    "innerComments"
  ];
  var Node = (function () {
    function Node(pos, loc, filename) {
      _classCallCheck(this, Node);
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new _location.SourceLocation(loc);
      if (filename)
        this.loc.filename = filename;
    }
    Node.prototype.__clone = function __clone() {
      var node2 = new Node();
      for (var key in this) {
        if (commentKeys.indexOf(key) < 0) {
          node2[key] = this[key];
        }
      }
      return node2;
    };
    return Node;
  }());
  pp.startNode = function () {
    return new Node(this.state.start, this.state.startLoc, this.filename);
  };
  pp.startNodeAt = function (pos, loc) {
    return new Node(pos, loc, this.filename);
  };
  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    node.loc.end = loc;
    this.processComment(node);
    return node;
  }
  pp.finishNode = function (node, type) {
    return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
  };
  pp.finishNodeAt = function (node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc);
  };
  return node;
}

var location = {};

var hasRequiredLocation;
function requireLocation() {
  if (hasRequiredLocation)
    return location;
  hasRequiredLocation = 1;
  var _location = requireLocation$1();
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _index2.default.prototype;
  pp.raise = function (pos, message) {
    var loc = (0, _location.getLineInfo)(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    throw err;
  };
  return location;
}

var comments$2 = {};

var hasRequiredComments$1;
function requireComments$1() {
  if (hasRequiredComments$1)
    return comments$2;
  hasRequiredComments$1 = 1;
  var _index = requireParser();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function last(stack) {
    return stack[stack.length - 1];
  }
  var pp = _index2.default.prototype;
  pp.addComment = function (comment) {
    if (this.filename)
      comment.loc.filename = this.filename;
    this.state.trailingComments.push(comment);
    this.state.leadingComments.push(comment);
  };
  pp.processComment = function (node) {
    if (node.type === "Program" && node.body.length > 0)
      return;
    var stack = this.state.commentStack;
    var lastChild = void 0, trailingComments = void 0, i = void 0, j = void 0;
    if (this.state.trailingComments.length > 0) {
      if (this.state.trailingComments[0].start >= node.end) {
        trailingComments = this.state.trailingComments;
        this.state.trailingComments = [];
      } else {
        this.state.trailingComments.length = 0;
      }
    } else {
      var lastInStack = last(stack);
      if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
        trailingComments = lastInStack.trailingComments;
        lastInStack.trailingComments = null;
      }
    }
    while (stack.length > 0 && last(stack).start >= node.start) {
      lastChild = stack.pop();
    }
    if (lastChild) {
      if (lastChild.leadingComments) {
        if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
          node.leadingComments = lastChild.leadingComments;
          lastChild.leadingComments = null;
        } else {
          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
            if (lastChild.leadingComments[i].end <= node.start) {
              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (this.state.leadingComments.length > 0) {
      if (last(this.state.leadingComments).end <= node.start) {
        if (this.state.commentPreviousNode) {
          for (j = 0; j < this.state.leadingComments.length; j++) {
            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
              this.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }
        if (this.state.leadingComments.length > 0) {
          node.leadingComments = this.state.leadingComments;
          this.state.leadingComments = [];
        }
      } else {
        for (i = 0; i < this.state.leadingComments.length; i++) {
          if (this.state.leadingComments[i].end > node.start) {
            break;
          }
        }
        node.leadingComments = this.state.leadingComments.slice(0, i);
        if (node.leadingComments.length === 0) {
          node.leadingComments = null;
        }
        trailingComments = this.state.leadingComments.slice(i);
        if (trailingComments.length === 0) {
          trailingComments = null;
        }
      }
    }
    this.state.commentPreviousNode = node;
    if (trailingComments) {
      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
        node.innerComments = trailingComments;
      } else {
        node.trailingComments = trailingComments;
      }
    }
    stack.push(node);
  };
  return comments$2;
}

var flow = {};

var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow)
    return flow;
  hasRequiredFlow = 1;
  flow.__esModule = true;
  flow.default = function (instance) {
    instance.extend("parseFunctionBody", function (inner) {
      return function (node, allowExpression) {
        if (this.match(_types.types.colon) && !allowExpression) {
          node.returnType = this.flowParseTypeAnnotation();
        }
        return inner.call(this, node, allowExpression);
      };
    });
    instance.extend("parseStatement", function (inner) {
      return function (declaration, topLevel) {
        if (this.state.strict && this.match(_types.types.name) && this.state.value === "interface") {
          var node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        } else {
          return inner.call(this, declaration, topLevel);
        }
      };
    });
    instance.extend("parseExpressionStatement", function (inner) {
      return function (node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(_types.types._class) || this.match(_types.types.name) || this.match(_types.types._function) || this.match(_types.types._var)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(_types.types.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            }
          }
        }
        return inner.call(this, node, expr);
      };
    });
    instance.extend("shouldParseExportDeclaration", function (inner) {
      return function () {
        return this.isContextual("type") || this.isContextual("interface") || inner.call(this);
      };
    });
    instance.extend("parseConditional", function (inner) {
      return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        if (refNeedsArrowPos && this.match(_types.types.question)) {
          var state = this.state.clone();
          try {
            return inner.call(this, expr, noIn, startPos, startLoc);
          } catch (err) {
            if (err instanceof SyntaxError) {
              this.state = state;
              refNeedsArrowPos.start = err.pos || this.state.start;
              return expr;
            } else {
              throw err;
            }
          }
        }
        return inner.call(this, expr, noIn, startPos, startLoc);
      };
    });
    instance.extend("parseParenItem", function (inner) {
      return function (node, startLoc, startPos) {
        node = inner.call(this, node, startLoc, startPos);
        if (this.eat(_types.types.question)) {
          node.optional = true;
        }
        if (this.match(_types.types.colon)) {
          var typeCastNode = this.startNodeAt(startLoc, startPos);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node;
      };
    });
    instance.extend("parseExport", function (inner) {
      return function (node) {
        node = inner.call(this, node);
        if (node.type === "ExportNamedDeclaration") {
          node.exportKind = node.exportKind || "value";
        }
        return node;
      };
    });
    instance.extend("parseExportDeclaration", function (inner) {
      return function (node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();
          if (this.match(_types.types.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";
          var _declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(_declarationNode);
        } else {
          return inner.call(this, node);
        }
      };
    });
    instance.extend("parseClassId", function (inner) {
      return function (node) {
        inner.apply(this, arguments);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      };
    });
    instance.extend("isKeyword", function (inner) {
      return function (name) {
        if (this.state.inType && name === "void") {
          return false;
        } else {
          return inner.call(this, name);
        }
      };
    });
    instance.extend("readToken", function (inner) {
      return function (code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(_types.types.relational, 1);
        } else {
          return inner.call(this, code);
        }
      };
    });
    instance.extend("jsx_readToken", function (inner) {
      return function () {
        if (!this.state.inType)
          return inner.call(this);
      };
    });
    instance.extend("toAssignable", function (inner) {
      return function (node, isBinding, contextDescription) {
        if (node.type === "TypeCastExpression") {
          return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
        } else {
          return inner.call(this, node, isBinding, contextDescription);
        }
      };
    });
    instance.extend("toAssignableList", function (inner) {
      return function (exprList, isBinding, contextDescription) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return inner.call(this, exprList, isBinding, contextDescription);
      };
    });
    instance.extend("toReferencedList", function () {
      return function (exprList) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
            this.raise(expr.start, "Unexpected type cast");
          }
        }
        return exprList;
      };
    });
    instance.extend("parseExprListItem", function (inner) {
      return function (allowEmpty, refShorthandDefaultPos) {
        var container = this.startNode();
        var node = inner.call(this, allowEmpty, refShorthandDefaultPos);
        if (this.match(_types.types.colon)) {
          container._exprListItem = true;
          container.expression = node;
          container.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(container, "TypeCastExpression");
        } else {
          return node;
        }
      };
    });
    instance.extend("checkLVal", function (inner) {
      return function (node) {
        if (node.type !== "TypeCastExpression") {
          return inner.apply(this, arguments);
        }
      };
    });
    instance.extend("parseClassProperty", function (inner) {
      return function (node) {
        if (this.match(_types.types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return inner.call(this, node);
      };
    });
    instance.extend("isClassProperty", function (inner) {
      return function () {
        return this.match(_types.types.colon) || inner.call(this);
      };
    });
    instance.extend("parseClassMethod", function () {
      return function (classBody, method, isGenerator, isAsync) {
        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.parseMethod(method, isGenerator, isAsync);
        classBody.body.push(this.finishNode(method, "ClassMethod"));
      };
    });
    instance.extend("parseClassSuper", function (inner) {
      return function (node, isStatement) {
        inner.call(this, node, isStatement);
        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual("implements")) {
          this.next();
          var implemented = node.implements = [];
          do {
            var _node = this.startNode();
            _node.id = this.parseIdentifier();
            if (this.isRelational("<")) {
              _node.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node.typeParameters = null;
            }
            implemented.push(this.finishNode(_node, "ClassImplements"));
          } while (this.eat(_types.types.comma));
        }
      };
    });
    instance.extend("parseObjPropValue", function (inner) {
      return function (prop) {
        var typeParameters = void 0;
        if (this.isRelational("<")) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(_types.types.parenL))
            this.unexpected();
        }
        inner.apply(this, arguments);
        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      };
    });
    instance.extend("parseAssignableListItemTypes", function () {
      return function (param) {
        if (this.eat(_types.types.question)) {
          param.optional = true;
        }
        if (this.match(_types.types.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        }
        this.finishNode(param, param.type);
        return param;
      };
    });
    instance.extend("parseMaybeDefault", function (inner) {
      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var node = inner.apply(this, args);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
        }
        return node;
      };
    });
    instance.extend("parseImportSpecifiers", function (inner) {
      return function (node) {
        node.importKind = "value";
        var kind = null;
        if (this.match(_types.types._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }
        if (kind) {
          var lh = this.lookahead();
          if (lh.type === _types.types.name && lh.value !== "from" || lh.type === _types.types.braceL || lh.type === _types.types.star) {
            this.next();
            node.importKind = kind;
          }
        }
        inner.call(this, node);
      };
    });
    instance.extend("parseFunctionParams", function (inner) {
      return function (node) {
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        inner.call(this, node);
      };
    });
    instance.extend("parseVarHead", function (inner) {
      return function (decl) {
        inner.call(this, decl);
        if (this.match(_types.types.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.finishNode(decl.id, decl.id.type);
        }
      };
    });
    instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
      return function (node, call) {
        if (this.match(_types.types.colon)) {
          node.returnType = this.flowParseTypeAnnotation();
        }
        return inner.call(this, node, call);
      };
    });
    instance.extend("shouldParseAsyncArrow", function (inner) {
      return function () {
        return this.match(_types.types.colon) || inner.call(this);
      };
    });
    instance.extend("parseMaybeAssign", function (inner) {
      return function () {
        var jsxError = null;
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (_types.types.jsxTagStart && this.match(_types.types.jsxTagStart)) {
          var state = this.state.clone();
          try {
            return inner.apply(this, args);
          } catch (err) {
            if (err instanceof SyntaxError) {
              this.state = state;
              jsxError = err;
            } else {
              throw err;
            }
          }
        }
        this.state.context.push(_context.types.parenExpression);
        if (jsxError != null || this.isRelational("<")) {
          var arrowExpression = void 0;
          var typeParameters = void 0;
          try {
            typeParameters = this.flowParseTypeParameterDeclaration();
            arrowExpression = inner.apply(this, args);
            arrowExpression.typeParameters = typeParameters;
            arrowExpression.start = typeParameters.start;
            arrowExpression.loc.start = typeParameters.loc.start;
          } catch (err) {
            throw jsxError || err;
          }
          if (arrowExpression.type === "ArrowFunctionExpression") {
            return arrowExpression;
          } else if (jsxError != null) {
            throw jsxError;
          } else {
            this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
          }
        }
        this.state.context.pop();
        return inner.apply(this, args);
      };
    });
    instance.extend("parseArrow", function (inner) {
      return function (node) {
        if (this.match(_types.types.colon)) {
          var state = this.state.clone();
          try {
            var returnType = this.flowParseTypeAnnotation();
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(_types.types.arrow))
              this.unexpected();
            node.returnType = returnType;
          } catch (err) {
            if (err instanceof SyntaxError) {
              this.state = state;
            } else {
              throw err;
            }
          }
        }
        return inner.call(this, node);
      };
    });
    instance.extend("shouldParseArrow", function (inner) {
      return function () {
        return this.match(_types.types.colon) || inner.call(this);
      };
    });
    instance.extend("isClassMutatorStarter", function (inner) {
      return function () {
        if (this.isRelational("<")) {
          return true;
        } else {
          return inner.call(this);
        }
      };
    });
  };
  var _types = requireTypes();
  var _context = requireContext$2();
  var _parser = requireParser();
  var _parser2 = _interopRequireDefault(_parser);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pp = _parser2.default.prototype;
  pp.flowParseTypeInitialiser = function (tok, allowLeadingPipeOrAnd) {
    var oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(tok || _types.types.colon);
    if (allowLeadingPipeOrAnd) {
      if (this.match(_types.types.bitwiseAND) || this.match(_types.types.bitwiseOR)) {
        this.next();
      }
    }
    var type = this.flowParseType();
    this.state.inType = oldInType;
    return type;
  };
  pp.flowParseDeclareClass = function (node) {
    this.next();
    this.flowParseInterfaceish(node, true);
    return this.finishNode(node, "DeclareClass");
  };
  pp.flowParseDeclareFunction = function (node) {
    this.next();
    var id = node.id = this.parseIdentifier();
    var typeNode = this.startNode();
    var typeContainer = this.startNode();
    if (this.isRelational("<")) {
      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }
    this.expect(_types.types.parenL);
    var tmp = this.flowParseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    this.expect(_types.types.parenR);
    typeNode.returnType = this.flowParseTypeInitialiser();
    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
    this.finishNode(id, id.type);
    this.semicolon();
    return this.finishNode(node, "DeclareFunction");
  };
  pp.flowParseDeclare = function (node) {
    if (this.match(_types.types._class)) {
      return this.flowParseDeclareClass(node);
    } else if (this.match(_types.types._function)) {
      return this.flowParseDeclareFunction(node);
    } else if (this.match(_types.types._var)) {
      return this.flowParseDeclareVariable(node);
    } else if (this.isContextual("module")) {
      if (this.lookahead().type === _types.types.dot) {
        return this.flowParseDeclareModuleExports(node);
      } else {
        return this.flowParseDeclareModule(node);
      }
    } else if (this.isContextual("type")) {
      return this.flowParseDeclareTypeAlias(node);
    } else if (this.isContextual("interface")) {
      return this.flowParseDeclareInterface(node);
    } else {
      this.unexpected();
    }
  };
  pp.flowParseDeclareVariable = function (node) {
    this.next();
    node.id = this.flowParseTypeAnnotatableIdentifier();
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  };
  pp.flowParseDeclareModule = function (node) {
    this.next();
    if (this.match(_types.types.string)) {
      node.id = this.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }
    var bodyNode = node.body = this.startNode();
    var body = bodyNode.body = [];
    this.expect(_types.types.braceL);
    while (!this.match(_types.types.braceR)) {
      var node2 = this.startNode();
      this.expectContextual("declare", "Unexpected token. Only declares are allowed inside declare module");
      body.push(this.flowParseDeclare(node2));
    }
    this.expect(_types.types.braceR);
    this.finishNode(bodyNode, "BlockStatement");
    return this.finishNode(node, "DeclareModule");
  };
  pp.flowParseDeclareModuleExports = function (node) {
    this.expectContextual("module");
    this.expect(_types.types.dot);
    this.expectContextual("exports");
    node.typeAnnotation = this.flowParseTypeAnnotation();
    return this.finishNode(node, "DeclareModuleExports");
  };
  pp.flowParseDeclareTypeAlias = function (node) {
    this.next();
    this.flowParseTypeAlias(node);
    return this.finishNode(node, "DeclareTypeAlias");
  };
  pp.flowParseDeclareInterface = function (node) {
    this.next();
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "DeclareInterface");
  };
  pp.flowParseInterfaceish = function (node, allowStatic) {
    node.id = this.parseIdentifier();
    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }
    node.extends = [];
    node.mixins = [];
    if (this.eat(_types.types._extends)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(_types.types.comma));
    }
    if (this.isContextual("mixins")) {
      this.next();
      do {
        node.mixins.push(this.flowParseInterfaceExtends());
      } while (this.eat(_types.types.comma));
    }
    node.body = this.flowParseObjectType(allowStatic);
  };
  pp.flowParseInterfaceExtends = function () {
    var node = this.startNode();
    node.id = this.flowParseQualifiedTypeIdentifier();
    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }
    return this.finishNode(node, "InterfaceExtends");
  };
  pp.flowParseInterface = function (node) {
    this.flowParseInterfaceish(node, false);
    return this.finishNode(node, "InterfaceDeclaration");
  };
  pp.flowParseTypeAlias = function (node) {
    node.id = this.parseIdentifier();
    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }
    node.right = this.flowParseTypeInitialiser(_types.types.eq, true);
    this.semicolon();
    return this.finishNode(node, "TypeAlias");
  };
  pp.flowParseTypeParameter = function () {
    var node = this.startNode();
    var variance = void 0;
    if (this.match(_types.types.plusMin)) {
      if (this.state.value === "+") {
        variance = "plus";
      } else if (this.state.value === "-") {
        variance = "minus";
      }
      this.eat(_types.types.plusMin);
    }
    var ident = this.flowParseTypeAnnotatableIdentifier(false, false);
    node.name = ident.name;
    node.variance = variance;
    node.bound = ident.typeAnnotation;
    if (this.match(_types.types.eq)) {
      this.eat(_types.types.eq);
      node.default = this.flowParseType();
    }
    return this.finishNode(node, "TypeParameter");
  };
  pp.flowParseTypeParameterDeclaration = function () {
    var oldInType = this.state.inType;
    var node = this.startNode();
    node.params = [];
    this.state.inType = true;
    if (this.isRelational("<") || this.match(_types.types.jsxTagStart)) {
      this.next();
    } else {
      this.unexpected();
    }
    do {
      node.params.push(this.flowParseTypeParameter());
      if (!this.isRelational(">")) {
        this.expect(_types.types.comma);
      }
    } while (!this.isRelational(">"));
    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterDeclaration");
  };
  pp.flowParseTypeParameterInstantiation = function () {
    var node = this.startNode(), oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expectRelational("<");
    while (!this.isRelational(">")) {
      node.params.push(this.flowParseType());
      if (!this.isRelational(">")) {
        this.expect(_types.types.comma);
      }
    }
    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  };
  pp.flowParseObjectPropertyKey = function () {
    return this.match(_types.types.num) || this.match(_types.types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  };
  pp.flowParseObjectTypeIndexer = function (node, isStatic) {
    node.static = isStatic;
    this.expect(_types.types.bracketL);
    node.id = this.flowParseObjectPropertyKey();
    node.key = this.flowParseTypeInitialiser();
    this.expect(_types.types.bracketR);
    node.value = this.flowParseTypeInitialiser();
    this.flowObjectTypeSemicolon();
    return this.finishNode(node, "ObjectTypeIndexer");
  };
  pp.flowParseObjectTypeMethodish = function (node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;
    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    this.expect(_types.types.parenL);
    while (this.match(_types.types.name)) {
      node.params.push(this.flowParseFunctionTypeParam());
      if (!this.match(_types.types.parenR)) {
        this.expect(_types.types.comma);
      }
    }
    if (this.eat(_types.types.ellipsis)) {
      node.rest = this.flowParseFunctionTypeParam();
    }
    this.expect(_types.types.parenR);
    node.returnType = this.flowParseTypeInitialiser();
    return this.finishNode(node, "FunctionTypeAnnotation");
  };
  pp.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
    var node = this.startNodeAt(startPos, startLoc);
    node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
    node.static = isStatic;
    node.key = key;
    node.optional = false;
    this.flowObjectTypeSemicolon();
    return this.finishNode(node, "ObjectTypeProperty");
  };
  pp.flowParseObjectTypeCallProperty = function (node, isStatic) {
    var valueNode = this.startNode();
    node.static = isStatic;
    node.value = this.flowParseObjectTypeMethodish(valueNode);
    this.flowObjectTypeSemicolon();
    return this.finishNode(node, "ObjectTypeCallProperty");
  };
  pp.flowParseObjectType = function (allowStatic, allowExact) {
    var nodeStart = this.startNode();
    var node = void 0;
    var propertyKey = void 0;
    var isStatic = false;
    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];
    var endDelim = void 0;
    var exact = void 0;
    if (allowExact && this.match(_types.types.braceBarL)) {
      this.expect(_types.types.braceBarL);
      endDelim = _types.types.braceBarR;
      exact = true;
    } else {
      this.expect(_types.types.braceL);
      endDelim = _types.types.braceR;
      exact = false;
    }
    nodeStart.exact = exact;
    while (!this.match(endDelim)) {
      var optional = false;
      var startPos = this.state.start, startLoc = this.state.startLoc;
      node = this.startNode();
      if (allowStatic && this.isContextual("static")) {
        this.next();
        isStatic = true;
      }
      if (this.match(_types.types.bracketL)) {
        nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic));
      } else if (this.match(_types.types.parenL) || this.isRelational("<")) {
        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, allowStatic));
      } else {
        if (isStatic && this.match(_types.types.colon)) {
          propertyKey = this.parseIdentifier();
        } else {
          propertyKey = this.flowParseObjectPropertyKey();
        }
        if (this.isRelational("<") || this.match(_types.types.parenL)) {
          nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
        } else {
          if (this.eat(_types.types.question)) {
            optional = true;
          }
          node.key = propertyKey;
          node.value = this.flowParseTypeInitialiser();
          node.optional = optional;
          node.static = isStatic;
          this.flowObjectTypeSemicolon();
          nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
        }
      }
      isStatic = false;
    }
    this.expect(endDelim);
    return this.finishNode(nodeStart, "ObjectTypeAnnotation");
  };
  pp.flowObjectTypeSemicolon = function () {
    if (!this.eat(_types.types.semi) && !this.eat(_types.types.comma) && !this.match(_types.types.braceR) && !this.match(_types.types.braceBarR)) {
      this.unexpected();
    }
  };
  pp.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    var node = id || this.parseIdentifier();
    while (this.eat(_types.types.dot)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.qualification = node;
      node2.id = this.parseIdentifier();
      node = this.finishNode(node2, "QualifiedTypeIdentifier");
    }
    return node;
  };
  pp.flowParseGenericType = function (startPos, startLoc, id) {
    var node = this.startNodeAt(startPos, startLoc);
    node.typeParameters = null;
    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    }
    return this.finishNode(node, "GenericTypeAnnotation");
  };
  pp.flowParseTypeofType = function () {
    var node = this.startNode();
    this.expect(_types.types._typeof);
    node.argument = this.flowParsePrimaryType();
    return this.finishNode(node, "TypeofTypeAnnotation");
  };
  pp.flowParseTupleType = function () {
    var node = this.startNode();
    node.types = [];
    this.expect(_types.types.bracketL);
    while (this.state.pos < this.input.length && !this.match(_types.types.bracketR)) {
      node.types.push(this.flowParseType());
      if (this.match(_types.types.bracketR))
        break;
      this.expect(_types.types.comma);
    }
    this.expect(_types.types.bracketR);
    return this.finishNode(node, "TupleTypeAnnotation");
  };
  pp.flowParseFunctionTypeParam = function () {
    var optional = false;
    var node = this.startNode();
    node.name = this.parseIdentifier();
    if (this.eat(_types.types.question)) {
      optional = true;
    }
    node.optional = optional;
    node.typeAnnotation = this.flowParseTypeInitialiser();
    return this.finishNode(node, "FunctionTypeParam");
  };
  pp.flowParseFunctionTypeParams = function () {
    var ret = {
      params: [],
      rest: null
    };
    while (this.match(_types.types.name)) {
      ret.params.push(this.flowParseFunctionTypeParam());
      if (!this.match(_types.types.parenR)) {
        this.expect(_types.types.comma);
      }
    }
    if (this.eat(_types.types.ellipsis)) {
      ret.rest = this.flowParseFunctionTypeParam();
    }
    return ret;
  };
  pp.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
    switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");
    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");
    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");
    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");
    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");
    case "string":
      return this.finishNode(node, "StringTypeAnnotation");
    default:
      return this.flowParseGenericType(startPos, startLoc, id);
    }
  };
  pp.flowParsePrimaryType = function () {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var node = this.startNode();
    var tmp = void 0;
    var type = void 0;
    var isGroupedType = false;
    switch (this.state.type) {
    case _types.types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
    case _types.types.braceL:
      return this.flowParseObjectType(false, false);
    case _types.types.braceBarL:
      return this.flowParseObjectType(false, true);
    case _types.types.bracketL:
      return this.flowParseTupleType();
    case _types.types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(_types.types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(_types.types.parenR);
        this.expect(_types.types.arrow);
        node.returnType = this.flowParseType();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;
    case _types.types.parenL:
      this.next();
      if (!this.match(_types.types.parenR) && !this.match(_types.types.ellipsis)) {
        if (this.match(_types.types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== _types.types.question && token !== _types.types.colon;
        } else {
          isGroupedType = true;
        }
      }
      if (isGroupedType) {
        type = this.flowParseType();
        this.expect(_types.types.parenR);
        return type;
      }
      tmp = this.flowParseFunctionTypeParams();
      node.params = tmp.params;
      node.rest = tmp.rest;
      this.expect(_types.types.parenR);
      this.expect(_types.types.arrow);
      node.returnType = this.flowParseType();
      node.typeParameters = null;
      return this.finishNode(node, "FunctionTypeAnnotation");
    case _types.types.string:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "StringLiteralTypeAnnotation");
    case _types.types._true:
    case _types.types._false:
      node.value = this.match(_types.types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");
    case _types.types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(_types.types.num))
          this.unexpected();
        node.value = -this.state.value;
        this.addExtra(node, "rawValue", node.value);
        this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
        this.next();
        return this.finishNode(node, "NumericLiteralTypeAnnotation");
      }
    case _types.types.num:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "NumericLiteralTypeAnnotation");
    case _types.types._null:
      node.value = this.match(_types.types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");
    case _types.types._this:
      node.value = this.match(_types.types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");
    case _types.types.star:
      this.next();
      return this.finishNode(node, "ExistentialTypeParam");
    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
    }
    this.unexpected();
  };
  pp.flowParsePostfixType = function () {
    var node = this.startNode();
    var type = node.elementType = this.flowParsePrimaryType();
    if (this.match(_types.types.bracketL)) {
      this.expect(_types.types.bracketL);
      this.expect(_types.types.bracketR);
      return this.finishNode(node, "ArrayTypeAnnotation");
    } else {
      return type;
    }
  };
  pp.flowParsePrefixType = function () {
    var node = this.startNode();
    if (this.eat(_types.types.question)) {
      node.typeAnnotation = this.flowParsePrefixType();
      return this.finishNode(node, "NullableTypeAnnotation");
    } else {
      return this.flowParsePostfixType();
    }
  };
  pp.flowParseIntersectionType = function () {
    var node = this.startNode();
    var type = this.flowParsePrefixType();
    node.types = [type];
    while (this.eat(_types.types.bitwiseAND)) {
      node.types.push(this.flowParsePrefixType());
    }
    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
  };
  pp.flowParseUnionType = function () {
    var node = this.startNode();
    var type = this.flowParseIntersectionType();
    node.types = [type];
    while (this.eat(_types.types.bitwiseOR)) {
      node.types.push(this.flowParseIntersectionType());
    }
    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
  };
  pp.flowParseType = function () {
    var oldInType = this.state.inType;
    this.state.inType = true;
    var type = this.flowParseUnionType();
    this.state.inType = oldInType;
    return type;
  };
  pp.flowParseTypeAnnotation = function () {
    var node = this.startNode();
    node.typeAnnotation = this.flowParseTypeInitialiser();
    return this.finishNode(node, "TypeAnnotation");
  };
  pp.flowParseTypeAnnotatableIdentifier = function (requireTypeAnnotation, canBeOptionalParam) {
    var ident = this.parseIdentifier();
    var isOptionalParam = false;
    if (canBeOptionalParam && this.eat(_types.types.question)) {
      this.expect(_types.types.question);
      isOptionalParam = true;
    }
    if (requireTypeAnnotation || this.match(_types.types.colon)) {
      ident.typeAnnotation = this.flowParseTypeAnnotation();
      this.finishNode(ident, ident.type);
    }
    if (isOptionalParam) {
      ident.optional = true;
      this.finishNode(ident, ident.type);
    }
    return ident;
  };
  pp.typeCastToParameter = function (node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
  };
  return flow;
}

var jsx = {};

var xhtml = {};

var hasRequiredXhtml;
function requireXhtml() {
  if (hasRequiredXhtml)
    return xhtml;
  hasRequiredXhtml = 1;
  xhtml.__esModule = true;
  xhtml.default = {
    quot: "\"",
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "ª",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "µ",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "º",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "\xD7",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "\xF7",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "\u02DC",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "‌",
    zwj: "‍",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "ℑ",
    weierp: "\u2118",
    real: "ℜ",
    trade: "\u2122",
    alefsym: "ℵ",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };
  return xhtml;
}

var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx)
    return jsx;
  hasRequiredJsx = 1;
  jsx.__esModule = true;
  jsx.default = function (instance) {
    instance.extend("parseExprAtom", function (inner) {
      return function (refShortHandDefaultPos) {
        if (this.match(_types.types.jsxText)) {
          var node = this.parseLiteral(this.state.value, "JSXText");
          node.extra = null;
          return node;
        } else if (this.match(_types.types.jsxTagStart)) {
          return this.jsxParseElement();
        } else {
          return inner.call(this, refShortHandDefaultPos);
        }
      };
    });
    instance.extend("readToken", function (inner) {
      return function (code) {
        var context = this.curContext();
        if (context === _context.types.j_expr) {
          return this.jsxReadToken();
        }
        if (context === _context.types.j_oTag || context === _context.types.j_cTag) {
          if ((0, _identifier.isIdentifierStart)(code)) {
            return this.jsxReadWord();
          }
          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(_types.types.jsxTagEnd);
          }
          if ((code === 34 || code === 39) && context === _context.types.j_oTag) {
            return this.jsxReadString(code);
          }
        }
        if (code === 60 && this.state.exprAllowed) {
          ++this.state.pos;
          return this.finishToken(_types.types.jsxTagStart);
        }
        return inner.call(this, code);
      };
    });
    instance.extend("updateContext", function (inner) {
      return function (prevType) {
        if (this.match(_types.types.braceL)) {
          var curContext = this.curContext();
          if (curContext === _context.types.j_oTag) {
            this.state.context.push(_context.types.braceExpression);
          } else if (curContext === _context.types.j_expr) {
            this.state.context.push(_context.types.templateQuasi);
          } else {
            inner.call(this, prevType);
          }
          this.state.exprAllowed = true;
        } else if (this.match(_types.types.slash) && prevType === _types.types.jsxTagStart) {
          this.state.context.length -= 2;
          this.state.context.push(_context.types.j_cTag);
          this.state.exprAllowed = false;
        } else {
          return inner.call(this, prevType);
        }
      };
    });
  };
  var _xhtml = requireXhtml();
  var _xhtml2 = _interopRequireDefault(_xhtml);
  var _types = requireTypes();
  var _context = requireContext$2();
  var _parser = requireParser();
  var _parser2 = _interopRequireDefault(_parser);
  var _identifier = requireIdentifier();
  var _whitespace = requireWhitespace();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var HEX_NUMBER = /^[\da-fA-F]+$/;
  var DECIMAL_NUMBER = /^\d+$/;
  _context.types.j_oTag = new _context.TokContext("<tag", false);
  _context.types.j_cTag = new _context.TokContext("</tag", false);
  _context.types.j_expr = new _context.TokContext("<tag>...</tag>", true, true);
  _types.types.jsxName = new _types.TokenType("jsxName");
  _types.types.jsxText = new _types.TokenType("jsxText", { beforeExpr: true });
  _types.types.jsxTagStart = new _types.TokenType("jsxTagStart", { startsExpr: true });
  _types.types.jsxTagEnd = new _types.TokenType("jsxTagEnd");
  _types.types.jsxTagStart.updateContext = function () {
    this.state.context.push(_context.types.j_expr);
    this.state.context.push(_context.types.j_oTag);
    this.state.exprAllowed = false;
  };
  _types.types.jsxTagEnd.updateContext = function (prevType) {
    var out = this.state.context.pop();
    if (out === _context.types.j_oTag && prevType === _types.types.slash || out === _context.types.j_cTag) {
      this.state.context.pop();
      this.state.exprAllowed = this.curContext() === _context.types.j_expr;
    } else {
      this.state.exprAllowed = true;
    }
  };
  var pp = _parser2.default.prototype;
  pp.jsxReadToken = function () {
    var out = "";
    var chunkStart = this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) {
        this.raise(this.state.start, "Unterminated JSX contents");
      }
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
      case 60:
      case 123:
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(_types.types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(_types.types.jsxText, out);
      case 38:
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;
      default:
        if ((0, _whitespace.isNewLine)(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }
  };
  pp.jsxReadNewLine = function (normalizeCRLF) {
    var ch = this.input.charCodeAt(this.state.pos);
    var out = void 0;
    ++this.state.pos;
    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
      ++this.state.pos;
      out = normalizeCRLF ? "\n" : "\r\n";
    } else {
      out = String.fromCharCode(ch);
    }
    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  };
  pp.jsxReadString = function (quote) {
    var out = "";
    var chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) {
        this.raise(this.state.start, "Unterminated string constant");
      }
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote)
        break;
      if (ch === 38) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
      } else if ((0, _whitespace.isNewLine)(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadNewLine(false);
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(_types.types.string, out);
  };
  pp.jsxReadEntity = function () {
    var str = "";
    var count = 0;
    var entity = void 0;
    var ch = this.input[this.state.pos];
    var startPos = ++this.state.pos;
    while (this.state.pos < this.input.length && count++ < 10) {
      ch = this.input[this.state.pos++];
      if (ch === ";") {
        if (str[0] === "#") {
          if (str[1] === "x") {
            str = str.substr(2);
            if (HEX_NUMBER.test(str))
              entity = String.fromCharCode(parseInt(str, 16));
          } else {
            str = str.substr(1);
            if (DECIMAL_NUMBER.test(str))
              entity = String.fromCharCode(parseInt(str, 10));
          }
        } else {
          entity = _xhtml2.default[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      this.state.pos = startPos;
      return "&";
    }
    return entity;
  };
  pp.jsxReadWord = function () {
    var ch = void 0;
    var start = this.state.pos;
    do {
      ch = this.input.charCodeAt(++this.state.pos);
    } while ((0, _identifier.isIdentifierChar)(ch) || ch === 45);
    return this.finishToken(_types.types.jsxName, this.input.slice(start, this.state.pos));
  };
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
  }
  pp.jsxParseIdentifier = function () {
    var node = this.startNode();
    if (this.match(_types.types.jsxName)) {
      node.name = this.state.value;
    } else if (this.state.type.keyword) {
      node.name = this.state.type.keyword;
    } else {
      this.unexpected();
    }
    this.next();
    return this.finishNode(node, "JSXIdentifier");
  };
  pp.jsxParseNamespacedName = function () {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var name = this.jsxParseIdentifier();
    if (!this.eat(_types.types.colon))
      return name;
    var node = this.startNodeAt(startPos, startLoc);
    node.namespace = name;
    node.name = this.jsxParseIdentifier();
    return this.finishNode(node, "JSXNamespacedName");
  };
  pp.jsxParseElementName = function () {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    var node = this.jsxParseNamespacedName();
    while (this.eat(_types.types.dot)) {
      var newNode = this.startNodeAt(startPos, startLoc);
      newNode.object = node;
      newNode.property = this.jsxParseIdentifier();
      node = this.finishNode(newNode, "JSXMemberExpression");
    }
    return node;
  };
  pp.jsxParseAttributeValue = function () {
    var node = void 0;
    switch (this.state.type) {
    case _types.types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }
    case _types.types.jsxTagStart:
    case _types.types.string:
      node = this.parseExprAtom();
      node.extra = null;
      return node;
    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
    }
  };
  pp.jsxParseEmptyExpression = function () {
    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
    return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
  };
  pp.jsxParseSpreadChild = function () {
    var node = this.startNode();
    this.expect(_types.types.braceL);
    this.expect(_types.types.ellipsis);
    node.expression = this.parseExpression();
    this.expect(_types.types.braceR);
    return this.finishNode(node, "JSXSpreadChild");
  };
  pp.jsxParseExpressionContainer = function () {
    var node = this.startNode();
    this.next();
    if (this.match(_types.types.braceR)) {
      node.expression = this.jsxParseEmptyExpression();
    } else {
      node.expression = this.parseExpression();
    }
    this.expect(_types.types.braceR);
    return this.finishNode(node, "JSXExpressionContainer");
  };
  pp.jsxParseAttribute = function () {
    var node = this.startNode();
    if (this.eat(_types.types.braceL)) {
      this.expect(_types.types.ellipsis);
      node.argument = this.parseMaybeAssign();
      this.expect(_types.types.braceR);
      return this.finishNode(node, "JSXSpreadAttribute");
    }
    node.name = this.jsxParseNamespacedName();
    node.value = this.eat(_types.types.eq) ? this.jsxParseAttributeValue() : null;
    return this.finishNode(node, "JSXAttribute");
  };
  pp.jsxParseOpeningElementAt = function (startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.attributes = [];
    node.name = this.jsxParseElementName();
    while (!this.match(_types.types.slash) && !this.match(_types.types.jsxTagEnd)) {
      node.attributes.push(this.jsxParseAttribute());
    }
    node.selfClosing = this.eat(_types.types.slash);
    this.expect(_types.types.jsxTagEnd);
    return this.finishNode(node, "JSXOpeningElement");
  };
  pp.jsxParseClosingElementAt = function (startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.name = this.jsxParseElementName();
    this.expect(_types.types.jsxTagEnd);
    return this.finishNode(node, "JSXClosingElement");
  };
  pp.jsxParseElementAt = function (startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    var children = [];
    var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
    var closingElement = null;
    if (!openingElement.selfClosing) {
      contents:
        for (;;) {
          switch (this.state.type) {
          case _types.types.jsxTagStart:
            startPos = this.state.start;
            startLoc = this.state.startLoc;
            this.next();
            if (this.eat(_types.types.slash)) {
              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
              break contents;
            }
            children.push(this.jsxParseElementAt(startPos, startLoc));
            break;
          case _types.types.jsxText:
            children.push(this.parseExprAtom());
            break;
          case _types.types.braceL:
            if (this.lookahead().type === _types.types.ellipsis) {
              children.push(this.jsxParseSpreadChild());
            } else {
              children.push(this.jsxParseExpressionContainer());
            }
            break;
          default:
            this.unexpected();
          }
        }
      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
        this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
      }
    }
    node.openingElement = openingElement;
    node.closingElement = closingElement;
    node.children = children;
    if (this.match(_types.types.relational) && this.state.value === "<") {
      this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
    }
    return this.finishNode(node, "JSXElement");
  };
  pp.jsxParseElement = function () {
    var startPos = this.state.start, startLoc = this.state.startLoc;
    this.next();
    return this.jsxParseElementAt(startPos, startLoc);
  };
  return jsx;
}

var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3)
    return lib;
  hasRequiredLib$3 = 1;
  lib.__esModule = true;
  lib.tokTypes = undefined;
  lib.parse = parse;
  var _parser = requireParser();
  var _parser2 = _interopRequireDefault(_parser);
  requireUtil$1();
  requireStatement();
  requireLval();
  requireExpression();
  requireNode();
  requireLocation();
  requireComments$1();
  var _types = requireTypes();
  requireTokenizer();
  requireContext$2();
  var _flow = requireFlow();
  var _flow2 = _interopRequireDefault(_flow);
  var _jsx = requireJsx();
  var _jsx2 = _interopRequireDefault(_jsx);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  _parser.plugins.flow = _flow2.default;
  _parser.plugins.jsx = _jsx2.default;
  function parse(input, options) {
    return new _parser2.default(options, input).parse();
  }
  lib.tokTypes = _types.types;
  return lib;
}

var hasRequiredReplacement;
function requireReplacement() {
  if (hasRequiredReplacement)
    return replacement;
  hasRequiredReplacement = 1;
  replacement.__esModule = true;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  replacement.replaceWithMultiple = replaceWithMultiple;
  replacement.replaceWithSourceString = replaceWithSourceString;
  replacement.replaceWith = replaceWith;
  replacement._replaceWith = _replaceWith;
  replacement.replaceExpressionWithStatements = replaceExpressionWithStatements;
  replacement.replaceInline = replaceInline;
  var _babelCodeFrame = requireLib$4();
  var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);
  var _index = requireLib$2();
  var _index2 = _interopRequireDefault(_index);
  var _index3 = requirePath();
  var _index4 = _interopRequireDefault(_index3);
  var _babylon = requireLib$3();
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hoistVariablesVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    VariableDeclaration: function VariableDeclaration(path) {
      if (path.node.kind !== "var")
        return;
      var bindings = path.getBindingIdentifiers();
      for (var key in bindings) {
        path.scope.push({ id: bindings[key] });
      }
      var exprs = [];
      for (var _iterator = path.node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var declar = _ref;
        if (declar.init) {
          exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
        }
      }
      path.replaceWithMultiple(exprs);
    }
  };
  function replaceWithMultiple(nodes) {
    this.resync();
    nodes = this._verifyNodeList(nodes);
    t.inheritLeadingComments(nodes[0], this.node);
    t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
    this.node = this.container[this.key] = null;
    this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
  }
  function replaceWithSourceString(replacement) {
    this.resync();
    try {
      replacement = "(" + replacement + ")";
      replacement = (0, _babylon.parse)(replacement);
    } catch (err) {
      var loc = err.loc;
      if (loc) {
        err.message += " - make sure this is an expression.";
        err.message += "\n" + (0, _babelCodeFrame2.default)(replacement, loc.line, loc.column + 1);
      }
      throw err;
    }
    replacement = replacement.program.body[0].expression;
    _index2.default.removeProperties(replacement);
    return this.replaceWith(replacement);
  }
  function replaceWith(replacement) {
    this.resync();
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    if (replacement instanceof _index4.default) {
      replacement = replacement.node;
    }
    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement) {
      return;
    }
    if (this.isProgram() && !t.isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    if (this.isNodeType("Statement") && t.isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        replacement = t.expressionStatement(replacement);
      }
    }
    if (this.isNodeType("Expression") && t.isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }
    var oldNode = this.node;
    if (oldNode) {
      t.inheritsComments(replacement, oldNode);
      t.removeComments(oldNode);
    }
    this._replaceWith(replacement);
    this.type = replacement.type;
    this.setScope();
    this.requeue();
  }
  function _replaceWith(node) {
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      t.validate(this.parent, this.key, [node]);
    } else {
      t.validate(this.parent, this.key, node);
    }
    this.debug(function () {
      return "Replace with " + (node && node.type);
    });
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    this.resync();
    var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);
    if (t.isSequenceExpression(toSequenceExpression)) {
      var exprs = toSequenceExpression.expressions;
      if (exprs.length >= 2 && this.parentPath.isExpressionStatement()) {
        this._maybePopFromStatements(exprs);
      }
      if (exprs.length === 1) {
        this.replaceWith(exprs[0]);
      } else {
        this.replaceWith(toSequenceExpression);
      }
    } else if (toSequenceExpression) {
      this.replaceWith(toSequenceExpression);
    } else {
      var container = t.functionExpression(null, [], t.blockStatement(nodes));
      container.shadow = true;
      this.replaceWith(t.callExpression(container, []));
      this.traverse(hoistVariablesVisitor);
      var completionRecords = this.get("callee").getCompletionRecords();
      for (var _iterator2 = completionRecords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var path = _ref2;
        if (!path.isExpressionStatement())
          continue;
        var loop = path.findParent(function (path) {
          return path.isLoop();
        });
        if (loop) {
          var callee = this.get("callee");
          var uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", t.returnStatement(uid));
          path.get("expression").replaceWith(t.assignmentExpression("=", uid, path.node.expression));
        } else {
          path.replaceWith(t.returnStatement(path.node.expression));
        }
      }
      return this.node;
    }
  }
  function replaceInline(nodes) {
    this.resync();
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);
        this._containerInsertAfter(nodes);
        return this.remove();
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }
  return replacement;
}

var evaluation = {};

var hasRequiredEvaluation;
function requireEvaluation() {
  if (hasRequiredEvaluation)
    return evaluation;
  hasRequiredEvaluation = 1;
  evaluation.__esModule = true;
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  var _map = requireMap();
  var _map2 = _interopRequireDefault(_map);
  evaluation.evaluateTruthy = evaluateTruthy;
  evaluation.evaluate = evaluate;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var VALID_CALLEES = [
    "String",
    "Number",
    "Math"
  ];
  var INVALID_METHODS = ["random"];
  function evaluateTruthy() {
    var res = this.evaluate();
    if (res.confident)
      return !!res.value;
  }
  function evaluate() {
    var confident = true;
    var deoptPath = void 0;
    var seen = new _map2.default();
    function deopt(path) {
      if (!confident)
        return;
      deoptPath = path;
      confident = false;
    }
    var value = evaluate(this);
    if (!confident)
      value = undefined;
    return {
      confident: confident,
      deopt: deoptPath,
      value: value
    };
    function evaluate(path) {
      var node = path.node;
      if (seen.has(node)) {
        var existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path);
          return;
        }
      } else {
        var item = { resolved: false };
        seen.set(node, item);
        var val = _evaluate(path);
        if (confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path) {
      if (!confident)
        return;
      var node = path.node;
      if (path.isSequenceExpression()) {
        var exprs = path.get("expressions");
        return evaluate(exprs[exprs.length - 1]);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        var str = "";
        var i = 0;
        var _exprs = path.get("expressions");
        for (var _iterator = node.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var elem = _ref;
          if (!confident)
            break;
          str += elem.value.cooked;
          var expr = _exprs[i++];
          if (expr)
            str += String(evaluate(expr));
        }
        if (!confident)
          return;
        return str;
      }
      if (path.isConditionalExpression()) {
        var testResult = evaluate(path.get("test"));
        if (!confident)
          return;
        if (testResult) {
          return evaluate(path.get("consequent"));
        } else {
          return evaluate(path.get("alternate"));
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluate(path.get("expression"));
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {
        var property = path.get("property");
        var object = path.get("object");
        if (object.isLiteral() && property.isIdentifier()) {
          var _value = object.node.value;
          var type = typeof _value === "undefined" ? "undefined" : (0, _typeof3.default)(_value);
          if (type === "number" || type === "string") {
            return _value[property.node.name];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        var binding = path.scope.getBinding(node.name);
        if (binding && binding.constantViolations.length > 0) {
          return deopt(binding.path);
        }
        if (binding && path.node.start < binding.path.node.end) {
          return deopt(binding.path);
        }
        if (binding && binding.hasValue) {
          return binding.value;
        } else {
          if (node.name === "undefined") {
            return undefined;
          } else if (node.name === "Infinity") {
            return Infinity;
          } else if (node.name === "NaN") {
            return NaN;
          }
          var resolved = path.resolve();
          if (resolved === path) {
            return deopt(path);
          } else {
            return evaluate(resolved);
          }
        }
      }
      if (path.isUnaryExpression({ prefix: true })) {
        if (node.operator === "void") {
          return undefined;
        }
        var argument = path.get("argument");
        if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        var arg = evaluate(argument);
        if (!confident)
          return;
        switch (node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg === "undefined" ? "undefined" : (0, _typeof3.default)(arg);
        }
      }
      if (path.isArrayExpression()) {
        var arr = [];
        var elems = path.get("elements");
        for (var _iterator2 = elems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var _elem = _ref2;
          _elem = _elem.evaluate();
          if (_elem.confident) {
            arr.push(_elem.value);
          } else {
            return deopt(_elem);
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        var obj = {};
        var props = path.get("properties");
        for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var prop = _ref3;
          if (prop.isObjectMethod() || prop.isSpreadProperty()) {
            return deopt(prop);
          }
          var keyPath = prop.get("key");
          var key = keyPath;
          if (prop.node.computed) {
            key = key.evaluate();
            if (!key.confident) {
              return deopt(keyPath);
            }
            key = key.value;
          } else if (key.isIdentifier()) {
            key = key.node.name;
          } else {
            key = key.node.value;
          }
          var valuePath = prop.get("value");
          var _value2 = valuePath.evaluate();
          if (!_value2.confident) {
            return deopt(valuePath);
          }
          _value2 = _value2.value;
          obj[key] = _value2;
        }
        return obj;
      }
      if (path.isLogicalExpression()) {
        var wasConfident = confident;
        var left = evaluate(path.get("left"));
        var leftConfident = confident;
        confident = wasConfident;
        var right = evaluate(path.get("right"));
        var rightConfident = confident;
        confident = leftConfident && rightConfident;
        switch (node.operator) {
        case "||":
          if (left && leftConfident) {
            confident = true;
            return left;
          }
          if (!confident)
            return;
          return left || right;
        case "&&":
          if (!left && leftConfident || !right && rightConfident) {
            confident = true;
          }
          if (!confident)
            return;
          return left && right;
        }
      }
      if (path.isBinaryExpression()) {
        var _left = evaluate(path.get("left"));
        if (!confident)
          return;
        var _right = evaluate(path.get("right"));
        if (!confident)
          return;
        switch (node.operator) {
        case "-":
          return _left - _right;
        case "+":
          return _left + _right;
        case "/":
          return _left / _right;
        case "*":
          return _left * _right;
        case "%":
          return _left % _right;
        case "**":
          return Math.pow(_left, _right);
        case "<":
          return _left < _right;
        case ">":
          return _left > _right;
        case "<=":
          return _left <= _right;
        case ">=":
          return _left >= _right;
        case "==":
          return _left == _right;
        case "!=":
          return _left != _right;
        case "===":
          return _left === _right;
        case "!==":
          return _left !== _right;
        case "|":
          return _left | _right;
        case "&":
          return _left & _right;
        case "^":
          return _left ^ _right;
        case "<<":
          return _left << _right;
        case ">>":
          return _left >> _right;
        case ">>>":
          return _left >>> _right;
        }
      }
      if (path.isCallExpression()) {
        var callee = path.get("callee");
        var context = void 0;
        var func = void 0;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
          func = commonjsGlobal[node.callee.name];
        }
        if (callee.isMemberExpression()) {
          var _object = callee.get("object");
          var _property = callee.get("property");
          if (_object.isIdentifier() && _property.isIdentifier() && VALID_CALLEES.indexOf(_object.node.name) >= 0 && INVALID_METHODS.indexOf(_property.node.name) < 0) {
            context = commonjsGlobal[_object.node.name];
            func = context[_property.node.name];
          }
          if (_object.isLiteral() && _property.isIdentifier()) {
            var _type = (0, _typeof3.default)(_object.node.value);
            if (_type === "string" || _type === "number") {
              context = _object.node.value;
              func = context[_property.node.name];
            }
          }
        }
        if (func) {
          var args = path.get("arguments").map(evaluate);
          if (!confident)
            return;
          return func.apply(context, args);
        }
      }
      deopt(path);
    }
  }
  return evaluation;
}

var conversion = {};

var hasRequiredConversion;
function requireConversion() {
  if (hasRequiredConversion)
    return conversion;
  hasRequiredConversion = 1;
  conversion.__esModule = true;
  conversion.toComputedKey = toComputedKey;
  conversion.ensureBlock = ensureBlock;
  conversion.arrowFunctionToShadowed = arrowFunctionToShadowed;
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function toComputedKey() {
    var node = this.node;
    var key = void 0;
    if (this.isMemberExpression()) {
      key = node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!node.computed) {
      if (t.isIdentifier(key))
        key = t.stringLiteral(key.name);
    }
    return key;
  }
  function ensureBlock() {
    return t.ensureBlock(this.node);
  }
  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression())
      return;
    this.ensureBlock();
    var node = this.node;
    node.expression = false;
    node.type = "FunctionExpression";
    node.shadow = node.shadow || true;
  }
  return conversion;
}

var introspection = {};

var hasRequiredIntrospection;
function requireIntrospection() {
  if (hasRequiredIntrospection)
    return introspection;
  hasRequiredIntrospection = 1;
  introspection.__esModule = true;
  introspection.is = undefined;
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  introspection.matchesPattern = matchesPattern;
  introspection.has = has;
  introspection.isStatic = isStatic;
  introspection.isnt = isnt;
  introspection.equals = equals;
  introspection.isNodeType = isNodeType;
  introspection.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
  introspection.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
  introspection.isCompletionRecord = isCompletionRecord;
  introspection.isStatementOrBlock = isStatementOrBlock;
  introspection.referencesImport = referencesImport;
  introspection.getSource = getSource;
  introspection.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
  introspection._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
  introspection._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
  introspection.resolve = resolve;
  introspection._resolve = _resolve;
  var _includes = requireIncludes();
  var _includes2 = _interopRequireDefault(_includes);
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function matchesPattern(pattern, allowPartial) {
    if (!this.isMemberExpression())
      return false;
    var parts = pattern.split(".");
    var search = [this.node];
    var i = 0;
    function matches(name) {
      var part = parts[i];
      return part === "*" || name === part;
    }
    while (search.length) {
      var node = search.shift();
      if (allowPartial && i === parts.length) {
        return true;
      }
      if (t.isIdentifier(node)) {
        if (!matches(node.name))
          return false;
      } else if (t.isLiteral(node)) {
        if (!matches(node.value))
          return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isLiteral(node.property)) {
          return false;
        } else {
          search.unshift(node.property);
          search.unshift(node.object);
          continue;
        }
      } else if (t.isThisExpression(node)) {
        if (!matches("this"))
          return false;
      } else {
        return false;
      }
      if (++i > parts.length) {
        return false;
      }
    }
    return i === parts.length;
  }
  function has(key) {
    var val = this.node && this.node[key];
    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }
  function isStatic() {
    return this.scope.isStatic(this.node);
  }
  introspection.is = has;
  function isnt(key) {
    return !this.has(key);
  }
  function equals(key, value) {
    return this.node[key] === value;
  }
  function isNodeType(type) {
    return t.isType(this.type, type);
  }
  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }
    if (this.isExpression()) {
      return t.isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return t.isExpression(replacement);
    }
    return false;
  }
  function isCompletionRecord(allowInsideFunction) {
    var path = this;
    var first = true;
    do {
      var container = path.container;
      if (path.isFunction() && !first) {
        return !!allowInsideFunction;
      }
      first = false;
      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());
    return true;
  }
  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
      return false;
    } else {
      return (0, _includes2.default)(t.STATEMENT_OR_BLOCK_KEYS, this.key);
    }
  }
  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier())
      return false;
    var binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module")
      return false;
    var path = binding.path;
    var parent = path.parentPath;
    if (!parent.isImportDeclaration())
      return false;
    if (parent.node.source.value === moduleSource) {
      if (!importName)
        return true;
    } else {
      return false;
    }
    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }
    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }
    if (path.isImportSpecifier() && path.node.imported.name === importName) {
      return true;
    }
    return false;
  }
  function getSource() {
    var node = this.node;
    if (node.end) {
      return this.hub.file.code.slice(node.start, node.end);
    } else {
      return "";
    }
  }
  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }
  function _guessExecutionStatusRelativeTo(target) {
    var targetFuncParent = target.scope.getFunctionParent();
    var selfFuncParent = this.scope.getFunctionParent();
    if (targetFuncParent.node !== selfFuncParent.node) {
      var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);
      if (status) {
        return status;
      } else {
        target = targetFuncParent.path;
      }
    }
    var targetPaths = target.getAncestry();
    if (targetPaths.indexOf(this) >= 0)
      return "after";
    var selfPaths = this.getAncestry();
    var commonPath = void 0;
    var targetIndex = void 0;
    var selfIndex = void 0;
    for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
      var selfPath = selfPaths[selfIndex];
      targetIndex = targetPaths.indexOf(selfPath);
      if (targetIndex >= 0) {
        commonPath = selfPath;
        break;
      }
    }
    if (!commonPath) {
      return "before";
    }
    var targetRelationship = targetPaths[targetIndex - 1];
    var selfRelationship = selfPaths[selfIndex - 1];
    if (!targetRelationship || !selfRelationship) {
      return "before";
    }
    if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
      return targetRelationship.key > selfRelationship.key ? "before" : "after";
    }
    var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
    var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
    return targetKeyPosition > selfKeyPosition ? "before" : "after";
  }
  function _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
    var targetFuncPath = targetFuncParent.path;
    if (!targetFuncPath.isFunctionDeclaration())
      return;
    var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);
    if (!binding.references)
      return "before";
    var referencePaths = binding.referencePaths;
    for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var path = _ref;
      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return;
      }
    }
    var allStatus = void 0;
    for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref2 = _i2.value;
      }
      var _path = _ref2;
      var childOfFunction = !!_path.find(function (path) {
        return path.node === targetFuncPath.node;
      });
      if (childOfFunction)
        continue;
      var status = this._guessExecutionStatusRelativeTo(_path);
      if (allStatus) {
        if (allStatus !== status)
          return;
      } else {
        allStatus = status;
      }
    }
    return allStatus;
  }
  function resolve(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }
  function _resolve(dangerous, resolved) {
    var _this = this;
    if (resolved && resolved.indexOf(this) >= 0)
      return;
    resolved = resolved || [];
    resolved.push(this);
    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      }
    } else if (this.isReferencedIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding)
        return;
      if (!binding.constant)
        return;
      if (binding.kind === "module")
        return;
      if (binding.path !== this) {
        var _ret = (function () {
          var ret = binding.path.resolve(dangerous, resolved);
          if (_this.find(function (parent) {
              return parent.node === ret.node;
            }))
            return { v: void 0 };
          return { v: ret };
        }());
        if ((typeof _ret === "undefined" ? "undefined" : (0, _typeof3.default)(_ret)) === "object")
          return _ret.v;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      var targetKey = this.toComputedKey();
      if (!t.isLiteral(targetKey))
        return;
      var targetName = targetKey.value;
      var target = this.get("object").resolve(dangerous, resolved);
      if (target.isObjectExpression()) {
        var props = target.get("properties");
        for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var prop = _ref3;
          if (!prop.isProperty())
            continue;
          var key = prop.get("key");
          var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });
          match = match || key.isLiteral({ value: targetName });
          if (match)
            return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        var elems = target.get("elements");
        var elem = elems[targetName];
        if (elem)
          return elem.resolve(dangerous, resolved);
      }
    }
  }
  return introspection;
}

var context$1 = {};

var hasRequiredContext$1;
function requireContext$1() {
  if (hasRequiredContext$1)
    return context$1;
  hasRequiredContext$1 = 1;
  context$1.__esModule = true;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  context$1.call = call;
  context$1._call = _call;
  context$1.isBlacklisted = isBlacklisted;
  context$1.visit = visit;
  context$1.skip = skip;
  context$1.skipKey = skipKey;
  context$1.stop = stop;
  context$1.setScope = setScope;
  context$1.setContext = setContext;
  context$1.resync = resync;
  context$1._resyncParent = _resyncParent;
  context$1._resyncKey = _resyncKey;
  context$1._resyncList = _resyncList;
  context$1._resyncRemoved = _resyncRemoved;
  context$1.popContext = popContext;
  context$1.pushContext = pushContext;
  context$1.setup = setup;
  context$1.setKey = setKey;
  context$1.requeue = requeue;
  context$1._getQueueContexts = _getQueueContexts;
  var _index = requireLib$2();
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function call(key) {
    var opts = this.opts;
    this.debug(function () {
      return key;
    });
    if (this.node) {
      if (this._call(opts[key]))
        return true;
    }
    if (this.node) {
      return this._call(opts[this.node.type] && opts[this.node.type][key]);
    }
    return false;
  }
  function _call(fns) {
    if (!fns)
      return false;
    for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var fn = _ref;
      if (!fn)
        continue;
      var node = this.node;
      if (!node)
        return true;
      var ret = fn.call(this.state, this, this.state);
      if (ret)
        throw new Error("Unexpected return value from visitor method " + fn);
      if (this.node !== node)
        return true;
      if (this.shouldStop || this.shouldSkip || this.removed)
        return true;
    }
    return false;
  }
  function isBlacklisted() {
    var blacklist = this.opts.blacklist;
    return blacklist && blacklist.indexOf(this.node.type) > -1;
  }
  function visit() {
    if (!this.node) {
      return false;
    }
    if (this.isBlacklisted()) {
      return false;
    }
    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
      return false;
    }
    if (this.call("enter") || this.shouldSkip) {
      this.debug(function () {
        return "Skip...";
      });
      return this.shouldStop;
    }
    this.debug(function () {
      return "Recursing into...";
    });
    _index2.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    this.call("exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    this.skipKeys[key] = true;
  }
  function stop() {
    this.shouldStop = true;
    this.shouldSkip = true;
  }
  function setScope() {
    if (this.opts && this.opts.noScope)
      return;
    var target = this.context && this.context.scope;
    if (!target) {
      var path = this.parentPath;
      while (path && !target) {
        if (path.opts && path.opts.noScope)
          return;
        target = path.scope;
        path = path.parentPath;
      }
    }
    this.scope = this.getScope(target);
    if (this.scope)
      this.scope.init();
  }
  function setContext(context) {
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.skipKeys = {};
    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }
    this.setScope();
    return this;
  }
  function resync() {
    if (this.removed)
      return;
    this._resyncParent();
    this._resyncList();
    this._resyncKey();
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container)
      return;
    if (this.node === this.container[this.key])
      return;
    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (var key in this.container) {
        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }
    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList)
      return;
    var newContainer = this.parent[this.listKey];
    if (this.container === newContainer)
      return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  }
  function popContext() {
    this.contexts.pop();
    this.setContext(this.contexts[this.contexts.length - 1]);
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup(parentPath, container, listKey, key) {
    this.inList = !!listKey;
    this.listKey = listKey;
    this.parentKey = listKey || key;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }
  function setKey(key) {
    this.key = key;
    this.node = this.container[this.key];
    this.type = this.node && this.node.type;
  }
  function requeue() {
    var pathToQueue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    if (pathToQueue.removed)
      return;
    var contexts = this.contexts;
    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref2 = _i2.value;
      }
      var context = _ref2;
      context.maybeQueue(pathToQueue);
    }
  }
  function _getQueueContexts() {
    var path = this;
    var contexts = this.contexts;
    while (!contexts.length) {
      path = path.parentPath;
      contexts = path.contexts;
    }
    return contexts;
  }
  return context$1;
}

var removal = {};

var removalHooks = {};

var hasRequiredRemovalHooks;
function requireRemovalHooks() {
  if (hasRequiredRemovalHooks)
    return removalHooks;
  hasRequiredRemovalHooks = 1;
  removalHooks.__esModule = true;
  removalHooks.hooks = [
    function (self, parent) {
      if (self.key === "body" && parent.isArrowFunctionExpression()) {
        self.replaceWith(self.scope.buildUndefinedNode());
        return true;
      }
    },
    function (self, parent) {
      var removeParent = false;
      removeParent = removeParent || self.key === "test" && (parent.isWhile() || parent.isSwitchCase());
      removeParent = removeParent || self.key === "declaration" && parent.isExportDeclaration();
      removeParent = removeParent || self.key === "body" && parent.isLabeledStatement();
      removeParent = removeParent || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1;
      removeParent = removeParent || self.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    },
    function (self, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    },
    function (self, parent) {
      if (parent.isBinary()) {
        if (self.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    },
    function (self, parent) {
      if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || parent.isLoop() && self.key === "body") {
        self.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }
  ];
  return removalHooks;
}

var hasRequiredRemoval;
function requireRemoval() {
  if (hasRequiredRemoval)
    return removal;
  hasRequiredRemoval = 1;
  removal.__esModule = true;
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  removal.remove = remove;
  removal._callRemovalHooks = _callRemovalHooks;
  removal._remove = _remove;
  removal._markRemoved = _markRemoved;
  removal._assertUnremoved = _assertUnremoved;
  var _removalHooks = requireRemovalHooks();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function remove() {
    this._assertUnremoved();
    this.resync();
    if (this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings();
    this._remove();
    this._markRemoved();
  }
  function _callRemovalHooks() {
    for (var _iterator = _removalHooks.hooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var fn = _ref;
      if (fn(this, this.parentPath))
        return true;
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }
  function _markRemoved() {
    this.shouldSkip = true;
    this.removed = true;
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
  return removal;
}

var modification = {};

var hoister = {exports: {}};

var hasRequiredHoister;
function requireHoister() {
  if (hasRequiredHoister)
    return hoister.exports;
  hasRequiredHoister = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var referenceVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && _babelTypes.react.isCompatTag(path.node.name)) {
          return;
        }
        var binding = path.scope.getBinding(path.node.name);
        if (!binding)
          return;
        if (binding !== state.scope.getBinding(path.node.name))
          return;
        if (binding.constant) {
          state.bindings[path.node.name] = binding;
        } else {
          for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
            var _ref;
            if (_isArray) {
              if (_i >= _iterator.length)
                break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done)
                break;
              _ref = _i.value;
            }
            var violationPath = _ref;
            state.breakOnScopePaths = state.breakOnScopePaths.concat(violationPath.getAncestry());
          }
        }
      }
    };
    var PathHoister = (function () {
      function PathHoister(path, scope) {
        (0, _classCallCheck3.default)(this, PathHoister);
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.scopes = [];
        this.scope = scope;
        this.path = path;
      }
      PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
        for (var key in this.bindings) {
          var binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      };
      PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
        var scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
            break;
          }
        } while (scope = scope.parent);
      };
      PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
        var path = this._getAttachmentPath();
        if (!path)
          return;
        var targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (var name in this.bindings) {
            if (!targetScope.hasOwnBinding(name))
              continue;
            var binding = this.bindings[name];
            if (binding.kind === "param")
              continue;
            if (this.getAttachmentParentForPath(binding.path).key > path.key)
              return;
          }
        }
        return path;
      };
      PathHoister.prototype._getAttachmentPath = function _getAttachmentPath() {
        var scopes = this.scopes;
        var scope = scopes.pop();
        if (!scope)
          return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope)
              return;
            return scope.path.get("body").get("body")[0];
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      };
      PathHoister.prototype.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
        var scope = this.scopes.pop();
        if (scope)
          return this.getAttachmentParentForPath(scope.path);
      };
      PathHoister.prototype.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement() || path.isVariableDeclarator() && path.parentPath.node.declarations.length > 1)
            return path;
        } while (path = path.parentPath);
      };
      PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
        for (var name in this.bindings) {
          if (!scope.hasOwnBinding(name))
            continue;
          var binding = this.bindings[name];
          if (binding.kind === "param")
            return true;
        }
        return false;
      };
      PathHoister.prototype.run = function run() {
        var node = this.path.node;
        if (node._hoisted)
          return;
        node._hoisted = true;
        this.path.traverse(referenceVisitor, this);
        this.getCompatibleScopes();
        var attachTo = this.getAttachmentPath();
        if (!attachTo)
          return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent())
          return;
        var uid = attachTo.scope.generateUidIdentifier("ref");
        var declarator = t.variableDeclarator(uid, this.path.node);
        attachTo.insertBefore([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration("var", [declarator])]);
        var parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = t.JSXExpressionContainer(uid);
        }
        this.path.replaceWith(uid);
      };
      return PathHoister;
    }());
    exports.default = PathHoister;
    module.exports = exports["default"];
  }(hoister, hoister.exports));
  return hoister.exports;
}

var hasRequiredModification;
function requireModification() {
  if (hasRequiredModification)
    return modification;
  hasRequiredModification = 1;
  modification.__esModule = true;
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  modification.insertBefore = insertBefore;
  modification._containerInsert = _containerInsert;
  modification._containerInsertBefore = _containerInsertBefore;
  modification._containerInsertAfter = _containerInsertAfter;
  modification._maybePopFromStatements = _maybePopFromStatements;
  modification.insertAfter = insertAfter;
  modification.updateSiblingKeys = updateSiblingKeys;
  modification._verifyNodeList = _verifyNodeList;
  modification.unshiftContainer = unshiftContainer;
  modification.pushContainer = pushContainer;
  modification.hoist = hoist;
  var _cache = requireCache();
  var _hoister = requireHoister();
  var _hoister2 = _interopRequireDefault(_hoister);
  var _index = requirePath();
  var _index2 = _interopRequireDefault(_index);
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function insertBefore(nodes) {
    this._assertUnremoved();
    nodes = this._verifyNodeList(nodes);
    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
      return this.parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
      if (this.node)
        nodes.push(this.node);
      this.replaceExpressionWithStatements(nodes);
    } else {
      this._maybePopFromStatements(nodes);
      if (Array.isArray(this.container)) {
        return this._containerInsertBefore(nodes);
      } else if (this.isStatementOrBlock()) {
        if (this.node)
          nodes.push(this.node);
        this._replaceWith(t.blockStatement(nodes));
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    return [this];
  }
  function _containerInsert(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);
    var paths = [];
    for (var i = 0; i < nodes.length; i++) {
      var to = from + i;
      var node = nodes[i];
      this.container.splice(to, 0, node);
      if (this.context) {
        var path = this.context.create(this.parent, this.container, to, this.listKey);
        if (this.context.queue)
          path.pushContext(this.context);
        paths.push(path);
      } else {
        paths.push(_index2.default.get({
          parentPath: this.parentPath,
          parent: this.parent,
          container: this.container,
          listKey: this.listKey,
          key: to
        }));
      }
    }
    var contexts = this._getQueueContexts();
    for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var _path = _ref;
      _path.setScope();
      _path.debug(function () {
        return "Inserted.";
      });
      for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var context = _ref2;
        context.maybeQueue(_path, true);
      }
    }
    return paths;
  }
  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }
  function _maybePopFromStatements(nodes) {
    var last = nodes[nodes.length - 1];
    var isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression);
    if (isIdentifier && !this.isCompletionRecord()) {
      nodes.pop();
    }
  }
  function insertAfter(nodes) {
    this._assertUnremoved();
    nodes = this._verifyNodeList(nodes);
    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
      return this.parentPath.insertAfter(nodes);
    } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        var temp = this.scope.generateDeclaredUidIdentifier();
        nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
        nodes.push(t.expressionStatement(temp));
      }
      this.replaceExpressionWithStatements(nodes);
    } else {
      this._maybePopFromStatements(nodes);
      if (Array.isArray(this.container)) {
        return this._containerInsertAfter(nodes);
      } else if (this.isStatementOrBlock()) {
        if (this.node)
          nodes.unshift(this.node);
        this._replaceWith(t.blockStatement(nodes));
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    return [this];
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent)
      return;
    var paths = _cache.path.get(this.parent);
    for (var i = 0; i < paths.length; i++) {
      var path = paths[i];
      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }
    if (nodes.constructor !== Array) {
      nodes = [nodes];
    }
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var msg = void 0;
      if (!node) {
        msg = "has falsy node";
      } else if ((typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node)) !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof _index2.default) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        var type = Array.isArray(node) ? "array" : typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node);
        throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
      }
    }
    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();
    nodes = this._verifyNodeList(nodes);
    var path = _index2.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    });
    return path.insertBefore(nodes);
  }
  function pushContainer(listKey, nodes) {
    this._assertUnremoved();
    nodes = this._verifyNodeList(nodes);
    var container = this.node[listKey];
    var path = _index2.default.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    });
    return path.replaceWithMultiple(nodes);
  }
  function hoist() {
    var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;
    var hoister = new _hoister2.default(this, scope);
    return hoister.run();
  }
  return modification;
}

var family = {};

var hasRequiredFamily;
function requireFamily() {
  if (hasRequiredFamily)
    return family;
  hasRequiredFamily = 1;
  family.__esModule = true;
  var _create = requireCreate();
  var _create2 = _interopRequireDefault(_create);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  family.getStatementParent = getStatementParent;
  family.getOpposite = getOpposite;
  family.getCompletionRecords = getCompletionRecords;
  family.getSibling = getSibling;
  family.get = get;
  family._getKey = _getKey;
  family._getPattern = _getPattern;
  family.getBindingIdentifiers = getBindingIdentifiers;
  family.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  family.getBindingIdentifierPaths = getBindingIdentifierPaths;
  family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  var _index = requirePath();
  var _index2 = _interopRequireDefault(_index);
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function getStatementParent() {
    var path = this;
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);
    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path;
  }
  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
  }
  function getCompletionRecords() {
    var paths = [];
    var add = function add(path) {
      if (path)
        paths = paths.concat(path.getCompletionRecords());
    };
    if (this.isIfStatement()) {
      add(this.get("consequent"));
      add(this.get("alternate"));
    } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
      add(this.get("body"));
    } else if (this.isProgram() || this.isBlockStatement()) {
      add(this.get("body").pop());
    } else if (this.isFunction()) {
      return this.get("body").getCompletionRecords();
    } else if (this.isTryStatement()) {
      add(this.get("block"));
      add(this.get("handler"));
      add(this.get("finalizer"));
    } else {
      paths.push(this);
    }
    return paths;
  }
  function getSibling(key) {
    return _index2.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    });
  }
  function get(key, context) {
    if (context === true)
      context = this.context;
    var parts = key.split(".");
    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }
  function _getKey(key, context) {
    var _this = this;
    var node = this.node;
    var container = node[key];
    if (Array.isArray(container)) {
      return container.map(function (_, i) {
        return _index2.default.get({
          listKey: key,
          parentPath: _this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return _index2.default.get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    var path = this;
    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var part = _ref;
      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }
    return path;
  }
  function getBindingIdentifiers(duplicates) {
    return t.getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers(duplicates) {
    return t.getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths() {
    var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var path = this;
    var search = [].concat(path);
    var ids = (0, _create2.default)(null);
    while (search.length) {
      var id = search.shift();
      if (!id)
        continue;
      if (!id.node)
        continue;
      var keys = t.getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          var _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        var declaration = id.get("declaration");
        if (declaration.isDeclaration()) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = id.get(key);
          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }
    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }
  return family;
}

var comments$1 = {};

var hasRequiredComments;
function requireComments() {
  if (hasRequiredComments)
    return comments$1;
  hasRequiredComments = 1;
  comments$1.__esModule = true;
  comments$1.shareCommentsWithSiblings = shareCommentsWithSiblings;
  comments$1.addComment = addComment;
  comments$1.addComments = addComments;
  function shareCommentsWithSiblings() {
    if (typeof this.key === "string")
      return;
    var node = this.node;
    if (!node)
      return;
    var trailing = node.trailingComments;
    var leading = node.leadingComments;
    if (!trailing && !leading)
      return;
    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);
    if (!prev.node)
      prev = next;
    if (!next.node)
      next = prev;
    prev.addComments("trailing", leading);
    next.addComments("leading", trailing);
  }
  function addComment(type, content, line) {
    this.addComments(type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
  }
  function addComments(type, comments) {
    if (!comments)
      return;
    var node = this.node;
    if (!node)
      return;
    var key = type + "Comments";
    if (node[key]) {
      node[key] = node[key].concat(comments);
    } else {
      node[key] = comments;
    }
  }
  return comments$1;
}

var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath)
    return path.exports;
  hasRequiredPath = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _virtualTypes = requireVirtualTypes();
    var virtualTypes = _interopRequireWildcard(_virtualTypes);
    var _debug2 = requireNode$1();
    var _debug3 = _interopRequireDefault(_debug2);
    var _invariant = requireInvariant();
    var _invariant2 = _interopRequireDefault(_invariant);
    var _index = requireLib$2();
    var _index2 = _interopRequireDefault(_index);
    var _assign = requireAssign();
    var _assign2 = _interopRequireDefault(_assign);
    var _scope = requireScope();
    var _scope2 = _interopRequireDefault(_scope);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    var _cache = requireCache();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _debug = (0, _debug3.default)("babel");
    var NodePath = (function () {
      function NodePath(hub, parent) {
        (0, _classCallCheck3.default)(this, NodePath);
        this.parent = parent;
        this.hub = hub;
        this.contexts = [];
        this.data = {};
        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
        this.state = null;
        this.opts = null;
        this.skipKeys = null;
        this.parentPath = null;
        this.context = null;
        this.container = null;
        this.listKey = null;
        this.inList = false;
        this.parentKey = null;
        this.key = null;
        this.node = null;
        this.scope = null;
        this.type = null;
        this.typeAnnotation = null;
      }
      NodePath.get = function get(_ref) {
        var hub = _ref.hub, parentPath = _ref.parentPath, parent = _ref.parent, container = _ref.container, listKey = _ref.listKey, key = _ref.key;
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        (0, _invariant2.default)(parent, "To get a node path the parent needs to exist");
        var targetNode = container[key];
        var paths = _cache.path.get(parent) || [];
        if (!_cache.path.has(parent)) {
          _cache.path.set(parent, paths);
        }
        var path = void 0;
        for (var i = 0; i < paths.length; i++) {
          var pathCheck = paths[i];
          if (pathCheck.node === targetNode) {
            path = pathCheck;
            break;
          }
        }
        if (!path) {
          path = new NodePath(hub, parent);
          paths.push(path);
        }
        path.setup(parentPath, container, listKey, key);
        return path;
      };
      NodePath.prototype.getScope = function getScope(scope) {
        var ourScope = scope;
        if (this.isScope()) {
          ourScope = new _scope2.default(this, scope);
        }
        return ourScope;
      };
      NodePath.prototype.setData = function setData(key, val) {
        return this.data[key] = val;
      };
      NodePath.prototype.getData = function getData(key, def) {
        var val = this.data[key];
        if (!val && def)
          val = this.data[key] = def;
        return val;
      };
      NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(msg) {
        var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;
        return this.hub.file.buildCodeFrameError(this.node, msg, Error);
      };
      NodePath.prototype.traverse = function traverse(visitor, state) {
        (0, _index2.default)(this.node, visitor, this.scope, state, this);
      };
      NodePath.prototype.mark = function mark(type, message) {
        this.hub.file.metadata.marked.push({
          type: type,
          message: message,
          loc: this.node.loc
        });
      };
      NodePath.prototype.set = function set(key, node) {
        t.validate(this.node, key, node);
        this.node[key] = node;
      };
      NodePath.prototype.getPathLocation = function getPathLocation() {
        var parts = [];
        var path = this;
        do {
          var key = path.key;
          if (path.inList)
            key = path.listKey + "[" + key + "]";
          parts.unshift(key);
        } while (path = path.parentPath);
        return parts.join(".");
      };
      NodePath.prototype.debug = function debug(buildMessage) {
        if (!_debug.enabled)
          return;
        _debug(this.getPathLocation() + " " + this.type + ": " + buildMessage());
      };
      return NodePath;
    }());
    exports.default = NodePath;
    (0, _assign2.default)(NodePath.prototype, requireAncestry());
    (0, _assign2.default)(NodePath.prototype, requireInference());
    (0, _assign2.default)(NodePath.prototype, requireReplacement());
    (0, _assign2.default)(NodePath.prototype, requireEvaluation());
    (0, _assign2.default)(NodePath.prototype, requireConversion());
    (0, _assign2.default)(NodePath.prototype, requireIntrospection());
    (0, _assign2.default)(NodePath.prototype, requireContext$1());
    (0, _assign2.default)(NodePath.prototype, requireRemoval());
    (0, _assign2.default)(NodePath.prototype, requireModification());
    (0, _assign2.default)(NodePath.prototype, requireFamily());
    (0, _assign2.default)(NodePath.prototype, requireComments());
    var _loop2 = function _loop2() {
      if (_isArray) {
        if (_i >= _iterator.length)
          return "break";
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          return "break";
        _ref2 = _i.value;
      }
      var type = _ref2;
      var typeKey = "is" + type;
      NodePath.prototype[typeKey] = function (opts) {
        return t[typeKey](this.node, opts);
      };
      NodePath.prototype["assert" + type] = function (opts) {
        if (!this[typeKey](opts)) {
          throw new TypeError("Expected node path of type " + type);
        }
      };
    };
    for (var _iterator = t.TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref2;
      var _ret2 = _loop2();
      if (_ret2 === "break")
        break;
    }
    var _loop = function _loop(type) {
      if (type[0] === "_")
        return "continue";
      if (t.TYPES.indexOf(type) < 0)
        t.TYPES.push(type);
      var virtualType = virtualTypes[type];
      NodePath.prototype["is" + type] = function (opts) {
        return virtualType.checkPath(this, opts);
      };
    };
    for (var type in virtualTypes) {
      var _ret = _loop(type);
      if (_ret === "continue")
        continue;
    }
    module.exports = exports["default"];
  }(path, path.exports));
  return path.exports;
}

var hub = {exports: {}};

var hasRequiredHub;
function requireHub() {
  if (hasRequiredHub)
    return hub.exports;
  hasRequiredHub = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Hub = function Hub(file, options) {
      (0, _classCallCheck3.default)(this, Hub);
      this.file = file;
      this.options = options;
    };
    exports.default = Hub;
    module.exports = exports["default"];
  }(hub, hub.exports));
  return hub.exports;
}

var context = {exports: {}};

var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext)
    return context.exports;
  hasRequiredContext = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _classCallCheck2 = requireClassCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _path2 = requirePath();
    var _path3 = _interopRequireDefault(_path2);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var testing = process.env.NODE_ENV === "test";
    var TraversalContext = (function () {
      function TraversalContext(scope, opts, state, parentPath) {
        (0, _classCallCheck3.default)(this, TraversalContext);
        this.queue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
        var opts = this.opts;
        if (opts.enter || opts.exit)
          return true;
        if (opts[node.type])
          return true;
        var keys = t.VISITOR_KEYS[node.type];
        if (!keys || !keys.length)
          return false;
        for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var key = _ref;
          if (node[key])
            return true;
        }
        return false;
      };
      TraversalContext.prototype.create = function create(node, obj, key, listKey) {
        return _path3.default.get({
          parentPath: this.parentPath,
          parent: node,
          container: obj,
          key: key,
          listKey: listKey
        });
      };
      TraversalContext.prototype.maybeQueue = function maybeQueue(path, notPriority) {
        if (this.trap) {
          throw new Error("Infinite cycle detected");
        }
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      };
      TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
        if (container.length === 0)
          return false;
        var queue = [];
        for (var key = 0; key < container.length; key++) {
          var node = container[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }
        return this.visitQueue(queue);
      };
      TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      };
      TraversalContext.prototype.visitQueue = function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        var visited = [];
        var stop = false;
        for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var path = _ref2;
          path.resync();
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            path.pushContext(this);
          }
          if (path.key === null)
            continue;
          if (testing && queue.length >= 10000) {
            this.trap = true;
          }
          if (visited.indexOf(path.node) >= 0)
            continue;
          visited.push(path.node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop)
              break;
          }
        }
        for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var _path = _ref3;
          _path.popContext();
        }
        this.queue = null;
        return stop;
      };
      TraversalContext.prototype.visit = function visit(node, key) {
        var nodes = node[key];
        if (!nodes)
          return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      };
      return TraversalContext;
    }());
    exports.default = TraversalContext;
    module.exports = exports["default"];
  }(context, context.exports));
  return context.exports;
}

var visitors = {};

var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors)
    return visitors;
  hasRequiredVisitors = 1;
  visitors.__esModule = true;
  var _typeof2 = require_typeof();
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _keys = requireKeys$1();
  var _keys2 = _interopRequireDefault(_keys);
  var _getIterator2 = requireGetIterator();
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  visitors.explode = explode;
  visitors.verify = verify;
  visitors.merge = merge;
  var _virtualTypes = requireVirtualTypes();
  var virtualTypes = _interopRequireWildcard(_virtualTypes);
  var _babelMessages = requireLib$5();
  var messages = _interopRequireWildcard(_babelMessages);
  var _babelTypes = requireLib$7();
  var t = _interopRequireWildcard(_babelTypes);
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function explode(visitor) {
    if (visitor._exploded)
      return visitor;
    visitor._exploded = true;
    for (var nodeType in visitor) {
      if (shouldIgnoreKey(nodeType))
        continue;
      var parts = nodeType.split("|");
      if (parts.length === 1)
        continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];
      for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var part = _ref;
        visitor[part] = fns;
      }
    }
    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (var _iterator2 = (0, _keys2.default)(visitor), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref2 = _i2.value;
      }
      var _nodeType3 = _ref2;
      if (shouldIgnoreKey(_nodeType3))
        continue;
      var wrapper = virtualTypes[_nodeType3];
      if (!wrapper)
        continue;
      var _fns2 = visitor[_nodeType3];
      for (var type in _fns2) {
        _fns2[type] = wrapCheck(wrapper, _fns2[type]);
      }
      delete visitor[_nodeType3];
      if (wrapper.types) {
        for (var _iterator4 = wrapper.types, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
          var _ref4;
          if (_isArray4) {
            if (_i4 >= _iterator4.length)
              break;
            _ref4 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done)
              break;
            _ref4 = _i4.value;
          }
          var _type = _ref4;
          if (visitor[_type]) {
            mergePair(visitor[_type], _fns2);
          } else {
            visitor[_type] = _fns2;
          }
        }
      } else {
        mergePair(visitor, _fns2);
      }
    }
    for (var _nodeType in visitor) {
      if (shouldIgnoreKey(_nodeType))
        continue;
      var _fns = visitor[_nodeType];
      var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType];
      var deprecratedKey = t.DEPRECATED_KEYS[_nodeType];
      if (deprecratedKey) {
        console.trace("Visitor defined for " + _nodeType + " but it has been renamed to " + deprecratedKey);
        aliases = [deprecratedKey];
      }
      if (!aliases)
        continue;
      delete visitor[_nodeType];
      for (var _iterator3 = aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var alias = _ref3;
        var existing = visitor[alias];
        if (existing) {
          mergePair(existing, _fns);
        } else {
          visitor[alias] = (0, _clone2.default)(_fns);
        }
      }
    }
    for (var _nodeType2 in visitor) {
      if (shouldIgnoreKey(_nodeType2))
        continue;
      ensureCallbackArrays(visitor[_nodeType2]);
    }
    return visitor;
  }
  function verify(visitor) {
    if (visitor._verified)
      return;
    if (typeof visitor === "function") {
      throw new Error(messages.get("traverseVerifyRootFunction"));
    }
    for (var nodeType in visitor) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType))
        continue;
      if (t.TYPES.indexOf(nodeType) < 0) {
        throw new Error(messages.get("traverseVerifyNodeType", nodeType));
      }
      var visitors = visitor[nodeType];
      if ((typeof visitors === "undefined" ? "undefined" : (0, _typeof3.default)(visitors)) === "object") {
        for (var visitorKey in visitors) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
          } else {
            throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);
    for (var _iterator5 = fns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
      var _ref5;
      if (_isArray5) {
        if (_i5 >= _iterator5.length)
          break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done)
          break;
        _ref5 = _i5.value;
      }
      var fn = _ref5;
      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in " + path + " with type " + (typeof fn === "undefined" ? "undefined" : (0, _typeof3.default)(fn)));
      }
    }
  }
  function merge(visitors) {
    var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var wrapper = arguments[2];
    var rootVisitor = {};
    for (var i = 0; i < visitors.length; i++) {
      var visitor = visitors[i];
      var state = states[i];
      explode(visitor);
      for (var type in visitor) {
        var visitorType = visitor[type];
        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }
        var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
        mergePair(nodeVisitor, visitorType);
      }
    }
    return rootVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};
    var _loop = function _loop(key) {
      var fns = oldVisitor[key];
      if (!Array.isArray(fns))
        return "continue";
      fns = fns.map(function (fn) {
        var newFn = fn;
        if (state) {
          newFn = function newFn(path) {
            return fn.call(state, path, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }
        return newFn;
      });
      newVisitor[key] = fns;
    };
    for (var key in oldVisitor) {
      var _ret = _loop(key);
      if (_ret === "continue")
        continue;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (var key in obj) {
      if (shouldIgnoreKey(key))
        continue;
      var fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = { enter: fns };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter))
      obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit))
      obj.exit = [obj.exit];
  }
  function wrapCheck(wrapper, fn) {
    var newFn = function newFn(path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = function () {
      return fn.toString();
    };
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_")
      return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip")
      return true;
    if (key === "blacklist" || key === "noScope" || key === "skipKeys")
      return true;
    return false;
  }
  function mergePair(dest, src) {
    for (var key in src) {
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }
  return visitors;
}

var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2)
    return lib$3;
  hasRequiredLib$2 = 1;
  (function (exports) {
    exports.__esModule = true;
    exports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined;
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _path = requirePath();
    Object.defineProperty(exports, "NodePath", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_path).default;
      }
    });
    var _scope = requireScope();
    Object.defineProperty(exports, "Scope", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_scope).default;
      }
    });
    var _hub = requireHub();
    Object.defineProperty(exports, "Hub", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_hub).default;
      }
    });
    exports.default = traverse;
    var _context = requireContext();
    var _context2 = _interopRequireDefault(_context);
    var _visitors = requireVisitors();
    var visitors = _interopRequireWildcard(_visitors);
    var _babelMessages = requireLib$5();
    var messages = _interopRequireWildcard(_babelMessages);
    var _includes = requireIncludes();
    var _includes2 = _interopRequireDefault(_includes);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    var _cache = requireCache();
    var cache = _interopRequireWildcard(_cache);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.visitors = visitors;
    function traverse(parent, opts, scope, state, parentPath) {
      if (!parent)
        return;
      if (!opts)
        opts = {};
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(messages.get("traverseNeedsParent", parent.type));
        }
      }
      visitors.explode(opts);
      traverse.node(parent, opts, scope, state, parentPath);
    }
    traverse.visitors = visitors;
    traverse.verify = visitors.verify;
    traverse.explode = visitors.explode;
    traverse.NodePath = requirePath();
    traverse.Scope = requireScope();
    traverse.Hub = requireHub();
    traverse.cheap = function (node, enter) {
      return t.traverseFast(node, enter);
    };
    traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
      var keys = t.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      var context = new _context2.default(scope, opts, state, parentPath);
      for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var key = _ref;
        if (skipKeys && skipKeys[key])
          continue;
        if (context.visit(node, key))
          return;
      }
    };
    traverse.clearNode = function (node, opts) {
      t.removeProperties(node, opts);
      cache.path.delete(node);
    };
    traverse.removeProperties = function (tree, opts) {
      t.traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };
    function hasBlacklistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }
    traverse.hasType = function (tree, scope, type, blacklistTypes) {
      if ((0, _includes2.default)(blacklistTypes, tree.type))
        return false;
      if (tree.type === type)
        return true;
      var state = {
        has: false,
        type: type
      };
      traverse(tree, {
        blacklist: blacklistTypes,
        enter: hasBlacklistedType
      }, scope, state);
      return state.has;
    };
    traverse.clearCache = function () {
      cache.clear();
    };
    traverse.clearCache.clearPath = cache.clearPath;
    traverse.clearCache.clearScope = cache.clearScope;
    traverse.copyCache = function (source, destination) {
      if (cache.path.has(source)) {
        cache.path.set(destination, cache.path.get(source));
      }
    };
  }(lib$3));
  return lib$3;
}

var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1)
    return lib$4.exports;
  hasRequiredLib$1 = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _symbol = requireSymbol();
    var _symbol2 = _interopRequireDefault(_symbol);
    exports.default = function (code, opts) {
      var stack = void 0;
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          stack = error.stack.split("\n").slice(1).join("\n");
        }
      }
      opts = (0, _assign2.default)({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        preserveComments: false
      }, opts);
      var _getAst = function getAst() {
        var ast = void 0;
        try {
          ast = babylon.parse(code, opts);
          ast = _babelTraverse2.default.removeProperties(ast, { preserveComments: opts.preserveComments });
          _babelTraverse2.default.cheap(ast, function (node) {
            node[FROM_TEMPLATE] = true;
          });
        } catch (err) {
          err.stack = err.stack + "from\n" + stack;
          throw err;
        }
        _getAst = function getAst() {
          return ast;
        };
        return ast;
      };
      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return useTemplate(_getAst(), args);
      };
    };
    var _cloneDeep = requireCloneDeep();
    var _cloneDeep2 = _interopRequireDefault(_cloneDeep);
    var _assign = requireAssign();
    var _assign2 = _interopRequireDefault(_assign);
    var _has = requireHas();
    var _has2 = _interopRequireDefault(_has);
    var _babelTraverse = requireLib$2();
    var _babelTraverse2 = _interopRequireDefault(_babelTraverse);
    var _babylon = requireLib$3();
    var babylon = _interopRequireWildcard(_babylon);
    var _babelTypes = requireLib$7();
    var t = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FROM_TEMPLATE = "_fromTemplate";
    var TEMPLATE_SKIP = (0, _symbol2.default)();
    function useTemplate(ast, nodes) {
      ast = (0, _cloneDeep2.default)(ast);
      var _ast = ast;
      var program = _ast.program;
      if (nodes.length) {
        (0, _babelTraverse2.default)(ast, templateVisitor, null, nodes);
      }
      if (program.body.length > 1) {
        return program.body;
      } else {
        return program.body[0];
      }
    }
    var templateVisitor = {
      noScope: true,
      enter: function enter(path, args) {
        var node = path.node;
        if (node[TEMPLATE_SKIP])
          return path.skip();
        if (t.isExpressionStatement(node)) {
          node = node.expression;
        }
        var replacement = void 0;
        if (t.isIdentifier(node) && node[FROM_TEMPLATE]) {
          if ((0, _has2.default)(args[0], node.name)) {
            replacement = args[0][node.name];
          } else if (node.name[0] === "$") {
            var i = +node.name.slice(1);
            if (args[i])
              replacement = args[i];
          }
        }
        if (replacement === null) {
          path.remove();
        }
        if (replacement) {
          replacement[TEMPLATE_SKIP] = true;
          path.replaceInline(replacement);
        }
      },
      exit: function exit(_ref) {
        var node = _ref.node;
        if (!node.loc)
          _babelTraverse2.default.clearNode(node);
      }
    };
    module.exports = exports["default"];
  }(lib$4, lib$4.exports));
  return lib$4.exports;
}

var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib$7.exports;
  hasRequiredLib = 1;
  (function (module, exports) {
    exports.__esModule = true;
    var _create = requireCreate();
    var _create2 = _interopRequireDefault(_create);
    var _getIterator2 = requireGetIterator();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _symbol = requireSymbol();
    var _symbol2 = _interopRequireDefault(_symbol);
    exports.default = function (_ref) {
      var t = _ref.types;
      var IGNORE_REASSIGNMENT_SYMBOL = (0, _symbol2.default)();
      var reassignmentVisitor = {
        "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
          if (path.node[IGNORE_REASSIGNMENT_SYMBOL])
            return;
          path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
          var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");
          if (!arg.isIdentifier())
            return;
          var name = arg.node.name;
          if (this.scope.getBinding(name) !== path.scope.getBinding(name))
            return;
          var exportedNames = this.exports[name];
          if (!exportedNames)
            return;
          var node = path.node;
          var isPostUpdateExpression = path.isUpdateExpression() && !node.prefix;
          if (isPostUpdateExpression) {
            if (node.operator === "++")
              node = t.binaryExpression("+", node.argument, t.numericLiteral(1));
            else if (node.operator === "--")
              node = t.binaryExpression("-", node.argument, t.numericLiteral(1));
            else
              isPostUpdateExpression = false;
          }
          for (var _iterator = exportedNames, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
            var _ref2;
            if (_isArray) {
              if (_i >= _iterator.length)
                break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done)
                break;
              _ref2 = _i.value;
            }
            var exportedName = _ref2;
            node = this.buildCall(exportedName, node).expression;
          }
          if (isPostUpdateExpression)
            node = t.sequenceExpression([
              node,
              path.node
            ]);
          path.replaceWith(node);
        }
      };
      return {
        visitor: {
          CallExpression: function CallExpression(path, state) {
            if (path.node.callee.type === TYPE_IMPORT) {
              var contextIdent = state.contextIdent;
              path.replaceWith(t.callExpression(t.memberExpression(contextIdent, t.identifier("import")), path.node.arguments));
            }
          },
          ReferencedIdentifier: function ReferencedIdentifier(path, state) {
            if (path.node.name == "__moduleName" && !path.scope.hasBinding("__moduleName")) {
              path.replaceWith(t.memberExpression(state.contextIdent, t.identifier("id")));
            }
          },
          Program: {
            enter: function enter(path, state) {
              state.contextIdent = path.scope.generateUidIdentifier("context");
            },
            exit: function exit(path, state) {
              var exportIdent = path.scope.generateUidIdentifier("export");
              var contextIdent = state.contextIdent;
              var exportNames = (0, _create2.default)(null);
              var modules = [];
              var beforeBody = [];
              var setters = [];
              var sources = [];
              var variableIds = [];
              var removedPaths = [];
              function addExportName(key, val) {
                exportNames[key] = exportNames[key] || [];
                exportNames[key].push(val);
              }
              function pushModule(source, key, specifiers) {
                var module = void 0;
                modules.forEach(function (m) {
                  if (m.key === source) {
                    module = m;
                  }
                });
                if (!module) {
                  modules.push(module = {
                    key: source,
                    imports: [],
                    exports: []
                  });
                }
                module[key] = module[key].concat(specifiers);
              }
              function buildExportCall(name, val) {
                return t.expressionStatement(t.callExpression(exportIdent, [
                  t.stringLiteral(name),
                  val
                ]));
              }
              var body = path.get("body");
              var canHoist = true;
              for (var _iterator2 = body, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
                var _ref3;
                if (_isArray2) {
                  if (_i2 >= _iterator2.length)
                    break;
                  _ref3 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done)
                    break;
                  _ref3 = _i2.value;
                }
                var _path = _ref3;
                if (_path.isExportDeclaration())
                  _path = _path.get("declaration");
                if (_path.isVariableDeclaration() && _path.node.kind !== "var") {
                  canHoist = false;
                  break;
                }
              }
              for (var _iterator3 = body, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
                var _ref4;
                if (_isArray3) {
                  if (_i3 >= _iterator3.length)
                    break;
                  _ref4 = _iterator3[_i3++];
                } else {
                  _i3 = _iterator3.next();
                  if (_i3.done)
                    break;
                  _ref4 = _i3.value;
                }
                var _path2 = _ref4;
                if (canHoist && _path2.isFunctionDeclaration()) {
                  beforeBody.push(_path2.node);
                  removedPaths.push(_path2);
                } else if (_path2.isImportDeclaration()) {
                  var source = _path2.node.source.value;
                  pushModule(source, "imports", _path2.node.specifiers);
                  for (var name in _path2.getBindingIdentifiers()) {
                    _path2.scope.removeBinding(name);
                    variableIds.push(t.identifier(name));
                  }
                  _path2.remove();
                } else if (_path2.isExportAllDeclaration()) {
                  pushModule(_path2.node.source.value, "exports", _path2.node);
                  _path2.remove();
                } else if (_path2.isExportDefaultDeclaration()) {
                  var declar = _path2.get("declaration");
                  if (declar.isClassDeclaration() || declar.isFunctionDeclaration()) {
                    var id = declar.node.id;
                    var nodes = [];
                    if (id) {
                      nodes.push(declar.node);
                      nodes.push(buildExportCall("default", id));
                      addExportName(id.name, "default");
                    } else {
                      nodes.push(buildExportCall("default", t.toExpression(declar.node)));
                    }
                    if (!canHoist || declar.isClassDeclaration()) {
                      _path2.replaceWithMultiple(nodes);
                    } else {
                      beforeBody = beforeBody.concat(nodes);
                      removedPaths.push(_path2);
                    }
                  } else {
                    _path2.replaceWith(buildExportCall("default", declar.node));
                  }
                } else if (_path2.isExportNamedDeclaration()) {
                  var _declar = _path2.get("declaration");
                  if (_declar.node) {
                    _path2.replaceWith(_declar);
                    var _nodes = [];
                    var bindingIdentifiers = void 0;
                    if (_path2.isFunction()) {
                      var node = _declar.node;
                      var _name = node.id.name;
                      if (canHoist) {
                        addExportName(_name, _name);
                        beforeBody.push(node);
                        beforeBody.push(buildExportCall(_name, node.id));
                        removedPaths.push(_path2);
                      } else {
                        var _bindingIdentifiers;
                        bindingIdentifiers = (_bindingIdentifiers = {}, _bindingIdentifiers[_name] = node.id, _bindingIdentifiers);
                      }
                    } else {
                      bindingIdentifiers = _declar.getBindingIdentifiers();
                    }
                    for (var _name2 in bindingIdentifiers) {
                      addExportName(_name2, _name2);
                      _nodes.push(buildExportCall(_name2, t.identifier(_name2)));
                    }
                    _path2.insertAfter(_nodes);
                  } else {
                    var specifiers = _path2.node.specifiers;
                    if (specifiers && specifiers.length) {
                      if (_path2.node.source) {
                        pushModule(_path2.node.source.value, "exports", specifiers);
                        _path2.remove();
                      } else {
                        var _nodes2 = [];
                        for (var _iterator7 = specifiers, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
                          var _ref8;
                          if (_isArray7) {
                            if (_i7 >= _iterator7.length)
                              break;
                            _ref8 = _iterator7[_i7++];
                          } else {
                            _i7 = _iterator7.next();
                            if (_i7.done)
                              break;
                            _ref8 = _i7.value;
                          }
                          var specifier = _ref8;
                          _nodes2.push(buildExportCall(specifier.exported.name, specifier.local));
                          addExportName(specifier.local.name, specifier.exported.name);
                        }
                        _path2.replaceWithMultiple(_nodes2);
                      }
                    }
                  }
                }
              }
              modules.forEach(function (specifiers) {
                var setterBody = [];
                var target = path.scope.generateUidIdentifier(specifiers.key);
                for (var _iterator4 = specifiers.imports, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
                  var _ref5;
                  if (_isArray4) {
                    if (_i4 >= _iterator4.length)
                      break;
                    _ref5 = _iterator4[_i4++];
                  } else {
                    _i4 = _iterator4.next();
                    if (_i4.done)
                      break;
                    _ref5 = _i4.value;
                  }
                  var specifier = _ref5;
                  if (t.isImportNamespaceSpecifier(specifier)) {
                    setterBody.push(t.expressionStatement(t.assignmentExpression("=", specifier.local, target)));
                  } else if (t.isImportDefaultSpecifier(specifier)) {
                    specifier = t.importSpecifier(specifier.local, t.identifier("default"));
                  }
                  if (t.isImportSpecifier(specifier)) {
                    setterBody.push(t.expressionStatement(t.assignmentExpression("=", specifier.local, t.memberExpression(target, specifier.imported))));
                  }
                }
                if (specifiers.exports.length) {
                  var exportObjRef = path.scope.generateUidIdentifier("exportObj");
                  setterBody.push(t.variableDeclaration("var", [t.variableDeclarator(exportObjRef, t.objectExpression([]))]));
                  for (var _iterator5 = specifiers.exports, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
                    var _ref6;
                    if (_isArray5) {
                      if (_i5 >= _iterator5.length)
                        break;
                      _ref6 = _iterator5[_i5++];
                    } else {
                      _i5 = _iterator5.next();
                      if (_i5.done)
                        break;
                      _ref6 = _i5.value;
                    }
                    var node = _ref6;
                    if (t.isExportAllDeclaration(node)) {
                      setterBody.push(buildExportAll({
                        KEY: path.scope.generateUidIdentifier("key"),
                        EXPORT_OBJ: exportObjRef,
                        TARGET: target
                      }));
                    } else if (t.isExportSpecifier(node)) {
                      setterBody.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(exportObjRef, node.exported), t.memberExpression(target, node.local))));
                    } else ;
                  }
                  setterBody.push(t.expressionStatement(t.callExpression(exportIdent, [exportObjRef])));
                }
                sources.push(t.stringLiteral(specifiers.key));
                setters.push(t.functionExpression(null, [target], t.blockStatement(setterBody)));
              });
              var moduleName = this.getModuleName();
              if (moduleName)
                moduleName = t.stringLiteral(moduleName);
              if (canHoist) {
                (0, _babelHelperHoistVariables2.default)(path, function (id) {
                  return variableIds.push(id);
                });
              }
              if (variableIds.length) {
                beforeBody.unshift(t.variableDeclaration("var", variableIds.map(function (id) {
                  return t.variableDeclarator(id);
                })));
              }
              path.traverse(reassignmentVisitor, {
                exports: exportNames,
                buildCall: buildExportCall,
                scope: path.scope
              });
              for (var _iterator6 = removedPaths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
                var _ref7;
                if (_isArray6) {
                  if (_i6 >= _iterator6.length)
                    break;
                  _ref7 = _iterator6[_i6++];
                } else {
                  _i6 = _iterator6.next();
                  if (_i6.done)
                    break;
                  _ref7 = _i6.value;
                }
                var _path3 = _ref7;
                _path3.remove();
              }
              path.node.body = [buildTemplate({
                  SYSTEM_REGISTER: t.memberExpression(t.identifier(state.opts.systemGlobal || "System"), t.identifier("register")),
                  BEFORE_BODY: beforeBody,
                  MODULE_NAME: moduleName,
                  SETTERS: setters,
                  SOURCES: sources,
                  BODY: path.node.body,
                  EXPORT_IDENTIFIER: exportIdent,
                  CONTEXT_IDENTIFIER: contextIdent
                })];
            }
          }
        }
      };
    };
    var _babelHelperHoistVariables = requireLib$6();
    var _babelHelperHoistVariables2 = _interopRequireDefault(_babelHelperHoistVariables);
    var _babelTemplate = requireLib$1();
    var _babelTemplate2 = _interopRequireDefault(_babelTemplate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var buildTemplate = (0, _babelTemplate2.default)("\n  SYSTEM_REGISTER(MODULE_NAME, [SOURCES], function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: [SETTERS],\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n");
    var buildExportAll = (0, _babelTemplate2.default)("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
    var TYPE_IMPORT = "Import";
    module.exports = exports["default"];
  }(lib$7, lib$7.exports));
  return lib$7.exports;
}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
		"/lively.next-node_modules/babel-plugin-transform-es2015-modules-systemjs/6.19.0/lib/index.js": requireLib
	});
}

function createCommonjsRequire(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	};
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}

typeof createCommonjsRequire("/lively.lang") !== "undefined" && typeof process !== "undefined";

typeof process !== "undefined" && process.env && typeof process.exit === "function";
function chain(object) {
  if (!object)
    return object;
  if (Array.isArray(object))
    return createChain(arr, object);
  if (object.constructor.name === "Date")
    return createChain(date, object);
  switch (typeof object) {
  case "string":
    return createChain(string, object);
  case "object":
    return createChain(obj, object);
  case "function":
    return createChain(fun, object);
  case "number":
    return createChain(num, object);
  }
  throw new Error("Chain for object " + object + " (" + object.constructor.name + ") no supported");
}
function createChain(interfaceObj, obj) {
  return Object.keys(interfaceObj).reduce(function (chained, methodName) {
    chained[methodName] = function () {
      const args = Array.from(arguments);
      const result = interfaceObj[methodName].apply(null, [obj].concat(args));
      return chain(result);
    };
    return chained;
  }, {
    value: function () {
      return obj;
    }
  });
}

class Visitor {
  accept(node, state, path) {
    if (!node)
      throw new Error("Undefined AST node in Visitor.accept:\n  " + path.join(".") + "\n  " + node);
    if (!node.type)
      throw new Error("Strangee AST node without type in Visitor.accept:\n  " + path.join(".") + "\n  " + JSON.stringify(node));
    switch (node.type) {
    case "Node":
      return this.visitNode(node, state, path);
    case "SourceLocation":
      return this.visitSourceLocation(node, state, path);
    case "Position":
      return this.visitPosition(node, state, path);
    case "Program":
      return this.visitProgram(node, state, path);
    case "Function":
      return this.visitFunction(node, state, path);
    case "Statement":
      return this.visitStatement(node, state, path);
    case "SwitchCase":
      return this.visitSwitchCase(node, state, path);
    case "CatchClause":
      return this.visitCatchClause(node, state, path);
    case "VariableDeclarator":
      return this.visitVariableDeclarator(node, state, path);
    case "Expression":
      return this.visitExpression(node, state, path);
    case "Property":
      return this.visitProperty(node, state, path);
    case "Pattern":
      return this.visitPattern(node, state, path);
    case "Super":
      return this.visitSuper(node, state, path);
    case "SpreadElement":
      return this.visitSpreadElement(node, state, path);
    case "TemplateElement":
      return this.visitTemplateElement(node, state, path);
    case "Class":
      return this.visitClass(node, state, path);
    case "ClassBody":
      return this.visitClassBody(node, state, path);
    case "MethodDefinition":
      return this.visitMethodDefinition(node, state, path);
    case "ModuleDeclaration":
      return this.visitModuleDeclaration(node, state, path);
    case "ModuleSpecifier":
      return this.visitModuleSpecifier(node, state, path);
    case "JSXEmptyExpression":
      return this.visitJSXEmptyExpression(node, state, path);
    case "JSXExpressionContainer":
      return this.visitJSXExpressionContainer(node, state, path);
    case "JSXSpreadChild":
      return this.visitJSXSpreadChild(node, state, path);
    case "JSXBoundaryElement":
      return this.visitJSXBoundaryElement(node, state, path);
    case "JSXAttribute":
      return this.visitJSXAttribute(node, state, path);
    case "JSXText":
      return this.visitJSXText(node, state, path);
    case "JSXOpeningFragment":
      return this.visitJSXOpeningFragment(node, state, path);
    case "JSXClosingFragment":
      return this.visitJSXClosingFragment(node, state, path);
    case "ChainElement":
      return this.visitChainElement(node, state, path);
    case "PropertyDefinition":
      return this.visitPropertyDefinition(node, state, path);
    case "PrivateIdentifier":
      return this.visitPrivateIdentifier(node, state, path);
    case "Decorator":
      return this.visitDecorator(node, state, path);
    case "AccessorProperty":
      return this.visitAccessorProperty(node, state, path);
    case "Identifier":
      return this.visitIdentifier(node, state, path);
    case "Literal":
      return this.visitLiteral(node, state, path);
    case "ExpressionStatement":
      return this.visitExpressionStatement(node, state, path);
    case "BlockStatement":
      return this.visitBlockStatement(node, state, path);
    case "EmptyStatement":
      return this.visitEmptyStatement(node, state, path);
    case "DebuggerStatement":
      return this.visitDebuggerStatement(node, state, path);
    case "WithStatement":
      return this.visitWithStatement(node, state, path);
    case "ReturnStatement":
      return this.visitReturnStatement(node, state, path);
    case "LabeledStatement":
      return this.visitLabeledStatement(node, state, path);
    case "BreakStatement":
      return this.visitBreakStatement(node, state, path);
    case "ContinueStatement":
      return this.visitContinueStatement(node, state, path);
    case "IfStatement":
      return this.visitIfStatement(node, state, path);
    case "SwitchStatement":
      return this.visitSwitchStatement(node, state, path);
    case "ThrowStatement":
      return this.visitThrowStatement(node, state, path);
    case "TryStatement":
      return this.visitTryStatement(node, state, path);
    case "WhileStatement":
      return this.visitWhileStatement(node, state, path);
    case "DoWhileStatement":
      return this.visitDoWhileStatement(node, state, path);
    case "ForStatement":
      return this.visitForStatement(node, state, path);
    case "ForInStatement":
      return this.visitForInStatement(node, state, path);
    case "Declaration":
      return this.visitDeclaration(node, state, path);
    case "ThisExpression":
      return this.visitThisExpression(node, state, path);
    case "ArrayExpression":
      return this.visitArrayExpression(node, state, path);
    case "ObjectExpression":
      return this.visitObjectExpression(node, state, path);
    case "FunctionExpression":
      return this.visitFunctionExpression(node, state, path);
    case "UnaryExpression":
      return this.visitUnaryExpression(node, state, path);
    case "UpdateExpression":
      return this.visitUpdateExpression(node, state, path);
    case "BinaryExpression":
      return this.visitBinaryExpression(node, state, path);
    case "AssignmentExpression":
      return this.visitAssignmentExpression(node, state, path);
    case "LogicalExpression":
      return this.visitLogicalExpression(node, state, path);
    case "MemberExpression":
      return this.visitMemberExpression(node, state, path);
    case "ConditionalExpression":
      return this.visitConditionalExpression(node, state, path);
    case "CallExpression":
      return this.visitCallExpression(node, state, path);
    case "NewExpression":
      return this.visitNewExpression(node, state, path);
    case "SequenceExpression":
      return this.visitSequenceExpression(node, state, path);
    case "ArrowFunctionExpression":
      return this.visitArrowFunctionExpression(node, state, path);
    case "YieldExpression":
      return this.visitYieldExpression(node, state, path);
    case "TemplateLiteral":
      return this.visitTemplateLiteral(node, state, path);
    case "TaggedTemplateExpression":
      return this.visitTaggedTemplateExpression(node, state, path);
    case "AssignmentProperty":
      return this.visitAssignmentProperty(node, state, path);
    case "ObjectPattern":
      return this.visitObjectPattern(node, state, path);
    case "ArrayPattern":
      return this.visitArrayPattern(node, state, path);
    case "RestElement":
      return this.visitRestElement(node, state, path);
    case "AssignmentPattern":
      return this.visitAssignmentPattern(node, state, path);
    case "ClassExpression":
      return this.visitClassExpression(node, state, path);
    case "MetaProperty":
      return this.visitMetaProperty(node, state, path);
    case "ImportDeclaration":
      return this.visitImportDeclaration(node, state, path);
    case "ImportSpecifier":
      return this.visitImportSpecifier(node, state, path);
    case "ImportDefaultSpecifier":
      return this.visitImportDefaultSpecifier(node, state, path);
    case "ImportNamespaceSpecifier":
      return this.visitImportNamespaceSpecifier(node, state, path);
    case "ExportNamedDeclaration":
      return this.visitExportNamedDeclaration(node, state, path);
    case "ExportSpecifier":
      return this.visitExportSpecifier(node, state, path);
    case "AnonymousDefaultExportedFunctionDeclaration":
      return this.visitAnonymousDefaultExportedFunctionDeclaration(node, state, path);
    case "AnonymousDefaultExportedClassDeclaration":
      return this.visitAnonymousDefaultExportedClassDeclaration(node, state, path);
    case "ExportDefaultDeclaration":
      return this.visitExportDefaultDeclaration(node, state, path);
    case "ExportAllDeclaration":
      return this.visitExportAllDeclaration(node, state, path);
    case "AwaitExpression":
      return this.visitAwaitExpression(node, state, path);
    case "JSXMemberExpression":
      return this.visitJSXMemberExpression(node, state, path);
    case "JSXNamespacedName":
      return this.visitJSXNamespacedName(node, state, path);
    case "JSXOpeningElement":
      return this.visitJSXOpeningElement(node, state, path);
    case "JSXClosingElement":
      return this.visitJSXClosingElement(node, state, path);
    case "JSXSpreadAttribute":
      return this.visitJSXSpreadAttribute(node, state, path);
    case "JSXElement":
      return this.visitJSXElement(node, state, path);
    case "JSXFragment":
      return this.visitJSXFragment(node, state, path);
    case "ChainExpression":
      return this.visitChainExpression(node, state, path);
    case "ImportExpression":
      return this.visitImportExpression(node, state, path);
    case "RegExpLiteral":
      return this.visitRegExpLiteral(node, state, path);
    case "Directive":
      return this.visitDirective(node, state, path);
    case "FunctionBody":
      return this.visitFunctionBody(node, state, path);
    case "FunctionDeclaration":
      return this.visitFunctionDeclaration(node, state, path);
    case "VariableDeclaration":
      return this.visitVariableDeclaration(node, state, path);
    case "ForOfStatement":
      return this.visitForOfStatement(node, state, path);
    case "ClassDeclaration":
      return this.visitClassDeclaration(node, state, path);
    case "JSXIdentifier":
      return this.visitJSXIdentifier(node, state, path);
    case "BigIntLiteral":
      return this.visitBigIntLiteral(node, state, path);
    case "StaticBlock":
      return this.visitStaticBlock(node, state, path);
    }
    throw new Error("No visit function in AST visitor Visitor for:\n  " + path.join(".") + "\n  " + JSON.stringify(node));
  }
  visitNode(node, state, path) {
    return node;
  }
  visitSourceLocation(node, state, path) {
    const visitor = this;
    node.start = visitor.accept(node.start, state, path.concat(["start"]));
    node.end = visitor.accept(node.end, state, path.concat(["end"]));
    return node;
  }
  visitPosition(node, state, path) {
    return node;
  }
  visitProgram(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.body.length; i++) {
      const ea = node.body[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "body",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.body = newElements;
    return node;
  }
  visitFunction(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    const newElements = [];
    for (let i = 0; i < node.params.length; i++) {
      const ea = node.params[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "params",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.params = newElements;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitStatement(node, state, path) {
    return node;
  }
  visitSwitchCase(node, state, path) {
    const visitor = this;
    if (node.test) {
      node.test = visitor.accept(node.test, state, path.concat(["test"]));
    }
    const newElements = [];
    for (let i = 0; i < node.consequent.length; i++) {
      const ea = node.consequent[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "consequent",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.consequent = newElements;
    return node;
  }
  visitCatchClause(node, state, path) {
    const visitor = this;
    if (node.param) {
      node.param = visitor.accept(node.param, state, path.concat(["param"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitVariableDeclarator(node, state, path) {
    const visitor = this;
    node.id = visitor.accept(node.id, state, path.concat(["id"]));
    if (node.init) {
      node.init = visitor.accept(node.init, state, path.concat(["init"]));
    }
    return node;
  }
  visitExpression(node, state, path) {
    return node;
  }
  visitProperty(node, state, path) {
    const visitor = this;
    node.key = visitor.accept(node.key, state, path.concat(["key"]));
    node.value = visitor.accept(node.value, state, path.concat(["value"]));
    return node;
  }
  visitPattern(node, state, path) {
    return node;
  }
  visitSuper(node, state, path) {
    return node;
  }
  visitSpreadElement(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitTemplateElement(node, state, path) {
    return node;
  }
  visitClass(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitClassBody(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.body.length; i++) {
      const ea = node.body[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "body",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.body = newElements;
    return node;
  }
  visitMethodDefinition(node, state, path) {
    const visitor = this;
    node.key = visitor.accept(node.key, state, path.concat(["key"]));
    node.value = visitor.accept(node.value, state, path.concat(["value"]));
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitModuleDeclaration(node, state, path) {
    return node;
  }
  visitModuleSpecifier(node, state, path) {
    const visitor = this;
    node.local = visitor.accept(node.local, state, path.concat(["local"]));
    return node;
  }
  visitJSXEmptyExpression(node, state, path) {
    return node;
  }
  visitJSXExpressionContainer(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitJSXSpreadChild(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitJSXBoundaryElement(node, state, path) {
    const visitor = this;
    node.name = visitor.accept(node.name, state, path.concat(["name"]));
    return node;
  }
  visitJSXAttribute(node, state, path) {
    const visitor = this;
    node.name = visitor.accept(node.name, state, path.concat(["name"]));
    if (node.value) {
      node.value = visitor.accept(node.value, state, path.concat(["value"]));
    }
    return node;
  }
  visitJSXText(node, state, path) {
    return node;
  }
  visitJSXOpeningFragment(node, state, path) {
    return node;
  }
  visitJSXClosingFragment(node, state, path) {
    return node;
  }
  visitChainElement(node, state, path) {
    return node;
  }
  visitPropertyDefinition(node, state, path) {
    const visitor = this;
    node.key = visitor.accept(node.key, state, path.concat(["key"]));
    if (node.value) {
      node.value = visitor.accept(node.value, state, path.concat(["value"]));
    }
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitPrivateIdentifier(node, state, path) {
    return node;
  }
  visitDecorator(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitAccessorProperty(node, state, path) {
    const visitor = this;
    node.key = visitor.accept(node.key, state, path.concat(["key"]));
    if (node.value) {
      node.value = visitor.accept(node.value, state, path.concat(["value"]));
    }
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitIdentifier(node, state, path) {
    return node;
  }
  visitLiteral(node, state, path) {
    return node;
  }
  visitExpressionStatement(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitBlockStatement(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.body.length; i++) {
      const ea = node.body[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "body",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.body = newElements;
    return node;
  }
  visitEmptyStatement(node, state, path) {
    return node;
  }
  visitDebuggerStatement(node, state, path) {
    return node;
  }
  visitWithStatement(node, state, path) {
    const visitor = this;
    node.object = visitor.accept(node.object, state, path.concat(["object"]));
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitReturnStatement(node, state, path) {
    const visitor = this;
    if (node.argument) {
      node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    }
    return node;
  }
  visitLabeledStatement(node, state, path) {
    const visitor = this;
    node.label = visitor.accept(node.label, state, path.concat(["label"]));
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitBreakStatement(node, state, path) {
    const visitor = this;
    if (node.label) {
      node.label = visitor.accept(node.label, state, path.concat(["label"]));
    }
    return node;
  }
  visitContinueStatement(node, state, path) {
    const visitor = this;
    if (node.label) {
      node.label = visitor.accept(node.label, state, path.concat(["label"]));
    }
    return node;
  }
  visitIfStatement(node, state, path) {
    const visitor = this;
    node.test = visitor.accept(node.test, state, path.concat(["test"]));
    node.consequent = visitor.accept(node.consequent, state, path.concat(["consequent"]));
    if (node.alternate) {
      node.alternate = visitor.accept(node.alternate, state, path.concat(["alternate"]));
    }
    return node;
  }
  visitSwitchStatement(node, state, path) {
    const visitor = this;
    node.discriminant = visitor.accept(node.discriminant, state, path.concat(["discriminant"]));
    const newElements = [];
    for (let i = 0; i < node.cases.length; i++) {
      const ea = node.cases[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "cases",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.cases = newElements;
    return node;
  }
  visitThrowStatement(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitTryStatement(node, state, path) {
    const visitor = this;
    node.block = visitor.accept(node.block, state, path.concat(["block"]));
    if (node.handler) {
      node.handler = visitor.accept(node.handler, state, path.concat(["handler"]));
    }
    if (node.finalizer) {
      node.finalizer = visitor.accept(node.finalizer, state, path.concat(["finalizer"]));
    }
    return node;
  }
  visitWhileStatement(node, state, path) {
    const visitor = this;
    node.test = visitor.accept(node.test, state, path.concat(["test"]));
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitDoWhileStatement(node, state, path) {
    const visitor = this;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    node.test = visitor.accept(node.test, state, path.concat(["test"]));
    return node;
  }
  visitForStatement(node, state, path) {
    const visitor = this;
    if (node.init) {
      node.init = visitor.accept(node.init, state, path.concat(["init"]));
    }
    if (node.test) {
      node.test = visitor.accept(node.test, state, path.concat(["test"]));
    }
    if (node.update) {
      node.update = visitor.accept(node.update, state, path.concat(["update"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitForInStatement(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitDeclaration(node, state, path) {
    return node;
  }
  visitThisExpression(node, state, path) {
    return node;
  }
  visitArrayExpression(node, state, path) {
    const visitor = this;
    if (node.elements) {
      const newElements = [];
      for (let i = 0; i < node.elements.length; i++) {
        const ea = node.elements[i];
        const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
          "elements",
          i
        ])) : ea;
        if (Array.isArray(acceptedNodes))
          newElements.push.apply(newElements, acceptedNodes);
        else
          newElements.push(acceptedNodes);
      }
      node.elements = newElements;
    }
    return node;
  }
  visitObjectExpression(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.properties.length; i++) {
      const ea = node.properties[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "properties",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.properties = newElements;
    return node;
  }
  visitFunctionExpression(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    const newElements = [];
    for (let i = 0; i < node.params.length; i++) {
      const ea = node.params[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "params",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.params = newElements;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitUnaryExpression(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitUpdateExpression(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitBinaryExpression(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    return node;
  }
  visitAssignmentExpression(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    return node;
  }
  visitLogicalExpression(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    return node;
  }
  visitMemberExpression(node, state, path) {
    const visitor = this;
    node.object = visitor.accept(node.object, state, path.concat(["object"]));
    node.property = visitor.accept(node.property, state, path.concat(["property"]));
    return node;
  }
  visitConditionalExpression(node, state, path) {
    const visitor = this;
    node.test = visitor.accept(node.test, state, path.concat(["test"]));
    node.alternate = visitor.accept(node.alternate, state, path.concat(["alternate"]));
    node.consequent = visitor.accept(node.consequent, state, path.concat(["consequent"]));
    return node;
  }
  visitCallExpression(node, state, path) {
    const visitor = this;
    node.callee = visitor.accept(node.callee, state, path.concat(["callee"]));
    const newElements = [];
    for (let i = 0; i < node.arguments.length; i++) {
      const ea = node.arguments[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "arguments",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.arguments = newElements;
    return node;
  }
  visitNewExpression(node, state, path) {
    const visitor = this;
    node.callee = visitor.accept(node.callee, state, path.concat(["callee"]));
    const newElements = [];
    for (let i = 0; i < node.arguments.length; i++) {
      const ea = node.arguments[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "arguments",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.arguments = newElements;
    return node;
  }
  visitSequenceExpression(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.expressions.length; i++) {
      const ea = node.expressions[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "expressions",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.expressions = newElements;
    return node;
  }
  visitArrowFunctionExpression(node, state, path) {
    const visitor = this;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    const newElements = [];
    for (let i = 0; i < node.params.length; i++) {
      const ea = node.params[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "params",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.params = newElements;
    return node;
  }
  visitYieldExpression(node, state, path) {
    const visitor = this;
    if (node.argument) {
      node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    }
    return node;
  }
  visitTemplateLiteral(node, state, path) {
    const visitor = this;
    let newElements = [];
    for (let i = 0; i < node.quasis.length; i++) {
      const ea = node.quasis[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "quasis",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.quasis = newElements;
    newElements = [];
    for (let i = 0; i < node.expressions.length; i++) {
      const ea = node.expressions[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "expressions",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.expressions = newElements;
    return node;
  }
  visitTaggedTemplateExpression(node, state, path) {
    const visitor = this;
    node.tag = visitor.accept(node.tag, state, path.concat(["tag"]));
    node.quasi = visitor.accept(node.quasi, state, path.concat(["quasi"]));
    return node;
  }
  visitAssignmentProperty(node, state, path) {
    const visitor = this;
    node.value = visitor.accept(node.value, state, path.concat(["value"]));
    node.key = visitor.accept(node.key, state, path.concat(["key"]));
    return node;
  }
  visitObjectPattern(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.properties.length; i++) {
      const ea = node.properties[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "properties",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.properties = newElements;
    return node;
  }
  visitArrayPattern(node, state, path) {
    const visitor = this;
    if (node.elements) {
      const newElements = [];
      for (let i = 0; i < node.elements.length; i++) {
        const ea = node.elements[i];
        const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
          "elements",
          i
        ])) : ea;
        if (Array.isArray(acceptedNodes))
          newElements.push.apply(newElements, acceptedNodes);
        else
          newElements.push(acceptedNodes);
      }
      node.elements = newElements;
    }
    return node;
  }
  visitRestElement(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitAssignmentPattern(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    return node;
  }
  visitClassExpression(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitMetaProperty(node, state, path) {
    const visitor = this;
    node.meta = visitor.accept(node.meta, state, path.concat(["meta"]));
    node.property = visitor.accept(node.property, state, path.concat(["property"]));
    return node;
  }
  visitImportDeclaration(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.specifiers.length; i++) {
      const ea = node.specifiers[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "specifiers",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.specifiers = newElements;
    node.source = visitor.accept(node.source, state, path.concat(["source"]));
    return node;
  }
  visitImportSpecifier(node, state, path) {
    const visitor = this;
    node.imported = visitor.accept(node.imported, state, path.concat(["imported"]));
    node.local = visitor.accept(node.local, state, path.concat(["local"]));
    return node;
  }
  visitImportDefaultSpecifier(node, state, path) {
    const visitor = this;
    node.local = visitor.accept(node.local, state, path.concat(["local"]));
    return node;
  }
  visitImportNamespaceSpecifier(node, state, path) {
    const visitor = this;
    node.local = visitor.accept(node.local, state, path.concat(["local"]));
    return node;
  }
  visitExportNamedDeclaration(node, state, path) {
    const visitor = this;
    if (node.declaration) {
      node.declaration = visitor.accept(node.declaration, state, path.concat(["declaration"]));
    }
    const newElements = [];
    for (let i = 0; i < node.specifiers.length; i++) {
      const ea = node.specifiers[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "specifiers",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.specifiers = newElements;
    if (node.source) {
      node.source = visitor.accept(node.source, state, path.concat(["source"]));
    }
    return node;
  }
  visitExportSpecifier(node, state, path) {
    const visitor = this;
    node.exported = visitor.accept(node.exported, state, path.concat(["exported"]));
    node.local = visitor.accept(node.local, state, path.concat(["local"]));
    return node;
  }
  visitAnonymousDefaultExportedFunctionDeclaration(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    const newElements = [];
    for (let i = 0; i < node.params.length; i++) {
      const ea = node.params[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "params",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.params = newElements;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitAnonymousDefaultExportedClassDeclaration(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    const newElements = [];
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitExportDefaultDeclaration(node, state, path) {
    const visitor = this;
    node.declaration = visitor.accept(node.declaration, state, path.concat(["declaration"]));
    return node;
  }
  visitExportAllDeclaration(node, state, path) {
    const visitor = this;
    node.source = visitor.accept(node.source, state, path.concat(["source"]));
    if (node.exported) {
      node.exported = visitor.accept(node.exported, state, path.concat(["exported"]));
    }
    return node;
  }
  visitAwaitExpression(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitJSXMemberExpression(node, state, path) {
    const visitor = this;
    node.object = visitor.accept(node.object, state, path.concat(["object"]));
    node.property = visitor.accept(node.property, state, path.concat(["property"]));
    return node;
  }
  visitJSXNamespacedName(node, state, path) {
    const visitor = this;
    node.namespace = visitor.accept(node.namespace, state, path.concat(["namespace"]));
    node.name = visitor.accept(node.name, state, path.concat(["name"]));
    return node;
  }
  visitJSXOpeningElement(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.attributes.length; i++) {
      const ea = node.attributes[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "attributes",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.attributes = newElements;
    node.name = visitor.accept(node.name, state, path.concat(["name"]));
    return node;
  }
  visitJSXClosingElement(node, state, path) {
    const visitor = this;
    node.name = visitor.accept(node.name, state, path.concat(["name"]));
    return node;
  }
  visitJSXSpreadAttribute(node, state, path) {
    const visitor = this;
    node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
    return node;
  }
  visitJSXElement(node, state, path) {
    const visitor = this;
    node.openingElement = visitor.accept(node.openingElement, state, path.concat(["openingElement"]));
    const newElements = [];
    for (let i = 0; i < node.children.length; i++) {
      const ea = node.children[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "children",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.children = newElements;
    if (node.closingElement) {
      node.closingElement = visitor.accept(node.closingElement, state, path.concat(["closingElement"]));
    }
    return node;
  }
  visitJSXFragment(node, state, path) {
    const visitor = this;
    node.openingFragment = visitor.accept(node.openingFragment, state, path.concat(["openingFragment"]));
    const newElements = [];
    for (let i = 0; i < node.children.length; i++) {
      const ea = node.children[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "children",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.children = newElements;
    node.closingFragment = visitor.accept(node.closingFragment, state, path.concat(["closingFragment"]));
    return node;
  }
  visitChainExpression(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitImportExpression(node, state, path) {
    const visitor = this;
    node.source = visitor.accept(node.source, state, path.concat(["source"]));
    return node;
  }
  visitRegExpLiteral(node, state, path) {
    return node;
  }
  visitDirective(node, state, path) {
    const visitor = this;
    node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
    return node;
  }
  visitFunctionBody(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.body.length; i++) {
      const ea = node.body[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "body",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.body = newElements;
    return node;
  }
  visitFunctionDeclaration(node, state, path) {
    const visitor = this;
    if (node.id) {
      node.id = visitor.accept(node.id, state, path.concat(["id"]));
    }
    const newElements = [];
    for (let i = 0; i < node.params.length; i++) {
      const ea = node.params[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "params",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.params = newElements;
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitVariableDeclaration(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.declarations.length; i++) {
      const ea = node.declarations[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "declarations",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.declarations = newElements;
    return node;
  }
  visitForOfStatement(node, state, path) {
    const visitor = this;
    node.left = visitor.accept(node.left, state, path.concat(["left"]));
    node.right = visitor.accept(node.right, state, path.concat(["right"]));
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    return node;
  }
  visitClassDeclaration(node, state, path) {
    const visitor = this;
    node.id = visitor.accept(node.id, state, path.concat(["id"]));
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, state, path.concat(["body"]));
    const newElements = [];
    if (!node.decorators)
      debugger;
    for (let i = 0; i < node.decorators.length; i++) {
      const ea = node.decorators[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "decorators",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.decorators = newElements;
    return node;
  }
  visitJSXIdentifier(node, state, path) {
    return node;
  }
  visitBigIntLiteral(node, state, path) {
    return node;
  }
  visitStaticBlock(node, state, path) {
    const visitor = this;
    const newElements = [];
    for (let i = 0; i < node.body.length; i++) {
      const ea = node.body[i];
      const acceptedNodes = ea ? visitor.accept(ea, state, path.concat([
        "body",
        i
      ])) : ea;
      if (Array.isArray(acceptedNodes))
        newElements.push.apply(newElements, acceptedNodes);
      else
        newElements.push(acceptedNodes);
    }
    node.body = newElements;
    return node;
  }
}

class PrinterVisitor extends Visitor {
  accept(node, state, path) {
    const pathString = path.map(ea => typeof ea === "string" ? `.${ ea }` : `[${ ea }]`).join("");
    const myChildren = [];
    const result = super.accept(node, {
      index: state.index,
      tree: myChildren
    }, path);
    state.tree.push({
      node: node,
      path: pathString,
      index: state.index++,
      children: myChildren
    });
    return result;
  }
}
class ComparisonVisitor extends Visitor {
  recordNotEqual(node1, node2, state, msg) {
    state.comparisons.errors.push({
      node1: node1,
      node2: node2,
      path: state.completePath,
      msg: msg
    });
  }
  compareType(node1, node2, state) {
    return this.compareField("type", node1, node2, state);
  }
  compareField(field, node1, node2, state) {
    node2 = Path(state.completePath.join(".")).get(node2);
    if (node1 && node2 && node1[field] === node2[field])
      return true;
    if (node1 && node1[field] === "*" || node2 && node2[field] === "*")
      return true;
    const fullPath = state.completePath.join(".") + "." + field;
    let msg;
    if (!node1)
      msg = "node1 on " + fullPath + " not defined";
    else if (!node2)
      msg = "node2 not defined but node1 (" + fullPath + ") is: " + node1[field];
    else
      msg = fullPath + " is not equal: " + node1[field] + " vs. " + node2[field];
    this.recordNotEqual(node1, node2, state, msg);
    return false;
  }
  accept(node1, node2, state, path) {
    const patternNode = Path(path.join(".")).get(node2);
    if (node1 === "*" || patternNode === "*")
      return;
    const nextState = {
      completePath: path,
      comparisons: state.comparisons
    };
    if (this.compareType(node1, node2, nextState)) {
      this["visit" + node1.type](node1, node2, nextState, path);
    }
  }
  visitFunction(node1, node2, state, path) {
    if (node1.generator) {
      this.compareField("generator", node1, node2, state);
    }
    if (node1.expression) {
      this.compareField("expression", node1, node2, state);
    }
    return super.visitFunction(node1, node2, state, path);
  }
  visitSwitchStatement(node1, node2, state, path) {
    if (node1.lexical) {
      this.compareField("lexical", node1, node2, state);
    }
    return super.visitSwitchStatement(node1, node2, state, path);
  }
  visitForInStatement(node1, node2, state, path) {
    if (node1.each) {
      this.compareField("each", node1, node2, state);
    }
    return super.visitForInStatement(node1, node2, state, path);
  }
  visitFunctionDeclaration(node1, node2, state, path) {
    if (node1.generator) {
      this.compareField("generator", node1, node2, state);
    }
    if (node1.expression) {
      this.compareField("expression", node1, node2, state);
    }
    return super.visitFunctionDeclaration(node1, node2, state, path);
  }
  visitVariableDeclaration(node1, node2, state, path) {
    this.compareField("kind", node1, node2, state);
    return super.visitVariableDeclaration(node1, node2, state, path);
  }
  visitUnaryExpression(node1, node2, state, path) {
    this.compareField("operator", node1, node2, state);
    if (node1.prefix) {
      this.compareField("prefix", node1, node2, state);
    }
    return super.visitUnaryExpression(node1, node2, state, path);
  }
  visitBinaryExpression(node1, node2, state, path) {
    this.compareField("operator", node1, node2, state);
    return super.visitBinaryExpression(node1, node2, state, path);
  }
  visitAssignmentExpression(node1, node2, state, path) {
    this.compareField("operator", node1, node2, state);
    return super.visitAssignmentExpression(node1, node2, state, path);
  }
  visitUpdateExpression(node1, node2, state, path) {
    this.compareField("operator", node1, node2, state);
    if (node1.prefix) {
      this.compareField("prefix", node1, node2, state);
    }
    return super.visitUpdateExpression(node1, node2, state, path);
  }
  visitLogicalExpression(node1, node2, state, path) {
    this.compareField("operator", node1, node2, state);
    return super.visitLogicalExpression(node1, node2, state, path);
  }
  visitMemberExpression(node1, node2, state, path) {
    if (node1.computed) {
      this.compareField("computed", node1, node2, state);
    }
    return super.visitMemberExpression(node1, node2, state, path);
  }
  visitComprehensionBlock(node1, node2, state, path) {
    if (node1.each) {
      this.compareField("each", node1, node2, state);
    }
    return super.visitComprehensionBlock(node1, node2, state, path);
  }
  visitIdentifier(node1, node2, state, path) {
    this.compareField("name", node1, node2, state);
    return super.visitIdentifier(node1, node2, state, path);
  }
  visitLiteral(node1, node2, state, path) {
    this.compareField("value", node1, node2, state);
    return super.visitLiteral(node1, node2, state, path);
  }
  visitClassDeclaration(node1, node2, state, path) {
    this.compareField("id", node1, node2, state);
    if (node1.superClass) {
      this.compareField("superClass", node1, node2, state);
    }
    this.compareField("body", node1, node2, state);
    return super.visitClassDeclaration(node1, node2, state, path);
  }
  visitClassBody(node1, node2, state, path) {
    this.compareField("body", node1, node2, state);
    return super.visitClassBody(node1, node2, state, path);
  }
  visitMethodDefinition(node1, node2, state, path) {
    this.compareField("static", node1, node2, state);
    this.compareField("computed", node1, node2, state);
    this.compareField("kind", node1, node2, state);
    this.compareField("key", node1, node2, state);
    this.compareField("value", node1, node2, state);
    return super.visitMethodDefinition(node1, node2, state, path);
  }
}
class ScopeVisitor extends Visitor {
  newScope(scopeNode, parentScope) {
    const scope = {
      node: scopeNode,
      varDecls: [],
      varDeclPaths: [],
      funcDecls: [],
      funcDeclPaths: [],
      classDecls: [],
      classDeclPaths: [],
      classExprs: [],
      classExprPaths: [],
      methodDecls: [],
      methodDeclPaths: [],
      importSpecifiers: [],
      importSpecifierPaths: [],
      exportDecls: [],
      exportDeclPaths: [],
      refs: [],
      thisRefs: [],
      params: [],
      catches: [],
      subScopes: [],
      resolvedRefMap: new Map()
    };
    if (parentScope)
      parentScope.subScopes.push(scope);
    return scope;
  }
  visitVariableDeclaration(node, scope, path) {
    scope.varDecls.push(node);
    scope.varDeclPaths.push(path);
    return super.visitVariableDeclaration(node, scope, path);
  }
  visitVariableDeclarator(node, scope, path) {
    const visitor = this;
    if (node.init) {
      node.init = visitor.accept(node.init, scope, path.concat(["init"]));
    }
    return node;
  }
  visitFunction(node, scope, path) {
    const visitor = this;
    const newScope = this.newScope(node, scope);
    node.params.forEach((param, i) => {
      if (param.type === "AssignmentPattern") {
        visitor.accept(param.right, newScope, path.concat("params", i, "right"));
      }
    });
    newScope.params = Array.prototype.slice.call(node.params);
    return newScope;
  }
  visitFunctionDeclaration(node, scope, path) {
    const newScope = this.visitFunction(node, scope, path);
    scope.funcDecls.push(node);
    scope.funcDeclPaths.push(path);
    const visitor = this;
    if (node.defaults) {
      node.defaults = node.defaults.reduce(function (results, ea, i) {
        const result = visitor.accept(ea, newScope, path.concat([
          "defaults",
          i
        ]));
        if (Array.isArray(result))
          results.push.apply(results, result);
        else
          results.push(result);
        return results;
      }, []);
    }
    if (node.rest) {
      node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
    }
    node.body = visitor.accept(node.body, newScope, path.concat(["body"]));
    if (node.loc) {
      node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
    }
    return node;
  }
  visitFunctionExpression(node, scope, path) {
    const newScope = this.visitFunction(node, scope, path);
    const visitor = this;
    if (node.defaults) {
      node.defaults = node.defaults.reduce(function (results, ea, i) {
        const result = visitor.accept(ea, newScope, path.concat([
          "defaults",
          i
        ]));
        if (Array.isArray(result))
          results.push.apply(results, result);
        else
          results.push(result);
        return results;
      }, []);
    }
    if (node.rest) {
      node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
    }
    node.body = visitor.accept(node.body, newScope, path.concat(["body"]));
    if (node.loc) {
      node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
    }
    return node;
  }
  visitArrowFunctionExpression(node, scope, path) {
    const newScope = this.visitFunction(node, scope, path);
    const visitor = this;
    if (node.defaults) {
      node.defaults = node.defaults.reduce(function (results, ea, i) {
        const result = visitor.accept(ea, newScope, path.concat([
          "defaults",
          i
        ]));
        if (Array.isArray(result))
          results.push.apply(results, result);
        else
          results.push(result);
        return results;
      }, []);
    }
    if (node.rest) {
      node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
    }
    node.body = visitor.accept(node.body, newScope, path.concat(["body"]));
    if (node.loc) {
      node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
    }
    if (node.generator) ;
    if (node.expression) ;
    return node;
  }
  visitIdentifier(node, scope, path) {
    scope.refs.push(node);
    return super.visitIdentifier(node, scope, path);
  }
  visitMemberExpression(node, scope, path) {
    const visitor = this;
    node.object = visitor.accept(node.object, scope, path.concat(["object"]));
    if (node.computed) {
      node.property = visitor.accept(node.property, scope, path.concat(["property"]));
    }
    return node;
  }
  visitProperty(node, scope, path) {
    const visitor = this;
    if (node.computed) {
      node.key = visitor.accept(node.key, scope, path.concat(["key"]));
    }
    node.value = visitor.accept(node.value, scope, path.concat(["value"]));
    return node;
  }
  visitThisExpression(node, scope, path) {
    scope.thisRefs.push(node);
    return super.visitThisExpression(node, scope, path);
  }
  visitTryStatement(node, scope, path) {
    const visitor = this;
    node.block = visitor.accept(node.block, scope, path.concat(["block"]));
    if (node.handler) {
      node.handler = visitor.accept(node.handler, scope, path.concat(["handler"]));
      scope.catches.push(node.handler.param);
    }
    if (node.finalizer) {
      node.finalizer = visitor.accept(node.finalizer, scope, path.concat(["finalizer"]));
    }
    return node;
  }
  visitLabeledStatement(node, scope, path) {
    const visitor = this;
    node.body = visitor.accept(node.body, scope, path.concat(["body"]));
    return node;
  }
  visitClassDeclaration(node, scope, path) {
    scope.classDecls.push(node);
    scope.classDeclPaths.push(path);
    const visitor = this;
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, scope, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, scope, path.concat(["body"]));
    return node;
  }
  visitClassExpression(node, scope, path) {
    if (node.id) {
      scope.classExprs.push(node);
      scope.classExprPaths.push(path);
    }
    const visitor = this;
    if (node.superClass) {
      node.superClass = visitor.accept(node.superClass, scope, path.concat(["superClass"]));
    }
    node.body = visitor.accept(node.body, scope, path.concat(["body"]));
    return node;
  }
  visitMethodDefinition(node, scope, path) {
    const visitor = this;
    node.value = visitor.accept(node.value, scope, path.concat(["value"]));
    return node;
  }
  visitMetaProperty(node, scope, path) {
    return node;
  }
  visitBreakStatement(node, scope, path) {
    return node;
  }
  visitContinueStatement(node, scope, path) {
    return node;
  }
  visitImportSpecifier(node, scope, path) {
    scope.importSpecifiers.push(node.local);
    scope.importSpecifierPaths.push(path);
    return node;
  }
  visitImportDefaultSpecifier(node, scope, path) {
    scope.importSpecifiers.push(node.local);
    scope.importSpecifierPaths.push(path);
    return node;
  }
  visitImportNamespaceSpecifier(node, scope, path) {
    scope.importSpecifiers.push(node.local);
    scope.importSpecifierPaths.push(path);
    return node;
  }
  visitExportSpecifier(node, scope, path) {
    const visitor = this;
    node.local = visitor.accept(node.local, scope, path.concat(["local"]));
    return node;
  }
  visitExportNamedDeclaration(node, scope, path) {
    scope.exportDecls.push(node);
    scope.exportDeclPaths.push(path);
    if (!node.source)
      super.visitExportNamedDeclaration(node, scope, path);
    return node;
  }
  visitExportDefaultDeclaration(node, scope, path) {
    scope.exportDecls.push(node);
    scope.exportDeclPaths.push(path);
    return super.visitExportDefaultDeclaration(node, scope, path);
  }
  visitExportAllDeclaration(node, scope, path) {
    scope.exportDecls.push(node);
    scope.exportDeclPaths.push(path);
    return super.visitExportAllDeclaration(node, scope, path);
  }
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64)
    return base64;
  hasRequiredBase64 = 1;
  Object.defineProperty(base64, "__esModule", { value: true });
  base64.decode = base64.encode = void 0;
  var charToIntMap = {};
  var intToCharMap = {};
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").forEach(function (ch, index) {
    charToIntMap[ch] = index;
    intToCharMap[index] = ch;
  });
  var a = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };
  base64.encode = a;
  var b = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };
  base64.decode = b;
  return base64;
}

var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq)
    return base64Vlq;
  hasRequiredBase64Vlq = 1;
  Object.defineProperty(base64Vlq, "__esModule", { value: true });
  base64Vlq.decode = base64Vlq.encode = void 0;
  var _base = _interopRequireDefault(requireBase64());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  var a = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += _base.default.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.encode = a;
  var b = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = _base.default.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };
  base64Vlq.decode = b;
  return base64Vlq;
}

var util = {};

var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.compareByGeneratedPositions = util.compareByOriginalPositions = util.relative = util.fromSetString = util.toSetString = util.join = util.urlGenerate = util.urlParse = util.getArg = void 0;
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error("\"" + aName + "\" is a required argument.");
    }
  }
  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  function join(aRoot, aPath) {
    var url;
    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aPath.charAt(0) === "/" && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }
    return aRoot.replace(/\/$/, "") + "/" + aPath;
  }
  function toSetString(aStr) {
    return "$" + aStr;
  }
  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, "");
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }
    return aPath.indexOf(aRoot + "/") === 0 ? aPath.substr(aRoot.length + 1) : aPath;
  }
  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }
    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }
    return mappingA.generatedColumn - mappingB.generatedColumn;
  }
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  var a = getArg;
  util.getArg = a;
  var b = urlParse;
  util.urlParse = b;
  var c = urlGenerate;
  util.urlGenerate = c;
  var d = join;
  util.join = d;
  var e = toSetString;
  util.toSetString = e;
  var f = fromSetString;
  util.fromSetString = f;
  var g = relative;
  util.relative = g;
  var h = compareByOriginalPositions;
  util.compareByOriginalPositions = h;
  var i = compareByGeneratedPositions;
  util.compareByGeneratedPositions = i;
  return util;
}

var arraySet = {};

var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet)
    return arraySet;
  hasRequiredArraySet = 1;
  Object.defineProperty(arraySet, "__esModule", { value: true });
  arraySet.ArraySet = void 0;
  var _util = _interopRequireDefault(requireUtil());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ArraySet() {
    this._array = [];
    this._set = {};
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[_util.default.toSetString(aStr)] = idx;
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set, _util.default.toSetString(aStr));
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[_util.default.toSetString(aStr)];
    }
    throw new Error("\"" + aStr + "\" is not in the set.");
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  var a = ArraySet;
  arraySet.ArraySet = a;
  return arraySet;
}

var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator)
    return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  Object.defineProperty(sourceMapGenerator, "__esModule", { value: true });
  sourceMapGenerator.SourceMapGenerator = void 0;
  var _base64Vlq = _interopRequireDefault(requireBase64Vlq());
  var _util = _interopRequireDefault(requireUtil());
  var _arraySet = _interopRequireDefault(requireArraySet());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ArraySet = _arraySet.default.ArraySet;
  function SourceMapGenerator(aArgs) {
    this._file = _util.default.getArg(aArgs, "file");
    this._sourceRoot = _util.default.getArg(aArgs, "sourceRoot", null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source) {
        newMapping.source = mapping.source;
        if (sourceRoot) {
          newMapping.source = _util.default.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = _util.default.getArg(aArgs, "generated");
    var original = _util.default.getArg(aArgs, "original", null);
    var source = _util.default.getArg(aArgs, "source", null);
    var name = _util.default.getArg(aArgs, "name", null);
    this._validateMapping(generated, original, source, name);
    if (source && !this._sources.has(source)) {
      this._sources.add(source);
    }
    if (name && !this._names.has(name)) {
      this._names.add(name);
    }
    this._mappings.push({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot) {
      source = _util.default.relative(this._sourceRoot, source);
    }
    if (aSourceContent !== null) {
      if (!this._sourcesContents) {
        this._sourcesContents = {};
      }
      this._sourcesContents[_util.default.toSetString(source)] = aSourceContent;
    } else {
      delete this._sourcesContents[_util.default.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
    if (!aSourceFile) {
      aSourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot) {
      aSourceFile = _util.default.relative(sourceRoot, aSourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.forEach(function (mapping) {
      if (mapping.source === aSourceFile && mapping.originalLine) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source !== null) {
          if (sourceRoot) {
            mapping.source = _util.default.relative(sourceRoot, original.source);
          } else {
            mapping.source = original.source;
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name !== null && mapping.name !== null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        if (sourceRoot) {
          sourceFile = _util.default.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var mapping;
    this._mappings.sort(_util.default.compareByGeneratedPositions);
    for (var i = 0, len = this._mappings.length; i < len; i++) {
      mapping = this._mappings[i];
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          result += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!_util.default.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
            continue;
          }
          result += ",";
        }
      }
      result += _base64Vlq.default.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source) {
        result += _base64Vlq.default.encode(this._sources.indexOf(mapping.source) - previousSource);
        previousSource = this._sources.indexOf(mapping.source);
        result += _base64Vlq.default.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        result += _base64Vlq.default.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name) {
          result += _base64Vlq.default.encode(this._names.indexOf(mapping.name) - previousName);
          previousName = this._names.indexOf(mapping.name);
        }
      }
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot) {
        source = _util.default.relative(aSourceRoot, source);
      }
      var key = _util.default.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      file: this._file,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._sourceRoot) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this);
  };
  var b = SourceMapGenerator;
  sourceMapGenerator.SourceMapGenerator = b;
  return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch)
    return binarySearch;
  hasRequiredBinarySearch = 1;
  Object.defineProperty(binarySearch, "__esModule", { value: true });
  binarySearch.search = void 0;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return aHaystack[mid];
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      return aHaystack[mid];
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      return aLow < 0 ? null : aHaystack[aLow];
    }
  }
  var a = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0 ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare) : null;
  };
  binarySearch.search = a;
  return binarySearch;
}

var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer)
    return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  Object.defineProperty(sourceMapConsumer, "__esModule", { value: true });
  sourceMapConsumer.SourceMapConsumer = void 0;
  var _util = _interopRequireDefault(requireUtil());
  var _binarySearch = _interopRequireDefault(requireBinarySearch());
  var _arraySet = _interopRequireDefault(requireArraySet());
  var _base64Vlq = _interopRequireDefault(requireBase64Vlq());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ArraySet = _arraySet.default.ArraySet;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = _util.default.getArg(sourceMap, "version");
    var sources = _util.default.getArg(sourceMap, "sources");
    var names = _util.default.getArg(sourceMap, "names", []);
    var sourceRoot = _util.default.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = _util.default.getArg(sourceMap, "sourcesContent", null);
    var mappings = _util.default.getArg(sourceMap, "mappings");
    var file = _util.default.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }
  SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(SourceMapConsumer.prototype);
    smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc.__generatedMappings = aSourceMap._mappings.slice().sort(_util.default.compareByGeneratedPositions);
    smc.__originalMappings = aSourceMap._mappings.slice().sort(_util.default.compareByOriginalPositions);
    return smc;
  };
  SourceMapConsumer.prototype._version = 3;
  Object.defineProperty(SourceMapConsumer.prototype, "sources", {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? _util.default.join(this.sourceRoot, s) : s;
      }, this);
    }
  });
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var mappingSeparator = /^[,;]/;
    var str = aStr;
    var mapping;
    var temp;
    while (str.length > 0) {
      if (str.charAt(0) === ";") {
        generatedLine++;
        str = str.slice(1);
        previousGeneratedColumn = 0;
      } else if (str.charAt(0) === ",") {
        str = str.slice(1);
      } else {
        mapping = {};
        mapping.generatedLine = generatedLine;
        temp = _base64Vlq.default.decode(str);
        mapping.generatedColumn = previousGeneratedColumn + temp.value;
        previousGeneratedColumn = mapping.generatedColumn;
        str = temp.rest;
        if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
          temp = _base64Vlq.default.decode(str);
          mapping.source = this._sources.at(previousSource + temp.value);
          previousSource += temp.value;
          str = temp.rest;
          if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
            throw new Error("Found a source, but no line and column");
          }
          temp = _base64Vlq.default.decode(str);
          mapping.originalLine = previousOriginalLine + temp.value;
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          str = temp.rest;
          if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
            throw new Error("Found a source and line, but no column");
          }
          temp = _base64Vlq.default.decode(str);
          mapping.originalColumn = previousOriginalColumn + temp.value;
          previousOriginalColumn = mapping.originalColumn;
          str = temp.rest;
          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            temp = _base64Vlq.default.decode(str);
            mapping.name = this._names.at(previousName + temp.value);
            previousName += temp.value;
            str = temp.rest;
          }
        }
        this.__generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          this.__originalMappings.push(mapping);
        }
      }
    }
    this.__generatedMappings.sort(_util.default.compareByGeneratedPositions);
    this.__originalMappings.sort(_util.default.compareByOriginalPositions);
  };
  SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return _binarySearch.default.search(aNeedle, aMappings, aComparator);
  };
  SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: _util.default.getArg(aArgs, "line"),
      generatedColumn: _util.default.getArg(aArgs, "column")
    };
    var mapping = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", _util.default.compareByGeneratedPositions);
    if (mapping) {
      var source = _util.default.getArg(mapping, "source", null);
      if (source && this.sourceRoot) {
        source = _util.default.join(this.sourceRoot, source);
      }
      return {
        source: source,
        line: _util.default.getArg(mapping, "originalLine", null),
        column: _util.default.getArg(mapping, "originalColumn", null),
        name: _util.default.getArg(mapping, "name", null)
      };
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {
    if (!this.sourcesContent) {
      return null;
    }
    if (this.sourceRoot) {
      aSource = _util.default.relative(this.sourceRoot, aSource);
    }
    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }
    var url;
    if (this.sourceRoot && (url = _util.default.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }
    throw new Error("\"" + aSource + "\" is not in the SourceMap.");
  };
  SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var needle = {
      source: _util.default.getArg(aArgs, "source"),
      originalLine: _util.default.getArg(aArgs, "line"),
      originalColumn: _util.default.getArg(aArgs, "column")
    };
    if (this.sourceRoot) {
      needle.source = _util.default.relative(this.sourceRoot, needle.source);
    }
    var mapping = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", _util.default.compareByOriginalPositions);
    if (mapping) {
      return {
        line: _util.default.getArg(mapping, "generatedLine", null),
        column: _util.default.getArg(mapping, "generatedColumn", null)
      };
    }
    return {
      line: null,
      column: null
    };
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source;
      if (source && sourceRoot) {
        source = _util.default.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name
      };
    }).forEach(aCallback, context);
  };
  var b = SourceMapConsumer;
  sourceMapConsumer.SourceMapConsumer = b;
  return sourceMapConsumer;
}

var sourceNode = {};

var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode)
    return sourceNode;
  hasRequiredSourceNode = 1;
  Object.defineProperty(sourceNode, "__esModule", { value: true });
  sourceNode.SourceNode = void 0;
  var _sourceMapGenerator = _interopRequireDefault(requireSourceMapGenerator());
  var _util = _interopRequireDefault(requireUtil());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var SourceMapGenerator = _sourceMapGenerator.default.SourceMapGenerator;
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split("\n");
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping === null) {
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(remainingLines.shift() + "\n");
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
      } else {
        if (lastGeneratedLine < mapping.generatedLine) {
          var code = "";
          do {
            code += remainingLines.shift() + "\n";
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } while (lastGeneratedLine < mapping.generatedLine);
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            code += nextLine.substr(0, mapping.generatedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          addMappingWithCode(lastMapping, code);
        } else {
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
        }
      }
      lastMapping = mapping;
    }, this);
    addMappingWithCode(lastMapping, remainingLines.join("\n"));
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, mapping.source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[_util.default.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i] instanceof SourceNode) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(_util.default.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split("").forEach(function (ch) {
        if (ch === "\n") {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };
  var b = SourceNode;
  sourceNode.SourceNode = b;
  return sourceNode;
}

var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap)
    return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}

var estraverse = {};

(function (exports) {
  (function clone(exports) {
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array, func) {
      var diff, len, i, current;
      len = array.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }
      return i;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      StaticBlock: "StaticBlock",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: [
        "left",
        "right"
      ],
      AssignmentPattern: [
        "left",
        "right"
      ],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: [
        "params",
        "body"
      ],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: [
        "left",
        "right"
      ],
      BreakStatement: ["label"],
      CallExpression: [
        "callee",
        "arguments"
      ],
      CatchClause: [
        "param",
        "body"
      ],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: [
        "id",
        "superClass",
        "body"
      ],
      ClassExpression: [
        "id",
        "superClass",
        "body"
      ],
      ComprehensionBlock: [
        "left",
        "right"
      ],
      ComprehensionExpression: [
        "blocks",
        "filter",
        "body"
      ],
      ConditionalExpression: [
        "test",
        "consequent",
        "alternate"
      ],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: [
        "body",
        "test"
      ],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: [
        "declaration",
        "specifiers",
        "source"
      ],
      ExportSpecifier: [
        "exported",
        "local"
      ],
      ExpressionStatement: ["expression"],
      ForStatement: [
        "init",
        "test",
        "update",
        "body"
      ],
      ForInStatement: [
        "left",
        "right",
        "body"
      ],
      ForOfStatement: [
        "left",
        "right",
        "body"
      ],
      FunctionDeclaration: [
        "id",
        "params",
        "body"
      ],
      FunctionExpression: [
        "id",
        "params",
        "body"
      ],
      GeneratorExpression: [
        "blocks",
        "filter",
        "body"
      ],
      Identifier: [],
      IfStatement: [
        "test",
        "consequent",
        "alternate"
      ],
      ImportExpression: ["source"],
      ImportDeclaration: [
        "specifiers",
        "source"
      ],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: [
        "imported",
        "local"
      ],
      Literal: [],
      LabeledStatement: [
        "label",
        "body"
      ],
      LogicalExpression: [
        "left",
        "right"
      ],
      MemberExpression: [
        "object",
        "property"
      ],
      MetaProperty: [
        "meta",
        "property"
      ],
      MethodDefinition: [
        "key",
        "value"
      ],
      ModuleSpecifier: [],
      NewExpression: [
        "callee",
        "arguments"
      ],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: [
        "key",
        "value"
      ],
      PropertyDefinition: [
        "key",
        "value"
      ],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      StaticBlock: ["body"],
      Super: [],
      SwitchStatement: [
        "discriminant",
        "cases"
      ],
      SwitchCase: [
        "test",
        "consequent"
      ],
      TaggedTemplateExpression: [
        "tag",
        "quasi"
      ],
      TemplateElement: [],
      TemplateLiteral: [
        "quasis",
        "expressions"
      ],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: [
        "block",
        "handler",
        "finalizer"
      ],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: [
        "id",
        "init"
      ],
      WhileStatement: [
        "test",
        "body"
      ],
      WithStatement: [
        "object",
        "body"
      ],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace(node) {
      this.parent[this.key] = node;
    };
    Reference.prototype.remove = function remove() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element(node, path, wrap, ref) {
      this.node = node;
      this.path = path;
      this.wrap = wrap;
      this.ref = ref;
    }
    function Controller() {
    }
    Controller.prototype.path = function path() {
      var i, iz, j, jz, result, element;
      function addToPath(result, path) {
        if (Array.isArray(path)) {
          for (j = 0, jz = path.length; j < jz; ++j) {
            result.push(path[j]);
          }
        } else {
          result.push(path);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function () {
      var node = this.current();
      return node.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i, iz, result;
      result = [];
      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = undefined;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function () {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function () {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function () {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function (root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === "object" && typeof node.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
    }
    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i = leavelist.length - 1; i >= 0; --i) {
        if (leavelist[i].node === candidate) {
          return true;
        }
      }
      return false;
    }
    Controller.prototype.traverse = function traverse(root, visitor) {
      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element(root, null, null, null));
      leavelist.push(new Element(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node = element.node;
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], "Property", null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }
              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element) {
        var i, key, nextElem, parent;
        if (element.ref.remove()) {
          key = element.ref.key;
          parent = element.ref.parent;
          i = worklist.length;
          while (i--) {
            nextElem = worklist[i];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = { root: root };
      element = new Element(root, null, null, new Reference(outer, "root"));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node = element.node;
        if (!node) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], "Property", new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [
        comment.range[0],
        comment.range[1]
      ];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [
              0,
              tree.range[0]
            ];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function (node) {
          var comment;
          while (cursor < comments.length) {
            comment = comments[cursor];
            if (comment.extendedRange[1] > node.range[0]) {
              break;
            }
            if (comment.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }
              node.leadingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function (node) {
          var comment;
          while (cursor < comments.length) {
            comment = comments[cursor];
            if (node.range[1] < comment.extendedRange[0]) {
              break;
            }
            if (node.range[1] === comment.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }
              node.trailingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () {
      return clone({});
    };
    return exports;
  }(exports));
}(estraverse));

function ESCODEGEN() {
  let Syntax, Precedence, BinaryPrecedence, SourceNode, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
  Syntax = estraverse.Syntax;
  function isExpression(node) {
    return CodeGenerator.Expression.hasOwnProperty(node.type);
  }
  function isStatement(node) {
    return CodeGenerator.Statement.hasOwnProperty(node.type);
  }
  Precedence = {
    Sequence: 0,
    Yield: 1,
    Assignment: 1,
    Conditional: 2,
    ArrowFunction: 2,
    NullishCoalescing: 3,
    LogicalOR: 3,
    LogicalAND: 4,
    BitwiseOR: 5,
    BitwiseXOR: 6,
    BitwiseAND: 7,
    Equality: 8,
    Relational: 9,
    BitwiseSHIFT: 10,
    Additive: 11,
    Multiplicative: 12,
    Exponentiation: 13,
    Await: 14,
    Unary: 14,
    Postfix: 15,
    OptionalChaining: 16,
    Call: 17,
    New: 18,
    TaggedTemplate: 19,
    Member: 20,
    Primary: 21
  };
  BinaryPrecedence = {
    "??": Precedence.NullishCoalescing,
    "||": Precedence.LogicalOR,
    "&&": Precedence.LogicalAND,
    "|": Precedence.BitwiseOR,
    "^": Precedence.BitwiseXOR,
    "&": Precedence.BitwiseAND,
    "==": Precedence.Equality,
    "!=": Precedence.Equality,
    "===": Precedence.Equality,
    "!==": Precedence.Equality,
    is: Precedence.Equality,
    isnt: Precedence.Equality,
    "<": Precedence.Relational,
    ">": Precedence.Relational,
    "<=": Precedence.Relational,
    ">=": Precedence.Relational,
    in: Precedence.Relational,
    instanceof: Precedence.Relational,
    "<<": Precedence.BitwiseSHIFT,
    ">>": Precedence.BitwiseSHIFT,
    ">>>": Precedence.BitwiseSHIFT,
    "+": Precedence.Additive,
    "-": Precedence.Additive,
    "*": Precedence.Multiplicative,
    "%": Precedence.Multiplicative,
    "/": Precedence.Multiplicative,
    "**": Precedence.Exponentiation
  };
  let F_ALLOW_IN = 1;
  let F_ALLOW_CALL = 1 << 1;
  let F_ALLOW_UNPARATH_NEW = 1 << 2;
  let F_FUNC_BODY = 1 << 3;
  let F_DIRECTIVE_CTX = 1 << 4;
  let F_SEMICOLON_OPT = 1 << 5;
  let E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;
  let E_TTF = F_ALLOW_IN | F_ALLOW_CALL;
  let E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;
  let E_TFF = F_ALLOW_IN;
  let E_FFT = F_ALLOW_UNPARATH_NEW;
  let E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
  let S_TFFF = F_ALLOW_IN;
  let S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT;
  let S_FFFF = 0;
  let S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX;
  let S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
  function getDefaultOptions() {
    return {
      indent: null,
      base: null,
      parse: null,
      comment: false,
      format: {
        indent: {
          style: "    ",
          base: 0,
          adjustMultilineComment: false
        },
        newline: "\n",
        space: " ",
        json: false,
        renumber: false,
        hexadecimal: false,
        quotes: "single",
        escapeless: false,
        compact: false,
        parentheses: true,
        semicolons: true,
        safeConcatenation: false,
        preserveBlankLines: false
      },
      moz: {
        comprehensionExpressionStartsWithAssignment: false,
        starlessGenerator: false
      },
      sourceMap: null,
      sourceMapRoot: null,
      sourceMapWithCode: false,
      directive: false,
      raw: true,
      verbatim: null,
      sourceCode: null
    };
  }
  function stringRepeat(str, num) {
    let result = "";
    for (num |= 0; num > 0; num >>>= 1, str += str) {
      if (num & 1) {
        result += str;
      }
    }
    return result;
  }
  function hasLineTerminator(str) {
    return /[\r\n]/g.test(str);
  }
  function endsWithLineTerminator(str) {
    let len = str.length;
    return len && utils.code.isLineTerminator(str.charCodeAt(len - 1));
  }
  function merge(target, override) {
    let key;
    for (key in override) {
      if (override.hasOwnProperty(key)) {
        target[key] = override[key];
      }
    }
    return target;
  }
  function updateDeeply(target, override) {
    let key, val;
    function isHashObject(target) {
      return typeof target === "object" && target instanceof Object && !(target instanceof RegExp);
    }
    for (key in override) {
      if (override.hasOwnProperty(key)) {
        val = override[key];
        if (isHashObject(val)) {
          if (isHashObject(target[key])) {
            updateDeeply(target[key], val);
          } else {
            target[key] = updateDeeply({}, val);
          }
        } else {
          target[key] = val;
        }
      }
    }
    return target;
  }
  function generateNumber(value) {
    let result, point, temp, exponent, pos;
    if (value !== value) {
      throw new Error("Numeric literal whose value is NaN");
    }
    if (value < 0 || value === 0 && 1 / value < 0) {
      throw new Error("Numeric literal whose value is negative");
    }
    if (value === 1 / 0) {
      return json ? "null" : renumber ? "1e400" : "1e+400";
    }
    result = "" + value;
    if (!renumber || result.length < 3) {
      return result;
    }
    point = result.indexOf(".");
    if (!json && result.charCodeAt(0) === 48 && point === 1) {
      point = 0;
      result = result.slice(1);
    }
    temp = result;
    result = result.replace("e+", "e");
    exponent = 0;
    if ((pos = temp.indexOf("e")) > 0) {
      exponent = +temp.slice(pos + 1);
      temp = temp.slice(0, pos);
    }
    if (point >= 0) {
      exponent -= temp.length - point - 1;
      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
    }
    pos = 0;
    while (temp.charCodeAt(temp.length + pos - 1) === 48) {
      --pos;
    }
    if (pos !== 0) {
      exponent -= pos;
      temp = temp.slice(0, pos);
    }
    if (exponent !== 0) {
      temp += "e" + exponent;
    }
    if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
      result = temp;
    }
    return result;
  }
  function escapeRegExpCharacter(ch, previousIsBackslash) {
    if ((ch & ~1) === 8232) {
      return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
    } else if (ch === 10 || ch === 13) {
      return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
    }
    return String.fromCharCode(ch);
  }
  function generateRegExp(reg) {
    let match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
    result = reg.toString();
    if (reg.source) {
      match = result.match(/\/([^/]*)$/);
      if (!match) {
        return result;
      }
      flags = match[1];
      result = "";
      characterInBrack = false;
      previousIsBackslash = false;
      for (i = 0, iz = reg.source.length; i < iz; ++i) {
        ch = reg.source.charCodeAt(i);
        if (!previousIsBackslash) {
          if (characterInBrack) {
            if (ch === 93) {
              characterInBrack = false;
            }
          } else {
            if (ch === 47) {
              result += "\\";
            } else if (ch === 91) {
              characterInBrack = true;
            }
          }
          result += escapeRegExpCharacter(ch, previousIsBackslash);
          previousIsBackslash = ch === 92;
        } else {
          result += escapeRegExpCharacter(ch, previousIsBackslash);
          previousIsBackslash = false;
        }
      }
      return "/" + result + "/" + flags;
    }
    return result;
  }
  function escapeAllowedCharacter(code, next) {
    let hex;
    if (code === 8) {
      return "\\b";
    }
    if (code === 12) {
      return "\\f";
    }
    if (code === 9) {
      return "\\t";
    }
    hex = code.toString(16).toUpperCase();
    if (json || code > 255) {
      return "\\u" + "0000".slice(hex.length) + hex;
    } else if (code === 0 && !utils.code.isDecimalDigit(next)) {
      return "\\0";
    } else if (code === 11) {
      return "\\x0B";
    } else {
      return "\\x" + "00".slice(hex.length) + hex;
    }
  }
  function escapeDisallowedCharacter(code) {
    if (code === 92) {
      return "\\\\";
    }
    if (code === 10) {
      return "\\n";
    }
    if (code === 13) {
      return "\\r";
    }
    if (code === 8232) {
      return "\\u2028";
    }
    if (code === 8233) {
      return "\\u2029";
    }
    throw new Error("Incorrectly classified character");
  }
  function escapeDirective(str) {
    let i, iz, code, quote;
    quote = quotes === "double" ? "\"" : "'";
    for (i = 0, iz = str.length; i < iz; ++i) {
      code = str.charCodeAt(i);
      if (code === 39) {
        quote = "\"";
        break;
      } else if (code === 34) {
        quote = "'";
        break;
      } else if (code === 92) {
        ++i;
      }
    }
    return quote + str + quote;
  }
  function escapeString(str) {
    let result = "";
    let i;
    let len;
    let code;
    let singleQuotes = 0;
    let doubleQuotes = 0;
    let single;
    let quote;
    for (i = 0, len = str.length; i < len; ++i) {
      code = str.charCodeAt(i);
      if (code === 39) {
        ++singleQuotes;
      } else if (code === 34) {
        ++doubleQuotes;
      } else if (code === 47 && json) {
        result += "\\";
      } else if (utils.code.isLineTerminator(code) || code === 92) {
        result += escapeDisallowedCharacter(code);
        continue;
      } else if (!utils.code.isIdentifierPartES5(code) && (json && code < 32 || !json && !escapeless && (code < 32 || code > 126))) {
        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
        continue;
      }
      result += String.fromCharCode(code);
    }
    single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
    quote = single ? "'" : "\"";
    if (!(single ? singleQuotes : doubleQuotes)) {
      return quote + result + quote;
    }
    str = result;
    result = quote;
    for (i = 0, len = str.length; i < len; ++i) {
      code = str.charCodeAt(i);
      if (code === 39 && single || code === 34 && !single) {
        result += "\\";
      }
      result += String.fromCharCode(code);
    }
    return result + quote;
  }
  function flattenToString(arr) {
    let i;
    let iz;
    let elem;
    let result = "";
    for (i = 0, iz = arr.length; i < iz; ++i) {
      elem = arr[i];
      result += Array.isArray(elem) ? flattenToString(elem) : elem;
    }
    return result;
  }
  function toSourceNodeWhenNeeded(generated, node) {
    if (!sourceMap) {
      if (Array.isArray(generated)) {
        return flattenToString(generated);
      } else {
        return generated;
      }
    }
    if (node == null) {
      if (generated instanceof SourceNode) {
        return generated;
      } else {
        node = {};
      }
    }
    if (node.loc == null) {
      return new SourceNode(null, null, sourceMap, generated, node.name || null);
    }
    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
  }
  function noEmptySpace() {
    return space || " ";
  }
  function join(left, right) {
    let leftSource, rightSource, leftCharCode, rightCharCode;
    leftSource = toSourceNodeWhenNeeded(left).toString();
    if (leftSource.length === 0) {
      return [right];
    }
    rightSource = toSourceNodeWhenNeeded(right).toString();
    if (rightSource.length === 0) {
      return [left];
    }
    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
    rightCharCode = rightSource.charCodeAt(0);
    if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || utils.code.isIdentifierPartES5(leftCharCode) && utils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
      return [
        left,
        noEmptySpace(),
        right
      ];
    } else if (utils.code.isWhiteSpace(leftCharCode) || utils.code.isLineTerminator(leftCharCode) || utils.code.isWhiteSpace(rightCharCode) || utils.code.isLineTerminator(rightCharCode)) {
      return [
        left,
        right
      ];
    }
    return [
      left,
      space,
      right
    ];
  }
  function addIndent(stmt) {
    return [
      base,
      stmt
    ];
  }
  function withIndent(fn) {
    let previousBase;
    previousBase = base;
    base += indent;
    fn(base);
    base = previousBase;
  }
  function calculateSpaces(str) {
    let i;
    for (i = str.length - 1; i >= 0; --i) {
      if (utils.code.isLineTerminator(str.charCodeAt(i))) {
        break;
      }
    }
    return str.length - 1 - i;
  }
  function adjustMultilineComment(value, specialBase) {
    let array, i, len, line, j, spaces, previousBase, sn;
    array = value.split(/\r\n|[\r\n]/);
    spaces = Number.MAX_VALUE;
    for (i = 1, len = array.length; i < len; ++i) {
      line = array[i];
      j = 0;
      while (j < line.length && utils.code.isWhiteSpace(line.charCodeAt(j))) {
        ++j;
      }
      if (spaces > j) {
        spaces = j;
      }
    }
    if (typeof specialBase !== "undefined") {
      previousBase = base;
      if (array[1][spaces] === "*") {
        specialBase += " ";
      }
      base = specialBase;
    } else {
      if (spaces & 1) {
        --spaces;
      }
      previousBase = base;
    }
    for (i = 1, len = array.length; i < len; ++i) {
      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
      array[i] = sourceMap ? sn.join("") : sn;
    }
    base = previousBase;
    return array.join("\n");
  }
  function generateComment(comment, specialBase) {
    if (comment.type === "Line") {
      if (endsWithLineTerminator(comment.value)) {
        return "//" + comment.value;
      } else {
        let result = "//" + comment.value;
        if (!preserveBlankLines) {
          result += "\n";
        }
        return result;
      }
    }
    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
      return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
    }
    return "/*" + comment.value + "*/";
  }
  function addComments(stmt, result) {
    let i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;
    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
      save = result;
      if (preserveBlankLines) {
        comment = stmt.leadingComments[0];
        result = [];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;
        if (count > 0) {
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }
        prevRange = range;
        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
          comment = stmt.leadingComments[i];
          range = comment.range;
          infix = sourceCode.substring(prevRange[1], range[0]);
          count = (infix.match(/\n/g) || []).length;
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
          prevRange = range;
        }
        suffix = sourceCode.substring(range[1], extRange[1]);
        count = (suffix.match(/\n/g) || []).length;
        result.push(stringRepeat("\n", count));
      } else {
        comment = stmt.leadingComments[0];
        result = [];
        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
          result.push("\n");
        }
        result.push(generateComment(comment));
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push("\n");
        }
        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
          comment = stmt.leadingComments[i];
          fragment = [generateComment(comment)];
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            fragment.push("\n");
          }
          result.push(addIndent(fragment));
        }
      }
      result.push(addIndent(save));
    }
    if (stmt.trailingComments) {
      if (preserveBlankLines) {
        comment = stmt.trailingComments[0];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;
        if (count > 0) {
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }
      } else {
        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([
          base,
          result,
          indent
        ]).toString()));
        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
          comment = stmt.trailingComments[i];
          if (tailingToStatement) {
            if (i === 0) {
              result = [
                result,
                indent
              ];
            } else {
              result = [
                result,
                specialBase
              ];
            }
            result.push(generateComment(comment, specialBase));
          } else {
            result = [
              result,
              addIndent(generateComment(comment))
            ];
          }
          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result = [
              result,
              "\n"
            ];
          }
        }
      }
    }
    return result;
  }
  function generateBlankLines(start, end, result) {
    let j;
    let newlineCount = 0;
    for (j = start; j < end; j++) {
      if (sourceCode[j] === "\n") {
        newlineCount++;
      }
    }
    for (j = 1; j < newlineCount; j++) {
      result.push(newline);
    }
  }
  function parenthesize(text, current, should) {
    if (current < should) {
      return [
        "(",
        text,
        ")"
      ];
    }
    return text;
  }
  function generateVerbatimString(string) {
    let i, iz, result;
    result = string.split(/\r\n|\n/);
    for (i = 1, iz = result.length; i < iz; i++) {
      result[i] = newline + base + result[i];
    }
    return result;
  }
  function generateVerbatim(expr, precedence) {
    let verbatim, result, prec;
    verbatim = expr[extra.verbatim];
    if (typeof verbatim === "string") {
      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
    } else {
      result = generateVerbatimString(verbatim.content);
      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
      result = parenthesize(result, prec, precedence);
    }
    return toSourceNodeWhenNeeded(result, expr);
  }
  function CodeGenerator() {
  }
  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {
    let result;
    let noLeadingComment;
    let that = this;
    noLeadingComment = !extra.comment || !stmt.leadingComments;
    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
      return [
        space,
        this.generateStatement(stmt, flags)
      ];
    }
    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
      return ";";
    }
    withIndent(function () {
      result = [
        newline,
        addIndent(that.generateStatement(stmt, flags))
      ];
    });
    return result;
  };
  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
    let ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
      return [
        result,
        space
      ];
    }
    if (ends) {
      return [
        result,
        base
      ];
    }
    return [
      result,
      newline,
      base
    ];
  };
  function generateIdentifier(node) {
    let identifierName = node.name;
    if (node.type === Syntax.PrivateIdentifier) {
      identifierName = "#" + identifierName;
    }
    return toSourceNodeWhenNeeded(identifierName, node);
  }
  function generateAsyncPrefix(node, spaceRequired) {
    return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
  }
  function generateStarSuffix(node) {
    let isGenerator = node.generator && !extra.moz.starlessGenerator;
    return isGenerator ? "*" + space : "";
  }
  function generateMethodPrefix(prop) {
    let func = prop.value;
    let prefix = "";
    if (func.async) {
      prefix += generateAsyncPrefix(func, !prop.computed);
    }
    if (func.generator) {
      prefix += generateStarSuffix(func) ? "*" : "";
    }
    return prefix;
  }
  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
    if (node.type === Syntax.Identifier) {
      return generateIdentifier(node);
    }
    return this.generateExpression(node, precedence, flags);
  };
  CodeGenerator.prototype.generateFunctionParams = function (node) {
    let i, iz, result, hasDefault;
    hasDefault = false;
    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
      result = [
        generateAsyncPrefix(node, true),
        generateIdentifier(node.params[0])
      ];
    } else {
      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
      result.push("(");
      if (node.defaults) {
        hasDefault = true;
      }
      for (i = 0, iz = node.params.length; i < iz; ++i) {
        if (hasDefault && node.defaults[i]) {
          result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
        } else {
          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
        }
        if (i + 1 < iz) {
          result.push("," + space);
        }
      }
      if (node.rest) {
        if (node.params.length) {
          result.push("," + space);
        }
        result.push("...");
        result.push(generateIdentifier(node.rest));
      }
      result.push(")");
    }
    return result;
  };
  CodeGenerator.prototype.generateFunctionBody = function (node) {
    let result, expr;
    result = this.generateFunctionParams(node);
    if (node.type === Syntax.ArrowFunctionExpression) {
      result.push(space);
      result.push("=>");
    }
    if (node.expression) {
      result.push(space);
      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
      if (expr.toString().charAt(0) === "{") {
        expr = [
          "(",
          expr,
          ")"
        ];
      }
      result.push(expr);
    } else {
      result.push(this.maybeBlock(node.body, S_TTFF));
    }
    return result;
  };
  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
    let result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("];
    let that = this;
    withIndent(function () {
      if (stmt.left.type === Syntax.VariableDeclaration) {
        withIndent(function () {
          result.push(stmt.left.kind + noEmptySpace());
          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
        });
      } else {
        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
      }
      result = join(result, operator);
      result = [
        join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)),
        ")"
      ];
    });
    result.push(this.maybeBlock(stmt.body, flags));
    return result;
  };
  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
    let result = [];
    if (computed) {
      result.push("[");
    }
    result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
    if (computed) {
      result.push("]");
    }
    return result;
  };
  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
    if (Precedence.Assignment < precedence) {
      flags |= F_ALLOW_IN;
    }
    return parenthesize([
      this.generateExpression(left, Precedence.Call, flags),
      space + operator + space,
      this.generateExpression(right, Precedence.Assignment, flags)
    ], Precedence.Assignment, precedence);
  };
  CodeGenerator.prototype.semicolon = function (flags) {
    if (!semicolons && flags & F_SEMICOLON_OPT) {
      return "";
    }
    return ";";
  };
  CodeGenerator.Statement = {
    BlockStatement: function (stmt, flags) {
      let range;
      let content;
      let result = [
        "{",
        newline
      ];
      let that = this;
      withIndent(function () {
        if (stmt.body.length === 0 && preserveBlankLines) {
          range = stmt.range;
          if (range[1] - range[0] > 2) {
            content = sourceCode.substring(range[0] + 1, range[1] - 1);
            if (content[0] === "\n") {
              result = ["{"];
            }
            result.push(content);
          }
        }
        let i, iz, fragment, bodyFlags;
        bodyFlags = S_TFFF;
        if (flags & F_FUNC_BODY) {
          bodyFlags |= F_DIRECTIVE_CTX;
        }
        for (i = 0, iz = stmt.body.length; i < iz; ++i) {
          if (preserveBlankLines) {
            if (i === 0) {
              if (stmt.body[0].leadingComments) {
                range = stmt.body[0].leadingComments[0].extendedRange;
                content = sourceCode.substring(range[0], range[1]);
                if (content[0] === "\n") {
                  result = ["{"];
                }
              }
              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
              }
            }
            if (i > 0) {
              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
              }
            }
          }
          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (stmt.body[i].leadingComments && preserveBlankLines) {
            fragment = that.generateStatement(stmt.body[i], bodyFlags);
          } else {
            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
          }
          result.push(fragment);
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines && i < iz - 1) {
              if (!stmt.body[i + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }
          if (preserveBlankLines) {
            if (i === iz - 1) {
              if (!stmt.body[i].trailingComments) {
                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
              }
            }
          }
        }
      });
      result.push(addIndent("}"));
      return result;
    },
    BreakStatement: function (stmt, flags) {
      if (stmt.label) {
        return "break " + stmt.label.name + this.semicolon(flags);
      }
      return "break" + this.semicolon(flags);
    },
    ContinueStatement: function (stmt, flags) {
      if (stmt.label) {
        return "continue " + stmt.label.name + this.semicolon(flags);
      }
      return "continue" + this.semicolon(flags);
    },
    ClassBody: function (stmt, flags) {
      let result = [
        "{",
        newline
      ];
      let that = this;
      withIndent(function (indent) {
        let i, iz;
        for (i = 0, iz = stmt.body.length; i < iz; ++i) {
          result.push(indent);
          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
          if (i + 1 < iz) {
            result.push(newline);
          }
        }
      });
      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(base);
      result.push("}");
      return result;
    },
    ClassDeclaration: function (stmt, flags) {
      let result = [];
      let fragment;
      if (stmt.decorators.length) {
        for (let dec of stmt.decorators) {
          result.push(this.generateStatement(dec));
          result.push(base);
        }
      }
      result.push("class");
      if (stmt.id) {
        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
      }
      if (stmt.superClass) {
        fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
        result = join(result, fragment);
      }
      result.push(space);
      result.push(this.generateStatement(stmt.body, S_TFFT));
      return result;
    },
    DirectiveStatement: function (stmt, flags) {
      if (extra.raw && stmt.raw) {
        return stmt.raw + this.semicolon(flags);
      }
      return escapeDirective(stmt.directive) + this.semicolon(flags);
    },
    DoWhileStatement: function (stmt, flags) {
      let result = join("do", this.maybeBlock(stmt.body, S_TFFF));
      result = this.maybeBlockSuffix(stmt.body, result);
      return join(result, [
        "while" + space + "(",
        this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
        ")" + this.semicolon(flags)
      ]);
    },
    CatchClause: function (stmt, flags) {
      let result;
      let that = this;
      withIndent(function () {
        let guard;
        if (stmt.param) {
          result = [
            "catch" + space + "(",
            that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
            ")"
          ];
          if (stmt.guard) {
            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
            result.splice(2, 0, " if ", guard);
          }
        } else {
          result = ["catch"];
        }
      });
      result.push(this.maybeBlock(stmt.body, S_TFFF));
      return result;
    },
    DebuggerStatement: function (stmt, flags) {
      return "debugger" + this.semicolon(flags);
    },
    EmptyStatement: function (stmt, flags) {
      return ";";
    },
    ExportDefaultDeclaration: function (stmt, flags) {
      let result = ["export"];
      let bodyFlags;
      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
      result = join(result, "default");
      if (isStatement(stmt.declaration)) {
        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
      } else {
        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
      }
      return result;
    },
    ExportNamedDeclaration: function (stmt, flags) {
      let result = ["export"];
      let bodyFlags;
      let that = this;
      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
      if (stmt.declaration) {
        return join(result, this.generateStatement(stmt.declaration, bodyFlags));
      }
      if (stmt.specifiers) {
        if (stmt.specifiers.length === 0) {
          result = join(result, "{" + space + "}");
        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
        } else {
          result = join(result, "{");
          withIndent(function (indent) {
            let i, iz;
            result.push(newline);
            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
              result.push(indent);
              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push("," + newline);
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base + "}");
        }
        if (stmt.source) {
          result = join(result, [
            "from" + space,
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]);
        } else {
          result.push(this.semicolon(flags));
        }
      }
      return result;
    },
    ExportAllDeclaration: function (stmt, flags) {
      let result = [
        "export" + space,
        "*" + space
      ];
      if (stmt.exported) {
        result.push("as " + stmt.exported.name + " ");
      }
      result = join(result, [
        "from" + space,
        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
        this.semicolon(flags)
      ]);
      return result;
    },
    ExpressionStatement: function (stmt, flags) {
      let result, fragment;
      function isClassPrefixed(fragment) {
        let code;
        if (fragment.slice(0, 5) !== "class") {
          return false;
        }
        code = fragment.charCodeAt(5);
        return code === 123 || utils.code.isWhiteSpace(code) || utils.code.isLineTerminator(code);
      }
      function isFunctionPrefixed(fragment) {
        let code;
        if (fragment.slice(0, 8) !== "function") {
          return false;
        }
        code = fragment.charCodeAt(8);
        return code === 40 || utils.code.isWhiteSpace(code) || code === 42 || utils.code.isLineTerminator(code);
      }
      function isAsyncPrefixed(fragment) {
        let code, i, iz;
        if (fragment.slice(0, 5) !== "async") {
          return false;
        }
        if (!utils.code.isWhiteSpace(fragment.charCodeAt(5))) {
          return false;
        }
        for (i = 6, iz = fragment.length; i < iz; ++i) {
          if (!utils.code.isWhiteSpace(fragment.charCodeAt(i))) {
            break;
          }
        }
        if (i === iz) {
          return false;
        }
        if (fragment.slice(i, i + 8) !== "function") {
          return false;
        }
        code = fragment.charCodeAt(i + 8);
        return code === 40 || utils.code.isWhiteSpace(code) || code === 42 || utils.code.isLineTerminator(code);
      }
      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
      fragment = toSourceNodeWhenNeeded(result).toString();
      if (fragment.charCodeAt(0) === 123 || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
        result = [
          "(",
          result,
          ")" + this.semicolon(flags)
        ];
      } else {
        result.push(this.semicolon(flags));
      }
      return result;
    },
    ImportDeclaration: function (stmt, flags) {
      let result;
      let cursor;
      let that = this;
      if (stmt.specifiers.length === 0) {
        return [
          "import",
          space,
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ];
      }
      result = ["import"];
      cursor = 0;
      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
        ++cursor;
      }
      if (stmt.specifiers[cursor]) {
        if (cursor !== 0) {
          result.push(",");
        }
        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
          result = join(result, [
            space,
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]);
        } else {
          result.push(space + "{");
          if (stmt.specifiers.length - cursor === 1) {
            result.push(space);
            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
            result.push(space + "}" + space);
          } else {
            withIndent(function (indent) {
              let i, iz;
              result.push(newline);
              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                result.push(indent);
                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
              }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            result.push(base + "}" + space);
          }
        }
      }
      result = join(result, [
        "from" + space,
        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
        this.semicolon(flags)
      ]);
      return result;
    },
    VariableDeclarator: function (stmt, flags) {
      let itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
      if (stmt.init) {
        return [
          this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
          space,
          "=",
          space,
          this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
        ];
      }
      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
    },
    VariableDeclaration: function (stmt, flags) {
      let result;
      let i;
      let iz;
      let node;
      let bodyFlags;
      let that = this;
      result = [stmt.kind];
      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
      function block() {
        node = stmt.declarations[0];
        if (extra.comment && node.leadingComments) {
          result.push("\n");
          result.push(addIndent(that.generateStatement(node, bodyFlags)));
        } else {
          result.push(noEmptySpace());
          result.push(that.generateStatement(node, bodyFlags));
        }
        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
          node = stmt.declarations[i];
          if (extra.comment && node.leadingComments) {
            result.push("," + newline);
            result.push(addIndent(that.generateStatement(node, bodyFlags)));
          } else {
            result.push("," + space);
            result.push(that.generateStatement(node, bodyFlags));
          }
        }
      }
      if (stmt.declarations.length > 1) {
        withIndent(block);
      } else {
        block();
      }
      result.push(this.semicolon(flags));
      return result;
    },
    StaticBlock: function (stmt, flags) {
      return [
        "static" + space,
        this.BlockStatement(stmt, flags)
      ];
    },
    ThrowStatement: function (stmt, flags) {
      return [
        join("throw", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),
        this.semicolon(flags)
      ];
    },
    TryStatement: function (stmt, flags) {
      let result, i, iz, guardedHandlers;
      result = [
        "try",
        this.maybeBlock(stmt.block, S_TFFF)
      ];
      result = this.maybeBlockSuffix(stmt.block, result);
      if (stmt.handlers) {
        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
          }
        }
      } else {
        guardedHandlers = stmt.guardedHandlers || [];
        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
          }
        }
        if (stmt.handler) {
          if (Array.isArray(stmt.handler)) {
            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
              }
            }
          } else {
            result = join(result, this.generateStatement(stmt.handler, S_TFFF));
            if (stmt.finalizer) {
              result = this.maybeBlockSuffix(stmt.handler.body, result);
            }
          }
        }
      }
      if (stmt.finalizer) {
        result = join(result, [
          "finally",
          this.maybeBlock(stmt.finalizer, S_TFFF)
        ]);
      }
      return result;
    },
    SwitchStatement: function (stmt, flags) {
      let result;
      let fragment;
      let i;
      let iz;
      let bodyFlags;
      let that = this;
      withIndent(function () {
        result = [
          "switch" + space + "(",
          that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
          ")" + space + "{" + newline
        ];
      });
      if (stmt.cases) {
        bodyFlags = S_TFFF;
        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
          result.push(fragment);
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
        }
      }
      result.push(addIndent("}"));
      return result;
    },
    SwitchCase: function (stmt, flags) {
      let result;
      let fragment;
      let i;
      let iz;
      let bodyFlags;
      let that = this;
      withIndent(function () {
        if (stmt.test) {
          result = [
            join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
            ":"
          ];
        } else {
          result = ["default:"];
        }
        i = 0;
        iz = stmt.consequent.length;
        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
          result.push(fragment);
          i = 1;
        }
        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        bodyFlags = S_TFFF;
        for (; i < iz; ++i) {
          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
          result.push(fragment);
          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
        }
      });
      return result;
    },
    IfStatement: function (stmt, flags) {
      let result;
      let bodyFlags;
      let semicolonOptional;
      let that = this;
      withIndent(function () {
        result = [
          "if" + space + "(",
          that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
          ")"
        ];
      });
      semicolonOptional = flags & F_SEMICOLON_OPT;
      bodyFlags = S_TFFF;
      if (semicolonOptional) {
        bodyFlags |= F_SEMICOLON_OPT;
      }
      if (stmt.alternate) {
        result.push(this.maybeBlock(stmt.consequent, S_TFFF));
        result = this.maybeBlockSuffix(stmt.consequent, result);
        if (stmt.alternate.type === Syntax.IfStatement) {
          result = join(result, [
            "else ",
            this.generateStatement(stmt.alternate, bodyFlags)
          ]);
        } else {
          result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
        }
      } else {
        result.push(this.maybeBlock(stmt.consequent, bodyFlags));
      }
      return result;
    },
    ForStatement: function (stmt, flags) {
      let result;
      let that = this;
      withIndent(function () {
        result = ["for" + space + "("];
        if (stmt.init) {
          if (stmt.init.type === Syntax.VariableDeclaration) {
            result.push(that.generateStatement(stmt.init, S_FFFF));
          } else {
            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
            result.push(";");
          }
        } else {
          result.push(";");
        }
        if (stmt.test) {
          result.push(space);
          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
          result.push(";");
        } else {
          result.push(";");
        }
        if (stmt.update) {
          result.push(space);
          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
          result.push(")");
        } else {
          result.push(")");
        }
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    },
    ForInStatement: function (stmt, flags) {
      return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
    },
    ForOfStatement: function (stmt, flags) {
      return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
    },
    LabeledStatement: function (stmt, flags) {
      return [
        stmt.label.name + ":",
        this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)
      ];
    },
    Program: function (stmt, flags) {
      let result, fragment, i, iz, bodyFlags;
      iz = stmt.body.length;
      result = [safeConcatenation && iz > 0 ? "\n" : ""];
      bodyFlags = S_TFTF;
      for (i = 0; i < iz; ++i) {
        if (!safeConcatenation && i === iz - 1) {
          bodyFlags |= F_SEMICOLON_OPT;
        }
        if (preserveBlankLines) {
          if (i === 0) {
            if (!stmt.body[0].leadingComments) {
              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
            }
          }
          if (i > 0) {
            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
            }
          }
        }
        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
        result.push(fragment);
        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          if (preserveBlankLines) {
            if (!stmt.body[i + 1].leadingComments) {
              result.push(newline);
            }
          } else {
            result.push(newline);
          }
        }
        if (preserveBlankLines) {
          if (i === iz - 1) {
            if (!stmt.body[i].trailingComments) {
              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
            }
          }
        }
      }
      return result;
    },
    FunctionDeclaration: function (stmt, flags) {
      return [
        generateAsyncPrefix(stmt, true),
        "function",
        generateStarSuffix(stmt) || noEmptySpace(),
        stmt.id ? generateIdentifier(stmt.id) : "",
        this.generateFunctionBody(stmt)
      ];
    },
    ReturnStatement: function (stmt, flags) {
      if (stmt.argument) {
        return [
          join("return", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),
          this.semicolon(flags)
        ];
      }
      return ["return" + this.semicolon(flags)];
    },
    WhileStatement: function (stmt, flags) {
      let result;
      let that = this;
      withIndent(function () {
        result = [
          "while" + space + "(",
          that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
          ")"
        ];
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    },
    WithStatement: function (stmt, flags) {
      let result;
      let that = this;
      withIndent(function () {
        result = [
          "with" + space + "(",
          that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
          ")"
        ];
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    }
  };
  merge(CodeGenerator.prototype, CodeGenerator.Statement);
  CodeGenerator.Expression = {
    SequenceExpression: function (expr, precedence, flags) {
      let result, i, iz;
      if (Precedence.Sequence < precedence) {
        flags |= F_ALLOW_IN;
      }
      result = [];
      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
        if (i + 1 < iz) {
          result.push("," + space);
        }
      }
      return parenthesize(result, Precedence.Sequence, precedence);
    },
    AssignmentExpression: function (expr, precedence, flags) {
      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
    },
    ArrowFunctionExpression: function (expr, precedence, flags) {
      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
    },
    ConditionalExpression: function (expr, precedence, flags) {
      if (Precedence.Conditional < precedence) {
        flags |= F_ALLOW_IN;
      }
      return parenthesize([
        this.generateExpression(expr.test, Precedence.LogicalOR, flags),
        space + "?" + space,
        this.generateExpression(expr.consequent, Precedence.Assignment, flags),
        space + ":" + space,
        this.generateExpression(expr.alternate, Precedence.Assignment, flags)
      ], Precedence.Conditional, precedence);
    },
    LogicalExpression: function (expr, precedence, flags) {
      return this.BinaryExpression(expr, precedence, flags);
    },
    BinaryExpression: function (expr, precedence, flags) {
      let result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
      currentPrecedence = BinaryPrecedence[expr.operator];
      leftPrecedence = currentPrecedence;
      rightPrecedence = currentPrecedence + 1;
      switch (expr.operator) {
      case "**":
        leftPrecedence = Precedence.Postfix;
        rightPrecedence = currentPrecedence;
        break;
      case "??":
        if (expr.left.type === Syntax.LogicalExpression && (expr.left.operator === "||" || expr.left.operator === "&&")) {
          leftPrecedence = BinaryPrecedence[expr.left.operator] + 1;
        }
        if (expr.right.type === Syntax.LogicalExpression && expr.right.operator === "&&") {
          rightPrecedence = BinaryPrecedence[expr.right.operator] + 1;
        }
        break;
      case "||":
        if (expr.left.type === Syntax.LogicalExpression && expr.left.operator === "??") {
          leftPrecedence = BinaryPrecedence[expr.left.operator] + 1;
        }
        break;
      }
      if (currentPrecedence < precedence) {
        flags |= F_ALLOW_IN;
      }
      fragment = this.generateExpression(expr.left, leftPrecedence, flags);
      leftSource = fragment.toString();
      if (leftSource.charCodeAt(leftSource.length - 1) === 47 && utils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
        result = [
          fragment,
          noEmptySpace(),
          expr.operator
        ];
      } else {
        result = join(fragment, expr.operator);
      }
      fragment = this.generateExpression(expr.right, rightPrecedence, flags);
      if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
        result.push(noEmptySpace());
        result.push(fragment);
      } else {
        result = join(result, fragment);
      }
      if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
        return [
          "(",
          result,
          ")"
        ];
      }
      return parenthesize(result, currentPrecedence, precedence);
    },
    CallExpression: function (expr, precedence, flags) {
      let result, i, iz, isIIFE;
      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
      if (expr.optional) {
        result.push("?.");
      }
      result.push("(");
      for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
        result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
        if (i + 1 < iz) {
          result.push("," + space);
        }
      }
      result.push(")");
      if (!(flags & F_ALLOW_CALL)) {
        return [
          "(",
          result,
          ")"
        ];
      }
      isIIFE = expr.callee.id === null && expr.callee.params.length === 0;
      return isIIFE ? parenthesize(result, precedence, Precedence.Call) : parenthesize(result, Precedence.Call, precedence);
    },
    ChainExpression: function (expr, precedence, flags) {
      if (Precedence.OptionalChaining < precedence) {
        flags |= F_ALLOW_CALL;
      }
      let result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
      return parenthesize(result, Precedence.OptionalChaining, precedence);
    },
    NewExpression: function (expr, precedence, flags) {
      let result, length, i, iz, itemFlags;
      length = expr["arguments"].length;
      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
      result = join("new", this.generateExpression(expr.callee, Precedence.New, itemFlags));
      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
        result.push("(");
        for (i = 0, iz = length; i < iz; ++i) {
          result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
          if (i + 1 < iz) {
            result.push("," + space);
          }
        }
        result.push(")");
      }
      return parenthesize(result, Precedence.New, precedence);
    },
    MemberExpression: function (expr, precedence, flags) {
      let result, fragment;
      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
      if (expr.computed) {
        if (expr.optional) {
          result.push("?.");
        }
        result.push("[");
        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
        result.push("]");
      } else {
        if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && utils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
            result.push(" ");
          }
        }
        result.push(expr.optional ? "?." : ".");
        result.push(generateIdentifier(expr.property));
      }
      return parenthesize(result, Precedence.Member, precedence);
    },
    MetaProperty: function (expr, precedence, flags) {
      let result;
      result = [];
      result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
      result.push(".");
      result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
      return parenthesize(result, Precedence.Member, precedence);
    },
    UnaryExpression: function (expr, precedence, flags) {
      let result, fragment, rightCharCode, leftSource, leftCharCode;
      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
      if (space === "") {
        result = join(expr.operator, fragment);
      } else {
        result = [expr.operator];
        if (expr.operator.length > 2) {
          result = join(result, fragment);
        } else {
          leftSource = toSourceNodeWhenNeeded(result).toString();
          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
          rightCharCode = fragment.toString().charCodeAt(0);
          if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || utils.code.isIdentifierPartES5(leftCharCode) && utils.code.isIdentifierPartES5(rightCharCode)) {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result.push(fragment);
          }
        }
      }
      return parenthesize(result, Precedence.Unary, precedence);
    },
    YieldExpression: function (expr, precedence, flags) {
      let result;
      if (expr.delegate) {
        result = "yield*";
      } else {
        result = "yield";
      }
      if (expr.argument) {
        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
      }
      return parenthesize(result, Precedence.Yield, precedence);
    },
    AwaitExpression: function (expr, precedence, flags) {
      let result = join(expr.all ? "await*" : "await", this.generateExpression(expr.argument, Precedence.Await, E_TTT));
      return parenthesize(result, Precedence.Await, precedence);
    },
    UpdateExpression: function (expr, precedence, flags) {
      if (expr.prefix) {
        return parenthesize([
          expr.operator,
          this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
        ], Precedence.Unary, precedence);
      }
      return parenthesize([
        this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
        expr.operator
      ], Precedence.Postfix, precedence);
    },
    FunctionExpression: function (expr, precedence, flags) {
      let result = [
        generateAsyncPrefix(expr, true),
        "function"
      ];
      if (expr.id) {
        result.push(generateStarSuffix(expr) || noEmptySpace());
        result.push(generateIdentifier(expr.id));
      } else {
        result.push(generateStarSuffix(expr) || space);
      }
      result.push(this.generateFunctionBody(expr));
      return result;
    },
    ArrayPattern: function (expr, precedence, flags) {
      return this.ArrayExpression(expr, precedence, flags, true);
    },
    ArrayExpression: function (expr, precedence, flags, isPattern) {
      let result;
      let multiline;
      let that = this;
      if (!expr.elements.length) {
        return "[]";
      }
      multiline = isPattern ? false : expr.elements.length > 1;
      result = [
        "[",
        multiline ? newline : ""
      ];
      withIndent(function (indent) {
        let i, iz;
        for (i = 0, iz = expr.elements.length; i < iz; ++i) {
          if (!expr.elements[i]) {
            if (multiline) {
              result.push(indent);
            }
            if (i + 1 === iz) {
              result.push(",");
            }
          } else {
            result.push(multiline ? indent : "");
            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
          }
          if (i + 1 < iz) {
            result.push("," + (multiline ? newline : space));
          }
        }
      });
      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(multiline ? base : "");
      result.push("]");
      return result;
    },
    RestElement: function (expr, precedence, flags) {
      return "..." + this.generatePattern(expr.argument);
    },
    ClassExpression: function (expr, precedence, flags) {
      let result, fragment;
      result = ["class"];
      if (expr.id) {
        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
      }
      if (expr.superClass) {
        fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
        result = join(result, fragment);
      }
      result.push(space);
      result.push(this.generateStatement(expr.body, S_TFFT));
      return result;
    },
    MethodDefinition: function (expr, precedence, flags) {
      let result = [];
      let fragment;
      if (expr.decorators.length) {
        for (let dec of expr.decorators) {
          result.push(this.generateStatement(dec));
          result.push(base);
        }
      }
      if (expr["static"]) {
        result.push("static" + space);
      }
      if (expr.kind === "get" || expr.kind === "set") {
        fragment = [
          join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
          this.generateFunctionBody(expr.value)
        ];
      } else {
        fragment = [
          generateMethodPrefix(expr),
          this.generatePropertyKey(expr.key, expr.computed),
          this.generateFunctionBody(expr.value)
        ];
      }
      return join(result, fragment);
    },
    PrivateIdentifier: function (expr, precedence, flags) {
      return generateIdentifier(expr);
    },
    Decorator: function (expr, precedence, flags) {
      return [
        "@",
        this.generateExpression(expr.expression, Precedence.Call, F_ALLOW_CALL),
        newline
      ];
    },
    Property: function (expr, precedence, flags) {
      if (expr.kind === "get" || expr.kind === "set") {
        return [
          expr.kind,
          noEmptySpace(),
          this.generatePropertyKey(expr.key, expr.computed),
          this.generateFunctionBody(expr.value)
        ];
      }
      if (expr.shorthand) {
        if (expr.value.type === "AssignmentPattern") {
          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
        }
        return this.generatePropertyKey(expr.key, expr.computed);
      }
      if (expr.method) {
        return [
          generateMethodPrefix(expr),
          this.generatePropertyKey(expr.key, expr.computed),
          this.generateFunctionBody(expr.value)
        ];
      }
      return [
        this.generatePropertyKey(expr.key, expr.computed),
        ":" + space,
        this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
      ];
    },
    PropertyDefinition: function (expr, precedence, flags) {
      let result;
      if (expr.static) {
        result = ["static "];
      } else {
        result = [];
      }
      result.push(this.generatePropertyKey(expr.key, expr.computed));
      if (expr.value) {
        result.push(space + "=" + space);
        result.push(this.generateExpression(expr.value, Precedence.Assignment, E_TTT));
      }
      result.push(this.semicolon(flags));
      return result;
    },
    ObjectExpression: function (expr, precedence, flags) {
      let multiline;
      let result;
      let fragment;
      let that = this;
      if (!expr.properties.length) {
        return "{}";
      }
      multiline = expr.properties.length > 1;
      withIndent(function () {
        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
      });
      if (!multiline) {
        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          return [
            "{",
            space,
            fragment,
            space,
            "}"
          ];
        }
      }
      withIndent(function (indent) {
        let i, iz;
        result = [
          "{",
          newline,
          indent,
          fragment
        ];
        if (multiline) {
          result.push("," + newline);
          for (i = 1, iz = expr.properties.length; i < iz; ++i) {
            result.push(indent);
            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
            if (i + 1 < iz) {
              result.push("," + newline);
            }
          }
        }
      });
      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(base);
      result.push("}");
      return result;
    },
    AssignmentPattern: function (expr, precedence, flags) {
      return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
    },
    ObjectPattern: function (expr, precedence, flags) {
      let result;
      let i;
      let iz;
      let multiline;
      let property;
      let that = this;
      if (!expr.properties.length) {
        return "{}";
      }
      multiline = false;
      if (expr.properties.length === 1) {
        property = expr.properties[0];
        if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
          multiline = true;
        }
      } else {
        for (i = 0, iz = expr.properties.length; i < iz; ++i) {
          property = expr.properties[i];
          if (property.type === Syntax.Property && !property.shorthand) {
            multiline = true;
            break;
          }
        }
      }
      result = [
        "{",
        multiline ? newline : ""
      ];
      withIndent(function (indent) {
        let i, iz;
        for (i = 0, iz = expr.properties.length; i < iz; ++i) {
          result.push(multiline ? indent : "");
          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
          if (i + 1 < iz) {
            result.push("," + (multiline ? newline : space));
          }
        }
      });
      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(multiline ? base : "");
      result.push("}");
      return result;
    },
    ThisExpression: function (expr, precedence, flags) {
      return "this";
    },
    Super: function (expr, precedence, flags) {
      return "super";
    },
    Identifier: function (expr, precedence, flags) {
      return generateIdentifier(expr);
    },
    ImportDefaultSpecifier: function (expr, precedence, flags) {
      return generateIdentifier(expr.id || expr.local);
    },
    ImportNamespaceSpecifier: function (expr, precedence, flags) {
      let result = ["*"];
      let id = expr.id || expr.local;
      if (id) {
        result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
      }
      return result;
    },
    ImportSpecifier: function (expr, precedence, flags) {
      let imported = expr.imported;
      let result = [imported.name];
      let local = expr.local;
      if (local && local.name !== imported.name) {
        result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
      }
      return result;
    },
    ExportSpecifier: function (expr, precedence, flags) {
      let local = expr.local;
      let result = [local.name];
      let exported = expr.exported;
      if (exported && exported.name !== local.name) {
        result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
      }
      return result;
    },
    Literal: function (expr, precedence, flags) {
      let raw;
      if (expr.hasOwnProperty("raw") && parse && extra.raw) {
        try {
          raw = parse(expr.raw).body[0].expression;
          if (raw.type === Syntax.Literal) {
            if (raw.value === expr.value) {
              return expr.raw;
            }
          }
        } catch (e) {
        }
      }
      if (expr.regex) {
        return "/" + expr.regex.pattern + "/" + expr.regex.flags;
      }
      if (typeof expr.bigint === "string" && expr.raw) {
        return expr.raw;
      }
      if (expr.value === null) {
        return "null";
      }
      if (typeof expr.value === "string") {
        return escapeString(expr.value);
      }
      if (typeof expr.value === "number") {
        if (expr.raw && expr.raw.indexOf("_") !== -1) {
          return expr.raw;
        }
        return generateNumber(expr.value);
      }
      if (typeof expr.value === "boolean") {
        return expr.value ? "true" : "false";
      }
      return generateRegExp(expr.value);
    },
    GeneratorExpression: function (expr, precedence, flags) {
      return this.ComprehensionExpression(expr, precedence, flags);
    },
    ComprehensionExpression: function (expr, precedence, flags) {
      let result;
      let i;
      let iz;
      let fragment;
      let that = this;
      result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
      if (extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result.push(fragment);
      }
      if (expr.blocks) {
        withIndent(function () {
          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
              result = join(result, fragment);
            } else {
              result.push(fragment);
            }
          }
        });
      }
      if (expr.filter) {
        result = join(result, "if" + space);
        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
        result = join(result, [
          "(",
          fragment,
          ")"
        ]);
      }
      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result = join(result, fragment);
      }
      result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
      return result;
    },
    ComprehensionBlock: function (expr, precedence, flags) {
      let fragment;
      if (expr.left.type === Syntax.VariableDeclaration) {
        fragment = [
          expr.left.kind,
          noEmptySpace(),
          this.generateStatement(expr.left.declarations[0], S_FFFF)
        ];
      } else {
        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
      }
      fragment = join(fragment, expr.of ? "of" : "in");
      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
      return [
        "for" + space + "(",
        fragment,
        ")"
      ];
    },
    SpreadElement: function (expr, precedence, flags) {
      return [
        "...",
        this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
      ];
    },
    TaggedTemplateExpression: function (expr, precedence, flags) {
      let itemFlags = E_TTF;
      if (!(flags & F_ALLOW_CALL)) {
        itemFlags = E_TFF;
      }
      let result = [
        this.generateExpression(expr.tag, Precedence.Call, itemFlags),
        this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
      ];
      return parenthesize(result, Precedence.TaggedTemplate, precedence);
    },
    TemplateElement: function (expr, precedence, flags) {
      return expr.value.raw;
    },
    TemplateLiteral: function (expr, precedence, flags) {
      let result, i, iz;
      result = ["`"];
      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
        if (i + 1 < iz) {
          result.push("${" + space);
          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
          result.push(space + "}");
        }
      }
      result.push("`");
      return result;
    },
    ModuleSpecifier: function (expr, precedence, flags) {
      return this.Literal(expr, precedence, flags);
    },
    ImportExpression: function (expr, precedence, flag) {
      return parenthesize([
        "import(",
        this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
        ")"
      ], Precedence.Call, precedence);
    }
  };
  merge(CodeGenerator.prototype, CodeGenerator.Expression);
  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
    let result, type;
    type = expr.type || Syntax.Property;
    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
      return generateVerbatim(expr, precedence);
    }
    result = this[type](expr, precedence, flags);
    if (extra.comment) {
      result = addComments(expr, result);
    }
    return toSourceNodeWhenNeeded(result, expr);
  };
  CodeGenerator.prototype.generateStatement = function (stmt, flags) {
    let result, fragment;
    result = this[stmt.type](stmt, flags);
    if (extra.comment) {
      result = addComments(stmt, result);
    }
    fragment = toSourceNodeWhenNeeded(result).toString();
    if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
    }
    return toSourceNodeWhenNeeded(result, stmt);
  };
  function generateInternal(node) {
    let codegen;
    codegen = new CodeGenerator();
    if (isStatement(node)) {
      return codegen.generateStatement(node, S_TFFF);
    }
    if (isExpression(node)) {
      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
    }
    throw new Error("Unknown node type: " + node.type);
  }
  function generate(node, options) {
    let defaultOptions = getDefaultOptions();
    let result;
    let pair;
    if (options != null) {
      if (typeof options.indent === "string") {
        defaultOptions.format.indent.style = options.indent;
      }
      if (typeof options.base === "number") {
        defaultOptions.format.indent.base = options.base;
      }
      options = updateDeeply(defaultOptions, options);
      indent = options.format.indent.style;
      if (typeof options.base === "string") {
        base = options.base;
      } else {
        base = stringRepeat(indent, options.format.indent.base);
      }
    } else {
      options = defaultOptions;
      indent = options.format.indent.style;
      base = stringRepeat(indent, options.format.indent.base);
    }
    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = json ? false : options.format.hexadecimal;
    quotes = json ? "double" : options.format.quotes;
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;
    if (options.format.compact) {
      newline = space = indent = base = "";
    }
    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = json ? null : options.parse;
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
    extra = options;
    if (sourceMap) {
      if (!exports.browser) {
        SourceNode = requireSourceMap().SourceNode;
      } else {
        SourceNode = global.sourceMap.SourceNode;
      }
    }
    result = generateInternal(node);
    if (!sourceMap) {
      pair = {
        code: result.toString(),
        map: null
      };
      return options.sourceMapWithCode ? pair : pair.code;
    }
    pair = result.toStringWithSourceMap({
      file: options.file,
      sourceRoot: options.sourceMapRoot
    });
    if (options.sourceContent) {
      pair.map.setSourceContent(options.sourceMap, options.sourceContent);
    }
    if (options.sourceMapWithCode) {
      return pair;
    }
    return pair.map.toString();
  }
  FORMAT_MINIFY = {
    indent: {
      style: "",
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: "auto",
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };
  const exports = {};
  FORMAT_DEFAULTS = getDefaultOptions().format;
  exports.generate = generate;
  exports.attachComments = estraverse.attachComments;
  exports.Precedence = updateDeeply({}, Precedence);
  exports.browser = false;
  exports.FORMAT_MINIFY = FORMAT_MINIFY;
  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
  return exports;
}
const es = ESCODEGEN();
function stringify(node, opts = {}) {
  const optsIndent = opts && opts.format && opts.format.indent || {};
  const indent = {
    style: "  ",
    base: 0,
    adjustMultilineComment: false,
    optsIndent
  };
  const optsFormat = opts && opts.format || {};
  const format = {
    indent,
    quotes: "double",
    ...dissoc(optsFormat, ["indent"])
  };
  opts = {
    format,
    comment: false,
    ...dissoc(opts, ["format"])
  };
  return es.generate(node, opts);
}

var acorn$2 = {exports: {}};

var hasRequiredAcorn$1;
function requireAcorn$1() {
  if (hasRequiredAcorn$1)
    return acorn$2.exports;
  hasRequiredAcorn$1 = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    }(commonjsGlobal, function (exports) {
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙ\u0560-\u0588א-ת\u05EF-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘ\u0860-\u086Aࢠ-ࢴࢶ-\u08C7ऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱ\u09FCਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲ\u0D04-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄ\u0E86-ຊ\u0E8C-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-\u1878ᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈ\u1C90-\u1CBA\u1CBD-\u1CBFᳩ-ᳬᳮ-ᳳᳵᳶ\u1CFAᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ\u2118-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ\u309B-ゟァ-ヺー-ヿㄅ-\u312Fㄱ-ㆎㆠ-\u31BFㇰ-ㇿ㐀-\u4DBF一-\u9FFCꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-\uA7BF\uA7C2-\uA7CA\uA7F5-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽ\uA8FEꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-\uAB69ꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var nonASCIIidentifierChars = "‌‍\xB7̀-ͯ\u0387҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳\u07FDࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛\u08D3-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯\u09FEਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯\u0AFA-\u0AFFଁ-ଃ଼ା-ୄେୈୋ-୍\u0B55-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-\u0C04ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯\u0D00-ഃ\u0D3B\u0D3Cാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯\u0D81-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟\u1369-\u1371ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-\u19DAᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽\u1ABF\u1AC0ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴\u1CF7-᳹᷀-\u1DF9᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ\uA82Cꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱\uA8FF-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
      ];
      var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
      ];
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) {
            return false;
          }
          pos += set[i + 1];
          if (pos >= code) {
            return true;
          }
        }
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, {
          beforeExpr: true,
          binop: prec
        });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords$1 = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords$1[name] = new TokenType(name, options);
      }
      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
          beforeExpr: true,
          startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
          beforeExpr: true,
          startsExpr: true
        }),
        eq: new TokenType("=", {
          beforeExpr: true,
          isAssign: true
        }),
        assign: new TokenType("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        incDec: new TokenType("++/--", {
          prefix: true,
          postfix: true,
          startsExpr: true
        }),
        prefix: new TokenType("!/~", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
          beforeExpr: true,
          binop: 9,
          prefix: true,
          startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
          isLoop: true,
          beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", {
          beforeExpr: true,
          startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
          beforeExpr: true,
          binop: 7
        }),
        _instanceof: kw("instanceof", {
          beforeExpr: true,
          binop: 7
        }),
        _typeof: kw("typeof", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _void: kw("void", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _delete: kw("delete", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code, ecma2019String) {
        return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      function has(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      }
      var isArray = Array.isArray || function (obj) {
        return toString.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur);
          }
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: false,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 100000000;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function (block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [
              start,
              end
            ];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = {};
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
      };
      var prototypeAccessors = {
        inFunction: { configurable: true },
        inGenerator: { configurable: true },
        inAsync: { configurable: true },
        allowSuper: { configurable: true },
        allowDirectSuper: { configurable: true },
        treatFunctionsAsVar: { configurable: true },
        inNonArrowFunction: { configurable: true }
      };
      Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function () {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function () {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function () {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.allowSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
      };
      prototypeAccessors.allowDirectSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function () {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.inNonArrowFunction.get = function () {
        return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      Parser.parse = function parse(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp.strictDirective = function (start) {
        for (;;) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp.eat = function (type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp.isContextual = function (name) {
        return this.type === types.name && this.value === name && !this.containsEsc;
      };
      pp.eatContextual = function (name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp.expectContextual = function (name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp.canInsertSemicolon = function () {
        return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp.insertSemicolon = function () {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp.semicolon = function () {
        if (!this.eat(types.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp.afterTrailingComma = function (tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp.expect = function (type) {
        this.eat(type) || this.unexpected();
      };
      pp.unexpected = function (pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      };
      pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp.checkYieldAwaitInDefaultParams = function () {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp.isSimpleAssignTarget = function (expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1 = Parser.prototype;
      pp$1.parseTopLevel = function (node) {
        var exports = {};
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types.eof) {
          var stmt = this.parseStatement(null, true, exports);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$1.isLet = function (context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$1.isAsyncFunction = function () {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
      };
      pp$1.parseStatement = function (context, topLevel, exports) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types._var;
          kind = "let";
        }
        switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
          return this.parseDebuggerStatement(node);
        case types._do:
          return this.parseDoStatement(node);
        case types._for:
          return this.parseForStatement(node);
        case types._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types._if:
          return this.parseIfStatement(node);
        case types._return:
          return this.parseReturnStatement(node);
        case types._switch:
          return this.parseSwitchStatement(node);
        case types._throw:
          return this.parseThrowStatement(node);
        case types._try:
          return this.parseTryStatement(node);
        case types._const:
        case types._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types._while:
          return this.parseWhileStatement(node);
        case types._with:
          return this.parseWithStatement(node);
        case types.braceL:
          return this.parseBlock(true, node);
        case types.semi:
          return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
          if (this.options.ecmaVersion > 10 && starttype === types._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
      };
      pp$1.parseBreakContinueStatement = function (node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$1.parseDebuggerStatement = function (node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$1.parseDoStatement = function (node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$1.parseForStatement = function (node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types.parenL);
        if (this.type === types.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types._var || this.type === types._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(true, refDestructuringErrors);
        if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$1.parseIfStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$1.parseReturnStatement = function (node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$1.parseSwitchStatement = function (node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types.braceR;) {
          if (this.type === types._case || this.type === types._default) {
            var isCase = this.type === types._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$1.parseThrowStatement = function (node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty = [];
      pp$1.parseTryStatement = function (node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$1.parseVarStatement = function (node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$1.parseWhileStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$1.parseWithStatement = function (node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$1.parseEmptyStatement = function (node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$1.parseLabeledStatement = function (node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
          var label = list[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({
          name: maybeName,
          kind: kind,
          statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$1.parseExpressionStatement = function (node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$1.parseBlock = function (createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$1.parseFor = function (node, init) {
        node.init = init;
        this.expect(types.semi);
        node.test = this.type === types.semi ? null : this.parseExpression();
        this.expect(types.semi);
        node.update = this.type === types.parenR ? null : this.parseExpression();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$1.parseForIn = function (node, init) {
        var isForIn = this.type === types._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$1.parseVar = function (node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types.comma)) {
            break;
          }
        }
        return node;
      };
      pp$1.parseVarId = function (decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$1.parseFunction = function (node, statement, allowExpressionBody, isAsync) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$1.parseFunctionParams = function (node) {
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$1.parseClass = function (node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types.braceL);
        while (this.type !== types.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$1.parseClassElement = function (constructorAllowsSuper) {
        var this$1$1 = this;
        if (this.eat(types.semi)) {
          return null;
        }
        var method = this.startNode();
        var tryContextual = function (k, noLineBreak) {
          if (noLineBreak === void 0)
            noLineBreak = false;
          var start = this$1$1.start, startLoc = this$1$1.startLoc;
          if (!this$1$1.eatContextual(k)) {
            return false;
          }
          if (this$1$1.type !== types.parenL && (!noLineBreak || !this$1$1.canInsertSemicolon())) {
            return true;
          }
          if (method.key) {
            this$1$1.unexpected();
          }
          method.computed = false;
          method.key = this$1$1.startNodeAt(start, startLoc);
          method.key.name = k;
          this$1$1.finishNode(method.key, "Identifier");
          return false;
        };
        method.kind = "method";
        method.static = tryContextual("static");
        var isGenerator = this.eat(types.star);
        var isAsync = false;
        if (!isGenerator) {
          if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          } else if (tryContextual("get")) {
            method.kind = "get";
          } else if (tryContextual("set")) {
            method.kind = "set";
          }
        }
        if (!method.key) {
          this.parsePropertyName(method);
        }
        var key = method.key;
        var allowsDirectSuper = false;
        if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
          if (method.kind !== "method") {
            this.raise(key.start, "Constructor can't have get/set modifier");
          }
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
          method.kind = "constructor";
          allowsDirectSuper = constructorAllowsSuper;
        } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && method.value.params.length !== 0) {
          this.raiseRecoverable(method.value.start, "getter should have no params");
        }
        if (method.kind === "set" && method.value.params.length !== 1) {
          this.raiseRecoverable(method.value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && method.value.params[0].type === "RestElement") {
          this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
        }
        return method;
      };
      pp$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
        method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        return this.finishNode(method, "MethodDefinition");
      };
      pp$1.parseClassId = function (node, isStatement) {
        if (this.type === types.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$1.parseClassSuper = function (node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
      };
      pp$1.parseExport = function (node, exports) {
        this.next();
        if (this.eat(types.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseIdent(true);
              this.checkExport(exports, node.exported.name, this.lastTokStart);
            } else {
              node.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types._default)) {
          this.checkExport(exports, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseStatement(null);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports, node.declaration.declarations);
          } else {
            this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports);
          if (this.eatContextual("from")) {
            if (this.type !== types.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
              var spec = list[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$1.checkExport = function (exports, name, pos) {
        if (!exports) {
          return;
        }
        if (has(exports, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports[name] = true;
      };
      pp$1.checkPatternExport = function (exports, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports, pat.name, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i = 0, list = pat.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkPatternExport(exports, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports, pat.expression);
        }
      };
      pp$1.checkVariableExport = function (exports, decls) {
        if (!exports) {
          return;
        }
        for (var i = 0, list = decls; i < list.length; i += 1) {
          var decl = list[i];
          this.checkPatternExport(exports, decl.id);
        }
      };
      pp$1.shouldParseExportStatement = function () {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$1.parseExportSpecifiers = function (exports) {
        var nodes = [], first = true;
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node = this.startNode();
          node.local = this.parseIdent(true);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          this.checkExport(exports, node.exported.name, node.exported.start);
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$1.parseImport = function (node) {
        this.next();
        if (this.type === types.string) {
          node.specifiers = empty;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$1.parseImportSpecifiers = function () {
        var nodes = [], first = true;
        if (this.type === types.name) {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(types.comma)) {
            return nodes;
          }
        }
        if (this.type === types.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$1.adaptDirectivePrologue = function (statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$1.isDirectiveCandidate = function (statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
      };
      var pp$2 = Parser.prototype;
      pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$2.toAssignableList = function (exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$2.parseSpread = function (refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$2.parseRestBinding = function () {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$2.parseBindingAtom = function () {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
          case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types.braceL:
            return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
          }
          if (allowEmpty && this.type === types.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$2.parseBindingListItem = function (param) {
        return param;
      };
      pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$2.checkLValSimple = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (has(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$2.checkLValPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$2.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var pp$3 = Parser.prototype;
      pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$3.parseExpression = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
        if (this.type === types.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types.comma)) {
            node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(noIn);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types.parenL || this.type === types.name) {
          this.potentialArrowAt = this.start;
        }
        var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
      };
      pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== types._in)) {
          if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var coalesce = this.type === types.coalesce;
            if (coalesce) {
              prec = types.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
          }
        }
        return left;
      };
      pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
          expr = this.parseAwait();
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!sawUnary && this.eat(types.starstar)) {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
        } else {
          return expr;
        }
      };
      pp$3.parseExprSubscripts = function (refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
        }
        return result;
      };
      pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$3.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types.bracketL);
        if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
          node.computed = !!computed;
          if (computed) {
            this.expect(types.bracketR);
          }
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$3.parseExprAtom = function (refDestructuringErrors) {
        if (this.type === types.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
        case types._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
            }
          }
          return id;
        case types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = {
            pattern: value.pattern,
            flags: value.flags
          };
          return node;
        case types.num:
        case types.string:
          return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
          node = this.startNode();
          node.value = this.type === types._null ? null : this.type === types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types.braceL:
          return this.parseObj(false, refDestructuringErrors);
        case types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types._class:
          return this.parseClass(this.startNode(), false);
        case types._new:
          return this.parseNew();
        case types.backQuote:
          return this.parseTemplate();
        case types._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
        }
      };
      pp$3.parseExprImport = function () {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
        case types.parenL:
          return this.parseDynamicImport(node);
        case types.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
        }
      };
      pp$3.parseDynamicImport = function (node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types.parenR)) {
          var errorPos = this.start;
          if (this.eat(types.comma) && this.eat(types.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$3.parseImportMeta = function (node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module") {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$3.parseLiteral = function (value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$3.parseParenExpression = function () {
        this.expect(types.parenL);
        var val = this.parseExpression();
        this.expect(types.parenR);
        return val;
      };
      pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types.parenR) {
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(types.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$3.parseParenItem = function (item) {
        return item;
      };
      pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
      };
      var empty$1 = [];
      pp$3.parseNew = function () {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.inNonArrowFunction) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types.parenL)) {
          node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty$1;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$3.parseTemplateElement = function (ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$3.parseTemplate = function (ref) {
        if (ref === void 0)
          ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged: isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged: isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$3.isAsyncProp = function (prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$3.parseObj = function (isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types.colon) {
          this.unexpected();
        }
        if (this.eat(types.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$3.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$3.initFunction = function (node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$3.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$3.parseArrowExpression = function (node, params, isAsync) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$3.parseFunctionBody = function (node, isArrowFunction, isMethod) {
        var isExpression = isArrowFunction && this.type !== types.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$3.isSimpleParamList = function (params) {
        for (var i = 0, list = params; i < list.length; i += 1) {
          var param = list[i];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$3.checkParams = function (node, allowDuplicates) {
        var nameHash = {};
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types.comma) {
            elt = null;
          } else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$3.checkUnreserved = function (ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$3.parseIdent = function (liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$3.parseYield = function (noIn) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types.star);
          node.argument = this.parseMaybeAssign(noIn);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$3.parseAwait = function () {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function (pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function () {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$5 = Parser.prototype;
      var Scope = function Scope(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$5.enterScope = function (flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$5.exitScope = function () {
        this.scopeStack.pop();
      };
      pp$5.treatFunctionsAsVarInScope = function (scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$5.declareName = function (name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$5.checkLocalExport = function (id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$5.currentScope = function () {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$5.currentVarScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$5.currentThisScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [
            pos,
            0
          ];
        }
      };
      var pp$6 = Parser.prototype;
      pp$6.startNode = function () {
        return new Node(this, this.start, this.startLoc);
      };
      pp$6.startNodeAt = function (pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$6.finishNode = function (node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$6.finishNodeAt = function (node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$6.copyNode = function (node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function (p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$7 = Parser.prototype;
      pp$7.initialContext = function () {
        return [types$1.b_stat];
      };
      pp$7.braceIsBlock = function (prevType) {
        var parent = this.curContext();
        if (parent === types$1.f_expr || parent === types$1.f_stat) {
          return true;
        }
        if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types._return || prevType === types.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
          return true;
        }
        if (prevType === types.braceL) {
          return parent === types$1.b_stat;
        }
        if (prevType === types._var || prevType === types._const || prevType === types.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$7.inGeneratorContext = function () {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$7.updateContext = function (prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      types.parenR.updateContext = types.braceR.updateContext = function () {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types.braceL.updateContext = function (prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
        this.exprAllowed = true;
      };
      types.dollarBraceL.updateContext = function () {
        this.context.push(types$1.b_tmpl);
        this.exprAllowed = true;
      };
      types.parenL.updateContext = function (prevType) {
        var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
        this.exprAllowed = true;
      };
      types.incDec.updateContext = function () {
      };
      types._function.updateContext = types._class.updateContext = function (prevType) {
        if (prevType.beforeExpr && prevType !== types._else && !(prevType === types.semi && this.curContext() !== types$1.p_stat) && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
          this.context.push(types$1.f_expr);
        } else {
          this.context.push(types$1.f_stat);
        }
        this.exprAllowed = false;
      };
      types.backQuote.updateContext = function () {
        if (this.curContext() === types$1.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types$1.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types.star.updateContext = function (prevType) {
        if (prevType === types._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types$1.f_expr) {
            this.context[index] = types$1.f_expr_gen;
          } else {
            this.context[index] = types$1.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types.name.updateContext = function (prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9);
      buildUnicodeData(10);
      buildUnicodeData(11);
      buildUnicodeData(12);
      var pp$8 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
          return i + 1;
        }
        return i + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      function codePointToString(ch) {
        if (ch <= 65535) {
          return String.fromCharCode(ch);
        }
        ch -= 65536;
        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
      }
      pp$8.validateRegExpFlags = function (state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$8.validateRegExpPattern = function (state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$8.regexp_pattern = function (state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
          var name = list[i];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$8.regexp_disjunction = function (state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$8.regexp_alternative = function (state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$8.regexp_eatTerm = function (state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatAssertion = function (state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$8.regexp_eatQuantifier = function (state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatQuantifierPrefix = function (state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$8.regexp_eatBracedQuantifier = function (state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatAtom = function (state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$8.regexp_eatReverseSolidusAtomEscape = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatUncapturingGroup = function (state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatCapturingGroup = function (state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$8.regexp_eatExtendedAtom = function (state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$8.regexp_eatInvalidBracedQuantifier = function (state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$8.regexp_eatSyntaxCharacter = function (state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8.regexp_eatPatternCharacters = function (state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$8.regexp_eatExtendedPatternCharacter = function (state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_groupSpecifier = function (state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$8.regexp_eatGroupName = function (state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierName = function (state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierStart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$8.regexp_eatRegExpIdentifierPart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8.regexp_eatAtomEscape = function (state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$8.regexp_eatBackReference = function (state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatKGroupName = function (state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$8.regexp_eatCharacterEscape = function (state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$8.regexp_eatCControlLetter = function (state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatZero = function (state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlEscape = function (state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlLetter = function (state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8.regexp_eatIdentityEscape = function (state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatDecimalEscape = function (state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatCharacterClassEscape = function (state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8.regexp_eatUnicodePropertyValueExpression = function (state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$8.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
        if (!has(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$8.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$8.regexp_eatUnicodePropertyName = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$8.regexp_eatUnicodePropertyValue = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$8.regexp_eatCharacterClass = function (state) {
        if (state.eat(91)) {
          state.eat(94);
          this.regexp_classRanges(state);
          if (state.eat(93)) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$8.regexp_classRanges = function (state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$8.regexp_eatClassAtom = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatClassEscape = function (state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$8.regexp_eatClassControlLetter = function (state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatHexEscapeSequence = function (state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatDecimalDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8.regexp_eatHexDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$8.regexp_eatLegacyOctalEscapeSequence = function (state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatOctalDigit = function (state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8.regexp_eatFixedHexDigits = function (state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [
            p.start,
            p.end
          ];
        }
      };
      var pp$9 = Parser.prototype;
      pp$9.next = function (ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp$9.getToken = function () {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp$9[Symbol.iterator] = function () {
          var this$1$1 = this;
          return {
            next: function () {
              var token = this$1$1.getToken();
              return {
                done: token.type === types.eof,
                value: token
              };
            }
          };
        };
      }
      pp$9.curContext = function () {
        return this.context[this.context.length - 1];
      };
      pp$9.nextToken = function () {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp$9.readToken = function (code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp$9.fullCharCodeAtPos = function () {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 57344) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return (code << 10) + next - 56613888;
      };
      pp$9.skipBlockComment = function () {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipLineComment = function (startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipSpace = function () {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
            }
          }
      };
      pp$9.finishToken = function (type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp$9.readToken_dot = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types.dot);
        }
      };
      pp$9.readToken_slash = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.slash, 1);
      };
      pp$9.readToken_mult_modulo_exp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types.star : types.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp$9.readToken_pipe_amp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      };
      pp$9.readToken_caret = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.bitwiseXOR, 1);
      };
      pp$9.readToken_plus_min = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.plusMin, 1);
      };
      pp$9.readToken_lt_gt = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types.assign, size + 1);
          }
          return this.finishOp(types.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types.relational, size);
      };
      pp$9.readToken_eq_excl = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types.arrow);
        }
        return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
      };
      pp$9.readToken_question = function () {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types.assign, 3);
              }
            }
            return this.finishOp(types.coalesce, 2);
          }
        }
        return this.finishOp(types.question, 1);
      };
      pp$9.getTokenFromCode = function (code) {
        switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types.prefix, 1);
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };
      pp$9.finishOp = function (type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp$9.readRegexp = function () {
        var escaped, inClass, start = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types.regexp, {
          pattern: pattern,
          flags: flags,
          value: value
        });
      };
      pp$9.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp$9.readRadixNumber = function (radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types.num, val);
      };
      pp$9.readNumber = function (startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types.num, val);
      };
      pp$9.readCodePoint = function () {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      function codePointToString$1(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      pp$9.readString = function (quote) {
        var out = "", chunkStart = ++this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else {
            if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp$9.tryReadTemplateToken = function () {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp$9.invalidStringToken = function (position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp$9.readTmplToken = function () {
        var out = "", chunkStart = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp$9.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp$9.readEscapedChar = function (inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString$1(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\x0B";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
        }
      };
      pp$9.readHexChar = function (len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp$9.readWord1 = function () {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString$1(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp$9.readWord = function () {
        var word = this.readWord1();
        var type = types.name;
        if (this.keywords.test(word)) {
          type = keywords$1[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.0.4";
      Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node,
        TokenType: TokenType,
        tokTypes: types,
        keywordTypes: keywords$1,
        TokContext: TokContext,
        tokContexts: types$1,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports.Node = Node;
      exports.Parser = Parser;
      exports.Position = Position;
      exports.SourceLocation = SourceLocation;
      exports.TokContext = TokContext;
      exports.Token = Token;
      exports.TokenType = TokenType;
      exports.defaultOptions = defaultOptions;
      exports.getLineInfo = getLineInfo;
      exports.isIdentifierChar = isIdentifierChar;
      exports.isIdentifierStart = isIdentifierStart;
      exports.isNewLine = isNewLine;
      exports.keywordTypes = keywords$1;
      exports.lineBreak = lineBreak;
      exports.lineBreakG = lineBreakG;
      exports.nonASCIIwhitespace = nonASCIIwhitespace;
      exports.parse = parse;
      exports.parseExpressionAt = parseExpressionAt;
      exports.tokContexts = types$1;
      exports.tokTypes = types;
      exports.tokenizer = tokenizer;
      exports.version = version;
      Object.defineProperty(exports, "__esModule", { value: true });
    }));
  }(acorn$2, acorn$2.exports));
  return acorn$2.exports;
}

var acornDecorators;
var hasRequiredAcornDecorators;
function requireAcornDecorators() {
  if (hasRequiredAcornDecorators)
    return acornDecorators;
  hasRequiredAcornDecorators = 1;
  const acorn = requireAcorn$1();
  const getAcorn = Parser => {
    if (Parser.acorn)
      return Parser.acorn;
    if (acorn.version.indexOf("6.") !== 0 && acorn.version.indexOf("6.0.") === 0 && acorn.version.indexOf("7.") !== 0) {
      throw new Error(`acorn-private-class-elements requires acorn@^6.1.0 or acorn@7.0.0, not ${ acorn.version }`);
    }
    for (let cur = Parser; cur && cur !== acorn.Parser; cur = Object.getPrototypeOf(cur)) {
      if (cur !== acorn.Parser) {
        throw new Error("acorn-private-class-elements does not support mixing different acorn copies");
      }
    }
    return acorn;
  };
  acornDecorators = function extendParser(Parser) {
    if (Parser.prototype._parseDecorator) {
      return Parser;
    }
    const acorn = getAcorn(Parser);
    class DecoratorParser extends Parser {
      _parseDecorator() {
        let node = this.startNode();
        this.next();
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "Decorator");
      }
      getTokenFromCode(code) {
        if (code === 64) {
          ++this.pos;
          return this.finishToken(this.decoratorIdentifier);
        }
        return super.getTokenFromCode(code);
      }
      parseStatement(declaration, topLevel, exports) {
        let decorators = [];
        switch (this.type) {
        case this.decoratorIdentifier:
          while (this.type === this.decoratorIdentifier) {
            decorators.push(this._parseDecorator());
          }
          if (this.type !== acorn.tokTypes._class) {
            this.raise(this.start, "Leading decorators must be attached to a class declaration");
          }
        case acorn.tokTypes._class:
          if (declaration)
            this.unexpected();
          let node = super.parseStatement(declaration, topLevel, exports);
          node.decorators = decorators;
          if (decorators.length) {
            node.start = node.decorators[0].start;
          }
          return node;
        }
        return super.parseStatement(declaration, topLevel, exports);
      }
      parseClass(node, isStatement) {
        node = super.parseClass(node, isStatement);
        node.decorators = [];
        return node;
      }
      parseClassElement(constructorAllowsSuper) {
        let decorators = [];
        switch (this.type) {
        case this.decoratorIdentifier:
          while (this.type === this.decoratorIdentifier) {
            decorators.push(this._parseDecorator());
          }
          if (this.type !== acorn.tokTypes.name && this.type !== acorn.tokTypes.star) {
            this.raise(this.start, "Inline decorators must be attached to a property declaration");
          }
        case this.privateIdentifierToken:
        case acorn.tokTypes.star:
        case acorn.tokTypes.bracketL:
        case acorn.tokTypes.name:
        case acorn.tokTypes._with:
        case acorn.tokTypes._delete:
          let node = super.parseClassElement(constructorAllowsSuper);
          node.decorators = decorators;
          if (decorators.length) {
            node.start = node.decorators[0].start;
          }
          return node;
        }
        return super.parseClassElement(constructorAllowsSuper);
      }
    }
    DecoratorParser.prototype.decoratorIdentifier = new acorn.TokenType("decorator-Identifier");
    return DecoratorParser;
  };
  return acornDecorators;
}

var _1_0_0$2;
var hasRequired_1_0_0$2;
function require_1_0_0$2() {
  if (hasRequired_1_0_0$2)
    return _1_0_0$2;
  hasRequired_1_0_0$2 = 1;
  const getPrototype = Object.getPrototypeOf || (o => o.__proto__);
  const getAcorn = Parser => {
    if (Parser.acorn)
      return Parser.acorn;
    const acorn = requireAcorn$1();
    if (acorn.version.indexOf("6.") != 0 && acorn.version.indexOf("6.0.") == 0 && acorn.version.indexOf("7.") != 0) {
      throw new Error(`acorn-private-class-elements requires acorn@^6.1.0 or acorn@7.0.0, not ${ acorn.version }`);
    }
    for (let cur = Parser; cur && cur !== acorn.Parser; cur = getPrototype(cur)) {
      if (cur !== acorn.Parser) {
        throw new Error("acorn-private-class-elements does not support mixing different acorn copies");
      }
    }
    return acorn;
  };
  _1_0_0$2 = function (Parser) {
    if (Parser.prototype.parsePrivateName) {
      return Parser;
    }
    const acorn = getAcorn(Parser);
    Parser = class extends Parser {
      _branch() {
        this.__branch = this.__branch || new Parser({ ecmaVersion: this.options.ecmaVersion }, this.input);
        this.__branch.end = this.end;
        this.__branch.pos = this.pos;
        this.__branch.type = this.type;
        this.__branch.value = this.value;
        this.__branch.containsEsc = this.containsEsc;
        return this.__branch;
      }
      parsePrivateClassElementName(element) {
        element.computed = false;
        element.key = this.parsePrivateName();
        if (element.key.name == "constructor")
          this.raise(element.key.start, "Classes may not have a private element named constructor");
        const accept = {
          get: "set",
          set: "get"
        }[element.kind];
        const privateBoundNames = this._privateBoundNames;
        if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {
          this.raise(element.start, "Duplicate private element");
        }
        privateBoundNames[element.key.name] = element.kind || true;
        delete this._unresolvedPrivateNames[element.key.name];
        return element.key;
      }
      parsePrivateName() {
        const node = this.startNode();
        node.name = this.value;
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.allowReserved == "never")
          this.checkUnreserved(node);
        return node;
      }
      getTokenFromCode(code) {
        if (code === 35) {
          ++this.pos;
          const word = this.readWord1();
          return this.finishToken(this.privateIdentifierToken, word);
        }
        return super.getTokenFromCode(code);
      }
      parseClass(node, isStatement) {
        const oldOuterPrivateBoundNames = this._outerPrivateBoundNames;
        this._outerPrivateBoundNames = this._privateBoundNames;
        this._privateBoundNames = Object.create(this._privateBoundNames || null);
        const oldOuterUnresolvedPrivateNames = this._outerUnresolvedPrivateNames;
        this._outerUnresolvedPrivateNames = this._unresolvedPrivateNames;
        this._unresolvedPrivateNames = Object.create(null);
        const _return = super.parseClass(node, isStatement);
        const unresolvedPrivateNames = this._unresolvedPrivateNames;
        this._privateBoundNames = this._outerPrivateBoundNames;
        this._outerPrivateBoundNames = oldOuterPrivateBoundNames;
        this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames;
        this._outerUnresolvedPrivateNames = oldOuterUnresolvedPrivateNames;
        if (!this._unresolvedPrivateNames) {
          const names = Object.keys(unresolvedPrivateNames);
          if (names.length) {
            names.sort((n1, n2) => unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]);
            this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name");
          }
        } else
          Object.assign(this._unresolvedPrivateNames, unresolvedPrivateNames);
        return _return;
      }
      parseClassSuper(node) {
        const privateBoundNames = this._privateBoundNames;
        this._privateBoundNames = this._outerPrivateBoundNames;
        const unresolvedPrivateNames = this._unresolvedPrivateNames;
        this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames;
        const _return = super.parseClassSuper(node);
        this._privateBoundNames = privateBoundNames;
        this._unresolvedPrivateNames = unresolvedPrivateNames;
        return _return;
      }
      parseSubscript(base, startPos, startLoc, _noCalls, _maybeAsyncArrow, _optionalChained) {
        const optionalSupported = this.options.ecmaVersion >= 11 && acorn.tokTypes.questionDot;
        const branch = this._branch();
        if (!((branch.eat(acorn.tokTypes.dot) || optionalSupported && branch.eat(acorn.tokTypes.questionDot)) && branch.type == this.privateIdentifierToken)) {
          return super.parseSubscript.apply(this, arguments);
        }
        let optional = false;
        if (!this.eat(acorn.tokTypes.dot)) {
          this.expect(acorn.tokTypes.questionDot);
          optional = true;
        }
        let node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.computed = false;
        if (optionalSupported) {
          node.optional = optional;
        }
        if (this.type == this.privateIdentifierToken) {
          if (base.type == "Super") {
            this.raise(this.start, "Cannot access private element on super");
          }
          node.property = this.parsePrivateName();
          if (!this._privateBoundNames || !this._privateBoundNames[node.property.name]) {
            if (!this._unresolvedPrivateNames) {
              this.raise(node.property.start, "Usage of undeclared private name");
            }
            this._unresolvedPrivateNames[node.property.name] = node.property.start;
          }
        } else {
          node.property = this.parseIdent(true);
        }
        return this.finishNode(node, "MemberExpression");
      }
      parseMaybeUnary(refDestructuringErrors, sawUnary) {
        const _return = super.parseMaybeUnary(refDestructuringErrors, sawUnary);
        if (_return.operator == "delete") {
          if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateIdentifier") {
            this.raise(_return.start, "Private elements may not be deleted");
          }
        }
        return _return;
      }
    };
    Parser.prototype.privateIdentifierToken = new acorn.TokenType("privateIdentifier");
    return Parser;
  };
  return _1_0_0$2;
}

var _1_0_0$1;
var hasRequired_1_0_0$1;
function require_1_0_0$1() {
  if (hasRequired_1_0_0$1)
    return _1_0_0$1;
  hasRequired_1_0_0$1 = 1;
  const privateClassElements = require_1_0_0$2();
  _1_0_0$1 = function (Parser) {
    const acorn = Parser.acorn || requireAcorn$1();
    const tt = acorn.tokTypes;
    Parser = privateClassElements(Parser);
    return class extends Parser {
      _maybeParseFieldValue(field) {
        if (this.eat(tt.eq)) {
          const oldInFieldValue = this._inFieldValue;
          this._inFieldValue = true;
          if (this.type === tt.name && this.value === "await" && (this.inAsync || this.options.allowAwaitOutsideFunction)) {
            field.value = this.parseAwait();
          } else
            field.value = this.parseExpression();
          this._inFieldValue = oldInFieldValue;
        } else
          field.value = null;
      }
      parseClassElement(_constructorAllowsSuper) {
        if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type.keyword || this.type == this.privateIdentifierToken || this.type == tt.bracketL || this.type == tt.string || this.type == tt.num)) {
          const branch = this._branch();
          if (branch.type == tt.bracketL) {
            let count = 0;
            do {
              if (branch.eat(tt.bracketL))
                ++count;
              else if (branch.eat(tt.bracketR))
                --count;
              else
                branch.next();
            } while (count > 0);
          } else
            branch.next(true);
          let isField = branch.type == tt.eq || branch.type == tt.semi;
          if (!isField && branch.canInsertSemicolon()) {
            isField = branch.type != tt.parenL;
          }
          if (isField) {
            const node = this.startNode();
            if (this.type == this.privateIdentifierToken) {
              this.parsePrivateClassElementName(node);
            } else {
              this.parsePropertyName(node);
            }
            if (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && node.key.value === "constructor") {
              this.raise(node.key.start, "Classes may not have a field called constructor");
            }
            this.enterScope(64 | 2 | 1);
            this._maybeParseFieldValue(node);
            this.exitScope();
            this.finishNode(node, "PropertyDefinition");
            this.semicolon();
            return node;
          }
        }
        return super.parseClassElement.apply(this, arguments);
      }
      parseIdent(liberal, isBinding) {
        const ident = super.parseIdent(liberal, isBinding);
        if (this._inFieldValue && ident.name == "arguments")
          this.raise(ident.start, "A class field initializer may not contain arguments");
        return ident;
      }
    };
  };
  return _1_0_0$1;
}

var _1_0_0;
var hasRequired_1_0_0;
function require_1_0_0() {
  if (hasRequired_1_0_0)
    return _1_0_0;
  hasRequired_1_0_0 = 1;
  const privateClassElements = require_1_0_0$2();
  _1_0_0 = function (Parser) {
    const ExtendedParser = privateClassElements(Parser);
    const acorn = Parser.acorn || requireAcorn$1();
    const tt = acorn.tokTypes;
    return class extends ExtendedParser {
      _maybeParseFieldValue(field) {
        if (this.eat(tt.eq)) {
          const oldInFieldValue = this._inStaticFieldScope;
          this._inStaticFieldScope = this.currentThisScope();
          field.value = this.parseExpression();
          this._inStaticFieldScope = oldInFieldValue;
        } else
          field.value = null;
      }
      parseClassElement(_constructorAllowsSuper) {
        if (this.options.ecmaVersion < 8 || !this.isContextual("static")) {
          return super.parseClassElement.apply(this, arguments);
        }
        const branch = this._branch();
        branch.next();
        if ([
            tt.name,
            tt.bracketL,
            tt.string,
            tt.num,
            this.privateIdentifierToken
          ].indexOf(branch.type) == -1 && !branch.type.keyword) {
          return super.parseClassElement.apply(this, arguments);
        }
        if (branch.type == tt.bracketL) {
          let count = 0;
          do {
            if (branch.eat(tt.bracketL))
              ++count;
            else if (branch.eat(tt.bracketR))
              --count;
            else
              branch.next();
          } while (count > 0);
        } else
          branch.next();
        if (branch.type != tt.eq && !branch.canInsertSemicolon() && branch.type != tt.semi) {
          return super.parseClassElement.apply(this, arguments);
        }
        const node = this.startNode();
        node.static = this.eatContextual("static");
        if (this.type == this.privateIdentifierToken) {
          this.parsePrivateClassElementName(node);
        } else {
          this.parsePropertyName(node);
        }
        if (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && !node.computed && node.key.value === "constructor") {
          this.raise(node.key.start, "Classes may not have a field called constructor");
        }
        if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
          this.raise(node.key.start, "Classes may not have a static property named prototype");
        }
        this.enterScope(64 | 2 | 1);
        this._maybeParseFieldValue(node);
        this.exitScope();
        this.finishNode(node, "PropertyDefinition");
        this.semicolon();
        return node;
      }
      parsePropertyName(prop) {
        if (prop.static && this.type == this.privateIdentifierToken) {
          this.parsePrivateClassElementName(prop);
        } else {
          super.parsePropertyName(prop);
        }
      }
      parseIdent(liberal, isBinding) {
        const ident = super.parseIdent(liberal, isBinding);
        if (this._inStaticFieldScope && this.currentThisScope() === this._inStaticFieldScope && ident.name == "arguments") {
          this.raise(ident.start, "A static class field initializer may not contain arguments");
        }
        return ident;
      }
    };
  };
  return _1_0_0;
}

var acornPrivateMethods;
var hasRequiredAcornPrivateMethods;
function requireAcornPrivateMethods() {
  if (hasRequiredAcornPrivateMethods)
    return acornPrivateMethods;
  hasRequiredAcornPrivateMethods = 1;
  var privateClassElements = require_1_0_0$2();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var privateClassElements__default = _interopDefaultLegacy(privateClassElements);
  function privateMethods(Parser) {
    const ExtendedParser = privateClassElements__default["default"](Parser);
    return class extends ExtendedParser {
      parseClassElement(_constructorAllowsSuper) {
        const oldInClassMemberName = this._inClassMemberName;
        this._inClassMemberName = true;
        const result = super.parseClassElement.apply(this, arguments);
        this._inClassMemberName = oldInClassMemberName;
        return result;
      }
      parsePropertyName(prop) {
        const isPrivate = this.options.ecmaVersion >= 8 && this._inClassMemberName && this.type == this.privateIdentifierToken && !prop.static;
        this._inClassMemberName = false;
        if (!isPrivate)
          return super.parsePropertyName(prop);
        return this.parsePrivateClassElementName(prop);
      }
    };
  }
  acornPrivateMethods = privateMethods;
  return acornPrivateMethods;
}

var acornDecoratorsExports = requireAcornDecorators();

var _1_0_0Exports$1 = require_1_0_0$1();

var _1_0_0Exports = require_1_0_0();

var acornPrivateMethodsExports = requireAcornPrivateMethods();

var acornExports = requireAcorn$1();

var acornDefault = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  'default': acornExports
}, [acornExports]);

var walk$2 = {exports: {}};

(function (module, exports) {
  (function (global, factory) {
    factory(exports) ;
  }(commonjsGlobal, function (exports) {
    function simple(node, visitors, baseVisitor, state, override) {
      if (!baseVisitor) {
        baseVisitor = base;
      }
      (function c(node, st, override) {
        var type = override || node.type, found = visitors[type];
        baseVisitor[type](node, st, c);
        if (found) {
          found(node, st);
        }
      }(node, state, override));
    }
    function ancestor(node, visitors, baseVisitor, state, override) {
      var ancestors = [];
      if (!baseVisitor) {
        baseVisitor = base;
      }
      (function c(node, st, override) {
        var type = override || node.type, found = visitors[type];
        var isNew = node !== ancestors[ancestors.length - 1];
        if (isNew) {
          ancestors.push(node);
        }
        baseVisitor[type](node, st, c);
        if (found) {
          found(node, st || ancestors, ancestors);
        }
        if (isNew) {
          ancestors.pop();
        }
      }(node, state, override));
    }
    function recursive(node, state, funcs, baseVisitor, override) {
      var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;
      (function c(node, st, override) {
        visitor[override || node.type](node, st, c);
      }(node, state, override));
    }
    function makeTest(test) {
      if (typeof test === "string") {
        return function (type) {
          return type === test;
        };
      } else if (!test) {
        return function () {
          return true;
        };
      } else {
        return test;
      }
    }
    var Found = function Found(node, state) {
      this.node = node;
      this.state = state;
    };
    function full(node, callback, baseVisitor, state, override) {
      if (!baseVisitor) {
        baseVisitor = base;
      }
      var last;
      (function c(node, st, override) {
        var type = override || node.type;
        baseVisitor[type](node, st, c);
        if (last !== node) {
          callback(node, st, type);
          last = node;
        }
      }(node, state, override));
    }
    function fullAncestor(node, callback, baseVisitor, state) {
      if (!baseVisitor) {
        baseVisitor = base;
      }
      var ancestors = [], last;
      (function c(node, st, override) {
        var type = override || node.type;
        var isNew = node !== ancestors[ancestors.length - 1];
        if (isNew) {
          ancestors.push(node);
        }
        baseVisitor[type](node, st, c);
        if (last !== node) {
          callback(node, st || ancestors, ancestors, type);
          last = node;
        }
        if (isNew) {
          ancestors.pop();
        }
      }(node, state));
    }
    function findNodeAt(node, start, end, test, baseVisitor, state) {
      if (!baseVisitor) {
        baseVisitor = base;
      }
      test = makeTest(test);
      try {
        (function c(node, st, override) {
          var type = override || node.type;
          if ((start == null || node.start <= start) && (end == null || node.end >= end)) {
            baseVisitor[type](node, st, c);
          }
          if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {
            throw new Found(node, st);
          }
        }(node, state));
      } catch (e) {
        if (e instanceof Found) {
          return e;
        }
        throw e;
      }
    }
    function findNodeAround(node, pos, test, baseVisitor, state) {
      test = makeTest(test);
      if (!baseVisitor) {
        baseVisitor = base;
      }
      try {
        (function c(node, st, override) {
          var type = override || node.type;
          if (node.start > pos || node.end < pos) {
            return;
          }
          baseVisitor[type](node, st, c);
          if (test(type, node)) {
            throw new Found(node, st);
          }
        }(node, state));
      } catch (e) {
        if (e instanceof Found) {
          return e;
        }
        throw e;
      }
    }
    function findNodeAfter(node, pos, test, baseVisitor, state) {
      test = makeTest(test);
      if (!baseVisitor) {
        baseVisitor = base;
      }
      try {
        (function c(node, st, override) {
          if (node.end < pos) {
            return;
          }
          var type = override || node.type;
          if (node.start >= pos && test(type, node)) {
            throw new Found(node, st);
          }
          baseVisitor[type](node, st, c);
        }(node, state));
      } catch (e) {
        if (e instanceof Found) {
          return e;
        }
        throw e;
      }
    }
    function findNodeBefore(node, pos, test, baseVisitor, state) {
      test = makeTest(test);
      if (!baseVisitor) {
        baseVisitor = base;
      }
      var max;
      (function c(node, st, override) {
        if (node.start > pos) {
          return;
        }
        var type = override || node.type;
        if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {
          max = new Found(node, st);
        }
        baseVisitor[type](node, st, c);
      }(node, state));
      return max;
    }
    function make(funcs, baseVisitor) {
      var visitor = Object.create(baseVisitor || base);
      for (var type in funcs) {
        visitor[type] = funcs[type];
      }
      return visitor;
    }
    function skipThrough(node, st, c) {
      c(node, st);
    }
    function ignore(_node, _st, _c) {
    }
    var base = {};
    base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var stmt = list[i];
        c(stmt, st, "Statement");
      }
    };
    base.Statement = skipThrough;
    base.EmptyStatement = ignore;
    base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function (node, st, c) {
      return c(node.expression, st, "Expression");
    };
    base.IfStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) {
        c(node.alternate, st, "Statement");
      }
    };
    base.LabeledStatement = function (node, st, c) {
      return c(node.body, st, "Statement");
    };
    base.BreakStatement = base.ContinueStatement = ignore;
    base.WithStatement = function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.SwitchStatement = function (node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];
        if (cs.test) {
          c(cs.test, st, "Expression");
        }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      }
    };
    base.SwitchCase = function (node, st, c) {
      if (node.test) {
        c(node.test, st, "Expression");
      }
      for (var i = 0, list = node.consequent; i < list.length; i += 1) {
        var cons = list[i];
        c(cons, st, "Statement");
      }
    };
    base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
      if (node.argument) {
        c(node.argument, st, "Expression");
      }
    };
    base.ThrowStatement = base.SpreadElement = function (node, st, c) {
      return c(node.argument, st, "Expression");
    };
    base.TryStatement = function (node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) {
        c(node.handler, st);
      }
      if (node.finalizer) {
        c(node.finalizer, st, "Statement");
      }
    };
    base.CatchClause = function (node, st, c) {
      if (node.param) {
        c(node.param, st, "Pattern");
      }
      c(node.body, st, "Statement");
    };
    base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForStatement = function (node, st, c) {
      if (node.init) {
        c(node.init, st, "ForInit");
      }
      if (node.test) {
        c(node.test, st, "Expression");
      }
      if (node.update) {
        c(node.update, st, "Expression");
      }
      c(node.body, st, "Statement");
    };
    base.ForInStatement = base.ForOfStatement = function (node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForInit = function (node, st, c) {
      if (node.type === "VariableDeclaration") {
        c(node, st);
      } else {
        c(node, st, "Expression");
      }
    };
    base.DebuggerStatement = ignore;
    base.FunctionDeclaration = function (node, st, c) {
      return c(node, st, "Function");
    };
    base.VariableDeclaration = function (node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1) {
        var decl = list[i];
        c(decl, st);
      }
    };
    base.VariableDeclarator = function (node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) {
        c(node.init, st, "Expression");
      }
    };
    base.Function = function (node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      for (var i = 0, list = node.params; i < list.length; i += 1) {
        var param = list[i];
        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };
    base.Pattern = function (node, st, c) {
      if (node.type === "Identifier") {
        c(node, st, "VariablePattern");
      } else if (node.type === "MemberExpression") {
        c(node, st, "MemberPattern");
      } else {
        c(node, st);
      }
    };
    base.VariablePattern = ignore;
    base.MemberPattern = skipThrough;
    base.RestElement = function (node, st, c) {
      return c(node.argument, st, "Pattern");
    };
    base.ArrayPattern = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Pattern");
        }
      }
    };
    base.ObjectPattern = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        if (prop.type === "Property") {
          if (prop.computed) {
            c(prop.key, st, "Expression");
          }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };
    base.Expression = skipThrough;
    base.ThisExpression = base.Super = base.MetaProperty = ignore;
    base.ArrayExpression = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Expression");
        }
      }
    };
    base.ObjectExpression = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        c(prop, st);
      }
    };
    base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
    base.SequenceExpression = function (node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1) {
        var expr = list[i];
        c(expr, st, "Expression");
      }
    };
    base.TemplateLiteral = function (node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1) {
        var quasi = list[i];
        c(quasi, st);
      }
      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
        var expr = list$1[i$1];
        c(expr, st, "Expression");
      }
    };
    base.TemplateElement = ignore;
    base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
      c(node.argument, st, "Expression");
    };
    base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base.ConditionalExpression = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base.NewExpression = base.CallExpression = function (node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments) {
        for (var i = 0, list = node.arguments; i < list.length; i += 1) {
          var arg = list[i];
          c(arg, st, "Expression");
        }
      }
    };
    base.MemberExpression = function (node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) {
        c(node.property, st, "Expression");
      }
    };
    base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
      if (node.declaration) {
        c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
      }
      if (node.source) {
        c(node.source, st, "Expression");
      }
    };
    base.ExportAllDeclaration = function (node, st, c) {
      if (node.exported) {
        c(node.exported, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportDeclaration = function (node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportExpression = function (node, st, c) {
      c(node.source, st, "Expression");
    };
    base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
    base.TaggedTemplateExpression = function (node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
      return c(node, st, "Class");
    };
    base.Class = function (node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      if (node.superClass) {
        c(node.superClass, st, "Expression");
      }
      c(node.body, st);
    };
    base.ClassBody = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var elt = list[i];
        c(elt, st);
      }
    };
    base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {
      if (node.computed) {
        c(node.key, st, "Expression");
      }
      if (node.value) {
        c(node.value, st, "Expression");
      }
    };
    exports.ancestor = ancestor;
    exports.base = base;
    exports.findNodeAfter = findNodeAfter;
    exports.findNodeAround = findNodeAround;
    exports.findNodeAt = findNodeAt;
    exports.findNodeBefore = findNodeBefore;
    exports.full = full;
    exports.fullAncestor = fullAncestor;
    exports.make = make;
    exports.recursive = recursive;
    exports.simple = simple;
    Object.defineProperty(exports, "__esModule", { value: true });
  }));
}(walk$2, walk$2.exports));
var walk = walk$2.exports;

var walk$1 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  'default': walk
}, [walk$2.exports]);

var acornLoose = {exports: {}};

var acorn$1 = {exports: {}};

var hasRequiredAcorn;
function requireAcorn() {
  if (hasRequiredAcorn)
    return acorn$1.exports;
  hasRequiredAcorn = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    }(commonjsGlobal, function (exports) {
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙ\u0560-\u0588א-ת\u05EF-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘ\u0860-\u086Aࢠ-ࢴࢶ-\u08C7ऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱ\u09FCਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲ\u0D04-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄ\u0E86-ຊ\u0E8C-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-\u1878ᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈ\u1C90-\u1CBA\u1CBD-\u1CBFᳩ-ᳬᳮ-ᳳᳵᳶ\u1CFAᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ\u2118-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ\u309B-ゟァ-ヺー-ヿㄅ-\u312Fㄱ-ㆎㆠ-\u31BFㇰ-ㇿ㐀-\u4DBF一-\u9FFCꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-\uA7BF\uA7C2-\uA7CA\uA7F5-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽ\uA8FEꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-\uAB69ꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var nonASCIIidentifierChars = "‌‍\xB7̀-ͯ\u0387҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳\u07FDࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛\u08D3-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯\u09FEਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯\u0AFA-\u0AFFଁ-ଃ଼ା-ୄେୈୋ-୍\u0B55-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-\u0C04ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯\u0D00-ഃ\u0D3B\u0D3Cാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯\u0D81-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟\u1369-\u1371ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-\u19DAᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽\u1ABF\u1AC0ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴\u1CF7-᳹᷀-\u1DF9᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ\uA82Cꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱\uA8FF-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
      ];
      var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
      ];
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) {
            return false;
          }
          pos += set[i + 1];
          if (pos >= code) {
            return true;
          }
        }
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, {
          beforeExpr: true,
          binop: prec
        });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords$1 = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords$1[name] = new TokenType(name, options);
      }
      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
          beforeExpr: true,
          startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
          beforeExpr: true,
          startsExpr: true
        }),
        eq: new TokenType("=", {
          beforeExpr: true,
          isAssign: true
        }),
        assign: new TokenType("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        incDec: new TokenType("++/--", {
          prefix: true,
          postfix: true,
          startsExpr: true
        }),
        prefix: new TokenType("!/~", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
          beforeExpr: true,
          binop: 9,
          prefix: true,
          startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
          isLoop: true,
          beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", {
          beforeExpr: true,
          startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
          beforeExpr: true,
          binop: 7
        }),
        _instanceof: kw("instanceof", {
          beforeExpr: true,
          binop: 7
        }),
        _typeof: kw("typeof", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _void: kw("void", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _delete: kw("delete", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      function has(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      }
      var isArray = Array.isArray || function (obj) {
        return toString.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur);
          }
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 100000000;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function (block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [
              start,
              end
            ];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = {
        inFunction: { configurable: true },
        inGenerator: { configurable: true },
        inAsync: { configurable: true },
        canAwait: { configurable: true },
        allowSuper: { configurable: true },
        allowDirectSuper: { configurable: true },
        treatFunctionsAsVar: { configurable: true },
        allowNewDotTarget: { configurable: true },
        inClassStaticBlock: { configurable: true }
      };
      Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function () {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function () {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function () {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function () {
        for (var i = this.scopeStack.length - 1; i >= 0; i--) {
          var scope = this.scopeStack[i];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function () {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function () {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function () {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function () {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      Parser.parse = function parse(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp.strictDirective = function (start) {
        for (;;) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp.eat = function (type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp.isContextual = function (name) {
        return this.type === types.name && this.value === name && !this.containsEsc;
      };
      pp.eatContextual = function (name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp.expectContextual = function (name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp.canInsertSemicolon = function () {
        return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp.insertSemicolon = function () {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp.semicolon = function () {
        if (!this.eat(types.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp.afterTrailingComma = function (tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp.expect = function (type) {
        this.eat(type) || this.unexpected();
      };
      pp.unexpected = function (pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      };
      pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp.checkYieldAwaitInDefaultParams = function () {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp.isSimpleAssignTarget = function (expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1 = Parser.prototype;
      pp$1.parseTopLevel = function (node) {
        var exports = Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types.eof) {
          var stmt = this.parseStatement(null, true, exports);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$1.isLet = function (context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$1.isAsyncFunction = function () {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$1.parseStatement = function (context, topLevel, exports) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types._var;
          kind = "let";
        }
        switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
          return this.parseDebuggerStatement(node);
        case types._do:
          return this.parseDoStatement(node);
        case types._for:
          return this.parseForStatement(node);
        case types._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types._if:
          return this.parseIfStatement(node);
        case types._return:
          return this.parseReturnStatement(node);
        case types._switch:
          return this.parseSwitchStatement(node);
        case types._throw:
          return this.parseThrowStatement(node);
        case types._try:
          return this.parseTryStatement(node);
        case types._const:
        case types._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types._while:
          return this.parseWhileStatement(node);
        case types._with:
          return this.parseWithStatement(node);
        case types.braceL:
          return this.parseBlock(true, node);
        case types.semi:
          return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
          if (this.options.ecmaVersion > 10 && starttype === types._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
      };
      pp$1.parseBreakContinueStatement = function (node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$1.parseDebuggerStatement = function (node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$1.parseDoStatement = function (node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$1.parseForStatement = function (node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types.parenL);
        if (this.type === types.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types._var || this.type === types._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$1.parseIfStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$1.parseReturnStatement = function (node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$1.parseSwitchStatement = function (node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types.braceR;) {
          if (this.type === types._case || this.type === types._default) {
            var isCase = this.type === types._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$1.parseThrowStatement = function (node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty = [];
      pp$1.parseTryStatement = function (node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$1.parseVarStatement = function (node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$1.parseWhileStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$1.parseWithStatement = function (node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$1.parseEmptyStatement = function (node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$1.parseLabeledStatement = function (node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
          var label = list[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({
          name: maybeName,
          kind: kind,
          statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$1.parseExpressionStatement = function (node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$1.parseBlock = function (createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$1.parseFor = function (node, init) {
        node.init = init;
        this.expect(types.semi);
        node.test = this.type === types.semi ? null : this.parseExpression();
        this.expect(types.semi);
        node.update = this.type === types.parenR ? null : this.parseExpression();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$1.parseForIn = function (node, init) {
        var isForIn = this.type === types._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$1.parseVar = function (node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types.comma)) {
            break;
          }
        }
        return node;
      };
      pp$1.parseVarId = function (decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$1.parseFunction = function (node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$1.parseFunctionParams = function (node) {
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$1.parseClass = function (node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types.braceL);
        while (this.type !== types.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$1.parseClassElement = function (constructorAllowsSuper) {
        if (this.eat(types.semi)) {
          return null;
        }
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion >= 13 && this.eat(types.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion < 13 || this.type === types.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$1.isClassElementNameStart = function () {
        return this.type === types.name || this.type === types.privateId || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword;
      };
      pp$1.parseClassElementName = function (element) {
        if (this.type === types.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$1.parseClassField = function (field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$1.parseClassStaticBlock = function (node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$1.parseClassId = function (node, isStatement) {
        if (this.type === types.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$1.parseClassSuper = function (node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts(false) : null;
      };
      pp$1.enterClassBody = function () {
        var element = {
          declared: Object.create(null),
          used: []
        };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$1.exitClassBody = function () {
        var ref = this.privateNameStack.pop();
        var declared = ref.declared;
        var used = ref.used;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i = 0; i < used.length; ++i) {
          var id = used[i];
          if (!has(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$1.parseExport = function (node, exports) {
        this.next();
        if (this.eat(types.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseIdent(true);
              this.checkExport(exports, node.exported.name, this.lastTokStart);
            } else {
              node.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types._default)) {
          this.checkExport(exports, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseStatement(null);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports, node.declaration.declarations);
          } else {
            this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports);
          if (this.eatContextual("from")) {
            if (this.type !== types.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
              var spec = list[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$1.checkExport = function (exports, name, pos) {
        if (!exports) {
          return;
        }
        if (has(exports, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports[name] = true;
      };
      pp$1.checkPatternExport = function (exports, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports, pat.name, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i = 0, list = pat.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkPatternExport(exports, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports, pat.expression);
        }
      };
      pp$1.checkVariableExport = function (exports, decls) {
        if (!exports) {
          return;
        }
        for (var i = 0, list = decls; i < list.length; i += 1) {
          var decl = list[i];
          this.checkPatternExport(exports, decl.id);
        }
      };
      pp$1.shouldParseExportStatement = function () {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$1.parseExportSpecifiers = function (exports) {
        var nodes = [], first = true;
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node = this.startNode();
          node.local = this.parseIdent(true);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          this.checkExport(exports, node.exported.name, node.exported.start);
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$1.parseImport = function (node) {
        this.next();
        if (this.type === types.string) {
          node.specifiers = empty;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$1.parseImportSpecifiers = function () {
        var nodes = [], first = true;
        if (this.type === types.name) {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(types.comma)) {
            return nodes;
          }
        }
        if (this.type === types.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$1.adaptDirectivePrologue = function (statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$1.isDirectiveCandidate = function (statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
      };
      var pp$2 = Parser.prototype;
      pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$2.toAssignableList = function (exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$2.parseSpread = function (refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$2.parseRestBinding = function () {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$2.parseBindingAtom = function () {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
          case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types.braceL:
            return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
          }
          if (allowEmpty && this.type === types.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$2.parseBindingListItem = function (param) {
        return param;
      };
      pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$2.checkLValSimple = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (has(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$2.checkLValPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$2.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function (p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$3 = Parser.prototype;
      pp$3.initialContext = function () {
        return [types$1.b_stat];
      };
      pp$3.curContext = function () {
        return this.context[this.context.length - 1];
      };
      pp$3.braceIsBlock = function (prevType) {
        var parent = this.curContext();
        if (parent === types$1.f_expr || parent === types$1.f_stat) {
          return true;
        }
        if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types._return || prevType === types.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
          return true;
        }
        if (prevType === types.braceL) {
          return parent === types$1.b_stat;
        }
        if (prevType === types._var || prevType === types._const || prevType === types.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$3.inGeneratorContext = function () {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$3.updateContext = function (prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$3.overrideContext = function (tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types.parenR.updateContext = types.braceR.updateContext = function () {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types.braceL.updateContext = function (prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
        this.exprAllowed = true;
      };
      types.dollarBraceL.updateContext = function () {
        this.context.push(types$1.b_tmpl);
        this.exprAllowed = true;
      };
      types.parenL.updateContext = function (prevType) {
        var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
        this.exprAllowed = true;
      };
      types.incDec.updateContext = function () {
      };
      types._function.updateContext = types._class.updateContext = function (prevType) {
        if (prevType.beforeExpr && prevType !== types._else && !(prevType === types.semi && this.curContext() !== types$1.p_stat) && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
          this.context.push(types$1.f_expr);
        } else {
          this.context.push(types$1.f_stat);
        }
        this.exprAllowed = false;
      };
      types.backQuote.updateContext = function () {
        if (this.curContext() === types$1.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types$1.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types.star.updateContext = function (prevType) {
        if (prevType === types._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types$1.f_expr) {
            this.context[index] = types$1.f_expr_gen;
          } else {
            this.context[index] = types$1.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types.name.updateContext = function (prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$4 = Parser.prototype;
      pp$4.checkPropClash = function (prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$4.parseExpression = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$4.parseMaybeAssign = function (forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types.parenL || this.type === types.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$4.parseMaybeConditional = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$4.parseExprOps = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$4.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types._in)) {
          if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var coalesce = this.type === types.coalesce;
            if (coalesce) {
              prec = types.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$4.buildBinary = function (startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$4.parseMaybeUnary = function (refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$4.parseExprSubscripts = function (refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$4.parseSubscripts = function (base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$4.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types.bracketL);
        if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types.bracketR);
          } else if (this.type === types.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$4.parseExprAtom = function (refDestructuringErrors, forInit) {
        if (this.type === types.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
        case types._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
            this.overrideContext(types$1.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = {
            pattern: value.pattern,
            flags: value.flags
          };
          return node;
        case types.num:
        case types.string:
          return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
          node = this.startNode();
          node.value = this.type === types._null ? null : this.type === types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types.braceL:
          this.overrideContext(types$1.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types._class:
          return this.parseClass(this.startNode(), false);
        case types._new:
          return this.parseNew();
        case types.backQuote:
          return this.parseTemplate();
        case types._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
        }
      };
      pp$4.parseExprImport = function () {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
        case types.parenL:
          return this.parseDynamicImport(node);
        case types.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
        }
      };
      pp$4.parseDynamicImport = function (node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types.parenR)) {
          var errorPos = this.start;
          if (this.eat(types.comma) && this.eat(types.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$4.parseImportMeta = function (node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$4.parseLiteral = function (value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$4.parseParenExpression = function () {
        this.expect(types.parenL);
        var val = this.parseExpression();
        this.expect(types.parenR);
        return val;
      };
      pp$4.parseParenAndDistinguishExpression = function (canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types.parenR) {
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$4.parseParenItem = function (item) {
        return item;
      };
      pp$4.parseParenArrowList = function (startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, forInit);
      };
      var empty$1 = [];
      pp$4.parseNew = function () {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types.parenL)) {
          node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty$1;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$4.parseTemplateElement = function (ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$4.parseTemplate = function (ref) {
        if (ref === void 0)
          ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged: isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged: isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$4.isAsyncProp = function (prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$4.parseObj = function (isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$4.parseProperty = function (isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$4.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types.colon) {
          this.unexpected();
        }
        if (this.eat(types.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$4.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$4.initFunction = function (node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$4.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$4.parseArrowExpression = function (node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$4.parseFunctionBody = function (node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$4.isSimpleParamList = function (params) {
        for (var i = 0, list = params; i < list.length; i += 1) {
          var param = list[i];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$4.checkParams = function (node, allowDuplicates) {
        var nameHash = Object.create(null);
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$4.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types.comma) {
            elt = null;
          } else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$4.checkUnreserved = function (ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$4.parseIdent = function (liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$4.parsePrivateIdent = function () {
        var node = this.startNode();
        if (this.type === types.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.privateNameStack.length === 0) {
          this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
        return node;
      };
      pp$4.parseYield = function (forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$4.parseAwait = function (forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$5 = Parser.prototype;
      pp$5.raise = function (pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$5.raiseRecoverable = pp$5.raise;
      pp$5.curPosition = function () {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$6 = Parser.prototype;
      var Scope = function Scope(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$6.enterScope = function (flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$6.exitScope = function () {
        this.scopeStack.pop();
      };
      pp$6.treatFunctionsAsVarInScope = function (scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$6.declareName = function (name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$6.checkLocalExport = function (id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$6.currentScope = function () {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$6.currentVarScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$6.currentThisScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [
            pos,
            0
          ];
        }
      };
      var pp$7 = Parser.prototype;
      pp$7.startNode = function () {
        return new Node(this, this.start, this.startLoc);
      };
      pp$7.startNodeAt = function (pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$7.finishNode = function (node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$7.finishNodeAt = function (node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$7.copyNode = function (node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9);
      buildUnicodeData(10);
      buildUnicodeData(11);
      buildUnicodeData(12);
      var pp$8 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
          return i + 1;
        }
        return i + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      function codePointToString(ch) {
        if (ch <= 65535) {
          return String.fromCharCode(ch);
        }
        ch -= 65536;
        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
      }
      pp$8.validateRegExpFlags = function (state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$8.validateRegExpPattern = function (state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$8.regexp_pattern = function (state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
          var name = list[i];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$8.regexp_disjunction = function (state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$8.regexp_alternative = function (state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$8.regexp_eatTerm = function (state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatAssertion = function (state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$8.regexp_eatQuantifier = function (state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatQuantifierPrefix = function (state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$8.regexp_eatBracedQuantifier = function (state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatAtom = function (state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$8.regexp_eatReverseSolidusAtomEscape = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatUncapturingGroup = function (state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatCapturingGroup = function (state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$8.regexp_eatExtendedAtom = function (state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$8.regexp_eatInvalidBracedQuantifier = function (state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$8.regexp_eatSyntaxCharacter = function (state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8.regexp_eatPatternCharacters = function (state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$8.regexp_eatExtendedPatternCharacter = function (state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_groupSpecifier = function (state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$8.regexp_eatGroupName = function (state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierName = function (state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierStart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$8.regexp_eatRegExpIdentifierPart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8.regexp_eatAtomEscape = function (state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$8.regexp_eatBackReference = function (state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatKGroupName = function (state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$8.regexp_eatCharacterEscape = function (state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$8.regexp_eatCControlLetter = function (state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatZero = function (state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlEscape = function (state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlLetter = function (state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8.regexp_eatIdentityEscape = function (state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatDecimalEscape = function (state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatCharacterClassEscape = function (state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8.regexp_eatUnicodePropertyValueExpression = function (state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$8.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
        if (!has(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$8.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$8.regexp_eatUnicodePropertyName = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$8.regexp_eatUnicodePropertyValue = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$8.regexp_eatCharacterClass = function (state) {
        if (state.eat(91)) {
          state.eat(94);
          this.regexp_classRanges(state);
          if (state.eat(93)) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$8.regexp_classRanges = function (state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$8.regexp_eatClassAtom = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatClassEscape = function (state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$8.regexp_eatClassControlLetter = function (state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatHexEscapeSequence = function (state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatDecimalDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8.regexp_eatHexDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$8.regexp_eatLegacyOctalEscapeSequence = function (state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatOctalDigit = function (state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8.regexp_eatFixedHexDigits = function (state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [
            p.start,
            p.end
          ];
        }
      };
      var pp$9 = Parser.prototype;
      pp$9.next = function (ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp$9.getToken = function () {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp$9[Symbol.iterator] = function () {
          var this$1$1 = this;
          return {
            next: function () {
              var token = this$1$1.getToken();
              return {
                done: token.type === types.eof,
                value: token
              };
            }
          };
        };
      }
      pp$9.nextToken = function () {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp$9.readToken = function (code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp$9.fullCharCodeAtPos = function () {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp$9.skipBlockComment = function () {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipLineComment = function (startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipSpace = function () {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
            }
          }
      };
      pp$9.finishToken = function (type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp$9.readToken_dot = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types.dot);
        }
      };
      pp$9.readToken_slash = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.slash, 1);
      };
      pp$9.readToken_mult_modulo_exp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types.star : types.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp$9.readToken_pipe_amp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      };
      pp$9.readToken_caret = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.bitwiseXOR, 1);
      };
      pp$9.readToken_plus_min = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.plusMin, 1);
      };
      pp$9.readToken_lt_gt = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types.assign, size + 1);
          }
          return this.finishOp(types.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types.relational, size);
      };
      pp$9.readToken_eq_excl = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types.arrow);
        }
        return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
      };
      pp$9.readToken_question = function () {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types.assign, 3);
              }
            }
            return this.finishOp(types.coalesce, 2);
          }
        }
        return this.finishOp(types.question, 1);
      };
      pp$9.readToken_numberSign = function () {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };
      pp$9.getTokenFromCode = function (code) {
        switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types.prefix, 1);
        case 35:
          return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };
      pp$9.finishOp = function (type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp$9.readRegexp = function () {
        var escaped, inClass, start = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types.regexp, {
          pattern: pattern,
          flags: flags,
          value: value
        });
      };
      pp$9.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp$9.readRadixNumber = function (radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types.num, val);
      };
      pp$9.readNumber = function (startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types.num, val);
      };
      pp$9.readCodePoint = function () {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      function codePointToString$1(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      pp$9.readString = function (quote) {
        var out = "", chunkStart = ++this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp$9.tryReadTemplateToken = function () {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp$9.invalidStringToken = function (position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp$9.readTmplToken = function () {
        var out = "", chunkStart = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp$9.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp$9.readEscapedChar = function (inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString$1(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\x0B";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
        }
      };
      pp$9.readHexChar = function (len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp$9.readWord1 = function () {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString$1(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp$9.readWord = function () {
        var word = this.readWord1();
        var type = types.name;
        if (this.keywords.test(word)) {
          type = keywords$1[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.5.0";
      Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node,
        TokenType: TokenType,
        tokTypes: types,
        keywordTypes: keywords$1,
        TokContext: TokContext,
        tokContexts: types$1,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports.Node = Node;
      exports.Parser = Parser;
      exports.Position = Position;
      exports.SourceLocation = SourceLocation;
      exports.TokContext = TokContext;
      exports.Token = Token;
      exports.TokenType = TokenType;
      exports.defaultOptions = defaultOptions;
      exports.getLineInfo = getLineInfo;
      exports.isIdentifierChar = isIdentifierChar;
      exports.isIdentifierStart = isIdentifierStart;
      exports.isNewLine = isNewLine;
      exports.keywordTypes = keywords$1;
      exports.lineBreak = lineBreak;
      exports.lineBreakG = lineBreakG;
      exports.nonASCIIwhitespace = nonASCIIwhitespace;
      exports.parse = parse;
      exports.parseExpressionAt = parseExpressionAt;
      exports.tokContexts = types$1;
      exports.tokTypes = types;
      exports.tokenizer = tokenizer;
      exports.version = version;
      Object.defineProperty(exports, "__esModule", { value: true });
    }));
  }(acorn$1, acorn$1.exports));
  return acorn$1.exports;
}

(function (module, exports) {
  (function (global, factory) {
    factory(exports, requireAcorn()) ;
  }(commonjsGlobal, function (exports, acorn) {
    var dummyValue = "\u2716";
    function isDummy(node) {
      return node.name === dummyValue;
    }
    function noop() {
    }
    var LooseParser = function LooseParser(input, options) {
      if (options === void 0)
        options = {};
      this.toks = this.constructor.BaseParser.tokenizer(input, options);
      this.options = this.toks.options;
      this.input = this.toks.input;
      this.tok = this.last = {
        type: acorn.tokTypes.eof,
        start: 0,
        end: 0
      };
      this.tok.validateRegExpFlags = noop;
      this.tok.validateRegExpPattern = noop;
      if (this.options.locations) {
        var here = this.toks.curPosition();
        this.tok.loc = new acorn.SourceLocation(this.toks, here, here);
      }
      this.ahead = [];
      this.context = [];
      this.curIndent = 0;
      this.curLineStart = 0;
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
      this.inAsync = false;
      this.inGenerator = false;
      this.inFunction = false;
    };
    LooseParser.prototype.startNode = function startNode() {
      return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
    };
    LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
      return this.options.locations ? [
        this.tok.start,
        this.tok.loc.start
      ] : this.tok.start;
    };
    LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
      if (this.options.locations) {
        return new acorn.Node(this.toks, pos[0], pos[1]);
      } else {
        return new acorn.Node(this.toks, pos);
      }
    };
    LooseParser.prototype.finishNode = function finishNode(node, type) {
      node.type = type;
      node.end = this.last.end;
      if (this.options.locations) {
        node.loc.end = this.last.loc.end;
      }
      if (this.options.ranges) {
        node.range[1] = this.last.end;
      }
      return node;
    };
    LooseParser.prototype.dummyNode = function dummyNode(type) {
      var dummy = this.startNode();
      dummy.type = type;
      dummy.end = dummy.start;
      if (this.options.locations) {
        dummy.loc.end = dummy.loc.start;
      }
      if (this.options.ranges) {
        dummy.range[1] = dummy.start;
      }
      this.last = {
        type: acorn.tokTypes.name,
        start: dummy.start,
        end: dummy.start,
        loc: dummy.loc
      };
      return dummy;
    };
    LooseParser.prototype.dummyIdent = function dummyIdent() {
      var dummy = this.dummyNode("Identifier");
      dummy.name = dummyValue;
      return dummy;
    };
    LooseParser.prototype.dummyString = function dummyString() {
      var dummy = this.dummyNode("Literal");
      dummy.value = dummy.raw = dummyValue;
      return dummy;
    };
    LooseParser.prototype.eat = function eat(type) {
      if (this.tok.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    LooseParser.prototype.isContextual = function isContextual(name) {
      return this.tok.type === acorn.tokTypes.name && this.tok.value === name;
    };
    LooseParser.prototype.eatContextual = function eatContextual(name) {
      return this.tok.value === name && this.eat(acorn.tokTypes.name);
    };
    LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
      return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR || acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
    };
    LooseParser.prototype.semicolon = function semicolon() {
      return this.eat(acorn.tokTypes.semi);
    };
    LooseParser.prototype.expect = function expect(type) {
      if (this.eat(type)) {
        return true;
      }
      for (var i = 1; i <= 2; i++) {
        if (this.lookAhead(i).type === type) {
          for (var j = 0; j < i; j++) {
            this.next();
          }
          return true;
        }
      }
    };
    LooseParser.prototype.pushCx = function pushCx() {
      this.context.push(this.curIndent);
    };
    LooseParser.prototype.popCx = function popCx() {
      this.curIndent = this.context.pop();
    };
    LooseParser.prototype.lineEnd = function lineEnd(pos) {
      while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) {
        ++pos;
      }
      return pos;
    };
    LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
      for (var count = 0;; ++pos) {
        var ch = this.input.charCodeAt(pos);
        if (ch === 32) {
          ++count;
        } else if (ch === 9) {
          count += this.options.tabSize;
        } else {
          return count;
        }
      }
    };
    LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
      if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) {
        return true;
      }
      return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
    };
    LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
      for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
        var ch = this.input.charCodeAt(p);
        if (ch !== 9 && ch !== 32) {
          return false;
        }
      }
      return true;
    };
    LooseParser.prototype.extend = function extend(name, f) {
      this[name] = f(this[name]);
    };
    LooseParser.prototype.parse = function parse() {
      this.next();
      return this.parseTopLevel();
    };
    LooseParser.extend = function extend() {
      var plugins = [], len = arguments.length;
      while (len--)
        plugins[len] = arguments[len];
      var cls = this;
      for (var i = 0; i < plugins.length; i++) {
        cls = plugins[i](cls);
      }
      return cls;
    };
    LooseParser.parse = function parse(input, options) {
      return new this(input, options).parse();
    };
    LooseParser.BaseParser = acorn.Parser;
    var lp$2 = LooseParser.prototype;
    function isSpace(ch) {
      return ch < 14 && ch > 8 || ch === 32 || ch === 160 || acorn.isNewLine(ch);
    }
    lp$2.next = function () {
      this.last = this.tok;
      if (this.ahead.length) {
        this.tok = this.ahead.shift();
      } else {
        this.tok = this.readToken();
      }
      if (this.tok.start >= this.nextLineStart) {
        while (this.tok.start >= this.nextLineStart) {
          this.curLineStart = this.nextLineStart;
          this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
        }
        this.curIndent = this.indentationAfter(this.curLineStart);
      }
    };
    lp$2.readToken = function () {
      for (;;) {
        try {
          this.toks.next();
          if (this.toks.type === acorn.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
            this.toks.end++;
            this.toks.type = acorn.tokTypes.ellipsis;
          }
          return new acorn.Token(this.toks);
        } catch (e) {
          if (!(e instanceof SyntaxError)) {
            throw e;
          }
          var msg = e.message, pos = e.raisedAt, replace = true;
          if (/unterminated/i.test(msg)) {
            pos = this.lineEnd(e.pos + 1);
            if (/string/.test(msg)) {
              replace = {
                start: e.pos,
                end: pos,
                type: acorn.tokTypes.string,
                value: this.input.slice(e.pos + 1, pos)
              };
            } else if (/regular expr/i.test(msg)) {
              var re = this.input.slice(e.pos, pos);
              try {
                re = new RegExp(re);
              } catch (e$1) {
              }
              replace = {
                start: e.pos,
                end: pos,
                type: acorn.tokTypes.regexp,
                value: re
              };
            } else if (/template/.test(msg)) {
              replace = {
                start: e.pos,
                end: pos,
                type: acorn.tokTypes.template,
                value: this.input.slice(e.pos, pos)
              };
            } else {
              replace = false;
            }
          } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
            while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {
              ++pos;
            }
          } else if (/character escape|expected hexadecimal/i.test(msg)) {
            while (pos < this.input.length) {
              var ch = this.input.charCodeAt(pos++);
              if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) {
                break;
              }
            }
          } else if (/unexpected character/i.test(msg)) {
            pos++;
            replace = false;
          } else if (/regular expression/i.test(msg)) {
            replace = true;
          } else {
            throw e;
          }
          this.resetTo(pos);
          if (replace === true) {
            replace = {
              start: pos,
              end: pos,
              type: acorn.tokTypes.name,
              value: dummyValue
            };
          }
          if (replace) {
            if (this.options.locations) {
              replace.loc = new acorn.SourceLocation(this.toks, acorn.getLineInfo(this.input, replace.start), acorn.getLineInfo(this.input, replace.end));
            }
            return replace;
          }
        }
      }
    };
    lp$2.resetTo = function (pos) {
      this.toks.pos = pos;
      var ch = this.input.charAt(pos - 1);
      this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));
      if (this.options.locations) {
        this.toks.curLine = 1;
        this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;
        var match;
        while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {
          ++this.toks.curLine;
          this.toks.lineStart = match.index + match[0].length;
        }
      }
    };
    lp$2.lookAhead = function (n) {
      while (n > this.ahead.length) {
        this.ahead.push(this.readToken());
      }
      return this.ahead[n - 1];
    };
    var lp$1 = LooseParser.prototype;
    lp$1.parseTopLevel = function () {
      var node = this.startNodeAt(this.options.locations ? [
        0,
        acorn.getLineInfo(this.input, 0)
      ] : 0);
      node.body = [];
      while (this.tok.type !== acorn.tokTypes.eof) {
        node.body.push(this.parseStatement());
      }
      this.toks.adaptDirectivePrologue(node.body);
      this.last = this.tok;
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program");
    };
    lp$1.parseStatement = function () {
      var starttype = this.tok.type, node = this.startNode(), kind;
      if (this.toks.isLet()) {
        starttype = acorn.tokTypes._var;
        kind = "let";
      }
      switch (starttype) {
      case acorn.tokTypes._break:
      case acorn.tokTypes._continue:
        this.next();
        var isBreak = starttype === acorn.tokTypes._break;
        if (this.semicolon() || this.canInsertSemicolon()) {
          node.label = null;
        } else {
          node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;
          this.semicolon();
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      case acorn.tokTypes._debugger:
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      case acorn.tokTypes._do:
        this.next();
        node.body = this.parseStatement();
        node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
        this.semicolon();
        return this.finishNode(node, "DoWhileStatement");
      case acorn.tokTypes._for:
        this.next();
        var isAwait = this.options.ecmaVersion >= 9 && this.eatContextual("await");
        this.pushCx();
        this.expect(acorn.tokTypes.parenL);
        if (this.tok.type === acorn.tokTypes.semi) {
          return this.parseFor(node, null);
        }
        var isLet = this.toks.isLet();
        if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {
          var init$1 = this.parseVar(this.startNode(), true, isLet ? "let" : this.tok.value);
          if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual("of"))) {
            if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {
              node.await = isAwait;
            }
            return this.parseForIn(node, init$1);
          }
          return this.parseFor(node, init$1);
        }
        var init = this.parseExpression(true);
        if (this.tok.type === acorn.tokTypes._in || this.isContextual("of")) {
          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {
            node.await = isAwait;
          }
          return this.parseForIn(node, this.toAssignable(init));
        }
        return this.parseFor(node, init);
      case acorn.tokTypes._function:
        this.next();
        return this.parseFunction(node, true);
      case acorn.tokTypes._if:
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement();
        node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;
        return this.finishNode(node, "IfStatement");
      case acorn.tokTypes._return:
        this.next();
        if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      case acorn.tokTypes._switch:
        var blockIndent = this.curIndent, line = this.curLineStart;
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.pushCx();
        this.expect(acorn.tokTypes.braceL);
        var cur;
        while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {
          if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {
            var isCase = this.tok.type === acorn.tokTypes._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              cur.test = null;
            }
            this.expect(acorn.tokTypes.colon);
          } else {
            if (!cur) {
              node.cases.push(cur = this.startNode());
              cur.consequent = [];
              cur.test = null;
            }
            cur.consequent.push(this.parseStatement());
          }
        }
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.popCx();
        this.eat(acorn.tokTypes.braceR);
        return this.finishNode(node, "SwitchStatement");
      case acorn.tokTypes._throw:
        this.next();
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      case acorn.tokTypes._try:
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.tok.type === acorn.tokTypes._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(acorn.tokTypes.parenL)) {
            clause.param = this.toAssignable(this.parseExprAtom(), true);
            this.expect(acorn.tokTypes.parenR);
          } else {
            clause.param = null;
          }
          clause.body = this.parseBlock();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          return node.block;
        }
        return this.finishNode(node, "TryStatement");
      case acorn.tokTypes._var:
      case acorn.tokTypes._const:
        return this.parseVar(node, false, kind || this.tok.value);
      case acorn.tokTypes._while:
        this.next();
        node.test = this.parseParenExpression();
        node.body = this.parseStatement();
        return this.finishNode(node, "WhileStatement");
      case acorn.tokTypes._with:
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement();
        return this.finishNode(node, "WithStatement");
      case acorn.tokTypes.braceL:
        return this.parseBlock();
      case acorn.tokTypes.semi:
        this.next();
        return this.finishNode(node, "EmptyStatement");
      case acorn.tokTypes._class:
        return this.parseClass(true);
      case acorn.tokTypes._import:
        if (this.options.ecmaVersion > 10) {
          var nextType = this.lookAhead(1).type;
          if (nextType === acorn.tokTypes.parenL || nextType === acorn.tokTypes.dot) {
            node.expression = this.parseExpression();
            this.semicolon();
            return this.finishNode(node, "ExpressionStatement");
          }
        }
        return this.parseImport();
      case acorn.tokTypes._export:
        return this.parseExport();
      default:
        if (this.toks.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(node, true, true);
        }
        var expr = this.parseExpression();
        if (isDummy(expr)) {
          this.next();
          if (this.tok.type === acorn.tokTypes.eof) {
            return this.finishNode(node, "EmptyStatement");
          }
          return this.parseStatement();
        } else if (starttype === acorn.tokTypes.name && expr.type === "Identifier" && this.eat(acorn.tokTypes.colon)) {
          node.body = this.parseStatement();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        } else {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
      }
    };
    lp$1.parseBlock = function () {
      var node = this.startNode();
      this.pushCx();
      this.expect(acorn.tokTypes.braceL);
      var blockIndent = this.curIndent, line = this.curLineStart;
      node.body = [];
      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {
        node.body.push(this.parseStatement());
      }
      this.popCx();
      this.eat(acorn.tokTypes.braceR);
      return this.finishNode(node, "BlockStatement");
    };
    lp$1.parseFor = function (node, init) {
      node.init = init;
      node.test = node.update = null;
      if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) {
        node.test = this.parseExpression();
      }
      if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) {
        node.update = this.parseExpression();
      }
      this.popCx();
      this.expect(acorn.tokTypes.parenR);
      node.body = this.parseStatement();
      return this.finishNode(node, "ForStatement");
    };
    lp$1.parseForIn = function (node, init) {
      var type = this.tok.type === acorn.tokTypes._in ? "ForInStatement" : "ForOfStatement";
      this.next();
      node.left = init;
      node.right = this.parseExpression();
      this.popCx();
      this.expect(acorn.tokTypes.parenR);
      node.body = this.parseStatement();
      return this.finishNode(node, type);
    };
    lp$1.parseVar = function (node, noIn, kind) {
      node.kind = kind;
      this.next();
      node.declarations = [];
      do {
        var decl = this.startNode();
        decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
        decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      } while (this.eat(acorn.tokTypes.comma));
      if (!node.declarations.length) {
        var decl$1 = this.startNode();
        decl$1.id = this.dummyIdent();
        node.declarations.push(this.finishNode(decl$1, "VariableDeclarator"));
      }
      if (!noIn) {
        this.semicolon();
      }
      return this.finishNode(node, "VariableDeclaration");
    };
    lp$1.parseClass = function (isStatement) {
      var node = this.startNode();
      this.next();
      if (this.tok.type === acorn.tokTypes.name) {
        node.id = this.parseIdent();
      } else if (isStatement === true) {
        node.id = this.dummyIdent();
      } else {
        node.id = null;
      }
      node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;
      node.body = this.startNode();
      node.body.body = [];
      this.pushCx();
      var indent = this.curIndent + 1, line = this.curLineStart;
      this.eat(acorn.tokTypes.braceL);
      if (this.curIndent + 1 < indent) {
        indent = this.curIndent;
        line = this.curLineStart;
      }
      while (!this.closes(acorn.tokTypes.braceR, indent, line)) {
        var element = this.parseClassElement();
        if (element) {
          node.body.body.push(element);
        }
      }
      this.popCx();
      if (!this.eat(acorn.tokTypes.braceR)) {
        this.last.end = this.tok.start;
        if (this.options.locations) {
          this.last.loc.end = this.tok.loc.start;
        }
      }
      this.semicolon();
      this.finishNode(node.body, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    lp$1.parseClassElement = function () {
      if (this.eat(acorn.tokTypes.semi)) {
        return null;
      }
      var ref = this.options;
      var ecmaVersion = ref.ecmaVersion;
      var locations = ref.locations;
      var indent = this.curIndent;
      var line = this.curLineStart;
      var node = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion >= 13 && this.eat(acorn.tokTypes.braceL)) {
          this.parseClassStaticBlock(node);
          return node;
        }
        if (this.isClassElementNameStart() || this.toks.type === acorn.tokTypes.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.toks.type === acorn.tokTypes.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName) {
        isGenerator = this.eat(acorn.tokTypes.star);
        var lastValue = this.toks.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node.computed = false;
        node.key = this.startNodeAt(locations ? [
          this.toks.lastTokStart,
          this.toks.lastTokStartLoc
        ] : this.toks.lastTokStart);
        node.key.name = keyName;
        this.finishNode(node.key, "Identifier");
      } else {
        this.parseClassElementName(node);
        if (isDummy(node.key)) {
          if (isDummy(this.parseMaybeAssign())) {
            this.next();
          }
          this.eat(acorn.tokTypes.comma);
          return null;
        }
      }
      if (ecmaVersion < 13 || this.toks.type === acorn.tokTypes.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node.computed && !node.static && !isGenerator && !isAsync && kind === "method" && (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && node.key.value === "constructor");
        node.kind = isConstructor ? "constructor" : kind;
        node.value = this.parseMethod(isGenerator, isAsync);
        this.finishNode(node, "MethodDefinition");
      } else {
        if (this.eat(acorn.tokTypes.eq)) {
          if (this.curLineStart !== line && this.curIndent <= indent && this.tokenStartsLine()) {
            node.value = null;
          } else {
            var oldInAsync = this.inAsync;
            var oldInGenerator = this.inGenerator;
            this.inAsync = false;
            this.inGenerator = false;
            node.value = this.parseMaybeAssign();
            this.inAsync = oldInAsync;
            this.inGenerator = oldInGenerator;
          }
        } else {
          node.value = null;
        }
        this.semicolon();
        this.finishNode(node, "PropertyDefinition");
      }
      return node;
    };
    lp$1.parseClassStaticBlock = function (node) {
      var blockIndent = this.curIndent, line = this.curLineStart;
      node.body = [];
      this.pushCx();
      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {
        node.body.push(this.parseStatement());
      }
      this.popCx();
      this.eat(acorn.tokTypes.braceR);
      return this.finishNode(node, "StaticBlock");
    };
    lp$1.isClassElementNameStart = function () {
      return this.toks.isClassElementNameStart();
    };
    lp$1.parseClassElementName = function (element) {
      if (this.toks.type === acorn.tokTypes.privateId) {
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    lp$1.parseFunction = function (node, isStatement, isAsync) {
      var oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = this.eat(acorn.tokTypes.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      if (this.tok.type === acorn.tokTypes.name) {
        node.id = this.parseIdent();
      } else if (isStatement === true) {
        node.id = this.dummyIdent();
      }
      this.inAsync = node.async;
      this.inGenerator = node.generator;
      this.inFunction = true;
      node.params = this.parseFunctionParams();
      node.body = this.parseBlock();
      this.toks.adaptDirectivePrologue(node.body.body);
      this.inAsync = oldInAsync;
      this.inGenerator = oldInGenerator;
      this.inFunction = oldInFunction;
      return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
    };
    lp$1.parseExport = function () {
      var node = this.startNode();
      this.next();
      if (this.eat(acorn.tokTypes.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseExprAtom();
          } else {
            node.exported = null;
          }
        }
        node.source = this.eatContextual("from") ? this.parseExprAtom() : this.dummyString();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(acorn.tokTypes._default)) {
        var isAsync;
        if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node.declaration = this.parseFunction(fNode, "nullableID", isAsync);
        } else if (this.tok.type === acorn.tokTypes._class) {
          node.declaration = this.parseClass("nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {
        node.declaration = this.parseStatement();
        node.specifiers = [];
        node.source = null;
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifierList();
        node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    lp$1.parseImport = function () {
      var node = this.startNode();
      this.next();
      if (this.tok.type === acorn.tokTypes.string) {
        node.specifiers = [];
        node.source = this.parseExprAtom();
      } else {
        var elt;
        if (this.tok.type === acorn.tokTypes.name && this.tok.value !== "from") {
          elt = this.startNode();
          elt.local = this.parseIdent();
          this.finishNode(elt, "ImportDefaultSpecifier");
          this.eat(acorn.tokTypes.comma);
        }
        node.specifiers = this.parseImportSpecifiers();
        node.source = this.eatContextual("from") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();
        if (elt) {
          node.specifiers.unshift(elt);
        }
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    lp$1.parseImportSpecifiers = function () {
      var elts = [];
      if (this.tok.type === acorn.tokTypes.star) {
        var elt = this.startNode();
        this.next();
        elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
        elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
      } else {
        var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;
        this.pushCx();
        this.eat(acorn.tokTypes.braceL);
        if (this.curLineStart > continuedLine) {
          continuedLine = this.curLineStart;
        }
        while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
          var elt$1 = this.startNode();
          if (this.eat(acorn.tokTypes.star)) {
            elt$1.local = this.eatContextual("as") ? this.parseModuleExportName() : this.dummyIdent();
            this.finishNode(elt$1, "ImportNamespaceSpecifier");
          } else {
            if (this.isContextual("from")) {
              break;
            }
            elt$1.imported = this.parseModuleExportName();
            if (isDummy(elt$1.imported)) {
              break;
            }
            elt$1.local = this.eatContextual("as") ? this.parseModuleExportName() : elt$1.imported;
            this.finishNode(elt$1, "ImportSpecifier");
          }
          elts.push(elt$1);
          this.eat(acorn.tokTypes.comma);
        }
        this.eat(acorn.tokTypes.braceR);
        this.popCx();
      }
      return elts;
    };
    lp$1.parseExportSpecifierList = function () {
      var elts = [];
      var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;
      this.pushCx();
      this.eat(acorn.tokTypes.braceL);
      if (this.curLineStart > continuedLine) {
        continuedLine = this.curLineStart;
      }
      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
        if (this.isContextual("from")) {
          break;
        }
        var elt = this.startNode();
        elt.local = this.parseModuleExportName();
        if (isDummy(elt.local)) {
          break;
        }
        elt.exported = this.eatContextual("as") ? this.parseModuleExportName() : elt.local;
        this.finishNode(elt, "ExportSpecifier");
        elts.push(elt);
        this.eat(acorn.tokTypes.comma);
      }
      this.eat(acorn.tokTypes.braceR);
      this.popCx();
      return elts;
    };
    lp$1.parseModuleExportName = function () {
      return this.options.ecmaVersion >= 13 && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
    };
    var lp = LooseParser.prototype;
    lp.checkLVal = function (expr) {
      if (!expr) {
        return expr;
      }
      switch (expr.type) {
      case "Identifier":
      case "MemberExpression":
        return expr;
      case "ParenthesizedExpression":
        expr.expression = this.checkLVal(expr.expression);
        return expr;
      default:
        return this.dummyIdent();
      }
    };
    lp.parseExpression = function (noIn) {
      var start = this.storeCurrentPos();
      var expr = this.parseMaybeAssign(noIn);
      if (this.tok.type === acorn.tokTypes.comma) {
        var node = this.startNodeAt(start);
        node.expressions = [expr];
        while (this.eat(acorn.tokTypes.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn));
        }
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    lp.parseParenExpression = function () {
      this.pushCx();
      this.expect(acorn.tokTypes.parenL);
      var val = this.parseExpression();
      this.popCx();
      this.expect(acorn.tokTypes.parenR);
      return val;
    };
    lp.parseMaybeAssign = function (noIn) {
      if (this.inGenerator && this.toks.isContextual("yield")) {
        var node = this.startNode();
        this.next();
        if (this.semicolon() || this.canInsertSemicolon() || this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(acorn.tokTypes.star);
          node.argument = this.parseMaybeAssign();
        }
        return this.finishNode(node, "YieldExpression");
      }
      var start = this.storeCurrentPos();
      var left = this.parseMaybeConditional(noIn);
      if (this.tok.type.isAssign) {
        var node$1 = this.startNodeAt(start);
        node$1.operator = this.tok.value;
        node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
        this.next();
        node$1.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node$1, "AssignmentExpression");
      }
      return left;
    };
    lp.parseMaybeConditional = function (noIn) {
      var start = this.storeCurrentPos();
      var expr = this.parseExprOps(noIn);
      if (this.eat(acorn.tokTypes.question)) {
        var node = this.startNodeAt(start);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    lp.parseExprOps = function (noIn) {
      var start = this.storeCurrentPos();
      var indent = this.curIndent, line = this.curLineStart;
      return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
    };
    lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {
        return left;
      }
      var prec = this.tok.type.binop;
      if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {
        if (prec > minPrec) {
          var node = this.startNodeAt(start);
          node.left = left;
          node.operator = this.tok.value;
          this.next();
          if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {
            node.right = this.dummyIdent();
          } else {
            var rightStart = this.storeCurrentPos();
            node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
          }
          this.finishNode(node, /&&|\|\||\?\?/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, start, minPrec, noIn, indent, line);
        }
      }
      return left;
    };
    lp.parseMaybeUnary = function (sawUnary) {
      var start = this.storeCurrentPos(), expr;
      if (this.options.ecmaVersion >= 8 && this.toks.isContextual("await") && (this.inAsync || this.toks.inModule && this.options.ecmaVersion >= 13 || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
        expr = this.parseAwait();
        sawUnary = true;
      } else if (this.tok.type.prefix) {
        var node = this.startNode(), update = this.tok.type === acorn.tokTypes.incDec;
        if (!update) {
          sawUnary = true;
        }
        node.operator = this.tok.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(true);
        if (update) {
          node.argument = this.checkLVal(node.argument);
        }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else if (this.tok.type === acorn.tokTypes.ellipsis) {
        var node$1 = this.startNode();
        this.next();
        node$1.argument = this.parseMaybeUnary(sawUnary);
        expr = this.finishNode(node$1, "SpreadElement");
      } else if (!sawUnary && this.tok.type === acorn.tokTypes.privateId) {
        expr = this.parsePrivateIdent();
      } else {
        expr = this.parseExprSubscripts();
        while (this.tok.type.postfix && !this.canInsertSemicolon()) {
          var node$2 = this.startNodeAt(start);
          node$2.operator = this.tok.value;
          node$2.prefix = false;
          node$2.argument = this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node$2, "UpdateExpression");
        }
      }
      if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {
        var node$3 = this.startNodeAt(start);
        node$3.operator = "**";
        node$3.left = expr;
        node$3.right = this.parseMaybeUnary(false);
        return this.finishNode(node$3, "BinaryExpression");
      }
      return expr;
    };
    lp.parseExprSubscripts = function () {
      var start = this.storeCurrentPos();
      return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
    };
    lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optionalChained = false;
      for (;;) {
        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {
          if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent) {
            --startIndent;
          } else {
            break;
          }
        }
        var maybeAsyncArrow = base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
        var optional = optionalSupported && this.eat(acorn.tokTypes.questionDot);
        if (optional) {
          optionalChained = true;
        }
        if (optional && this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.bracketL && this.tok.type !== acorn.tokTypes.backQuote || this.eat(acorn.tokTypes.dot)) {
          var node = this.startNodeAt(start);
          node.object = base;
          if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {
            node.property = this.dummyIdent();
          } else {
            node.property = this.parsePropertyAccessor() || this.dummyIdent();
          }
          node.computed = false;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (this.tok.type === acorn.tokTypes.bracketL) {
          this.pushCx();
          this.next();
          var node$1 = this.startNodeAt(start);
          node$1.object = base;
          node$1.property = this.parseExpression();
          node$1.computed = true;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          this.popCx();
          this.expect(acorn.tokTypes.bracketR);
          base = this.finishNode(node$1, "MemberExpression");
        } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {
          var exprList = this.parseExprList(acorn.tokTypes.parenR);
          if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow)) {
            return this.parseArrowExpression(this.startNodeAt(start), exprList, true);
          }
          var node$2 = this.startNodeAt(start);
          node$2.callee = base;
          node$2.arguments = exprList;
          if (optionalSupported) {
            node$2.optional = optional;
          }
          base = this.finishNode(node$2, "CallExpression");
        } else if (this.tok.type === acorn.tokTypes.backQuote) {
          var node$3 = this.startNodeAt(start);
          node$3.tag = base;
          node$3.quasi = this.parseTemplate();
          base = this.finishNode(node$3, "TaggedTemplateExpression");
        } else {
          break;
        }
      }
      if (optionalChained) {
        var chainNode = this.startNodeAt(start);
        chainNode.expression = base;
        base = this.finishNode(chainNode, "ChainExpression");
      }
      return base;
    };
    lp.parseExprAtom = function () {
      var node;
      switch (this.tok.type) {
      case acorn.tokTypes._this:
      case acorn.tokTypes._super:
        var type = this.tok.type === acorn.tokTypes._this ? "ThisExpression" : "Super";
        node = this.startNode();
        this.next();
        return this.finishNode(node, type);
      case acorn.tokTypes.name:
        var start = this.storeCurrentPos();
        var id = this.parseIdent();
        var isAsync = false;
        if (id.name === "async" && !this.canInsertSemicolon()) {
          if (this.eat(acorn.tokTypes._function)) {
            this.toks.overrideContext(acorn.tokContexts.f_expr);
            return this.parseFunction(this.startNodeAt(start), false, true);
          }
          if (this.tok.type === acorn.tokTypes.name) {
            id = this.parseIdent();
            isAsync = true;
          }
        }
        return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;
      case acorn.tokTypes.regexp:
        node = this.startNode();
        var val = this.tok.value;
        node.regex = {
          pattern: val.pattern,
          flags: val.flags
        };
        node.value = val.value;
        node.raw = this.input.slice(this.tok.start, this.tok.end);
        this.next();
        return this.finishNode(node, "Literal");
      case acorn.tokTypes.num:
      case acorn.tokTypes.string:
        node = this.startNode();
        node.value = this.tok.value;
        node.raw = this.input.slice(this.tok.start, this.tok.end);
        if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      case acorn.tokTypes._null:
      case acorn.tokTypes._true:
      case acorn.tokTypes._false:
        node = this.startNode();
        node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;
        node.raw = this.tok.type.keyword;
        this.next();
        return this.finishNode(node, "Literal");
      case acorn.tokTypes.parenL:
        var parenStart = this.storeCurrentPos();
        this.next();
        var inner = this.parseExpression();
        this.expect(acorn.tokTypes.parenR);
        if (this.eat(acorn.tokTypes.arrow)) {
          var params = inner.expressions || [inner];
          if (params.length && isDummy(params[params.length - 1])) {
            params.pop();
          }
          return this.parseArrowExpression(this.startNodeAt(parenStart), params);
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(parenStart);
          par.expression = inner;
          inner = this.finishNode(par, "ParenthesizedExpression");
        }
        return inner;
      case acorn.tokTypes.bracketL:
        node = this.startNode();
        node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);
        return this.finishNode(node, "ArrayExpression");
      case acorn.tokTypes.braceL:
        this.toks.overrideContext(acorn.tokContexts.b_expr);
        return this.parseObj();
      case acorn.tokTypes._class:
        return this.parseClass(false);
      case acorn.tokTypes._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, false);
      case acorn.tokTypes._new:
        return this.parseNew();
      case acorn.tokTypes.backQuote:
        return this.parseTemplate();
      case acorn.tokTypes._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport();
        } else {
          return this.dummyIdent();
        }
      default:
        return this.dummyIdent();
      }
    };
    lp.parseExprImport = function () {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      switch (this.tok.type) {
      case acorn.tokTypes.parenL:
        return this.parseDynamicImport(node);
      case acorn.tokTypes.dot:
        node.meta = meta;
        return this.parseImportMeta(node);
      default:
        node.name = "import";
        return this.finishNode(node, "Identifier");
      }
    };
    lp.parseDynamicImport = function (node) {
      node.source = this.parseExprList(acorn.tokTypes.parenR)[0] || this.dummyString();
      return this.finishNode(node, "ImportExpression");
    };
    lp.parseImportMeta = function (node) {
      this.next();
      node.property = this.parseIdent(true);
      return this.finishNode(node, "MetaProperty");
    };
    lp.parseNew = function () {
      var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {
        node.meta = meta;
        node.property = this.parseIdent(true);
        return this.finishNode(node, "MetaProperty");
      }
      var start = this.storeCurrentPos();
      node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
      if (this.tok.type === acorn.tokTypes.parenL) {
        node.arguments = this.parseExprList(acorn.tokTypes.parenR);
      } else {
        node.arguments = [];
      }
      return this.finishNode(node, "NewExpression");
    };
    lp.parseTemplateElement = function () {
      var elem = this.startNode();
      if (this.tok.type === acorn.tokTypes.invalidTemplate) {
        elem.value = {
          raw: this.tok.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, "\n"),
          cooked: this.tok.value
        };
      }
      this.next();
      elem.tail = this.tok.type === acorn.tokTypes.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    lp.parseTemplate = function () {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement();
      node.quasis = [curElt];
      while (!curElt.tail) {
        this.next();
        node.expressions.push(this.parseExpression());
        if (this.expect(acorn.tokTypes.braceR)) {
          curElt = this.parseTemplateElement();
        } else {
          curElt = this.startNode();
          curElt.value = {
            cooked: "",
            raw: ""
          };
          curElt.tail = true;
          this.finishNode(curElt, "TemplateElement");
        }
        node.quasis.push(curElt);
      }
      this.expect(acorn.tokTypes.backQuote);
      return this.finishNode(node, "TemplateLiteral");
    };
    lp.parseObj = function () {
      var node = this.startNode();
      node.properties = [];
      this.pushCx();
      var indent = this.curIndent + 1, line = this.curLineStart;
      this.eat(acorn.tokTypes.braceL);
      if (this.curIndent + 1 < indent) {
        indent = this.curIndent;
        line = this.curLineStart;
      }
      while (!this.closes(acorn.tokTypes.braceR, indent, line)) {
        var prop = this.startNode(), isGenerator = void 0, isAsync = void 0, start = void 0;
        if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {
          prop.argument = this.parseMaybeAssign();
          node.properties.push(this.finishNode(prop, "SpreadElement"));
          this.eat(acorn.tokTypes.comma);
          continue;
        }
        if (this.options.ecmaVersion >= 6) {
          start = this.storeCurrentPos();
          prop.method = false;
          prop.shorthand = false;
          isGenerator = this.eat(acorn.tokTypes.star);
        }
        this.parsePropertyName(prop);
        if (this.toks.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        if (isDummy(prop.key)) {
          if (isDummy(this.parseMaybeAssign())) {
            this.next();
          }
          this.eat(acorn.tokTypes.comma);
          continue;
        }
        if (this.eat(acorn.tokTypes.colon)) {
          prop.kind = "init";
          prop.value = this.parseMaybeAssign();
        } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq) {
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
        } else {
          prop.kind = "init";
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(acorn.tokTypes.eq)) {
              var assign = this.startNodeAt(start);
              assign.operator = "=";
              assign.left = prop.key;
              assign.right = this.parseMaybeAssign();
              prop.value = this.finishNode(assign, "AssignmentExpression");
            } else {
              prop.value = prop.key;
            }
          } else {
            prop.value = this.dummyIdent();
          }
          prop.shorthand = true;
        }
        node.properties.push(this.finishNode(prop, "Property"));
        this.eat(acorn.tokTypes.comma);
      }
      this.popCx();
      if (!this.eat(acorn.tokTypes.braceR)) {
        this.last.end = this.tok.start;
        if (this.options.locations) {
          this.last.loc.end = this.tok.loc.start;
        }
      }
      return this.finishNode(node, "ObjectExpression");
    };
    lp.parsePropertyName = function (prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(acorn.tokTypes.bracketL)) {
          prop.computed = true;
          prop.key = this.parseExpression();
          this.expect(acorn.tokTypes.bracketR);
          return;
        } else {
          prop.computed = false;
        }
      }
      var key = this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
      prop.key = key || this.dummyIdent();
    };
    lp.parsePropertyAccessor = function () {
      if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) {
        return this.parseIdent();
      }
      if (this.tok.type === acorn.tokTypes.privateId) {
        return this.parsePrivateIdent();
      }
    };
    lp.parseIdent = function () {
      var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;
      if (!name) {
        return this.dummyIdent();
      }
      var node = this.startNode();
      this.next();
      node.name = name;
      return this.finishNode(node, "Identifier");
    };
    lp.parsePrivateIdent = function () {
      var node = this.startNode();
      node.name = this.tok.value;
      this.next();
      return this.finishNode(node, "PrivateIdentifier");
    };
    lp.initFunction = function (node) {
      node.id = null;
      node.params = [];
      if (this.options.ecmaVersion >= 6) {
        node.generator = false;
        node.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = false;
      }
    };
    lp.toAssignable = function (node, binding) {
      if (!node || node.type === "Identifier" || node.type === "MemberExpression" && !binding);
      else if (node.type === "ParenthesizedExpression") {
        this.toAssignable(node.expression, binding);
      } else if (this.options.ecmaVersion < 6) {
        return this.dummyIdent();
      } else if (node.type === "ObjectExpression") {
        node.type = "ObjectPattern";
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, binding);
        }
      } else if (node.type === "ArrayExpression") {
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, binding);
      } else if (node.type === "Property") {
        this.toAssignable(node.value, binding);
      } else if (node.type === "SpreadElement") {
        node.type = "RestElement";
        this.toAssignable(node.argument, binding);
      } else if (node.type === "AssignmentExpression") {
        node.type = "AssignmentPattern";
        delete node.operator;
      } else {
        return this.dummyIdent();
      }
      return node;
    };
    lp.toAssignableList = function (exprList, binding) {
      for (var i = 0, list = exprList; i < list.length; i += 1) {
        var expr = list[i];
        this.toAssignable(expr, binding);
      }
      return exprList;
    };
    lp.parseFunctionParams = function (params) {
      params = this.parseExprList(acorn.tokTypes.parenR);
      return this.toAssignableList(params, true);
    };
    lp.parseMethod = function (isGenerator, isAsync) {
      var node = this.startNode(), oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = !!isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.inAsync = node.async;
      this.inGenerator = node.generator;
      this.inFunction = true;
      node.params = this.parseFunctionParams();
      node.body = this.parseBlock();
      this.toks.adaptDirectivePrologue(node.body.body);
      this.inAsync = oldInAsync;
      this.inGenerator = oldInGenerator;
      this.inFunction = oldInFunction;
      return this.finishNode(node, "FunctionExpression");
    };
    lp.parseArrowExpression = function (node, params, isAsync) {
      var oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.inAsync = node.async;
      this.inGenerator = false;
      this.inFunction = true;
      node.params = this.toAssignableList(params, true);
      node.expression = this.tok.type !== acorn.tokTypes.braceL;
      if (node.expression) {
        node.body = this.parseMaybeAssign();
      } else {
        node.body = this.parseBlock();
        this.toks.adaptDirectivePrologue(node.body.body);
      }
      this.inAsync = oldInAsync;
      this.inGenerator = oldInGenerator;
      this.inFunction = oldInFunction;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    lp.parseExprList = function (close, allowEmpty) {
      this.pushCx();
      var indent = this.curIndent, line = this.curLineStart, elts = [];
      this.next();
      while (!this.closes(close, indent + 1, line)) {
        if (this.eat(acorn.tokTypes.comma)) {
          elts.push(allowEmpty ? null : this.dummyIdent());
          continue;
        }
        var elt = this.parseMaybeAssign();
        if (isDummy(elt)) {
          if (this.closes(close, indent, line)) {
            break;
          }
          this.next();
        } else {
          elts.push(elt);
        }
        this.eat(acorn.tokTypes.comma);
      }
      this.popCx();
      if (!this.eat(close)) {
        this.last.end = this.tok.start;
        if (this.options.locations) {
          this.last.loc.end = this.tok.loc.start;
        }
      }
      return elts;
    };
    lp.parseAwait = function () {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary();
      return this.finishNode(node, "AwaitExpression");
    };
    acorn.defaultOptions.tabSize = 4;
    function parse(input, options) {
      return LooseParser.parse(input, options);
    }
    exports.LooseParser = LooseParser;
    exports.isDummy = isDummy;
    exports.parse = parse;
    Object.defineProperty(exports, "__esModule", { value: true });
  }));
}(acornLoose, acornLoose.exports));

const isNode = typeof System !== "undefined" ? System.get("@system-env").node : false;
let Decorators, ClassFields, StaticClassFeatures, PrivateMethods;
if (isNode) {
  Decorators = _1_0_0Exports$1 ? acornDecoratorsExports : requireAcornDecorators();
  ClassFields = _1_0_0Exports$1 || require_1_0_0$1();
  StaticClassFeatures = _1_0_0Exports || require_1_0_0();
  PrivateMethods = acornPrivateMethodsExports || requireAcornPrivateMethods();
} else {
  Decorators = acornDecoratorsExports;
  ClassFields = _1_0_0Exports$1;
  StaticClassFeatures = _1_0_0Exports;
  PrivateMethods = acornPrivateMethodsExports;
}
const custom = {};
custom.forEachNode = forEachNode;
custom.matchNodes = matchNodes;
custom.findNodesIncluding = findNodesIncluding;
custom.withParentInfo = withParentInfo;
custom.copy = copy;
custom.findSiblings = findSiblings;
custom.findNodeByAstIndex = findNodeByAstIndex;
custom.findStatementOfNode = findStatementOfNode;
custom.addAstIndex = addAstIndex;
const Parser = acornExports.Parser.extend(ClassFields, StaticClassFeatures, PrivateMethods, Decorators);
const acorn = {};
Object.assign(acorn, acornDefault);
acorn.Parser = Parser;
acorn.parse = (source, opts) => Parser.parse(source, opts);
function forEachNode(parsed, func, state, options) {
  options = options || {};
  const traversal = options.traversal || "preorder";
  const visitors = clone(options.visitors ? options.visitors : walk$2.exports.make(custom.visitors.withMemberExpression));
  const iterator = traversal === "preorder" ? function (orig, type, node, depth, cont) {
    func(node, state, depth, type);
    return orig(node, depth + 1, cont);
  } : function (orig, type, node, depth, cont) {
    const result = orig(node, depth + 1, cont);
    func(node, state, depth, type);
    return result;
  };
  Object.keys(visitors).forEach(function (type) {
    const orig = visitors[type];
    visitors[type] = function (node, depth, cont) {
      return iterator(orig, type, node, depth, cont);
    };
  });
  walk$2.exports.recursive(parsed, 0, null, visitors);
  return parsed;
}
function matchNodes(parsed, visitor, state, options) {
  function visit(node, state, depth, type) {
    if (visitor[node.type])
      visitor[node.type](node, state, depth, type);
  }
  return forEachNode(parsed, visit, state, options);
}
function findNodesIncluding(parsed, pos, test, base) {
  const nodes = [];
  base = base || walk$2.exports.make(custom.visitors.withMemberExpression);
  Object.keys(walk$2.exports.base).forEach(function (name) {
    const orig = base[name];
    base[name] = function (node, state, cont) {
      pushIfNotIncluded(nodes, node);
      return orig(node, state, cont);
    };
  });
  base.Property = function (node, st, c) {
    pushIfNotIncluded(nodes, node);
    c(node.key, st, "Expression");
    c(node.value, st, "Expression");
  };
  base.LabeledStatement = function (node, st, c) {
    node.label && c(node.label, st, "Expression");
    c(node.body, st, "Statement");
  };
  walk$2.exports.findNodeAround(parsed, pos, test, base);
  return nodes;
}
function withParentInfo(parsed, iterator, options) {
  options = options || {};
  function makeScope(parentScope) {
    const scope = {
      id: newUUID(),
      parentScope: parentScope,
      containingScopes: []
    };
    parentScope && parentScope.containingScopes.push(scope);
    return scope;
  }
  const visitors = walk$2.exports.make({
    Function: function (node, st, c) {
      if (st && st.scope)
        st.scope = makeScope(st.scope);
      c(node.body, st, "ScopeBody");
    },
    VariableDeclarator: function (node, st, c) {
      node.init && c(node.init, st, "Expression");
    },
    VariableDeclaration: function (node, st, c) {
      for (let i = 0; i < node.declarations.length; ++i) {
        const decl = node.declarations[i];
        if (decl)
          c(decl, st, "VariableDeclarator");
      }
    },
    ObjectExpression: function (node, st, c) {
      for (let i = 0; i < node.properties.length; ++i) {
        const prop = node.properties[i];
        c(prop.key, st, "Expression");
        c(prop.value, st, "Expression");
      }
    },
    MemberExpression: function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, "Expression");
    }
  }, walk$2.exports.base);
  let lastActiveProp;
  const getters = [];
  forEachNode(parsed, function (node) {
    withoutAll(Object.keys(node), [
      "end",
      "start",
      "type",
      "source",
      "raw"
    ]).forEach(function (propName) {
      if (node.__lookupGetter__(propName))
        return;
      const val = node[propName];
      node.__defineGetter__(propName, function () {
        lastActiveProp = propName;
        return val;
      });
      getters.push([
        node,
        propName,
        node[propName]
      ]);
    });
  }, null, { visitors: visitors });
  const result = [];
  Object.keys(visitors).forEach(function (type) {
    const orig = visitors[type];
    visitors[type] = function (node, state, cont) {
      if (type === node.type || options.visitAllNodes) {
        result.push(iterator.call(null, node, {
          scope: state.scope,
          depth: state.depth,
          parent: state.parent,
          type: type,
          propertyInParent: lastActiveProp
        }));
        return orig(node, {
          scope: state.scope,
          parent: node,
          depth: state.depth + 1
        }, cont);
      } else {
        return orig(node, state, cont);
      }
    };
  });
  walk$2.exports.recursive(parsed, {
    scope: makeScope(),
    parent: null,
    propertyInParent: "",
    depth: 0
  }, null, visitors);
  getters.forEach(function (nodeNameVal) {
    delete nodeNameVal[0][nodeNameVal[1]];
    nodeNameVal[0][nodeNameVal[1]] = nodeNameVal[2];
  });
  return result;
}
function copy(ast, override) {
  const visitors = extend({
    Program: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "Program",
        body: n.body.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    FunctionDeclaration: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "FunctionDeclaration",
        id: c(n.id),
        params: n.params.map(c),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    BlockStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "BlockStatement",
        body: n.body.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ExpressionStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ExpressionStatement",
        expression: c(n.expression),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    CallExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "CallExpression",
        callee: c(n.callee),
        arguments: n.arguments.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    MemberExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "MemberExpression",
        object: c(n.object),
        property: c(n.property),
        computed: n.computed,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    NewExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "NewExpression",
        callee: c(n.callee),
        arguments: n.arguments.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    VariableDeclaration: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "VariableDeclaration",
        declarations: n.declarations.map(c),
        kind: n.kind,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    VariableDeclarator: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "VariableDeclarator",
        id: c(n.id),
        init: c(n.init),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    FunctionExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "FunctionExpression",
        id: c(n.id),
        params: n.params.map(c),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    IfStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "IfStatement",
        test: c(n.test),
        consequent: c(n.consequent),
        alternate: c(n.alternate),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ConditionalExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ConditionalExpression",
        test: c(n.test),
        consequent: c(n.consequent),
        alternate: c(n.alternate),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    SwitchStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "SwitchStatement",
        discriminant: c(n.discriminant),
        cases: n.cases.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    SwitchCase: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "SwitchCase",
        test: c(n.test),
        consequent: n.consequent.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    BreakStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "BreakStatement",
        label: n.label,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ContinueStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ContinueStatement",
        label: n.label,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    TryStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "TryStatement",
        block: c(n.block),
        handler: c(n.handler),
        finalizer: c(n.finalizer),
        guardedHandlers: n.guardedHandlers.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    CatchClause: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "CatchClause",
        param: c(n.param),
        guard: c(n.guard),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ThrowStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ThrowStatement",
        argument: c(n.argument),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ForStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ForStatement",
        init: c(n.init),
        test: c(n.test),
        update: c(n.update),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ForInStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ForInStatement",
        left: c(n.left),
        right: c(n.right),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    WhileStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "WhileStatement",
        test: c(n.test),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    DoWhileStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "DoWhileStatement",
        test: c(n.test),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    WithStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "WithStatement",
        object: c(n.object),
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    UnaryExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "UnaryExpression",
        argument: c(n.argument),
        operator: n.operator,
        prefix: n.prefix,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    BinaryExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "BinaryExpression",
        left: c(n.left),
        operator: n.operator,
        right: c(n.right),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    LogicalExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "LogicalExpression",
        left: c(n.left),
        operator: n.operator,
        right: c(n.right),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    AssignmentExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "AssignmentExpression",
        left: c(n.left),
        operator: n.operator,
        right: c(n.right),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    UpdateExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "UpdateExpression",
        argument: c(n.argument),
        operator: n.operator,
        prefix: n.prefix,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ReturnStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ReturnStatement",
        argument: c(n.argument),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    Identifier: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "Identifier",
        name: n.name,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    Literal: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "Literal",
        value: n.value,
        raw: n.raw,
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ObjectExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ObjectExpression",
        properties: n.properties.map(function (prop) {
          return {
            key: c(prop.key),
            value: c(prop.value),
            kind: prop.kind
          };
        }),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ArrayExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ArrayExpression",
        elements: n.elements.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    SequenceExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "SequenceExpression",
        expressions: n.expressions.map(c),
        source: n.source,
        astIndex: n.astIndex
      };
    },
    EmptyStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "EmptyStatement",
        source: n.source,
        astIndex: n.astIndex
      };
    },
    ThisExpression: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "ThisExpression",
        source: n.source,
        astIndex: n.astIndex
      };
    },
    DebuggerStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "DebuggerStatement",
        source: n.source,
        astIndex: n.astIndex
      };
    },
    LabeledStatement: function (n, c) {
      return {
        start: n.start,
        end: n.end,
        type: "LabeledStatement",
        label: n.label,
        body: c(n.body),
        source: n.source,
        astIndex: n.astIndex
      };
    }
  }, override || {});
  function c(node) {
    if (node === null)
      return null;
    return visitors[node.type](node, c);
  }
  return c(ast);
}
function findSiblings(parsed, node, beforeOrAfter) {
  if (!node)
    return [];
  const nodes = findNodesIncluding(parsed, node.start);
  const idx = nodes.indexOf(node);
  const parents = nodes.slice(0, idx);
  const parentWithBody = parents.reverse().find(function (p) {
    return Array.isArray(p.body);
  });
  const siblingsWithNode = parentWithBody.body;
  if (!beforeOrAfter)
    return without(siblingsWithNode, node);
  const nodeIdxInSiblings = siblingsWithNode.indexOf(node);
  return beforeOrAfter === "before" ? siblingsWithNode.slice(0, nodeIdxInSiblings) : siblingsWithNode.slice(nodeIdxInSiblings + 1);
}
custom.visitors = {
  stopAtFunctions: walk$2.exports.make({
    Function: function () {
    },
    ...walk$2.exports.base
  }),
  withMemberExpression: walk$2.exports.make({
    MemberExpression: function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, "Expression");
    }
  }, walk$2.exports.base)
};
function findNodeByAstIndex(parsed, astIndexToFind, addIndex) {
  addIndex = addIndex == null ? true : !!addIndex;
  if (!parsed.astIndex && addIndex)
    addAstIndex(parsed);
  let found = null;
  withMozillaAstDo(parsed, null, function (next, node, state) {
    if (found)
      return;
    const idx = node.astIndex;
    if (idx < astIndexToFind)
      return;
    if (node.astIndex === astIndexToFind) {
      found = node;
      return;
    }
    next();
  });
  return found;
}
function findStatementOfNode(options, parsed, target) {
  if (!target) {
    target = parsed;
    parsed = options;
    options = null;
  }
  if (!options)
    options = {};
  if (!parsed.astIndex)
    addAstIndex(parsed);
  let found;
  let targetReached = false;
  const statements = [
    "EmptyStatement",
    "BlockStatement",
    "ExpressionStatement",
    "IfStatement",
    "LabeledStatement",
    "BreakStatement",
    "ContinueStatement",
    "WithStatement",
    "SwitchStatement",
    "ReturnStatement",
    "ThrowStatement",
    "TryStatement",
    "WhileStatement",
    "DoWhileStatement",
    "ForStatement",
    "ForInStatement",
    "DebuggerStatement",
    "FunctionDeclaration",
    "VariableDeclaration",
    "ClassDeclaration"
  ];
  withMozillaAstDo(parsed, {}, function (next, node, state, path) {
    if (targetReached || node.astIndex < target.astIndex)
      return;
    if (node === target || node.astIndex === target.astIndex) {
      targetReached = true;
      if (options.asPath) {
        found = path;
      } else {
        let p = Path(path);
        do {
          found = p.get(parsed);
          p = p.slice(0, p.size() - 1);
        } while (statements.indexOf(found.type) == -1 && p.size() > 0);
      }
    }
    !targetReached && next();
  });
  return found;
}
function addAstIndex(parsed) {
  withMozillaAstDo(parsed, { index: 0 }, function (next, node, state) {
    next();
    node.astIndex = state.index++;
  });
  return parsed;
}

var cacheLru = {exports: {}};

(function (module, exports) {
  (function (f) {
    {
      module.exports = f();
    }
  }(function () {
    return function () {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof createCommonjsRequire("/lively.next-node_modules/cache-lru/1.1.11/lib") && createCommonjsRequire("/lively.next-node_modules/cache-lru/1.1.11/lib");
              if (!f && c)
                return c(i, !0);
              if (u)
                return u(i, !0);
              var a = new Error("Cannot find module '" + i + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i] = { exports: {} };
            e[i][0].call(p.exports, function (r) {
              var n = e[i][1][r];
              return o(n || r);
            }, p, p.exports, r, e, n, t);
          }
          return n[i].exports;
        }
        for (var u = "function" == typeof createCommonjsRequire("/lively.next-node_modules/cache-lru/1.1.11/lib") && createCommonjsRequire("/lively.next-node_modules/cache-lru/1.1.11/lib"), i = 0; i < t.length; i++)
          o(t[i]);
        return o;
      }
      return r;
    }()({
      1: [
        function (_dereq_, module, exports) {
          function _classCallCheck(e, t) {
            if (!(e instanceof t))
              throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperties(e, t) {
            for (var i = 0; i < t.length; i++) {
              var n = t[i];
              n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
            }
          }
          function _createClass(e, t, i) {
            return t && _defineProperties(e.prototype, t), i && _defineProperties(e, i), e;
          }
          var CacheLRU = (function () {
            function e() {
              return _classCallCheck(this, e), this._index = {}, this._LRU = { newer: null }, this._MRU = { older: null }, this._LRU.newer = this._MRU, this._MRU.older = this._LRU, this._cur = 0, this._max = 1 / 0, this._dispose = function () {
              }, this;
            }
            return _createClass(e, [
              {
                key: "limit",
                value: function (e) {
                  var t = this._max;
                  return arguments.length > 0 && (this._max = e, this._purge()), t;
                }
              },
              {
                key: "dispose",
                value: function (e) {
                  return this._dispose = e, this;
                }
              },
              {
                key: "length",
                value: function () {
                  return this._cur;
                }
              },
              {
                key: "keys",
                value: function () {
                  return this.each(function (e, t) {
                    this.push(t);
                  }, []);
                }
              },
              {
                key: "values",
                value: function () {
                  return this.each(function (e) {
                    this.push(e);
                  }, []);
                }
              },
              {
                key: "each",
                value: function (e, t) {
                  arguments < 2 && (t = this);
                  for (var i = 0, n = this._MRU.older; n !== this._LRU;)
                    e.call(t, n.val, n.key, i++), n = n.older;
                  return t;
                }
              },
              {
                key: "has",
                value: function (e) {
                  var t = this._index[e];
                  return void 0 !== t && t.expires >= Date.now();
                }
              },
              {
                key: "peek",
                value: function (e) {
                  var t = this._index[e];
                  if (void 0 !== t) {
                    if (!(t.expires < Date.now()))
                      return t.val;
                    this.del(t.key);
                  }
                }
              },
              {
                key: "touch",
                value: function (e) {
                  var t = this._index[e];
                  if (void 0 === t)
                    throw new Error("touch: no such item");
                  return this._promote(t), this;
                }
              },
              {
                key: "get",
                value: function (e) {
                  var t = this._index[e];
                  if (void 0 !== t) {
                    if (!(t.expires < Date.now()))
                      return this._promote(t), t.val;
                    this.del(t.key);
                  }
                }
              },
              {
                key: "set",
                value: function (e, t, i) {
                  arguments.length < 3 && (i = 1 / 0), i += Date.now();
                  var n = this._index[e];
                  if (void 0 === n)
                    n = {
                      older: null,
                      newer: null,
                      key: e,
                      val: t,
                      expires: i
                    }, this._index[e] = n, this._attach(n), this._cur++, this._purge();
                  else {
                    var r = n.val;
                    n.val = t, this._promote(n), this._dispose.call(void 0, n.key, r, "set");
                  }
                  return this;
                }
              },
              {
                key: "del",
                value: function (e) {
                  var t = this._index[e];
                  if (void 0 === t)
                    throw new Error("del: no such item");
                  return delete this._index[e], this._detach(t), this._cur--, this._dispose.call(void 0, e, t.val, "del"), this;
                }
              },
              {
                key: "clear",
                value: function () {
                  for (; this._cur > 0;)
                    this.del(this._LRU.newer.key);
                  return this;
                }
              },
              {
                key: "_purge",
                value: function () {
                  for (; this._cur > this._max;)
                    this.del(this._LRU.newer.key);
                }
              },
              {
                key: "_promote",
                value: function (e) {
                  this._detach(e), this._attach(e);
                }
              },
              {
                key: "_detach",
                value: function (e) {
                  e.older.newer = e.newer, e.newer.older = e.older, e.older = null, e.newer = null;
                }
              },
              {
                key: "_attach",
                value: function (e) {
                  e.older = this._MRU.older, e.newer = this._MRU, e.newer.older = e, e.older.newer = e;
                }
              }
            ]), e;
          }());
          module.exports = CacheLRU;
        },
        {}
      ]
    }, {}, [1])(1);
  }));
}(cacheLru));
var CacheLRU = cacheLru.exports;

class ASTQAdapter {
  constructor() {
    this._adapters = [];
    return this;
  }
  register(adapter, force = false) {
    this._adapters.unshift({
      adapter: adapter,
      force: force
    });
    return this;
  }
  unregister(adapter) {
    if (adapter === undefined)
      this._adapters = [];
    else {
      let adapters = [];
      for (let i = 0; i < this._adapters.length; i++)
        if (this._adapters[i].adapter !== adapter)
          adapters.push(this._adapters[i]);
      this._adapters = adapters;
    }
    return this;
  }
  select(node) {
    for (let i = 0; i < this._adapters.length; i++)
      if (this._adapters[i].force || this._adapters[i].adapter.taste(node))
        return this._adapters[i].adapter;
    return undefined;
  }
}

class ASTQAdapterXMLDOM {
  static taste(node) {
    return typeof Node === "object" && node !== null && node instanceof Node && typeof node === "object" && typeof node.nodeType === "number" && typeof node.nodeName === "string";
  }
  static getParentNode(node) {
    return node.parentNode;
  }
  static getChildNodes(node) {
    return typeof node.childNodes === "object" && node.childNodes !== null && node.hasChildNodes() ? Array.prototype.slice.call(node.childNodes, 0) : [];
  }
  static getNodeType(node) {
    return typeof node.nodeName === "string" ? node.nodeName : "unknown";
  }
  static getNodeAttrNames(node) {
    return typeof node.attributes === "object" && node.attributes !== null && node.hasAttributes() ? Array.prototype.slice.call(node.attributes, 0).map(n => n.nodeName) : [];
  }
  static getNodeAttrValue(node, attr) {
    return typeof node.attributes === "object" && node.attributes !== null && node.hasAttributes() ? node.getAttribute(attr) : undefined;
  }
}

class ASTQAdapterParse5 {
  static taste(node) {
    return typeof node === "object" && node !== null && !(typeof Node === "object" && node instanceof Node) && typeof node.nodeName === "string" && node.nodeName !== "";
  }
  static getParentNode(node) {
    return node.parentNode;
  }
  static getChildNodes(node) {
    return typeof node.childNodes === "object" && node.childNodes instanceof Array ? node.childNodes : [];
  }
  static getNodeType(node) {
    return node.nodeName;
  }
  static getNodeAttrNames(node) {
    let attrs = ["value"];
    if (typeof node.attrs === "object" && node.attrs instanceof Array)
      attrs = attrs.concat(node.attrs.map(n => n.name));
    return attrs;
  }
  static getNodeAttrValue(node, attr) {
    let value;
    if (attr === "value")
      value = node.value;
    else if (typeof node.attrs === "object" && node.attrs instanceof Array) {
      let values = node.attrs.filter(n => n.name === attr).map(n => n.value);
      if (values.length === 1)
        value = values[0];
    }
    return value;
  }
}

class ASTQAdapterMozAST {
  static taste(node) {
    return typeof node === "object" && node !== null && typeof node.type === "string" && node.type !== "";
  }
  static getParentNode(node, type) {
    if (type !== "*" && type !== "parent")
      throw new Error("no such axis named \"" + type + "\" for walking to parent nodes");
    if (typeof node.parent !== "undefined")
      return node.parent;
    else
      throw new Error("Your Mozilla SpiderMonkey AST does not support parent node traversal");
  }
  static getChildNodes(node, type) {
    let childs = [];
    let checkField = (node, field) => {
      if (Object.prototype.hasOwnProperty.call(node, field) && this.taste(node[field]))
        childs.push(node[field]);
      else if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] === "object" && node[field] instanceof Array) {
        node[field].forEach(node => {
          if (this.taste(node))
            childs.push(node);
        });
      }
    };
    if (type === "*") {
      for (let field in node)
        checkField(node, field);
    } else {
      if (typeof node[type] !== "undefined")
        checkField(node, type);
    }
    return childs;
  }
  static getNodeType(node) {
    return node.type;
  }
  static getNodeAttrNames(node) {
    let names = [];
    for (let field in node)
      if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] !== "object" && field !== "type" && field !== "loc")
        names.push(field);
    return names;
  }
  static getNodeAttrValue(node, attr) {
    if (Object.prototype.hasOwnProperty.call(node, attr) && typeof node[attr] !== "object" && attr !== "type" && attr !== "loc")
      return node[attr];
    else
      return undefined;
  }
}

class ASTQAdapterGraphQL {
  static taste(node) {
    return typeof node === "object" && node !== null && typeof node.kind === "string" && node.kind !== "";
  }
  static getParentNode(node, type) {
    throw new Error("GraphQL AST does not support parent node traversal");
  }
  static getChildNodes(node, type) {
    let childs = [];
    let checkField = (node, field) => {
      if (Object.prototype.hasOwnProperty.call(node, field) && this.taste(node[field]))
        childs.push(node[field]);
      else if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] === "object" && node[field] instanceof Array) {
        node[field].forEach(node => {
          if (this.taste(node))
            childs.push(node);
        });
      }
    };
    if (type === "*") {
      for (let field in node)
        checkField(node, field);
    } else {
      if (typeof node[type] !== "undefined")
        checkField(node, type);
    }
    return childs;
  }
  static getNodeType(node) {
    return node.kind;
  }
  static getNodeAttrNames(node) {
    let names = [];
    for (let field in node)
      if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] !== "object" && field !== "kind" && field !== "loc")
        names.push(field);
    return names;
  }
  static getNodeAttrValue(node, attr) {
    if (Object.prototype.hasOwnProperty.call(node, attr) && typeof node[attr] !== "object" && attr !== "kind" && attr !== "loc")
      return node[attr];
    else
      return undefined;
  }
}

class ASTQAdapterJSON {
  static taste(node) {
    return typeof node === "object" && node !== null;
  }
  static getParentNode(node, type) {
    throw new Error("JSON does not support parent node traversal");
  }
  static getChildNodes(node, type) {
    let childs = [];
    let checkField = (node, field) => {
      if (Object.prototype.hasOwnProperty.call(node, field) && this.taste(node[field]))
        childs.push(node[field]);
      else if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] === "object" && node[field] instanceof Array) {
        node[field].forEach(node => {
          if (this.taste(node))
            childs.push(node);
        });
      }
    };
    if (type === "*") {
      for (let field in node)
        checkField(node, field);
    } else {
      if (typeof node[type] !== "undefined")
        checkField(node, type);
    }
    return childs;
  }
  static getNodeType(node) {
    if (node === null)
      return "Null";
    else if (node instanceof Boolean)
      return "Boolean";
    else if (node instanceof Number)
      return "Number";
    else if (node instanceof String)
      return "String";
    else if (typeof node === "object") {
      if (node instanceof Array)
        return "Array";
      else if (typeof node.constructor === "function" && typeof node.constructor.name === "string")
        return node.constructor.name;
      else
        return "Object";
    } else
      return "Unknown";
  }
  static getNodeAttrNames(node) {
    let names = [];
    for (let field in node)
      if (Object.prototype.hasOwnProperty.call(node, field) && typeof node[field] !== "object")
        names.push(field);
    return names;
  }
  static getNodeAttrValue(node, attr) {
    if (Object.prototype.hasOwnProperty.call(node, attr) && typeof node[attr] !== "object")
      return node[attr];
    else
      return undefined;
  }
}

class ASTQAdapterCheerio {
  static taste(node) {
    return typeof node === "object" && node !== null && !(typeof Node === "object" && node instanceof Node) && typeof node.tagName === "string" && node.tagName !== "";
  }
  static getParentNode(node) {
    return node.parentNode;
  }
  static getChildNodes(node) {
    return typeof node.childNodes === "object" && node.childNodes instanceof Array ? node.childNodes : [];
  }
  static getNodeType(node) {
    return node.tagName || `#${ node.type || "unknown" }`;
  }
  static getNodeAttrNames(node) {
    let attrs = ["value"];
    if (typeof node.attribs === "object")
      attrs = attrs.concat(Object.keys(node.attribs));
    return attrs;
  }
  static getNodeAttrValue(node, attr) {
    let value;
    if (attr === "value")
      value = node.nodeValue;
    else if (typeof node.attribs === "object")
      value = node.attribs[attr];
    return value;
  }
}

class ASTQAdapterUniST {
  static taste(node) {
    return typeof node === "object" && node !== null && typeof node.type === "string" && node.type !== "";
  }
  static getParentNode(node) {
    if (typeof node.parent === "object" && node.parent !== null)
      return node.parent;
    else
      throw new Error("Your UniST AST does not support parent node traversal");
  }
  static getChildNodes(node) {
    return typeof node.children === "object" && node.children instanceof Array ? node.children : [];
  }
  static getNodeType(node) {
    return node.type;
  }
  static getNodeAttrNames(node) {
    const attrs = [];
    for (const attr in node)
      if (Object.prototype.hasOwnProperty.call(node, attr) && attr !== "type" && attr !== "data" && attr !== "position" && attr !== "children" && typeof node[attr] !== "object")
        attrs.push(attr);
    return attrs;
  }
  static getNodeAttrValue(node, attr) {
    if (Object.prototype.hasOwnProperty.call(node, attr) && attr !== "type" && attr !== "data" && attr !== "position" && attr !== "children" && typeof node[attr] !== "object")
      return node[attr];
    else
      return undefined;
  }
}

class ASTQAdapterASTY {
  static taste(node) {
    return typeof node === "object" && node !== null && typeof node.ASTy === "boolean";
  }
  static getParentNode(node) {
    return node.parent();
  }
  static getChildNodes(node) {
    return node.childs();
  }
  static getNodeType(node) {
    return node.type();
  }
  static getNodeAttrNames(node) {
    return node.attrs();
  }
  static getNodeAttrValue(node, attr) {
    return node.get(attr);
  }
}

class ASTQFuncs {
  constructor() {
    this._funcs = {};
    return this;
  }
  register(name, func) {
    this._funcs[name] = func;
  }
  run(name, args) {
    let func = this._funcs[name];
    if (typeof func !== "function")
      throw new Error("invalid function \"" + name + "\"");
    return func.apply(null, args);
  }
}

const pos = (A, T) => {
  let parent = A.getParentNode(T, "*");
  if (parent === null)
    return 1;
  let pchilds = A.getChildNodes(parent, "*");
  for (let i = 0; i < pchilds.length; i++)
    if (pchilds[i] === T)
      return i + 1;
  throw new Error("cannot find myself");
};
const parents = (A, T) => {
  let parents = [];
  while ((T = A.getParentNode(T, "*")) !== null)
    parents.push(T);
  return parents;
};
const stdfuncs = {
  "type": (A, T) => {
    return A.getNodeType(T);
  },
  "attrs": (A, T, sep) => {
    if (sep === undefined)
      sep = " ";
    return sep + A.getNodeAttrNames(T).join(sep) + sep;
  },
  "depth": (A, T) => {
    let depth = 1;
    let node = T;
    while ((node = A.getParentNode(node, "*")) !== null)
      depth++;
    return depth;
  },
  "pos": (A, T) => {
    return pos(A, T);
  },
  "nth": (A, T, num) => {
    num = parseInt(num, 10);
    let parent = A.getParentNode(T, "*");
    if (parent !== null) {
      let pchilds = A.getChildNodes(parent, "*");
      if (num < 0)
        num = pchilds.length - (num + 1);
      for (let i = 0; i < pchilds.length; i++)
        if (pchilds[i] === T)
          return i + 1 === num;
      return false;
    } else if (num === 1)
      return true;
    else
      return false;
  },
  "first": (A, T) => {
    return stdfuncs.nth(A, T, 1);
  },
  "last": (A, T) => {
    return stdfuncs.nth(A, T, -1);
  },
  "count": (A, T, val) => {
    if (typeof val === "object" && val instanceof Array)
      return val.length;
    else if (typeof val === "object")
      return Object.keys(val).length;
    else if (typeof val === "string")
      return val.length;
    else
      return String(val).length;
  },
  "below": (A, T, other) => {
    if (!A.taste(other))
      throw new Error("invalid argument to function \"below\" (node expected)");
    let node = T;
    while ((node = A.getParentNode(node, "*")) !== null)
      if (node === other)
        return true;
    return false;
  },
  "follows": (A, T, other) => {
    if (!A.taste(other))
      throw new Error("invalid argument to function \"follows\" (node expected)");
    if (T === other)
      return false;
    let pathOfT = [T].concat(parents(A, T)).reverse();
    let pathOfOther = [other].concat(parents(A, other)).reverse();
    let len = Math.min(pathOfT.length, pathOfOther.length);
    let i;
    for (i = 0; i < len; i++)
      if (pathOfT[i] !== pathOfOther[i])
        break;
    if (i === 0)
      throw new Error("internal error: root nodes have to be same same");
    else if (i === len) {
      if (pathOfOther.length < pathOfT.length)
        return true;
      else
        return false;
    } else
      return pos(A, pathOfT[i]) > pos(A, pathOfOther[i]);
  },
  "in": (A, T, val) => {
    if (!(typeof val === "object" && val instanceof Array))
      throw new Error("invalid argument to function \"in\" (array expected)");
    for (let i = 0; i < val.length; i++)
      if (val[i] === T)
        return true;
    return false;
  },
  "substr": (A, T, str, pos, len) => {
    return String(str).substr(pos, len);
  },
  "index": (A, T, str, sub, from) => {
    return String(str).indexOf(sub, from);
  },
  "trim": (A, T, str) => {
    return String(str).trim();
  },
  "lc": (A, T, str) => {
    return String(str).toLowerCase();
  },
  "uc": (A, T, str) => {
    return String(str).toUpperCase();
  }
};

var lodash = {exports: {}};

(function (module, exports) {
  (function () {
    var undefined$1;
    var VERSION = "4.17.20";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      [
        "ary",
        WRAP_ARY_FLAG
      ],
      [
        "bind",
        WRAP_BIND_FLAG
      ],
      [
        "bindKey",
        WRAP_BIND_KEY_FLAG
      ],
      [
        "curry",
        WRAP_CURRY_FLAG
      ],
      [
        "curryRight",
        WRAP_CURRY_RIGHT_FLAG
      ],
      [
        "flip",
        WRAP_FLIP_FLAG
      ],
      [
        "partial",
        WRAP_PARTIAL_FLAG
      ],
      [
        "partialRight",
        WRAP_PARTIAL_RIGHT_FLAG
      ],
      [
        "rearg",
        WRAP_REARG_FLAG
      ]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
        rsNonAstral,
        rsRegional,
        rsSurrPair
      ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [
        rsDingbat,
        rsRegional,
        rsSurrPair
      ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [
        rsNonAstral + rsCombo + "?",
        rsCombo,
        rsRegional,
        rsSurrPair,
        rsAstral
      ].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [
        rsBreak,
        rsUpper,
        "$"
      ].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [
        rsBreak,
        rsUpper + rsMiscLower,
        "$"
      ].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\"": "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": "\"",
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function () {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }());
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function (value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function (key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function (value, index, collection) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function (key) {
        return [
          key,
          object[key]
        ];
      });
    }
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [
          key,
          value
        ];
      });
      return result;
    }
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = [
          value,
          value
        ];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }());
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object);
      var oldDash = root._;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1, symIterator = Symbol ? Symbol.iterator : undefined$1, symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;
      var defineProperty = (function () {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }());
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create");
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol ? Symbol.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = (function () {
        function object() {
        }
        return function (proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = undefined$1;
          return result;
        };
      }());
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": { "_": lodash }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result = new LazyWrapper(this.__wrapped__);
        result.__actions__ = copyArray(this.__actions__);
        result.__dir__ = this.__dir__;
        result.__filtered__ = this.__filtered__;
        result.__iteratees__ = copyArray(this.__iteratees__);
        result.__takeCount__ = this.__takeCount__;
        result.__views__ = copyArray(this.__views__);
        return result;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1;
          result.__filtered__ = true;
        } else {
          result = this.clone();
          result.__dir__ *= -1;
        }
        return result;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
        return result;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined$1 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined$1 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([
            key,
            value
          ]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
              key,
              value
            ]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function (value, key, collection) {
          setter(accumulator, value, iteratee(value), collection);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result = Array(length), skip = object == null;
        while (++index < length) {
          result[index] = skip ? undefined$1 : get(object, paths[index]);
        }
        return result;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined$1) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function (subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function (subValue, key) {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function (subValue, key) {
          if (props) {
            key = subValue;
            subValue = value[key];
          }
          assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
        return result;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function (object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return setTimeout(function () {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee == null ? value : iteratee(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
        return result;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function (value, index, collection) {
          result = !!predicate(value, index, collection);
          return result;
        });
        return result;
      }
      function baseExtremum(array, iteratee, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result = value;
          }
        }
        return result;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function (value, index, collection) {
          if (predicate(value, index, collection)) {
            result.push(value);
          }
        });
        return result;
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function baseForOwnRight(object, iteratee) {
        return object && baseForRight(object, iteratee, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function (key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee, comparator) {
        var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      function baseInverter(object, setter, iteratee, accumulator) {
        baseForOwn(object, function (value, key, object) {
          setter(accumulator, iteratee(value), key, object);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function (value, key, collection) {
          result[++index] = iteratee(value, key, collection);
        });
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function (object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function (object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function (srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function (iteratee) {
            if (isArray(iteratee)) {
              return function (value) {
                return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
              };
            }
            return iteratee;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result = baseMap(collection, function (value, key, collection) {
          var criteria = arrayMap(iteratees, function (iteratee) {
            return iteratee(value);
          });
          return {
            "criteria": criteria,
            "index": ++index,
            "value": value
          };
        });
        return baseSortBy(result, function (object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function (value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      function basePropertyDeep(path) {
        return function (object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values, iteratee, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
        if (array === values) {
          values = copyArray(values);
        }
        if (iteratee) {
          seen = arrayMap(array, baseUnary(iteratee));
        }
        while (++index < length) {
          var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
          while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index] = start;
          start += step;
        }
        return result;
      }
      function baseRepeat(string, n) {
        var result = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        }
        do {
          if (n % 2) {
            result += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function (func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function (func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      function baseSome(collection, predicate) {
        var result;
        baseEach(collection, function (value, index, collection) {
          result = predicate(value, index, collection);
          return !result;
        });
        return !!result;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseUniq(array, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result = value;
        if (result instanceof LazyWrapper) {
          result = result.value();
        }
        return arrayReduce(actions, function (result, action) {
          return action.func.apply(action.thisArg, arrayPush([result], action.args));
        }, result);
      }
      function baseXor(arrays, iteratee, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result = Array(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
      }
      function baseZipObject(props, values, assignFunc) {
        var index = -1, length = props.length, valsLength = values.length, result = {};
        while (++index < length) {
          var value = index < valsLength ? values[index] : undefined$1;
          assignFunc(result, props[index], value);
        }
        return result;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout = ctxClearTimeout || function (id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result[leftIndex++] = args[argsIndex++];
        }
        return result;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function (collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function (object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function (collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function (string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function (string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function () {
          var args = arguments;
          switch (args.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args[0]);
          case 2:
            return new Ctor(args[0], args[1]);
          case 3:
            return new Ctor(args[0], args[1], args[2]);
          case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
          case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function (collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function (key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function (funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function () {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index = 0, result = length ? funcs[index].apply(this, args) : value;
            while (++index < length) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary < length) {
            args.length = ary;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function (object, iteratee) {
          return baseInverter(object, setter, toIteratee(iteratee), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function (value, other) {
          var result;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result = value;
          }
          if (other !== undefined$1) {
            if (result === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result = operator(value, other);
          }
          return result;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function (iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function (args) {
            var thisArg = this;
            return arrayFunc(iteratees, function (iteratee) {
              return apply(iteratee, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function (start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function (value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary,
          arity
        ];
        var result = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result, newData);
        }
        result.placeholder = placeholder;
        return setWrapToString(result, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math[methodName];
        return function (number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set && 1 / setToArray(new Set([
        ,
        -0
      ]))[1] == INFINITY) ? noop : function (values) {
        return new Set(values);
      };
      function createToPairs(keysFunc) {
        return function (object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result = createPartial(func, bitmask, thisArg, partials);
        } else {
          result = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function (func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [
            key,
            value,
            isStrictComparable(value)
          ];
        }
        return result;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function (value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
            }
          }
          return result;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size = data.size;
          switch (data.type) {
          case "drop":
            start += size;
            break;
          case "dropRight":
            end -= size;
            break;
          case "take":
            end = nativeMin(end, start + size);
            break;
          case "takeRight":
            start = nativeMax(start, end - size);
            break;
          }
        }
        return {
          "start": start,
          "end": end
        };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function (object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object(object));
        };
      }
      function memoizeCapped(func) {
        var result = memoize(func, function (key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function () {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout = ctxSetTimeout || function (func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function () {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size = size === undefined$1 ? length : size;
        while (++index < size) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size;
        return array;
      }
      var stringToPath = memoizeCapped(function (string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function (match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function (pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result.__actions__ = copyArray(wrapper.__actions__);
        result.__index__ = wrapper.__index__;
        result.__values__ = wrapper.__values__;
        return result;
      }
      function chunk(array, size, guard) {
        if (guard ? isIterateeCall(array, size, guard) : size === undefined$1) {
          size = 1;
        } else {
          size = nativeMax(toInteger(size), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
        while (index < length) {
          result[resIndex++] = baseSlice(array, index, index += size);
        }
        return result;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function (array, values) {
        var iteratee = last(values);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
      });
      var differenceWith = baseRest(function (array, values) {
        var comparator = last(values);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function (arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function (arrays) {
        var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee === last(mapped)) {
          iteratee = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
      });
      var intersectionWith = baseRest(function (arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values) {
        return array && array.length && values && values.length ? basePullAll(array, values) : array;
      }
      function pullAllBy(array, values, iteratee) {
        return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
      }
      function pullAllWith(array, values, comparator) {
        return array && array.length && values && values.length ? basePullAll(array, values, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function (array, indexes) {
        var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function (index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result;
      });
      function remove(array, predicate) {
        var result = [];
        if (!(array && array.length)) {
          return result;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function (arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function (arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
      });
      var unionWith = baseRest(function (arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function (group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function (index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee) {
        if (!(array && array.length)) {
          return [];
        }
        var result = unzip(array);
        if (iteratee == null) {
          return result;
        }
        return arrayMap(result, function (group) {
          return apply(iteratee, undefined$1, group);
        });
      }
      var without = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
      });
      var xor = baseRest(function (arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function (arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
      });
      var xorWith = baseRest(function (arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values) {
        return baseZipObject(props || [], values || [], assignValue);
      }
      function zipObjectDeep(props, values) {
        return baseZipObject(props || [], values || [], baseSet);
      }
      var zipWith = baseRest(function (arrays) {
        var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : undefined$1;
        return unzipWith(arrays, iteratee);
      });
      function chain(value) {
        var result = lodash(value);
        result.__chain__ = true;
        return result;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function (paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) {
            return baseAt(object, paths);
          };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function (array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return {
          "done": done,
          "value": value
        };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result, parent = this;
        while (parent instanceof baseLodash) {
          var clone = wrapperClone(parent);
          clone.__index__ = 0;
          clone.__values__ = undefined$1;
          if (result) {
            previous.__wrapped__ = clone;
          } else {
            result = clone;
          }
          var previous = clone;
          parent = parent.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function (result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          ++result[key];
        } else {
          baseAssignValue(result, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      function flatMapDeep(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), INFINITY);
      }
      function flatMapDepth(collection, iteratee, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee), depth);
      }
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee, 3));
      }
      function forEachRight(collection, iteratee) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee, 3));
      }
      var groupBy = createAggregator(function (result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function (collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function (value) {
          result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result;
      });
      var keyBy = createAggregator(function (result, value, key) {
        baseAssignValue(result, key, value);
      });
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function (result, value, key) {
        result[key ? 0 : 1].push(value);
      }, function () {
        return [
          [],
          []
        ];
      });
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function (collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function () {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function () {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function () {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result;
        };
      }
      var bind = baseRest(function (func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function (object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result.placeholder = curry.placeholder;
        return result;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result.placeholder = curryRight.placeholder;
        return result;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function (func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function (func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function () {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function () {
          var args = arguments;
          switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function (func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function (args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function (func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function (func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function (func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function (args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function (value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments((function () {
        return arguments;
      }())) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result = customizer ? customizer(value, other) : undefined$1;
        return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function (value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function (object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function (object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result = baseCreate(prototype);
        return properties == null ? result : baseAssign(result, properties);
      }
      var defaults = baseRest(function (object, sources) {
        object = Object(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function (args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
      }
      function forInRight(object, iteratee) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
      }
      function forOwn(object, iteratee) {
        return object && baseForOwn(object, getIteratee(iteratee, 3));
      }
      function forOwnRight(object, iteratee) {
        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result = object == null ? undefined$1 : baseGet(object, path);
        return result === undefined$1 ? defaultValue : result;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function (result, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function (result, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function (value, key, object) {
          baseAssignValue(result, iteratee(value, key, object), value);
        });
        return result;
      }
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function (value, key, object) {
          baseAssignValue(result, key, iteratee(value, key, object));
        });
        return result;
      }
      var merge = createAssigner(function (object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function (object, paths) {
        var result = {};
        if (object == null) {
          return result;
        }
        var isDeep = false;
        paths = arrayMap(paths, function (path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result);
        if (isDeep) {
          result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result, paths[length]);
        }
        return result;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function (object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function (prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function (value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          if (value === undefined$1) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee = getIteratee(iteratee, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
          return iteratee(accumulator, value, index, object);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function (result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function (result, word, index) {
        return result + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function (result, word, index) {
        return result + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function (result, word, index) {
        return result + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function (result, word, index) {
        return result + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result = attempt(function () {
          return Function(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result.source = source;
        if (isError(result)) {
          throw result;
        }
        return result;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrim, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimEnd, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result + omission;
        }
        if (strSymbols) {
          end += result.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result;
            if (!separator.global) {
              separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result.lastIndexOf(separator);
          if (index > -1) {
            result = result.slice(0, index);
          }
        }
        return result + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function (result, word, index) {
        return result + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function (func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });
      var bindAll = flatRest(function (object, methodNames) {
        arrayEach(methodNames, function (key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function (pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return [
            toIteratee(pair[0]),
            pair[1]
          ];
        });
        return baseRest(function (args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function () {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function (path, args) {
        return function (object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function (object, args) {
        return function (path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function (methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function () {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                actions.push({
                  "func": func,
                  "args": arguments,
                  "thisArg": object
                });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function (args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function (path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee = getIteratee(iteratee);
        n -= MAX_ARRAY_LENGTH;
        var result = baseTimes(length, iteratee);
        while (++index < n) {
          iteratee(index);
        }
        return result;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function (augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function (dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee) {
        return baseMean(array, getIteratee(iteratee, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function (multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function (minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee) {
        return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, (function () {
        var source = {};
        baseForOwn(lodash, function (func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }()), { "chain": false });
      lodash.VERSION = VERSION;
      arrayEach([
        "bind",
        "bindKey",
        "curry",
        "curryRight",
        "partial",
        "partialRight"
      ], function (methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach([
        "drop",
        "take"
      ], function (methodName, index) {
        LazyWrapper.prototype[methodName] = function (n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result.__filtered__) {
            result.__takeCount__ = nativeMin(n, result.__takeCount__);
          } else {
            result.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result.__dir__ < 0 ? "Right" : "")
            });
          }
          return result;
        };
        LazyWrapper.prototype[methodName + "Right"] = function (n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach([
        "filter",
        "map",
        "takeWhile"
      ], function (methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function (iteratee) {
          var result = this.clone();
          result.__iteratees__.push({
            "iteratee": getIteratee(iteratee, 3),
            "type": type
          });
          result.__filtered__ = result.__filtered__ || isFilter;
          return result;
        };
      });
      arrayEach([
        "head",
        "last"
      ], function (methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function () {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach([
        "initial",
        "tail"
      ], function (methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function () {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function () {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function (predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function (predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function (value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function (predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function (start, end) {
        start = toInteger(start);
        var result = this;
        if (result.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result);
        }
        if (start < 0) {
          result = result.takeRight(-start);
        } else if (start) {
          result = result.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result = end < 0 ? result.dropRight(-end) : result.take(end - start);
        }
        return result;
      };
      LazyWrapper.prototype.takeRightWhile = function (predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function () {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function (func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function () {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function (value) {
            var result = lodashFunc.apply(lodash, arrayPush([value], args));
            return isTaker && chainAll ? result[0] : result;
          };
          if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);
            result.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined$1
            });
            return new LodashWrapper(result, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
        };
      });
      arrayEach([
        "pop",
        "push",
        "shift",
        "sort",
        "splice",
        "unshift"
      ], function (methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function () {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function (value) {
            return func.apply(isArray(value) ? value : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function (func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({
            "name": methodName,
            "func": lodashFunc
          });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }.call(commonjsGlobal));
}(lodash, lodash.exports));

var arrays$9 = {
  range: function (start, stop) {
    var length = stop - start, result = new Array(length), i, j;
    for (i = 0, j = start; i < length; i++, j++) {
      result[i] = j;
    }
    return result;
  },
  find: function (array, valueOrPredicate) {
    var length = array.length, i;
    if (typeof valueOrPredicate === "function") {
      for (i = 0; i < length; i++) {
        if (valueOrPredicate(array[i])) {
          return array[i];
        }
      }
    } else {
      for (i = 0; i < length; i++) {
        if (array[i] === valueOrPredicate) {
          return array[i];
        }
      }
    }
  },
  indexOf: function (array, valueOrPredicate) {
    var length = array.length, i;
    if (typeof valueOrPredicate === "function") {
      for (i = 0; i < length; i++) {
        if (valueOrPredicate(array[i])) {
          return i;
        }
      }
    } else {
      for (i = 0; i < length; i++) {
        if (array[i] === valueOrPredicate) {
          return i;
        }
      }
    }
    return -1;
  },
  contains: function (array, valueOrPredicate) {
    return arrays$9.indexOf(array, valueOrPredicate) !== -1;
  },
  each: function (array, iterator) {
    var length = array.length, i;
    for (i = 0; i < length; i++) {
      iterator(array[i], i);
    }
  },
  map: function (array, iterator) {
    var length = array.length, result = new Array(length), i;
    for (i = 0; i < length; i++) {
      result[i] = iterator(array[i], i);
    }
    return result;
  },
  pluck: function (array, key) {
    return arrays$9.map(array, function (e) {
      return e[key];
    });
  },
  every: function (array, predicate) {
    var length = array.length, i;
    for (i = 0; i < length; i++) {
      if (!predicate(array[i])) {
        return false;
      }
    }
    return true;
  },
  some: function (array, predicate) {
    var length = array.length, i;
    for (i = 0; i < length; i++) {
      if (predicate(array[i])) {
        return true;
      }
    }
    return false;
  }
};
var arrays_1 = arrays$9;

var objects$6 = {
  keys: function (object) {
    var result = [], key;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        result.push(key);
      }
    }
    return result;
  },
  values: function (object) {
    var result = [], key;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        result.push(object[key]);
      }
    }
    return result;
  },
  clone: function (object) {
    var result = {}, key;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        result[key] = object[key];
      }
    }
    return result;
  },
  defaults: function (object, defaults) {
    var key;
    for (key in defaults) {
      if (defaults.hasOwnProperty(key)) {
        if (!(key in object)) {
          object[key] = defaults[key];
        }
      }
    }
  }
};
var objects_1 = objects$6;

var classes$1 = {
  subclass: function (child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
};
var classes_1 = classes$1;

var classes = classes_1;
function GrammarError$5(message, location) {
  this.name = "GrammarError";
  this.message = message;
  this.location = location;
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, GrammarError$5);
  }
}
classes.subclass(GrammarError$5, Error);
var grammarError = GrammarError$5;

function peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}
function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}
peg$subclass(peg$SyntaxError, Error);
peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    "class": function (expectation) {
      var escapedParts = "", i;
      for (i = 0; i < expectation.parts.length; i++) {
        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
      }
      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function (expectation) {
      return "any character";
    },
    end: function (expectation) {
      return "end of input";
    },
    other: function (expectation) {
      return expectation.description;
    }
  };
  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }
  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }
  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }
  function describeExpected(expected) {
    var descriptions = new Array(expected.length), i, j;
    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }
    descriptions.sort();
    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }
    switch (descriptions.length) {
    case 1:
      return descriptions[0];
    case 2:
      return descriptions[0] + " or " + descriptions[1];
    default:
      return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }
  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }
  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  var peg$FAILED = {}, peg$startRuleFunctions = { Grammar: peg$parseGrammar }, peg$startRuleFunction = peg$parseGrammar, peg$c0 = function (initializer, rules) {
      return {
        type: "grammar",
        initializer: extractOptional(initializer, 0),
        rules: extractList(rules, 0),
        location: location()
      };
    }, peg$c1 = function (code) {
      return {
        type: "initializer",
        code: code,
        location: location()
      };
    }, peg$c2 = "=", peg$c3 = peg$literalExpectation("=", false), peg$c4 = function (name, displayName, expression) {
      return {
        type: "rule",
        name: name,
        expression: displayName !== null ? {
          type: "named",
          name: displayName[0],
          expression: expression,
          location: location()
        } : expression,
        location: location()
      };
    }, peg$c5 = "/", peg$c6 = peg$literalExpectation("/", false), peg$c7 = function (head, tail) {
      return tail.length > 0 ? {
        type: "choice",
        alternatives: buildList(head, tail, 3),
        location: location()
      } : head;
    }, peg$c8 = function (expression, code) {
      return code !== null ? {
        type: "action",
        expression: expression,
        code: code[1],
        location: location()
      } : expression;
    }, peg$c9 = function (head, tail) {
      return tail.length > 0 ? {
        type: "sequence",
        elements: buildList(head, tail, 1),
        location: location()
      } : head;
    }, peg$c10 = ":", peg$c11 = peg$literalExpectation(":", false), peg$c12 = function (label, expression) {
      return {
        type: "labeled",
        label: label,
        expression: expression,
        location: location()
      };
    }, peg$c13 = function (operator, expression) {
      return {
        type: OPS_TO_PREFIXED_TYPES[operator],
        expression: expression,
        location: location()
      };
    }, peg$c14 = "$", peg$c15 = peg$literalExpectation("$", false), peg$c16 = "&", peg$c17 = peg$literalExpectation("&", false), peg$c18 = "!", peg$c19 = peg$literalExpectation("!", false), peg$c20 = function (expression, operator) {
      return {
        type: OPS_TO_SUFFIXED_TYPES[operator],
        expression: expression,
        location: location()
      };
    }, peg$c21 = "?", peg$c22 = peg$literalExpectation("?", false), peg$c23 = "*", peg$c24 = peg$literalExpectation("*", false), peg$c25 = "+", peg$c26 = peg$literalExpectation("+", false), peg$c27 = "(", peg$c28 = peg$literalExpectation("(", false), peg$c29 = ")", peg$c30 = peg$literalExpectation(")", false), peg$c31 = function (expression) {
      return expression.type === "labeled" || expression.type === "sequence" ? {
        type: "group",
        expression: expression
      } : expression;
    }, peg$c32 = function (name) {
      return {
        type: "rule_ref",
        name: name,
        location: location()
      };
    }, peg$c33 = function (operator, code) {
      return {
        type: OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],
        code: code,
        location: location()
      };
    }, peg$c34 = peg$anyExpectation(), peg$c35 = peg$otherExpectation("whitespace"), peg$c36 = "\t", peg$c37 = peg$literalExpectation("\t", false), peg$c38 = "\x0B", peg$c39 = peg$literalExpectation("\x0B", false), peg$c40 = "\f", peg$c41 = peg$literalExpectation("\f", false), peg$c42 = " ", peg$c43 = peg$literalExpectation(" ", false), peg$c44 = "\xA0", peg$c45 = peg$literalExpectation("\xA0", false), peg$c46 = "\uFEFF", peg$c47 = peg$literalExpectation("\uFEFF", false), peg$c48 = /^[\n\r\u2028\u2029]/, peg$c49 = peg$classExpectation([
      "\n",
      "\r",
      "\u2028",
      "\u2029"
    ], false, false), peg$c50 = peg$otherExpectation("end of line"), peg$c51 = "\n", peg$c52 = peg$literalExpectation("\n", false), peg$c53 = "\r\n", peg$c54 = peg$literalExpectation("\r\n", false), peg$c55 = "\r", peg$c56 = peg$literalExpectation("\r", false), peg$c57 = "\u2028", peg$c58 = peg$literalExpectation("\u2028", false), peg$c59 = "\u2029", peg$c60 = peg$literalExpectation("\u2029", false), peg$c61 = peg$otherExpectation("comment"), peg$c62 = "/*", peg$c63 = peg$literalExpectation("/*", false), peg$c64 = "*/", peg$c65 = peg$literalExpectation("*/", false), peg$c66 = "//", peg$c67 = peg$literalExpectation("//", false), peg$c68 = function (name) {
      return name;
    }, peg$c69 = peg$otherExpectation("identifier"), peg$c70 = function (head, tail) {
      return head + tail.join("");
    }, peg$c71 = "_", peg$c72 = peg$literalExpectation("_", false), peg$c73 = "\\", peg$c74 = peg$literalExpectation("\\", false), peg$c75 = function (sequence) {
      return sequence;
    }, peg$c76 = "‌", peg$c77 = peg$literalExpectation("‌", false), peg$c78 = "‍", peg$c79 = peg$literalExpectation("‍", false), peg$c80 = peg$otherExpectation("literal"), peg$c81 = "i", peg$c82 = peg$literalExpectation("i", false), peg$c83 = function (value, ignoreCase) {
      return {
        type: "literal",
        value: value,
        ignoreCase: ignoreCase !== null,
        location: location()
      };
    }, peg$c84 = peg$otherExpectation("string"), peg$c85 = "\"", peg$c86 = peg$literalExpectation("\"", false), peg$c87 = function (chars) {
      return chars.join("");
    }, peg$c88 = "'", peg$c89 = peg$literalExpectation("'", false), peg$c90 = function () {
      return text();
    }, peg$c91 = peg$otherExpectation("character class"), peg$c92 = "[", peg$c93 = peg$literalExpectation("[", false), peg$c94 = "^", peg$c95 = peg$literalExpectation("^", false), peg$c96 = "]", peg$c97 = peg$literalExpectation("]", false), peg$c98 = function (inverted, parts, ignoreCase) {
      return {
        type: "class",
        parts: filterEmptyStrings(parts),
        inverted: inverted !== null,
        ignoreCase: ignoreCase !== null,
        location: location()
      };
    }, peg$c99 = "-", peg$c100 = peg$literalExpectation("-", false), peg$c101 = function (begin, end) {
      if (begin.charCodeAt(0) > end.charCodeAt(0)) {
        error("Invalid character range: " + text() + ".");
      }
      return [
        begin,
        end
      ];
    }, peg$c102 = function () {
      return "";
    }, peg$c103 = "0", peg$c104 = peg$literalExpectation("0", false), peg$c105 = function () {
      return "\0";
    }, peg$c106 = "b", peg$c107 = peg$literalExpectation("b", false), peg$c108 = function () {
      return "\b";
    }, peg$c109 = "f", peg$c110 = peg$literalExpectation("f", false), peg$c111 = function () {
      return "\f";
    }, peg$c112 = "n", peg$c113 = peg$literalExpectation("n", false), peg$c114 = function () {
      return "\n";
    }, peg$c115 = "r", peg$c116 = peg$literalExpectation("r", false), peg$c117 = function () {
      return "\r";
    }, peg$c118 = "t", peg$c119 = peg$literalExpectation("t", false), peg$c120 = function () {
      return "\t";
    }, peg$c121 = "v", peg$c122 = peg$literalExpectation("v", false), peg$c123 = function () {
      return "\x0B";
    }, peg$c124 = "x", peg$c125 = peg$literalExpectation("x", false), peg$c126 = "u", peg$c127 = peg$literalExpectation("u", false), peg$c128 = function (digits) {
      return String.fromCharCode(parseInt(digits, 16));
    }, peg$c129 = /^[0-9]/, peg$c130 = peg$classExpectation([[
        "0",
        "9"
      ]], false, false), peg$c131 = /^[0-9a-f]/i, peg$c132 = peg$classExpectation([
      [
        "0",
        "9"
      ],
      [
        "a",
        "f"
      ]
    ], false, true), peg$c133 = ".", peg$c134 = peg$literalExpectation(".", false), peg$c135 = function () {
      return {
        type: "any",
        location: location()
      };
    }, peg$c136 = peg$otherExpectation("code block"), peg$c137 = "{", peg$c138 = peg$literalExpectation("{", false), peg$c139 = "}", peg$c140 = peg$literalExpectation("}", false), peg$c141 = function (code) {
      return code;
    }, peg$c142 = /^[{}]/, peg$c143 = peg$classExpectation([
      "{",
      "}"
    ], false, false), peg$c144 = /^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/, peg$c145 = peg$classExpectation([
      [
        "a",
        "z"
      ],
      "µ",
      [
        "ß",
        "ö"
      ],
      [
        "ø",
        "ÿ"
      ],
      "ā",
      "ă",
      "ą",
      "ć",
      "ĉ",
      "ċ",
      "č",
      "ď",
      "đ",
      "ē",
      "ĕ",
      "ė",
      "ę",
      "ě",
      "ĝ",
      "ğ",
      "ġ",
      "ģ",
      "ĥ",
      "ħ",
      "ĩ",
      "ī",
      "ĭ",
      "į",
      "ı",
      "ĳ",
      "ĵ",
      [
        "ķ",
        "ĸ"
      ],
      "ĺ",
      "ļ",
      "ľ",
      "ŀ",
      "ł",
      "ń",
      "ņ",
      [
        "ň",
        "ŉ"
      ],
      "ŋ",
      "ō",
      "ŏ",
      "ő",
      "œ",
      "ŕ",
      "ŗ",
      "ř",
      "ś",
      "ŝ",
      "ş",
      "š",
      "ţ",
      "ť",
      "ŧ",
      "ũ",
      "ū",
      "ŭ",
      "ů",
      "ű",
      "ų",
      "ŵ",
      "ŷ",
      "ź",
      "ż",
      [
        "ž",
        "ƀ"
      ],
      "ƃ",
      "ƅ",
      "ƈ",
      [
        "ƌ",
        "ƍ"
      ],
      "ƒ",
      "ƕ",
      [
        "ƙ",
        "ƛ"
      ],
      "ƞ",
      "ơ",
      "ƣ",
      "ƥ",
      "ƨ",
      [
        "ƪ",
        "ƫ"
      ],
      "ƭ",
      "ư",
      "ƴ",
      "ƶ",
      [
        "ƹ",
        "ƺ"
      ],
      [
        "ƽ",
        "ƿ"
      ],
      "ǆ",
      "ǉ",
      "ǌ",
      "ǎ",
      "ǐ",
      "ǒ",
      "ǔ",
      "ǖ",
      "ǘ",
      "ǚ",
      [
        "ǜ",
        "ǝ"
      ],
      "ǟ",
      "ǡ",
      "ǣ",
      "ǥ",
      "ǧ",
      "ǩ",
      "ǫ",
      "ǭ",
      [
        "ǯ",
        "ǰ"
      ],
      "ǳ",
      "ǵ",
      "ǹ",
      "ǻ",
      "ǽ",
      "ǿ",
      "ȁ",
      "ȃ",
      "ȅ",
      "ȇ",
      "ȉ",
      "ȋ",
      "ȍ",
      "ȏ",
      "ȑ",
      "ȓ",
      "ȕ",
      "ȗ",
      "ș",
      "ț",
      "ȝ",
      "ȟ",
      "ȡ",
      "ȣ",
      "ȥ",
      "ȧ",
      "ȩ",
      "ȫ",
      "ȭ",
      "ȯ",
      "ȱ",
      [
        "ȳ",
        "ȹ"
      ],
      "ȼ",
      [
        "ȿ",
        "ɀ"
      ],
      "ɂ",
      "ɇ",
      "ɉ",
      "ɋ",
      "ɍ",
      [
        "ɏ",
        "ʓ"
      ],
      [
        "ʕ",
        "ʯ"
      ],
      "ͱ",
      "ͳ",
      "ͷ",
      [
        "ͻ",
        "ͽ"
      ],
      "ΐ",
      [
        "ά",
        "ώ"
      ],
      [
        "ϐ",
        "ϑ"
      ],
      [
        "ϕ",
        "ϗ"
      ],
      "ϙ",
      "ϛ",
      "ϝ",
      "ϟ",
      "ϡ",
      "ϣ",
      "ϥ",
      "ϧ",
      "ϩ",
      "ϫ",
      "ϭ",
      [
        "ϯ",
        "ϳ"
      ],
      "ϵ",
      "ϸ",
      [
        "ϻ",
        "ϼ"
      ],
      [
        "а",
        "џ"
      ],
      "ѡ",
      "ѣ",
      "ѥ",
      "ѧ",
      "ѩ",
      "ѫ",
      "ѭ",
      "ѯ",
      "ѱ",
      "ѳ",
      "ѵ",
      "ѷ",
      "ѹ",
      "ѻ",
      "ѽ",
      "ѿ",
      "ҁ",
      "ҋ",
      "ҍ",
      "ҏ",
      "ґ",
      "ғ",
      "ҕ",
      "җ",
      "ҙ",
      "қ",
      "ҝ",
      "ҟ",
      "ҡ",
      "ң",
      "ҥ",
      "ҧ",
      "ҩ",
      "ҫ",
      "ҭ",
      "ү",
      "ұ",
      "ҳ",
      "ҵ",
      "ҷ",
      "ҹ",
      "һ",
      "ҽ",
      "ҿ",
      "ӂ",
      "ӄ",
      "ӆ",
      "ӈ",
      "ӊ",
      "ӌ",
      [
        "ӎ",
        "ӏ"
      ],
      "ӑ",
      "ӓ",
      "ӕ",
      "ӗ",
      "ә",
      "ӛ",
      "ӝ",
      "ӟ",
      "ӡ",
      "ӣ",
      "ӥ",
      "ӧ",
      "ө",
      "ӫ",
      "ӭ",
      "ӯ",
      "ӱ",
      "ӳ",
      "ӵ",
      "ӷ",
      "ӹ",
      "ӻ",
      "ӽ",
      "ӿ",
      "ԁ",
      "ԃ",
      "ԅ",
      "ԇ",
      "ԉ",
      "ԋ",
      "ԍ",
      "ԏ",
      "ԑ",
      "ԓ",
      "ԕ",
      "ԗ",
      "ԙ",
      "ԛ",
      "ԝ",
      "ԟ",
      "ԡ",
      "ԣ",
      "ԥ",
      "ԧ",
      "ԩ",
      "ԫ",
      "ԭ",
      "ԯ",
      [
        "ա",
        "և"
      ],
      [
        "ᏸ",
        "ᏽ"
      ],
      [
        "ᴀ",
        "ᴫ"
      ],
      [
        "ᵫ",
        "ᵷ"
      ],
      [
        "ᵹ",
        "ᶚ"
      ],
      "ḁ",
      "ḃ",
      "ḅ",
      "ḇ",
      "ḉ",
      "ḋ",
      "ḍ",
      "ḏ",
      "ḑ",
      "ḓ",
      "ḕ",
      "ḗ",
      "ḙ",
      "ḛ",
      "ḝ",
      "ḟ",
      "ḡ",
      "ḣ",
      "ḥ",
      "ḧ",
      "ḩ",
      "ḫ",
      "ḭ",
      "ḯ",
      "ḱ",
      "ḳ",
      "ḵ",
      "ḷ",
      "ḹ",
      "ḻ",
      "ḽ",
      "ḿ",
      "ṁ",
      "ṃ",
      "ṅ",
      "ṇ",
      "ṉ",
      "ṋ",
      "ṍ",
      "ṏ",
      "ṑ",
      "ṓ",
      "ṕ",
      "ṗ",
      "ṙ",
      "ṛ",
      "ṝ",
      "ṟ",
      "ṡ",
      "ṣ",
      "ṥ",
      "ṧ",
      "ṩ",
      "ṫ",
      "ṭ",
      "ṯ",
      "ṱ",
      "ṳ",
      "ṵ",
      "ṷ",
      "ṹ",
      "ṻ",
      "ṽ",
      "ṿ",
      "ẁ",
      "ẃ",
      "ẅ",
      "ẇ",
      "ẉ",
      "ẋ",
      "ẍ",
      "ẏ",
      "ẑ",
      "ẓ",
      [
        "ẕ",
        "ẝ"
      ],
      "ẟ",
      "ạ",
      "ả",
      "ấ",
      "ầ",
      "ẩ",
      "ẫ",
      "ậ",
      "ắ",
      "ằ",
      "ẳ",
      "ẵ",
      "ặ",
      "ẹ",
      "ẻ",
      "ẽ",
      "ế",
      "ề",
      "ể",
      "ễ",
      "ệ",
      "ỉ",
      "ị",
      "ọ",
      "ỏ",
      "ố",
      "ồ",
      "ổ",
      "ỗ",
      "ộ",
      "ớ",
      "ờ",
      "ở",
      "ỡ",
      "ợ",
      "ụ",
      "ủ",
      "ứ",
      "ừ",
      "ử",
      "ữ",
      "ự",
      "ỳ",
      "ỵ",
      "ỷ",
      "ỹ",
      "ỻ",
      "ỽ",
      [
        "ỿ",
        "ἇ"
      ],
      [
        "ἐ",
        "ἕ"
      ],
      [
        "ἠ",
        "ἧ"
      ],
      [
        "ἰ",
        "ἷ"
      ],
      [
        "ὀ",
        "ὅ"
      ],
      [
        "ὐ",
        "ὗ"
      ],
      [
        "ὠ",
        "ὧ"
      ],
      [
        "ὰ",
        "ώ"
      ],
      [
        "ᾀ",
        "ᾇ"
      ],
      [
        "ᾐ",
        "ᾗ"
      ],
      [
        "ᾠ",
        "ᾧ"
      ],
      [
        "ᾰ",
        "ᾴ"
      ],
      [
        "ᾶ",
        "ᾷ"
      ],
      "ι",
      [
        "ῂ",
        "ῄ"
      ],
      [
        "ῆ",
        "ῇ"
      ],
      [
        "ῐ",
        "ΐ"
      ],
      [
        "ῖ",
        "ῗ"
      ],
      [
        "ῠ",
        "ῧ"
      ],
      [
        "ῲ",
        "ῴ"
      ],
      [
        "ῶ",
        "ῷ"
      ],
      "ℊ",
      [
        "ℎ",
        "ℏ"
      ],
      "ℓ",
      "ℯ",
      "ℴ",
      "ℹ",
      [
        "ℼ",
        "ℽ"
      ],
      [
        "ⅆ",
        "ⅉ"
      ],
      "ⅎ",
      "ↄ",
      [
        "ⰰ",
        "ⱞ"
      ],
      "ⱡ",
      [
        "ⱥ",
        "ⱦ"
      ],
      "ⱨ",
      "ⱪ",
      "ⱬ",
      "ⱱ",
      [
        "ⱳ",
        "ⱴ"
      ],
      [
        "ⱶ",
        "ⱻ"
      ],
      "ⲁ",
      "ⲃ",
      "ⲅ",
      "ⲇ",
      "ⲉ",
      "ⲋ",
      "ⲍ",
      "ⲏ",
      "ⲑ",
      "ⲓ",
      "ⲕ",
      "ⲗ",
      "ⲙ",
      "ⲛ",
      "ⲝ",
      "ⲟ",
      "ⲡ",
      "ⲣ",
      "ⲥ",
      "ⲧ",
      "ⲩ",
      "ⲫ",
      "ⲭ",
      "ⲯ",
      "ⲱ",
      "ⲳ",
      "ⲵ",
      "ⲷ",
      "ⲹ",
      "ⲻ",
      "ⲽ",
      "ⲿ",
      "ⳁ",
      "ⳃ",
      "ⳅ",
      "ⳇ",
      "ⳉ",
      "ⳋ",
      "ⳍ",
      "ⳏ",
      "ⳑ",
      "ⳓ",
      "ⳕ",
      "ⳗ",
      "ⳙ",
      "ⳛ",
      "ⳝ",
      "ⳟ",
      "ⳡ",
      [
        "ⳣ",
        "ⳤ"
      ],
      "ⳬ",
      "ⳮ",
      "ⳳ",
      [
        "ⴀ",
        "ⴥ"
      ],
      "ⴧ",
      "ⴭ",
      "ꙁ",
      "ꙃ",
      "ꙅ",
      "ꙇ",
      "ꙉ",
      "ꙋ",
      "ꙍ",
      "ꙏ",
      "ꙑ",
      "ꙓ",
      "ꙕ",
      "ꙗ",
      "ꙙ",
      "ꙛ",
      "ꙝ",
      "ꙟ",
      "ꙡ",
      "ꙣ",
      "ꙥ",
      "ꙧ",
      "ꙩ",
      "ꙫ",
      "ꙭ",
      "ꚁ",
      "ꚃ",
      "ꚅ",
      "ꚇ",
      "ꚉ",
      "ꚋ",
      "ꚍ",
      "ꚏ",
      "ꚑ",
      "ꚓ",
      "ꚕ",
      "ꚗ",
      "ꚙ",
      "ꚛ",
      "ꜣ",
      "ꜥ",
      "ꜧ",
      "ꜩ",
      "ꜫ",
      "ꜭ",
      [
        "ꜯ",
        "ꜱ"
      ],
      "ꜳ",
      "ꜵ",
      "ꜷ",
      "ꜹ",
      "ꜻ",
      "ꜽ",
      "ꜿ",
      "ꝁ",
      "ꝃ",
      "ꝅ",
      "ꝇ",
      "ꝉ",
      "ꝋ",
      "ꝍ",
      "ꝏ",
      "ꝑ",
      "ꝓ",
      "ꝕ",
      "ꝗ",
      "ꝙ",
      "ꝛ",
      "ꝝ",
      "ꝟ",
      "ꝡ",
      "ꝣ",
      "ꝥ",
      "ꝧ",
      "ꝩ",
      "ꝫ",
      "ꝭ",
      "ꝯ",
      [
        "ꝱ",
        "ꝸ"
      ],
      "ꝺ",
      "ꝼ",
      "ꝿ",
      "ꞁ",
      "ꞃ",
      "ꞅ",
      "ꞇ",
      "ꞌ",
      "ꞎ",
      "ꞑ",
      [
        "ꞓ",
        "ꞕ"
      ],
      "ꞗ",
      "ꞙ",
      "ꞛ",
      "ꞝ",
      "ꞟ",
      "ꞡ",
      "ꞣ",
      "ꞥ",
      "ꞧ",
      "ꞩ",
      "ꞵ",
      "ꞷ",
      "ꟺ",
      [
        "ꬰ",
        "ꭚ"
      ],
      [
        "ꭠ",
        "ꭥ"
      ],
      [
        "ꭰ",
        "ꮿ"
      ],
      [
        "ﬀ",
        "ﬆ"
      ],
      [
        "ﬓ",
        "ﬗ"
      ],
      [
        "ａ",
        "ｚ"
      ]
    ], false, false), peg$c146 = /^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C-\uA69D\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3-\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E-\uFF9F]/, peg$c147 = peg$classExpectation([
      [
        "ʰ",
        "ˁ"
      ],
      [
        "ˆ",
        "ˑ"
      ],
      [
        "ˠ",
        "ˤ"
      ],
      "ˬ",
      "ˮ",
      "ʹ",
      "ͺ",
      "ՙ",
      "ـ",
      [
        "ۥ",
        "ۦ"
      ],
      [
        "ߴ",
        "ߵ"
      ],
      "ߺ",
      "ࠚ",
      "ࠤ",
      "ࠨ",
      "ॱ",
      "ๆ",
      "ໆ",
      "ჼ",
      "ៗ",
      "ᡃ",
      "ᪧ",
      [
        "ᱸ",
        "ᱽ"
      ],
      [
        "ᴬ",
        "ᵪ"
      ],
      "ᵸ",
      [
        "ᶛ",
        "ᶿ"
      ],
      "ⁱ",
      "ⁿ",
      [
        "ₐ",
        "ₜ"
      ],
      [
        "ⱼ",
        "ⱽ"
      ],
      "ⵯ",
      "ⸯ",
      "々",
      [
        "〱",
        "〵"
      ],
      "〻",
      [
        "ゝ",
        "ゞ"
      ],
      [
        "ー",
        "ヾ"
      ],
      "ꀕ",
      [
        "ꓸ",
        "ꓽ"
      ],
      "ꘌ",
      "ꙿ",
      [
        "ꚜ",
        "ꚝ"
      ],
      [
        "ꜗ",
        "ꜟ"
      ],
      "ꝰ",
      "ꞈ",
      [
        "ꟸ",
        "ꟹ"
      ],
      "ꧏ",
      "ꧦ",
      "ꩰ",
      "ꫝ",
      [
        "ꫳ",
        "ꫴ"
      ],
      [
        "ꭜ",
        "ꭟ"
      ],
      "ｰ",
      [
        "ﾞ",
        "ﾟ"
      ]
    ], false, false), peg$c148 = /^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, peg$c149 = peg$classExpectation([
      "ª",
      "º",
      "ƻ",
      [
        "ǀ",
        "ǃ"
      ],
      "ʔ",
      [
        "א",
        "ת"
      ],
      [
        "װ",
        "ײ"
      ],
      [
        "ؠ",
        "ؿ"
      ],
      [
        "ف",
        "ي"
      ],
      [
        "ٮ",
        "ٯ"
      ],
      [
        "ٱ",
        "ۓ"
      ],
      "ە",
      [
        "ۮ",
        "ۯ"
      ],
      [
        "ۺ",
        "ۼ"
      ],
      "ۿ",
      "ܐ",
      [
        "ܒ",
        "ܯ"
      ],
      [
        "ݍ",
        "ޥ"
      ],
      "ޱ",
      [
        "ߊ",
        "ߪ"
      ],
      [
        "ࠀ",
        "ࠕ"
      ],
      [
        "ࡀ",
        "ࡘ"
      ],
      [
        "ࢠ",
        "ࢴ"
      ],
      [
        "ऄ",
        "ह"
      ],
      "ऽ",
      "ॐ",
      [
        "क़",
        "ॡ"
      ],
      [
        "ॲ",
        "ঀ"
      ],
      [
        "অ",
        "ঌ"
      ],
      [
        "এ",
        "ঐ"
      ],
      [
        "ও",
        "ন"
      ],
      [
        "প",
        "র"
      ],
      "ল",
      [
        "শ",
        "হ"
      ],
      "ঽ",
      "ৎ",
      [
        "ড়",
        "ঢ়"
      ],
      [
        "য়",
        "ৡ"
      ],
      [
        "ৰ",
        "ৱ"
      ],
      [
        "ਅ",
        "ਊ"
      ],
      [
        "ਏ",
        "ਐ"
      ],
      [
        "ਓ",
        "ਨ"
      ],
      [
        "ਪ",
        "ਰ"
      ],
      [
        "ਲ",
        "ਲ਼"
      ],
      [
        "ਵ",
        "ਸ਼"
      ],
      [
        "ਸ",
        "ਹ"
      ],
      [
        "ਖ਼",
        "ੜ"
      ],
      "ਫ਼",
      [
        "ੲ",
        "ੴ"
      ],
      [
        "અ",
        "ઍ"
      ],
      [
        "એ",
        "ઑ"
      ],
      [
        "ઓ",
        "ન"
      ],
      [
        "પ",
        "ર"
      ],
      [
        "લ",
        "ળ"
      ],
      [
        "વ",
        "હ"
      ],
      "ઽ",
      "ૐ",
      [
        "ૠ",
        "ૡ"
      ],
      "ૹ",
      [
        "ଅ",
        "ଌ"
      ],
      [
        "ଏ",
        "ଐ"
      ],
      [
        "ଓ",
        "ନ"
      ],
      [
        "ପ",
        "ର"
      ],
      [
        "ଲ",
        "ଳ"
      ],
      [
        "ଵ",
        "ହ"
      ],
      "ଽ",
      [
        "ଡ଼",
        "ଢ଼"
      ],
      [
        "ୟ",
        "ୡ"
      ],
      "ୱ",
      "ஃ",
      [
        "அ",
        "ஊ"
      ],
      [
        "எ",
        "ஐ"
      ],
      [
        "ஒ",
        "க"
      ],
      [
        "ங",
        "ச"
      ],
      "ஜ",
      [
        "ஞ",
        "ட"
      ],
      [
        "ண",
        "த"
      ],
      [
        "ந",
        "ப"
      ],
      [
        "ம",
        "ஹ"
      ],
      "ௐ",
      [
        "అ",
        "ఌ"
      ],
      [
        "ఎ",
        "ఐ"
      ],
      [
        "ఒ",
        "న"
      ],
      [
        "ప",
        "హ"
      ],
      "ఽ",
      [
        "ౘ",
        "ౚ"
      ],
      [
        "ౠ",
        "ౡ"
      ],
      [
        "ಅ",
        "ಌ"
      ],
      [
        "ಎ",
        "ಐ"
      ],
      [
        "ಒ",
        "ನ"
      ],
      [
        "ಪ",
        "ಳ"
      ],
      [
        "ವ",
        "ಹ"
      ],
      "ಽ",
      "ೞ",
      [
        "ೠ",
        "ೡ"
      ],
      [
        "ೱ",
        "ೲ"
      ],
      [
        "അ",
        "ഌ"
      ],
      [
        "എ",
        "ഐ"
      ],
      [
        "ഒ",
        "ഺ"
      ],
      "ഽ",
      "ൎ",
      [
        "ൟ",
        "ൡ"
      ],
      [
        "ൺ",
        "ൿ"
      ],
      [
        "අ",
        "ඖ"
      ],
      [
        "ක",
        "න"
      ],
      [
        "ඳ",
        "ර"
      ],
      "ල",
      [
        "ව",
        "ෆ"
      ],
      [
        "ก",
        "ะ"
      ],
      [
        "า",
        "ำ"
      ],
      [
        "เ",
        "ๅ"
      ],
      [
        "ກ",
        "ຂ"
      ],
      "ຄ",
      [
        "ງ",
        "ຈ"
      ],
      "ຊ",
      "ຍ",
      [
        "ດ",
        "ທ"
      ],
      [
        "ນ",
        "ຟ"
      ],
      [
        "ມ",
        "ຣ"
      ],
      "ລ",
      "ວ",
      [
        "ສ",
        "ຫ"
      ],
      [
        "ອ",
        "ະ"
      ],
      [
        "າ",
        "ຳ"
      ],
      "ຽ",
      [
        "ເ",
        "ໄ"
      ],
      [
        "ໜ",
        "ໟ"
      ],
      "ༀ",
      [
        "ཀ",
        "ཇ"
      ],
      [
        "ཉ",
        "ཬ"
      ],
      [
        "ྈ",
        "ྌ"
      ],
      [
        "က",
        "ဪ"
      ],
      "ဿ",
      [
        "ၐ",
        "ၕ"
      ],
      [
        "ၚ",
        "ၝ"
      ],
      "ၡ",
      [
        "ၥ",
        "ၦ"
      ],
      [
        "ၮ",
        "ၰ"
      ],
      [
        "ၵ",
        "ႁ"
      ],
      "ႎ",
      [
        "ა",
        "ჺ"
      ],
      [
        "ჽ",
        "ቈ"
      ],
      [
        "ቊ",
        "ቍ"
      ],
      [
        "ቐ",
        "ቖ"
      ],
      "ቘ",
      [
        "ቚ",
        "ቝ"
      ],
      [
        "በ",
        "ኈ"
      ],
      [
        "ኊ",
        "ኍ"
      ],
      [
        "ነ",
        "ኰ"
      ],
      [
        "ኲ",
        "ኵ"
      ],
      [
        "ኸ",
        "ኾ"
      ],
      "ዀ",
      [
        "ዂ",
        "ዅ"
      ],
      [
        "ወ",
        "ዖ"
      ],
      [
        "ዘ",
        "ጐ"
      ],
      [
        "ጒ",
        "ጕ"
      ],
      [
        "ጘ",
        "ፚ"
      ],
      [
        "ᎀ",
        "ᎏ"
      ],
      [
        "ᐁ",
        "ᙬ"
      ],
      [
        "ᙯ",
        "ᙿ"
      ],
      [
        "ᚁ",
        "ᚚ"
      ],
      [
        "ᚠ",
        "ᛪ"
      ],
      [
        "ᛱ",
        "ᛸ"
      ],
      [
        "ᜀ",
        "ᜌ"
      ],
      [
        "ᜎ",
        "ᜑ"
      ],
      [
        "ᜠ",
        "ᜱ"
      ],
      [
        "ᝀ",
        "ᝑ"
      ],
      [
        "ᝠ",
        "ᝬ"
      ],
      [
        "ᝮ",
        "ᝰ"
      ],
      [
        "ក",
        "ឳ"
      ],
      "ៜ",
      [
        "ᠠ",
        "ᡂ"
      ],
      [
        "ᡄ",
        "ᡷ"
      ],
      [
        "ᢀ",
        "ᢨ"
      ],
      "ᢪ",
      [
        "ᢰ",
        "ᣵ"
      ],
      [
        "ᤀ",
        "ᤞ"
      ],
      [
        "ᥐ",
        "ᥭ"
      ],
      [
        "ᥰ",
        "ᥴ"
      ],
      [
        "ᦀ",
        "ᦫ"
      ],
      [
        "ᦰ",
        "ᧉ"
      ],
      [
        "ᨀ",
        "ᨖ"
      ],
      [
        "ᨠ",
        "ᩔ"
      ],
      [
        "ᬅ",
        "ᬳ"
      ],
      [
        "ᭅ",
        "ᭋ"
      ],
      [
        "ᮃ",
        "ᮠ"
      ],
      [
        "ᮮ",
        "ᮯ"
      ],
      [
        "ᮺ",
        "ᯥ"
      ],
      [
        "ᰀ",
        "ᰣ"
      ],
      [
        "ᱍ",
        "ᱏ"
      ],
      [
        "ᱚ",
        "ᱷ"
      ],
      [
        "ᳩ",
        "ᳬ"
      ],
      [
        "ᳮ",
        "ᳱ"
      ],
      [
        "ᳵ",
        "ᳶ"
      ],
      [
        "ℵ",
        "ℸ"
      ],
      [
        "ⴰ",
        "ⵧ"
      ],
      [
        "ⶀ",
        "ⶖ"
      ],
      [
        "ⶠ",
        "ⶦ"
      ],
      [
        "ⶨ",
        "ⶮ"
      ],
      [
        "ⶰ",
        "ⶶ"
      ],
      [
        "ⶸ",
        "ⶾ"
      ],
      [
        "ⷀ",
        "ⷆ"
      ],
      [
        "ⷈ",
        "ⷎ"
      ],
      [
        "ⷐ",
        "ⷖ"
      ],
      [
        "ⷘ",
        "ⷞ"
      ],
      "〆",
      "〼",
      [
        "ぁ",
        "ゖ"
      ],
      "ゟ",
      [
        "ァ",
        "ヺ"
      ],
      "ヿ",
      [
        "ㄅ",
        "ㄭ"
      ],
      [
        "ㄱ",
        "ㆎ"
      ],
      [
        "ㆠ",
        "ㆺ"
      ],
      [
        "ㇰ",
        "ㇿ"
      ],
      [
        "㐀",
        "䶵"
      ],
      [
        "一",
        "鿕"
      ],
      [
        "ꀀ",
        "ꀔ"
      ],
      [
        "ꀖ",
        "ꒌ"
      ],
      [
        "ꓐ",
        "ꓷ"
      ],
      [
        "ꔀ",
        "ꘋ"
      ],
      [
        "ꘐ",
        "ꘟ"
      ],
      [
        "ꘪ",
        "ꘫ"
      ],
      "ꙮ",
      [
        "ꚠ",
        "ꛥ"
      ],
      "ꞏ",
      "ꟷ",
      [
        "ꟻ",
        "ꠁ"
      ],
      [
        "ꠃ",
        "ꠅ"
      ],
      [
        "ꠇ",
        "ꠊ"
      ],
      [
        "ꠌ",
        "ꠢ"
      ],
      [
        "ꡀ",
        "ꡳ"
      ],
      [
        "ꢂ",
        "ꢳ"
      ],
      [
        "ꣲ",
        "ꣷ"
      ],
      "ꣻ",
      "ꣽ",
      [
        "ꤊ",
        "ꤥ"
      ],
      [
        "ꤰ",
        "ꥆ"
      ],
      [
        "ꥠ",
        "ꥼ"
      ],
      [
        "ꦄ",
        "ꦲ"
      ],
      [
        "ꧠ",
        "ꧤ"
      ],
      [
        "ꧧ",
        "ꧯ"
      ],
      [
        "ꧺ",
        "ꧾ"
      ],
      [
        "ꨀ",
        "ꨨ"
      ],
      [
        "ꩀ",
        "ꩂ"
      ],
      [
        "ꩄ",
        "ꩋ"
      ],
      [
        "ꩠ",
        "ꩯ"
      ],
      [
        "ꩱ",
        "ꩶ"
      ],
      "ꩺ",
      [
        "ꩾ",
        "ꪯ"
      ],
      "ꪱ",
      [
        "ꪵ",
        "ꪶ"
      ],
      [
        "ꪹ",
        "ꪽ"
      ],
      "ꫀ",
      "ꫂ",
      [
        "ꫛ",
        "ꫜ"
      ],
      [
        "ꫠ",
        "ꫪ"
      ],
      "ꫲ",
      [
        "ꬁ",
        "ꬆ"
      ],
      [
        "ꬉ",
        "ꬎ"
      ],
      [
        "ꬑ",
        "ꬖ"
      ],
      [
        "ꬠ",
        "ꬦ"
      ],
      [
        "ꬨ",
        "ꬮ"
      ],
      [
        "ꯀ",
        "ꯢ"
      ],
      [
        "가",
        "힣"
      ],
      [
        "ힰ",
        "ퟆ"
      ],
      [
        "ퟋ",
        "ퟻ"
      ],
      [
        "豈",
        "舘"
      ],
      [
        "並",
        "龎"
      ],
      "יִ",
      [
        "ײַ",
        "ﬨ"
      ],
      [
        "שׁ",
        "זּ"
      ],
      [
        "טּ",
        "לּ"
      ],
      "מּ",
      [
        "נּ",
        "סּ"
      ],
      [
        "ףּ",
        "פּ"
      ],
      [
        "צּ",
        "ﮱ"
      ],
      [
        "ﯓ",
        "ﴽ"
      ],
      [
        "ﵐ",
        "ﶏ"
      ],
      [
        "ﶒ",
        "ﷇ"
      ],
      [
        "ﷰ",
        "ﷻ"
      ],
      [
        "ﹰ",
        "ﹴ"
      ],
      [
        "ﹶ",
        "ﻼ"
      ],
      [
        "ｦ",
        "ｯ"
      ],
      [
        "ｱ",
        "ﾝ"
      ],
      [
        "ﾠ",
        "ﾾ"
      ],
      [
        "ￂ",
        "ￇ"
      ],
      [
        "ￊ",
        "ￏ"
      ],
      [
        "ￒ",
        "ￗ"
      ],
      [
        "ￚ",
        "ￜ"
      ]
    ], false, false), peg$c150 = /^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/, peg$c151 = peg$classExpectation([
      "ǅ",
      "ǈ",
      "ǋ",
      "ǲ",
      [
        "ᾈ",
        "ᾏ"
      ],
      [
        "ᾘ",
        "ᾟ"
      ],
      [
        "ᾨ",
        "ᾯ"
      ],
      "ᾼ",
      "ῌ",
      "ῼ"
    ], false, false), peg$c152 = /^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]/, peg$c153 = peg$classExpectation([
      [
        "A",
        "Z"
      ],
      [
        "À",
        "Ö"
      ],
      [
        "Ø",
        "Þ"
      ],
      "Ā",
      "Ă",
      "Ą",
      "Ć",
      "Ĉ",
      "Ċ",
      "Č",
      "Ď",
      "Đ",
      "Ē",
      "Ĕ",
      "Ė",
      "Ę",
      "Ě",
      "Ĝ",
      "Ğ",
      "Ġ",
      "Ģ",
      "Ĥ",
      "Ħ",
      "Ĩ",
      "Ī",
      "Ĭ",
      "Į",
      "İ",
      "Ĳ",
      "Ĵ",
      "Ķ",
      "Ĺ",
      "Ļ",
      "Ľ",
      "Ŀ",
      "Ł",
      "Ń",
      "Ņ",
      "Ň",
      "Ŋ",
      "Ō",
      "Ŏ",
      "Ő",
      "Œ",
      "Ŕ",
      "Ŗ",
      "Ř",
      "Ś",
      "Ŝ",
      "Ş",
      "Š",
      "Ţ",
      "Ť",
      "Ŧ",
      "Ũ",
      "Ū",
      "Ŭ",
      "Ů",
      "Ű",
      "Ų",
      "Ŵ",
      "Ŷ",
      [
        "Ÿ",
        "Ź"
      ],
      "Ż",
      "Ž",
      [
        "Ɓ",
        "Ƃ"
      ],
      "Ƅ",
      [
        "Ɔ",
        "Ƈ"
      ],
      [
        "Ɖ",
        "Ƌ"
      ],
      [
        "Ǝ",
        "Ƒ"
      ],
      [
        "Ɠ",
        "Ɣ"
      ],
      [
        "Ɩ",
        "Ƙ"
      ],
      [
        "Ɯ",
        "Ɲ"
      ],
      [
        "Ɵ",
        "Ơ"
      ],
      "Ƣ",
      "Ƥ",
      [
        "Ʀ",
        "Ƨ"
      ],
      "Ʃ",
      "Ƭ",
      [
        "Ʈ",
        "Ư"
      ],
      [
        "Ʊ",
        "Ƴ"
      ],
      "Ƶ",
      [
        "Ʒ",
        "Ƹ"
      ],
      "Ƽ",
      "Ǆ",
      "Ǉ",
      "Ǌ",
      "Ǎ",
      "Ǐ",
      "Ǒ",
      "Ǔ",
      "Ǖ",
      "Ǘ",
      "Ǚ",
      "Ǜ",
      "Ǟ",
      "Ǡ",
      "Ǣ",
      "Ǥ",
      "Ǧ",
      "Ǩ",
      "Ǫ",
      "Ǭ",
      "Ǯ",
      "Ǳ",
      "Ǵ",
      [
        "Ƕ",
        "Ǹ"
      ],
      "Ǻ",
      "Ǽ",
      "Ǿ",
      "Ȁ",
      "Ȃ",
      "Ȅ",
      "Ȇ",
      "Ȉ",
      "Ȋ",
      "Ȍ",
      "Ȏ",
      "Ȑ",
      "Ȓ",
      "Ȕ",
      "Ȗ",
      "Ș",
      "Ț",
      "Ȝ",
      "Ȟ",
      "Ƞ",
      "Ȣ",
      "Ȥ",
      "Ȧ",
      "Ȩ",
      "Ȫ",
      "Ȭ",
      "Ȯ",
      "Ȱ",
      "Ȳ",
      [
        "Ⱥ",
        "Ȼ"
      ],
      [
        "Ƚ",
        "Ⱦ"
      ],
      "Ɂ",
      [
        "Ƀ",
        "Ɇ"
      ],
      "Ɉ",
      "Ɋ",
      "Ɍ",
      "Ɏ",
      "Ͱ",
      "Ͳ",
      "Ͷ",
      "Ϳ",
      "Ά",
      [
        "Έ",
        "Ί"
      ],
      "Ό",
      [
        "Ύ",
        "Ώ"
      ],
      [
        "Α",
        "Ρ"
      ],
      [
        "Σ",
        "Ϋ"
      ],
      "Ϗ",
      [
        "ϒ",
        "ϔ"
      ],
      "Ϙ",
      "Ϛ",
      "Ϝ",
      "Ϟ",
      "Ϡ",
      "Ϣ",
      "Ϥ",
      "Ϧ",
      "Ϩ",
      "Ϫ",
      "Ϭ",
      "Ϯ",
      "ϴ",
      "Ϸ",
      [
        "Ϲ",
        "Ϻ"
      ],
      [
        "Ͻ",
        "Я"
      ],
      "Ѡ",
      "Ѣ",
      "Ѥ",
      "Ѧ",
      "Ѩ",
      "Ѫ",
      "Ѭ",
      "Ѯ",
      "Ѱ",
      "Ѳ",
      "Ѵ",
      "Ѷ",
      "Ѹ",
      "Ѻ",
      "Ѽ",
      "Ѿ",
      "Ҁ",
      "Ҋ",
      "Ҍ",
      "Ҏ",
      "Ґ",
      "Ғ",
      "Ҕ",
      "Җ",
      "Ҙ",
      "Қ",
      "Ҝ",
      "Ҟ",
      "Ҡ",
      "Ң",
      "Ҥ",
      "Ҧ",
      "Ҩ",
      "Ҫ",
      "Ҭ",
      "Ү",
      "Ұ",
      "Ҳ",
      "Ҵ",
      "Ҷ",
      "Ҹ",
      "Һ",
      "Ҽ",
      "Ҿ",
      [
        "Ӏ",
        "Ӂ"
      ],
      "Ӄ",
      "Ӆ",
      "Ӈ",
      "Ӊ",
      "Ӌ",
      "Ӎ",
      "Ӑ",
      "Ӓ",
      "Ӕ",
      "Ӗ",
      "Ә",
      "Ӛ",
      "Ӝ",
      "Ӟ",
      "Ӡ",
      "Ӣ",
      "Ӥ",
      "Ӧ",
      "Ө",
      "Ӫ",
      "Ӭ",
      "Ӯ",
      "Ӱ",
      "Ӳ",
      "Ӵ",
      "Ӷ",
      "Ӹ",
      "Ӻ",
      "Ӽ",
      "Ӿ",
      "Ԁ",
      "Ԃ",
      "Ԅ",
      "Ԇ",
      "Ԉ",
      "Ԋ",
      "Ԍ",
      "Ԏ",
      "Ԑ",
      "Ԓ",
      "Ԕ",
      "Ԗ",
      "Ԙ",
      "Ԛ",
      "Ԝ",
      "Ԟ",
      "Ԡ",
      "Ԣ",
      "Ԥ",
      "Ԧ",
      "Ԩ",
      "Ԫ",
      "Ԭ",
      "Ԯ",
      [
        "Ա",
        "Ֆ"
      ],
      [
        "Ⴀ",
        "Ⴥ"
      ],
      "Ⴧ",
      "Ⴭ",
      [
        "Ꭰ",
        "Ᏽ"
      ],
      "Ḁ",
      "Ḃ",
      "Ḅ",
      "Ḇ",
      "Ḉ",
      "Ḋ",
      "Ḍ",
      "Ḏ",
      "Ḑ",
      "Ḓ",
      "Ḕ",
      "Ḗ",
      "Ḙ",
      "Ḛ",
      "Ḝ",
      "Ḟ",
      "Ḡ",
      "Ḣ",
      "Ḥ",
      "Ḧ",
      "Ḩ",
      "Ḫ",
      "Ḭ",
      "Ḯ",
      "Ḱ",
      "Ḳ",
      "Ḵ",
      "Ḷ",
      "Ḹ",
      "Ḻ",
      "Ḽ",
      "Ḿ",
      "Ṁ",
      "Ṃ",
      "Ṅ",
      "Ṇ",
      "Ṉ",
      "Ṋ",
      "Ṍ",
      "Ṏ",
      "Ṑ",
      "Ṓ",
      "Ṕ",
      "Ṗ",
      "Ṙ",
      "Ṛ",
      "Ṝ",
      "Ṟ",
      "Ṡ",
      "Ṣ",
      "Ṥ",
      "Ṧ",
      "Ṩ",
      "Ṫ",
      "Ṭ",
      "Ṯ",
      "Ṱ",
      "Ṳ",
      "Ṵ",
      "Ṷ",
      "Ṹ",
      "Ṻ",
      "Ṽ",
      "Ṿ",
      "Ẁ",
      "Ẃ",
      "Ẅ",
      "Ẇ",
      "Ẉ",
      "Ẋ",
      "Ẍ",
      "Ẏ",
      "Ẑ",
      "Ẓ",
      "Ẕ",
      "ẞ",
      "Ạ",
      "Ả",
      "Ấ",
      "Ầ",
      "Ẩ",
      "Ẫ",
      "Ậ",
      "Ắ",
      "Ằ",
      "Ẳ",
      "Ẵ",
      "Ặ",
      "Ẹ",
      "Ẻ",
      "Ẽ",
      "Ế",
      "Ề",
      "Ể",
      "Ễ",
      "Ệ",
      "Ỉ",
      "Ị",
      "Ọ",
      "Ỏ",
      "Ố",
      "Ồ",
      "Ổ",
      "Ỗ",
      "Ộ",
      "Ớ",
      "Ờ",
      "Ở",
      "Ỡ",
      "Ợ",
      "Ụ",
      "Ủ",
      "Ứ",
      "Ừ",
      "Ử",
      "Ữ",
      "Ự",
      "Ỳ",
      "Ỵ",
      "Ỷ",
      "Ỹ",
      "Ỻ",
      "Ỽ",
      "Ỿ",
      [
        "Ἀ",
        "Ἇ"
      ],
      [
        "Ἐ",
        "Ἕ"
      ],
      [
        "Ἠ",
        "Ἧ"
      ],
      [
        "Ἰ",
        "Ἷ"
      ],
      [
        "Ὀ",
        "Ὅ"
      ],
      "Ὑ",
      "Ὓ",
      "Ὕ",
      "Ὗ",
      [
        "Ὠ",
        "Ὧ"
      ],
      [
        "Ᾰ",
        "Ά"
      ],
      [
        "Ὲ",
        "Ή"
      ],
      [
        "Ῐ",
        "Ί"
      ],
      [
        "Ῠ",
        "Ῥ"
      ],
      [
        "Ὸ",
        "Ώ"
      ],
      "ℂ",
      "ℇ",
      [
        "ℋ",
        "ℍ"
      ],
      [
        "ℐ",
        "ℒ"
      ],
      "ℕ",
      [
        "ℙ",
        "ℝ"
      ],
      "ℤ",
      "Ω",
      "ℨ",
      [
        "K",
        "ℭ"
      ],
      [
        "ℰ",
        "ℳ"
      ],
      [
        "ℾ",
        "ℿ"
      ],
      "ⅅ",
      "Ↄ",
      [
        "Ⰰ",
        "Ⱞ"
      ],
      "Ⱡ",
      [
        "Ɫ",
        "Ɽ"
      ],
      "Ⱨ",
      "Ⱪ",
      "Ⱬ",
      [
        "Ɑ",
        "Ɒ"
      ],
      "Ⱳ",
      "Ⱶ",
      [
        "Ȿ",
        "Ⲁ"
      ],
      "Ⲃ",
      "Ⲅ",
      "Ⲇ",
      "Ⲉ",
      "Ⲋ",
      "Ⲍ",
      "Ⲏ",
      "Ⲑ",
      "Ⲓ",
      "Ⲕ",
      "Ⲗ",
      "Ⲙ",
      "Ⲛ",
      "Ⲝ",
      "Ⲟ",
      "Ⲡ",
      "Ⲣ",
      "Ⲥ",
      "Ⲧ",
      "Ⲩ",
      "Ⲫ",
      "Ⲭ",
      "Ⲯ",
      "Ⲱ",
      "Ⲳ",
      "Ⲵ",
      "Ⲷ",
      "Ⲹ",
      "Ⲻ",
      "Ⲽ",
      "Ⲿ",
      "Ⳁ",
      "Ⳃ",
      "Ⳅ",
      "Ⳇ",
      "Ⳉ",
      "Ⳋ",
      "Ⳍ",
      "Ⳏ",
      "Ⳑ",
      "Ⳓ",
      "Ⳕ",
      "Ⳗ",
      "Ⳙ",
      "Ⳛ",
      "Ⳝ",
      "Ⳟ",
      "Ⳡ",
      "Ⳣ",
      "Ⳬ",
      "Ⳮ",
      "Ⳳ",
      "Ꙁ",
      "Ꙃ",
      "Ꙅ",
      "Ꙇ",
      "Ꙉ",
      "Ꙋ",
      "Ꙍ",
      "Ꙏ",
      "Ꙑ",
      "Ꙓ",
      "Ꙕ",
      "Ꙗ",
      "Ꙙ",
      "Ꙛ",
      "Ꙝ",
      "Ꙟ",
      "Ꙡ",
      "Ꙣ",
      "Ꙥ",
      "Ꙧ",
      "Ꙩ",
      "Ꙫ",
      "Ꙭ",
      "Ꚁ",
      "Ꚃ",
      "Ꚅ",
      "Ꚇ",
      "Ꚉ",
      "Ꚋ",
      "Ꚍ",
      "Ꚏ",
      "Ꚑ",
      "Ꚓ",
      "Ꚕ",
      "Ꚗ",
      "Ꚙ",
      "Ꚛ",
      "Ꜣ",
      "Ꜥ",
      "Ꜧ",
      "Ꜩ",
      "Ꜫ",
      "Ꜭ",
      "Ꜯ",
      "Ꜳ",
      "Ꜵ",
      "Ꜷ",
      "Ꜹ",
      "Ꜻ",
      "Ꜽ",
      "Ꜿ",
      "Ꝁ",
      "Ꝃ",
      "Ꝅ",
      "Ꝇ",
      "Ꝉ",
      "Ꝋ",
      "Ꝍ",
      "Ꝏ",
      "Ꝑ",
      "Ꝓ",
      "Ꝕ",
      "Ꝗ",
      "Ꝙ",
      "Ꝛ",
      "Ꝝ",
      "Ꝟ",
      "Ꝡ",
      "Ꝣ",
      "Ꝥ",
      "Ꝧ",
      "Ꝩ",
      "Ꝫ",
      "Ꝭ",
      "Ꝯ",
      "Ꝺ",
      "Ꝼ",
      [
        "Ᵹ",
        "Ꝿ"
      ],
      "Ꞁ",
      "Ꞃ",
      "Ꞅ",
      "Ꞇ",
      "Ꞌ",
      "Ɥ",
      "Ꞑ",
      "Ꞓ",
      "Ꞗ",
      "Ꞙ",
      "Ꞛ",
      "Ꞝ",
      "Ꞟ",
      "Ꞡ",
      "Ꞣ",
      "Ꞥ",
      "Ꞧ",
      "Ꞩ",
      [
        "Ɦ",
        "Ɬ"
      ],
      [
        "Ʞ",
        "Ꞵ"
      ],
      "Ꞷ",
      [
        "Ａ",
        "Ｚ"
      ]
    ], false, false), peg$c154 = /^[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0982-\u0983\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0B02-\u0B03\u0B3E\u0B40\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82-\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82-\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2-\u0DF3\u0F3E-\u0F3F\u0F7F\u102B-\u102C\u1031\u1038\u103B-\u103C\u1056-\u1057\u1062-\u1064\u1067-\u106D\u1083-\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7-\u17C8\u1923-\u1926\u1929-\u192B\u1930-\u1931\u1933-\u1938\u1A19-\u1A1A\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B82\u1BA1\u1BA6-\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1C24-\u1C2B\u1C34-\u1C35\u1CE1\u1CF2-\u1CF3\u302E-\u302F\uA823-\uA824\uA827\uA880-\uA881\uA8B4-\uA8C3\uA952-\uA953\uA983\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uAA2F-\uAA30\uAA33-\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE-\uAAEF\uAAF5\uABE3-\uABE4\uABE6-\uABE7\uABE9-\uABEA\uABEC]/, peg$c155 = peg$classExpectation([
      "ः",
      "ऻ",
      [
        "ा",
        "ी"
      ],
      [
        "ॉ",
        "ौ"
      ],
      [
        "ॎ",
        "ॏ"
      ],
      [
        "ং",
        "ঃ"
      ],
      [
        "া",
        "ী"
      ],
      [
        "ে",
        "ৈ"
      ],
      [
        "ো",
        "ৌ"
      ],
      "ৗ",
      "ਃ",
      [
        "ਾ",
        "ੀ"
      ],
      "ઃ",
      [
        "ા",
        "ી"
      ],
      "ૉ",
      [
        "ો",
        "ૌ"
      ],
      [
        "ଂ",
        "ଃ"
      ],
      "ା",
      "ୀ",
      [
        "େ",
        "ୈ"
      ],
      [
        "ୋ",
        "ୌ"
      ],
      "ୗ",
      [
        "ா",
        "ி"
      ],
      [
        "ு",
        "ூ"
      ],
      [
        "ெ",
        "ை"
      ],
      [
        "ொ",
        "ௌ"
      ],
      "ௗ",
      [
        "ఁ",
        "ః"
      ],
      [
        "ు",
        "ౄ"
      ],
      [
        "ಂ",
        "ಃ"
      ],
      "ಾ",
      [
        "ೀ",
        "ೄ"
      ],
      [
        "ೇ",
        "ೈ"
      ],
      [
        "ೊ",
        "ೋ"
      ],
      [
        "ೕ",
        "ೖ"
      ],
      [
        "ം",
        "ഃ"
      ],
      [
        "ാ",
        "ീ"
      ],
      [
        "െ",
        "ൈ"
      ],
      [
        "ൊ",
        "ൌ"
      ],
      "ൗ",
      [
        "ං",
        "ඃ"
      ],
      [
        "ා",
        "ෑ"
      ],
      [
        "ෘ",
        "ෟ"
      ],
      [
        "ෲ",
        "ෳ"
      ],
      [
        "༾",
        "༿"
      ],
      "ཿ",
      [
        "ါ",
        "ာ"
      ],
      "ေ",
      "း",
      [
        "ျ",
        "ြ"
      ],
      [
        "ၖ",
        "ၗ"
      ],
      [
        "ၢ",
        "ၤ"
      ],
      [
        "ၧ",
        "ၭ"
      ],
      [
        "ႃ",
        "ႄ"
      ],
      [
        "ႇ",
        "ႌ"
      ],
      "ႏ",
      [
        "ႚ",
        "ႜ"
      ],
      "ា",
      [
        "ើ",
        "ៅ"
      ],
      [
        "ះ",
        "ៈ"
      ],
      [
        "ᤣ",
        "ᤦ"
      ],
      [
        "ᤩ",
        "ᤫ"
      ],
      [
        "ᤰ",
        "ᤱ"
      ],
      [
        "ᤳ",
        "ᤸ"
      ],
      [
        "ᨙ",
        "ᨚ"
      ],
      "ᩕ",
      "ᩗ",
      "ᩡ",
      [
        "ᩣ",
        "ᩤ"
      ],
      [
        "ᩭ",
        "ᩲ"
      ],
      "ᬄ",
      "ᬵ",
      "ᬻ",
      [
        "ᬽ",
        "ᭁ"
      ],
      [
        "ᭃ",
        "᭄"
      ],
      "ᮂ",
      "ᮡ",
      [
        "ᮦ",
        "ᮧ"
      ],
      "᮪",
      "ᯧ",
      [
        "ᯪ",
        "ᯬ"
      ],
      "ᯮ",
      [
        "᯲",
        "᯳"
      ],
      [
        "ᰤ",
        "ᰫ"
      ],
      [
        "ᰴ",
        "ᰵ"
      ],
      "᳡",
      [
        "ᳲ",
        "ᳳ"
      ],
      [
        "〮",
        "〯"
      ],
      [
        "ꠣ",
        "ꠤ"
      ],
      "ꠧ",
      [
        "ꢀ",
        "ꢁ"
      ],
      [
        "ꢴ",
        "ꣃ"
      ],
      [
        "ꥒ",
        "꥓"
      ],
      "ꦃ",
      [
        "ꦴ",
        "ꦵ"
      ],
      [
        "ꦺ",
        "ꦻ"
      ],
      [
        "ꦽ",
        "꧀"
      ],
      [
        "ꨯ",
        "ꨰ"
      ],
      [
        "ꨳ",
        "ꨴ"
      ],
      "ꩍ",
      "ꩻ",
      "ꩽ",
      "ꫫ",
      [
        "ꫮ",
        "ꫯ"
      ],
      "ꫵ",
      [
        "ꯣ",
        "ꯤ"
      ],
      [
        "ꯦ",
        "ꯧ"
      ],
      [
        "ꯩ",
        "ꯪ"
      ],
      "꯬"
    ], false, false), peg$c156 = /^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62-\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC-\u0CCD\u0CE2-\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62-\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099-\u309A\uA66F\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/, peg$c157 = peg$classExpectation([
      [
        "̀",
        "ͯ"
      ],
      [
        "҃",
        "҇"
      ],
      [
        "֑",
        "ֽ"
      ],
      "ֿ",
      [
        "ׁ",
        "ׂ"
      ],
      [
        "ׄ",
        "ׅ"
      ],
      "ׇ",
      [
        "ؐ",
        "ؚ"
      ],
      [
        "ً",
        "ٟ"
      ],
      "ٰ",
      [
        "ۖ",
        "ۜ"
      ],
      [
        "۟",
        "ۤ"
      ],
      [
        "ۧ",
        "ۨ"
      ],
      [
        "۪",
        "ۭ"
      ],
      "ܑ",
      [
        "ܰ",
        "݊"
      ],
      [
        "ަ",
        "ް"
      ],
      [
        "߫",
        "߳"
      ],
      [
        "ࠖ",
        "࠙"
      ],
      [
        "ࠛ",
        "ࠣ"
      ],
      [
        "ࠥ",
        "ࠧ"
      ],
      [
        "ࠩ",
        "࠭"
      ],
      [
        "࡙",
        "࡛"
      ],
      [
        "ࣣ",
        "ं"
      ],
      "ऺ",
      "़",
      [
        "ु",
        "ै"
      ],
      "्",
      [
        "॑",
        "ॗ"
      ],
      [
        "ॢ",
        "ॣ"
      ],
      "ঁ",
      "়",
      [
        "ু",
        "ৄ"
      ],
      "্",
      [
        "ৢ",
        "ৣ"
      ],
      [
        "ਁ",
        "ਂ"
      ],
      "਼",
      [
        "ੁ",
        "ੂ"
      ],
      [
        "ੇ",
        "ੈ"
      ],
      [
        "ੋ",
        "੍"
      ],
      "ੑ",
      [
        "ੰ",
        "ੱ"
      ],
      "ੵ",
      [
        "ઁ",
        "ં"
      ],
      "઼",
      [
        "ુ",
        "ૅ"
      ],
      [
        "ે",
        "ૈ"
      ],
      "્",
      [
        "ૢ",
        "ૣ"
      ],
      "ଁ",
      "଼",
      "ି",
      [
        "ୁ",
        "ୄ"
      ],
      "୍",
      "ୖ",
      [
        "ୢ",
        "ୣ"
      ],
      "ஂ",
      "ீ",
      "்",
      "ఀ",
      [
        "ా",
        "ీ"
      ],
      [
        "ె",
        "ై"
      ],
      [
        "ొ",
        "్"
      ],
      [
        "ౕ",
        "ౖ"
      ],
      [
        "ౢ",
        "ౣ"
      ],
      "ಁ",
      "಼",
      "ಿ",
      "ೆ",
      [
        "ೌ",
        "್"
      ],
      [
        "ೢ",
        "ೣ"
      ],
      "ഁ",
      [
        "ു",
        "ൄ"
      ],
      "്",
      [
        "ൢ",
        "ൣ"
      ],
      "්",
      [
        "ි",
        "ු"
      ],
      "ූ",
      "ั",
      [
        "ิ",
        "ฺ"
      ],
      [
        "็",
        "๎"
      ],
      "ັ",
      [
        "ິ",
        "ູ"
      ],
      [
        "ົ",
        "ຼ"
      ],
      [
        "່",
        "ໍ"
      ],
      [
        "༘",
        "༙"
      ],
      "༵",
      "༷",
      "༹",
      [
        "ཱ",
        "ཾ"
      ],
      [
        "ྀ",
        "྄"
      ],
      [
        "྆",
        "྇"
      ],
      [
        "ྍ",
        "ྗ"
      ],
      [
        "ྙ",
        "ྼ"
      ],
      "࿆",
      [
        "ိ",
        "ူ"
      ],
      [
        "ဲ",
        "့"
      ],
      [
        "္",
        "်"
      ],
      [
        "ွ",
        "ှ"
      ],
      [
        "ၘ",
        "ၙ"
      ],
      [
        "ၞ",
        "ၠ"
      ],
      [
        "ၱ",
        "ၴ"
      ],
      "ႂ",
      [
        "ႅ",
        "ႆ"
      ],
      "ႍ",
      "ႝ",
      [
        "፝",
        "፟"
      ],
      [
        "ᜒ",
        "᜔"
      ],
      [
        "ᜲ",
        "᜴"
      ],
      [
        "ᝒ",
        "ᝓ"
      ],
      [
        "ᝲ",
        "ᝳ"
      ],
      [
        "឴",
        "឵"
      ],
      [
        "ិ",
        "ួ"
      ],
      "ំ",
      [
        "៉",
        "៓"
      ],
      "៝",
      [
        "᠋",
        "᠍"
      ],
      "ᢩ",
      [
        "ᤠ",
        "ᤢ"
      ],
      [
        "ᤧ",
        "ᤨ"
      ],
      "ᤲ",
      [
        "᤹",
        "᤻"
      ],
      [
        "ᨗ",
        "ᨘ"
      ],
      "ᨛ",
      "ᩖ",
      [
        "ᩘ",
        "ᩞ"
      ],
      "᩠",
      "ᩢ",
      [
        "ᩥ",
        "ᩬ"
      ],
      [
        "ᩳ",
        "᩼"
      ],
      "᩿",
      [
        "᪰",
        "᪽"
      ],
      [
        "ᬀ",
        "ᬃ"
      ],
      "᬴",
      [
        "ᬶ",
        "ᬺ"
      ],
      "ᬼ",
      "ᭂ",
      [
        "᭫",
        "᭳"
      ],
      [
        "ᮀ",
        "ᮁ"
      ],
      [
        "ᮢ",
        "ᮥ"
      ],
      [
        "ᮨ",
        "ᮩ"
      ],
      [
        "᮫",
        "ᮭ"
      ],
      "᯦",
      [
        "ᯨ",
        "ᯩ"
      ],
      "ᯭ",
      [
        "ᯯ",
        "ᯱ"
      ],
      [
        "ᰬ",
        "ᰳ"
      ],
      [
        "ᰶ",
        "᰷"
      ],
      [
        "᳐",
        "᳒"
      ],
      [
        "᳔",
        "᳠"
      ],
      [
        "᳢",
        "᳨"
      ],
      "᳭",
      "᳴",
      [
        "᳸",
        "᳹"
      ],
      [
        "᷀",
        "᷵"
      ],
      [
        "᷼",
        "᷿"
      ],
      [
        "⃐",
        "⃜"
      ],
      "⃡",
      [
        "⃥",
        "⃰"
      ],
      [
        "⳯",
        "⳱"
      ],
      "⵿",
      [
        "ⷠ",
        "ⷿ"
      ],
      [
        "〪",
        "〭"
      ],
      [
        "゙",
        "゚"
      ],
      "꙯",
      [
        "ꙴ",
        "꙽"
      ],
      [
        "ꚞ",
        "ꚟ"
      ],
      [
        "꛰",
        "꛱"
      ],
      "ꠂ",
      "꠆",
      "ꠋ",
      [
        "ꠥ",
        "ꠦ"
      ],
      "꣄",
      [
        "꣠",
        "꣱"
      ],
      [
        "ꤦ",
        "꤭"
      ],
      [
        "ꥇ",
        "ꥑ"
      ],
      [
        "ꦀ",
        "ꦂ"
      ],
      "꦳",
      [
        "ꦶ",
        "ꦹ"
      ],
      "ꦼ",
      "ꧥ",
      [
        "ꨩ",
        "ꨮ"
      ],
      [
        "ꨱ",
        "ꨲ"
      ],
      [
        "ꨵ",
        "ꨶ"
      ],
      "ꩃ",
      "ꩌ",
      "ꩼ",
      "ꪰ",
      [
        "ꪲ",
        "ꪴ"
      ],
      [
        "ꪷ",
        "ꪸ"
      ],
      [
        "ꪾ",
        "꪿"
      ],
      "꫁",
      [
        "ꫬ",
        "ꫭ"
      ],
      "꫶",
      "ꯥ",
      "ꯨ",
      "꯭",
      "ﬞ",
      [
        "︀",
        "️"
      ],
      [
        "︠",
        "︯"
      ]
    ], false, false), peg$c158 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/, peg$c159 = peg$classExpectation([
      [
        "0",
        "9"
      ],
      [
        "٠",
        "٩"
      ],
      [
        "۰",
        "۹"
      ],
      [
        "߀",
        "߉"
      ],
      [
        "०",
        "९"
      ],
      [
        "০",
        "৯"
      ],
      [
        "੦",
        "੯"
      ],
      [
        "૦",
        "૯"
      ],
      [
        "୦",
        "୯"
      ],
      [
        "௦",
        "௯"
      ],
      [
        "౦",
        "౯"
      ],
      [
        "೦",
        "೯"
      ],
      [
        "൦",
        "൯"
      ],
      [
        "෦",
        "෯"
      ],
      [
        "๐",
        "๙"
      ],
      [
        "໐",
        "໙"
      ],
      [
        "༠",
        "༩"
      ],
      [
        "၀",
        "၉"
      ],
      [
        "႐",
        "႙"
      ],
      [
        "០",
        "៩"
      ],
      [
        "᠐",
        "᠙"
      ],
      [
        "᥆",
        "᥏"
      ],
      [
        "᧐",
        "᧙"
      ],
      [
        "᪀",
        "᪉"
      ],
      [
        "᪐",
        "᪙"
      ],
      [
        "᭐",
        "᭙"
      ],
      [
        "᮰",
        "᮹"
      ],
      [
        "᱀",
        "᱉"
      ],
      [
        "᱐",
        "᱙"
      ],
      [
        "꘠",
        "꘩"
      ],
      [
        "꣐",
        "꣙"
      ],
      [
        "꤀",
        "꤉"
      ],
      [
        "꧐",
        "꧙"
      ],
      [
        "꧰",
        "꧹"
      ],
      [
        "꩐",
        "꩙"
      ],
      [
        "꯰",
        "꯹"
      ],
      [
        "０",
        "９"
      ]
    ], false, false), peg$c160 = /^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/, peg$c161 = peg$classExpectation([
      [
        "ᛮ",
        "ᛰ"
      ],
      [
        "Ⅰ",
        "ↂ"
      ],
      [
        "ↅ",
        "ↈ"
      ],
      "〇",
      [
        "〡",
        "〩"
      ],
      [
        "〸",
        "〺"
      ],
      [
        "ꛦ",
        "ꛯ"
      ]
    ], false, false), peg$c162 = /^[_\u203F-\u2040\u2054\uFE33-\uFE34\uFE4D-\uFE4F\uFF3F]/, peg$c163 = peg$classExpectation([
      "_",
      [
        "‿",
        "⁀"
      ],
      "⁔",
      [
        "︳",
        "︴"
      ],
      [
        "﹍",
        "﹏"
      ],
      "＿"
    ], false, false), peg$c164 = /^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/, peg$c165 = peg$classExpectation([
      " ",
      "\xA0",
      "\u1680",
      [
        "\u2000",
        "\u200A"
      ],
      "\u202F",
      "\u205F",
      "\u3000"
    ], false, false), peg$c166 = "break", peg$c167 = peg$literalExpectation("break", false), peg$c168 = "case", peg$c169 = peg$literalExpectation("case", false), peg$c170 = "catch", peg$c171 = peg$literalExpectation("catch", false), peg$c172 = "class", peg$c173 = peg$literalExpectation("class", false), peg$c174 = "const", peg$c175 = peg$literalExpectation("const", false), peg$c176 = "continue", peg$c177 = peg$literalExpectation("continue", false), peg$c178 = "debugger", peg$c179 = peg$literalExpectation("debugger", false), peg$c180 = "default", peg$c181 = peg$literalExpectation("default", false), peg$c182 = "delete", peg$c183 = peg$literalExpectation("delete", false), peg$c184 = "do", peg$c185 = peg$literalExpectation("do", false), peg$c186 = "else", peg$c187 = peg$literalExpectation("else", false), peg$c188 = "enum", peg$c189 = peg$literalExpectation("enum", false), peg$c190 = "export", peg$c191 = peg$literalExpectation("export", false), peg$c192 = "extends", peg$c193 = peg$literalExpectation("extends", false), peg$c194 = "false", peg$c195 = peg$literalExpectation("false", false), peg$c196 = "finally", peg$c197 = peg$literalExpectation("finally", false), peg$c198 = "for", peg$c199 = peg$literalExpectation("for", false), peg$c200 = "function", peg$c201 = peg$literalExpectation("function", false), peg$c202 = "if", peg$c203 = peg$literalExpectation("if", false), peg$c204 = "import", peg$c205 = peg$literalExpectation("import", false), peg$c206 = "instanceof", peg$c207 = peg$literalExpectation("instanceof", false), peg$c208 = "in", peg$c209 = peg$literalExpectation("in", false), peg$c210 = "new", peg$c211 = peg$literalExpectation("new", false), peg$c212 = "null", peg$c213 = peg$literalExpectation("null", false), peg$c214 = "return", peg$c215 = peg$literalExpectation("return", false), peg$c216 = "super", peg$c217 = peg$literalExpectation("super", false), peg$c218 = "switch", peg$c219 = peg$literalExpectation("switch", false), peg$c220 = "this", peg$c221 = peg$literalExpectation("this", false), peg$c222 = "throw", peg$c223 = peg$literalExpectation("throw", false), peg$c224 = "true", peg$c225 = peg$literalExpectation("true", false), peg$c226 = "try", peg$c227 = peg$literalExpectation("try", false), peg$c228 = "typeof", peg$c229 = peg$literalExpectation("typeof", false), peg$c230 = "var", peg$c231 = peg$literalExpectation("var", false), peg$c232 = "void", peg$c233 = peg$literalExpectation("void", false), peg$c234 = "while", peg$c235 = peg$literalExpectation("while", false), peg$c236 = "with", peg$c237 = peg$literalExpectation("with", false), peg$c238 = ";", peg$c239 = peg$literalExpectation(";", false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{
        line: 1,
        column: 1
      }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }
  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location);
  }
  function peg$literalExpectation(text, ignoreCase) {
    return {
      type: "literal",
      text: text,
      ignoreCase: ignoreCase
    };
  }
  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  }
  function peg$anyExpectation() {
    return { type: "any" };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }
  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;
    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }
      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };
      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected);
  }
  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }
  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }
  function peg$parseGrammar() {
    var s0, s1, s2, s3, s4, s5, s6;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseInitializer();
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s3 = [
            s3,
            s4
          ];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$parseRule();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s5 = [
              s5,
              s6
            ];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseRule();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s5 = [
                  s5,
                  s6
                ];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseInitializer() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseCodeBlock();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOS();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseRule() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parseIdentifierName();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseStringLiteral();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s4 = peg$c2;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseChoiceExpression();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseEOS();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c4(s1, s3, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseChoiceExpression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parseActionExpression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s5 = peg$c5;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseActionExpression();
            if (s7 !== peg$FAILED) {
              s4 = [
                s4,
                s5,
                s6,
                s7
              ];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s5 = peg$c5;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseActionExpression();
              if (s7 !== peg$FAILED) {
                s4 = [
                  s4,
                  s5,
                  s6,
                  s7
                ];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseActionExpression() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parseSequenceExpression();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseCodeBlock();
        if (s4 !== peg$FAILED) {
          s3 = [
            s3,
            s4
          ];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSequenceExpression() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseLabeledExpression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseLabeledExpression();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseLabeledExpression();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseLabeledExpression() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseIdentifier();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsePrefixedExpression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c12(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsePrefixedExpression();
    }
    return s0;
  }
  function peg$parsePrefixedExpression() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parsePrefixedOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseSuffixedExpression();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c13(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseSuffixedExpression();
    }
    return s0;
  }
  function peg$parsePrefixedOperator() {
    var s0;
    if (input.charCodeAt(peg$currPos) === 36) {
      s0 = peg$c14;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c15);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 38) {
        s0 = peg$c16;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c17);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 33) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }
      }
    }
    return s0;
  }
  function peg$parseSuffixedExpression() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parsePrimaryExpression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseSuffixedOperator();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c20(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsePrimaryExpression();
    }
    return s0;
  }
  function peg$parseSuffixedOperator() {
    var s0;
    if (input.charCodeAt(peg$currPos) === 63) {
      s0 = peg$c21;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c22);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 42) {
        s0 = peg$c23;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c24);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c25;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }
      }
    }
    return s0;
  }
  function peg$parsePrimaryExpression() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$parseLiteralMatcher();
    if (s0 === peg$FAILED) {
      s0 = peg$parseCharacterClassMatcher();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAnyMatcher();
        if (s0 === peg$FAILED) {
          s0 = peg$parseRuleReferenceExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSemanticPredicateExpression();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c27;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse__();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseChoiceExpression();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse__();
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s5 = peg$c29;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c30);
                        }
                      }
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseRuleReferenceExpression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parseIdentifierName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        s6 = peg$parseStringLiteral();
        if (s6 !== peg$FAILED) {
          s7 = peg$parse__();
          if (s7 !== peg$FAILED) {
            s6 = [
              s6,
              s7
            ];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        if (s5 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s6 = peg$c2;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }
          if (s6 !== peg$FAILED) {
            s4 = [
              s4,
              s5,
              s6
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c32(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSemanticPredicateExpression() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parseSemanticPredicateOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseCodeBlock();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSemanticPredicateOperator() {
    var s0;
    if (input.charCodeAt(peg$currPos) === 38) {
      s0 = peg$c16;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c17);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 33) {
        s0 = peg$c18;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c19);
        }
      }
    }
    return s0;
  }
  function peg$parseSourceCharacter() {
    var s0;
    if (input.length > peg$currPos) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c34);
      }
    }
    return s0;
  }
  function peg$parseWhiteSpace() {
    var s0;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 9) {
      s0 = peg$c36;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c37);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 11) {
        s0 = peg$c38;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c39);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 12) {
          s0 = peg$c40;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s0 = peg$c42;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 160) {
              s0 = peg$c44;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 65279) {
                s0 = peg$c46;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c47);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseZs();
              }
            }
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c35);
      }
    }
    return s0;
  }
  function peg$parseLineTerminator() {
    var s0;
    if (peg$c48.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c49);
      }
    }
    return s0;
  }
  function peg$parseLineTerminatorSequence() {
    var s0;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 10) {
      s0 = peg$c51;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c52);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c53) {
        s0 = peg$c53;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c54);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c55;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c56);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 8232) {
            s0 = peg$c57;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8233) {
              s0 = peg$c59;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c60);
              }
            }
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c50);
      }
    }
    return s0;
  }
  function peg$parseComment() {
    var s0;
    peg$silentFails++;
    s0 = peg$parseMultiLineComment();
    if (s0 === peg$FAILED) {
      s0 = peg$parseSingleLineComment();
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c61);
      }
    }
    return s0;
  }
  function peg$parseMultiLineComment() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c62) {
      s1 = peg$c62;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c63);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c64) {
        s5 = peg$c64;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c65);
        }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSourceCharacter();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c64) {
          s5 = peg$c64;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c64) {
          s3 = peg$c64;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s3 !== peg$FAILED) {
          s1 = [
            s1,
            s2,
            s3
          ];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseMultiLineCommentNoLineTerminator() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c62) {
      s1 = peg$c62;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c63);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c64) {
        s5 = peg$c64;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c65);
        }
      }
      if (s5 === peg$FAILED) {
        s5 = peg$parseLineTerminator();
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSourceCharacter();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c64) {
          s5 = peg$c64;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s5 === peg$FAILED) {
          s5 = peg$parseLineTerminator();
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c64) {
          s3 = peg$c64;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s3 !== peg$FAILED) {
          s1 = [
            s1,
            s2,
            s3
          ];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSingleLineComment() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c66) {
      s1 = peg$c66;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c67);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parseLineTerminator();
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSourceCharacter();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseIdentifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$parseReservedWord();
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseIdentifierName();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c68(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseIdentifierName() {
    var s0, s1, s2, s3;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseIdentifierStart();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseIdentifierPart();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseIdentifierPart();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c70(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c69);
      }
    }
    return s0;
  }
  function peg$parseIdentifierStart() {
    var s0, s1, s2;
    s0 = peg$parseUnicodeLetter();
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 36) {
        s0 = peg$c14;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c15);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 95) {
          s0 = peg$c71;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c73;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseUnicodeEscapeSequence();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c75(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }
    return s0;
  }
  function peg$parseIdentifierPart() {
    var s0;
    s0 = peg$parseIdentifierStart();
    if (s0 === peg$FAILED) {
      s0 = peg$parseUnicodeCombiningMark();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNd();
        if (s0 === peg$FAILED) {
          s0 = peg$parsePc();
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8204) {
              s0 = peg$c76;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c77);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8205) {
                s0 = peg$c78;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c79);
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseUnicodeLetter() {
    var s0;
    s0 = peg$parseLu();
    if (s0 === peg$FAILED) {
      s0 = peg$parseLl();
      if (s0 === peg$FAILED) {
        s0 = peg$parseLt();
        if (s0 === peg$FAILED) {
          s0 = peg$parseLm();
          if (s0 === peg$FAILED) {
            s0 = peg$parseLo();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNl();
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseUnicodeCombiningMark() {
    var s0;
    s0 = peg$parseMn();
    if (s0 === peg$FAILED) {
      s0 = peg$parseMc();
    }
    return s0;
  }
  function peg$parseReservedWord() {
    var s0;
    s0 = peg$parseKeyword();
    if (s0 === peg$FAILED) {
      s0 = peg$parseFutureReservedWord();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNullToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseBooleanLiteral();
        }
      }
    }
    return s0;
  }
  function peg$parseKeyword() {
    var s0;
    s0 = peg$parseBreakToken();
    if (s0 === peg$FAILED) {
      s0 = peg$parseCaseToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseCatchToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseContinueToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseDebuggerToken();
            if (s0 === peg$FAILED) {
              s0 = peg$parseDefaultToken();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDeleteToken();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseDoToken();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseElseToken();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseFinallyToken();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseForToken();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseFunctionToken();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseIfToken();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseInstanceofToken();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseInToken();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseNewToken();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseReturnToken();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parseSwitchToken();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseThisToken();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseThrowToken();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseTryToken();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$parseTypeofToken();
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$parseVarToken();
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$parseVoidToken();
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$parseWhileToken();
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$parseWithToken();
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseFutureReservedWord() {
    var s0;
    s0 = peg$parseClassToken();
    if (s0 === peg$FAILED) {
      s0 = peg$parseConstToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseEnumToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseExportToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseExtendsToken();
            if (s0 === peg$FAILED) {
              s0 = peg$parseImportToken();
              if (s0 === peg$FAILED) {
                s0 = peg$parseSuperToken();
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseBooleanLiteral() {
    var s0;
    s0 = peg$parseTrueToken();
    if (s0 === peg$FAILED) {
      s0 = peg$parseFalseToken();
    }
    return s0;
  }
  function peg$parseLiteralMatcher() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseStringLiteral();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 105) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c82);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c83(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c80);
      }
    }
    return s0;
  }
  function peg$parseStringLiteral() {
    var s0, s1, s2, s3;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c85;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c86);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDoubleStringCharacter();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDoubleStringCharacter();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c85;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c87(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c88;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c89);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseSingleStringCharacter();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseSingleStringCharacter();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c88;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c89);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c84);
      }
    }
    return s0;
  }
  function peg$parseDoubleStringCharacter() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 34) {
      s2 = peg$c85;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c86);
      }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c73;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminator();
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSourceCharacter();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapeSequence();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c75(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLineContinuation();
      }
    }
    return s0;
  }
  function peg$parseSingleStringCharacter() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 39) {
      s2 = peg$c88;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c89);
      }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c73;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminator();
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSourceCharacter();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapeSequence();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c75(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLineContinuation();
      }
    }
    return s0;
  }
  function peg$parseCharacterClassMatcher() {
    var s0, s1, s2, s3, s4, s5;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c92;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c93);
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 94) {
        s2 = peg$c94;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c95);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseClassCharacterRange();
        if (s4 === peg$FAILED) {
          s4 = peg$parseClassCharacter();
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseClassCharacterRange();
          if (s4 === peg$FAILED) {
            s4 = peg$parseClassCharacter();
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s4 = peg$c96;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c97);
            }
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 105) {
              s5 = peg$c81;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c82);
              }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c98(s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c91);
      }
    }
    return s0;
  }
  function peg$parseClassCharacterRange() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parseClassCharacter();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c99;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c100);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseClassCharacter();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c101(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseClassCharacter() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 93) {
      s2 = peg$c96;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c97);
      }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c73;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminator();
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSourceCharacter();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapeSequence();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c75(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLineContinuation();
      }
    }
    return s0;
  }
  function peg$parseLineContinuation() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c73;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c74);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseLineTerminatorSequence();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c102();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseEscapeSequence() {
    var s0, s1, s2, s3;
    s0 = peg$parseCharacterEscapeSequence();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 48) {
        s1 = peg$c103;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c104);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseDecimalDigit();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c105();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseHexEscapeSequence();
        if (s0 === peg$FAILED) {
          s0 = peg$parseUnicodeEscapeSequence();
        }
      }
    }
    return s0;
  }
  function peg$parseCharacterEscapeSequence() {
    var s0;
    s0 = peg$parseSingleEscapeCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNonEscapeCharacter();
    }
    return s0;
  }
  function peg$parseSingleEscapeCharacter() {
    var s0, s1;
    if (input.charCodeAt(peg$currPos) === 39) {
      s0 = peg$c88;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c89);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c85;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c86);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s0 = peg$c73;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 98) {
            s1 = peg$c106;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c107);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c108();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 102) {
              s1 = peg$c109;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c110);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c111();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 110) {
                s1 = peg$c112;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c113);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c114();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s1 = peg$c115;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c116);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c117();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 116) {
                    s1 = peg$c118;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c119);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c120();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 118) {
                      s1 = peg$c121;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c122);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c123();
                    }
                    s0 = s1;
                  }
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseNonEscapeCharacter() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$parseEscapeCharacter();
    if (s2 === peg$FAILED) {
      s2 = peg$parseLineTerminator();
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSourceCharacter();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseEscapeCharacter() {
    var s0;
    s0 = peg$parseSingleEscapeCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parseDecimalDigit();
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 120) {
          s0 = peg$c124;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 117) {
            s0 = peg$c126;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c127);
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseHexEscapeSequence() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 120) {
      s1 = peg$c124;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c125);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parseHexDigit();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseHexDigit();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c128(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseUnicodeEscapeSequence() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 117) {
      s1 = peg$c126;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c127);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parseHexDigit();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseHexDigit();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseHexDigit();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseHexDigit();
            if (s7 !== peg$FAILED) {
              s4 = [
                s4,
                s5,
                s6,
                s7
              ];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c128(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDecimalDigit() {
    var s0;
    if (peg$c129.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c130);
      }
    }
    return s0;
  }
  function peg$parseHexDigit() {
    var s0;
    if (peg$c131.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c132);
      }
    }
    return s0;
  }
  function peg$parseAnyMatcher() {
    var s0, s1;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c133;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c134);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c135();
    }
    s0 = s1;
    return s0;
  }
  function peg$parseCodeBlock() {
    var s0, s1, s2, s3;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c137;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c138);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCode();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c139;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c140);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c141(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c136);
      }
    }
    return s0;
  }
  function peg$parseCode() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = [];
    s2 = [];
    s3 = peg$currPos;
    s4 = peg$currPos;
    peg$silentFails++;
    if (peg$c142.test(input.charAt(peg$currPos))) {
      s5 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s5 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c143);
      }
    }
    peg$silentFails--;
    if (s5 === peg$FAILED) {
      s4 = void 0;
    } else {
      peg$currPos = s4;
      s4 = peg$FAILED;
    }
    if (s4 !== peg$FAILED) {
      s5 = peg$parseSourceCharacter();
      if (s5 !== peg$FAILED) {
        s4 = [
          s4,
          s5
        ];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$c142.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c143);
          }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [
              s4,
              s5
            ];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
    } else {
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s3 = peg$c137;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c138);
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseCode();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c139;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = [
              s3,
              s4,
              s5
            ];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (peg$c142.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c143);
        }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSourceCharacter();
        if (s5 !== peg$FAILED) {
          s4 = [
            s4,
            s5
          ];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (peg$c142.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c143);
            }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [
                s4,
                s5
              ];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s3 = peg$c137;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c138);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCode();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c139;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c140);
              }
            }
            if (s5 !== peg$FAILED) {
              s3 = [
                s3,
                s4,
                s5
              ];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    return s0;
  }
  function peg$parseLl() {
    var s0;
    if (peg$c144.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c145);
      }
    }
    return s0;
  }
  function peg$parseLm() {
    var s0;
    if (peg$c146.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c147);
      }
    }
    return s0;
  }
  function peg$parseLo() {
    var s0;
    if (peg$c148.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c149);
      }
    }
    return s0;
  }
  function peg$parseLt() {
    var s0;
    if (peg$c150.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c151);
      }
    }
    return s0;
  }
  function peg$parseLu() {
    var s0;
    if (peg$c152.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c153);
      }
    }
    return s0;
  }
  function peg$parseMc() {
    var s0;
    if (peg$c154.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c155);
      }
    }
    return s0;
  }
  function peg$parseMn() {
    var s0;
    if (peg$c156.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c157);
      }
    }
    return s0;
  }
  function peg$parseNd() {
    var s0;
    if (peg$c158.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c159);
      }
    }
    return s0;
  }
  function peg$parseNl() {
    var s0;
    if (peg$c160.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c161);
      }
    }
    return s0;
  }
  function peg$parsePc() {
    var s0;
    if (peg$c162.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c163);
      }
    }
    return s0;
  }
  function peg$parseZs() {
    var s0;
    if (peg$c164.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c165);
      }
    }
    return s0;
  }
  function peg$parseBreakToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c166) {
      s1 = peg$c166;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c167);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseCaseToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c168) {
      s1 = peg$c168;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c169);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseCatchToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c170) {
      s1 = peg$c170;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c171);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseClassToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c172) {
      s1 = peg$c172;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c173);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseConstToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c174) {
      s1 = peg$c174;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c175);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseContinueToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8) === peg$c176) {
      s1 = peg$c176;
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c177);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDebuggerToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8) === peg$c178) {
      s1 = peg$c178;
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c179);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDefaultToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c180) {
      s1 = peg$c180;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c181);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDeleteToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c182) {
      s1 = peg$c182;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c183);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDoToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c184) {
      s1 = peg$c184;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c185);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseElseToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c186) {
      s1 = peg$c186;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c187);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseEnumToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c188) {
      s1 = peg$c188;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c189);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseExportToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c190) {
      s1 = peg$c190;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c191);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseExtendsToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c192) {
      s1 = peg$c192;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c193);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFalseToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c194) {
      s1 = peg$c194;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c195);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFinallyToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c196) {
      s1 = peg$c196;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c197);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseForToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c198) {
      s1 = peg$c198;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c199);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFunctionToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8) === peg$c200) {
      s1 = peg$c200;
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c201);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseIfToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c202) {
      s1 = peg$c202;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c203);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseImportToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c204) {
      s1 = peg$c204;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c205);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseInstanceofToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10) === peg$c206) {
      s1 = peg$c206;
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c207);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseInToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c208) {
      s1 = peg$c208;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c209);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseNewToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c210) {
      s1 = peg$c210;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c211);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseNullToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c212) {
      s1 = peg$c212;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c213);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseReturnToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c214) {
      s1 = peg$c214;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c215);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSuperToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c216) {
      s1 = peg$c216;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c217);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSwitchToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c218) {
      s1 = peg$c218;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c219);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseThisToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c220) {
      s1 = peg$c220;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c221);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseThrowToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c222) {
      s1 = peg$c222;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c223);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseTrueToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c224) {
      s1 = peg$c224;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c225);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseTryToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c226) {
      s1 = peg$c226;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c227);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseTypeofToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c228) {
      s1 = peg$c228;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c229);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseVarToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c230) {
      s1 = peg$c230;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c231);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseVoidToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c232) {
      s1 = peg$c232;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c233);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseWhileToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c234) {
      s1 = peg$c234;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c235);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseWithToken() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c236) {
      s1 = peg$c236;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c237);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseIdentifierPart();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parse__() {
    var s0, s1;
    s0 = [];
    s1 = peg$parseWhiteSpace();
    if (s1 === peg$FAILED) {
      s1 = peg$parseLineTerminatorSequence();
      if (s1 === peg$FAILED) {
        s1 = peg$parseComment();
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseLineTerminatorSequence();
        if (s1 === peg$FAILED) {
          s1 = peg$parseComment();
        }
      }
    }
    return s0;
  }
  function peg$parse_() {
    var s0, s1;
    s0 = [];
    s1 = peg$parseWhiteSpace();
    if (s1 === peg$FAILED) {
      s1 = peg$parseMultiLineCommentNoLineTerminator();
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseMultiLineCommentNoLineTerminator();
      }
    }
    return s0;
  }
  function peg$parseEOS() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 59) {
        s2 = peg$c238;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c239);
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [
          s1,
          s2
        ];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSingleLineComment();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLineTerminatorSequence();
          if (s3 !== peg$FAILED) {
            s1 = [
              s1,
              s2,
              s3
            ];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse__();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEOF();
          if (s2 !== peg$FAILED) {
            s1 = [
              s1,
              s2
            ];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }
    return s0;
  }
  function peg$parseEOF() {
    var s0, s1;
    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c34);
      }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  var OPS_TO_PREFIXED_TYPES = {
    "$": "text",
    "&": "simple_and",
    "!": "simple_not"
  };
  var OPS_TO_SUFFIXED_TYPES = {
    "?": "optional",
    "*": "zero_or_more",
    "+": "one_or_more"
  };
  var OPS_TO_SEMANTIC_PREDICATE_TYPES = {
    "&": "semantic_and",
    "!": "semantic_not"
  };
  function filterEmptyStrings(array) {
    var result = [], i;
    for (i = 0; i < array.length; i++) {
      if (array[i] !== "") {
        result.push(array[i]);
      }
    }
    return result;
  }
  function extractOptional(optional, index) {
    return optional ? optional[index] : null;
  }
  function extractList(list, index) {
    var result = new Array(list.length), i;
    for (i = 0; i < list.length; i++) {
      result[i] = list[i][index];
    }
    return result;
  }
  function buildList(head, tail, index) {
    return [head].concat(extractList(tail, index));
  }
  peg$result = peg$startRuleFunction();
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
var parser = {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};

var objects$5 = objects_1, arrays$8 = arrays_1;
var visitor$8 = {
  build: function (functions) {
    function visit(node) {
      return functions[node.type].apply(null, arguments);
    }
    function visitNop() {
    }
    function visitExpression(node) {
      var extraArgs = Array.prototype.slice.call(arguments, 1);
      visit.apply(null, [node.expression].concat(extraArgs));
    }
    function visitChildren(property) {
      return function (node) {
        var extraArgs = Array.prototype.slice.call(arguments, 1);
        arrays$8.each(node[property], function (child) {
          visit.apply(null, [child].concat(extraArgs));
        });
      };
    }
    var DEFAULT_FUNCTIONS = {
      grammar: function (node) {
        var extraArgs = Array.prototype.slice.call(arguments, 1);
        if (node.initializer) {
          visit.apply(null, [node.initializer].concat(extraArgs));
        }
        arrays$8.each(node.rules, function (rule) {
          visit.apply(null, [rule].concat(extraArgs));
        });
      },
      initializer: visitNop,
      rule: visitExpression,
      named: visitExpression,
      choice: visitChildren("alternatives"),
      action: visitExpression,
      sequence: visitChildren("elements"),
      labeled: visitExpression,
      text: visitExpression,
      simple_and: visitExpression,
      simple_not: visitExpression,
      optional: visitExpression,
      zero_or_more: visitExpression,
      one_or_more: visitExpression,
      group: visitExpression,
      semantic_and: visitNop,
      semantic_not: visitNop,
      rule_ref: visitNop,
      literal: visitNop,
      "class": visitNop,
      any: visitNop
    };
    objects$5.defaults(functions, DEFAULT_FUNCTIONS);
    return visit;
  }
};
var visitor_1 = visitor$8;

var arrays$7 = arrays_1, visitor$7 = visitor_1;
var asts$5 = {
  findRule: function (ast, name) {
    return arrays$7.find(ast.rules, function (r) {
      return r.name === name;
    });
  },
  indexOfRule: function (ast, name) {
    return arrays$7.indexOf(ast.rules, function (r) {
      return r.name === name;
    });
  },
  alwaysConsumesOnSuccess: function (ast, node) {
    function consumesTrue() {
      return true;
    }
    function consumesFalse() {
      return false;
    }
    function consumesExpression(node) {
      return consumes(node.expression);
    }
    var consumes = visitor$7.build({
      rule: consumesExpression,
      named: consumesExpression,
      choice: function (node) {
        return arrays$7.every(node.alternatives, consumes);
      },
      action: consumesExpression,
      sequence: function (node) {
        return arrays$7.some(node.elements, consumes);
      },
      labeled: consumesExpression,
      text: consumesExpression,
      simple_and: consumesFalse,
      simple_not: consumesFalse,
      optional: consumesFalse,
      zero_or_more: consumesFalse,
      one_or_more: consumesExpression,
      group: consumesExpression,
      semantic_and: consumesFalse,
      semantic_not: consumesFalse,
      rule_ref: function (node) {
        return consumes(asts$5.findRule(ast, node.name));
      },
      literal: function (node) {
        return node.value !== "";
      },
      "class": consumesTrue,
      any: consumesTrue
    });
    return consumes(node);
  }
};
var asts_1 = asts$5;

var GrammarError$4 = grammarError, asts$4 = asts_1, visitor$6 = visitor_1;
function reportUndefinedRules(ast) {
  var check = visitor$6.build({
    rule_ref: function (node) {
      if (!asts$4.findRule(ast, node.name)) {
        throw new GrammarError$4("Rule \"" + node.name + "\" is not defined.", node.location);
      }
    }
  });
  check(ast);
}
var reportUndefinedRules_1 = reportUndefinedRules;

var GrammarError$3 = grammarError, visitor$5 = visitor_1;
function reportDuplicateRules(ast) {
  var rules = {};
  var check = visitor$5.build({
    rule: function (node) {
      if (rules.hasOwnProperty(node.name)) {
        throw new GrammarError$3("Rule \"" + node.name + "\" is already defined " + "at line " + rules[node.name].start.line + ", " + "column " + rules[node.name].start.column + ".", node.location);
      }
      rules[node.name] = node.location;
    }
  });
  check(ast);
}
var reportDuplicateRules_1 = reportDuplicateRules;

var GrammarError$2 = grammarError, arrays$6 = arrays_1, objects$4 = objects_1, visitor$4 = visitor_1;
function reportDuplicateLabels(ast) {
  function checkExpressionWithClonedEnv(node, env) {
    check(node.expression, objects$4.clone(env));
  }
  var check = visitor$4.build({
    rule: function (node) {
      check(node.expression, {});
    },
    choice: function (node, env) {
      arrays$6.each(node.alternatives, function (alternative) {
        check(alternative, objects$4.clone(env));
      });
    },
    action: checkExpressionWithClonedEnv,
    labeled: function (node, env) {
      if (env.hasOwnProperty(node.label)) {
        throw new GrammarError$2("Label \"" + node.label + "\" is already defined " + "at line " + env[node.label].start.line + ", " + "column " + env[node.label].start.column + ".", node.location);
      }
      check(node.expression, env);
      env[node.label] = node.location;
    },
    text: checkExpressionWithClonedEnv,
    simple_and: checkExpressionWithClonedEnv,
    simple_not: checkExpressionWithClonedEnv,
    optional: checkExpressionWithClonedEnv,
    zero_or_more: checkExpressionWithClonedEnv,
    one_or_more: checkExpressionWithClonedEnv,
    group: checkExpressionWithClonedEnv
  });
  check(ast);
}
var reportDuplicateLabels_1 = reportDuplicateLabels;

var arrays$5 = arrays_1, GrammarError$1 = grammarError, asts$3 = asts_1, visitor$3 = visitor_1;
function reportInfiniteRecursion(ast) {
  var visitedRules = [];
  var check = visitor$3.build({
    rule: function (node) {
      visitedRules.push(node.name);
      check(node.expression);
      visitedRules.pop(node.name);
    },
    sequence: function (node) {
      arrays$5.every(node.elements, function (element) {
        check(element);
        return !asts$3.alwaysConsumesOnSuccess(ast, element);
      });
    },
    rule_ref: function (node) {
      if (arrays$5.contains(visitedRules, node.name)) {
        visitedRules.push(node.name);
        throw new GrammarError$1("Possible infinite loop when parsing (left recursion: " + visitedRules.join(" -> ") + ").", node.location);
      }
      check(asts$3.findRule(ast, node.name));
    }
  });
  check(ast);
}
var reportInfiniteRecursion_1 = reportInfiniteRecursion;

var GrammarError = grammarError, asts$2 = asts_1, visitor$2 = visitor_1;
function reportInfiniteRepetition(ast) {
  var check = visitor$2.build({
    zero_or_more: function (node) {
      if (!asts$2.alwaysConsumesOnSuccess(ast, node.expression)) {
        throw new GrammarError("Possible infinite loop when parsing (repetition used with an expression that may not consume any input).", node.location);
      }
    },
    one_or_more: function (node) {
      if (!asts$2.alwaysConsumesOnSuccess(ast, node.expression)) {
        throw new GrammarError("Possible infinite loop when parsing (repetition used with an expression that may not consume any input).", node.location);
      }
    }
  });
  check(ast);
}
var reportInfiniteRepetition_1 = reportInfiniteRepetition;

var arrays$4 = arrays_1, visitor$1 = visitor_1;
function removeProxyRules(ast, options) {
  function isProxyRule(node) {
    return node.type === "rule" && node.expression.type === "rule_ref";
  }
  function replaceRuleRefs(ast, from, to) {
    var replace = visitor$1.build({
      rule_ref: function (node) {
        if (node.name === from) {
          node.name = to;
        }
      }
    });
    replace(ast);
  }
  var indices = [];
  arrays$4.each(ast.rules, function (rule, i) {
    if (isProxyRule(rule)) {
      replaceRuleRefs(ast, rule.name, rule.expression.name);
      if (!arrays$4.contains(options.allowedStartRules, rule.name)) {
        indices.push(i);
      }
    }
  });
  indices.reverse();
  arrays$4.each(indices, function (i) {
    ast.rules.splice(i, 1);
  });
}
var removeProxyRules_1 = removeProxyRules;

var opcodes = {
  PUSH: 0,
  PUSH_UNDEFINED: 1,
  PUSH_NULL: 2,
  PUSH_FAILED: 3,
  PUSH_EMPTY_ARRAY: 4,
  PUSH_CURR_POS: 5,
  POP: 6,
  POP_CURR_POS: 7,
  POP_N: 8,
  NIP: 9,
  APPEND: 10,
  WRAP: 11,
  TEXT: 12,
  IF: 13,
  IF_ERROR: 14,
  IF_NOT_ERROR: 15,
  WHILE_NOT_ERROR: 16,
  MATCH_ANY: 17,
  MATCH_STRING: 18,
  MATCH_STRING_IC: 19,
  MATCH_REGEXP: 20,
  ACCEPT_N: 21,
  ACCEPT_STRING: 22,
  FAIL: 23,
  LOAD_SAVED_POS: 24,
  UPDATE_SAVED_POS: 25,
  CALL: 26,
  RULE: 27,
  SILENT_FAILS_ON: 28,
  SILENT_FAILS_OFF: 29
};
var opcodes_1 = opcodes;

function hex(ch) {
  return ch.charCodeAt(0).toString(16).toUpperCase();
}
var js$2 = {
  stringEscape: function (s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\xFF]/g, function (ch) {
      return "\\x" + hex(ch);
    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
      return "\\u0" + hex(ch);
    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
      return "\\u" + hex(ch);
    });
  },
  regexpClassEscape: function (s) {
    return s.replace(/\\/g, "\\\\").replace(/\//g, "\\/").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\v/g, "\\x0B").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\xFF]/g, function (ch) {
      return "\\x" + hex(ch);
    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
      return "\\u0" + hex(ch);
    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
      return "\\u" + hex(ch);
    });
  }
};
var js_1 = js$2;

var arrays$3 = arrays_1, objects$3 = objects_1, asts$1 = asts_1, visitor = visitor_1, op$1 = opcodes_1, js$1 = js_1;
function generateBytecode(ast) {
  var consts = [];
  function addConst(value) {
    var index = arrays$3.indexOf(consts, value);
    return index === -1 ? consts.push(value) - 1 : index;
  }
  function addFunctionConst(params, code) {
    return addConst("function(" + params.join(", ") + ") {" + code + "}");
  }
  function buildSequence() {
    return Array.prototype.concat.apply([], arguments);
  }
  function buildCondition(condCode, thenCode, elseCode) {
    return condCode.concat([
      thenCode.length,
      elseCode.length
    ], thenCode, elseCode);
  }
  function buildLoop(condCode, bodyCode) {
    return condCode.concat([bodyCode.length], bodyCode);
  }
  function buildCall(functionIndex, delta, env, sp) {
    var params = arrays$3.map(objects$3.values(env), function (p) {
      return sp - p;
    });
    return [
      op$1.CALL,
      functionIndex,
      delta,
      params.length
    ].concat(params);
  }
  function buildSimplePredicate(expression, negative, context) {
    return buildSequence([op$1.PUSH_CURR_POS], [op$1.SILENT_FAILS_ON], generate(expression, {
      sp: context.sp + 1,
      env: objects$3.clone(context.env),
      action: null
    }), [op$1.SILENT_FAILS_OFF], buildCondition([negative ? op$1.IF_ERROR : op$1.IF_NOT_ERROR], buildSequence([op$1.POP], [negative ? op$1.POP : op$1.POP_CURR_POS], [op$1.PUSH_UNDEFINED]), buildSequence([op$1.POP], [negative ? op$1.POP_CURR_POS : op$1.POP], [op$1.PUSH_FAILED])));
  }
  function buildSemanticPredicate(code, negative, context) {
    var functionIndex = addFunctionConst(objects$3.keys(context.env), code);
    return buildSequence([op$1.UPDATE_SAVED_POS], buildCall(functionIndex, 0, context.env, context.sp), buildCondition([op$1.IF], buildSequence([op$1.POP], negative ? [op$1.PUSH_FAILED] : [op$1.PUSH_UNDEFINED]), buildSequence([op$1.POP], negative ? [op$1.PUSH_UNDEFINED] : [op$1.PUSH_FAILED])));
  }
  function buildAppendLoop(expressionCode) {
    return buildLoop([op$1.WHILE_NOT_ERROR], buildSequence([op$1.APPEND], expressionCode));
  }
  var generate = visitor.build({
    grammar: function (node) {
      arrays$3.each(node.rules, generate);
      node.consts = consts;
    },
    rule: function (node) {
      node.bytecode = generate(node.expression, {
        sp: -1,
        env: {},
        action: null
      });
    },
    named: function (node, context) {
      var nameIndex = addConst("peg$otherExpectation(\"" + js$1.stringEscape(node.name) + "\")");
      return buildSequence([op$1.SILENT_FAILS_ON], generate(node.expression, context), [op$1.SILENT_FAILS_OFF], buildCondition([op$1.IF_ERROR], [
        op$1.FAIL,
        nameIndex
      ], []));
    },
    choice: function (node, context) {
      function buildAlternativesCode(alternatives, context) {
        return buildSequence(generate(alternatives[0], {
          sp: context.sp,
          env: objects$3.clone(context.env),
          action: null
        }), alternatives.length > 1 ? buildCondition([op$1.IF_ERROR], buildSequence([op$1.POP], buildAlternativesCode(alternatives.slice(1), context)), []) : []);
      }
      return buildAlternativesCode(node.alternatives, context);
    },
    action: function (node, context) {
      var env = objects$3.clone(context.env), emitCall = node.expression.type !== "sequence" || node.expression.elements.length === 0, expressionCode = generate(node.expression, {
          sp: context.sp + (emitCall ? 1 : 0),
          env: env,
          action: node
        }), functionIndex = addFunctionConst(objects$3.keys(env), node.code);
      return emitCall ? buildSequence([op$1.PUSH_CURR_POS], expressionCode, buildCondition([op$1.IF_NOT_ERROR], buildSequence([
        op$1.LOAD_SAVED_POS,
        1
      ], buildCall(functionIndex, 1, env, context.sp + 2)), []), [op$1.NIP]) : expressionCode;
    },
    sequence: function (node, context) {
      function buildElementsCode(elements, context) {
        var processedCount, functionIndex;
        if (elements.length > 0) {
          processedCount = node.elements.length - elements.slice(1).length;
          return buildSequence(generate(elements[0], {
            sp: context.sp,
            env: context.env,
            action: null
          }), buildCondition([op$1.IF_NOT_ERROR], buildElementsCode(elements.slice(1), {
            sp: context.sp + 1,
            env: context.env,
            action: context.action
          }), buildSequence(processedCount > 1 ? [
            op$1.POP_N,
            processedCount
          ] : [op$1.POP], [op$1.POP_CURR_POS], [op$1.PUSH_FAILED])));
        } else {
          if (context.action) {
            functionIndex = addFunctionConst(objects$3.keys(context.env), context.action.code);
            return buildSequence([
              op$1.LOAD_SAVED_POS,
              node.elements.length
            ], buildCall(functionIndex, node.elements.length, context.env, context.sp), [op$1.NIP]);
          } else {
            return buildSequence([
              op$1.WRAP,
              node.elements.length
            ], [op$1.NIP]);
          }
        }
      }
      return buildSequence([op$1.PUSH_CURR_POS], buildElementsCode(node.elements, {
        sp: context.sp + 1,
        env: context.env,
        action: context.action
      }));
    },
    labeled: function (node, context) {
      var env = objects$3.clone(context.env);
      context.env[node.label] = context.sp + 1;
      return generate(node.expression, {
        sp: context.sp,
        env: env,
        action: null
      });
    },
    text: function (node, context) {
      return buildSequence([op$1.PUSH_CURR_POS], generate(node.expression, {
        sp: context.sp + 1,
        env: objects$3.clone(context.env),
        action: null
      }), buildCondition([op$1.IF_NOT_ERROR], buildSequence([op$1.POP], [op$1.TEXT]), [op$1.NIP]));
    },
    simple_and: function (node, context) {
      return buildSimplePredicate(node.expression, false, context);
    },
    simple_not: function (node, context) {
      return buildSimplePredicate(node.expression, true, context);
    },
    optional: function (node, context) {
      return buildSequence(generate(node.expression, {
        sp: context.sp,
        env: objects$3.clone(context.env),
        action: null
      }), buildCondition([op$1.IF_ERROR], buildSequence([op$1.POP], [op$1.PUSH_NULL]), []));
    },
    zero_or_more: function (node, context) {
      var expressionCode = generate(node.expression, {
        sp: context.sp + 1,
        env: objects$3.clone(context.env),
        action: null
      });
      return buildSequence([op$1.PUSH_EMPTY_ARRAY], expressionCode, buildAppendLoop(expressionCode), [op$1.POP]);
    },
    one_or_more: function (node, context) {
      var expressionCode = generate(node.expression, {
        sp: context.sp + 1,
        env: objects$3.clone(context.env),
        action: null
      });
      return buildSequence([op$1.PUSH_EMPTY_ARRAY], expressionCode, buildCondition([op$1.IF_NOT_ERROR], buildSequence(buildAppendLoop(expressionCode), [op$1.POP]), buildSequence([op$1.POP], [op$1.POP], [op$1.PUSH_FAILED])));
    },
    group: function (node, context) {
      return generate(node.expression, {
        sp: context.sp,
        env: objects$3.clone(context.env),
        action: null
      });
    },
    semantic_and: function (node, context) {
      return buildSemanticPredicate(node.code, false, context);
    },
    semantic_not: function (node, context) {
      return buildSemanticPredicate(node.code, true, context);
    },
    rule_ref: function (node) {
      return [
        op$1.RULE,
        asts$1.indexOfRule(ast, node.name)
      ];
    },
    literal: function (node) {
      var stringIndex, expectedIndex;
      if (node.value.length > 0) {
        stringIndex = addConst("\"" + js$1.stringEscape(node.ignoreCase ? node.value.toLowerCase() : node.value) + "\"");
        expectedIndex = addConst("peg$literalExpectation(" + "\"" + js$1.stringEscape(node.value) + "\", " + node.ignoreCase + ")");
        return buildCondition(node.ignoreCase ? [
          op$1.MATCH_STRING_IC,
          stringIndex
        ] : [
          op$1.MATCH_STRING,
          stringIndex
        ], node.ignoreCase ? [
          op$1.ACCEPT_N,
          node.value.length
        ] : [
          op$1.ACCEPT_STRING,
          stringIndex
        ], [
          op$1.FAIL,
          expectedIndex
        ]);
      } else {
        stringIndex = addConst("\"\"");
        return [
          op$1.PUSH,
          stringIndex
        ];
      }
    },
    "class": function (node) {
      var regexp, parts, regexpIndex, expectedIndex;
      if (node.parts.length > 0) {
        regexp = "/^[" + (node.inverted ? "^" : "") + arrays$3.map(node.parts, function (part) {
          return part instanceof Array ? js$1.regexpClassEscape(part[0]) + "-" + js$1.regexpClassEscape(part[1]) : js$1.regexpClassEscape(part);
        }).join("") + "]/" + (node.ignoreCase ? "i" : "");
      } else {
        regexp = node.inverted ? "/^[\\S\\s]/" : "/^(?!)/";
      }
      parts = "[" + arrays$3.map(node.parts, function (part) {
        return part instanceof Array ? "[\"" + js$1.stringEscape(part[0]) + "\", \"" + js$1.stringEscape(part[1]) + "\"]" : "\"" + js$1.stringEscape(part) + "\"";
      }).join(", ") + "]";
      regexpIndex = addConst(regexp);
      expectedIndex = addConst("peg$classExpectation(" + parts + ", " + node.inverted + ", " + node.ignoreCase + ")");
      return buildCondition([
        op$1.MATCH_REGEXP,
        regexpIndex
      ], [
        op$1.ACCEPT_N,
        1
      ], [
        op$1.FAIL,
        expectedIndex
      ]);
    },
    any: function () {
      var expectedIndex = addConst("peg$anyExpectation()");
      return buildCondition([op$1.MATCH_ANY], [
        op$1.ACCEPT_N,
        1
      ], [
        op$1.FAIL,
        expectedIndex
      ]);
    }
  });
  generate(ast);
}
var generateBytecode_1 = generateBytecode;

var arrays$2 = arrays_1, objects$2 = objects_1, asts = asts_1, op = opcodes_1, js = js_1;
function generateJS(ast, options) {
  function indent2(code) {
    return code.replace(/^(.+)$/gm, "  $1");
  }
  function indent6(code) {
    return code.replace(/^(.+)$/gm, "      $1");
  }
  function indent10(code) {
    return code.replace(/^(.+)$/gm, "          $1");
  }
  function generateTables() {
    if (options.optimize === "size") {
      return [
        "peg$consts = [",
        indent2(ast.consts.join(",\n")),
        "],",
        "",
        "peg$bytecode = [",
        indent2(arrays$2.map(ast.rules, function (rule) {
          return "peg$decode(\"" + js.stringEscape(arrays$2.map(rule.bytecode, function (b) {
            return String.fromCharCode(b + 32);
          }).join("")) + "\")";
        }).join(",\n")),
        "],"
      ].join("\n");
    } else {
      return arrays$2.map(ast.consts, function (c, i) {
        return "peg$c" + i + " = " + c + ",";
      }).join("\n");
    }
  }
  function generateRuleHeader(ruleNameCode, ruleIndexCode) {
    var parts = [];
    parts.push("");
    if (options.trace) {
      parts.push([
        "peg$tracer.trace({",
        "  type:     \"rule.enter\",",
        "  rule:     " + ruleNameCode + ",",
        "  location: peg$computeLocation(startPos, startPos)",
        "});",
        ""
      ].join("\n"));
    }
    if (options.cache) {
      parts.push([
        "var key    = peg$currPos * " + ast.rules.length + " + " + ruleIndexCode + ",",
        "    cached = peg$resultsCache[key];",
        "",
        "if (cached) {",
        "  peg$currPos = cached.nextPos;",
        ""
      ].join("\n"));
      if (options.trace) {
        parts.push([
          "if (cached.result !== peg$FAILED) {",
          "  peg$tracer.trace({",
          "    type:   \"rule.match\",",
          "    rule:   " + ruleNameCode + ",",
          "    result: cached.result,",
          "    location: peg$computeLocation(startPos, peg$currPos)",
          "  });",
          "} else {",
          "  peg$tracer.trace({",
          "    type: \"rule.fail\",",
          "    rule: " + ruleNameCode + ",",
          "    location: peg$computeLocation(startPos, startPos)",
          "  });",
          "}",
          ""
        ].join("\n"));
      }
      parts.push([
        "  return cached.result;",
        "}",
        ""
      ].join("\n"));
    }
    return parts.join("\n");
  }
  function generateRuleFooter(ruleNameCode, resultCode) {
    var parts = [];
    if (options.cache) {
      parts.push([
        "",
        "peg$resultsCache[key] = { nextPos: peg$currPos, result: " + resultCode + " };"
      ].join("\n"));
    }
    if (options.trace) {
      parts.push([
        "",
        "if (" + resultCode + " !== peg$FAILED) {",
        "  peg$tracer.trace({",
        "    type:   \"rule.match\",",
        "    rule:   " + ruleNameCode + ",",
        "    result: " + resultCode + ",",
        "    location: peg$computeLocation(startPos, peg$currPos)",
        "  });",
        "} else {",
        "  peg$tracer.trace({",
        "    type: \"rule.fail\",",
        "    rule: " + ruleNameCode + ",",
        "    location: peg$computeLocation(startPos, startPos)",
        "  });",
        "}"
      ].join("\n"));
    }
    parts.push([
      "",
      "return " + resultCode + ";"
    ].join("\n"));
    return parts.join("\n");
  }
  function generateInterpreter() {
    var parts = [];
    function generateCondition(cond, argsLength) {
      var baseLength = argsLength + 3, thenLengthCode = "bc[ip + " + (baseLength - 2) + "]", elseLengthCode = "bc[ip + " + (baseLength - 1) + "]";
      return [
        "ends.push(end);",
        "ips.push(ip + " + baseLength + " + " + thenLengthCode + " + " + elseLengthCode + ");",
        "",
        "if (" + cond + ") {",
        "  end = ip + " + baseLength + " + " + thenLengthCode + ";",
        "  ip += " + baseLength + ";",
        "} else {",
        "  end = ip + " + baseLength + " + " + thenLengthCode + " + " + elseLengthCode + ";",
        "  ip += " + baseLength + " + " + thenLengthCode + ";",
        "}",
        "",
        "break;"
      ].join("\n");
    }
    function generateLoop(cond) {
      var baseLength = 2, bodyLengthCode = "bc[ip + " + (baseLength - 1) + "]";
      return [
        "if (" + cond + ") {",
        "  ends.push(end);",
        "  ips.push(ip);",
        "",
        "  end = ip + " + baseLength + " + " + bodyLengthCode + ";",
        "  ip += " + baseLength + ";",
        "} else {",
        "  ip += " + baseLength + " + " + bodyLengthCode + ";",
        "}",
        "",
        "break;"
      ].join("\n");
    }
    function generateCall() {
      var baseLength = 4, paramsLengthCode = "bc[ip + " + (baseLength - 1) + "]";
      return [
        "params = bc.slice(ip + " + baseLength + ", ip + " + baseLength + " + " + paramsLengthCode + ");",
        "for (i = 0; i < " + paramsLengthCode + "; i++) {",
        "  params[i] = stack[stack.length - 1 - params[i]];",
        "}",
        "",
        "stack.splice(",
        "  stack.length - bc[ip + 2],",
        "  bc[ip + 2],",
        "  peg$consts[bc[ip + 1]].apply(null, params)",
        ");",
        "",
        "ip += " + baseLength + " + " + paramsLengthCode + ";",
        "break;"
      ].join("\n");
    }
    parts.push([
      "function peg$decode(s) {",
      "  var bc = new Array(s.length), i;",
      "",
      "  for (i = 0; i < s.length; i++) {",
      "    bc[i] = s.charCodeAt(i) - 32;",
      "  }",
      "",
      "  return bc;",
      "}",
      "",
      "function peg$parseRule(index) {"
    ].join("\n"));
    if (options.trace) {
      parts.push([
        "  var bc       = peg$bytecode[index],",
        "      ip       = 0,",
        "      ips      = [],",
        "      end      = bc.length,",
        "      ends     = [],",
        "      stack    = [],",
        "      startPos = peg$currPos,",
        "      params, i;"
      ].join("\n"));
    } else {
      parts.push([
        "  var bc    = peg$bytecode[index],",
        "      ip    = 0,",
        "      ips   = [],",
        "      end   = bc.length,",
        "      ends  = [],",
        "      stack = [],",
        "      params, i;"
      ].join("\n"));
    }
    parts.push(indent2(generateRuleHeader("peg$ruleNames[index]", "index")));
    parts.push([
      "  while (true) {",
      "    while (ip < end) {",
      "      switch (bc[ip]) {",
      "        case " + op.PUSH + ":",
      "          stack.push(peg$consts[bc[ip + 1]]);",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.PUSH_UNDEFINED + ":",
      "          stack.push(void 0);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.PUSH_NULL + ":",
      "          stack.push(null);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.PUSH_FAILED + ":",
      "          stack.push(peg$FAILED);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.PUSH_EMPTY_ARRAY + ":",
      "          stack.push([]);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.PUSH_CURR_POS + ":",
      "          stack.push(peg$currPos);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.POP + ":",
      "          stack.pop();",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.POP_CURR_POS + ":",
      "          peg$currPos = stack.pop();",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.POP_N + ":",
      "          stack.length -= bc[ip + 1];",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.NIP + ":",
      "          stack.splice(-2, 1);",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.APPEND + ":",
      "          stack[stack.length - 2].push(stack.pop());",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.WRAP + ":",
      "          stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.TEXT + ":",
      "          stack.push(input.substring(stack.pop(), peg$currPos));",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.IF + ":",
      indent10(generateCondition("stack[stack.length - 1]", 0)),
      "",
      "        case " + op.IF_ERROR + ":",
      indent10(generateCondition("stack[stack.length - 1] === peg$FAILED", 0)),
      "",
      "        case " + op.IF_NOT_ERROR + ":",
      indent10(generateCondition("stack[stack.length - 1] !== peg$FAILED", 0)),
      "",
      "        case " + op.WHILE_NOT_ERROR + ":",
      indent10(generateLoop("stack[stack.length - 1] !== peg$FAILED")),
      "",
      "        case " + op.MATCH_ANY + ":",
      indent10(generateCondition("input.length > peg$currPos", 0)),
      "",
      "        case " + op.MATCH_STRING + ":",
      indent10(generateCondition("input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]", 1)),
      "",
      "        case " + op.MATCH_STRING_IC + ":",
      indent10(generateCondition("input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]", 1)),
      "",
      "        case " + op.MATCH_REGEXP + ":",
      indent10(generateCondition("peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))", 1)),
      "",
      "        case " + op.ACCEPT_N + ":",
      "          stack.push(input.substr(peg$currPos, bc[ip + 1]));",
      "          peg$currPos += bc[ip + 1];",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.ACCEPT_STRING + ":",
      "          stack.push(peg$consts[bc[ip + 1]]);",
      "          peg$currPos += peg$consts[bc[ip + 1]].length;",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.FAIL + ":",
      "          stack.push(peg$FAILED);",
      "          if (peg$silentFails === 0) {",
      "            peg$fail(peg$consts[bc[ip + 1]]);",
      "          }",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.LOAD_SAVED_POS + ":",
      "          peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.UPDATE_SAVED_POS + ":",
      "          peg$savedPos = peg$currPos;",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.CALL + ":",
      indent10(generateCall()),
      "",
      "        case " + op.RULE + ":",
      "          stack.push(peg$parseRule(bc[ip + 1]));",
      "          ip += 2;",
      "          break;",
      "",
      "        case " + op.SILENT_FAILS_ON + ":",
      "          peg$silentFails++;",
      "          ip++;",
      "          break;",
      "",
      "        case " + op.SILENT_FAILS_OFF + ":",
      "          peg$silentFails--;",
      "          ip++;",
      "          break;",
      "",
      "        default:",
      "          throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");",
      "      }",
      "    }",
      "",
      "    if (ends.length > 0) {",
      "      end = ends.pop();",
      "      ip = ips.pop();",
      "    } else {",
      "      break;",
      "    }",
      "  }"
    ].join("\n"));
    parts.push(indent2(generateRuleFooter("peg$ruleNames[index]", "stack[0]")));
    parts.push("}");
    return parts.join("\n");
  }
  function generateRuleFunction(rule) {
    var parts = [], code;
    function c(i) {
      return "peg$c" + i;
    }
    function s(i) {
      return "s" + i;
    }
    var stack = {
      sp: -1,
      maxSp: -1,
      push: function (exprCode) {
        var code = s(++this.sp) + " = " + exprCode + ";";
        if (this.sp > this.maxSp) {
          this.maxSp = this.sp;
        }
        return code;
      },
      pop: function (n) {
        var values;
        if (n === void 0) {
          return s(this.sp--);
        } else {
          values = arrays$2.map(arrays$2.range(this.sp - n + 1, this.sp + 1), s);
          this.sp -= n;
          return values;
        }
      },
      top: function () {
        return s(this.sp);
      },
      index: function (i) {
        return s(this.sp - i);
      }
    };
    function compile(bc) {
      var ip = 0, end = bc.length, parts = [], value;
      function compileCondition(cond, argCount) {
        var baseLength = argCount + 3, thenLength = bc[ip + baseLength - 2], elseLength = bc[ip + baseLength - 1], baseSp = stack.sp, thenCode, elseCode, thenSp, elseSp;
        ip += baseLength;
        thenCode = compile(bc.slice(ip, ip + thenLength));
        thenSp = stack.sp;
        ip += thenLength;
        if (elseLength > 0) {
          stack.sp = baseSp;
          elseCode = compile(bc.slice(ip, ip + elseLength));
          elseSp = stack.sp;
          ip += elseLength;
          if (thenSp !== elseSp) {
            throw new Error("Branches of a condition must move the stack pointer in the same way.");
          }
        }
        parts.push("if (" + cond + ") {");
        parts.push(indent2(thenCode));
        if (elseLength > 0) {
          parts.push("} else {");
          parts.push(indent2(elseCode));
        }
        parts.push("}");
      }
      function compileLoop(cond) {
        var baseLength = 2, bodyLength = bc[ip + baseLength - 1], baseSp = stack.sp, bodyCode, bodySp;
        ip += baseLength;
        bodyCode = compile(bc.slice(ip, ip + bodyLength));
        bodySp = stack.sp;
        ip += bodyLength;
        if (bodySp !== baseSp) {
          throw new Error("Body of a loop can't move the stack pointer.");
        }
        parts.push("while (" + cond + ") {");
        parts.push(indent2(bodyCode));
        parts.push("}");
      }
      function compileCall() {
        var baseLength = 4, paramsLength = bc[ip + baseLength - 1];
        var value = c(bc[ip + 1]) + "(" + arrays$2.map(bc.slice(ip + baseLength, ip + baseLength + paramsLength), function (p) {
          return stack.index(p);
        }).join(", ") + ")";
        stack.pop(bc[ip + 2]);
        parts.push(stack.push(value));
        ip += baseLength + paramsLength;
      }
      while (ip < end) {
        switch (bc[ip]) {
        case op.PUSH:
          parts.push(stack.push(c(bc[ip + 1])));
          ip += 2;
          break;
        case op.PUSH_CURR_POS:
          parts.push(stack.push("peg$currPos"));
          ip++;
          break;
        case op.PUSH_UNDEFINED:
          parts.push(stack.push("void 0"));
          ip++;
          break;
        case op.PUSH_NULL:
          parts.push(stack.push("null"));
          ip++;
          break;
        case op.PUSH_FAILED:
          parts.push(stack.push("peg$FAILED"));
          ip++;
          break;
        case op.PUSH_EMPTY_ARRAY:
          parts.push(stack.push("[]"));
          ip++;
          break;
        case op.POP:
          stack.pop();
          ip++;
          break;
        case op.POP_CURR_POS:
          parts.push("peg$currPos = " + stack.pop() + ";");
          ip++;
          break;
        case op.POP_N:
          stack.pop(bc[ip + 1]);
          ip += 2;
          break;
        case op.NIP:
          value = stack.pop();
          stack.pop();
          parts.push(stack.push(value));
          ip++;
          break;
        case op.APPEND:
          value = stack.pop();
          parts.push(stack.top() + ".push(" + value + ");");
          ip++;
          break;
        case op.WRAP:
          parts.push(stack.push("[" + stack.pop(bc[ip + 1]).join(", ") + "]"));
          ip += 2;
          break;
        case op.TEXT:
          parts.push(stack.push("input.substring(" + stack.pop() + ", peg$currPos)"));
          ip++;
          break;
        case op.IF:
          compileCondition(stack.top(), 0);
          break;
        case op.IF_ERROR:
          compileCondition(stack.top() + " === peg$FAILED", 0);
          break;
        case op.IF_NOT_ERROR:
          compileCondition(stack.top() + " !== peg$FAILED", 0);
          break;
        case op.WHILE_NOT_ERROR:
          compileLoop(stack.top() + " !== peg$FAILED");
          break;
        case op.MATCH_ANY:
          compileCondition("input.length > peg$currPos", 0);
          break;
        case op.MATCH_STRING:
          compileCondition(eval(ast.consts[bc[ip + 1]]).length > 1 ? "input.substr(peg$currPos, " + eval(ast.consts[bc[ip + 1]]).length + ") === " + c(bc[ip + 1]) : "input.charCodeAt(peg$currPos) === " + eval(ast.consts[bc[ip + 1]]).charCodeAt(0), 1);
          break;
        case op.MATCH_STRING_IC:
          compileCondition("input.substr(peg$currPos, " + eval(ast.consts[bc[ip + 1]]).length + ").toLowerCase() === " + c(bc[ip + 1]), 1);
          break;
        case op.MATCH_REGEXP:
          compileCondition(c(bc[ip + 1]) + ".test(input.charAt(peg$currPos))", 1);
          break;
        case op.ACCEPT_N:
          parts.push(stack.push(bc[ip + 1] > 1 ? "input.substr(peg$currPos, " + bc[ip + 1] + ")" : "input.charAt(peg$currPos)"));
          parts.push(bc[ip + 1] > 1 ? "peg$currPos += " + bc[ip + 1] + ";" : "peg$currPos++;");
          ip += 2;
          break;
        case op.ACCEPT_STRING:
          parts.push(stack.push(c(bc[ip + 1])));
          parts.push(eval(ast.consts[bc[ip + 1]]).length > 1 ? "peg$currPos += " + eval(ast.consts[bc[ip + 1]]).length + ";" : "peg$currPos++;");
          ip += 2;
          break;
        case op.FAIL:
          parts.push(stack.push("peg$FAILED"));
          parts.push("if (peg$silentFails === 0) { peg$fail(" + c(bc[ip + 1]) + "); }");
          ip += 2;
          break;
        case op.LOAD_SAVED_POS:
          parts.push("peg$savedPos = " + stack.index(bc[ip + 1]) + ";");
          ip += 2;
          break;
        case op.UPDATE_SAVED_POS:
          parts.push("peg$savedPos = peg$currPos;");
          ip++;
          break;
        case op.CALL:
          compileCall();
          break;
        case op.RULE:
          parts.push(stack.push("peg$parse" + ast.rules[bc[ip + 1]].name + "()"));
          ip += 2;
          break;
        case op.SILENT_FAILS_ON:
          parts.push("peg$silentFails++;");
          ip++;
          break;
        case op.SILENT_FAILS_OFF:
          parts.push("peg$silentFails--;");
          ip++;
          break;
        default:
          throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }
      return parts.join("\n");
    }
    code = compile(rule.bytecode);
    parts.push("function peg$parse" + rule.name + "() {");
    if (options.trace) {
      parts.push([
        "  var " + arrays$2.map(arrays$2.range(0, stack.maxSp + 1), s).join(", ") + ",",
        "      startPos = peg$currPos;"
      ].join("\n"));
    } else {
      parts.push("  var " + arrays$2.map(arrays$2.range(0, stack.maxSp + 1), s).join(", ") + ";");
    }
    parts.push(indent2(generateRuleHeader("\"" + js.stringEscape(rule.name) + "\"", asts.indexOfRule(ast, rule.name))));
    parts.push(indent2(code));
    parts.push(indent2(generateRuleFooter("\"" + js.stringEscape(rule.name) + "\"", s(0))));
    parts.push("}");
    return parts.join("\n");
  }
  function generateToplevel() {
    var parts = [], startRuleIndices, startRuleIndex, startRuleFunctions, startRuleFunction, ruleNames;
    parts.push([
      "function peg$subclass(child, parent) {",
      "  function ctor() { this.constructor = child; }",
      "  ctor.prototype = parent.prototype;",
      "  child.prototype = new ctor();",
      "}",
      "",
      "function peg$SyntaxError(message, expected, found, location) {",
      "  this.message  = message;",
      "  this.expected = expected;",
      "  this.found    = found;",
      "  this.location = location;",
      "  this.name     = \"SyntaxError\";",
      "",
      "  if (typeof Error.captureStackTrace === \"function\") {",
      "    Error.captureStackTrace(this, peg$SyntaxError);",
      "  }",
      "}",
      "",
      "peg$subclass(peg$SyntaxError, Error);",
      "",
      "peg$SyntaxError.buildMessage = function(expected, found) {",
      "  var DESCRIBE_EXPECTATION_FNS = {",
      "        literal: function(expectation) {",
      "          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";",
      "        },",
      "",
      "        \"class\": function(expectation) {",
      "          var escapedParts = \"\",",
      "              i;",
      "",
      "          for (i = 0; i < expectation.parts.length; i++) {",
      "            escapedParts += expectation.parts[i] instanceof Array",
      "              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])",
      "              : classEscape(expectation.parts[i]);",
      "          }",
      "",
      "          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";",
      "        },",
      "",
      "        any: function(expectation) {",
      "          return \"any character\";",
      "        },",
      "",
      "        end: function(expectation) {",
      "          return \"end of input\";",
      "        },",
      "",
      "        other: function(expectation) {",
      "          return expectation.description;",
      "        }",
      "      };",
      "",
      "  function hex(ch) {",
      "    return ch.charCodeAt(0).toString(16).toUpperCase();",
      "  }",
      "",
      "  function literalEscape(s) {",
      "    return s",
      "      .replace(/\\\\/g, '\\\\\\\\')",
      "      .replace(/\"/g,  '\\\\\"')",
      "      .replace(/\\0/g, '\\\\0')",
      "      .replace(/\\t/g, '\\\\t')",
      "      .replace(/\\n/g, '\\\\n')",
      "      .replace(/\\r/g, '\\\\r')",
      "      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })",
      "      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });",
      "  }",
      "",
      "  function classEscape(s) {",
      "    return s",
      "      .replace(/\\\\/g, '\\\\\\\\')",
      "      .replace(/\\]/g, '\\\\]')",
      "      .replace(/\\^/g, '\\\\^')",
      "      .replace(/-/g,  '\\\\-')",
      "      .replace(/\\0/g, '\\\\0')",
      "      .replace(/\\t/g, '\\\\t')",
      "      .replace(/\\n/g, '\\\\n')",
      "      .replace(/\\r/g, '\\\\r')",
      "      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })",
      "      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });",
      "  }",
      "",
      "  function describeExpectation(expectation) {",
      "    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);",
      "  }",
      "",
      "  function describeExpected(expected) {",
      "    var descriptions = new Array(expected.length),",
      "        i, j;",
      "",
      "    for (i = 0; i < expected.length; i++) {",
      "      descriptions[i] = describeExpectation(expected[i]);",
      "    }",
      "",
      "    descriptions.sort();",
      "",
      "    if (descriptions.length > 0) {",
      "      for (i = 1, j = 1; i < descriptions.length; i++) {",
      "        if (descriptions[i - 1] !== descriptions[i]) {",
      "          descriptions[j] = descriptions[i];",
      "          j++;",
      "        }",
      "      }",
      "      descriptions.length = j;",
      "    }",
      "",
      "    switch (descriptions.length) {",
      "      case 1:",
      "        return descriptions[0];",
      "",
      "      case 2:",
      "        return descriptions[0] + \" or \" + descriptions[1];",
      "",
      "      default:",
      "        return descriptions.slice(0, -1).join(\", \")",
      "          + \", or \"",
      "          + descriptions[descriptions.length - 1];",
      "    }",
      "  }",
      "",
      "  function describeFound(found) {",
      "    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";",
      "  }",
      "",
      "  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";",
      "};",
      ""
    ].join("\n"));
    if (options.trace) {
      parts.push([
        "function peg$DefaultTracer() {",
        "  this.indentLevel = 0;",
        "}",
        "",
        "peg$DefaultTracer.prototype.trace = function(event) {",
        "  var that = this;",
        "",
        "  function log(event) {",
        "    function repeat(string, n) {",
        "       var result = \"\", i;",
        "",
        "       for (i = 0; i < n; i++) {",
        "         result += string;",
        "       }",
        "",
        "       return result;",
        "    }",
        "",
        "    function pad(string, length) {",
        "      return string + repeat(\" \", length - string.length);",
        "    }",
        "",
        "    if (typeof console === \"object\") {",
        "      console.log(",
        "        event.location.start.line + \":\" + event.location.start.column + \"-\"",
        "          + event.location.end.line + \":\" + event.location.end.column + \" \"",
        "          + pad(event.type, 10) + \" \"",
        "          + repeat(\"  \", that.indentLevel) + event.rule",
        "      );",
        "    }",
        "  }",
        "",
        "  switch (event.type) {",
        "    case \"rule.enter\":",
        "      log(event);",
        "      this.indentLevel++;",
        "      break;",
        "",
        "    case \"rule.match\":",
        "      this.indentLevel--;",
        "      log(event);",
        "      break;",
        "",
        "    case \"rule.fail\":",
        "      this.indentLevel--;",
        "      log(event);",
        "      break;",
        "",
        "    default:",
        "      throw new Error(\"Invalid event type: \" + event.type + \".\");",
        "  }",
        "};",
        ""
      ].join("\n"));
    }
    parts.push([
      "function peg$parse(input, options) {",
      "  options = options !== void 0 ? options : {};",
      "",
      "  var peg$FAILED = {},",
      ""
    ].join("\n"));
    if (options.optimize === "size") {
      startRuleIndices = "{ " + arrays$2.map(options.allowedStartRules, function (r) {
        return r + ": " + asts.indexOfRule(ast, r);
      }).join(", ") + " }";
      startRuleIndex = asts.indexOfRule(ast, options.allowedStartRules[0]);
      parts.push([
        "      peg$startRuleIndices = " + startRuleIndices + ",",
        "      peg$startRuleIndex   = " + startRuleIndex + ","
      ].join("\n"));
    } else {
      startRuleFunctions = "{ " + arrays$2.map(options.allowedStartRules, function (r) {
        return r + ": peg$parse" + r;
      }).join(", ") + " }";
      startRuleFunction = "peg$parse" + options.allowedStartRules[0];
      parts.push([
        "      peg$startRuleFunctions = " + startRuleFunctions + ",",
        "      peg$startRuleFunction  = " + startRuleFunction + ","
      ].join("\n"));
    }
    parts.push("");
    parts.push(indent6(generateTables()));
    parts.push([
      "",
      "      peg$currPos          = 0,",
      "      peg$savedPos         = 0,",
      "      peg$posDetailsCache  = [{ line: 1, column: 1 }],",
      "      peg$maxFailPos       = 0,",
      "      peg$maxFailExpected  = [],",
      "      peg$silentFails      = 0,",
      ""
    ].join("\n"));
    if (options.cache) {
      parts.push([
        "      peg$resultsCache = {},",
        ""
      ].join("\n"));
    }
    if (options.trace) {
      if (options.optimize === "size") {
        ruleNames = "[" + arrays$2.map(ast.rules, function (r) {
          return "\"" + js.stringEscape(r.name) + "\"";
        }).join(", ") + "]";
        parts.push([
          "      peg$ruleNames = " + ruleNames + ",",
          ""
        ].join("\n"));
      }
      parts.push([
        "      peg$tracer = \"tracer\" in options ? options.tracer : new peg$DefaultTracer(),",
        ""
      ].join("\n"));
    }
    parts.push([
      "      peg$result;",
      ""
    ].join("\n"));
    if (options.optimize === "size") {
      parts.push([
        "  if (\"startRule\" in options) {",
        "    if (!(options.startRule in peg$startRuleIndices)) {",
        "      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");",
        "    }",
        "",
        "    peg$startRuleIndex = peg$startRuleIndices[options.startRule];",
        "  }"
      ].join("\n"));
    } else {
      parts.push([
        "  if (\"startRule\" in options) {",
        "    if (!(options.startRule in peg$startRuleFunctions)) {",
        "      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");",
        "    }",
        "",
        "    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];",
        "  }"
      ].join("\n"));
    }
    parts.push([
      "",
      "  function text() {",
      "    return input.substring(peg$savedPos, peg$currPos);",
      "  }",
      "",
      "  function location() {",
      "    return peg$computeLocation(peg$savedPos, peg$currPos);",
      "  }",
      "",
      "  function expected(description, location) {",
      "    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)",
      "",
      "    throw peg$buildStructuredError(",
      "      [peg$otherExpectation(description)],",
      "      input.substring(peg$savedPos, peg$currPos),",
      "      location",
      "    );",
      "  }",
      "",
      "  function error(message, location) {",
      "    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)",
      "",
      "    throw peg$buildSimpleError(message, location);",
      "  }",
      "",
      "  function peg$literalExpectation(text, ignoreCase) {",
      "    return { type: \"literal\", text: text, ignoreCase: ignoreCase };",
      "  }",
      "",
      "  function peg$classExpectation(parts, inverted, ignoreCase) {",
      "    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };",
      "  }",
      "",
      "  function peg$anyExpectation() {",
      "    return { type: \"any\" };",
      "  }",
      "",
      "  function peg$endExpectation() {",
      "    return { type: \"end\" };",
      "  }",
      "",
      "  function peg$otherExpectation(description) {",
      "    return { type: \"other\", description: description };",
      "  }",
      "",
      "  function peg$computePosDetails(pos) {",
      "    var details = peg$posDetailsCache[pos], p;",
      "",
      "    if (details) {",
      "      return details;",
      "    } else {",
      "      p = pos - 1;",
      "      while (!peg$posDetailsCache[p]) {",
      "        p--;",
      "      }",
      "",
      "      details = peg$posDetailsCache[p];",
      "      details = {",
      "        line:   details.line,",
      "        column: details.column",
      "      };",
      "",
      "      while (p < pos) {",
      "        if (input.charCodeAt(p) === 10) {",
      "          details.line++;",
      "          details.column = 1;",
      "        } else {",
      "          details.column++;",
      "        }",
      "",
      "        p++;",
      "      }",
      "",
      "      peg$posDetailsCache[pos] = details;",
      "      return details;",
      "    }",
      "  }",
      "",
      "  function peg$computeLocation(startPos, endPos) {",
      "    var startPosDetails = peg$computePosDetails(startPos),",
      "        endPosDetails   = peg$computePosDetails(endPos);",
      "",
      "    return {",
      "      start: {",
      "        offset: startPos,",
      "        line:   startPosDetails.line,",
      "        column: startPosDetails.column",
      "      },",
      "      end: {",
      "        offset: endPos,",
      "        line:   endPosDetails.line,",
      "        column: endPosDetails.column",
      "      }",
      "    };",
      "  }",
      "",
      "  function peg$fail(expected) {",
      "    if (peg$currPos < peg$maxFailPos) { return; }",
      "",
      "    if (peg$currPos > peg$maxFailPos) {",
      "      peg$maxFailPos = peg$currPos;",
      "      peg$maxFailExpected = [];",
      "    }",
      "",
      "    peg$maxFailExpected.push(expected);",
      "  }",
      "",
      "  function peg$buildSimpleError(message, location) {",
      "    return new peg$SyntaxError(message, null, null, location);",
      "  }",
      "",
      "  function peg$buildStructuredError(expected, found, location) {",
      "    return new peg$SyntaxError(",
      "      peg$SyntaxError.buildMessage(expected, found),",
      "      expected,",
      "      found,",
      "      location",
      "    );",
      "  }",
      ""
    ].join("\n"));
    if (options.optimize === "size") {
      parts.push(indent2(generateInterpreter()));
      parts.push("");
    } else {
      arrays$2.each(ast.rules, function (rule) {
        parts.push(indent2(generateRuleFunction(rule)));
        parts.push("");
      });
    }
    if (ast.initializer) {
      parts.push(indent2(ast.initializer.code));
      parts.push("");
    }
    if (options.optimize === "size") {
      parts.push("  peg$result = peg$parseRule(peg$startRuleIndex);");
    } else {
      parts.push("  peg$result = peg$startRuleFunction();");
    }
    parts.push([
      "",
      "  if (peg$result !== peg$FAILED && peg$currPos === input.length) {",
      "    return peg$result;",
      "  } else {",
      "    if (peg$result !== peg$FAILED && peg$currPos < input.length) {",
      "      peg$fail(peg$endExpectation());",
      "    }",
      "",
      "    throw peg$buildStructuredError(",
      "      peg$maxFailExpected,",
      "      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,",
      "      peg$maxFailPos < input.length",
      "        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)",
      "        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)",
      "    );",
      "  }",
      "}"
    ].join("\n"));
    return parts.join("\n");
  }
  function generateWrapper(toplevelCode) {
    function generateGeneratedByComment() {
      return [
        "/*",
        " * Generated by PEG.js 0.10.0.",
        " *",
        " * http://pegjs.org/",
        " */"
      ].join("\n");
    }
    function generateParserObject() {
      return options.trace ? [
        "{",
        "  SyntaxError:   peg$SyntaxError,",
        "  DefaultTracer: peg$DefaultTracer,",
        "  parse:         peg$parse",
        "}"
      ].join("\n") : [
        "{",
        "  SyntaxError: peg$SyntaxError,",
        "  parse:       peg$parse",
        "}"
      ].join("\n");
    }
    var generators = {
      bare: function () {
        return [
          generateGeneratedByComment(),
          "(function() {",
          "  \"use strict\";",
          "",
          indent2(toplevelCode),
          "",
          indent2("return " + generateParserObject() + ";"),
          "})()"
        ].join("\n");
      },
      commonjs: function () {
        var parts = [], dependencyVars = objects$2.keys(options.dependencies), requires = arrays$2.map(dependencyVars, function (variable) {
            return variable + " = require(\"" + js.stringEscape(options.dependencies[variable]) + "\")";
          });
        parts.push([
          generateGeneratedByComment(),
          "",
          "\"use strict\";",
          ""
        ].join("\n"));
        if (requires.length > 0) {
          parts.push("var " + requires.join(", ") + ";");
          parts.push("");
        }
        parts.push([
          toplevelCode,
          "",
          "module.exports = " + generateParserObject() + ";",
          ""
        ].join("\n"));
        return parts.join("\n");
      },
      amd: function () {
        var dependencyIds = objects$2.values(options.dependencies), dependencyVars = objects$2.keys(options.dependencies), dependencies = "[" + arrays$2.map(dependencyIds, function (id) {
            return "\"" + js.stringEscape(id) + "\"";
          }).join(", ") + "]", params = dependencyVars.join(", ");
        return [
          generateGeneratedByComment(),
          "define(" + dependencies + ", function(" + params + ") {",
          "  \"use strict\";",
          "",
          indent2(toplevelCode),
          "",
          indent2("return " + generateParserObject() + ";"),
          "});",
          ""
        ].join("\n");
      },
      globals: function () {
        return [
          generateGeneratedByComment(),
          "(function(root) {",
          "  \"use strict\";",
          "",
          indent2(toplevelCode),
          "",
          indent2("root." + options.exportVar + " = " + generateParserObject() + ";"),
          "})(this);",
          ""
        ].join("\n");
      },
      umd: function () {
        var parts = [], dependencyIds = objects$2.values(options.dependencies), dependencyVars = objects$2.keys(options.dependencies), dependencies = "[" + arrays$2.map(dependencyIds, function (id) {
            return "\"" + js.stringEscape(id) + "\"";
          }).join(", ") + "]", requires = arrays$2.map(dependencyIds, function (id) {
            return "require(\"" + js.stringEscape(id) + "\")";
          }).join(", "), params = dependencyVars.join(", ");
        parts.push([
          generateGeneratedByComment(),
          "(function(root, factory) {",
          "  if (typeof define === \"function\" && define.amd) {",
          "    define(" + dependencies + ", factory);",
          "  } else if (typeof module === \"object\" && module.exports) {",
          "    module.exports = factory(" + requires + ");"
        ].join("\n"));
        if (options.exportVar !== null) {
          parts.push([
            "  } else {",
            "    root." + options.exportVar + " = factory();"
          ].join("\n"));
        }
        parts.push([
          "  }",
          "})(this, function(" + params + ") {",
          "  \"use strict\";",
          "",
          indent2(toplevelCode),
          "",
          indent2("return " + generateParserObject() + ";"),
          "});",
          ""
        ].join("\n"));
        return parts.join("\n");
      }
    };
    return generators[options.format]();
  }
  ast.code = generateWrapper(generateToplevel());
}
var generateJs = generateJS;

var arrays$1 = arrays_1, objects$1 = objects_1;
var compiler = {
  visitor: visitor_1,
  passes: {
    check: {
      reportUndefinedRules: reportUndefinedRules_1,
      reportDuplicateRules: reportDuplicateRules_1,
      reportDuplicateLabels: reportDuplicateLabels_1,
      reportInfiniteRecursion: reportInfiniteRecursion_1,
      reportInfiniteRepetition: reportInfiniteRepetition_1
    },
    transform: { removeProxyRules: removeProxyRules_1 },
    generate: {
      generateBytecode: generateBytecode_1,
      generateJS: generateJs
    }
  },
  compile: function (ast, passes, options) {
    options = options !== void 0 ? options : {};
    var stage;
    options = objects$1.clone(options);
    objects$1.defaults(options, {
      allowedStartRules: [ast.rules[0].name],
      cache: false,
      dependencies: {},
      exportVar: null,
      format: "bare",
      optimize: "speed",
      output: "parser",
      trace: false
    });
    for (stage in passes) {
      if (passes.hasOwnProperty(stage)) {
        arrays$1.each(passes[stage], function (p) {
          p(ast, options);
        });
      }
    }
    switch (options.output) {
    case "parser":
      return eval(ast.code);
    case "source":
      return ast.code;
    }
  }
};
var compiler_1 = compiler;

var arrays = arrays_1, objects = objects_1;
var peg = {
  VERSION: "0.10.0",
  GrammarError: grammarError,
  parser: parser,
  compiler: compiler_1,
  generate: function (grammar, options) {
    options = options !== void 0 ? options : {};
    function convertPasses(passes) {
      var converted = {}, stage;
      for (stage in passes) {
        if (passes.hasOwnProperty(stage)) {
          converted[stage] = objects.values(passes[stage]);
        }
      }
      return converted;
    }
    options = objects.clone(options);
    var plugins = "plugins" in options ? options.plugins : [], config = {
        parser: peg.parser,
        passes: convertPasses(peg.compiler.passes)
      };
    arrays.each(plugins, function (p) {
      p.use(config, options);
    });
    return peg.compiler.compile(config.parser.parse(grammar), config.passes, options);
  }
};
var peg_1 = peg;

var fs = require$$2__default["default"];
var _ = lodash.exports;
var pegjs = peg_1;
var _1_2_17 = _.extend({
  generateFromFile: function (filename, options) {
    var source = fs.readFileSync(filename, { encoding: "utf8" });
    return pegjs.generate(source, options);
  }
}, pegjs);

var asty_node = {exports: {}};

(function (module, exports) {
  (function (f) {
    {
      module.exports = f();
    }
  }(function () {
    return function () {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof createCommonjsRequire("/lively.next-node_modules/asty/1.8.14/lib") && createCommonjsRequire("/lively.next-node_modules/asty/1.8.14/lib");
              if (!f && c)
                return c(i, !0);
              if (u)
                return u(i, !0);
              var a = new Error("Cannot find module '" + i + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i] = { exports: {} };
            e[i][0].call(p.exports, function (r) {
              var n = e[i][1][r];
              return o(n || r);
            }, p, p.exports, r, e, n, t);
          }
          return n[i].exports;
        }
        for (var u = "function" == typeof createCommonjsRequire("/lively.next-node_modules/asty/1.8.14/lib") && createCommonjsRequire("/lively.next-node_modules/asty/1.8.14/lib"), i = 0; i < t.length; i++)
          o(t[i]);
        return o;
      }
      return r;
    }()({
      1: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          class ASTYBase {
            init(ctx, T, A, C) {
              if (arguments.length < 2)
                throw new Error("init: invalid number of arguments");
              this.ctx = ctx;
              this.ASTy = true;
              this.T = T;
              this.L = {
                L: 0,
                C: 0,
                O: 0
              };
              this.A = {};
              this.C = [];
              this.P = null;
              if (typeof A === "object") {
                for (let name in A)
                  if (Object.prototype.hasOwnProperty.call(A, name))
                    this.set(name, A[name]);
              }
              if (typeof C === "object" && C instanceof Array)
                this.add(C);
              return this;
            }
            create(T, A, C) {
              return this.ctx.create(T, A, C);
            }
            type(T) {
              if (arguments.length === 0)
                return this.T;
              else if (arguments.length === 1) {
                this.T = T;
                return this;
              } else
                throw new Error("type: invalid number of arguments");
            }
            pos(line, column, offset) {
              if (arguments.length === 0)
                return {
                  line: this.L.L,
                  column: this.L.C,
                  offset: this.L.O
                };
              else if (arguments.length <= 3) {
                this.L.L = line || 0;
                this.L.C = column || 0;
                this.L.O = offset || 0;
                return this;
              } else
                throw new Error("pos: invalid number of arguments");
            }
            set(...args) {
              if (args.length === 1 && typeof args[0] === "object") {
                Object.keys(args[0]).forEach(key => {
                  if (args[0][key] !== undefined)
                    this.A[key] = args[0][key];
                  else
                    delete this.A[key];
                });
              } else if (args.length === 2) {
                if (args[1] !== undefined)
                  this.A[args[0]] = args[1];
                else
                  delete this.A[args[0]];
              } else
                throw new Error("set: invalid number of arguments");
              return this;
            }
            unset(...args) {
              if (args.length === 1 && typeof args[0] === "object" && args[0] instanceof Array) {
                args[0].forEach(key => {
                  delete this.A[key];
                });
              } else if (args.length === 1)
                delete this.A[args[0]];
              else
                throw new Error("unset: invalid number of arguments");
              return this;
            }
            get(...args) {
              if (args.length !== 1)
                throw new Error("get: invalid number of arguments");
              if (typeof args[0] === "object" && args[0] instanceof Array) {
                return args[0].map(key => {
                  if (typeof key !== "string")
                    throw new Error("get: invalid key argument");
                  return this.A[key];
                });
              } else {
                let key = args[0];
                if (typeof key !== "string")
                  throw new Error("get: invalid key argument");
                return this.A[key];
              }
            }
            attrs() {
              return Object.keys(this.A);
            }
            nth() {
              if (this.P === null)
                return 1;
              let idx = this.P.C.indexOf(this);
              if (idx < 0)
                throw new Error("nth: internal error -- node not in childs of its parent");
              return idx;
            }
            ins(pos, ...args) {
              if (args.length === 0)
                throw new Error("ins: invalid number of arguments");
              if (pos < 0)
                pos = this.C.length + 1 - pos;
              if (!(pos >= 0 && pos <= this.C.length))
                throw new Error("ins: invalid position");
              let _ins = node => {
                if (!this.ctx.isA(node))
                  throw new Error("ins: invalid AST node argument");
                this.C.splice(pos++, 0, node);
                node.P = this;
              };
              args.forEach(arg => {
                if (typeof arg === "object" && arg instanceof Array)
                  arg.forEach(arg => {
                    _ins(arg);
                  });
                else if (arg !== null)
                  _ins(arg);
              });
              return this;
            }
            add(...args) {
              if (args.length === 0)
                throw new Error("add: invalid number of arguments");
              let _add = node => {
                if (!this.ctx.isA(node))
                  throw new Error("add: invalid AST node argument");
                this.C.push(node);
                node.P = this;
              };
              args.forEach(arg => {
                if (typeof arg === "object" && arg instanceof Array)
                  arg.forEach(arg => {
                    _add(arg);
                  });
                else if (arg !== null)
                  _add(arg);
              });
              return this;
            }
            del(...args) {
              if (args.length === 0)
                throw new Error("del: invalid number of arguments");
              args.forEach(node => {
                if (!this.ctx.isA(node))
                  throw new Error("del: invalid AST node argument");
                let found = false;
                for (let j = 0; j < this.C.length; j++) {
                  if (this.C[j] === node) {
                    this.C.splice(j, 1);
                    node.P = null;
                    found = true;
                    break;
                  }
                }
                if (!found)
                  throw new Error("del: AST node not found in childs");
              });
              return this;
            }
            childs(...args) {
              if (args.length > 2)
                throw new Error("childs: invalid number of arguments");
              if (args.length === 2 && typeof args[0] === "number" && typeof args[1] === "number")
                return this.C.slice(args[0], args[1]);
              else if (args.length === 1 && typeof args[0] === "number")
                return this.C.slice(args[0]);
              else if (args.length === 0)
                return this.C;
              else
                throw new Error("childs: invalid type of arguments");
            }
            child(pos) {
              if (typeof pos !== "number")
                throw new Error("child: invalid argument");
              return pos < this.C.length ? this.C[pos] : null;
            }
            parent() {
              return this.P;
            }
            serialize() {
              return this.ctx.__serialize(this);
            }
          }
          exports.default = ASTYBase;
        },
        {}
      ],
      2: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          const tree = {
            mid: {
              unicode: String.fromCharCode(9500),
              ascii: "+"
            },
            last: {
              unicode: String.fromCharCode(9492),
              ascii: "+"
            },
            down: {
              unicode: String.fromCharCode(9474),
              ascii: "|"
            },
            left: {
              unicode: String.fromCharCode(9472),
              ascii: "-"
            }
          };
          class ASTYDump {
            dump(maxDepth = Infinity, colorize = (type, txt) => txt, unicode = true) {
              let out = "";
              let self = this;
              this.walk((node, depth) => {
                if (depth > maxDepth)
                  return;
                if (depth > 0) {
                  const nodeIndex = node => {
                    let nth = 0;
                    let max = 0;
                    if (node.P !== null) {
                      nth = node.P.C.indexOf(node);
                      max = node.P.C.length - 1;
                    }
                    return {
                      nth,
                      max
                    };
                  };
                  let {nth, max} = nodeIndex(node);
                  let prefix = " ";
                  if (unicode)
                    prefix = `${ tree.left.unicode }${ tree.left.unicode }${ prefix }`;
                  else
                    prefix = `${ tree.left.ascii }${ tree.left.ascii }${ prefix }`;
                  if (nth < max)
                    prefix = `${ unicode ? tree.mid.unicode : tree.mid.ascii }${ prefix }`;
                  else
                    prefix = `${ unicode ? tree.last.unicode : tree.last.ascii }${ prefix }`;
                  for (let parent = node.P; parent !== null && parent !== self; parent = parent.P) {
                    if (parent.P !== null) {
                      let {nth, max} = nodeIndex(parent);
                      if (nth < max)
                        prefix = `${ unicode ? tree.down.unicode : tree.down.ascii }   ${ prefix }`;
                      else
                        prefix = `    ${ prefix }`;
                    }
                  }
                  out += colorize("tree", prefix);
                }
                out += colorize("type", node.T) + " ";
                let keys = Object.keys(node.A).filter(key => !key.match(/^__/));
                if (keys.length > 0) {
                  out += colorize("parenthesis", "(");
                  let first = true;
                  keys.forEach(key => {
                    if (!first)
                      out += colorize("comma", ",") + " ";
                    else
                      first = false;
                    out += colorize("key", key) + colorize("colon", ":") + " ";
                    let value = node.A[key];
                    switch (typeof value) {
                    case "boolean":
                    case "number":
                      out += colorize("value", value.toString());
                      break;
                    case "string": {
                        let hex = ch => ch.charCodeAt(0).toString(16).toUpperCase();
                        out += colorize("value", "\"" + value.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, ch => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x80-\xFF]/g, ch => "\\x" + hex(ch)).replace(/[\u0100-\u0FFF]/g, ch => "\\u0" + hex(ch)).replace(/[\u1000-\uFFFF]/g, ch => "\\u" + hex(ch)) + "\"");
                        break;
                      }
                    case "object":
                      if (value instanceof RegExp)
                        out += colorize("value", "/" + value.source + "/");
                      else
                        out += colorize("value", JSON.stringify(value));
                      break;
                    default:
                      out += colorize("value", JSON.stringify(value));
                      break;
                    }
                  });
                  out += colorize("parenthesis", ")") + " ";
                }
                out += colorize("position", colorize("bracket", "[") + colorize("line", node.L.L) + colorize("slash", ",") + colorize("column", node.L.C) + colorize("bracket", "]"));
                out += "\n";
              }, "downward");
              return out;
            }
          }
          exports.default = ASTYDump;
        },
        {}
      ],
      3: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          class ASTYMerge {
            merge(node, takePos = false, attrMap = {}) {
              if (node === null)
                return this;
              if (!this.ctx.isA(node))
                throw new Error("merge: invalid AST node argument");
              if (takePos) {
                let pos = node.pos();
                this.pos(pos.line, pos.column, pos.offset);
              }
              node.attrs().forEach(attrSource => {
                let attrTarget = typeof attrMap[attrSource] !== "undefined" ? attrMap[attrSource] : attrSource;
                if (attrTarget !== null)
                  this.set(attrTarget, node.get(attrSource));
              });
              node.childs().forEach(child => {
                node.del(child);
                this.add(child);
              });
              let parent = node.parent();
              if (parent !== null)
                parent.del(node);
              return this;
            }
          }
          exports.default = ASTYMerge;
        },
        {}
      ],
      4: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          class ASTYSerialize {
            static serialize(asty, node) {
              const serializeNode = node => {
                let clone = {
                  T: node.T,
                  L: {
                    L: node.L.L,
                    C: node.L.C,
                    O: node.L.O
                  }
                };
                let keys = Object.keys(node.A);
                if (keys.length > 0) {
                  clone.A = {};
                  keys.forEach(key => {
                    let value = node.A[key];
                    switch (typeof value) {
                    case "boolean":
                    case "number":
                    case "string":
                      clone.A[key] = value;
                      break;
                    default:
                      clone.A[key] = JSON.parse(JSON.stringify(value));
                      break;
                    }
                  });
                }
                if (node.C.length > 0)
                  clone.C = node.C.map(C => serializeNode(C));
                return clone;
              };
              if (!asty.isA(node))
                throw new Error("serialize: not an ASTy node");
              return JSON.stringify({ ASTy: serializeNode(node) });
            }
            static unserialize(asty, json) {
              const unserializeNode = clone => {
                let node = asty.create(clone.T);
                node.pos(clone.L.L, clone.L.C, clone.L.O);
                if (typeof clone.A === "object") {
                  Object.keys(clone.A).forEach(key => {
                    let value = clone.A[key];
                    switch (typeof value) {
                    case "boolean":
                    case "number":
                    case "string":
                      node.set(key, value);
                      break;
                    default:
                      node.set(key, JSON.parse(JSON.stringify(value)));
                      break;
                    }
                  });
                }
                if (typeof clone.C === "object" && clone.C instanceof Array)
                  node.add(clone.C.map(C => unserializeNode(C)));
                return node;
              };
              let obj = JSON.parse(json);
              if (typeof obj !== "object" || typeof obj.ASTy !== "object")
                throw new Error("unserialize: not an ASTy JSON export");
              return unserializeNode(obj.ASTy);
            }
          }
          exports.default = ASTYSerialize;
        },
        {}
      ],
      5: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          const version = {
            major: 1,
            minor: 8,
            micro: 14,
            date: 20210107
          };
          var _default = version;
          exports.default = _default;
        },
        {}
      ],
      6: [
        function (_dereq_, module, exports) {
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.default = void 0;
          class ASTYWalk {
            walk(cb, when = "downward") {
              let _walk = (node, depth, parent) => {
                if (when === "downward" || when === "both")
                  cb(node, depth, parent, "downward");
                node.C.forEach(child => {
                  _walk(child, depth + 1, node);
                });
                if (when === "upward" || when === "both")
                  cb(node, depth, parent, "upward");
              };
              _walk(this, 0, null);
              return this;
            }
          }
          exports.default = ASTYWalk;
        },
        {}
      ],
      7: [
        function (_dereq_, module, exports) {
          var _astyBase = _interopRequireDefault(_dereq_("./asty-base.js"));
          var _astyMerge = _interopRequireDefault(_dereq_("./asty-merge.js"));
          var _astyWalk = _interopRequireDefault(_dereq_("./asty-walk.js"));
          var _astyDump = _interopRequireDefault(_dereq_("./asty-dump.js"));
          var _astySerialize = _interopRequireDefault(_dereq_("./asty-serialize.js"));
          var _astyVersion = _interopRequireDefault(_dereq_("./asty-version.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class ASTYCtx {
            constructor() {
              this.ASTYNode = class ASTYNode {
              };
              let mixins = [
                [
                  _astyBase.default,
                  "init",
                  "create",
                  "type",
                  "pos",
                  "set",
                  "unset",
                  "get",
                  "attrs",
                  "nth",
                  "ins",
                  "add",
                  "del",
                  "childs",
                  "child",
                  "parent",
                  "serialize"
                ],
                [
                  _astyMerge.default,
                  "merge"
                ],
                [
                  _astyWalk.default,
                  "walk"
                ],
                [
                  _astyDump.default,
                  "dump"
                ]
              ];
              mixins.forEach(mixin => {
                let proto = mixin[0].prototype;
                mixin.slice(1).forEach(method => {
                  this.ASTYNode.prototype[method] = proto[method];
                });
              });
              return this;
            }
            version() {
              return _astyVersion.default;
            }
            extend(mixin) {
              for (let method in mixin)
                if (Object.prototype.hasOwnProperty.call(mixin, method))
                  this.ASTYNode.prototype[method] = mixin[method];
              return this;
            }
            create(type, attrs, childs) {
              return new this.ASTYNode().init(this, type, attrs, childs);
            }
            isA(node) {
              return typeof node === "object" && node instanceof this.ASTYNode && typeof node.ASTy === "boolean" && node.ASTy === true;
            }
            __serialize(node) {
              return ASTYCtx.serialize(node);
            }
            static serialize(node) {
              return _astySerialize.default.serialize(node.ctx, node);
            }
            static unserialize(json) {
              let Ctx = this;
              return _astySerialize.default.unserialize(new Ctx(), json);
            }
          }
          module.exports = ASTYCtx;
        },
        {
          "./asty-base.js": 1,
          "./asty-dump.js": 2,
          "./asty-merge.js": 3,
          "./asty-serialize.js": 4,
          "./asty-version.js": 5,
          "./asty-walk.js": 6
        }
      ]
    }, {}, [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ])(7);
  }));
}(asty_node));
var ASTY = asty_node.exports;

var PEGUtil$1 = {exports: {}};

(function (module) {
  (function (root, name, factory) {
    module.exports = factory(root);
  }(typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : commonjsGlobal, "PEGUtil", function () {
    var PEGUtil = {};
    PEGUtil.makeAST = function makeAST(location, options) {
      return function () {
        return options.util.__makeAST.call(null, location().start.line, location().start.column, location().start.offset, arguments);
      };
    };
    PEGUtil.makeUnroll = function (location, options) {
      return function (first, list, take) {
        if (typeof list !== "object" || !(list instanceof Array))
          throw new options.util.__SyntaxError("unroll: invalid list argument for unrolling", typeof list, "Array", location());
        if (typeof take !== "undefined") {
          if (typeof take === "number")
            take = [take];
          var result = [];
          if (first !== null)
            result.push(first);
          for (var i = 0; i < list.length; i++) {
            for (var j = 0; j < take.length; j++)
              result.push(list[i][take[j]]);
          }
          return result;
        } else {
          if (first !== null)
            list.unshift(first);
          return list;
        }
      };
    };
    var excerpt = function (txt, o) {
      var l = txt.length;
      var b = o - 20;
      if (b < 0)
        b = 0;
      var e = o + 20;
      if (e > l)
        e = l;
      var hex = function (ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      };
      var extract = function (txt, pos, len) {
        return txt.substr(pos, len).replace(/\\/g, "\\\\").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
          return "\\x" + hex(ch);
        }).replace(/[\u0100-\u0FFF]/g, function (ch) {
          return "\\u0" + hex(ch);
        }).replace(/[\u1000-\uFFFF]/g, function (ch) {
          return "\\u" + hex(ch);
        });
      };
      return {
        prolog: extract(txt, b, o - b),
        token: extract(txt, o, 1),
        epilog: extract(txt, o + 1, e - (o + 1))
      };
    };
    PEGUtil.parse = function (parser, txt, options) {
      if (typeof parser !== "object")
        throw new Error("invalid parser object (not an object)");
      if (typeof parser.parse !== "function")
        throw new Error("invalid parser object (no \"parse\" function)");
      if (typeof txt !== "string")
        throw new Error("invalid input text (not a string)");
      if (typeof options !== "undefined" && typeof options !== "object")
        throw new Error("invalid options (not an object)");
      if (typeof options === "undefined")
        options = {};
      var result = {
        ast: null,
        error: null
      };
      try {
        var makeAST;
        if (typeof options.makeAST === "function")
          makeAST = options.makeAST;
        else {
          makeAST = function (location, args) {
            return {
              line: location().start.line,
              column: location().start.column,
              offset: location().start.offset,
              args: args
            };
          };
        }
        options.util = {
          makeUnroll: PEGUtil.makeUnroll,
          makeAST: PEGUtil.makeAST,
          __makeAST: makeAST,
          __SyntaxError: parser.SyntaxError
        };
        result.ast = parser.parse(txt, options);
        result.error = null;
      } catch (e) {
        result.ast = null;
        if (e instanceof parser.SyntaxError) {
          var definedOrElse = function (value, fallback) {
            return typeof value !== "undefined" ? value : fallback;
          };
          result.error = {
            line: definedOrElse(e.location.start.line, 0),
            column: definedOrElse(e.location.start.column, 0),
            message: e.message,
            found: definedOrElse(e.found, ""),
            expected: definedOrElse(e.expected, ""),
            location: excerpt(txt, definedOrElse(e.location.start.offset, 0))
          };
        } else {
          result.error = {
            line: 0,
            column: 0,
            message: e.message,
            found: "",
            expected: "",
            location: excerpt("", 0)
          };
        }
      }
      return result;
    };
    PEGUtil.errorMessage = function (e, noFinalNewline) {
      var l = e.location;
      var prefix1 = "line " + e.line + " (column " + e.column + "): ";
      var prefix2 = "";
      for (var i = 0; i < prefix1.length + l.prolog.length; i++)
        prefix2 += "-";
      var msg = prefix1 + l.prolog + l.token + l.epilog + "\n" + prefix2 + "^" + "\n" + e.message + (noFinalNewline ? "" : "\n");
      return msg;
    };
    return PEGUtil;
  }));
}(PEGUtil$1));
var PEGUtil = PEGUtil$1.exports;

class ASTQUtil {
  static pad(str, num) {
    let n = num < 0 ? -num : num;
    if (str.length > n)
      str = str.substr(0, n);
    else {
      let pad = Array(n + 1 - str.length).join(" ");
      str = num < 0 ? str + pad : pad + str;
    }
    return str;
  }
  static truthy(value) {
    let result;
    switch (typeof value) {
    case "boolean":
      result = value;
      break;
    case "number":
      result = value !== 0 && !isNaN(value);
      break;
    case "string":
      result = value !== "";
      break;
    case "object":
      result = false;
      if (value !== null) {
        result = true;
        if (value instanceof Array)
          result = value.length > 0;
      }
      break;
    default:
      result = false;
    }
    return result;
  }
  static coerce(value, type) {
    if (typeof value !== type) {
      try {
        switch (type) {
        case "boolean":
          if (typeof value !== "boolean")
            value = Boolean(value);
          break;
        case "number":
          if (typeof value !== "number")
            value = Number(value);
          break;
        case "string":
          if (typeof value !== "string")
            value = String(value);
          break;
        case "regexp":
          if (!(typeof value === "object" && value instanceof RegExp))
            value = new RegExp(value);
          break;
        }
      } catch (e) {
        throw new Error("cannot coerce value into type " + type);
      }
    }
    return value;
  }
}

class ASTQQueryTrace {
  prefixOf(Q, T) {
    let depth = 0;
    let node = Q;
    while ((node = node.parent()) !== null)
      depth++;
    let prefix1 = ASTQUtil.pad("", 4 * depth);
    depth = 0;
    node = T;
    while ((node = this.adapter.getParentNode(node, "*")) !== null)
      depth++;
    let prefix2 = ASTQUtil.pad("", 4 * depth);
    return {
      prefix1,
      prefix2
    };
  }
  traceBegin(Q, T) {
    if (!this.trace)
      return;
    let {prefix1, prefix2} = this.prefixOf(Q, T);
    console.log("ASTQ: execute: | " + ASTQUtil.pad(prefix1 + Q.type() + " (", -60) + " | " + prefix2 + this.adapter.getNodeType(T));
  }
  traceEnd(Q, T, val) {
    if (!this.trace)
      return;
    let {prefix1, prefix2} = this.prefixOf(Q, T);
    let result;
    if (val === undefined)
      result = "undefined";
    else if (typeof val === "object" && val instanceof Array) {
      result = "[";
      val.forEach(node => {
        result += "node(" + this.adapter.getNodeType(node) + "),";
      });
      result = result.replace(/,$/, "") + "]";
    } else
      result = typeof val + "(" + val + ")";
    if (result.length > 60)
      result = result.substr(0, 60) + "...";
    console.log("ASTQ: execute: | " + ASTQUtil.pad(prefix1 + "): " + result, -60) + " | " + prefix2 + this.adapter.getNodeType(T));
  }
}

class ASTQQueryExec extends ASTQQueryTrace {
  constructor(adapter, params, funcs, trace) {
    super();
    this.adapter = adapter;
    this.params = params;
    this.funcs = funcs;
    this.trace = trace;
  }
  execQuery(Q, T) {
    this.traceBegin(Q, T);
    let output = [];
    Q.childs().forEach(Q => {
      output = output.concat(this.execPath(Q, T));
    });
    this.traceEnd(Q, T, output);
    return output;
  }
  execPath(Q, T) {
    this.traceBegin(Q, T);
    let nodes = [T];
    let result = [];
    let resultExplicit = false;
    Q.childs().forEach(Q => {
      let output = [];
      nodes.forEach(T => {
        output = output.concat(this.execStep(Q, T));
      });
      nodes = output;
      if (Q.get("isResult")) {
        resultExplicit = true;
        result = result.concat(nodes);
      }
    });
    this.traceEnd(Q, T, nodes);
    return resultExplicit ? result : nodes;
  }
  execStep(Q, T) {
    this.traceBegin(Q, T);
    let childs = Q.childs();
    let axis = null;
    let match = null;
    let filter = null;
    let i = 0;
    if (i < childs.length && childs[i].type() === "Axis")
      axis = childs[i++];
    if (i < childs.length && childs[i].type() === "Match")
      match = childs[i++];
    if (i < childs.length && childs[i].type() === "Filter")
      filter = childs[i++];
    if (match === null)
      throw new Error("no matching part in query step");
    let nodes = [];
    let id = match.get("id");
    let matchAndTake = T => {
      let type = this.adapter.getNodeType(T);
      if (id === "*" || id === type) {
        let take = true;
        if (filter !== null)
          if (!this.execFilter(filter, T))
            take = false;
        if (take)
          nodes.push(T);
      }
    };
    if (axis !== null) {
      let op = axis.get("op");
      let t = axis.get("type");
      if (op === "/") {
        this.adapter.getChildNodes(T, t).forEach(T => matchAndTake(T));
      } else if (op === "//") {
        let walk = T => {
          matchAndTake(T);
          this.adapter.getChildNodes(T, t).forEach(T => walk(T));
        };
        this.adapter.getChildNodes(T, t).forEach(T => walk(T));
      } else if (op === "./") {
        matchAndTake(T);
        this.adapter.getChildNodes(T, t).forEach(T => matchAndTake(T));
      } else if (op === ".//") {
        matchAndTake(T);
        let walk = T => {
          matchAndTake(T);
          this.adapter.getChildNodes(T, t).forEach(T => walk(T));
        };
        this.adapter.getChildNodes(T, t).forEach(T => walk(T));
      } else if (op === "-/") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          let leftSibling = null;
          for (let i = 0; i < pchilds.length; i++) {
            if (pchilds[i] === T)
              break;
            leftSibling = pchilds[i];
          }
          if (leftSibling !== null)
            matchAndTake(leftSibling);
        }
      } else if (op === "-//") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          let i = 0;
          for (; i < pchilds.length; i++)
            if (pchilds[i] === T)
              break;
          for (i--; i >= 0; i--)
            matchAndTake(pchilds[i]);
        }
      } else if (op === "+/") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          let i;
          for (i = 0; i < pchilds.length; i++)
            if (pchilds[i] === T)
              break;
          if (i < pchilds.length)
            matchAndTake(pchilds[++i]);
        }
      } else if (op === "+//") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          let i;
          for (i = 0; i < pchilds.length; i++)
            if (pchilds[i] === T)
              break;
          if (i < pchilds.length)
            for (i++; i < pchilds.length; i++)
              matchAndTake(pchilds[i]);
        }
      } else if (op === "~/") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          let i;
          for (i = 0; i < pchilds.length; i++)
            if (pchilds[i] === T)
              break;
          if (i > 0)
            matchAndTake(pchilds[i - 1]);
          if (i < pchilds.length - 1)
            matchAndTake(pchilds[i + 1]);
        }
      } else if (op === "~//") {
        let parent = this.adapter.getParentNode(T, "*");
        if (parent !== null) {
          let pchilds = this.adapter.getChildNodes(parent, t);
          for (let i = 0; i < pchilds.length; i++)
            if (pchilds[i] !== T)
              matchAndTake(pchilds[i]);
        }
      } else if (op === "../") {
        let parent = this.adapter.getParentNode(T, t);
        if (parent !== null)
          matchAndTake(parent);
      } else if (op === "..//") {
        let node = T;
        for (;;) {
          let parent = this.adapter.getParentNode(node, t);
          if (parent === null)
            break;
          matchAndTake(parent);
          node = parent;
        }
      } else if (op === "<//") {
        let ctx = {
          sentinel: T,
          take: true
        };
        for (;;) {
          let parent = this.adapter.getParentNode(T, "*");
          if (parent === null)
            break;
          T = parent;
        }
        let walk = T => {
          if (T === ctx.sentinel)
            ctx.take = false;
          if (ctx.take)
            matchAndTake(T);
          if (ctx.take)
            this.adapter.getChildNodes(T, t).forEach(T => walk(T));
        };
        if (T !== ctx.sentinel) {
          matchAndTake(T);
          this.adapter.getChildNodes(T, t).forEach(T => walk(T));
        }
        nodes = nodes.reverse();
      } else if (op === ">//") {
        let ctx = {
          sentinel: T,
          take: false
        };
        for (;;) {
          let parent = this.adapter.getParentNode(T, "*");
          if (parent === null)
            break;
          T = parent;
        }
        let walk = T => {
          if (ctx.take)
            matchAndTake(T);
          if (T === ctx.sentinel)
            ctx.take = true;
          this.adapter.getChildNodes(T, t).forEach(T => walk(T));
        };
        this.adapter.getChildNodes(T, t).forEach(T => walk(T));
      }
    } else
      matchAndTake(T);
    this.traceEnd(Q, T, nodes);
    return nodes;
  }
  execFilter(Q, T) {
    this.traceBegin(Q, T);
    let expr = Q.childs()[0];
    let result = this.execExpr(expr, T);
    result = ASTQUtil.truthy(result);
    this.traceEnd(Q, T, result);
    return result;
  }
  execExpr(Q, T) {
    switch (Q.type()) {
    case "ConditionalBinary":
      return this.execExprConditionalBinary(Q, T);
    case "ConditionalTernary":
      return this.execExprConditionalTernary(Q, T);
    case "Logical":
      return this.execExprLogical(Q, T);
    case "Bitwise":
      return this.execExprBitwise(Q, T);
    case "Relational":
      return this.execExprRelational(Q, T);
    case "Arithmetical":
      return this.execExprArithmetical(Q, T);
    case "Unary":
      return this.execExprUnary(Q, T);
    case "FuncCall":
      return this.execExprFuncCall(Q, T);
    case "Attribute":
      return this.execExprAttribute(Q, T);
    case "Param":
      return this.execExprParam(Q, T);
    case "LiteralString":
      return this.execExprLiteralString(Q, T);
    case "LiteralRegExp":
      return this.execExprLiteralRegExp(Q, T);
    case "LiteralNumber":
      return this.execExprLiteralNumber(Q, T);
    case "LiteralValue":
      return this.execExprLiteralValue(Q, T);
    case "Path":
      return this.execExprPath(Q, T);
    }
  }
  execExprConditionalBinary(Q, T) {
    this.traceBegin(Q, T);
    let result = this.execExpr(Q.childs()[0], T);
    if (!ASTQUtil.truthy(result))
      result = this.execExpr(Q.childs()[1], T);
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprConditionalTernary(Q, T) {
    this.traceBegin(Q, T);
    let result = this.execExpr(Q.childs()[0], T);
    if (ASTQUtil.truthy(result))
      result = this.execExpr(Q.childs()[1], T);
    else
      result = this.execExpr(Q.childs()[2], T);
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprLogical(Q, T) {
    this.traceBegin(Q, T);
    let result = false;
    switch (Q.get("op")) {
    case "&&":
      result = ASTQUtil.truthy(this.execExpr(Q.childs()[0], T));
      if (result)
        result = result && ASTQUtil.truthy(this.execExpr(Q.childs()[1], T));
      break;
    case "||":
      result = ASTQUtil.truthy(this.execExpr(Q.childs()[0], T));
      if (!result)
        result = result || ASTQUtil.truthy(this.execExpr(Q.childs()[1], T));
      break;
    }
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprBitwise(Q, T) {
    this.traceBegin(Q, T);
    let v1 = ASTQUtil.coerce(this.execExpr(Q.childs()[0], T), "number");
    let v2 = ASTQUtil.coerce(this.execExpr(Q.childs()[1], T), "number");
    let result;
    switch (Q.get("op")) {
    case "&":
      result = v1 & v2;
      break;
    case "|":
      result = v1 | v2;
      break;
    case "<<":
      result = v1 << v2;
      break;
    case ">>":
      result = v1 >> v2;
      break;
    }
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprRelational(Q, T) {
    this.traceBegin(Q, T);
    let v1 = this.execExpr(Q.childs()[0], T);
    let v2 = this.execExpr(Q.childs()[1], T);
    let result;
    switch (Q.get("op")) {
    case "==":
      result = v1 === v2;
      break;
    case "!=":
      result = v1 !== v2;
      break;
    case "<=":
      result = ASTQUtil.coerce(v1, "number") <= ASTQUtil.coerce(v2, "number");
      break;
    case ">=":
      result = ASTQUtil.coerce(v1, "number") >= ASTQUtil.coerce(v2, "number");
      break;
    case "<":
      result = ASTQUtil.coerce(v1, "number") < ASTQUtil.coerce(v2, "number");
      break;
    case ">":
      result = ASTQUtil.coerce(v1, "number") > ASTQUtil.coerce(v2, "number");
      break;
    case "=~":
      result = ASTQUtil.coerce(v1, "string").match(ASTQUtil.coerce(v2, "regexp")) !== null;
      break;
    case "!~":
      result = ASTQUtil.coerce(v1, "string").match(ASTQUtil.coerce(v2, "regexp")) === null;
      break;
    }
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprArithmetical(Q, T) {
    this.traceBegin(Q, T);
    let v1 = this.execExpr(Q.childs()[0], T);
    let v2 = this.execExpr(Q.childs()[1], T);
    let result;
    switch (Q.get("op")) {
    case "+":
      if (typeof v1 === "string")
        result = v1 + ASTQUtil.coerce(v2, "string");
      else
        result = ASTQUtil.coerce(v1, "number") + ASTQUtil.coerce(v2, "number");
      break;
    case "-":
      result = ASTQUtil.coerce(v1, "number") + ASTQUtil.coerce(v2, "number");
      break;
    case "*":
      result = ASTQUtil.coerce(v1, "number") * ASTQUtil.coerce(v2, "number");
      break;
    case "/":
      result = ASTQUtil.coerce(v1, "number") / ASTQUtil.coerce(v2, "number");
      break;
    case "%":
      result = ASTQUtil.coerce(v1, "number") % ASTQUtil.coerce(v2, "number");
      break;
    case "**":
      result = Math.pow(ASTQUtil.coerce(v1, "number"), ASTQUtil.coerce(v2, "number"));
      break;
    }
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprUnary(Q, T) {
    this.traceBegin(Q, T);
    let v = this.execExpr(Q.childs()[0], T);
    let result;
    switch (Q.get("op")) {
    case "!":
      result = !ASTQUtil.coerce(v, "boolean");
      break;
    case "~":
      result = ~ASTQUtil.coerce(v, "number");
      break;
    }
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprFuncCall(Q, T) {
    this.traceBegin(Q, T);
    let id = Q.get("id");
    let args = [
      this.adapter,
      T
    ];
    Q.childs().forEach(Q => {
      args.push(this.execExpr(Q, T));
    });
    let result = this.funcs.run(id, args);
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprAttribute(Q, T) {
    this.traceBegin(Q, T);
    let id = Q.get("id");
    let result = this.adapter.getNodeAttrValue(T, id);
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprParam(Q, T) {
    this.traceBegin(Q, T);
    let id = Q.get("id");
    if (typeof this.params[id] === "undefined")
      throw new Error("invalid parameter \"" + id + "\"");
    let result = this.params[id];
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprLiteralString(Q, T) {
    this.traceBegin(Q, T);
    let result = Q.get("value");
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprLiteralRegExp(Q, T) {
    this.traceBegin(Q, T);
    let result = Q.get("value");
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprLiteralNumber(Q, T) {
    this.traceBegin(Q, T);
    let result = Q.get("value");
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprLiteralValue(Q, T) {
    this.traceBegin(Q, T);
    let result = Q.get("value");
    this.traceEnd(Q, T, result);
    return result;
  }
  execExprPath(Q, T) {
    this.traceBegin(Q, T);
    let result = this.execPath(Q, T);
    this.traceEnd(Q, T, result);
    return result;
  }
}

const PEG = _1_2_17;
const ASTQQueryParse = PEG.generateFromFile(__dirname + "/astq-query-parse.pegjs", {
  optimize: "speed",
  cache: true
});
class ASTQQuery {
  constructor(selector) {
    this.asty = new ASTY();
    this.ast = null;
    if (selector)
      this.compile(selector);
  }
  compile(selector, trace) {
    if (trace)
      console.log("ASTQ: compile: +---------------------------------------" + "----------------------------------------------------------------\n" + "ASTQ: compile: | " + selector);
    let result = PEGUtil.parse(ASTQQueryParse, selector, {
      startRule: "query",
      makeAST: (line, column, offset, args) => {
        return this.asty.create.apply(this.asty, args).pos(line, column, offset);
      }
    });
    if (result.error !== null)
      throw new Error("ASTQ: compile: query parsing failed:\n" + PEGUtil.errorMessage(result.error, true).replace(/^/mg, "ERROR: "));
    this.ast = result.ast;
    if (trace)
      console.log("ASTQ: compile: +---------------------------------------" + "----------------------------------------------------------------\n" + this.dump().replace(/\n$/, "").replace(/^/mg, "ASTQ: compile: | "));
    return this;
  }
  dump() {
    return this.ast.dump();
  }
  execute(node, adapter, params, funcs, trace) {
    if (trace)
      console.log("ASTQ: execute: +---------------------------------------" + "----------------------------------------------------------------");
    let qe = new ASTQQueryExec(adapter, params, funcs, trace);
    return qe.execQuery(this.ast, node);
  }
}

let version = {
  major: 2,
  minor: 7,
  micro: 5,
  date: 20210107
};

class ASTQ$1 {
  constructor() {
    this._adapter = new ASTQAdapter().register(ASTQAdapterXMLDOM, false).register(ASTQAdapterParse5, false).register(ASTQAdapterMozAST, false).register(ASTQAdapterGraphQL, false).register(ASTQAdapterJSON, false).register(ASTQAdapterCheerio, false).register(ASTQAdapterUniST, false).register(ASTQAdapterASTY, false);
    this._funcs = new ASTQFuncs();
    for (let name in stdfuncs)
      this.func(name, stdfuncs[name]);
    this._cache = new CacheLRU();
  }
  version() {
    return version;
  }
  adapter(adapter, force = false) {
    if (arguments.length < 1 || arguments.length > 2)
      throw new Error("ASTQ#adapter: invalid number of arguments");
    this._adapter.unregister();
    if (!(typeof adapter === "object" && adapter instanceof Array))
      adapter = [adapter];
    if (adapter.length > 1 && force)
      throw new Error("ASTQ#adapter: you can force just a single adapter to not taste the AST node");
    adapter.forEach(adapter => {
      if (typeof adapter === "string") {
        if (adapter === "mozast")
          adapter = ASTQAdapterMozAST;
        else if (adapter === "graphql")
          adapter = ASTQAdapterGraphQL;
        else if (adapter === "xmldom")
          adapter = ASTQAdapterXMLDOM;
        else if (adapter === "parse5")
          adapter = ASTQAdapterParse5;
        else if (adapter === "json")
          adapter = ASTQAdapterJSON;
        else if (adapter === "cheerio")
          adapter = ASTQAdapterCheerio;
        else if (adapter === "unist")
          adapter = ASTQAdapterUniST;
        else if (adapter === "asty")
          adapter = ASTQAdapterASTY;
        else
          throw new Error("ASTQ#adapter: unknown built-in adapter");
      }
      this._adapter.register(adapter, force);
    });
    return this;
  }
  func(name, func) {
    if (arguments.length !== 2)
      throw new Error("ASTQ#func: invalid number of arguments");
    this._funcs.register(name, func);
    return this;
  }
  cache(entries) {
    if (arguments.length !== 1)
      throw new Error("ASTQ#cache: invalid number of arguments");
    this._cache.limit(entries);
    return this;
  }
  compile(selector, trace) {
    if (arguments.length < 1)
      throw new Error("ASTQ#compile: too less arguments");
    if (arguments.length > 2)
      throw new Error("ASTQ#compile: too many arguments");
    if (trace === undefined)
      trace = false;
    let query = this._cache.get(selector);
    if (query === undefined) {
      query = new ASTQQuery();
      query.compile(selector, trace);
      this._cache.set(selector, query);
    }
    return query;
  }
  execute(node, query, params, trace) {
    if (arguments.length < 2)
      throw new Error("ASTQ#execute: too less arguments");
    if (arguments.length > 4)
      throw new Error("ASTQ#execute: too many arguments");
    if (params === undefined)
      params = {};
    if (trace === undefined)
      trace = false;
    let adapter = this._adapter.select(node);
    if (adapter === undefined)
      throw new Error("ASTQ#execute: no suitable adapter found for node");
    return query.execute(node, adapter, params, this._funcs, trace);
  }
  query(node, selector, params, trace) {
    if (arguments.length < 2)
      throw new Error("ASTQ#query: too less arguments");
    if (arguments.length > 4)
      throw new Error("ASTQ#query: too many arguments");
    if (params === undefined)
      params = {};
    if (trace === undefined)
      trace = false;
    return this.execute(node, this.compile(selector, trace), params, trace);
  }
}

var astq$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': ASTQ$1
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(astq$1);

let ASTQ = ASTQ$1 || require$$0;
class AllNodesVisitor extends Visitor {
  accept(node, state, path) {
    this.doFunc(node, state, path);
    return super.accept(node, state, path);
  }
  static run(parsed, doFunc, state) {
    const v = new this();
    v.doFunc = doFunc;
    v.accept(parsed, state, []);
    return state;
  }
}
class FindToplevelFuncDeclVisitor extends Visitor {
  accept(node, funcDecls, path) {
    switch (node.type) {
    case "ArrowFunctionExpression":
      return node;
    case "FunctionExpression":
      return node;
    case "FunctionDeclaration":
      funcDecls.unshift({
        node,
        path
      });
      return node;
    default:
      return super.accept(node, funcDecls, path);
    }
  }
  static run(parsed) {
    const state = [];
    new this().accept(parsed, state, []);
    return state;
  }
}
const canBeInlinedSym = Symbol("canBeInlined");
function blockInliner(node) {
  if (Array.isArray(node.body)) {
    for (let i = node.body.length - 1; i >= 0; i--) {
      const stmt = node.body[i];
      if (stmt.type === "BlockStatement" && stmt[canBeInlinedSym]) {
        node.body.splice.apply(node.body, [
          i,
          1
        ].concat(stmt.body));
      }
    }
  }
  return node;
}
function block$1(nodes) {
  return {
    type: "BlockStatement",
    body: nodes
  };
}
class ReplaceManyVisitor extends Visitor {
  accept(node, state, path) {
    const replaced = this.replacer(super.accept(node, state, path));
    return !Array.isArray(replaced) ? replaced : replaced.length === 1 ? replaced[0] : Object.assign(block$1(replaced), { [canBeInlinedSym]: true });
  }
  visitBlockStatement(node, state, path) {
    return blockInliner(super.visitBlockStatement(node, state, path));
  }
  visitProgram(node, state, path) {
    return blockInliner(super.visitProgram(node, state, path));
  }
  static run(parsed, replacer) {
    const v = new this();
    v.replacer = replacer;
    return v.accept(parsed, null, []);
  }
}
class ReplaceVisitor extends Visitor {
  accept(node, state, path) {
    return this.replacer(super.accept(node, state, path), path);
  }
  static run(parsed, replacer) {
    const v = new this();
    v.replacer = replacer;
    return v.accept(parsed, null, []);
  }
}
const astq = new ASTQ();
astq.adapter("mozast");

custom.addSource = addSource;
function addSource(parsed, source) {
  if (typeof parsed === "string") {
    source = parsed;
    parsed = parse(parsed);
  }
  source && AllNodesVisitor.run(parsed, (node, state, path) => !node.source && (node.source = source.slice(node.start, node.end)));
  return parsed;
}
function nodesAt$1(pos, ast) {
  ast = typeof ast === "string" ? this.parse(ast) : ast;
  return findNodesIncluding(ast, pos);
}
function parseFunction(source, options = {}) {
  const src = "(" + source + ")";
  const offset = -1;
  const parsed = parse(src, options);
  AllNodesVisitor.run(parsed, (node, state, path) => {
    if (node._positionFixed)
      return;
    node._positionFixed = true;
    if (node.start || node.start === 0) {
      node.start += offset;
      node.end += offset;
    }
    if (options.addSource && !node.source) {
      node.source = source.slice(node.start, node.end);
    }
  });
  return parsed.body[0].expression;
}
function fuzzyParse(source, options) {
  options = options || {};
  options.ecmaVersion = options.ecmaVersion || 11;
  options.sourceType = options.sourceType || "module";
  options.plugins = options.plugins || {};
  options.plugins.jsx = options.plugins.hasOwnProperty("jsx") ? options.plugins.jsx : true;
  options.plugins.asyncawait = options.plugins.hasOwnProperty("asyncawait") ? options.plugins.asyncawait : { inAsyncFunction: true };
  options.plugins.objectSpread = options.plugins.hasOwnProperty("objectSpread") ? options.plugins.objectSpread : true;
  let ast, safeSource, err;
  if (options.type === "LabeledStatement") {
    safeSource = "$={" + source + "}";
  }
  try {
    ast = parse(safeSource || source, options);
    if (safeSource)
      ast = null;
    else if (options.addSource)
      addSource(ast, source);
  } catch (e) {
    err = e;
  }
  if (err && err.raisedAt !== undefined) {
    if (safeSource) {
      err.pos -= 3;
      err.raisedAt -= 3;
      err.loc.column -= 3;
    }
    let parseErrorSource = "";
    parseErrorSource += source.slice(err.raisedAt - 20, err.raisedAt);
    parseErrorSource += "<-error->";
    parseErrorSource += source.slice(err.raisedAt, err.raisedAt + 20);
    options.verbose && console.log("parse error: " + parseErrorSource);
    err.parseErrorSource = parseErrorSource;
  } else if (err && options.verbose) {
    console.log("" + err + err.stack);
  }
  if (!ast) {
    ast = acornLoose.exports.parse(source, options);
    if (options.addSource)
      addSource(ast, source);
    ast.isFuzzy = true;
    ast.parseError = err;
  }
  return ast;
}
function parse(source, options) {
  options = options || {};
  options.ecmaVersion = options.ecmaVersion || 11;
  options.allowAwaitOutsideFunction = true;
  options.sourceType = options.sourceType || "module";
  if (!options.hasOwnProperty("allowImportExportEverywhere")) {
    options.allowImportExportEverywhere = true;
  }
  options.plugins = options.plugins || {};
  options.plugins.jsx = options.plugins.hasOwnProperty("jsx") ? options.plugins.jsx : true;
  options.plugins.asyncawait = options.plugins.hasOwnProperty("asyncawait") ? options.plugins.asyncawait : { inAsyncFunction: true };
  options.plugins.objectSpread = options.plugins.hasOwnProperty("objectSpread") ? options.plugins.objectSpread : true;
  if (options.withComments) {
    delete options.withComments;
    var comments = [];
    options.onComment = function (isBlock, text, start, end, line, column) {
      comments.push({
        isBlock: isBlock,
        text: text,
        node: null,
        start: start,
        end: end,
        line: line,
        column: column
      });
    };
  }
  try {
    var parsed = acorn.parse(source, options);
  } catch (err) {
    if (typeof SyntaxError !== "undefined" && err instanceof SyntaxError && err.loc) {
      const lines = source.split("\n");
      const {
        message,
        loc: {
          line: row,
          column
        },
        pos
      } = err;
      const line = lines[row - 1];
      const newMessage = `Syntax error at line ${ row } column ${ column } (index ${ pos }) "${ message }"\nsource: ${ line.slice(0, column) }<--SyntaxError-->${ line.slice(column) }`;
      const betterErr = new SyntaxError(newMessage);
      betterErr.loc = {
        line: row,
        column
      };
      betterErr.pos = pos;
      throw betterErr;
    } else
      throw err;
  }
  if (options.addSource)
    addSource(parsed, source);
  if (options.addAstIndex && !parsed.hasOwnProperty("astIndex"))
    addAstIndex(parsed);
  if (parsed && comments)
    attachCommentsToAST({
      ast: parsed,
      comments: comments,
      nodesWithComments: []
    });
  return parsed;
  function attachCommentsToAST(commentData) {
    commentData = mergeComments(assignCommentsToBlockNodes(commentData));
    parsed.allComments = commentData.comments;
  }
  function assignCommentsToBlockNodes(commentData) {
    comments.forEach(function (comment) {
      let node = nodesAt$1(comment.start, parsed).reverse().find(function (node) {
        return node.type === "BlockStatement" || node.type === "Program";
      });
      if (!node)
        node = parsed;
      if (!node.comments)
        node.comments = [];
      node.comments.push(comment);
      commentData.nodesWithComments.push(node);
    });
    return commentData;
  }
  function mergeComments(commentData) {
    commentData.nodesWithComments.forEach(function (blockNode) {
      clone$1(blockNode.comments).reduce(function (coalesceData, comment) {
        if (comment.isBlock) {
          coalesceData.lastComment = null;
          return coalesceData;
        }
        if (!coalesceData.lastComment) {
          coalesceData.lastComment = comment;
          return coalesceData;
        }
        const last = coalesceData.lastComment;
        const nodeInbetween = blockNode.body.find(function (node) {
          return node.start >= last.end && node.end <= comment.start;
        });
        if (nodeInbetween) {
          coalesceData.lastComment = comment;
          return coalesceData;
        }
        const codeInBetween = source.slice(last.end, comment.start);
        if (/[\n\r][\n\r]+/.test(codeInBetween)) {
          coalesceData.lastComment = comment;
          return coalesceData;
        }
        last.text += "\n" + comment.text;
        last.end = comment.end;
        remove(blockNode.comments, comment);
        remove(commentData.comments, comment);
        return coalesceData;
      }, { lastComment: null });
    });
    return commentData;
  }
}

const methods = {
  withMozillaAstDo: function (parsed, state, func) {
    const vis = new Visitor();
    const origAccept = vis.accept;
    vis.accept = function (node, st, path) {
      const next = function () {
        origAccept.call(vis, node, st, path);
      };
      state = func(next, node, st, path);
      return node;
    };
    vis.accept(parsed, state, []);
    return state;
  },
  printAst: function (astOrSource, options) {
    options = options || {};
    const printSource = options.printSource || false;
    const printPositions = options.printPositions || false;
    const printIndex = options.printIndex || false;
    let source;
    let parsed;
    const tree = [];
    if (typeof astOrSource === "string") {
      source = astOrSource;
      parsed = parse(astOrSource);
    } else {
      parsed = astOrSource;
      source = options.source || parsed.source;
    }
    if (printSource && !parsed.source) {
      if (!source) {
        source = stringify(parsed);
        parsed = parse(source);
      }
      addSource(parsed, source);
    }
    function printFunc(ea) {
      let line = ea.path + ":" + ea.node.type;
      const additional = [];
      if (printIndex) {
        additional.push(ea.index);
      }
      if (printPositions) {
        additional.push(ea.node.start + "-" + ea.node.end);
      }
      if (printSource) {
        const src = ea.node.source || source.slice(ea.node.start, ea.node.end);
        const printed = print(src.truncate(60).replace(/\n/g, "").replace(/\s+/g, " "));
        additional.push(printed);
      }
      if (additional.length) {
        line += "(" + additional.join(",") + ")";
      }
      return line;
    }
    new PrinterVisitor().accept(parsed, {
      index: 0,
      tree: tree
    }, []);
    return printTree(tree[0], printFunc, ea => ea.children, "  ");
  },
  compareAst: function (node1, node2) {
    if (!node1 || !node2)
      throw new Error("node" + (node1 ? "1" : "2") + " not defined");
    const state = {
      completePath: [],
      comparisons: { errors: [] }
    };
    new ComparisonVisitor().accept(node1, node2, state, []);
    return !state.comparisons.errors.length ? null : state.comparisons.errors.pluck("msg");
  },
  pathToNode: function (parsed, index, options) {
    if (!parsed.astIndex)
      addAstIndex(parsed);
    const vis = new Visitor();
    let found = null;
    (vis.accept = function (node, pathToHere, state, path) {
      if (found)
        return;
      const fullPath = pathToHere.concat(path);
      if (node.astIndex === index) {
        const pathString = fullPath.map(function (ea) {
          return typeof ea === "string" ? "." + ea : "[" + ea + "]";
        }).join("");
        found = {
          pathString: pathString,
          path: fullPath,
          node: node
        };
      }
      return this["visit" + node.type](node, fullPath, state, path);
    }).call(vis, parsed, [], {}, []);
    return found;
  },
  rematchAstWithSource: function (parsed, source, addLocations, subTreePath) {
    addLocations = !!addLocations;
    let parsed2 = parse(source, addLocations ? { locations: true } : undefined);
    const visitor = new Visitor();
    if (subTreePath)
      parsed2 = Path(subTreePath).get(parsed2);
    visitor.accept = function (node, state, path) {
      path = path || [];
      const node2 = path.reduce((node, pathElem) => node[pathElem], parsed);
      node2.start = node.start;
      node2.end = node.end;
      if (addLocations)
        node2.loc = node.loc;
      return this["visit" + node.type](node, state, path);
    };
    visitor.accept(parsed2);
  }
};
const withMozillaAstDo = methods.withMozillaAstDo;
const printAst = methods.printAst;
const compareAst = methods.compareAst;
const pathToNode = methods.pathToNode;
const rematchAstWithSource = methods.rematchAstWithSource;

const identifierRe = /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function isIdentifier(string) {
  return identifierRe.test(string) && string.indexOf("-") === -1;
}
function id(name) {
  return name === "this" ? { type: "ThisExpression" } : {
    name: String(name),
    type: "Identifier"
  };
}
function literal(value) {
  return {
    type: "Literal",
    value: value
  };
}
function exprStmt(expression) {
  return {
    type: "ExpressionStatement",
    expression: expression
  };
}
function sqncExpr(...expressions) {
  return {
    type: "SequenceExpression",
    expressions
  };
}
function returnStmt(expr) {
  return {
    type: "ReturnStatement",
    argument: expr
  };
}
function empty() {
  return { type: "EmptyStatement" };
}
function binaryExpr(left, op, right) {
  return {
    left: left,
    right: right,
    operator: op,
    type: "BinaryExpression"
  };
}
function funcExpr({
  arrow,
  id: funcId,
  expression,
  generator
}, params = [], ...statements) {
  params = params.map(ea => typeof ea === "string" ? id(ea) : ea);
  return {
    type: (arrow ? "Arrow" : "") + "FunctionExpression",
    id: funcId ? typeof funcId === "string" ? id(funcId) : funcId : undefined,
    params: params,
    body: expression && statements.length === 1 ? statements[0] : {
      body: statements,
      type: "BlockStatement"
    },
    expression: expression || false,
    generator: generator || false
  };
}
function funcCall(callee, ...args) {
  if (typeof callee === "string")
    callee = id(callee);
  return {
    type: "CallExpression",
    callee: callee,
    arguments: args
  };
}
function varDecl(id, init, kind) {
  if (typeof id === "string")
    id = {
      name: id,
      type: "Identifier"
    };
  return {
    type: "VariableDeclaration",
    kind: kind || "var",
    declarations: [{
        type: "VariableDeclarator",
        id: id,
        init: init
      }]
  };
}
function member(obj, prop, computed) {
  if (typeof obj === "string")
    obj = id(obj);
  if (typeof prop === "string") {
    if (!computed && !isIdentifier(prop))
      computed = true;
    prop = computed ? literal(prop) : id(prop);
  } else if (typeof prop === "number") {
    prop = literal(prop);
    computed = true;
  } else if (prop.type === "Literal") {
    computed = true;
  }
  return {
    type: "MemberExpression",
    computed: !!computed,
    object: obj,
    property: prop
  };
}
function memberChain(first, ...rest) {
  return rest.reduce((memberExpr, key) => member(memberExpr, key), typeof first === "object" ? first : id(first));
}
function assign(left, right) {
  return {
    type: "AssignmentExpression",
    operator: "=",
    right: right ? typeof right === "string" ? id(right) : right : id("undefined"),
    left: typeof left === "string" ? id(left) : left
  };
}
function block(...body) {
  return {
    body: Array.isArray(body[0]) ? body[0] : body,
    type: "BlockStatement"
  };
}
function program(...body) {
  return Object.assign(block(...body), {
    sourceType: "module",
    type: "Program"
  });
}
function tryStmt(exName, handlerBody, finalizerBody, ...body) {
  if (!Array.isArray(finalizerBody)) {
    body.unshift(finalizerBody);
    finalizerBody = null;
  }
  return {
    block: block(body),
    finalizer: finalizerBody ? block(finalizerBody) : null,
    handler: {
      body: block(handlerBody),
      param: id(exName),
      type: "CatchClause"
    },
    type: "TryStatement"
  };
}
function prop(key, value) {
  return {
    type: "Property",
    key: key,
    computed: key.type !== "Identifier",
    shorthand: false,
    value: value
  };
}
function objectLiteral(keysAndValues) {
  const props = [];
  for (let i = 0; i < keysAndValues.length; i += 2) {
    let key = keysAndValues[i];
    if (typeof key === "string")
      key = id(key);
    props.push(prop(key, keysAndValues[i + 1]));
  }
  return {
    properties: props,
    type: "ObjectExpression"
  };
}
function ifStmt(test, consequent = block(), alternate = block()) {
  return {
    consequent,
    alternate,
    test,
    type: "IfStatement"
  };
}
function forIn(varDeclOrName, objExprOrName, body) {
  return {
    type: "ForInStatement",
    left: typeof varDeclOrName === "string" ? varDecl(varDeclOrName) : varDeclOrName,
    right: typeof objExprOrName === "string" ? id(objExprOrName) : objExprOrName,
    body
  };
}
function conditional(test, consequent = id("undefined"), alternate = id("undefined")) {
  return {
    consequent,
    alternate,
    test,
    type: "ConditionalExpression"
  };
}
function logical(op, left, right) {
  return {
    operator: op,
    left,
    right,
    type: "LogicalExpression"
  };
}

var nodes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isIdentifier: isIdentifier,
  id: id,
  literal: literal,
  objectLiteral: objectLiteral,
  prop: prop,
  exprStmt: exprStmt,
  returnStmt: returnStmt,
  empty: empty,
  sqncExpr: sqncExpr,
  binaryExpr: binaryExpr,
  funcExpr: funcExpr,
  funcCall: funcCall,
  varDecl: varDecl,
  member: member,
  memberChain: memberChain,
  assign: assign,
  block: block,
  program: program,
  tryStmt: tryStmt,
  ifStmt: ifStmt,
  forIn: forIn,
  conditional: conditional,
  logical: logical
});

var helpers = {
  declIds(nodes, result = []) {
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node)
        continue;
      else if (node.type === "Identifier")
        result.push(node);
      else if (node.type === "RestElement")
        result.push(node.argument);
      else if (node.type === "AssignmentPattern")
        helpers.declIds([node.left], result);
      else if (node.type === "ObjectPattern") {
        for (let j = 0; j < node.properties.length; j++) {
          const prop = node.properties[j];
          helpers.declIds([prop.value || prop], result);
        }
      } else if (node.type === "ArrayPattern") {
        helpers.declIds(node.elements, result);
      }
    }
    return result;
  },
  varDecls(scope, result = []) {
    for (const varDecl of scope.varDecls) {
      for (const decl of varDecl.declarations) {
        for (const id of helpers.declIds([decl.id])) {
          result.push([
            decl,
            id
          ]);
        }
      }
    }
    return result;
  },
  varDeclIds(scope, result = []) {
    for (const varDecl of scope.varDecls) {
      for (const decl of varDecl.declarations) {
        helpers.declIds([decl.id], result);
      }
    }
    return result;
  },
  objPropertiesAsList(objExpr, path, onlyLeafs, result = []) {
    for (const prop of objExpr.properties) {
      const key = prop.key.name;
      const thisNode = {
        key: path.concat([key]),
        value: prop.value
      };
      switch (prop.value.type) {
      case "ArrayExpression":
      case "ArrayPattern":
        if (!onlyLeafs)
          result.push(thisNode);
        for (let i = 0; i < prop.value.elements.length; i++) {
          const el = prop.value.elements[i];
          helpers.objPropertiesAsList(el, path.concat([
            key,
            i
          ]), onlyLeafs, result);
        }
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        if (!onlyLeafs)
          result.push(thisNode);
        helpers.objPropertiesAsList(prop.value, path.concat([key]), onlyLeafs, result);
        break;
      case "AssignmentPattern":
        if (!onlyLeafs)
          result.push(thisNode);
        helpers.objPropertiesAsList(prop.left, path.concat([key]), onlyLeafs, result);
        break;
      default:
        result.push(thisNode);
      }
    }
    return result;
  },
  isDeclaration(node) {
    return node.type === "FunctionDeclaration" || node.type === "VariableDeclaration" || node.type === "ClassDeclaration";
  }
};
const knownGlobals = [
  "closed",
  "true",
  "false",
  "null",
  "undefined",
  "arguments",
  "Object",
  "Function",
  "Array",
  "Number",
  "parseFloat",
  "parseInt",
  "Infinity",
  "NaN",
  "Boolean",
  "String",
  "Symbol",
  "Date",
  "Promise",
  "RegExp",
  "Error",
  "EvalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError",
  "JSON",
  "Math",
  "console",
  "ArrayBuffer",
  "Uint8Array",
  "Int8Array",
  "Uint16Array",
  "Int16Array",
  "Uint32Array",
  "Int32Array",
  "Float32Array",
  "Float64Array",
  "Uint8ClampedArray",
  "DataView",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "Proxy",
  "Reflect",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape",
  "eval",
  "isFinite",
  "isNaN",
  "Intl",
  "navigator",
  "window",
  "document",
  "Blob",
  "setTimeout",
  "clearTimeout",
  "setInterval",
  "clearInterval",
  "requestAnimationFrame",
  "cancelAnimationFrame",
  "btoa",
  "atob",
  "sessionStorage",
  "localStorage",
  "$world",
  "lively",
  "System",
  "customElements",
  "performance",
  "addEventListener",
  "closed"
];
function scopes(parsed) {
  const vis = new ScopeVisitor();
  const scope = vis.newScope(parsed, null);
  vis.accept(parsed, scope, []);
  return scope;
}
function nodesAtIndex(parsed, index) {
  return withMozillaAstDo(parsed, [], function (next, node, found) {
    if (node.start <= index && index <= node.end) {
      found.push(node);
      next();
    }
    return found;
  });
}
function scopesAtIndex(parsed, index) {
  return filter(scopes(parsed), scope => {
    const n = scope.node;
    let start = n.start;
    let end = n.end;
    if (n.type === "FunctionDeclaration") {
      start = n.params.length ? n.params[0].start : n.body.start;
      end = n.body.end;
    }
    return start <= index && index <= end;
  }, s => s.subScopes);
}
function scopeAtIndex(parsed, index) {
  return last(scopesAtIndex(parsed, index));
}
function scopesAtPos(pos, parsed) {
  return nodesAt(pos, parsed).filter(function (node) {
    return node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression";
  });
}
function nodesInScopeOf(node) {
  return withMozillaAstDo(node, {
    root: node,
    result: []
  }, function (next, node, state) {
    state.result.push(node);
    if (node !== state.root && (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression"))
      return state;
    next();
    return state;
  }).result;
}
function declarationsOfScope(scope, includeOuter, result = []) {
  if (includeOuter && scope.node.id && scope.node.id.name) {
    result.push(scope.node.id);
  }
  helpers.declIds(scope.params, result);
  for (var i = 0; i < scope.funcDecls.length; i++) {
    var id = scope.funcDecls[i].id;
    if (id)
      result.push(id);
  }
  helpers.varDeclIds(scope, result);
  result.push(...scope.catches);
  for (var i = 0; i < scope.classDecls.length; i++) {
    var id = scope.classDecls[i].id;
    if (id)
      result.push(id);
  }
  result.push(...scope.importSpecifiers);
  return compact(result);
}
function declarationsWithIdsOfScope(scope) {
  const bareIds = compact(helpers.declIds(scope.params).concat(scope.catches));
  const declNodes = [
    ...scope.node.id && scope.node.id.name ? [scope.node] : [],
    ...scope.funcDecls.filter(ea => ea.id),
    ...scope.classDecls.filter(ea => ea.id)
  ];
  return bareIds.map(ea => [
    ea,
    ea
  ]).concat(declNodes.map(ea => [
    ea,
    ea.id
  ])).concat(helpers.varDecls(scope)).concat(scope.importSpecifiers.map(im => {
    return [
      statementOf(scope.node, im),
      im
    ];
  }));
}
function _declaredVarNames(scope, useComments) {
  const result = [];
  for (const decl of declarationsOfScope(scope, true)) {
    result.push(decl.name);
  }
  if (useComments) {
    _findJsLintGlobalDeclarations(scope.node.type === "Program" ? scope.node : scope.node.body, result);
  }
  return result;
}
const globalDeclRe = /^\s*global\s*/;
function _findJsLintGlobalDeclarations(node, result = []) {
  if (!node || !node.comments)
    return result;
  for (const comment of node.comments) {
    const text = comment.text.trim();
    if (!text.startsWith("global"))
      continue;
    for (const globalDecl of text.replace(globalDeclRe, "").split(",")) {
      result.push(globalDecl.trim());
    }
  }
  return result;
}
function topLevelFuncDecls(parsed) {
  return FindToplevelFuncDeclVisitor.run(parsed);
}
function resolveReference(ref, scopePath) {
  if (scopePath.length == 0)
    return [
      null,
      null
    ];
  const [scope, ...outer] = scopePath;
  const decls = scope.decls || declarationsWithIdsOfScope(scope);
  scope.decls = decls;
  const decl = decls.find(([_, id]) => id.name == ref);
  return decl || resolveReference(ref, outer);
}
function resolveReferences(scope) {
  function rec(scope, outerScopes) {
    const path = [scope].concat(outerScopes);
    scope.refs.forEach(ref => {
      const [decl, id] = resolveReference(ref.name, path);
      map.set(ref, {
        decl,
        declId: id,
        ref
      });
    });
    scope.subScopes.forEach(s => rec(s, path));
  }
  if (scope.referencesResolvedSafely)
    return scope;
  var map = scope.resolvedRefMap || (scope.resolvedRefMap = new Map());
  rec(scope, []);
  scope.referencesResolvedSafely = true;
  return scope;
}
function refWithDeclAt(pos, scope) {
  for (const ref of scope.resolvedRefMap.values()) {
    const {
      ref: {start, end}
    } = ref;
    if (start <= pos && pos <= end)
      return ref;
  }
}
function topLevelDeclsAndRefs(parsed, options) {
  options = options || {};
  options.withComments = true;
  if (typeof parsed === "string")
    parsed = parse(parsed, options);
  const scope = scopes(parsed);
  const useComments = !!options.jslintGlobalComment;
  const declared = _declaredVarNames(scope, useComments);
  const refs = scope.refs.concat(scope.subScopes.map(findUndeclaredReferences).flat());
  const undeclared = withoutAll(refs.map(ea => ea.name), declared);
  return {
    scope: scope,
    varDecls: scope.varDecls,
    funcDecls: scope.funcDecls.filter(ea => ea.id),
    classDecls: scope.classDecls.filter(ea => ea.id),
    declaredNames: declared,
    undeclaredNames: undeclared,
    refs: refs,
    thisRefs: scope.thisRefs
  };
  function findUndeclaredReferences(scope) {
    const names = _declaredVarNames(scope, useComments);
    return scope.subScopes.map(findUndeclaredReferences).reduce(function (refs, ea) {
      return refs.concat(ea);
    }, scope.refs).filter(function (ref) {
      return names.indexOf(ref.name) === -1;
    });
  }
}
function findGlobalVarRefs(parsed, options) {
  const topLevel = topLevelDeclsAndRefs(parsed, options);
  const noGlobals = topLevel.declaredNames.concat(knownGlobals);
  return topLevel.refs.filter(function (ea) {
    return noGlobals.indexOf(ea.name) === -1;
  });
}
function findNodesIncludingLines(parsed, code, lines, options) {
  if (!code && !parsed)
    throw new Error("Need at least ast or code");
  code = code || stringify(parsed);
  parsed = parsed && parsed.loc ? parsed : parse(code, { locations: true });
  return withMozillaAstDo(parsed, [], (next, node, found) => {
    if (lines.every(line => between(line, node.loc.start.line, node.loc.end.line))) {
      pushIfNotIncluded(found, node);
      next();
    }
    return found;
  });
}
function __varDeclIdsFor(scope, name) {
  const result = [];
  for (var ea of scope.params)
    if (ea.name === name)
      result.push(ea);
  for (var ea of scope.funcDecls)
    if (ea.id && ea.id.name === name)
      result.push(ea.id);
  for (var ea of scope.classDecls)
    if (ea.id && ea.id.name === name)
      result.push(ea.id);
  for (var ea of scope.importSpecifiers)
    if (ea.name === name)
      result.push(ea);
  for (var ea of helpers.varDeclIds(scope))
    if (ea.name === name)
      result.push(ea);
  return result;
}
function findReferencesAndDeclsInScope(scope, name, startingScope = true, result = {
  refs: [],
  decls: []
}) {
  if (name === "this") {
    result.refs.push(...scope.thisRefs);
    return result;
  }
  const decls = __varDeclIdsFor(scope, name);
  if (!startingScope && decls.length)
    return result;
  for (const ref of scope.refs)
    if (ref.name === name)
      result.refs.push(ref);
  result.decls.push(...decls);
  for (const subScope of scope.subScopes) {
    findReferencesAndDeclsInScope(subScope, name, false, result);
  }
  return result;
}
function findDeclarationClosestToIndex(parsed, name, index) {
  let found = null;
  scopesAtIndex(parsed, index).reverse().find(scope => {
    const decls = declarationsOfScope(scope, true);
    const idx = pluck(decls, "name").indexOf(name);
    if (idx === -1)
      return false;
    found = decls[idx];
    return true;
  });
  return found;
}
function nodesAt(pos, ast) {
  ast = typeof ast === "string" ? parse(ast) : ast;
  return custom.findNodesIncluding(ast, pos);
}
const _stmtTypes = [
  "EmptyStatement",
  "BlockStatement",
  "ExpressionStatement",
  "IfStatement",
  "BreakStatement",
  "ContinueStatement",
  "WithStatement",
  "ReturnStatement",
  "ThrowStatement",
  "TryStatement",
  "WhileStatement",
  "DoWhileStatement",
  "ForStatement",
  "ForInStatement",
  "ForOfStatement",
  "DebuggerStatement",
  "FunctionDeclaration",
  "VariableDeclaration",
  "ClassDeclaration",
  "ImportDeclaration",
  "ImportDeclaration",
  "ExportNamedDeclaration",
  "ExportDefaultDeclaration",
  "ExportAllDeclaration"
];
function statementOf(parsed, node, options) {
  const nodes = nodesAt(node.start, parsed);
  const found = nodes.reverse().find(node => _stmtTypes.includes(node.type));
  if (options && options.asPath) {
    const v = new Visitor();
    let foundPath;
    v.accept = wrap(v.accept, (proceed, node, state, path) => {
      if (node === found) {
        foundPath = path;
        throw new Error("stop search");
      }
      return proceed(node, state, path);
    });
    try {
      v.accept(parsed, {}, []);
    } catch (e) {
    }
    return foundPath;
  }
  return found;
}
function imports(scope) {
  const imports = [];
  const stmts = scope.node.body || [];
  for (let i = 0; i < stmts.length; i++) {
    var stmt = stmts[i];
    if (stmt.type !== "ImportDeclaration")
      continue;
    if (stmt.specifiers.length === 0) {
      imports.push({
        local: null,
        imported: null,
        fromModule: stmt.source.value,
        node: stmt
      });
      continue;
    }
    var from = stmt.source ? stmt.source.value : "unknown module";
    imports.push(...stmt.specifiers.map(importSpec => {
      let imported;
      if (importSpec.type === "ImportNamespaceSpecifier")
        imported = "*";
      else if (importSpec.type === "ImportDefaultSpecifier")
        imported = "default";
      else if (importSpec.type === "ImportSpecifier")
        imported = importSpec.imported.name;
      else
        imported = null;
      return {
        local: importSpec.local ? importSpec.local.name : null,
        imported: imported,
        fromModule: from,
        node: stmt
      };
    }));
  }
  return imports;
}
function exports$1(scope, resolve = false) {
  if (resolve)
    resolveReferences(scope);
  const exports = [];
  for (const node of scope.exportDecls) {
    var exportsStmt = statementOf(scope.node, node);
    if (!exportsStmt)
      continue;
    var from = exportsStmt.source ? exportsStmt.source.value : null;
    if (exportsStmt.type === "ExportAllDeclaration") {
      exports.push({
        local: null,
        exported: "*",
        imported: "*",
        fromModule: from,
        node: node,
        type: "all"
      });
      continue;
    }
    if (exportsStmt.type === "ExportDefaultDeclaration") {
      if (helpers.isDeclaration(exportsStmt.declaration)) {
        exports.push({
          local: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : null,
          exported: "default",
          type: exportsStmt.declaration.type === "FunctionDeclaration" ? "function" : exportsStmt.declaration.type === "ClassDeclaration" ? "class" : null,
          fromModule: null,
          node: node,
          decl: exportsStmt.declaration,
          declId: exportsStmt.declaration.id
        });
        continue;
      }
      if (exportsStmt.declaration.type === "Identifier") {
        const {decl, declId} = scope.resolvedRefMap.get(exportsStmt.declaration) || {};
        exports.push({
          local: exportsStmt.declaration.name,
          exported: "default",
          fromModule: null,
          node: node,
          type: "id",
          decl,
          declId
        });
        continue;
      }
      exports.push({
        local: null,
        exported: "default",
        fromModule: null,
        node: node,
        type: "expr",
        decl: exportsStmt.declaration,
        declId: exportsStmt.declaration
      });
      continue;
    }
    if (exportsStmt.specifiers && exportsStmt.specifiers.length) {
      exports.push(...exportsStmt.specifiers.map(exportSpec => {
        let decl, declId;
        if (from) {
          decl = node;
          declId = exportSpec.exported;
        } else if (exportSpec.local) {
          const resolved = scope.resolvedRefMap.get(exportSpec.local);
          decl = resolved ? resolved.decl : null;
          declId = resolved ? resolved.declId : null;
        }
        return {
          local: !from && exportSpec.local ? exportSpec.local.name : null,
          exported: exportSpec.exported ? exportSpec.exported.name : null,
          imported: from && exportSpec.local ? exportSpec.local.name : null,
          fromModule: from || null,
          type: "id",
          node,
          decl,
          declId
        };
      }));
      continue;
    }
    if (exportsStmt.declaration && exportsStmt.declaration.declarations) {
      exports.push(...exportsStmt.declaration.declarations.map(decl => {
        return {
          local: decl.id ? decl.id.name : "default",
          exported: decl.id ? decl.id.name : "default",
          type: exportsStmt.declaration.kind,
          fromModule: null,
          node: node,
          decl: decl,
          declId: decl.id
        };
      }));
      continue;
    }
    if (exportsStmt.declaration) {
      exports.push({
        local: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : "default",
        exported: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : "default",
        type: exportsStmt.declaration.type === "FunctionDeclaration" ? "function" : exportsStmt.declaration.type === "ClassDeclaration" ? "class" : null,
        fromModule: null,
        node: node,
        decl: exportsStmt.declaration,
        declId: exportsStmt.declaration.id
      });
      continue;
    }
  }
  return uniqBy(exports, (a, b) => a.local == b.local && a.exported == b.exported && a.fromModule == b.fromModule);
}

var query = /*#__PURE__*/Object.freeze({
  __proto__: null,
  helpers: helpers,
  knownGlobals: knownGlobals,
  scopes: scopes,
  nodesAtIndex: nodesAtIndex,
  scopesAtIndex: scopesAtIndex,
  scopeAtIndex: scopeAtIndex,
  scopesAtPos: scopesAtPos,
  nodesInScopeOf: nodesInScopeOf,
  declarationsOfScope: declarationsOfScope,
  _declaredVarNames: _declaredVarNames,
  _findJsLintGlobalDeclarations: _findJsLintGlobalDeclarations,
  topLevelDeclsAndRefs: topLevelDeclsAndRefs,
  topLevelFuncDecls: topLevelFuncDecls,
  findGlobalVarRefs: findGlobalVarRefs,
  findNodesIncludingLines: findNodesIncludingLines,
  findReferencesAndDeclsInScope: findReferencesAndDeclsInScope,
  findDeclarationClosestToIndex: findDeclarationClosestToIndex,
  nodesAt: nodesAt,
  statementOf: statementOf,
  resolveReferences: resolveReferences,
  refWithDeclAt: refWithDeclAt,
  imports: imports,
  exports: exports$1
});

class ObjectSpreadTransformer extends Visitor {
  accept(node, state, path) {
    if (node.type === "ObjectExpression") {
      node = this.transformSpreadElement(node);
    }
    return super.accept(node, state, path);
  }
  transformSpreadElement(node) {
    let currentGroup = [];
    const propGroups = [currentGroup];
    node.properties.forEach(prop => {
      if (prop.type !== "SpreadElement") {
        prop.shorthand = false;
        currentGroup.push(prop);
      } else {
        propGroups.push(prop);
        currentGroup = [];
        propGroups.push(currentGroup);
      }
    });
    if (propGroups.length === 1)
      return node;
    if (!currentGroup.length)
      propGroups.pop();
    return funcCall(member("Object", "assign"), ...propGroups.map(group => {
      return group.type === "SpreadElement" ? group.argument : {
        properties: group,
        type: "ObjectExpression"
      };
    }));
  }
}
function objectSpreadTransform(parsed) {
  return new ObjectSpreadTransformer().accept(parsed, {}, []);
}

function _node2string(node) {
  return node.source || stringify(node);
}
function _findIndentAt(s, pos) {
  const bol = peekLeft(s, pos, /\s+$/);
  let indent = typeof bol === "number" ? s.slice(bol, pos) : "";
  if (indent[0] === "\n")
    indent = indent.slice(1);
  return indent;
}
function _applyChanges(changes, source) {
  for (let i = 0; i < changes.length; i++) {
    const change = changes[i];
    if (change.type === "del") {
      source = source.slice(0, change.pos) + source.slice(change.pos + change.length);
    } else if (change.type === "add") {
      source = source.slice(0, change.pos) + change.string + source.slice(change.pos);
    } else {
      throw new Error("Unexpected change " + inspect(change));
    }
  }
  return source;
}
function _compareNodesForReplacement(nodeA, nodeB) {
  if (nodeA.start === nodeB.start && nodeA.end === nodeB.end)
    return 0;
  if (nodeA.end <= nodeB.start)
    return -1;
  if (nodeA.start >= nodeB.end)
    return 1;
  if (nodeA.start <= nodeB.start && nodeA.end >= nodeB.end)
    return 1;
  if (nodeB.start <= nodeA.start && nodeB.end >= nodeA.end)
    return -1;
  throw new Error("Comparing nodes");
}
function replaceNode(target, replacementFunc, sourceOrChanges) {
  const sourceChanges = typeof sourceOrChanges === "object" ? sourceOrChanges : {
    changes: [],
    source: sourceOrChanges
  };
  let insideChangedBefore = false;
  const pos = sourceChanges.changes.reduce(function (pos, change) {
    if (pos.end < change.pos)
      return pos;
    const isInFront = change.pos < pos.start;
    insideChangedBefore = insideChangedBefore || change.pos >= pos.start && change.pos <= pos.end;
    if (change.type === "add") {
      return {
        start: isInFront ? pos.start + change.string.length : pos.start,
        end: pos.end + change.string.length
      };
    }
    if (change.type === "del") {
      return {
        start: isInFront ? pos.start - change.length : pos.start,
        end: pos.end - change.length
      };
    }
    throw new Error("Cannot deal with change " + inspect(change));
  }, {
    start: target.start,
    end: target.end
  });
  const source = sourceChanges.source;
  const replacement = replacementFunc(target, source.slice(pos.start, pos.end), insideChangedBefore);
  var replacementSource = typeof replacement === "string" ? replacement : Array.isArray(replacement) ? replacement.map(_node2string).join("\n" + _findIndentAt(source, pos.start)) : replacementSource = _node2string(replacement);
  const changes = [
    {
      type: "del",
      pos: pos.start,
      length: pos.end - pos.start
    },
    {
      type: "add",
      pos: pos.start,
      string: replacementSource
    }
  ];
  return {
    changes: sourceChanges.changes.concat(changes),
    source: _applyChanges(changes, source)
  };
}
function replaceNodes(targetAndReplacementFuncs, sourceOrChanges) {
  const sorted = targetAndReplacementFuncs.sort((a, b) => _compareNodesForReplacement(a.target, b.target));
  let sourceChanges = typeof sourceOrChanges === "object" ? sourceOrChanges : {
    changes: [],
    source: sourceOrChanges
  };
  for (let i = 0; i < sorted.length; i++) {
    const {target, replacementFunc} = sorted[i];
    sourceChanges = replaceNode(target, replacementFunc, sourceChanges);
  }
  return sourceChanges;
}
function replace(astOrSource, targetNode, replacementFunc, options) {
  const parsed = typeof astOrSource === "object" ? astOrSource : null;
  const source = typeof astOrSource === "string" ? astOrSource : parsed.source || _node2string(parsed);
  return replaceNode(targetNode, replacementFunc, source);
}
function __findVarDecls(scope, varDecls = []) {
  varDecls.push(...scope.varDecls);
  for (const subScope of scope.subScopes) {
    __findVarDecls(subScope, varDecls);
  }
  return varDecls;
}
function oneDeclaratorPerVarDecl(astOrSource) {
  const parsed = typeof astOrSource === "object" ? astOrSource : parse(astOrSource);
  const source = typeof astOrSource === "string" ? astOrSource : parsed.source || _node2string(parsed);
  const scope = scopes(parsed);
  const varDecls = __findVarDecls(scope);
  const targetsAndReplacements = [];
  for (const decl of varDecls) {
    targetsAndReplacements.push({
      target: decl,
      replacementFunc: function (declNode, s, wasChanged) {
        if (wasChanged) {
          declNode = parse(s).body[0];
        }
        return declNode.declarations.map(function (ea) {
          return {
            type: "VariableDeclaration",
            kind: "var",
            declarations: [ea]
          };
        });
      }
    });
  }
  return replaceNodes(targetsAndReplacements, source);
}
function oneDeclaratorForVarsInDestructoring(astOrSource) {
  const parsed = typeof astOrSource === "object" ? astOrSource : parse(astOrSource);
  const source = typeof astOrSource === "string" ? astOrSource : parsed.source || _node2string(parsed);
  const scope = scopes(parsed);
  const varDecls = __findVarDecls(scope);
  const targetsAndReplacements = [];
  for (const decl of varDecls) {
    targetsAndReplacements.push({
      target: decl,
      replacementFunc: function (declNode, s, wasChanged) {
        if (wasChanged) {
          declNode = parse(s).body[0];
        }
        const nodes = [];
        for (const decl of declNode.declarations) {
          const extractedId = {
            type: "Identifier",
            name: "__temp"
          };
          const extractedInit = {
            type: "VariableDeclaration",
            kind: "var",
            declarations: [{
                type: "VariableDeclarator",
                id: extractedId,
                init: decl.init
              }]
          };
          nodes.push(extractedInit);
          for (const {key: keyPath} of helpers.objPropertiesAsList(decl.id, [], false)) {
            nodes.push(varDecl(keyPath[keyPath.length - 2], memberChain(extractedId.name, ...keyPath), "var"));
          }
        }
        return nodes;
      }
    });
  }
  return replaceNodes(targetsAndReplacements, source);
}
function returnLastStatement(source, opts) {
  opts = opts || {};
  const parsed = parse(source, opts);
  const last$1 = last(parsed.body);
  if (last$1.type !== "ExpressionStatement") {
    return opts.asAST ? parsed : source;
  }
  parsed.body.splice(parsed.body.length - 1, 1, returnStmt(last$1.expression));
  return opts.asAST ? parsed : stringify(parsed);
}
function wrapInFunction(code, opts) {
  opts = opts || {};
  const transformed = returnLastStatement(code, opts);
  return opts.asAST ? program(funcExpr({ id: opts.id || undefined }, [], ...transformed.body)) : `function${ opts.id ? " " + opts.id : "" }() {\n${ transformed }\n}`;
}
function wrapInStartEndCall(parsed, options) {
  if (typeof parsed === "string")
    parsed = parse(parsed);
  options = options || {};
  const isProgram = parsed.type === "Program";
  const startFuncNode = options.startFuncNode || id("__start_execution");
  const endFuncNode = options.endFuncNode || id("__end_execution");
  const funcDecls = topLevelFuncDecls(parsed);
  const innerBody = parsed.body;
  const outerBody = [];
  funcDecls.forEach(({node, path}) => {
    Path(path).set(parsed, exprStmt(node.id));
    outerBody.push(node);
  });
  innerBody.unshift(exprStmt(funcCall(startFuncNode)));
  const last$1 = last(innerBody);
  if (last$1.type === "ExpressionStatement") {
    innerBody.pop();
    innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), last$1.expression)));
  } else if (last$1.type === "VariableDeclaration" && last(last$1.declarations).id.type === "Identifier") {
    innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), last(last$1.declarations).id)));
  } else {
    innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), id("undefined"))));
  }
  outerBody.push(tryStmt("err", [exprStmt(funcCall(endFuncNode, id("err"), id("undefined")))], ...innerBody));
  return isProgram ? program(...outerBody) : block(...outerBody);
}
const isProbablySingleExpressionRe = /^\s*(\{|function\s*\()/;
function transformSingleExpression(code) {
  if (!isProbablySingleExpressionRe.test(code) || code.split("\n").length > 30)
    return code;
  try {
    const parsed = fuzzyParse(code);
    if (parsed.body.length === 1 && (parsed.body[0].type === "FunctionDeclaration" || parsed.body[0].type === "BlockStatement" && parsed.body[0].body[0].type === "LabeledStatement")) {
      code = "(" + code.replace(/;\s*$/, "") + ")";
    }
  } catch (e) {
    if (typeof $world !== "undefined")
      $world.logError(e);
    else
      console.error("Eval preprocess error: %s", e.stack || e);
  }
  return code;
}

var transform = /*#__PURE__*/Object.freeze({
  __proto__: null,
  replaceNode: replaceNode,
  replaceNodes: replaceNodes,
  replace: replace,
  _compareNodesForReplacement: _compareNodesForReplacement,
  oneDeclaratorPerVarDecl: oneDeclaratorPerVarDecl,
  oneDeclaratorForVarsInDestructoring: oneDeclaratorForVarsInDestructoring,
  returnLastStatement: returnLastStatement,
  wrapInFunction: wrapInFunction,
  wrapInStartEndCall: wrapInStartEndCall,
  transformSingleExpression: transformSingleExpression,
  objectSpreadTransform: objectSpreadTransform
});

function getCommentPrecedingNode(parsed, node) {
  const statementPath = statementOf(parsed, node, { asPath: true });
  const blockPath = statementPath.slice(0, -2);
  const block = Path(blockPath).get(parsed);
  return !block.comments || !block.comments.length ? null : chain(extractComments(parsed)).reversed().find(function (ea) {
    return ea.followingNode === node;
  }).value();
}
function extractComments(astOrCode, optCode) {
  const parsed = typeof astOrCode === "string" ? parse(astOrCode, { withComments: true }) : astOrCode;
  const code = optCode || (typeof astOrCode === "string" ? astOrCode : stringify(astOrCode));
  const parsedComments = sortBy(commentsWithPathsAndNodes(parsed), c => c.comment.start);
  return parsedComments.map(function (c, i) {
    if (isInObjectMethod(c)) {
      return merge([
        c,
        c.comment,
        {
          type: "method",
          comment: c.comment.text
        },
        methodAttributesOf(c)
      ]);
    }
    if (isInComputedMethod(c)) {
      return merge([
        c,
        c.comment,
        {
          type: "method",
          comment: c.comment.text
        },
        computedMethodAttributesOf(c)
      ]);
    }
    if (isInFunctionStatement(c)) {
      return merge([
        c,
        c.comment,
        {
          type: "function",
          comment: c.comment.text
        },
        functionAttributesOf(c)
      ]);
    }
    if (isInAssignedMethod(c)) {
      return merge([
        c,
        c.comment,
        {
          type: "method",
          comment: c.comment.text
        },
        methodAttributesOfAssignment(c)
      ]);
    }
    const followingNode = followingNodeOf(c);
    if (!followingNode)
      return merge([
        c,
        c.comment,
        { followingNode: followingNode },
        unknownComment(c)
      ]);
    const followingComment = parsedComments[i + 1];
    if (followingComment && followingComment.comment.start <= followingNode.start) {
      return merge([
        c,
        c.comment,
        { followingNode: followingNode },
        unknownComment(c)
      ]);
    }
    if (isSingleObjVarDeclaration(followingNode)) {
      return merge([
        c,
        c.comment,
        { followingNode: followingNode },
        {
          type: "object",
          comment: c.comment.text
        },
        objAttributesOf(followingNode)
      ]);
    }
    if (isSingleVarDeclaration(followingNode)) {
      return merge([
        c,
        c.comment,
        { followingNode: followingNode },
        {
          type: "var",
          comment: c.comment.text
        },
        objAttributesOf(followingNode)
      ]);
    }
    return merge([
      c,
      c.comment,
      { followingNode: followingNode },
      unknownComment(c)
    ]);
  });
  function commentsWithPathsAndNodes(parsed) {
    const comments = [];
    const v = new Visitor();
    v.accept = wrap(v.accept, (proceed, node, state, path) => {
      if (node.comments) {
        pushAll(comments, node.comments.map(function (comment) {
          return {
            path: path,
            comment: comment,
            node: node
          };
        }));
      }
      return proceed(node, state, path);
    });
    v.accept(parsed, comments, []);
    return comments;
  }
  function followingNodeOf(comment) {
    return comment.node.body.find(function (node) {
      return node.start > comment.comment.end;
    });
  }
  function unknownComment(comment) {
    return {
      type: "unknown",
      comment: comment.comment.text
    };
  }
  function isInFunctionStatement(comment) {
    const node = Path(comment.path.slice(0, -1)).get(parsed);
    return node && node.type === "FunctionDeclaration";
  }
  function functionAttributesOf(comment) {
    const funcNode = Path(comment.path.slice(0, -1)).get(parsed);
    const name = funcNode.id ? funcNode.id.name : "<error: no name for function>";
    return {
      name: name,
      args: pluck(funcNode.params, "name")
    };
  }
  function isInObjectMethod(comment) {
    return equals$2(comment.path.slice(-2), [
      "value",
      "body"
    ]);
  }
  function isInAssignedMethod(comment) {
    return equals$2(comment.path.slice(-2), [
      "right",
      "body"
    ]);
  }
  function methodAttributesOf(comment) {
    const methodNode = Path(comment.path.slice(0, -2)).get(parsed);
    const name = methodNode.key ? methodNode.key.name : "<error: no name for method>";
    let p = comment.path.slice();
    let objectName = "<error: no object found for method>";
    while (p.length && last(p) !== "init")
      p.pop();
    if (p.length) {
      objectName = Path(p.slice(0, -1).concat([
        "id",
        "name"
      ])).get(parsed);
    }
    if (startsWith(objectName, "<error")) {
      p = comment.path.slice();
      while (p.length && last(p) !== "right")
        p.pop();
      if (p.length) {
        const assignNode = Path(p.slice(0, -1).concat(["left"])).get(parsed);
        objectName = code.slice(assignNode.start, assignNode.end);
      }
    }
    if (startsWith(objectName, "<error")) {
      p = comment.path.slice();
      const callExpr = Path(p.slice(0, -6)).get(parsed);
      const isCall = callExpr && callExpr.type === "CallExpression";
      const firstArg = isCall && callExpr.arguments[0];
      if (firstArg)
        objectName = code.slice(firstArg.start, firstArg.end);
    }
    return {
      name: name,
      args: pluck(methodNode.value.params, "name"),
      objectName: objectName
    };
  }
  function methodAttributesOfAssignment(comment) {
    const node = Path(comment.path.slice(0, -1)).get(parsed);
    if (node.type !== "FunctionExpression" && node.type !== "FunctionDeclaration")
      return {};
    const statement = statementOf(parsed, node);
    if (statement.type !== "ExpressionStatement" || statement.expression.type !== "AssignmentExpression")
      return {};
    const objName = code.slice(statement.expression.left.object.start, statement.expression.left.object.end);
    const methodName = code.slice(statement.expression.left.property.start, statement.expression.left.property.end);
    return {
      name: methodName,
      objectName: objName,
      args: pluck(node.params, "name")
    };
  }
  function isInComputedMethod(comment) {
    const path = comment.path.slice(-5);
    removeAt(path, 1);
    return equals$2(path, [
      "properties",
      "value",
      "callee",
      "body"
    ]);
  }
  function computedMethodAttributesOf(comment) {
    let name, args, pathToProp;
    pathToProp = comment.path.slice(0, -3);
    let propertyNode = Path(pathToProp).get(parsed);
    if (propertyNode && propertyNode.type === "Property") {
      args = pluck(propertyNode.value.callee.params, "name");
      name = propertyNode.key ? propertyNode.key.name : "<error: no name for method>";
    }
    if (!name) {
      pathToProp = comment.path.slice(0, -2);
      propertyNode = Path(pathToProp).get(parsed);
      if (propertyNode && propertyNode.type === "Property") {
        args = pluck(propertyNode.value.params, "name");
        name = propertyNode.key ? propertyNode.key.name : "<error: no name for method>";
      }
    }
    if (!name) {
      name = "<error: no name for method>";
      args = [];
      pathToProp = comment.path;
    }
    var p = clone$1(pathToProp);
    let objectName = "<error: no object found for method>";
    while (p.length && last(p) !== "init")
      p.pop();
    if (p.length) {
      objectName = Path(p.slice(0, -1).concat([
        "id",
        "name"
      ])).get(parsed);
    }
    if (startsWith(objectName, "<error")) {
      var p = clone$1(pathToProp);
      while (p.length && last(p) !== "right")
        p.pop();
      if (p.length) {
        const assignNode = Path(p.slice(0, -1).concat(["left"])).get(parsed);
        objectName = code.slice(assignNode.start, assignNode.end);
      }
    }
    if (startsWith(objectName, "<error")) {
      var p = clone$1(pathToProp);
      const callExpr = Path(p.slice(0, -4)).get(parsed);
      const isCall = callExpr && callExpr.type === "CallExpression";
      const firstArg = isCall && callExpr.arguments[0];
      if (firstArg)
        objectName = code.slice(firstArg.start, firstArg.end);
    }
    return {
      name: name,
      args: args,
      objectName: objectName
    };
  }
  function isSingleObjVarDeclaration(node) {
    return isSingleVarDeclaration(node) && (node.declarations[0].init.type === "ObjectExpression" || isObjectAssignment(node.declarations[0].init));
  }
  function isSingleVarDeclaration(node) {
    return node && node.type === "VariableDeclaration" && node.declarations.length === 1;
  }
  function objAttributesOf(node) {
    return { name: node.declarations[0].id.name };
  }
  function isObjectAssignment(node) {
    if (node.type !== "AssignmentExpression")
      return false;
    if (node.right.type === "ObjectExpression")
      return true;
    if (node.right.type === "AssignmentExpression")
      return isObjectAssignment(node.right);
    return false;
  }
}

var comments = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getCommentPrecedingNode: getCommentPrecedingNode,
  extractComments: extractComments
});

function findDecls(parsed, options) {
  options = options || merge({ hideOneLiners: false }, options);
  if (typeof parsed === "string") {
    parsed = parse(parsed, { addSource: true });
  }
  const topLevelNodes = parsed.type === "Program" ? parsed.body : parsed.body.body;
  const defs = [];
  for (let node of topLevelNodes) {
    node = unwrapExport(node);
    let found = functionWrapper(node, options) || varDefs(node) || funcDef(node) || es6ClassDef(node) || someObjectExpressionCall(node) || describe(node);
    if (!found)
      continue;
    if (options.hideOneLiners) {
      if (parsed.loc) {
        found = found.filter(def => !def.node.loc || def.node.loc.start.line !== def.node.loc.end.line);
      } else if (parsed.source) {
        const filtered = [];
        for (const def of found) {
          if (def.parent && filtered.includes(def.parent) || (def.node.source || "").includes("\n"))
            filtered.push(def);
        }
        found = filtered;
      }
    }
    defs.push(...found);
  }
  return defs;
}
function es6ClassDef(node) {
  if (node.type !== "ClassDeclaration")
    return null;
  const def = {
    type: "class-decl",
    name: node.id.name,
    node: node,
    children: []
  };
  def.children.push(...compact(node.body.body.map((node, i) => es6ClassMethod(node, def))));
  return [
    def,
    ...def.children
  ];
}
function es6ClassMethod(node, parent, i) {
  if (node.type !== "MethodDefinition")
    return null;
  let type;
  if (node.kind === "constructor")
    type = "class-constructor";
  else if (node.kind === "method")
    type = node.static ? "class-class-method" : "class-instance-method";
  else if (node.kind === "get")
    type = node.static ? "class-class-getter" : "class-instance-getter";
  else if (node.kind === "set")
    type = node.static ? "class-class-setter" : "class-instance-setter";
  if (type === "class-instance-getter" && node.key.name === "commands")
    return parseCommandsMethod(node, parent, type);
  if (type === "class-class-getter" && node.key.name === "properties")
    return parsePropertiesMethod(node, parent, type);
  return type ? {
    type,
    parent,
    node,
    name: node.key.name
  } : null;
}
function parsePropertiesMethod(node, parent, type) {
  const propertiesNode = {
    type,
    parent,
    node,
    name: node.key.name
  };
  try {
    const children = [];
    propertiesNode.node.value.body.body[0].argument.properties.forEach(property => {
      children.push({
        type: property.type,
        parent: propertiesNode,
        node: property,
        name: property.key ? property.key.name : property.argument.arguments[0].value
      });
    });
    propertiesNode.children = children;
  } finally {
    return propertiesNode;
  }
}
function parseCommandsMethod(node, parent, type) {
  const commandsNode = {
    type,
    parent,
    node,
    name: node.key.name
  };
  try {
    const children = [];
    if (commandsNode.node.value.body.body) {
      const commands = commandsNode.node.value.body.body[0].argument.elements;
      if (commands) {
        commands.forEach(command => {
          children.push({
            type: command.type,
            parent: commandsNode,
            node: command,
            name: command.properties[0].value.value
          });
        });
        commandsNode.children = children;
      }
    }
  } finally {
    return commandsNode;
  }
}
function varDefs(varDeclNode) {
  if (varDeclNode.type !== "VariableDeclaration")
    return null;
  const result = [];
  for (const {id, node} of withVarDeclIds(varDeclNode)) {
    const def = {
      name: id.name,
      node: node,
      type: "var-decl"
    };
    result.push(def);
    if (!def.node.init)
      continue;
    let initNode = def.node.init;
    while (initNode.type === "AssignmentExpression") {
      initNode = initNode.right;
    }
    if (initNode.type === "ObjectExpression") {
      def.type = "object-decl";
      def.children = objectKeyValsAsDefs(initNode).map(ea => ({
        ...ea,
        type: "object-" + ea.type,
        parent: def
      }));
      result.push(...def.children);
      continue;
    }
    if (initNode.type === "ArrayExpression") {
      def.type = "array-decl";
      try {
        def.children = arrayEntriesAsDefs(initNode).map(ea => ({
          ...ea,
          type: "object-" + ea.type,
          parent: def
        }));
        result.push(...def.children);
      } finally {
        continue;
      }
    }
    const objDefs = someObjectExpressionCall(initNode, def);
    if (objDefs) {
      def.children = objDefs.map(d => ({
        ...d,
        parent: def
      }));
      result.push(...def.children);
    }
  }
  return result;
}
function funcDef(node) {
  if (node.type !== "FunctionStatement" && node.type !== "FunctionDeclaration")
    return null;
  if (!node.id)
    return null;
  return [{
      name: node.id.name,
      node,
      type: "function-decl"
    }];
}
function someObjectExpressionCall(node, parentDef) {
  if (node.type === "ExpressionStatement")
    node = node.expression;
  if (node.type !== "CallExpression")
    return null;
  const objArg = node.arguments.find(a => a.type === "ObjectExpression");
  if (!objArg)
    return null;
  return objectKeyValsAsDefs(objArg, parentDef);
}
function parseDescribeBlock(parent) {
  const parseInSuits = [
    "describe",
    "xdescribe",
    "it",
    "xit",
    "after",
    "afterEach",
    "before",
    "beforeEach"
  ];
  const nodes = [];
  parent.expression.arguments[1].body.body.forEach(subnode => {
    if (subnode.type !== "ExpressionStatement" || !subnode.expression.callee)
      return null;
    const type = subnode.expression.callee.name;
    if (!parseInSuits.includes(type))
      return;
    const name = subnode.expression.arguments[0].value || subnode.expression.callee.name;
    let parsedSubNode = {
      name,
      node: subnode,
      type,
      parent: parent
    };
    if (subnode.expression.callee.name === "describe" || subnode.expression.callee.name === "xdescribe") {
      parsedSubNode.children = parseDescribeBlock(subnode);
    }
    nodes.push(parsedSubNode);
  });
  return nodes;
}
function describe(node) {
  if (node.type !== "ExpressionStatement")
    return null;
  if (node.expression && Path("expression.callee.name").get(node) !== "describe" && Path("expression.callee.name").get(node) !== "xdescribe")
    return null;
  const parsedNode = {
    name: node.expression.arguments[0].value,
    node,
    type: node.expression.callee.name
  };
  parsedNode.children = parseDescribeBlock(node);
  return [parsedNode];
}
function functionWrapper(node, options) {
  if (!isFunctionWrapper(node))
    return null;
  let decls;
  const argFunc = Path("expression.arguments.0").get(node);
  if (argFunc && argFunc.type === "FunctionExpression" && lines(argFunc.source || "").length > 5) {
    decls = findDecls(argFunc, options);
  } else {
    decls = findDecls(Path("expression.callee").get(node), options);
  }
  const parent = {
    node: node,
    name: Path("expression.callee.id.name").get(node)
  };
  decls.forEach(function (decl) {
    return decl.parent || (decl.parent = parent);
  });
  return decls;
}
function unwrapExport(node) {
  return (node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration ? node.declaration : node;
}
function objectKeyValsAsDefs(objectExpression, parent) {
  return objectExpression.properties.map(node => ({
    name: node.key.name || node.key.value,
    type: node.value.type === "FunctionExpression" ? "method" : "property",
    node,
    parent
  }));
}
function arrayEntriesAsDefs(arrayExpression, parent) {
  return arrayExpression.elements.map(node => ({
    name: node.value || node.properties[0].value.value,
    type: node.type,
    node,
    parent
  }));
}
function isFunctionWrapper(node) {
  return Path("expression.type").get(node) === "CallExpression" && Path("expression.callee.type").get(node) === "FunctionExpression";
}
function withVarDeclIds(varNode) {
  return varNode.declarations.map(declNode => {
    if (!declNode.source && declNode.init) {
      declNode.source = declNode.id.name + " = " + declNode.init.source;
    }
    return {
      node: declNode,
      id: declNode.id
    };
  });
}

var codeCategorizer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  findDecls: findDecls
});

const isValidIdentifierRe = /^(?!(?:do|if|in|for|let|new|try|var|case|default|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/;
function isValidIdentifier(string) {
  return isValidIdentifierRe.test(string);
}
const Node$1 = parse("").constructor;
Object.defineProperty(Node$1.prototype, "__serialize__", {
  configurable: true,
  value: function () {
    return { __expr__: "(" + JSON.stringify(this) + ")" };
  }
});

exports.AllNodesVisitor = AllNodesVisitor;
exports.BaseVisitor = Visitor;
exports.ReplaceManyVisitor = ReplaceManyVisitor;
exports.ReplaceVisitor = ReplaceVisitor;
exports.acorn = acorn;
exports.categorizer = codeCategorizer;
exports.comments = comments;
exports.compareAst = compareAst;
exports.custom = custom;
exports.escodegen = es;
exports.fuzzyParse = fuzzyParse;
exports.isValidIdentifier = isValidIdentifier;
exports.nodes = nodes;
exports.parse = parse;
exports.parseFunction = parseFunction;
exports.pathToNode = pathToNode;
exports.printAst = printAst;
exports.query = query;
exports.rematchAstWithSource = rematchAstWithSource;
exports.stringify = stringify;
exports.transform = transform;
exports.walk = walk$1;
exports.withMozillaAstDo = withMozillaAstDo;
