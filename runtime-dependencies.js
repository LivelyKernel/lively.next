!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Babel=t():e.Babel=t()}(this,function(){return function(e){function t(n){if(r[n])return r[n].exports;var i=r[n]={exports:{},id:n,loaded:!1};return e[n].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var r={};return t.m=e,t.c=r,t.p="",t(0)}(function(e){for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t))switch(typeof e[t]){case"function":break;case"object":e[t]=function(t){var r=t.slice(1),n=e[t[0]];return function(e,t,i){n.apply(this,[e,t,i].concat(r))}}(e[t]);break;default:e[t]=e[e[t]]}return e}([function(e,t,r){"use strict";function n(e,t){return g(t)&&"string"==typeof t[0]?e.hasOwnProperty(t[0])?[e[t[0]]].concat(t.slice(1)):void 0:"string"==typeof t?e[t]:t}function i(e){var t=(e.presets||[]).map(function(e){var t=n(E,e);if(!t)throw new Error('Invalid preset specified in Babel options: "'+e+'"');return g(t)&&"object"===h(t[0])&&t[0].hasOwnProperty("buildPreset")&&(t[0]=d({},t[0],{buildPreset:t[0].buildPreset})),t}),r=(e.plugins||[]).map(function(e){var t=n(b,e);if(!t)throw new Error('Invalid plugin specified in Babel options: "'+e+'"');return t});return d({babelrc:!1},e,{presets:t,plugins:r})}function s(e,t){return y.transform(e,i(t))}function a(e,t,r){return y.transformFromAst(e,t,i(r))}function o(e,t){b.hasOwnProperty(e)&&console.warn('A plugin named "'+e+'" is already registered, it will be overridden'),b[e]=t}function u(e){Object.keys(e).forEach(function(t){return o(t,e[t])})}function l(e,t){E.hasOwnProperty(e)&&console.warn('A preset named "'+e+'" is already registered, it will be overridden'),E[e]=t}function c(e){Object.keys(e).forEach(function(t){return l(t,e[t])})}function f(e){(0,v.runScripts)(s,e)}function p(){window.removeEventListener("DOMContentLoaded",f)}Object.defineProperty(t,"__esModule",{value:!0}),t.version=t.buildExternalHelpers=t.availablePresets=t.availablePlugins=void 0;var d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.transform=s,t.transformFromAst=a,t.registerPlugin=o,t.registerPlugins=u,t.registerPreset=l,t.registerPresets=c,t.transformScriptTags=f,t.disableScriptTags=p;var m=r(290),y=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(m),v=r(629),g=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},b=t.availablePlugins={},E=t.availablePresets={};t.buildExternalHelpers=y.buildExternalHelpers;u({"check-es2015-constants":r(66),"external-helpers":r(322),"inline-replace-variables":r(323),"syntax-async-functions":r(67),"syntax-async-generators":r(195),"syntax-class-constructor-call":r(196),"syntax-class-properties":r(197),"syntax-decorators":r(125),"syntax-do-expressions":r(198),"syntax-exponentiation-operator":r(199),"syntax-export-extensions":r(200),"syntax-flow":r(126),"syntax-function-bind":r(201),"syntax-function-sent":r(325),"syntax-jsx":r(127),"syntax-object-rest-spread":r(202),"syntax-trailing-function-commas":r(128),"transform-async-functions":r(326),"transform-async-to-generator":r(129),"transform-async-to-module-method":r(328),"transform-class-constructor-call":r(203),"transform-class-properties":r(204),"transform-decorators":r(205),"transform-decorators-legacy":r(329).default,"transform-do-expressions":r(206),"transform-es2015-arrow-functions":r(68),"transform-es2015-block-scoped-functions":r(69),"transform-es2015-block-scoping":r(70),"transform-es2015-classes":r(71),"transform-es2015-computed-properties":r(72),"transform-es2015-destructuring":r(73),"transform-es2015-duplicate-keys":r(130),"transform-es2015-for-of":r(74),"transform-es2015-function-name":r(75),"transform-es2015-instanceof":r(332),"transform-es2015-literals":r(76),"transform-es2015-modules-amd":r(131),"transform-es2015-modules-commonjs":r(77),"transform-es2015-modules-systemjs":r(208),"transform-es2015-modules-umd":r(209),"transform-es2015-object-super":r(78),"transform-es2015-parameters":r(79),"transform-es2015-shorthand-properties":r(80),"transform-es2015-spread":r(81),"transform-es2015-sticky-regex":r(82),"transform-es2015-template-literals":r(83),"transform-es2015-typeof-symbol":r(84),"transform-es2015-unicode-regex":r(85),"transform-es3-member-expression-literals":r(336),"transform-es3-property-literals":r(337),"transform-es5-property-mutators":r(338),"transform-eval":r(339),"transform-exponentiation-operator":r(132),"transform-export-extensions":r(210),"transform-flow-comments":r(340),"transform-flow-strip-types":r(211),"transform-function-bind":r(212),"transform-jscript":r(341),"transform-object-assign":r(342),"transform-object-rest-spread":r(213),"transform-object-set-prototype-of-to-assign":r(343),"transform-proto-to-assign":r(344),"transform-react-constant-elements":r(345),"transform-react-display-name":r(214),"transform-react-inline-elements":r(346),"transform-react-jsx":r(215),"transform-react-jsx-compat":r(347),"transform-react-jsx-self":r(349),"transform-react-jsx-source":r(350),"transform-regenerator":r(86),"transform-runtime":r(353),"transform-strict-mode":r(216),"undeclared-variables-check":r(354)}),c({es2015:r(217),es2016:r(218),es2017:r(219),latest:r(356),react:r(357),"stage-0":r(358),"stage-1":r(220),"stage-2":r(221),"stage-3":r(222),"es2015-no-commonjs":{plugins:[r(83),r(76),r(75),r(68),r(69),r(71),r(78),r(80),r(72),r(74),r(82),r(85),r(66),r(81),r(79),r(73),r(70),r(84),[r(86),{async:!1,asyncGenerators:!1}]]},"es2015-loose":{plugins:[[r(83),{loose:!0}],r(76),r(75),r(68),r(69),[r(71),{loose:!0}],r(78),r(80),r(130),[r(72),{loose:!0}],[r(74),{loose:!0}],r(82),r(85),r(66),[r(81),{loose:!0}],r(79),[r(73),{loose:!0}],r(70),r(84),[r(77),{loose:!0}],[r(86),{async:!1,asyncGenerators:!1}]]}});t.version="6.26.0";"undefined"!=typeof window&&window&&window.addEventListener&&window.addEventListener("DOMContentLoaded",function(){return f()},!1)},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=z["is"+e];t||(t=z["is"+e]=function(t,r){return z.is(e,t,r)}),z["assert"+e]=function(r,n){if(n=n||{},!t(r,n))throw new Error("Expected type "+(0,I.default)(e)+" with option "+(0,I.default)(n))}}function s(e,t,r){return!!t&&(!!a(t.type,e)&&(void 0===r||z.shallowEqual(t,r)))}function a(e,t){if(e===t)return!0;if(z.ALIAS_KEYS[t])return!1;var r=z.FLIPPED_ALIAS_KEYS[t];if(r){if(r[0]===e)return!0;for(var n=r,i=Array.isArray(n),s=0,n=i?n:(0,T.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}if(e===a)return!0}}return!1}function o(e,t,r){if(e){var n=z.NODE_FIELDS[e.type];if(n){var i=n[t];i&&i.validate&&(i.optional&&null==r||i.validate(e,t,r))}}}function u(e,t){for(var r=(0,B.default)(t),n=r,i=Array.isArray(n),s=0,n=i?n:(0,T.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;if(e[o]!==t[o])return!1}return!0}function l(e,t,r){return e.object=z.memberExpression(e.object,e.property,e.computed),e.property=t,e.computed=!!r,e}function c(e,t){return e.object=z.memberExpression(t,e.object),e}function f(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"body";return e[t]=z.toBlock(e[t],e)}function p(e){if(!e)return e;var t={};for(var r in e)"_"!==r[0]&&(t[r]=e[r]);return t}function d(e){var t=p(e);return delete t.loc,t}function h(e){if(!e)return e;var t={};for(var r in e)if("_"!==r[0]){var n=e[r];n&&(n.type?n=z.cloneDeep(n):Array.isArray(n)&&(n=n.map(z.cloneDeep))),t[r]=n}return t}function m(e,t){var r=e.split(".");return function(e){if(!z.isMemberExpression(e))return!1;for(var n=[e],i=0;n.length;){var s=n.shift();if(t&&i===r.length)return!0;if(z.isIdentifier(s)){if(r[i]!==s.name)return!1}else{if(!z.isStringLiteral(s)){if(z.isMemberExpression(s)){if(s.computed&&!z.isStringLiteral(s.property))return!1;n.push(s.object),n.push(s.property);continue}return!1}if(r[i]!==s.value)return!1}if(++i>r.length)return!1}return!0}}function y(e){for(var t=z.COMMENT_KEYS,r=Array.isArray(t),n=0,t=r?t:(0,T.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}delete e[i]}return e}function v(e,t){return g(e,t),b(e,t),E(e,t),e}function g(e,t){x("trailingComments",e,t)}function b(e,t){x("leadingComments",e,t)}function E(e,t){x("innerComments",e,t)}function x(e,t,r){t&&r&&(t[e]=(0,K.default)([].concat(t[e],r[e]).filter(Boolean)))}function A(e,t){if(!e||!t)return e;for(var r=z.INHERIT_KEYS.optional,n=Array.isArray(r),i=0,r=n?r:(0,T.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;null==e[a]&&(e[a]=t[a])}for(var o in t)"_"===o[0]&&(e[o]=t[o]);for(var u=z.INHERIT_KEYS.force,l=Array.isArray(u),c=0,u=l?u:(0,T.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;e[p]=t[p]}return z.inheritsComments(e,t),e}function S(e){if(!_(e))throw new TypeError("Not a valid node "+(e&&e.type))}function _(e){return!(!e||!H.VISITOR_KEYS[e.type])}function D(e,t,r){if(e){var n=z.VISITOR_KEYS[e.type];if(n){r=r||{},t(e,r);for(var i=n,s=Array.isArray(i),a=0,i=s?i:(0,T.default)(i);;){var o;if(s){if(a>=i.length)break;o=i[a++]}else{if(a=i.next(),a.done)break;o=a.value}var u=o,l=e[u];if(Array.isArray(l))for(var c=l,f=Array.isArray(c),p=0,c=f?c:(0,T.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d;D(h,t,r)}else D(l,t,r)}}}}function C(e,t){t=t||{};for(var r=t.preserveComments?Z:ee,n=r,i=Array.isArray(n),s=0,n=i?n:(0,T.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;null!=e[o]&&(e[o]=void 0)}for(var u in e)"_"===u[0]&&null!=e[u]&&(e[u]=void 0);for(var l=(0,k.default)(e),c=l,f=Array.isArray(c),p=0,c=f?c:(0,T.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}e[d]=null}}function w(e,t){return D(e,C,t),e}t.__esModule=!0,t.createTypeAnnotationBasedOnTypeof=t.removeTypeDuplicates=t.createUnionTypeAnnotation=t.valueToNode=t.toBlock=t.toExpression=t.toStatement=t.toBindingIdentifierName=t.toIdentifier=t.toKeyAlias=t.toSequenceExpression=t.toComputedKey=t.isNodesEquivalent=t.isImmutable=t.isScope=t.isSpecifierDefault=t.isVar=t.isBlockScoped=t.isLet=t.isValidIdentifier=t.isReferenced=t.isBinding=t.getOuterBindingIdentifiers=t.getBindingIdentifiers=t.TYPES=t.react=t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.NODE_FIELDS=t.ALIAS_KEYS=t.VISITOR_KEYS=t.NOT_LOCAL_BINDING=t.BLOCK_SCOPED_SYMBOL=t.INHERIT_KEYS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.NUMBER_UNARY_OPERATORS=t.BOOLEAN_UNARY_OPERATORS=t.BINARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.EQUALITY_BINARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.UPDATE_OPERATORS=t.LOGICAL_OPERATORS=t.COMMENT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.STATEMENT_OR_BLOCK_KEYS=void 0;var P=r(360),k=n(P),F=r(2),T=n(F),O=r(14),B=n(O),R=r(35),I=n(R),M=r(135);Object.defineProperty(t,"STATEMENT_OR_BLOCK_KEYS",{enumerable:!0,get:function(){return M.STATEMENT_OR_BLOCK_KEYS}}),Object.defineProperty(t,"FLATTENABLE_KEYS",{enumerable:!0,get:function(){return M.FLATTENABLE_KEYS}}),Object.defineProperty(t,"FOR_INIT_KEYS",{enumerable:!0,get:function(){return M.FOR_INIT_KEYS}}),Object.defineProperty(t,"COMMENT_KEYS",{enumerable:!0,get:function(){return M.COMMENT_KEYS}}),Object.defineProperty(t,"LOGICAL_OPERATORS",{enumerable:!0,get:function(){return M.LOGICAL_OPERATORS}}),Object.defineProperty(t,"UPDATE_OPERATORS",{enumerable:!0,get:function(){return M.UPDATE_OPERATORS}}),Object.defineProperty(t,"BOOLEAN_NUMBER_BINARY_OPERATORS",{enumerable:!0,get:function(){return M.BOOLEAN_NUMBER_BINARY_OPERATORS}}),Object.defineProperty(t,"EQUALITY_BINARY_OPERATORS",{enumerable:!0,get:function(){return M.EQUALITY_BINARY_OPERATORS}}),Object.defineProperty(t,"COMPARISON_BINARY_OPERATORS",{enumerable:!0,get:function(){return M.COMPARISON_BINARY_OPERATORS}}),Object.defineProperty(t,"BOOLEAN_BINARY_OPERATORS",{enumerable:!0,get:function(){return M.BOOLEAN_BINARY_OPERATORS}}),Object.defineProperty(t,"NUMBER_BINARY_OPERATORS",{enumerable:!0,get:function(){return M.NUMBER_BINARY_OPERATORS}}),Object.defineProperty(t,"BINARY_OPERATORS",{enumerable:!0,get:function(){return M.BINARY_OPERATORS}}),Object.defineProperty(t,"BOOLEAN_UNARY_OPERATORS",{enumerable:!0,get:function(){return M.BOOLEAN_UNARY_OPERATORS}}),Object.defineProperty(t,"NUMBER_UNARY_OPERATORS",{enumerable:!0,get:function(){return M.NUMBER_UNARY_OPERATORS}}),Object.defineProperty(t,"STRING_UNARY_OPERATORS",{enumerable:!0,get:function(){return M.STRING_UNARY_OPERATORS}}),Object.defineProperty(t,"UNARY_OPERATORS",{enumerable:!0,get:function(){return M.UNARY_OPERATORS}}),Object.defineProperty(t,"INHERIT_KEYS",{enumerable:!0,get:function(){return M.INHERIT_KEYS}}),Object.defineProperty(t,"BLOCK_SCOPED_SYMBOL",{enumerable:!0,get:function(){return M.BLOCK_SCOPED_SYMBOL}}),Object.defineProperty(t,"NOT_LOCAL_BINDING",{enumerable:!0,get:function(){return M.NOT_LOCAL_BINDING}}),t.is=s,t.isType=a,t.validate=o,t.shallowEqual=u,t.appendToMemberExpression=l,t.prependToMemberExpression=c,t.ensureBlock=f,t.clone=p,t.cloneWithoutLoc=d,t.cloneDeep=h,t.buildMatchMemberExpression=m,t.removeComments=y,t.inheritsComments=v,t.inheritTrailingComments=g,t.inheritLeadingComments=b,t.inheritInnerComments=E,t.inherits=A,t.assertNode=S,t.isNode=_,t.traverseFast=D,t.removeProperties=C,t.removePropertiesDeep=w;var N=r(226);Object.defineProperty(t,"getBindingIdentifiers",{enumerable:!0,get:function(){return N.getBindingIdentifiers}}),Object.defineProperty(t,"getOuterBindingIdentifiers",{enumerable:!0,get:function(){return N.getOuterBindingIdentifiers}});var L=r(395);Object.defineProperty(t,"isBinding",{enumerable:!0,get:function(){return L.isBinding}}),Object.defineProperty(t,"isReferenced",{enumerable:!0,get:function(){return L.isReferenced}}),Object.defineProperty(t,"isValidIdentifier",{enumerable:!0,get:function(){return L.isValidIdentifier}}),Object.defineProperty(t,"isLet",{enumerable:!0,get:function(){return L.isLet}}),Object.defineProperty(t,"isBlockScoped",{enumerable:!0,get:function(){return L.isBlockScoped}}),Object.defineProperty(t,"isVar",{enumerable:!0,get:function(){return L.isVar}}),Object.defineProperty(t,"isSpecifierDefault",{enumerable:!0,get:function(){return L.isSpecifierDefault}}),Object.defineProperty(t,"isScope",{enumerable:!0,get:function(){return L.isScope}}),Object.defineProperty(t,"isImmutable",{enumerable:!0,get:function(){return L.isImmutable}}),Object.defineProperty(t,"isNodesEquivalent",{enumerable:!0,get:function(){return L.isNodesEquivalent}});var j=r(385);Object.defineProperty(t,"toComputedKey",{enumerable:!0,get:function(){return j.toComputedKey}}),Object.defineProperty(t,"toSequenceExpression",{enumerable:!0,get:function(){return j.toSequenceExpression}}),Object.defineProperty(t,"toKeyAlias",{enumerable:!0,get:function(){return j.toKeyAlias}}),Object.defineProperty(t,"toIdentifier",{enumerable:!0,get:function(){return j.toIdentifier}}),Object.defineProperty(t,"toBindingIdentifierName",{enumerable:!0,get:function(){return j.toBindingIdentifierName}}),Object.defineProperty(t,"toStatement",{enumerable:!0,get:function(){return j.toStatement}}),Object.defineProperty(t,"toExpression",{enumerable:!0,get:function(){return j.toExpression}}),Object.defineProperty(t,"toBlock",{enumerable:!0,get:function(){return j.toBlock}}),Object.defineProperty(t,"valueToNode",{enumerable:!0,get:function(){return j.valueToNode}});var U=r(393);Object.defineProperty(t,"createUnionTypeAnnotation",{enumerable:!0,get:function(){return U.createUnionTypeAnnotation}}),Object.defineProperty(t,"removeTypeDuplicates",{enumerable:!0,get:function(){return U.removeTypeDuplicates}}),Object.defineProperty(t,"createTypeAnnotationBasedOnTypeof",{enumerable:!0,get:function(){return U.createTypeAnnotationBasedOnTypeof}});var V=r(624),G=n(V),W=r(109),Y=n(W),q=r(600),K=n(q);r(390);var H=r(26),J=r(394),X=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(J),z=t;t.VISITOR_KEYS=H.VISITOR_KEYS,t.ALIAS_KEYS=H.ALIAS_KEYS,t.NODE_FIELDS=H.NODE_FIELDS,t.BUILDER_KEYS=H.BUILDER_KEYS,t.DEPRECATED_KEYS=H.DEPRECATED_KEYS,t.react=X;for(var $ in z.VISITOR_KEYS)i($);z.FLIPPED_ALIAS_KEYS={},(0,B.default)(z.ALIAS_KEYS).forEach(function(e){z.ALIAS_KEYS[e].forEach(function(t){(z.FLIPPED_ALIAS_KEYS[t]=z.FLIPPED_ALIAS_KEYS[t]||[]).push(e)})}),(0,B.default)(z.FLIPPED_ALIAS_KEYS).forEach(function(e){z[e.toUpperCase()+"_TYPES"]=z.FLIPPED_ALIAS_KEYS[e],i(e)});t.TYPES=(0,B.default)(z.VISITOR_KEYS).concat((0,B.default)(z.FLIPPED_ALIAS_KEYS)).concat((0,B.default)(z.DEPRECATED_KEYS));(0,B.default)(z.BUILDER_KEYS).forEach(function(e){function t(){if(arguments.length>r.length)throw new Error("t."+e+": Too many arguments passed. Received "+arguments.length+" but can receive no more than "+r.length);var t={};t.type=e;for(var n=0,i=r,s=Array.isArray(i),a=0,i=s?i:(0,T.default)(i);;){var u;if(s){if(a>=i.length)break;u=i[a++]}else{if(a=i.next(),a.done)break;u=a.value}var l=u,c=z.NODE_FIELDS[e][l],f=arguments[n++];void 0===f&&(f=(0,Y.default)(c.default)),t[l]=f}for(var p in t)o(t,p,t[p]);return t}var r=z.BUILDER_KEYS[e];z[e]=t,z[e[0].toLowerCase()+e.slice(1)]=t});for(var Q in z.DEPRECATED_KEYS)!function(e){function t(t){return function(){return console.trace("The node type "+e+" has been renamed to "+r),t.apply(this,arguments)}}var r=z.DEPRECATED_KEYS[e];z[e]=z[e[0].toLowerCase()+e.slice(1)]=t(z[r]),z["is"+e]=t(z["is"+r]),z["assert"+e]=t(z["assert"+r])}(Q);(0,G.default)(z),(0,G.default)(z.VISITOR_KEYS);var Z=["tokens","start","end","loc","raw","rawValue"],ee=z.COMMENT_KEYS.concat(["comments"]).concat(Z)},function(e,t,r){"use strict";e.exports={default:r(404),__esModule:!0}},function(e,t){"use strict";t.__esModule=!0,t.default=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t){e=(0,l.default)(e);var r=e,n=r.program;return t.length&&(0,m.default)(e,A,null,t),n.body.length>1?n.body:n.body[0]}t.__esModule=!0;var a=r(10),o=i(a);t.default=function(e,t){var r=void 0;try{throw new Error}catch(e){e.stack&&(r=e.stack.split("\n").slice(1).join("\n"))}t=(0,f.default)({allowReturnOutsideFunction:!0,allowSuperOutsideMethod:!0,preserveComments:!1},t);var n=function(){var i=void 0;try{i=v.parse(e,t),i=m.default.removeProperties(i,{preserveComments:t.preserveComments}),m.default.cheap(i,function(e){e[E]=!0})}catch(e){throw e.stack=e.stack+"from\n"+r,e}return n=function(){return i},i};return function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return s(n(),t)}};var u=r(574),l=i(u),c=r(174),f=i(c),p=r(274),d=i(p),h=r(7),m=i(h),y=r(89),v=n(y),g=r(1),b=n(g),E="_fromTemplate",x=(0,o.default)(),A={noScope:!0,enter:function(e,t){var r=e.node;if(r[x])return e.skip();b.isExpressionStatement(r)&&(r=r.expression);var n=void 0;if(b.isIdentifier(r)&&r[E])if((0,d.default)(t[0],r.name))n=t[0][r.name];else if("$"===r.name[0]){var i=+r.name.slice(1);t[i]&&(n=t[i])}null===n&&e.remove(),n&&(n[x]=!0,e.replaceInline(n))},exit:function(e){var t=e.node;t.loc||m.default.clearNode(t)}};e.exports=t.default},function(e,t){"use strict";var r=e.exports={version:"2.5.0"};"number"==typeof __e&&(__e=r)},function(e,t){"use strict";var r=Array.isArray;e.exports=r},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t,r,n,i){if(e){if(t||(t={}),!t.noScope&&!r&&"Program"!==e.type&&"File"!==e.type)throw new Error(v.get("traverseNeedsParent",e.type));m.explode(t),s.node(e,t,r,n,i)}}function a(e,t){e.node.type===t.type&&(t.has=!0,e.stop())}t.__esModule=!0,t.visitors=t.Hub=t.Scope=t.NodePath=void 0;var o=r(2),u=i(o),l=r(36);Object.defineProperty(t,"NodePath",{enumerable:!0,get:function(){return i(l).default}});var c=r(134);Object.defineProperty(t,"Scope",{enumerable:!0,get:function(){return i(c).default}});var f=r(223);Object.defineProperty(t,"Hub",{enumerable:!0,get:function(){return i(f).default}}),t.default=s;var p=r(367),d=i(p),h=r(384),m=n(h),y=r(20),v=n(y),g=r(111),b=i(g),E=r(1),x=n(E),A=r(88),S=n(A);t.visitors=m,s.visitors=m,s.verify=m.verify,s.explode=m.explode,s.NodePath=r(36),s.Scope=r(134),s.Hub=r(223),s.cheap=function(e,t){return x.traverseFast(e,t)},s.node=function(e,t,r,n,i,s){var a=x.VISITOR_KEYS[e.type];if(a)for(var o=new d.default(r,t,n,i),l=a,c=Array.isArray(l),f=0,l=c?l:(0,u.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var h=p;if((!s||!s[h])&&o.visit(e,h))return}},s.clearNode=function(e,t){x.removeProperties(e,t),S.path.delete(e)},s.removeProperties=function(e,t){return x.traverseFast(e,s.clearNode,t),e},s.hasType=function(e,t,r,n){if((0,b.default)(n,e.type))return!1;if(e.type===r)return!0;var i={has:!1,type:r};return s(e,{blacklist:n,enter:a},t,i),i.has},s.clearCache=function(){S.clear()},s.clearCache.clearPath=S.clearPath,s.clearCache.clearScope=S.clearScope,s.copyCache=function(e,t){S.path.has(e)&&S.path.set(t,S.path.get(e))}},function(e,t){"use strict";function r(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function i(e){if(c===setTimeout)return setTimeout(e,0);if((c===r||!c)&&setTimeout)return c=setTimeout,setTimeout(e,0);try{return c(e,0)}catch(t){try{return c.call(null,e,0)}catch(t){return c.call(this,e,0)}}}function s(e){if(f===clearTimeout)return clearTimeout(e);if((f===n||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(e);try{return f(e)}catch(t){try{return f.call(null,e)}catch(t){return f.call(this,e)}}}function a(){m&&d&&(m=!1,d.length?h=d.concat(h):y=-1,h.length&&o())}function o(){if(!m){var e=i(a);m=!0;for(var t=h.length;t;){for(d=h,h=[];++y<t;)d&&d[y].run();y=-1,t=h.length}d=null,m=!1,s(e)}}function u(e,t){this.fun=e,this.array=t}function l(){}var c,f,p=e.exports={};!function(){try{c="function"==typeof setTimeout?setTimeout:r}catch(e){c=r}try{f="function"==typeof clearTimeout?clearTimeout:n}catch(e){f=n}}();var d,h=[],m=!1,y=-1;p.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];h.push(new u(e,t)),1!==h.length||m||i(o)},u.prototype.run=function(){this.fun.apply(null,this.array)},p.title="browser",p.browser=!0,p.env={},p.argv=[],p.version="",p.versions={},p.on=l,p.addListener=l,p.once=l,p.off=l,p.removeListener=l,p.removeAllListeners=l,p.emit=l,p.prependListener=l,p.prependOnceListener=l,p.listeners=function(e){return[]},p.binding=function(e){throw new Error("process.binding is not supported")},p.cwd=function(){return"/"},p.chdir=function(e){throw new Error("process.chdir is not supported")},p.umask=function(){return 0}},function(e,t,r){"use strict";e.exports={default:r(409),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(414),__esModule:!0}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.__esModule=!0;var s=r(363),a=n(s),o=r(10),u=n(o),l="function"==typeof u.default&&"symbol"===i(a.default)?function(e){return void 0===e?"undefined":i(e)}:function(e){return e&&"function"==typeof u.default&&e.constructor===u.default&&e!==u.default.prototype?"symbol":void 0===e?"undefined":i(e)};t.default="function"==typeof u.default&&"symbol"===l(a.default)?function(e){return void 0===e?"undefined":l(e)}:function(e){return e&&"function"==typeof u.default&&e.constructor===u.default&&e!==u.default.prototype?"symbol":void 0===e?"undefined":l(e)}},function(e,t,r){"use strict";var n=r(15),i=r(5),s=r(43),a=r(29),o=function e(t,r,o){var u,l,c,f=t&e.F,p=t&e.G,d=t&e.S,h=t&e.P,m=t&e.B,y=t&e.W,v=p?i:i[r]||(i[r]={}),g=v.prototype,b=p?n:d?n[r]:(n[r]||{}).prototype;p&&(o=r);for(u in o)(l=!f&&b&&void 0!==b[u])&&u in v||(c=l?b[u]:o[u],v[u]=p&&"function"!=typeof b[u]?o[u]:m&&l?s(c,n):y&&b[u]==c?function(e){var t=function(t,r,n){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,r)}return new e(t,r,n)}return e.apply(this,arguments)};return t.prototype=e.prototype,t}(c):h&&"function"==typeof c?s(Function.call,c):c,h&&((v.virtual||(v.virtual={}))[u]=c,t&e.R&&g&&!g[u]&&a(g,u,c)))};o.F=1,o.G=2,o.S=4,o.P=8,o.B=16,o.W=32,o.U=64,o.R=128,e.exports=o},function(e,t,r){"use strict";var n=r(151)("wks"),i=r(95),s=r(15).Symbol,a="function"==typeof s;(e.exports=function(e){return n[e]||(n[e]=a&&s[e]||(a?s:i)("Symbol."+e))}).store=n},function(e,t,r){"use strict";e.exports={default:r(411),__esModule:!0}},function(e,t){"use strict";var r=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=function(e){return"object"===(void 0===e?"undefined":r(e))?null!==e:"function"==typeof e}},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(261),s="object"==("undefined"==typeof self?"undefined":n(self))&&self&&self.Object===Object&&self,a=i||s||Function("return this")();e.exports=a},function(e,t){"use strict";function r(e){var t=void 0===e?"undefined":n(e);return null!=e&&("object"==t||"function"==t)}var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=r},function(e,t,r){(function(e){"use strict";function r(e,t){for(var r=0,n=e.length-1;n>=0;n--){var i=e[n];"."===i?e.splice(n,1):".."===i?(e.splice(n,1),r++):r&&(e.splice(n,1),r--)}if(t)for(;r--;r)e.unshift("..");return e}function n(e,t){if(e.filter)return e.filter(t);for(var r=[],n=0;n<e.length;n++)t(e[n],n,e)&&r.push(e[n]);return r}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,s=function(e){return i.exec(e).slice(1)};t.resolve=function(){for(var t="",i=!1,s=arguments.length-1;s>=-1&&!i;s--){var a=s>=0?arguments[s]:e.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(t=a+"/"+t,i="/"===a.charAt(0))}return t=r(n(t.split("/"),function(e){return!!e}),!i).join("/"),(i?"/":"")+t||"."},t.normalize=function(e){var i=t.isAbsolute(e),s="/"===a(e,-1);return e=r(n(e.split("/"),function(e){return!!e}),!i).join("/"),e||i||(e="."),e&&s&&(e+="/"),(i?"/":"")+e},t.isAbsolute=function(e){return"/"===e.charAt(0)},t.join=function(){var e=Array.prototype.slice.call(arguments,0);return t.normalize(n(e,function(e,t){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},t.relative=function(e,r){function n(e){for(var t=0;t<e.length&&""===e[t];t++);for(var r=e.length-1;r>=0&&""===e[r];r--);return t>r?[]:e.slice(t,r-t+1)}e=t.resolve(e).substr(1),r=t.resolve(r).substr(1);for(var i=n(e.split("/")),s=n(r.split("/")),a=Math.min(i.length,s.length),o=a,u=0;u<a;u++)if(i[u]!==s[u]){o=u;break}for(var l=[],u=o;u<i.length;u++)l.push("..");return l=l.concat(s.slice(o)),l.join("/")},t.sep="/",t.delimiter=":",t.dirname=function(e){var t=s(e),r=t[0],n=t[1];return r||n?(n&&(n=n.substr(0,n.length-1)),r+n):"."},t.basename=function(e,t){var r=s(e)[2];return t&&r.substr(-1*t.length)===t&&(r=r.substr(0,r.length-t.length)),r},t.extname=function(e){return s(e)[3]};var a="b"==="ab".substr(-1)?function(e,t,r){return e.substr(t,r)}:function(e,t,r){return t<0&&(t=e.length+t),e.substr(t,r)}}).call(t,r(8))},function(e,t,r){"use strict";function n(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];var s=l[e];if(!s)throw new ReferenceError("Unknown message "+(0,a.default)(e));return r=i(r),s.replace(/\$(\d+)/g,function(e,t){return r[t-1]})}function i(e){return e.map(function(e){if(null!=e&&e.inspect)return e.inspect();try{return(0,a.default)(e)||e+""}catch(t){return u.inspect(e)}})}t.__esModule=!0,t.MESSAGES=void 0;var s=r(35),a=function(e){return e&&e.__esModule?e:{default:e}}(s);t.get=n,t.parseArgs=i;var o=r(117),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(o),l=t.MESSAGES={tailCallReassignmentDeopt:"Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",classesIllegalBareSuper:"Illegal use of bare super",classesIllegalSuperCall:"Direct super call is illegal in non-constructor, use super.$1() instead",scopeDuplicateDeclaration:"Duplicate declaration $1",settersNoRest:"Setters aren't allowed to have a rest",noAssignmentsInForHead:"No assignments allowed in for-in/of head",expectedMemberExpressionOrIdentifier:"Expected type MemberExpression or Identifier",invalidParentForThisNode:"We don't know how to handle this node within the current parent - please open an issue",readOnly:"$1 is read-only",unknownForHead:"Unknown node type $1 in ForStatement",didYouMean:"Did you mean $1?",codeGeneratorDeopt:"Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",missingTemplatesDirectory:"no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",unsupportedOutputType:"Unsupported output type $1",illegalMethodName:"Illegal method name $1",lostTrackNodePath:"We lost track of this node's position, likely because the AST was directly manipulated",modulesIllegalExportName:"Illegal export $1",modulesDuplicateDeclarations:"Duplicate module declarations with the same source but in different scopes",undeclaredVariable:"Reference to undeclared variable $1",undeclaredVariableType:"Referencing a type alias outside of a type annotation",undeclaredVariableSuggestion:"Reference to undeclared variable $1 - did you mean $2?",traverseNeedsParent:"You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",traverseVerifyRootFunction:"You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",traverseVerifyVisitorProperty:"You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",traverseVerifyNodeType:"You gave us a visitor for the node type $1 but it's not a valid type",pluginNotObject:"Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",pluginNotFunction:"Plugin $2 specified in $1 was expected to return a function but returned $3",
pluginUnknown:"Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",pluginInvalidProperty:"Plugin $2 specified in $1 provided an invalid property of $3"}},function(e,t,r){"use strict";var n=r(16);e.exports=function(e){if(!n(e))throw TypeError(e+" is not an object!");return e}},function(e,t,r){"use strict";e.exports=!r(27)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(e,t,r){"use strict";var n=r(21),i=r(231),s=r(154),a=Object.defineProperty;t.f=r(22)?Object.defineProperty:function(e,t,r){if(n(e),t=s(t,!0),n(r),i)try{return a(e,t,r)}catch(e){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(e[t]=r.value),e}},function(e,t,r){"use strict";function n(e){return null!=e&&s(e.length)&&!i(e)}var i=r(175),s=r(176);e.exports=n},function(e,t){"use strict";function r(e){return null!=e&&"object"==(void 0===e?"undefined":n(e))}var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=r},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return Array.isArray(e)?"array":null===e?"null":void 0===e?"undefined":void 0===e?"undefined":(0,v.default)(e)}function s(e){function t(t,r,n){if(Array.isArray(n))for(var i=0;i<n.length;i++)e(t,r+"["+i+"]",n[i])}return t.each=e,t}function a(){function e(e,t,n){if(r.indexOf(n)<0)throw new TypeError("Property "+t+" expected value to be one of "+(0,m.default)(r)+" but got "+(0,m.default)(n))}for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return e.oneOf=r,e}function o(){function e(e,t,n){for(var i=!1,s=r,a=Array.isArray(s),o=0,s=a?s:(0,d.default)(s);;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u;if(b.is(l,n)){i=!0;break}}if(!i)throw new TypeError("Property "+t+" of "+e.type+" expected node to be of a type "+(0,m.default)(r)+" but instead got "+(0,m.default)(n&&n.type))}for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return e.oneOfNodeTypes=r,e}function u(){function e(e,t,n){for(var s=!1,a=r,o=Array.isArray(a),u=0,a=o?a:(0,d.default)(a);;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;if(i(n)===c||b.is(c,n)){s=!0;break}}if(!s)throw new TypeError("Property "+t+" of "+e.type+" expected node to be of a type "+(0,m.default)(r)+" but instead got "+(0,m.default)(n&&n.type))}for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return e.oneOfNodeOrValueTypes=r,e}function l(e){function t(t,r,n){if(i(n)!==e)throw new TypeError("Property "+r+" expected type of "+e+" but got "+i(n))}return t.type=e,t}function c(){function e(){for(var e=r,t=Array.isArray(e),n=0,e=t?e:(0,d.default)(e);;){var i;if(t){if(n>=e.length)break;i=e[n++]}else{if(n=e.next(),n.done)break;i=n.value}i.apply(void 0,arguments)}}for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return e.chainOf=r,e}function f(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.inherits&&D[t.inherits]||{};t.fields=t.fields||r.fields||{},t.visitor=t.visitor||r.visitor||[],t.aliases=t.aliases||r.aliases||[],t.builder=t.builder||r.builder||t.visitor||[],t.deprecatedAlias&&(_[t.deprecatedAlias]=e);for(var n=t.visitor.concat(t.builder),s=Array.isArray(n),a=0,n=s?n:(0,d.default)(n);;){var o;if(s){if(a>=n.length)break;o=n[a++]}else{if(a=n.next(),a.done)break;o=a.value}var u=o;t.fields[u]=t.fields[u]||{}}for(var c in t.fields){var f=t.fields[c];-1===t.builder.indexOf(c)&&(f.optional=!0),void 0===f.default?f.default=null:f.validate||(f.validate=l(i(f.default)))}E[e]=t.visitor,S[e]=t.builder,A[e]=t.fields,x[e]=t.aliases,D[e]=t}t.__esModule=!0,t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.NODE_FIELDS=t.ALIAS_KEYS=t.VISITOR_KEYS=void 0;var p=r(2),d=n(p),h=r(35),m=n(h),y=r(11),v=n(y);t.assertEach=s,t.assertOneOf=a,t.assertNodeType=o,t.assertNodeOrValueType=u,t.assertValueType=l,t.chain=c,t.default=f;var g=r(1),b=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(g),E=t.VISITOR_KEYS={},x=t.ALIAS_KEYS={},A=t.NODE_FIELDS={},S=t.BUILDER_KEYS={},_=t.DEPRECATED_KEYS={},D={}},function(e,t){"use strict";e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,t){"use strict";var r={}.hasOwnProperty;e.exports=function(e,t){return r.call(e,t)}},function(e,t,r){"use strict";var n=r(23),i=r(92);e.exports=r(22)?function(e,t,r){return n.f(e,t,i(1,r))}:function(e,t,r){return e[t]=r,e}},function(e,t,r){"use strict";function n(e){return null==e?void 0===e?u:o:l&&l in Object(e)?s(e):a(e)}var i=r(45),s=r(534),a=r(559),o="[object Null]",u="[object Undefined]",l=i?i.toStringTag:void 0;e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n){var a=!r;r||(r={});for(var o=-1,u=t.length;++o<u;){var l=t[o],c=n?n(r[l],e[l],l,r,e):void 0;void 0===c&&(c=e[l]),a?s(r,l,c):i(r,l,c)}return r}var i=r(162),s=r(163);e.exports=n},function(e,t,r){"use strict";function n(e){return a(e)?i(e):s(e)}var i=r(245),s=r(500),a=r(24);e.exports=n},function(e,t){"use strict";e.exports={filename:{type:"filename",description:"filename to use when reading from stdin - this will be used in source-maps, errors etc",default:"unknown",shorthand:"f"},filenameRelative:{hidden:!0,type:"string"},inputSourceMap:{hidden:!0},env:{hidden:!0,default:{}},mode:{description:"",hidden:!0},retainLines:{type:"boolean",default:!1,description:"retain line numbers - will result in really ugly code"},highlightCode:{description:"enable/disable ANSI syntax highlighting of code frames (on by default)",type:"boolean",default:!0},suppressDeprecationMessages:{type:"boolean",default:!1,hidden:!0},presets:{type:"list",description:"",default:[]},plugins:{type:"list",default:[],description:""},ignore:{type:"list",description:"list of glob paths to **not** compile",default:[]},only:{type:"list",description:"list of glob paths to **only** compile"},code:{hidden:!0,default:!0,type:"boolean"},metadata:{hidden:!0,default:!0,type:"boolean"},ast:{hidden:!0,default:!0,type:"boolean"},extends:{type:"string",hidden:!0},comments:{type:"boolean",default:!0,description:"write comments to generated output (true by default)"},shouldPrintComment:{hidden:!0,description:"optional callback to control whether a comment should be inserted, when this is used the comments option is ignored"},wrapPluginVisitorMethod:{hidden:!0,description:"optional callback to wrap all visitor methods"},compact:{type:"booleanString",default:"auto",description:"do not include superfluous whitespace characters and line terminators [true|false|auto]"},minified:{type:"boolean",default:!1,description:"save as much bytes when printing [true|false]"},sourceMap:{alias:"sourceMaps",hidden:!0},sourceMaps:{type:"booleanString",description:"[true|false|inline]",default:!1,shorthand:"s"},sourceMapTarget:{type:"string",description:"set `file` on returned source map"},sourceFileName:{type:"string",description:"set `sources[0]` on returned source map"},sourceRoot:{type:"filename",description:"the root from which all sources are relative"},babelrc:{description:"Whether or not to look up .babelrc and .babelignore files",type:"boolean",default:!0},sourceType:{description:"",default:"module"},auxiliaryCommentBefore:{type:"string",description:"print a comment before any injected non-user code"},auxiliaryCommentAfter:{type:"string",description:"print a comment after any injected non-user code"},resolveModuleSource:{hidden:!0},getModuleId:{hidden:!0},moduleRoot:{type:"filename",description:"optional prefix for the AMD module formatter that will be prepend to the filename on module definitions"},moduleIds:{type:"boolean",default:!1,shorthand:"M",description:"insert an explicit id for modules"},moduleId:{description:"specify a custom name for module ids",type:"string"},passPerPreset:{description:"Whether to spawn a traversal pass per a preset. By default all presets are merged.",type:"boolean",default:!1,hidden:!0},parserOpts:{description:"Options to pass into the parser, or to change parsers (parserOpts.parser)",default:!1},generatorOpts:{description:"Options to pass into the generator, or to change generators (generatorOpts.generator)",default:!1}}},function(e,t,r){(function(n){"use strict";function i(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function s(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var a=r(366),o=s(a),u=r(35),l=s(u),c=r(87),f=s(c),p=r(2),d=s(p),h=r(11),m=s(h),y=r(3),v=s(y),g=r(182),b=i(g),E=r(65),x=s(E),A=r(20),S=i(A),_=r(52),D=r(184),C=s(D),w=r(185),P=s(w),k=r(575),F=s(k),T=r(109),O=s(T),B=r(293),R=s(B),I=r(33),M=s(I),N=r(54),L=s(N),j=r(51),U=s(j),V=r(19),G=s(V),W=function(){function e(t){(0,v.default)(this,e),this.resolvedConfigs=[],this.options=e.createBareOptions(),this.log=t}return e.memoisePluginContainer=function(t,r,n,i){for(var s=e.memoisedPlugins,a=Array.isArray(s),o=0,s=a?s:(0,d.default)(s);;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u;if(l.container===t)return l.plugin}var c=void 0;if(c="function"==typeof t?t(b):t,"object"===(void 0===c?"undefined":(0,m.default)(c))){var f=new x.default(c,i);return e.memoisedPlugins.push({container:t,plugin:f}),f}throw new TypeError(S.get("pluginNotObject",r,n,void 0===c?"undefined":(0,m.default)(c))+r+n)},e.createBareOptions=function(){var e={};for(var t in M.default){var r=M.default[t];e[t]=(0,O.default)(r.default)}return e},e.normalisePlugin=function(t,r,n,i){if(!((t=t.__esModule?t.default:t)instanceof x.default)){if("function"!=typeof t&&"object"!==(void 0===t?"undefined":(0,m.default)(t)))throw new TypeError(S.get("pluginNotFunction",r,n,void 0===t?"undefined":(0,m.default)(t)));t=e.memoisePluginContainer(t,r,n,i)}return t.init(r,n),t},e.normalisePlugins=function(t,n,i){return i.map(function(i,s){var a=void 0,o=void 0;if(!i)throw new TypeError("Falsy value found in plugins");Array.isArray(i)?(a=i[0],o=i[1]):a=i;var u="string"==typeof a?a:t+"$"+s;if("string"==typeof a){var l=(0,C.default)(a,n);if(!l)throw new ReferenceError(S.get("pluginUnknown",a,t,s,n));a=r(179)(l)}return a=e.normalisePlugin(a,t,s,u),[a,o]})},e.prototype.mergeOptions=function(t){var r=this,i=t.options,s=t.extending,a=t.alias,o=t.loc,u=t.dirname;if(a=a||"foreign",i){("object"!==(void 0===i?"undefined":(0,m.default)(i))||Array.isArray(i))&&this.log.error("Invalid options type for "+a,TypeError);var l=(0,F.default)(i,function(e){if(e instanceof x.default)return e});u=u||n.cwd(),o=o||a;for(var c in l){if(!M.default[c]&&this.log)if(L.default[c])this.log.error("Using removed Babel 5 option: "+a+"."+c+" - "+L.default[c].message,ReferenceError);else{var p="Unknown option: "+a+"."+c+". Check out http://babeljs.io/docs/usage/options/ for more information about options.";this.log.error(p+"\n\nA common cause of this error is the presence of a configuration options object without the corresponding preset name. Example:\n\nInvalid:\n  `{ presets: [{option: value}] }`\nValid:\n  `{ presets: [['presetName', {option: value}]] }`\n\nFor more detailed information on preset configuration, please see http://babeljs.io/docs/plugins/#pluginpresets-options.",ReferenceError)}}(0,_.normaliseOptions)(l),l.plugins&&(l.plugins=e.normalisePlugins(o,u,l.plugins)),l.presets&&(l.passPerPreset?l.presets=this.resolvePresets(l.presets,u,function(e,t){r.mergeOptions({options:e,extending:e,alias:t,loc:t,dirname:u})}):(this.mergePresets(l.presets,u),delete l.presets)),i===s?(0,f.default)(s,l):(0,R.default)(s||this.options,l)}},e.prototype.mergePresets=function(e,t){var r=this;this.resolvePresets(e,t,function(e,t){r.mergeOptions({options:e,alias:t,loc:t,dirname:G.default.dirname(t||"")})})},e.prototype.resolvePresets=function(e,t,n){return e.map(function(e){var i=void 0;if(Array.isArray(e)){if(e.length>2)throw new Error("Unexpected extra options "+(0,l.default)(e.slice(2))+" passed to preset.");var s=e;e=s[0],i=s[1]}var a=void 0;try{if("string"==typeof e){if(!(a=(0,P.default)(e,t)))throw new Error("Couldn't find preset "+(0,l.default)(e)+" relative to directory "+(0,l.default)(t));e=r(179)(a)}if("object"===(void 0===e?"undefined":(0,m.default)(e))&&e.__esModule)if(e.default)e=e.default;else{var u=e,c=(u.__esModule,(0,o.default)(u,["__esModule"]));e=c}if("object"===(void 0===e?"undefined":(0,m.default)(e))&&e.buildPreset&&(e=e.buildPreset),"function"!=typeof e&&void 0!==i)throw new Error("Options "+(0,l.default)(i)+" passed to "+(a||"a preset")+" which does not accept options.");if("function"==typeof e&&(e=e(b,i,{dirname:t})),"object"!==(void 0===e?"undefined":(0,m.default)(e)))throw new Error("Unsupported preset format: "+e+".");n&&n(e,a)}catch(e){throw a&&(e.message+=" (While processing preset: "+(0,l.default)(a)+")"),e}return e})},e.prototype.normaliseOptions=function(){var e=this.options;for(var t in M.default){var r=M.default[t],n=e[t];!n&&r.optional||(r.alias?e[r.alias]=e[r.alias]||n:e[t]=n)}},e.prototype.init=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=(0,U.default)(e,this.log),r=Array.isArray(t),n=0,t=r?t:(0,d.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;this.mergeOptions(s)}return this.normaliseOptions(e),this.options},e}();t.default=W,W.memoisedPlugins=[],e.exports=t.default}).call(t,r(8))},function(e,t,r){"use strict";e.exports={default:r(405),__esModule:!0}},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var s=r(2),a=i(s),o=r(3),u=i(o),l=r(224),c=n(l),f=r(239),p=i(f),d=r(466),h=i(d),m=r(7),y=i(m),v=r(174),g=i(v),b=r(134),E=i(b),x=r(1),A=n(x),S=r(88),_=(0,p.default)("babel"),D=function(){function e(t,r){(0,u.default)(this,e),this.parent=r,this.hub=t,this.contexts=[],this.data={},this.shouldSkip=!1,this.shouldStop=!1,this.removed=!1,this.state=null,this.opts=null,this.skipKeys=null,this.parentPath=null,this.context=null,this.container=null,this.listKey=null,this.inList=!1,this.parentKey=null,this.key=null,this.node=null,this.scope=null,this.type=null,this.typeAnnotation=null}return e.get=function(t){var r=t.hub,n=t.parentPath,i=t.parent,s=t.container,a=t.listKey,o=t.key;!r&&n&&(r=n.hub),(0,h.default)(i,"To get a node path the parent needs to exist");var u=s[o],l=S.path.get(i)||[];S.path.has(i)||S.path.set(i,l);for(var c=void 0,f=0;f<l.length;f++){var p=l[f];if(p.node===u){c=p;break}}return c||(c=new e(r,i),l.push(c)),c.setup(n,s,a,o),c},e.prototype.getScope=function(e){var t=e;return this.isScope()&&(t=new E.default(this,e)),t},e.prototype.setData=function(e,t){return this.data[e]=t},e.prototype.getData=function(e,t){var r=this.data[e];return!r&&t&&(r=this.data[e]=t),r},e.prototype.buildCodeFrameError=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:SyntaxError;return this.hub.file.buildCodeFrameError(this.node,e,t)},e.prototype.traverse=function(e,t){(0,y.default)(this.node,e,this.scope,t,this)},e.prototype.mark=function(e,t){this.hub.file.metadata.marked.push({type:e,message:t,loc:this.node.loc})},e.prototype.set=function(e,t){A.validate(this.node,e,t),this.node[e]=t},e.prototype.getPathLocation=function(){var e=[],t=this;do{var r=t.key;t.inList&&(r=t.listKey+"["+r+"]"),e.unshift(r)}while(t=t.parentPath);return e.join(".")},e.prototype.debug=function(e){_.enabled&&_(this.getPathLocation()+" "+this.type+": "+e())},e}();t.default=D,(0,g.default)(D.prototype,r(368)),(0,g.default)(D.prototype,r(374)),(0,g.default)(D.prototype,r(382)),(0,g.default)(D.prototype,r(372)),(0,g.default)(D.prototype,r(371)),(0,g.default)(D.prototype,r(377)),(0,g.default)(D.prototype,r(370)),(0,g.default)(D.prototype,r(381)),(0,g.default)(D.prototype,r(380)),(0,g.default)(D.prototype,r(373)),(0,g.default)(D.prototype,r(369));for(var C=A.TYPES,w=Array.isArray(C),P=0,C=w?C:(0,a.default)(C);;){var k;if("break"===function(){if(w){if(P>=C.length)return"break";k=C[P++]}else{if(P=C.next(),P.done)return"break";k=P.value}var e=k,t="is"+e;D.prototype[t]=function(e){return A[t](this.node,e)},D.prototype["assert"+e]=function(r){if(!this[t](r))throw new TypeError("Expected node path of type "+e)}}())break}for(var F in c){(function(e){if("_"===e[0])return"continue";A.TYPES.indexOf(e)<0&&A.TYPES.push(e);var t=c[e];D.prototype["is"+e]=function(e){return t.checkPath(this,e)}})(F)}e.exports=t.default},function(e,t,r){"use strict";var n=r(142),i=r(140);e.exports=function(e){return n(i(e))}},function(e,t,r){"use strict";function n(e,t){var r=s(e,t);return i(r)?r:void 0}var i=r(497),s=r(535);e.exports=n},function(e,t){"use strict";e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children=[],e.webpackPolyfill=1),e}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t,r,n){if(e.selfReference){if(!n.hasBinding(r.name)||n.hasGlobal(r.name)){if(!f.isFunction(t))return;var i=p;t.generator&&(i=d);var s=i({FUNCTION:t,FUNCTION_ID:r,FUNCTION_KEY:n.generateUidIdentifier(r.name)}).expression;s.callee._skipModulesRemap=!0;for(var a=s.callee.body.body[0].params,u=0,l=(0,o.default)(t);u<l;u++)a.push(n.generateUidIdentifier("x"));return s}n.rename(r.name)}t.id=r,n.getProgramParent().references[r.name]=!0}function s(e,t,r){var n={selfAssignment:!1,selfReference:!1,outerDeclar:r.getBindingIdentifier(t),references:[],name:t},i=r.getOwnBinding(t);return i?"param"===i.kind&&(n.selfReference=!0):(n.outerDeclar||r.hasGlobal(t))&&r.traverse(e,h,n),n}t.__esModule=!0,t.default=function(e){var t=e.node,r=e.parent,n=e.scope,a=e.id;if(!t.id){if(!f.isObjectProperty(r)&&!f.isObjectMethod(r,{kind:"method"})||r.computed&&!f.isLiteral(r.key)){if(f.isVariableDeclarator(r)){if(a=r.id,f.isIdentifier(a)){var o=n.parent.getBinding(a.name);if(o&&o.constant&&n.getBinding(a.name)===o)return t.id=a,void(t.id[f.NOT_LOCAL_BINDING]=!0)}}else if(f.isAssignmentExpression(r))a=r.left;else if(!a)return}else a=r.key;var u=void 0;if(a&&f.isLiteral(a))u=a.value;else{if(!a||!f.isIdentifier(a))return;u=a.name}u=f.toBindingIdentifierName(u),a=f.identifier(u),a[f.NOT_LOCAL_BINDING]=!0;return i(s(t,u,n),t,a,n)||t}};var a=r(189),o=n(a),u=r(4),l=n(u),c=r(1),f=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(c),p=(0,l.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),d=(0,l.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),h={"ReferencedIdentifier|BindingIdentifier":function(e,t){if(e.node.name===t.name){e.scope.getBindingIdentifier(t.name)===t.outerDeclar&&(t.selfReference=!0,e.stop())}}};e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(361),s=n(i),a=r(9),o=n(a),u=r(11),l=n(u);t.default=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+(void 0===t?"undefined":(0,l.default)(t)));e.prototype=(0,o.default)(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(s.default?(0,s.default)(e,t):e.__proto__=t)}},function(e,t,r){"use strict";t.__esModule=!0;var n=r(11),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!==(void 0===t?"undefined":(0,i.default)(t))&&"function"!=typeof t?e:t}},function(e,t,r){"use strict";var n=r(227);e.exports=function(e,t,r){if(n(e),void 0===t)return e;switch(r){case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,i){return e.call(t,r,n,i)}}return function(){return e.apply(t,arguments)}}},function(e,t,r){"use strict";var n=r(237),i=r(141);e.exports=Object.keys||function(e){return n(e,i)}},function(e,t,r){"use strict";var n=r(17),i=n.Symbol;e.exports=i},function(e,t){"use strict";function r(e,t){return e===t||e!==e&&t!==t}e.exports=r},function(e,t,r){"use strict";function n(e){return a(e)?i(e,!0):s(e)}var i=r(245),s=r(501),a=r(24);e.exports=n},function(e,t,r){"use strict";function n(e){var t=i(e),r=t%1;return t===t?r?t-r:t:0}var i=r(597);e.exports=n},function(e,t){(function(t){e.exports=t}).call(t,{})},function(e,t,r){(function(e){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.File=void 0;var s=r(2),a=i(s),o=r(9),u=i(o),l=r(87),c=i(l),f=r(3),p=i(f),d=r(42),h=i(d),m=r(41),y=i(m),v=r(194),g=i(v),b=r(121),E=n(b),x=r(403),A=i(x),S=r(34),_=i(S),D=r(299),C=i(D),w=r(7),P=i(w),k=r(288),F=i(k),T=r(186),O=i(T),B=r(181),R=i(B),I=r(273),M=i(I),N=r(120),L=i(N),j=r(119),U=i(j),V=r(89),G=r(122),W=n(G),Y=r(19),q=i(Y),K=r(1),H=n(K),J=r(118),X=i(J),z=r(296),$=i(z),Q=r(297),Z=i(Q),ee=/^#!.*/,te=[[$.default],[Z.default]],re={enter:function(e,t){var r=e.node.loc;r&&(t.loc=r,e.stop())}},ne=function(t){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments[1];(0,p.default)(this,n);var i=(0,h.default)(this,t.call(this));return i.pipeline=r,i.log=new L.default(i,e.filename||"unknown"),i.opts=i.initOptions(e),i.parserOpts={sourceType:i.opts.sourceType,sourceFileName:i.opts.filename,plugins:[]},i.pluginVisitors=[],i.pluginPasses=[],i.buildPluginsForOptions(i.opts),i.opts.passPerPreset&&(i.perPresetOpts=[],i.opts.presets.forEach(function(e){var t=(0,c.default)((0,u.default)(i.opts),e);i.perPresetOpts.push(t),i.buildPluginsForOptions(t)})),i.metadata={usedHelpers:[],marked:[],modules:{imports:[],exports:{exported:[],specifiers:[]}}},i.dynamicImportTypes={},i.dynamicImportIds={},i.dynamicImports=[],i.declarations={},i.usedHelpers={},i.path=null,i.ast={},i.code="",i.shebang="",i.hub=new w.Hub(i),i}return(0,y.default)(n,t),n.prototype.getMetadata=function(){for(var e=!1,t=this.ast.program.body,r=Array.isArray(t),n=0,t=r?t:(0,a.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;if(H.isModuleDeclaration(s)){e=!0;break}}e&&this.path.traverse(E,this)},n.prototype.initOptions=function(e){e=new _.default(this.log,this.pipeline).init(e),e.inputSourceMap&&(e.sourceMaps=!0),e.moduleId&&(e.moduleIds=!0),e.basename=q.default.basename(e.filename,q.default.extname(e.filename)),e.ignore=W.arrayify(e.ignore,W.regexify),e.only&&(e.only=W.arrayify(e.only,W.regexify)),(0,M.default)(e,{moduleRoot:e.sourceRoot}),(0,M.default)(e,{sourceRoot:e.moduleRoot}),(0,M.default)(e,{filenameRelative:e.filename});var t=q.default.basename(e.filenameRelative);return(0,M.default)(e,{sourceFileName:t,sourceMapTarget:t}),e},n.prototype.buildPluginsForOptions=function(e){if(Array.isArray(e.plugins)){for(var t=e.plugins.concat(te),r=[],n=[],i=t,s=Array.isArray(i),o=0,i=s?i:(0,a.default)(i);;){var u;if(s){if(o>=i.length)break;u=i[o++]}else{if(o=i.next(),o.done)break;u=o.value}var l=u,c=l[0],f=l[1];r.push(c.visitor),n.push(new C.default(this,c,f)),c.manipulateOptions&&c.manipulateOptions(e,this.parserOpts,this)}this.pluginVisitors.push(r),this.pluginPasses.push(n)}},n.prototype.getModuleName=function(){var e=this.opts;if(!e.moduleIds)return null;if(null!=e.moduleId&&!e.getModuleId)return e.moduleId;var t=e.filenameRelative,r="";if(null!=e.moduleRoot&&(r=e.moduleRoot+"/"),!e.filenameRelative)return r+e.filename.replace(/^\//,"");if(null!=e.sourceRoot){var n=new RegExp("^"+e.sourceRoot+"/?");t=t.replace(n,"")}return t=t.replace(/\.(\w*?)$/,""),r+=t,r=r.replace(/\\/g,"/"),e.getModuleId?e.getModuleId(r)||r:r},n.prototype.resolveModuleSource=function(e){var t=this.opts.resolveModuleSource;return t&&(e=t(e,this.opts.filename)),e},n.prototype.addImport=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t,n=e+":"+t,i=this.dynamicImportIds[n];if(!i){e=this.resolveModuleSource(e),i=this.dynamicImportIds[n]=this.scope.generateUidIdentifier(r);var s=[];"*"===t?s.push(H.importNamespaceSpecifier(i)):"default"===t?s.push(H.importDefaultSpecifier(i)):s.push(H.importSpecifier(i,H.identifier(t)));var a=H.importDeclaration(s,H.stringLiteral(e));a._blockHoist=3,this.path.unshiftContainer("body",a)}return i},n.prototype.addHelper=function(e){var t=this.declarations[e];if(t)return t;this.usedHelpers[e]||(this.metadata.usedHelpers.push(e),this.usedHelpers[e]=!0);var r=this.get("helperGenerator"),n=this.get("helpersNamespace");if(r){var i=r(e);if(i)return i}else if(n)return H.memberExpression(n,H.identifier(e));var s=(0,g.default)(e),a=this.declarations[e]=this.scope.generateUidIdentifier(e);return H.isFunctionExpression(s)&&!s.id?(s.body._compact=!0,s._generated=!0,s.id=a,s.type="FunctionDeclaration",this.path.unshiftContainer("body",s)):(s._compact=!0,this.scope.push({id:a,init:s,unique:!0})),a},n.prototype.addTemplateObject=function(e,t,r){var n=r.elements.map(function(e){return e.value}),i=e+"_"+r.elements.length+"_"+n.join(","),s=this.declarations[i];if(s)return s;var a=this.declarations[i]=this.scope.generateUidIdentifier("templateObject"),o=this.addHelper(e),u=H.callExpression(o,[t,r]);return u._compact=!0,this.scope.push({id:a,init:u,_blockHoist:1.9}),a},n.prototype.buildCodeFrameError=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:SyntaxError,n=e&&(e.loc||e._loc),i=new r(t);return n?i.loc=n.start:((0,P.default)(e,re,this.scope,i),i.message+=" (This is an error on an internal node. Probably an internal error",i.loc&&(i.message+=". Location has been estimated."),i.message+=")"),i},n.prototype.mergeSourceMap=function(e){var t=this.opts.inputSourceMap;if(t){var r=new F.default.SourceMapConsumer(t),n=new F.default.SourceMapConsumer(e),i=new F.default.SourceMapGenerator({file:r.file,sourceRoot:r.sourceRoot}),s=n.sources[0];r.eachMapping(function(e){var t=n.generatedPositionFor({line:e.generatedLine,column:e.generatedColumn,source:s});null!=t.column&&i.addMapping({source:e.source,original:null==e.source?null:{line:e.originalLine,column:e.originalColumn},generated:t})});var a=i.toJSON();return t.mappings=a.mappings,t}return e},n.prototype.parse=function(t){var n=V.parse,i=this.opts.parserOpts;if(i&&(i=(0,c.default)({},this.parserOpts,i),i.parser)){if("string"==typeof i.parser){var s=q.default.dirname(this.opts.filename)||e.cwd(),a=(0,X.default)(i.parser,s);if(!a)throw new Error("Couldn't find parser "+i.parser+' with "parse" method relative to directory '+s);n=r(178)(a).parse}else n=i.parser;i.parser={parse:function(e){return(0,V.parse)(e,i)}}}this.log.debug("Parse start");var o=n(t,i||this.parserOpts);return this.log.debug("Parse stop"),o},n.prototype._addAst=function(e){this.path=w.NodePath.get({hub:this.hub,parentPath:null,parent:e,container:e,key:"program"}).setContext(),this.scope=this.path.scope,this.ast=e,this.getMetadata()},n.prototype.addAst=function(e){this.log.debug("Start set AST"),this._addAst(e),this.log.debug("End set AST")},n.prototype.transform=function(){for(var e=0;e<this.pluginPasses.length;e++){var t=this.pluginPasses[e];this.call("pre",t),this.log.debug("Start transform traverse");var r=P.default.visitors.merge(this.pluginVisitors[e],t,this.opts.wrapPluginVisitorMethod);(0,P.default)(this.ast,r,this.scope),this.log.debug("End transform traverse"),this.call("post",t)}return this.generate()},n.prototype.wrap=function(t,r){t+="";try{return this.shouldIgnore()?this.makeResult({code:t,ignored:!0}):r()}catch(r){if(r._babel)throw r;r._babel=!0;var n=r.message=this.opts.filename+": "+r.message,i=r.loc;if(i&&(r.codeFrame=(0,R.default)(t,i.line,i.column+1,this.opts),n+="\n"+r.codeFrame),e.browser&&(r.message=n),r.stack){var s=r.stack.replace(r.message,n);r.stack=s}throw r}},n.prototype.addCode=function(e){e=(e||"")+"",e=this.parseInputSourceMap(e),this.code=e},n.prototype.parseCode=function(){this.parseShebang();var e=this.parse(this.code);this.addAst(e)},n.prototype.shouldIgnore=function(){var e=this.opts;return W.shouldIgnore(e.filename,e.ignore,e.only)},n.prototype.call=function(e,t){for(var r=t,n=Array.isArray(r),i=0,r=n?r:(0,a.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var o=s,u=o.plugin,l=u[e];l&&l.call(o,this)}},n.prototype.parseInputSourceMap=function(e){var t=this.opts;if(!1!==t.inputSourceMap){var r=A.default.fromSource(e);r&&(t.inputSourceMap=r.toObject(),e=A.default.removeComments(e))}return e},n.prototype.parseShebang=function(){var e=ee.exec(this.code);e&&(this.shebang=e[0],this.code=this.code.replace(ee,""))},n.prototype.makeResult=function(e){var t=e.code,r=e.map,n=e.ast,i=e.ignored,s={metadata:null,options:this.opts,ignored:!!i,code:null,ast:null,map:r||null};return this.opts.code&&(s.code=t),this.opts.ast&&(s.ast=n),this.opts.metadata&&(s.metadata=this.metadata),s},n.prototype.generate=function(){var t=this.opts,n=this.ast,i={ast:n};if(!t.code)return this.makeResult(i);var s=O.default;if(t.generatorOpts.generator&&"string"==typeof(s=t.generatorOpts.generator)){var a=q.default.dirname(this.opts.filename)||e.cwd(),o=(0,X.default)(s,a);if(!o)throw new Error("Couldn't find generator "+s+' with "print" method relative to directory '+a);s=r(178)(o).print}this.log.debug("Generation start");var u=s(n,t.generatorOpts?(0,c.default)(t,t.generatorOpts):t,this.code);return i.code=u.code,i.map=u.map,this.log.debug("Generation end"),this.shebang&&(i.code=this.shebang+"\n"+i.code),i.map&&(i.map=this.mergeSourceMap(i.map)),"inline"!==t.sourceMaps&&"both"!==t.sourceMaps||(i.code+="\n"+A.default.fromObject(i.map).toComment()),"inline"===t.sourceMaps&&(i.map=null),this.makeResult(i)},n}(U.default);t.default=ne,t.File=ne}).call(t,r(8))},function(e,t,r){(function(n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function s(e){var t=x[e];return null==t?x[e]=E.default.existsSync(e):t}function a(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments[1],r=e.filename,n=new S(t);return!1!==e.babelrc&&n.findConfigs(r),n.mergeConfig({options:e,alias:"base",dirname:r&&g.default.dirname(r)}),n.configs}t.__esModule=!0;var o=r(87),u=i(o),l=r(3),c=i(l);t.default=a;var f=r(118),p=i(f),d=r(470),h=i(d),m=r(604),y=i(m),v=r(19),g=i(v),b=r(115),E=i(b),x={},A={},S=function(){function e(t){(0,c.default)(this,e),this.resolvedConfigs=[],this.configs=[],this.log=t}return e.prototype.findConfigs=function(e){if(e){(0,y.default)(e)||(e=g.default.join(n.cwd(),e));for(var t=!1,r=!1;e!==(e=g.default.dirname(e));){if(!t){var i=g.default.join(e,".babelrc");s(i)&&(this.addConfig(i),t=!0);var a=g.default.join(e,"package.json");!t&&s(a)&&(t=this.addConfig(a,"babel",JSON))}if(!r){var o=g.default.join(e,".babelignore");s(o)&&(this.addIgnoreConfig(o),r=!0)}if(r&&t)return}}},e.prototype.addIgnoreConfig=function(e){var t=E.default.readFileSync(e,"utf8"),r=t.split("\n");r=r.map(function(e){return e.replace(/#(.*?)$/,"").trim()}).filter(function(e){return!!e}),r.length&&this.mergeConfig({options:{ignore:r},alias:e,dirname:g.default.dirname(e)})},e.prototype.addConfig=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h.default;if(this.resolvedConfigs.indexOf(e)>=0)return!1
;this.resolvedConfigs.push(e);var n=E.default.readFileSync(e,"utf8"),i=void 0;try{i=A[n]=A[n]||r.parse(n),t&&(i=i[t])}catch(t){throw t.message=e+": Error while parsing JSON - "+t.message,t}return this.mergeConfig({options:i,alias:e,dirname:g.default.dirname(e)}),!!i},e.prototype.mergeConfig=function(e){var t=e.options,r=e.alias,i=e.loc,s=e.dirname;if(!t)return!1;if(t=(0,u.default)({},t),s=s||n.cwd(),i=i||r,t.extends){var a=(0,p.default)(t.extends,s);a?this.addConfig(a):this.log&&this.log.error("Couldn't resolve extends clause of "+t.extends+" in "+r),delete t.extends}this.configs.push({options:t,alias:r,loc:i,dirname:s});var o=void 0,l=n.env.BABEL_ENV||"production"||"development";t.env&&(o=t.env[l],delete t.env),this.mergeConfig({options:o,alias:r+".env."+l,dirname:s})},e}();e.exports=t.default}).call(t,r(8))},function(e,t,r){"use strict";function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(var t in e){var r=e[t];if(null!=r){var n=o.default[t];if(n&&n.alias&&(n=o.default[n.alias]),n){var i=s[n.type];i&&(r=i(r)),e[t]=r}}}return e}t.__esModule=!0,t.config=void 0,t.normaliseOptions=n;var i=r(53),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(i),a=r(33),o=function(e){return e&&e.__esModule?e:{default:e}}(a);t.config=o.default},function(e,t,r){"use strict";function n(e){return!!e}function i(e){return l.booleanify(e)}function s(e){return l.list(e)}t.__esModule=!0,t.filename=void 0,t.boolean=n,t.booleanString=i,t.list=s;var a=r(284),o=function(e){return e&&e.__esModule?e:{default:e}}(a),u=r(122),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(u);t.filename=o.default},function(e,t){"use strict";e.exports={auxiliaryComment:{message:"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"},blacklist:{message:"Put the specific transforms you want in the `plugins` option"},breakConfig:{message:"This is not a necessary option in Babel 6"},experimental:{message:"Put the specific transforms you want in the `plugins` option"},externalHelpers:{message:"Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"},extra:{message:""},jsxPragma:{message:"use the `pragma` option in the `react-jsx` plugin . Check out http://babeljs.io/docs/plugins/transform-react-jsx/"},loose:{message:"Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."},metadataUsedHelpers:{message:"Not required anymore as this is enabled by default"},modules:{message:"Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"},nonStandard:{message:"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"},optional:{message:"Put the specific transforms you want in the `plugins` option"},sourceMapName:{message:"Use the `sourceMapTarget` option"},stage:{message:"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"},whitelist:{message:"Put the specific transforms you want in the `plugins` option"}}},function(e,t,r){"use strict";var n=r(43),i=r(428),s=r(427),a=r(21),o=r(153),u=r(238),l={},c={},f=e.exports=function(e,t,r,f,p){var d,h,m,y,v=p?function(){return e}:u(e),g=n(r,f,t?2:1),b=0;if("function"!=typeof v)throw TypeError(e+" is not iterable!");if(s(v)){for(d=o(e.length);d>b;b++)if((y=t?g(a(h=e[b])[0],h[1]):g(e[b]))===l||y===c)return y}else for(m=v.call(e);!(h=m.next()).done;)if((y=i(m,g,h.value,t))===l||y===c)return y};f.BREAK=l,f.RETURN=c},function(e,t){"use strict";e.exports={}},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(95)("meta"),s=r(16),a=r(28),o=r(23).f,u=0,l=Object.isExtensible||function(){return!0},c=!r(27)(function(){return l(Object.preventExtensions({}))}),f=function(e){o(e,i,{value:{i:"O"+ ++u,w:{}}})},p=function(e,t){if(!s(e))return"symbol"==(void 0===e?"undefined":n(e))?e:("string"==typeof e?"S":"P")+e;if(!a(e,i)){if(!l(e))return"F";if(!t)return"E";f(e)}return e[i].i},d=function(e,t){if(!a(e,i)){if(!l(e))return!0;if(!t)return!1;f(e)}return e[i].w},h=function(e){return c&&m.NEED&&l(e)&&!a(e,i)&&f(e),e},m=e.exports={KEY:i,NEED:!1,fastKey:p,getWeak:d,onFreeze:h}},function(e,t,r){"use strict";var n=r(16);e.exports=function(e,t){if(!n(e)||e._t!==t)throw TypeError("Incompatible receiver, "+t+" required!");return e}},function(e,t,r){"use strict";r(440);for(var n=r(15),i=r(29),s=r(56),a=r(13)("toStringTag"),o="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),u=0;u<o.length;u++){var l=o[u],c=n[l],f=c&&c.prototype;f&&!f[a]&&i(f,a,l),s[l]=s.Array}},function(e,t){"use strict";function r(e,t){for(var r=-1,n=null==e?0:e.length,i=Array(n);++r<n;)i[r]=t(e[r],r,e);return i}e.exports=r},function(e,t,r){"use strict";function n(e){return"function"==typeof e?e:null==e?o:"object"==(void 0===e?"undefined":i(e))?u(e)?a(e[0],e[1]):s(e):l(e)}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=r(502),a=r(503),o=r(110),u=r(6),l=r(592);e.exports=n},function(e,t,r){"use strict";function n(e){return"symbol"==(void 0===e?"undefined":i(e))||a(e)&&s(e)==o}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=r(30),a=r(25),o="[object Symbol]";e.exports=n},function(e,t){"use strict";function r(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')}function n(e){var t=e.match(y);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function i(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function s(e){var r=e,s=n(e);if(s){if(!s.path)return e;r=s.path}for(var a,o=t.isAbsolute(r),u=r.split(/\/+/),l=0,c=u.length-1;c>=0;c--)a=u[c],"."===a?u.splice(c,1):".."===a?l++:l>0&&(""===a?(u.splice(c+1,l),l=0):(u.splice(c,2),l--));return r=u.join("/"),""===r&&(r=o?"/":"."),s?(s.path=r,i(s)):r}function a(e,t){""===e&&(e="."),""===t&&(t=".");var r=n(t),a=n(e);if(a&&(e=a.path||"/"),r&&!r.scheme)return a&&(r.scheme=a.scheme),i(r);if(r||t.match(v))return t;if(a&&!a.host&&!a.path)return a.host=t,i(a);var o="/"===t.charAt(0)?t:s(e.replace(/\/+$/,"")+"/"+t);return a?(a.path=o,i(a)):o}function o(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var n=e.lastIndexOf("/");if(n<0)return t;if(e=e.slice(0,n),e.match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join("../")+t.substr(e.length+1)}function u(e){return e}function l(e){return f(e)?"$"+e:e}function c(e){return f(e)?e.slice(1):e}function f(e){if(!e)return!1;var t=e.length;if(t<9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function p(e,t,r){var n=e.source-t.source;return 0!==n?n:0!==(n=e.originalLine-t.originalLine)?n:0!==(n=e.originalColumn-t.originalColumn)||r?n:0!==(n=e.generatedColumn-t.generatedColumn)?n:(n=e.generatedLine-t.generatedLine,0!==n?n:e.name-t.name)}function d(e,t,r){var n=e.generatedLine-t.generatedLine;return 0!==n?n:0!==(n=e.generatedColumn-t.generatedColumn)||r?n:0!==(n=e.source-t.source)?n:0!==(n=e.originalLine-t.originalLine)?n:(n=e.originalColumn-t.originalColumn,0!==n?n:e.name-t.name)}function h(e,t){return e===t?0:e>t?1:-1}function m(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r?r:0!==(r=e.generatedColumn-t.generatedColumn)?r:0!==(r=h(e.source,t.source))?r:0!==(r=e.originalLine-t.originalLine)?r:(r=e.originalColumn-t.originalColumn,0!==r?r:h(e.name,t.name))}t.getArg=r;var y=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,v=/^data:.+\,.+$/;t.urlParse=n,t.urlGenerate=i,t.normalize=s,t.join=a,t.isAbsolute=function(e){return"/"===e.charAt(0)||!!e.match(y)},t.relative=o;var g=function(){return!("__proto__"in Object.create(null))}();t.toSetString=g?u:l,t.fromSetString=g?u:c,t.compareByOriginalPositions=p,t.compareByGeneratedPositionsDeflated=d,t.compareByGeneratedPositionsInflated=m},function(e,t,r){(function(t){"use strict";function n(e,t){if(e===t)return 0;for(var r=e.length,n=t.length,i=0,s=Math.min(r,n);i<s;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0}function i(e){return t.Buffer&&"function"==typeof t.Buffer.isBuffer?t.Buffer.isBuffer(e):!(null==e||!e._isBuffer)}function s(e){return Object.prototype.toString.call(e)}function a(e){return!i(e)&&("function"==typeof t.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&&(e instanceof DataView||!!(e.buffer&&e.buffer instanceof ArrayBuffer))))}function o(e){if(x.isFunction(e)){if(_)return e.name;var t=e.toString(),r=t.match(C);return r&&r[1]}}function u(e,t){return"string"==typeof e?e.length<t?e:e.slice(0,t):e}function l(e){if(_||!x.isFunction(e))return x.inspect(e);var t=o(e);return"[Function"+(t?": "+t:"")+"]"}function c(e){return u(l(e.actual),128)+" "+e.operator+" "+u(l(e.expected),128)}function f(e,t,r,n,i){throw new D.AssertionError({message:r,actual:e,expected:t,operator:n,stackStartFunction:i})}function p(e,t){e||f(e,!0,t,"==",D.ok)}function d(e,t,r,o){if(e===t)return!0;if(i(e)&&i(t))return 0===n(e,t);if(x.isDate(e)&&x.isDate(t))return e.getTime()===t.getTime();if(x.isRegExp(e)&&x.isRegExp(t))return e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase;if(null!==e&&"object"===(void 0===e?"undefined":E(e))||null!==t&&"object"===(void 0===t?"undefined":E(t))){if(a(e)&&a(t)&&s(e)===s(t)&&!(e instanceof Float32Array||e instanceof Float64Array))return 0===n(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(i(e)!==i(t))return!1;o=o||{actual:[],expected:[]};var u=o.actual.indexOf(e);return-1!==u&&u===o.expected.indexOf(t)||(o.actual.push(e),o.expected.push(t),m(e,t,r,o))}return r?e===t:e==t}function h(e){return"[object Arguments]"==Object.prototype.toString.call(e)}function m(e,t,r,n){if(null===e||void 0===e||null===t||void 0===t)return!1;if(x.isPrimitive(e)||x.isPrimitive(t))return e===t;if(r&&Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1;var i=h(e),s=h(t);if(i&&!s||!i&&s)return!1;if(i)return e=S.call(e),t=S.call(t),d(e,t,r);var a,o,u=w(e),l=w(t);if(u.length!==l.length)return!1;for(u.sort(),l.sort(),o=u.length-1;o>=0;o--)if(u[o]!==l[o])return!1;for(o=u.length-1;o>=0;o--)if(a=u[o],!d(e[a],t[a],r,n))return!1;return!0}function y(e,t,r){d(e,t,!0)&&f(e,t,r,"notDeepStrictEqual",y)}function v(e,t){if(!e||!t)return!1;if("[object RegExp]"==Object.prototype.toString.call(t))return t.test(e);try{if(e instanceof t)return!0}catch(e){}return!Error.isPrototypeOf(t)&&!0===t.call({},e)}function g(e){var t;try{e()}catch(e){t=e}return t}function b(e,t,r,n){var i;if("function"!=typeof t)throw new TypeError('"block" argument must be a function');"string"==typeof r&&(n=r,r=null),i=g(t),n=(r&&r.name?" ("+r.name+").":".")+(n?" "+n:"."),e&&!i&&f(i,r,"Missing expected exception"+n);var s="string"==typeof n,a=!e&&x.isError(i),o=!e&&i&&!r;if((a&&s&&v(i,r)||o)&&f(i,r,"Got unwanted exception"+n),e&&i&&r&&!v(i,r)||!e&&i)throw i}var E="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},x=r(117),A=Object.prototype.hasOwnProperty,S=Array.prototype.slice,_=function(){return"foo"===function(){}.name}(),D=e.exports=p,C=/\s*function\s+([^\(\s]*)\s*/;D.AssertionError=function(e){this.name="AssertionError",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=c(this),this.generatedMessage=!0);var t=e.stackStartFunction||f;if(Error.captureStackTrace)Error.captureStackTrace(this,t);else{var r=new Error;if(r.stack){var n=r.stack,i=o(t),s=n.indexOf("\n"+i);if(s>=0){var a=n.indexOf("\n",s+1);n=n.substring(a+1)}this.stack=n}}},x.inherits(D.AssertionError,Error),D.fail=f,D.ok=p,D.equal=function(e,t,r){e!=t&&f(e,t,r,"==",D.equal)},D.notEqual=function(e,t,r){e==t&&f(e,t,r,"!=",D.notEqual)},D.deepEqual=function(e,t,r){d(e,t,!1)||f(e,t,r,"deepEqual",D.deepEqual)},D.deepStrictEqual=function(e,t,r){d(e,t,!0)||f(e,t,r,"deepStrictEqual",D.deepStrictEqual)},D.notDeepEqual=function(e,t,r){d(e,t,!1)&&f(e,t,r,"notDeepEqual",D.notDeepEqual)},D.notDeepStrictEqual=y,D.strictEqual=function(e,t,r){e!==t&&f(e,t,r,"===",D.strictEqual)},D.notStrictEqual=function(e,t,r){e===t&&f(e,t,r,"!==",D.notStrictEqual)},D.throws=function(e,t,r){b(!0,e,t,r)},D.doesNotThrow=function(e,t,r){b(!1,e,t,r)},D.ifError=function(e){if(e)throw e};var w=Object.keys||function(e){var t=[];for(var r in e)A.call(e,r)&&t.push(r);return t}}).call(t,function(){return this}())},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i),a=r(3),o=n(a),u=r(42),l=n(u),c=r(41),f=n(c),p=r(34),d=n(p),h=r(20),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h),y=r(119),v=n(y),g=r(7),b=n(g),E=r(174),x=n(E),A=r(109),S=n(A),_=["enter","exit"],D=function(e){function t(r,n){(0,o.default)(this,t);var i=(0,l.default)(this,e.call(this));return i.initialized=!1,i.raw=(0,x.default)({},r),i.key=i.take("name")||n,i.manipulateOptions=i.take("manipulateOptions"),i.post=i.take("post"),i.pre=i.take("pre"),i.visitor=i.normaliseVisitor((0,S.default)(i.take("visitor"))||{}),i}return(0,f.default)(t,e),t.prototype.take=function(e){var t=this.raw[e];return delete this.raw[e],t},t.prototype.chain=function(e,t){if(!e[t])return this[t];if(!this[t])return e[t];var r=[e[t],this[t]];return function(){for(var e=void 0,t=arguments.length,n=Array(t),i=0;i<t;i++)n[i]=arguments[i];for(var a=r,o=Array.isArray(a),u=0,a=o?a:(0,s.default)(a);;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;if(c){var f=c.apply(this,n);null!=f&&(e=f)}}return e}},t.prototype.maybeInherit=function(e){var t=this.take("inherits");t&&(t=d.default.normalisePlugin(t,e,"inherits"),this.manipulateOptions=this.chain(t,"manipulateOptions"),this.post=this.chain(t,"post"),this.pre=this.chain(t,"pre"),this.visitor=b.default.visitors.merge([t.visitor,this.visitor]))},t.prototype.init=function(e,t){if(!this.initialized){this.initialized=!0,this.maybeInherit(e);for(var r in this.raw)throw new Error(m.get("pluginInvalidProperty",e,t,r))}},t.prototype.normaliseVisitor=function(e){for(var t=_,r=Array.isArray(t),n=0,t=r?t:(0,s.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}if(e[i])throw new Error("Plugins aren't allowed to specify catch-all enter/exit handlers. Please target individual nodes.")}return b.default.explode(e),e},t}(v.default);t.default=D,e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){var t=e.messages;return{visitor:{Scope:function(e){var r=e.scope;for(var n in r.bindings){var s=r.bindings[n];if("const"===s.kind||"module"===s.kind)for(var a=s.constantViolations,o=Array.isArray(a),u=0,a=o?a:(0,i.default)(a);;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;throw c.buildCodeFrameError(t.get("readOnly",n))}}}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("asyncFunctions")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{ArrowFunctionExpression:function(e,r){if(r.opts.spec){var n=e.node;if(n.shadow)return;n.shadow={this:!1},n.type="FunctionExpression";var i=t.thisExpression();i._forceShadow=e,e.ensureBlock(),e.get("body").unshiftContainer("body",t.expressionStatement(t.callExpression(r.addHelper("newArrowCheck"),[t.thisExpression(),i]))),e.replaceWith(t.callExpression(t.memberExpression(n,t.identifier("bind")),[t.thisExpression()]))}else e.arrowFunctionToShadowed()}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e,t){for(var n=t.get(e),s=n,a=Array.isArray(s),o=0,s=a?s:(0,i.default)(s);;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u,c=l.node;if(l.isFunctionDeclaration()){var f=r.variableDeclaration("let",[r.variableDeclarator(c.id,r.toExpression(c))]);f._blockHoist=2,c.id=null,l.replaceWith(f)}}}var r=e.types;return{visitor:{BlockStatement:function(e){var n=e.node,i=e.parent;r.isFunction(i,{body:n})||r.isExportDeclaration(i)||t("body",e)},SwitchCase:function(e){t("consequent",e)}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return b.isLoop(e.parent)||b.isCatchClause(e.parent)}function s(e){return!!b.isVariableDeclaration(e)&&(!!e[b.BLOCK_SCOPED_SYMBOL]||("let"===e.kind||"const"===e.kind))}function a(e,t,r,n){var i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(t||(t=e.node),!b.isFor(r))for(var s=0;s<t.declarations.length;s++){var a=t.declarations[s];a.init=a.init||n.buildUndefinedNode()}if(t[b.BLOCK_SCOPED_SYMBOL]=!0,t.kind="var",i){var o=n.getFunctionParent(),u=e.getBindingIdentifiers();for(var l in u){var c=n.getOwnBinding(l);c&&(c.kind="var"),n.moveBindingTo(l,o)}}}function o(e){return b.isVariableDeclaration(e,{kind:"var"})&&!s(e)}function u(e){return b.isBreakStatement(e)?"break":b.isContinueStatement(e)?"continue":void 0}t.__esModule=!0;var l=r(10),c=n(l),f=r(9),p=n(f),d=r(3),h=n(d);t.default=function(){return{visitor:{VariableDeclaration:function(e,t){var r=e.node,n=e.parent,i=e.scope;if(s(r)&&(a(e,null,n,i,!0),r._tdzThis)){for(var o=[r],u=0;u<r.declarations.length;u++){var l=r.declarations[u];if(l.init){var c=b.assignmentExpression("=",l.id,l.init);c._ignoreBlockScopingTDZ=!0,o.push(b.expressionStatement(c))}l.init=t.addHelper("temporalUndefined")}r._blockHoist=2,e.isCompletionRecord()&&o.push(b.expressionStatement(i.buildUndefinedNode())),e.replaceWithMultiple(o)}},Loop:function(e,t){var r=e.node,n=e.parent,i=e.scope;b.ensureBlock(r);var s=new B(e,e.get("body"),n,i,t),a=s.run();a&&e.replaceWith(a)},CatchClause:function(e,t){var r=e.parent,n=e.scope;new B(null,e.get("body"),r,n,t).run()},"BlockStatement|SwitchStatement|Program":function(e,t){if(!i(e)){new B(null,e,e.parent,e.scope,t).run()}}}}};var m=r(7),y=n(m),v=r(330),g=r(1),b=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(g),E=r(280),x=n(E),A=r(578),S=n(A),_=r(4),D=n(_),C=(0,D.default)('\n  if (typeof RETURN === "object") return RETURN.v;\n'),w=y.default.visitors.merge([{Loop:{enter:function(e,t){t.loopDepth++},exit:function(e,t){t.loopDepth--}},Function:function(e,t){return t.loopDepth>0&&e.traverse(P,t),e.skip()}},v.visitor]),P=y.default.visitors.merge([{ReferencedIdentifier:function(e,t){var r=t.letReferences[e.node.name];if(r){var n=e.scope.getBindingIdentifier(e.node.name);n&&n!==r||(t.closurify=!0)}}},v.visitor]),k={enter:function(e,t){var r=e.node;e.parent;if(e.isForStatement()){if(o(r.init)){var n=t.pushDeclar(r.init);1===n.length?r.init=n[0]:r.init=b.sequenceExpression(n)}}else if(e.isFor())o(r.left)&&(t.pushDeclar(r.left),r.left=r.left.declarations[0].id);else if(o(r))e.replaceWithMultiple(t.pushDeclar(r).map(function(e){return b.expressionStatement(e)}));else if(e.isFunction())return e.skip()}},F={LabeledStatement:function(e,t){var r=e.node;t.innerLabels.push(r.label.name)}},T={enter:function(e,t){if(e.isAssignmentExpression()||e.isUpdateExpression()){var r=e.getBindingIdentifiers();for(var n in r)t.outsideReferences[n]===e.scope.getBindingIdentifier(n)&&(t.reassignments[n]=!0)}}},O={Loop:function(e,t){var r=t.ignoreLabeless;t.ignoreLabeless=!0,e.traverse(O,t),t.ignoreLabeless=r,e.skip()},Function:function(e){e.skip()},SwitchCase:function(e,t){var r=t.inSwitchCase;t.inSwitchCase=!0,e.traverse(O,t),t.inSwitchCase=r,e.skip()},"BreakStatement|ContinueStatement|ReturnStatement":function(e,t){var r=e.node,n=e.parent,i=e.scope;if(!r[this.LOOP_IGNORE]){var s=void 0,a=u(r);if(a){if(r.label){if(t.innerLabels.indexOf(r.label.name)>=0)return;a=a+"|"+r.label.name}else{if(t.ignoreLabeless)return;if(t.inSwitchCase)return;if(b.isBreakStatement(r)&&b.isSwitchCase(n))return}t.hasBreakContinue=!0,t.map[a]=r,s=b.stringLiteral(a)}e.isReturnStatement()&&(t.hasReturn=!0,s=b.objectExpression([b.objectProperty(b.identifier("v"),r.argument||i.buildUndefinedNode())])),s&&(s=b.returnStatement(s),s[this.LOOP_IGNORE]=!0,e.skip(),e.replaceWith(b.inherits(s,r)))}}},B=function(){function e(t,r,n,i,s){(0,h.default)(this,e),this.parent=n,this.scope=i,this.file=s,this.blockPath=r,this.block=r.node,this.outsideLetReferences=(0,p.default)(null),this.hasLetReferences=!1,this.letReferences=(0,p.default)(null),this.body=[],t&&(this.loopParent=t.parent,this.loopLabel=b.isLabeledStatement(this.loopParent)&&this.loopParent.label,this.loopPath=t,this.loop=t.node)}return e.prototype.run=function(){var e=this.block;if(!e._letDone){e._letDone=!0;var t=this.getLetReferences();if(b.isFunction(this.parent)||b.isProgram(this.block))return void this.updateScopeInfo();if(this.hasLetReferences)return t?this.wrapClosure():this.remap(),this.updateScopeInfo(t),this.loopLabel&&!b.isLabeledStatement(this.loopParent)?b.labeledStatement(this.loopLabel,this.loop):void 0}},e.prototype.updateScopeInfo=function(e){var t=this.scope,r=t.getFunctionParent(),n=this.letReferences;for(var i in n){var s=n[i],a=t.getBinding(s.name);a&&("let"!==a.kind&&"const"!==a.kind||(a.kind="var",e?t.removeBinding(s.name):t.moveBindingTo(s.name,r)))}},e.prototype.remap=function(){var e=this.letReferences,t=this.scope;for(var r in e){var n=e[r];(t.parentHasBinding(r)||t.hasGlobal(r))&&(t.hasOwnBinding(r)&&t.rename(n.name),this.blockPath.scope.hasOwnBinding(r)&&this.blockPath.scope.rename(n.name))}},e.prototype.wrapClosure=function(){if(this.file.opts.throwIfClosureRequired)throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure (throwIfClosureRequired).");var e=this.block,t=this.outsideLetReferences;if(this.loop)for(var r in t){var n=t[r];(this.scope.hasGlobal(n.name)||this.scope.parentHasBinding(n.name))&&(delete t[n.name],delete this.letReferences[n.name],this.scope.rename(n.name),this.letReferences[n.name]=n,t[n.name]=n)}this.has=this.checkLoop(),this.hoistVarDeclarations();var i=(0,x.default)(t),s=(0,x.default)(t),a=this.blockPath.isSwitchStatement(),o=b.functionExpression(null,i,b.blockStatement(a?[e]:e.body));o.shadow=!0,this.addContinuations(o);var u=o;this.loop&&(u=this.scope.generateUidIdentifier("loop"),this.loopPath.insertBefore(b.variableDeclaration("var",[b.variableDeclarator(u,o)])));var l=b.callExpression(u,s),c=this.scope.generateUidIdentifier("ret");y.default.hasType(o.body,this.scope,"YieldExpression",b.FUNCTION_TYPES)&&(o.generator=!0,l=b.yieldExpression(l,!0)),y.default.hasType(o.body,this.scope,"AwaitExpression",b.FUNCTION_TYPES)&&(o.async=!0,l=b.awaitExpression(l)),this.buildClosure(c,l),a?this.blockPath.replaceWithMultiple(this.body):e.body=this.body},e.prototype.buildClosure=function(e,t){var r=this.has;r.hasReturn||r.hasBreakContinue?this.buildHas(e,t):this.body.push(b.expressionStatement(t))},e.prototype.addContinuations=function(e){var t={reassignments:{},outsideReferences:this.outsideLetReferences};this.scope.traverse(e,T,t);for(var r=0;r<e.params.length;r++){var n=e.params[r];if(t.reassignments[n.name]){var i=this.scope.generateUidIdentifier(n.name);e.params[r]=i,this.scope.rename(n.name,i.name,e),e.body.body.push(b.expressionStatement(b.assignmentExpression("=",n,i)))}}},e.prototype.getLetReferences=function(){var e=this,t=this.block,r=[];if(this.loop){var n=this.loop.left||this.loop.init;s(n)&&(r.push(n),(0,S.default)(this.outsideLetReferences,b.getBindingIdentifiers(n)))}var i=function n(i,o){o=o||i.node,(b.isClassDeclaration(o)||b.isFunctionDeclaration(o)||s(o))&&(s(o)&&a(i,o,t,e.scope),r=r.concat(o.declarations||o)),b.isLabeledStatement(o)&&n(i.get("body"),o.body)};if(t.body)for(var o=0;o<t.body.length;o++){var u=this.blockPath.get("body")[o];i(u)}if(t.cases)for(var l=0;l<t.cases.length;l++)for(var c=t.cases[l].consequent,f=0;f<c.length;f++){var p=this.blockPath.get("cases")[l],d=c[f];i(p,d)}for(var h=0;h<r.length;h++){var m=r[h],y=b.getBindingIdentifiers(m,!1,!0);(0,S.default)(this.letReferences,y),this.hasLetReferences=!0}if(this.hasLetReferences){var v={letReferences:this.letReferences,closurify:!1,file:this.file,loopDepth:0},g=this.blockPath.find(function(e){return e.isLoop()||e.isFunction()});return g&&g.isLoop()&&v.loopDepth++,this.blockPath.traverse(w,v),v.closurify}},e.prototype.checkLoop=function(){var e={hasBreakContinue:!1,ignoreLabeless:!1,inSwitchCase:!1,innerLabels:[],hasReturn:!1,isLoop:!!this.loop,map:{},LOOP_IGNORE:(0,c.default)()};return this.blockPath.traverse(F,e),this.blockPath.traverse(O,e),e},e.prototype.hoistVarDeclarations=function(){this.blockPath.traverse(k,this)},e.prototype.pushDeclar=function(e){var t=[],r=b.getBindingIdentifiers(e);for(var n in r)t.push(b.variableDeclarator(r[n]));this.body.push(b.variableDeclaration(e.kind,t));for(var i=[],s=0;s<e.declarations.length;s++){var a=e.declarations[s];if(a.init){var o=b.assignmentExpression("=",a.id,a.init);i.push(b.inherits(o,a))}}return i},e.prototype.buildHas=function(e,t){var r=this.body;r.push(b.variableDeclaration("var",[b.variableDeclarator(e,t)]));var n=void 0,i=this.has,s=[];if(i.hasReturn&&(n=C({RETURN:e})),i.hasBreakContinue){for(var a in i.map)s.push(b.switchCase(b.stringLiteral(a),[i.map[a]]));if(i.hasReturn&&s.push(b.switchCase(null,[n])),1===s.length){var o=s[0];r.push(b.ifStatement(b.binaryExpression("===",e,o.test),o.consequent[0]))}else{if(this.loop)for(var u=0;u<s.length;u++){var l=s[u].consequent[0];b.isBreakStatement(l)&&!l.label&&(l.label=this.loopLabel=this.loopLabel||this.scope.generateUidIdentifier("loop"))}r.push(b.switchStatement(e,s))}}else i.hasReturn&&r.push(n)},e}();e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(10),s=n(i);t.default=function(e){var t=e.types,r=(0,s.default)();return{visitor:{ExportDefaultDeclaration:function(e){if(e.get("declaration").isClassDeclaration()){var r=e.node,n=r.declaration.id||e.scope.generateUidIdentifier("class");r.declaration.id=n,e.replaceWith(r.declaration),e.insertAfter(t.exportDefaultDeclaration(n))}},ClassDeclaration:function(e){var r=e.node,n=r.id||e.scope.generateUidIdentifier("class");e.replaceWith(t.variableDeclaration("let",[t.variableDeclarator(n,t.toExpression(r))]))},ClassExpression:function(e,t){var n=e.node;if(!n[r]){var i=(0,f.default)(e);if(i&&i!==n)return e.replaceWith(i);n[r]=!0;var s=l.default;t.opts.loose&&(s=o.default),e.replaceWith(new s(e,t.file).run())}}}}};var a=r(331),o=n(a),u=r(207),l=n(u),c=r(40),f=n(c);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e){return o.isObjectProperty(e)?e.value:o.isObjectMethod(e)?o.functionExpression(null,e.params,e.body,e.generator,e.async):void 0}function r(e,r,i){"get"===r.kind&&"set"===r.kind?n(e,r,i):i.push(o.expressionStatement(o.assignmentExpression("=",o.memberExpression(e,r.key,r.computed||o.isLiteral(r.key)),t(r))))}function n(e,r){var n=(e.objId,e.body),i=e.getMutatorId,s=e.scope,a=!r.computed&&o.isIdentifier(r.key)?o.stringLiteral(r.key.name):r.key,u=s.maybeGenerateMemoised(a);u&&(n.push(o.expressionStatement(o.assignmentExpression("=",u,a))),a=u),n.push.apply(n,l({MUTATOR_MAP_REF:i(),KEY:a,VALUE:t(r),KIND:o.identifier(r.kind)}))}function s(e){for(var t=e.computedProps,s=Array.isArray(t),a=0,t=s?t:(0,i.default)(t);;){var o;if(s){if(a>=t.length)break;o=t[a++]}else{if(a=t.next(),a.done)break;o=a.value}var u=o;"get"===u.kind||"set"===u.kind?n(e,u):r(e.objId,u,e.body)}}function a(e){for(var s=e.objId,a=e.body,u=e.computedProps,l=e.state,c=u,f=Array.isArray(c),p=0,c=f?c:(0,i.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d,m=o.toComputedKey(h);if("get"===h.kind||"set"===h.kind)n(e,h);else if(o.isStringLiteral(m,{value:"__proto__"}))r(s,h,a);else{if(1===u.length)return o.callExpression(l.addHelper("defineProperty"),[e.initPropExpression,m,t(h)]);a.push(o.expressionStatement(o.callExpression(l.addHelper("defineProperty"),[s,m,t(h)])))}}}var o=e.types,u=e.template,l=u("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");return{visitor:{ObjectExpression:{exit:function(e,t){for(var r=e.node,n=e.parent,u=e.scope,l=!1,c=r.properties,f=Array.isArray(c),p=0,c=f?c:(0,i.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}if(l=!0===d.computed)break}if(l){for(var h=[],m=[],y=!1,v=r.properties,g=Array.isArray(v),b=0,v=g?v:(0,i.default)(v);;){var E;if(g){if(b>=v.length)break;E=v[b++]}else{if(b=v.next(),b.done)break;E=b.value}var x=E;x.computed&&(y=!0),y?m.push(x):h.push(x)}var A=u.generateUidIdentifierBasedOnNode(n),S=o.objectExpression(h),_=[];_.push(o.variableDeclaration("var",[o.variableDeclarator(A,S)]));var D=a;t.opts.loose&&(D=s);var C=void 0,w=function(){return C||(C=u.generateUidIdentifier("mutatorMap"),_.push(o.variableDeclaration("var",[o.variableDeclarator(C,o.objectExpression([]))]))),C},P=D({scope:u,objId:A,body:_,computedProps:m,initPropExpression:S,getMutatorId:w,state:t});C&&_.push(o.expressionStatement(o.callExpression(t.addHelper("defineEnumerableProperties"),[A,C]))),P?e.replaceWith(P):(_.push(o.expressionStatement(A)),e.replaceWithMultiple(_))}}}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(2),o=n(a);t.default=function(e){function t(e){for(var t=e.declarations,r=Array.isArray(t),i=0,t=r?t:(0,o.default)(t);;){var s;if(r){if(i>=t.length)break;s=t[i++]}else{if(i=t.next(),i.done)break;s=i.value}var a=s;if(n.isPattern(a.id))return!0}return!1}function r(e){for(var t=e.elements,r=Array.isArray(t),i=0,t=r?t:(0,o.default)(t);;){var s;if(r){if(i>=t.length)break;s=t[i++]}else{if(i=t.next(),i.done)break;s=i.value}var a=s;if(n.isRestElement(a))return!0}return!1}var n=e.types,i={ReferencedIdentifier:function(e,t){t.bindings[e.node.name]&&(t.deopt=!0,e.stop())}},a=function(){function e(t){(0,s.default)(this,e),this.blockHoist=t.blockHoist,this.operator=t.operator,this.arrays={},this.nodes=t.nodes||[],this.scope=t.scope,this.file=t.file,this.kind=t.kind}
return e.prototype.buildVariableAssignment=function(e,t){var r=this.operator;n.isMemberExpression(e)&&(r="=");var i=void 0;return i=r?n.expressionStatement(n.assignmentExpression(r,e,t)):n.variableDeclaration(this.kind,[n.variableDeclarator(e,t)]),i._blockHoist=this.blockHoist,i},e.prototype.buildVariableDeclaration=function(e,t){var r=n.variableDeclaration("var",[n.variableDeclarator(e,t)]);return r._blockHoist=this.blockHoist,r},e.prototype.push=function(e,t){n.isObjectPattern(e)?this.pushObjectPattern(e,t):n.isArrayPattern(e)?this.pushArrayPattern(e,t):n.isAssignmentPattern(e)?this.pushAssignmentPattern(e,t):this.nodes.push(this.buildVariableAssignment(e,t))},e.prototype.toArray=function(e,t){return this.file.opts.loose||n.isIdentifier(e)&&this.arrays[e.name]?e:this.scope.toArray(e,t)},e.prototype.pushAssignmentPattern=function(e,t){var r=this.scope.generateUidIdentifierBasedOnNode(t),i=n.variableDeclaration("var",[n.variableDeclarator(r,t)]);i._blockHoist=this.blockHoist,this.nodes.push(i);var s=n.conditionalExpression(n.binaryExpression("===",r,n.identifier("undefined")),e.right,r),a=e.left;if(n.isPattern(a)){var o=n.expressionStatement(n.assignmentExpression("=",r,s));o._blockHoist=this.blockHoist,this.nodes.push(o),this.push(a,r)}else this.nodes.push(this.buildVariableAssignment(a,s))},e.prototype.pushObjectRest=function(e,t,r,i){for(var s=[],a=0;a<e.properties.length;a++){var o=e.properties[a];if(a>=i)break;if(!n.isRestProperty(o)){var u=o.key;n.isIdentifier(u)&&!o.computed&&(u=n.stringLiteral(o.key.name)),s.push(u)}}s=n.arrayExpression(s);var l=n.callExpression(this.file.addHelper("objectWithoutProperties"),[t,s]);this.nodes.push(this.buildVariableAssignment(r.argument,l))},e.prototype.pushObjectProperty=function(e,t){n.isLiteral(e.key)&&(e.computed=!0);var r=e.value,i=n.memberExpression(t,e.key,e.computed);n.isPattern(r)?this.push(r,i):this.nodes.push(this.buildVariableAssignment(r,i))},e.prototype.pushObjectPattern=function(e,t){if(e.properties.length||this.nodes.push(n.expressionStatement(n.callExpression(this.file.addHelper("objectDestructuringEmpty"),[t]))),e.properties.length>1&&!this.scope.isStatic(t)){var r=this.scope.generateUidIdentifierBasedOnNode(t);this.nodes.push(this.buildVariableDeclaration(r,t)),t=r}for(var i=0;i<e.properties.length;i++){var s=e.properties[i];n.isRestProperty(s)?this.pushObjectRest(e,t,s,i):this.pushObjectProperty(s,t)}},e.prototype.canUnpackArrayPattern=function(e,t){if(!n.isArrayExpression(t))return!1;if(!(e.elements.length>t.elements.length)){if(e.elements.length<t.elements.length&&!r(e))return!1;for(var s=e.elements,a=Array.isArray(s),u=0,s=a?s:(0,o.default)(s);;){var l;if(a){if(u>=s.length)break;l=s[u++]}else{if(u=s.next(),u.done)break;l=u.value}var c=l;if(!c)return!1;if(n.isMemberExpression(c))return!1}for(var f=t.elements,p=Array.isArray(f),d=0,f=p?f:(0,o.default)(f);;){var h;if(p){if(d>=f.length)break;h=f[d++]}else{if(d=f.next(),d.done)break;h=d.value}var m=h;if(n.isSpreadElement(m))return!1;if(n.isCallExpression(m))return!1;if(n.isMemberExpression(m))return!1}var y=n.getBindingIdentifiers(e),v={deopt:!1,bindings:y};return this.scope.traverse(t,i,v),!v.deopt}},e.prototype.pushUnpackedArrayPattern=function(e,t){for(var r=0;r<e.elements.length;r++){var i=e.elements[r];n.isRestElement(i)?this.push(i.argument,n.arrayExpression(t.elements.slice(r))):this.push(i,t.elements[r])}},e.prototype.pushArrayPattern=function(e,t){if(e.elements){if(this.canUnpackArrayPattern(e,t))return this.pushUnpackedArrayPattern(e,t);var i=!r(e)&&e.elements.length,s=this.toArray(t,i);n.isIdentifier(s)?t=s:(t=this.scope.generateUidIdentifierBasedOnNode(t),this.arrays[t.name]=!0,this.nodes.push(this.buildVariableDeclaration(t,s)));for(var a=0;a<e.elements.length;a++){var o=e.elements[a];if(o){var u=void 0;n.isRestElement(o)?(u=this.toArray(t),u=n.callExpression(n.memberExpression(u,n.identifier("slice")),[n.numericLiteral(a)]),o=o.argument):u=n.memberExpression(t,n.numericLiteral(a),!0),this.push(o,u)}}}},e.prototype.init=function(e,t){if(!n.isArrayExpression(t)&&!n.isMemberExpression(t)){var r=this.scope.maybeGenerateMemoised(t,!0);r&&(this.nodes.push(this.buildVariableDeclaration(r,t)),t=r)}return this.push(e,t),this.nodes},e}();return{visitor:{ExportNamedDeclaration:function(e){var r=e.get("declaration");if(r.isVariableDeclaration()&&t(r.node)){var i=[];for(var s in e.getOuterBindingIdentifiers(e)){var a=n.identifier(s);i.push(n.exportSpecifier(a,a))}e.replaceWith(r.node),e.insertAfter(n.exportNamedDeclaration(null,i))}},ForXStatement:function(e,t){var r=e.node,i=e.scope,s=r.left;if(n.isPattern(s)){var o=i.generateUidIdentifier("ref");return r.left=n.variableDeclaration("var",[n.variableDeclarator(o)]),e.ensureBlock(),void r.body.body.unshift(n.variableDeclaration("var",[n.variableDeclarator(s,o)]))}if(n.isVariableDeclaration(s)){var u=s.declarations[0].id;if(n.isPattern(u)){var l=i.generateUidIdentifier("ref");r.left=n.variableDeclaration(s.kind,[n.variableDeclarator(l,null)]);var c=[];new a({kind:s.kind,file:t,scope:i,nodes:c}).init(u,l),e.ensureBlock();var f=r.body;f.body=c.concat(f.body)}}},CatchClause:function(e,t){var r=e.node,i=e.scope,s=r.param;if(n.isPattern(s)){var o=i.generateUidIdentifier("ref");r.param=o;var u=[];new a({kind:"let",file:t,scope:i,nodes:u}).init(s,o),r.body.body=u.concat(r.body.body)}},AssignmentExpression:function(e,t){var r=e.node,i=e.scope;if(n.isPattern(r.left)){var s=[],o=new a({operator:r.operator,file:t,scope:i,nodes:s}),u=void 0;!e.isCompletionRecord()&&e.parentPath.isExpressionStatement()||(u=i.generateUidIdentifierBasedOnNode(r.right,"ref"),s.push(n.variableDeclaration("var",[n.variableDeclarator(u,r.right)])),n.isArrayExpression(r.right)&&(o.arrays[u.name]=!0)),o.init(r.left,u||r.right),u&&s.push(n.expressionStatement(u)),e.replaceWithMultiple(s)}},VariableDeclaration:function(e,r){var i=e.node,s=e.scope,u=e.parent;if(!n.isForXStatement(u)&&u&&e.container&&t(i)){for(var l=[],c=void 0,f=0;f<i.declarations.length;f++){c=i.declarations[f];var p=c.init,d=c.id,h=new a({blockHoist:i._blockHoist,nodes:l,scope:s,kind:i.kind,file:r});n.isPattern(d)?(h.init(d,p),+f!=i.declarations.length-1&&n.inherits(l[l.length-1],c)):l.push(n.inherits(h.buildVariableAssignment(c.id,c.init),c))}for(var m=[],y=l,v=Array.isArray(y),g=0,y=v?y:(0,o.default)(y);;){var b;if(v){if(g>=y.length)break;b=y[g++]}else{if(g=y.next(),g.done)break;b=g.value}var E=b,x=m[m.length-1];if(x&&n.isVariableDeclaration(x)&&n.isVariableDeclaration(E)&&x.kind===E.kind){var A;(A=x.declarations).push.apply(A,E.declarations)}else m.push(E)}for(var S=m,_=Array.isArray(S),D=0,S=_?S:(0,o.default)(S);;){var C;if(_){if(D>=S.length)break;C=S[D++]}else{if(D=S.next(),D.done)break;C=D.value}var w=C;if(w.declarations)for(var P=w.declarations,k=Array.isArray(P),F=0,P=k?P:(0,o.default)(P);;){var T;if(k){if(F>=P.length)break;T=P[F++]}else{if(F=P.next(),F.done)break;T=F.value}var O=T,B=O.id.name;s.bindings[B]&&(s.bindings[B].kind=w.kind)}}1===m.length?e.replaceWith(m[0]):e.replaceWithMultiple(m)}}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){function t(e){var t=e.node,r=e.scope,n=[],i=t.right;if(!a.isIdentifier(i)||!r.hasBinding(i.name)){var s=r.generateUidIdentifier("arr");n.push(a.variableDeclaration("var",[a.variableDeclarator(s,i)])),i=s}var u=r.generateUidIdentifier("i"),l=o({BODY:t.body,KEY:u,ARR:i});a.inherits(l,t),a.ensureBlock(l);var c=a.memberExpression(i,u,!0),f=t.left;return a.isVariableDeclaration(f)?(f.declarations[0].init=c,l.body.body.unshift(f)):l.body.body.unshift(a.expressionStatement(a.assignmentExpression("=",f,c))),e.parentPath.isLabeledStatement()&&(l=a.labeledStatement(e.parentPath.node.label,l)),n.push(l),n}function r(e,t){var r=e.node,n=e.scope,s=e.parent,o=r.left,l=void 0,c=void 0;if(a.isIdentifier(o)||a.isPattern(o)||a.isMemberExpression(o))c=o;else{if(!a.isVariableDeclaration(o))throw t.buildCodeFrameError(o,i.get("unknownForHead",o.type));c=n.generateUidIdentifier("ref"),l=a.variableDeclaration(o.kind,[a.variableDeclarator(o.declarations[0].id,c)])}var f=n.generateUidIdentifier("iterator"),p=n.generateUidIdentifier("isArray"),d=u({LOOP_OBJECT:f,IS_ARRAY:p,OBJECT:r.right,INDEX:n.generateUidIdentifier("i"),ID:c});l||d.body.body.shift();var h=a.isLabeledStatement(s),m=void 0;return h&&(m=a.labeledStatement(s.label,d)),{replaceParent:h,declar:l,node:m||d,loop:d}}function n(e,t){var r=e.node,n=e.scope,s=e.parent,o=r.left,u=void 0,c=n.generateUidIdentifier("step"),f=a.memberExpression(c,a.identifier("value"));if(a.isIdentifier(o)||a.isPattern(o)||a.isMemberExpression(o))u=a.expressionStatement(a.assignmentExpression("=",o,f));else{if(!a.isVariableDeclaration(o))throw t.buildCodeFrameError(o,i.get("unknownForHead",o.type));u=a.variableDeclaration(o.kind,[a.variableDeclarator(o.declarations[0].id,f)])}var p=n.generateUidIdentifier("iterator"),d=l({ITERATOR_HAD_ERROR_KEY:n.generateUidIdentifier("didIteratorError"),ITERATOR_COMPLETION:n.generateUidIdentifier("iteratorNormalCompletion"),ITERATOR_ERROR_KEY:n.generateUidIdentifier("iteratorError"),ITERATOR_KEY:p,STEP_KEY:c,OBJECT:r.right,BODY:null}),h=a.isLabeledStatement(s),m=d[3].block.body,y=m[0];return h&&(m[0]=a.labeledStatement(s.label,y)),{replaceParent:h,declar:u,loop:y,node:d}}var i=e.messages,s=e.template,a=e.types,o=s("\n    for (var KEY = 0; KEY < ARR.length; KEY++) BODY;\n  "),u=s("\n    for (var LOOP_OBJECT = OBJECT,\n             IS_ARRAY = Array.isArray(LOOP_OBJECT),\n             INDEX = 0,\n             LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n      var ID;\n      if (IS_ARRAY) {\n        if (INDEX >= LOOP_OBJECT.length) break;\n        ID = LOOP_OBJECT[INDEX++];\n      } else {\n        INDEX = LOOP_OBJECT.next();\n        if (INDEX.done) break;\n        ID = INDEX.value;\n      }\n    }\n  "),l=s("\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY = undefined;\n    try {\n      for (var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY; !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done); ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return) {\n          ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  ");return{visitor:{ForOfStatement:function(e,i){if(e.get("right").isArrayExpression())return e.parentPath.isLabeledStatement()?e.parentPath.replaceWithMultiple(t(e)):e.replaceWithMultiple(t(e));var s=n;i.opts.loose&&(s=r);var o=e.node,u=s(e,i),l=u.declar,c=u.loop,f=c.body;e.ensureBlock(),l&&f.body.push(l),f.body=f.body.concat(o.body.body),a.inherits(c,o),a.inherits(c.body,o.body),u.replaceParent?(e.parentPath.replaceWithMultiple(u.node),e.remove()):e.replaceWithMultiple(u.node)}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{FunctionExpression:{exit:function(e){if("value"!==e.key&&!e.parentPath.isObjectProperty()){var t=(0,i.default)(e);t&&e.replaceWith(t)}}},ObjectProperty:function(e){var t=e.get("value");if(t.isFunction()){var r=(0,i.default)(t);r&&t.replaceWith(r)}}}}};var n=r(40),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{NumericLiteral:function(e){var t=e.node;t.extra&&/^0[ob]/i.test(t.extra.raw)&&(t.extra=void 0)},StringLiteral:function(e){var t=e.node;t.extra&&/\\[u]/gi.test(t.extra.raw)&&(t.extra=void 0)}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(14),s=n(i),a=r(9),o=n(a),u=r(2),l=n(u),c=r(10),f=n(c);t.default=function(){var e=(0,f.default)(),t={ReferencedIdentifier:function(e){var t=e.node.name,r=this.remaps[t];if(r&&this.scope.getBinding(t)===e.scope.getBinding(t)){if(e.parentPath.isCallExpression({callee:e.node}))e.replaceWith(g.sequenceExpression([g.numericLiteral(0),r]));else if(e.isJSXIdentifier()&&g.isMemberExpression(r)){var n=r.object,i=r.property;e.replaceWith(g.JSXMemberExpression(g.JSXIdentifier(n.name),g.JSXIdentifier(i.name)))}else e.replaceWith(r);this.requeueInParent(e)}},AssignmentExpression:function(t){var r=t.node;if(!r[e]){var n=t.get("left");if(n.isIdentifier()){var i=n.node.name,s=this.exports[i];if(!s)return;if(this.scope.getBinding(i)!==t.scope.getBinding(i))return;r[e]=!0;for(var a=s,o=Array.isArray(a),u=0,a=o?a:(0,l.default)(a);;){var c;if(o){if(u>=a.length)break;c=a[u++]}else{if(u=a.next(),u.done)break;c=u.value}r=S(c,r).expression}t.replaceWith(r),this.requeueInParent(t)}else if(n.isObjectPattern())for(var f=n.node.properties,p=Array.isArray(f),d=0,f=p?f:(0,l.default)(f);;){var h;if(p){if(d>=f.length)break;h=f[d++]}else{if(d=f.next(),d.done)break;h=d.value}var m=h,y=m.value.name,v=this.exports[y];if(v){if(this.scope.getBinding(y)!==t.scope.getBinding(y))return;r[e]=!0,t.insertAfter(S(g.identifier(y),g.identifier(y)))}}else if(n.isArrayPattern())for(var b=n.node.elements,E=Array.isArray(b),x=0,b=E?b:(0,l.default)(b);;){var A;if(E){if(x>=b.length)break;A=b[x++]}else{if(x=b.next(),x.done)break;A=x.value}var _=A;if(_){var D=_.name,C=this.exports[D];if(C){if(this.scope.getBinding(D)!==t.scope.getBinding(D))return;r[e]=!0,t.insertAfter(S(g.identifier(D),g.identifier(D)))}}}}},UpdateExpression:function(e){var t=e.get("argument");if(t.isIdentifier()){var r=t.node.name;if(this.exports[r]&&this.scope.getBinding(r)===e.scope.getBinding(r)){var n=g.assignmentExpression(e.node.operator[0]+"=",t.node,g.numericLiteral(1));if(e.parentPath.isExpressionStatement()&&!e.isCompletionRecord()||e.node.prefix)return e.replaceWith(n),void this.requeueInParent(e);var i=[];i.push(n);var s=void 0;s="--"===e.node.operator?"+":"-",i.push(g.binaryExpression(s,t.node,g.numericLiteral(1))),e.replaceWithMultiple(g.sequenceExpression(i))}}}};return{inherits:y.default,visitor:{ThisExpression:function(e,t){this.ranCommonJS||!0===t.opts.allowTopLevelThis||e.findParent(function(e){return!e.is("shadow")&&D.indexOf(e.type)>=0})||e.replaceWith(g.identifier("undefined"))},Program:{exit:function(e){function r(t,r){var n=C[t];if(n)return n;var i=e.scope.generateUidIdentifier((0,p.basename)(t,(0,p.extname)(t))),s=g.variableDeclaration("var",[g.variableDeclarator(i,b(g.stringLiteral(t)).expression)]);return h[t]&&(s.loc=h[t].loc),"number"==typeof r&&r>0&&(s._blockHoist=r),v.push(s),C[t]=i}function n(e,t,r){var n=e[t]||[];e[t]=n.concat(r)}this.ranCommonJS=!0;var i=!!this.opts.strict,a=!!this.opts.noInterop,u=e.scope;u.rename("module"),u.rename("exports"),u.rename("require");for(var c=!1,f=!1,d=e.get("body"),h=(0,o.default)(null),m=(0,o.default)(null),y=(0,o.default)(null),v=[],D=(0,o.default)(null),C=(0,o.default)(null),w=d,P=Array.isArray(w),k=0,w=P?w:(0,l.default)(w);;){var F;if(P){if(k>=w.length)break;F=w[k++]}else{if(k=w.next(),k.done)break;F=k.value}var T=F;if(T.isExportDeclaration()){c=!0;for(var O=[].concat(T.get("declaration"),T.get("specifiers")),B=O,R=Array.isArray(B),I=0,B=R?B:(0,l.default)(B);;){var M;if(R){if(I>=B.length)break;M=B[I++]}else{if(I=B.next(),I.done)break;M=I.value}var N=M;if(N.getBindingIdentifiers().__esModule)throw N.buildCodeFrameError('Illegal export "__esModule"')}}if(T.isImportDeclaration()){var L;f=!0;var j=T.node.source.value,U=h[j]||{specifiers:[],maxBlockHoist:0,loc:T.node.loc};(L=U.specifiers).push.apply(L,T.node.specifiers),"number"==typeof T.node._blockHoist&&(U.maxBlockHoist=Math.max(T.node._blockHoist,U.maxBlockHoist)),h[j]=U,T.remove()}else if(T.isExportDefaultDeclaration()){var V=T.get("declaration");if(V.isFunctionDeclaration()){var G=V.node.id,W=g.identifier("default");G?(n(m,G.name,W),v.push(S(W,G)),T.replaceWith(V.node)):(v.push(S(W,g.toExpression(V.node))),T.remove())}else if(V.isClassDeclaration()){var Y=V.node.id,q=g.identifier("default");Y?(n(m,Y.name,q),T.replaceWithMultiple([V.node,S(q,Y)])):(T.replaceWith(S(q,g.toExpression(V.node))),T.parentPath.requeue(T.get("expression.left")))}else T.replaceWith(S(g.identifier("default"),V.node)),T.parentPath.requeue(T.get("expression.left"))}else if(T.isExportNamedDeclaration()){var K=T.get("declaration");if(K.node){if(K.isFunctionDeclaration()){var H=K.node.id;n(m,H.name,H),v.push(S(H,H)),T.replaceWith(K.node)}else if(K.isClassDeclaration()){var J=K.node.id;n(m,J.name,J),T.replaceWithMultiple([K.node,S(J,J)]),y[J.name]=!0}else if(K.isVariableDeclaration()){for(var X=K.get("declarations"),z=X,$=Array.isArray(z),Q=0,z=$?z:(0,l.default)(z);;){var Z;if($){if(Q>=z.length)break;Z=z[Q++]}else{if(Q=z.next(),Q.done)break;Z=Q.value}var ee=Z,te=ee.get("id"),re=ee.get("init"),ne=[];if(re.node||re.replaceWith(g.identifier("undefined")),te.isIdentifier())n(m,te.node.name,te.node),re.replaceWith(S(te.node,re.node).expression),y[te.node.name]=!0;else if(te.isObjectPattern())for(var ie=0;ie<te.node.properties.length;ie++){var se=te.node.properties[ie],ae=se.value;g.isAssignmentPattern(ae)?ae=ae.left:g.isRestProperty(se)&&(ae=se.argument),n(m,ae.name,ae),ne.push(S(ae,ae)),y[ae.name]=!0}else if(te.isArrayPattern()&&te.node.elements)for(var oe=0;oe<te.node.elements.length;oe++){var ue=te.node.elements[oe];if(ue){g.isAssignmentPattern(ue)?ue=ue.left:g.isRestElement(ue)&&(ue=ue.argument);var le=ue.name;n(m,le,ue),ne.push(S(ue,ue)),y[le]=!0}}T.insertAfter(ne)}T.replaceWith(K.node)}continue}var ce=T.get("specifiers"),fe=[],pe=T.node.source;if(pe)for(var de=r(pe.value,T.node._blockHoist),he=ce,me=Array.isArray(he),ye=0,he=me?he:(0,l.default)(he);;){var ve;if(me){if(ye>=he.length)break;ve=he[ye++]}else{if(ye=he.next(),ye.done)break;ve=ye.value}var ge=ve;ge.isExportNamespaceSpecifier()||ge.isExportDefaultSpecifier()||ge.isExportSpecifier()&&(a||"default"!==ge.node.local.name?v.push(x(g.stringLiteral(ge.node.exported.name),g.memberExpression(de,ge.node.local))):v.push(x(g.stringLiteral(ge.node.exported.name),g.memberExpression(g.callExpression(this.addHelper("interopRequireDefault"),[de]),ge.node.local))),y[ge.node.exported.name]=!0)}else for(var be=ce,Ee=Array.isArray(be),xe=0,be=Ee?be:(0,l.default)(be);;){var Ae;if(Ee){if(xe>=be.length)break;Ae=be[xe++]}else{if(xe=be.next(),xe.done)break;Ae=xe.value}var Se=Ae;Se.isExportSpecifier()&&(n(m,Se.node.local.name,Se.node.exported),y[Se.node.exported.name]=!0,fe.push(S(Se.node.exported,Se.node.local)))}T.replaceWithMultiple(fe)}else if(T.isExportAllDeclaration()){var _e=_({OBJECT:r(T.node.source.value,T.node._blockHoist)});_e.loc=T.node.loc,v.push(_e),T.remove()}}for(var De in h){var Ce=h[De],O=Ce.specifiers,we=Ce.maxBlockHoist;if(O.length){for(var Pe=r(De,we),ke=void 0,Fe=0;Fe<O.length;Fe++){var Te=O[Fe];if(g.isImportNamespaceSpecifier(Te)){if(i||a)D[Te.local.name]=Pe;else{var Oe=g.variableDeclaration("var",[g.variableDeclarator(Te.local,g.callExpression(this.addHelper("interopRequireWildcard"),[Pe]))]);we>0&&(Oe._blockHoist=we),v.push(Oe)}ke=Te.local}else g.isImportDefaultSpecifier(Te)&&(O[Fe]=g.importSpecifier(Te.local,g.identifier("default")))}for(var Be=O,Re=Array.isArray(Be),Ie=0,Be=Re?Be:(0,l.default)(Be);;){var Me;if(Re){if(Ie>=Be.length)break;Me=Be[Ie++]}else{if(Ie=Be.next(),Ie.done)break;Me=Ie.value}var Ne=Me;if(g.isImportSpecifier(Ne)){var Le=Pe;if("default"===Ne.imported.name)if(ke)Le=ke;else if(!a){Le=ke=e.scope.generateUidIdentifier(Pe.name);var je=g.variableDeclaration("var",[g.variableDeclarator(Le,g.callExpression(this.addHelper("interopRequireDefault"),[Pe]))]);we>0&&(je._blockHoist=we),v.push(je)}D[Ne.local.name]=g.memberExpression(Le,g.cloneWithoutLoc(Ne.imported))}}}else{var Ue=b(g.stringLiteral(De));Ue.loc=h[De].loc,v.push(Ue)}}if(f&&(0,s.default)(y).length)for(var Ve=(0,s.default)(y),Ge=0;Ge<Ve.length;Ge+=100)!function(e){var t=Ve.slice(e,e+100),r=g.identifier("undefined");t.forEach(function(e){r=S(g.identifier(e),r).expression});var n=g.expressionStatement(r);n._blockHoist=3,v.unshift(n)}(Ge);if(c&&!i){var We=E;this.opts.loose&&(We=A);var Ye=We();Ye._blockHoist=3,v.unshift(Ye)}e.unshiftContainer("body",v),e.traverse(t,{remaps:D,scope:u,exports:m,requeueInParent:function(t){return e.requeue(t)}})}}}}};var p=r(19),d=r(4),h=n(d),m=r(216),y=n(m),v=r(1),g=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(v),b=(0,h.default)("\n  require($0);\n"),E=(0,h.default)('\n  Object.defineProperty(exports, "__esModule", {\n    value: true\n  });\n'),x=(0,h.default)("\n  Object.defineProperty(exports, $0, {\n    enumerable: true,\n    get: function () {\n      return $1;\n    }\n  });\n"),A=(0,h.default)("\n  exports.__esModule = true;\n"),S=(0,h.default)("\n  exports.$0 = $1;\n"),_=(0,h.default)('\n  Object.keys(OBJECT).forEach(function (key) {\n    if (key === "default" || key === "__esModule") return;\n    Object.defineProperty(exports, key, {\n      enumerable: true,\n      get: function () {\n        return OBJECT[key];\n      }\n    });\n  });\n'),D=["FunctionExpression","FunctionDeclaration","ClassProperty","ClassMethod","ObjectMethod"];e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i),a=r(10),o=n(a);t.default=function(e){function t(e,t,r,n,i){new l.default({getObjectRef:n,methodNode:t,methodPath:e,isStatic:!0,scope:r,file:i}).replace()}var r=e.types,n=(0,o.default)();return{visitor:{Super:function(e){var t=e.findParent(function(e){return e.isObjectExpression()});t&&(t.node[n]=!0)},ObjectExpression:{exit:function(e,i){if(e.node[n]){for(var a=void 0,o=function(){return a=a||e.scope.generateUidIdentifier("obj")},u=e.get("properties"),l=u,c=Array.isArray(l),f=0,l=c?l:(0,s.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var d=p;d.isObjectProperty()&&(d=d.get("value")),t(d,d.node,e.scope,o,i)}a&&(e.scope.push({id:a}),e.replaceWith(r.assignmentExpression("=",a,e.node)))}}}}}};var u=r(193),l=n(u);e.exports=t.default},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}t.__esModule=!0;var i=r(2),s=function(e){return e&&e.__esModule?e:{default:e}}(i);t.default=function(){return{visitor:a.visitors.merge([{ArrowFunctionExpression:function(e){for(var t=e.get("params"),r=t,n=Array.isArray(r),i=0,r=n?r:(0,s.default)(r);;){var a;if(n){if(i>=r.length)break;a=r[i++]}else{if(i=r.next(),i.done)break;a=i.value}var o=a;if(o.isRestElement()||o.isAssignmentPattern()){e.arrowFunctionToShadowed();break}}}},u.visitor,p.visitor,c.visitor])}};var a=r(7),o=r(334),u=n(o),l=r(333),c=n(l),f=r(335),p=n(f);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{ObjectMethod:function(e){var t=e.node;if("method"===t.kind){var r=i.functionExpression(null,t.params,t.body,t.generator,t.async);r.returnType=t.returnType,e.replaceWith(i.objectProperty(t.key,r,t.computed))}},ObjectProperty:function(e){var t=e.node;t.shorthand&&(t.shorthand=!1)}}}};var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e,t,r){return r.opts.loose&&!s.isIdentifier(e.argument,{name:"arguments"})?e.argument:t.toArray(e.argument,!0)}function r(e){for(var t=0;t<e.length;t++)if(s.isSpreadElement(e[t]))return!0;return!1}function n(e,r,n){function a(){u.length&&(o.push(s.arrayExpression(u)),u=[])}for(var o=[],u=[],l=e,c=Array.isArray(l),f=0,l=c?l:(0,i.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var d=p;s.isSpreadElement(d)?(a(),o.push(t(d,r,n))):u.push(d)}return a(),o}var s=e.types;return{visitor:{ArrayExpression:function(e,t){var i=e.node,a=e.scope,o=i.elements;if(r(o)){var u=n(o,a,t),l=u.shift();s.isArrayExpression(l)||(u.unshift(l),l=s.arrayExpression([])),e.replaceWith(s.callExpression(s.memberExpression(l,s.identifier("concat")),u))}},CallExpression:function(e,t){var i=e.node,a=e.scope,o=i.arguments;if(r(o)){var u=e.get("callee");if(!u.isSuper()){var l=s.identifier("undefined");i.arguments=[];var c=void 0;c=1===o.length&&"arguments"===o[0].argument.name?[o[0].argument]:n(o,a,t);var f=c.shift();c.length?i.arguments.push(s.callExpression(s.memberExpression(f,s.identifier("concat")),c)):i.arguments.push(f);var p=i.callee;if(u.isMemberExpression()){var d=a.maybeGenerateMemoised(p.object);d?(p.object=s.assignmentExpression("=",d,p.object),l=d):l=p.object,s.appendToMemberExpression(p,s.identifier("apply"))}else i.callee=s.memberExpression(i.callee,s.identifier("apply"));s.isSuper(l)&&(l=s.thisExpression()),i.arguments.unshift(l)}}},NewExpression:function(e,t){var i=e.node,a=e.scope,o=i.arguments;if(r(o)){var u=n(o,a,t),l=s.arrayExpression([s.nullLiteral()]);o=s.callExpression(s.memberExpression(l,s.identifier("concat")),u),e.replaceWith(s.newExpression(s.callExpression(s.memberExpression(s.memberExpression(s.memberExpression(s.identifier("Function"),s.identifier("prototype")),s.identifier("bind")),s.identifier("apply")),[i.callee,o]),[]))}}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}t.__esModule=!0,t.default=function(){return{visitor:{RegExpLiteral:function(e){var t=e.node;s.is(t,"y")&&e.replaceWith(o.newExpression(o.identifier("RegExp"),[o.stringLiteral(t.pattern),o.stringLiteral(t.flags)]))}}}};var i=r(192),s=n(i),a=r(1),o=n(a);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e){return n.isLiteral(e)&&"string"==typeof e.value}function r(e,t){return n.binaryExpression("+",e,t)}var n=e.types;return{visitor:{TaggedTemplateExpression:function(e,t){for(var r=e.node,s=r.quasi,a=[],o=[],u=[],l=s.quasis,c=Array.isArray(l),f=0,l=c?l:(0,i.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var d=p;o.push(n.stringLiteral(d.value.cooked)),u.push(n.stringLiteral(d.value.raw))}o=n.arrayExpression(o),u=n.arrayExpression(u);var h="taggedTemplateLiteral";t.opts.loose&&(h+="Loose");var m=t.file.addTemplateObject(h,o,u);a.push(m),a=a.concat(s.expressions),e.replaceWith(n.callExpression(r.tag,a))},TemplateLiteral:function(e,s){for(var a=[],o=e.get("expressions"),u=e.node.quasis,l=Array.isArray(u),c=0,u=l?u:(0,i.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;a.push(n.stringLiteral(p.value.cooked));var d=o.shift();d&&(!s.opts.spec||d.isBaseType("string")||d.isBaseType("number")?a.push(d.node):a.push(n.callExpression(n.identifier("String"),[d.node])))}if(a=a.filter(function(e){return!n.isLiteral(e,{value:""})}),t(a[0])||t(a[1])||a.unshift(n.stringLiteral("")),a.length>1){for(var h=r(a.shift(),a.shift()),m=a,y=Array.isArray(m),v=0,m=y?m:(0,i.default)(m);;){var g;if(y){if(v>=m.length)break;g=m[v++]}else{if(v=m.next(),v.done)break;g=v.value}h=r(h,g)}e.replaceWith(h)}else e.replaceWith(a[0])}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(10),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){var t=e.types,r=(0,i.default)();return{visitor:{Scope:function(e){var t=e.scope;t.getBinding("Symbol")&&t.rename("Symbol")},UnaryExpression:function(e){var n=e.node,i=e.parent;if(!n[r]&&!e.find(function(e){return e.node&&!!e.node._generated})){if(e.parentPath.isBinaryExpression()&&t.EQUALITY_BINARY_OPERATORS.indexOf(i.operator)>=0){var s=e.getOpposite();if(s.isLiteral()&&"symbol"!==s.node.value&&"object"!==s.node.value)return}if("typeof"===n.operator){var a=t.callExpression(this.addHelper("typeof"),[n.argument]);if(e.get("argument").isIdentifier()){var o=t.stringLiteral("undefined"),u=t.unaryExpression("typeof",n.argument);u[r]=!0,e.replaceWith(t.conditionalExpression(t.binaryExpression("===",u,o),o,a))}else e.replaceWith(a)}}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{RegExpLiteral:function(e){var t=e.node;a.is(t,"u")&&(t.pattern=(0,i.default)(t.pattern,t.flags),a.pullFlag(t,"u"))}}}};var n=r(612),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=r(192),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t,r){"use strict";e.exports=r(606)},function(e,t,r){"use strict";e.exports={default:r(408),__esModule:!0}},function(e,t,r){"use strict";function n(){i(),s()}function i(){t.path=u=new o.default}function s(){t.scope=l=new o.default}t.__esModule=!0,t.scope=t.path=void 0;var a=r(364),o=function(e){return e&&e.__esModule?e:{default:e}}(a);t.clear=n,t.clearPath=i,t.clearScope=s;var u=t.path=new o.default,l=t.scope=new o.default},function(e,t){"use strict";function r(e){return e=e.split(" "),function(t){return e.indexOf(t)>=0}}function n(e,t){for(var r=65536,n=0;n<t.length;n+=2){if((r+=t[n])>e)return!1;if((r+=t[n+1])>=e)return!0}}function i(e){return e<65?36===e:e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&x.test(String.fromCharCode(e)):n(e,S)))}function s(e){return e<48?36===e:e<58||!(e<65)&&(e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&A.test(String.fromCharCode(e)):n(e,S)||n(e,_))))}function a(e){var t={};for(var r in D)t[r]=e&&r in e?e[r]:D[r];return t}function o(e){return 10===e||13===e||8232===e||8233===e}function u(e,t){for(var r=1,n=0;;){N.lastIndex=n;var i=N.exec(e);if(!(i&&i.index<t))return new V(r,t-n);++r,n=i.index+i[0].length}}function l(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(55296+(e-65536>>10),56320+(e-65536&1023))}function c(e,t,r,n){return e.type=t,e.end=r,e.loc.end=n,this.processComment(e),e}function f(e){return e[e.length-1]}function p(e){return e&&"Property"===e.type&&"init"===e.kind&&!1===e.method}function d(e){return"JSXIdentifier"===e.type?e.name:"JSXNamespacedName"===e.type?e.namespace.name+":"+e.name.name:"JSXMemberExpression"===e.type?d(e.object)+"."+d(e.property):void 0}function h(e,t){return new J(t,e).parse()}function m(e,t){var r=new J(t,e);return r.options.strictMode&&(r.state.strict=!0),r.getExpression()}var y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};Object.defineProperty(t,"__esModule",{value:!0});var v={6:r("enum await"),strict:r("implements interface let package private protected public static yield"),strictBind:r("eval arguments")
},g=r("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super"),b="-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",E="-------------------------------------------------------------------------------------------------------------------------------------------------",x=new RegExp("["+b+"]"),A=new RegExp("["+b+E+"]");b=E=null;var S=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541],_=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239],D={sourceType:"script",sourceFilename:void 0,startLine:1,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowSuperOutsideMethod:!1,plugins:[],strictMode:null},C="function"==typeof Symbol&&"symbol"===y(Symbol.iterator)?function(e){return void 0===e?"undefined":y(e)}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":void 0===e?"undefined":y(e)},w=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},P=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+(void 0===t?"undefined":y(t)));e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},k=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!==(void 0===t?"undefined":y(t))&&"function"!=typeof t?e:t},F=!0,T=function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(this,e),this.label=t,this.keyword=r.keyword,this.beforeExpr=!!r.beforeExpr,this.startsExpr=!!r.startsExpr,this.rightAssociative=!!r.rightAssociative,this.isLoop=!!r.isLoop,this.isAssign=!!r.isAssign,this.prefix=!!r.prefix,this.postfix=!!r.postfix,this.binop=r.binop||null,this.updateContext=null},O=function(e){function t(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return w(this,t),n.keyword=r,k(this,e.call(this,r,n))}return P(t,e),t}(T),B=function(e){function t(r,n){return w(this,t),k(this,e.call(this,r,{beforeExpr:F,binop:n}))}return P(t,e),t}(T),R={num:new T("num",{startsExpr:!0}),regexp:new T("regexp",{startsExpr:!0}),string:new T("string",{startsExpr:!0}),name:new T("name",{startsExpr:!0}),eof:new T("eof"),bracketL:new T("[",{beforeExpr:F,startsExpr:!0}),bracketR:new T("]"),braceL:new T("{",{beforeExpr:F,startsExpr:!0}),braceBarL:new T("{|",{beforeExpr:F,startsExpr:!0}),braceR:new T("}"),braceBarR:new T("|}"),parenL:new T("(",{beforeExpr:F,startsExpr:!0}),parenR:new T(")"),comma:new T(",",{beforeExpr:F}),semi:new T(";",{beforeExpr:F}),colon:new T(":",{beforeExpr:F}),doubleColon:new T("::",{beforeExpr:F}),dot:new T("."),question:new T("?",{beforeExpr:F}),arrow:new T("=>",{beforeExpr:F}),template:new T("template"),ellipsis:new T("...",{beforeExpr:F}),backQuote:new T("`",{startsExpr:!0}),dollarBraceL:new T("${",{beforeExpr:F,startsExpr:!0}),at:new T("@"),eq:new T("=",{beforeExpr:F,isAssign:!0}),assign:new T("_=",{beforeExpr:F,isAssign:!0}),incDec:new T("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new T("prefix",{beforeExpr:F,prefix:!0,startsExpr:!0}),logicalOR:new B("||",1),logicalAND:new B("&&",2),bitwiseOR:new B("|",3),bitwiseXOR:new B("^",4),bitwiseAND:new B("&",5),equality:new B("==/!=",6),relational:new B("</>",7),bitShift:new B("<</>>",8),plusMin:new T("+/-",{beforeExpr:F,binop:9,prefix:!0,startsExpr:!0}),modulo:new B("%",10),star:new B("*",10),slash:new B("/",10),exponent:new T("**",{beforeExpr:F,binop:11,rightAssociative:!0})},I={break:new O("break"),case:new O("case",{beforeExpr:F}),catch:new O("catch"),continue:new O("continue"),debugger:new O("debugger"),default:new O("default",{beforeExpr:F}),do:new O("do",{isLoop:!0,beforeExpr:F}),else:new O("else",{beforeExpr:F}),finally:new O("finally"),for:new O("for",{isLoop:!0}),function:new O("function",{startsExpr:!0}),if:new O("if"),return:new O("return",{beforeExpr:F}),switch:new O("switch"),throw:new O("throw",{beforeExpr:F}),try:new O("try"),var:new O("var"),let:new O("let"),const:new O("const"),while:new O("while",{isLoop:!0}),with:new O("with"),new:new O("new",{beforeExpr:F,startsExpr:!0}),this:new O("this",{startsExpr:!0}),super:new O("super",{startsExpr:!0}),class:new O("class"),extends:new O("extends",{beforeExpr:F}),export:new O("export"),import:new O("import",{startsExpr:!0}),yield:new O("yield",{beforeExpr:F,startsExpr:!0}),null:new O("null",{startsExpr:!0}),true:new O("true",{startsExpr:!0}),false:new O("false",{startsExpr:!0}),in:new O("in",{beforeExpr:F,binop:7}),instanceof:new O("instanceof",{beforeExpr:F,binop:7}),typeof:new O("typeof",{beforeExpr:F,prefix:!0,startsExpr:!0}),void:new O("void",{beforeExpr:F,prefix:!0,startsExpr:!0}),delete:new O("delete",{beforeExpr:F,prefix:!0,startsExpr:!0})};Object.keys(I).forEach(function(e){R["_"+e]=I[e]});var M=/\r\n?|\n|\u2028|\u2029/,N=new RegExp(M.source,"g"),L=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,j=function e(t,r,n,i){w(this,e),this.token=t,this.isExpr=!!r,this.preserveSpace=!!n,this.override=i},U={braceStatement:new j("{",!1),braceExpression:new j("{",!0),templateQuasi:new j("${",!0),parenStatement:new j("(",!1),parenExpression:new j("(",!0),template:new j("`",!0,!0,function(e){return e.readTmplToken()}),functionExpression:new j("function",!0)};R.parenR.updateContext=R.braceR.updateContext=function(){if(1===this.state.context.length)return void(this.state.exprAllowed=!0);var e=this.state.context.pop();e===U.braceStatement&&this.curContext()===U.functionExpression?(this.state.context.pop(),this.state.exprAllowed=!1):e===U.templateQuasi?this.state.exprAllowed=!0:this.state.exprAllowed=!e.isExpr},R.name.updateContext=function(e){this.state.exprAllowed=!1,e!==R._let&&e!==R._const&&e!==R._var||M.test(this.input.slice(this.state.end))&&(this.state.exprAllowed=!0)},R.braceL.updateContext=function(e){this.state.context.push(this.braceIsBlock(e)?U.braceStatement:U.braceExpression),this.state.exprAllowed=!0},R.dollarBraceL.updateContext=function(){this.state.context.push(U.templateQuasi),this.state.exprAllowed=!0},R.parenL.updateContext=function(e){var t=e===R._if||e===R._for||e===R._with||e===R._while;this.state.context.push(t?U.parenStatement:U.parenExpression),this.state.exprAllowed=!0},R.incDec.updateContext=function(){},R._function.updateContext=function(){this.curContext()!==U.braceStatement&&this.state.context.push(U.functionExpression),this.state.exprAllowed=!1},R.backQuote.updateContext=function(){this.curContext()===U.template?this.state.context.pop():this.state.context.push(U.template),this.state.exprAllowed=!1};var V=function e(t,r){w(this,e),this.line=t,this.column=r},G=function e(t,r){w(this,e),this.start=t,this.end=r},W=function(){function e(){w(this,e)}return e.prototype.init=function(e,t){return this.strict=!1!==e.strictMode&&"module"===e.sourceType,this.input=t,this.potentialArrowAt=-1,this.inMethod=this.inFunction=this.inGenerator=this.inAsync=this.inPropertyName=this.inType=this.inClassProperty=this.noAnonFunctionType=!1,this.labels=[],this.decorators=[],this.tokens=[],this.comments=[],this.trailingComments=[],this.leadingComments=[],this.commentStack=[],this.pos=this.lineStart=0,this.curLine=e.startLine,this.type=R.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=[U.braceStatement],this.exprAllowed=!0,this.containsEsc=this.containsOctal=!1,this.octalPosition=null,this.invalidTemplateEscapePosition=null,this.exportedIdentifiers=[],this},e.prototype.curPosition=function(){return new V(this.curLine,this.pos-this.lineStart)},e.prototype.clone=function(t){var r=new e;for(var n in this){var i=this[n];t&&"context"!==n||!Array.isArray(i)||(i=i.slice()),r[n]=i}return r},e}(),Y=function e(t){w(this,e),this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,this.loc=new G(t.startLoc,t.endLoc)},q=function(){function e(t,r){w(this,e),this.state=new W,this.state.init(t,r)}return e.prototype.next=function(){this.isLookahead||this.state.tokens.push(new Y(this.state)),this.state.lastTokEnd=this.state.end,this.state.lastTokStart=this.state.start,this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken()},e.prototype.eat=function(e){return!!this.match(e)&&(this.next(),!0)},e.prototype.match=function(e){return this.state.type===e},e.prototype.isKeyword=function(e){return g(e)},e.prototype.lookahead=function(){var e=this.state;this.state=e.clone(!0),this.isLookahead=!0,this.next(),this.isLookahead=!1;var t=this.state.clone(!0);return this.state=e,t},e.prototype.setStrict=function(e){if(this.state.strict=e,this.match(R.num)||this.match(R.string)){for(this.state.pos=this.state.start;this.state.pos<this.state.lineStart;)this.state.lineStart=this.input.lastIndexOf("\n",this.state.lineStart-2)+1,--this.state.curLine;this.nextToken()}},e.prototype.curContext=function(){return this.state.context[this.state.context.length-1]},e.prototype.nextToken=function(){var e=this.curContext();return e&&e.preserveSpace||this.skipSpace(),this.state.containsOctal=!1,this.state.octalPosition=null,this.state.start=this.state.pos,this.state.startLoc=this.state.curPosition(),this.state.pos>=this.input.length?this.finishToken(R.eof):e.override?e.override(this):this.readToken(this.fullCharCodeAtPos())},e.prototype.readToken=function(e){return i(e)||92===e?this.readWord():this.getTokenFromCode(e)},e.prototype.fullCharCodeAtPos=function(){var e=this.input.charCodeAt(this.state.pos);return e<=55295||e>=57344?e:(e<<10)+this.input.charCodeAt(this.state.pos+1)-56613888},e.prototype.pushComment=function(e,t,r,n,i,s){var a={type:e?"CommentBlock":"CommentLine",value:t,start:r,end:n,loc:new G(i,s)};this.isLookahead||(this.state.tokens.push(a),this.state.comments.push(a),this.addComment(a))},e.prototype.skipBlockComment=function(){var e=this.state.curPosition(),t=this.state.pos,r=this.input.indexOf("*/",this.state.pos+=2);-1===r&&this.raise(this.state.pos-2,"Unterminated comment"),this.state.pos=r+2,N.lastIndex=t;for(var n=void 0;(n=N.exec(this.input))&&n.index<this.state.pos;)++this.state.curLine,this.state.lineStart=n.index+n[0].length;this.pushComment(!0,this.input.slice(t+2,r),t,this.state.pos,e,this.state.curPosition())},e.prototype.skipLineComment=function(e){for(var t=this.state.pos,r=this.state.curPosition(),n=this.input.charCodeAt(this.state.pos+=e);this.state.pos<this.input.length&&10!==n&&13!==n&&8232!==n&&8233!==n;)++this.state.pos,n=this.input.charCodeAt(this.state.pos);this.pushComment(!1,this.input.slice(t+e,this.state.pos),t,this.state.pos,r,this.state.curPosition())},e.prototype.skipSpace=function(){e:for(;this.state.pos<this.input.length;){var e=this.input.charCodeAt(this.state.pos);switch(e){case 32:case 160:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(!(e>8&&e<14||e>=5760&&L.test(String.fromCharCode(e))))break e;++this.state.pos}}},e.prototype.finishToken=function(e,t){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();var r=this.state.type;this.state.type=e,this.state.value=t,this.updateContext(r)},e.prototype.readToken_dot=function(){var e=this.input.charCodeAt(this.state.pos+1);if(e>=48&&e<=57)return this.readNumber(!0);var t=this.input.charCodeAt(this.state.pos+2);return 46===e&&46===t?(this.state.pos+=3,this.finishToken(R.ellipsis)):(++this.state.pos,this.finishToken(R.dot))},e.prototype.readToken_slash=function(){return this.state.exprAllowed?(++this.state.pos,this.readRegexp()):61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(R.assign,2):this.finishOp(R.slash,1)},e.prototype.readToken_mult_modulo=function(e){var t=42===e?R.star:R.modulo,r=1,n=this.input.charCodeAt(this.state.pos+1);return 42===n&&(r++,n=this.input.charCodeAt(this.state.pos+2),t=R.exponent),61===n&&(r++,t=R.assign),this.finishOp(t,r)},e.prototype.readToken_pipe_amp=function(e){var t=this.input.charCodeAt(this.state.pos+1);return t===e?this.finishOp(124===e?R.logicalOR:R.logicalAND,2):61===t?this.finishOp(R.assign,2):124===e&&125===t&&this.hasPlugin("flow")?this.finishOp(R.braceBarR,2):this.finishOp(124===e?R.bitwiseOR:R.bitwiseAND,1)},e.prototype.readToken_caret=function(){return 61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(R.assign,2):this.finishOp(R.bitwiseXOR,1)},e.prototype.readToken_plus_min=function(e){var t=this.input.charCodeAt(this.state.pos+1);return t===e?45===t&&62===this.input.charCodeAt(this.state.pos+2)&&M.test(this.input.slice(this.state.lastTokEnd,this.state.pos))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(R.incDec,2):61===t?this.finishOp(R.assign,2):this.finishOp(R.plusMin,1)},e.prototype.readToken_lt_gt=function(e){var t=this.input.charCodeAt(this.state.pos+1),r=1;return t===e?(r=62===e&&62===this.input.charCodeAt(this.state.pos+2)?3:2,61===this.input.charCodeAt(this.state.pos+r)?this.finishOp(R.assign,r+1):this.finishOp(R.bitShift,r)):33===t&&60===e&&45===this.input.charCodeAt(this.state.pos+2)&&45===this.input.charCodeAt(this.state.pos+3)?(this.inModule&&this.unexpected(),this.skipLineComment(4),this.skipSpace(),this.nextToken()):(61===t&&(r=2),this.finishOp(R.relational,r))},e.prototype.readToken_eq_excl=function(e){var t=this.input.charCodeAt(this.state.pos+1);return 61===t?this.finishOp(R.equality,61===this.input.charCodeAt(this.state.pos+2)?3:2):61===e&&62===t?(this.state.pos+=2,this.finishToken(R.arrow)):this.finishOp(61===e?R.eq:R.prefix,1)},e.prototype.getTokenFromCode=function(e){switch(e){case 46:return this.readToken_dot();case 40:return++this.state.pos,this.finishToken(R.parenL);case 41:return++this.state.pos,this.finishToken(R.parenR);case 59:return++this.state.pos,this.finishToken(R.semi);case 44:return++this.state.pos,this.finishToken(R.comma);case 91:return++this.state.pos,this.finishToken(R.bracketL);case 93:return++this.state.pos,this.finishToken(R.bracketR);case 123:return this.hasPlugin("flow")&&124===this.input.charCodeAt(this.state.pos+1)?this.finishOp(R.braceBarL,2):(++this.state.pos,this.finishToken(R.braceL));case 125:return++this.state.pos,this.finishToken(R.braceR);case 58:return this.hasPlugin("functionBind")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(R.doubleColon,2):(++this.state.pos,this.finishToken(R.colon));case 63:return++this.state.pos,this.finishToken(R.question);case 64:return++this.state.pos,this.finishToken(R.at);case 96:return++this.state.pos,this.finishToken(R.backQuote);case 48:var t=this.input.charCodeAt(this.state.pos+1);if(120===t||88===t)return this.readRadixNumber(16);if(111===t||79===t)return this.readRadixNumber(8);if(98===t||66===t)return this.readRadixNumber(2);case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(e);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo(e);case 124:case 38:return this.readToken_pipe_amp(e);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(e);case 60:case 62:return this.readToken_lt_gt(e);case 61:case 33:return this.readToken_eq_excl(e);case 126:return this.finishOp(R.prefix,1)}this.raise(this.state.pos,"Unexpected character '"+l(e)+"'")},e.prototype.finishOp=function(e,t){var r=this.input.slice(this.state.pos,this.state.pos+t);return this.state.pos+=t,this.finishToken(e,r)},e.prototype.readRegexp=function(){for(var e=this.state.pos,t=void 0,r=void 0;;){this.state.pos>=this.input.length&&this.raise(e,"Unterminated regular expression");var n=this.input.charAt(this.state.pos);if(M.test(n)&&this.raise(e,"Unterminated regular expression"),t)t=!1;else{if("["===n)r=!0;else if("]"===n&&r)r=!1;else if("/"===n&&!r)break;t="\\"===n}++this.state.pos}var i=this.input.slice(e,this.state.pos);++this.state.pos;var s=this.readWord1();if(s){/^[gmsiyu]*$/.test(s)||this.raise(e,"Invalid regular expression flag")}return this.finishToken(R.regexp,{pattern:i,flags:s})},e.prototype.readInt=function(e,t){for(var r=this.state.pos,n=0,i=0,s=null==t?1/0:t;i<s;++i){var a=this.input.charCodeAt(this.state.pos),o=void 0;if((o=a>=97?a-97+10:a>=65?a-65+10:a>=48&&a<=57?a-48:1/0)>=e)break;++this.state.pos,n=n*e+o}return this.state.pos===r||null!=t&&this.state.pos-r!==t?null:n},e.prototype.readRadixNumber=function(e){this.state.pos+=2;var t=this.readInt(e);return null==t&&this.raise(this.state.start+2,"Expected number in radix "+e),i(this.fullCharCodeAtPos())&&this.raise(this.state.pos,"Identifier directly after number"),this.finishToken(R.num,t)},e.prototype.readNumber=function(e){var t=this.state.pos,r=48===this.input.charCodeAt(t),n=!1;e||null!==this.readInt(10)||this.raise(t,"Invalid number"),r&&this.state.pos==t+1&&(r=!1);var s=this.input.charCodeAt(this.state.pos);46!==s||r||(++this.state.pos,this.readInt(10),n=!0,s=this.input.charCodeAt(this.state.pos)),69!==s&&101!==s||r||(s=this.input.charCodeAt(++this.state.pos),43!==s&&45!==s||++this.state.pos,null===this.readInt(10)&&this.raise(t,"Invalid number"),n=!0),i(this.fullCharCodeAtPos())&&this.raise(this.state.pos,"Identifier directly after number");var a=this.input.slice(t,this.state.pos),o=void 0;return n?o=parseFloat(a):r&&1!==a.length?this.state.strict?this.raise(t,"Invalid number"):o=/[89]/.test(a)?parseInt(a,10):parseInt(a,8):o=parseInt(a,10),this.finishToken(R.num,o)},e.prototype.readCodePoint=function(e){var t=this.input.charCodeAt(this.state.pos),r=void 0;if(123===t){var n=++this.state.pos;if(r=this.readHexChar(this.input.indexOf("}",this.state.pos)-this.state.pos,e),++this.state.pos,null===r)--this.state.invalidTemplateEscapePosition;else if(r>1114111){if(!e)return this.state.invalidTemplateEscapePosition=n-2,null;this.raise(n,"Code point out of bounds")}}else r=this.readHexChar(4,e);return r},e.prototype.readString=function(e){for(var t="",r=++this.state.pos;;){this.state.pos>=this.input.length&&this.raise(this.state.start,"Unterminated string constant");var n=this.input.charCodeAt(this.state.pos);if(n===e)break;92===n?(t+=this.input.slice(r,this.state.pos),t+=this.readEscapedChar(!1),r=this.state.pos):(o(n)&&this.raise(this.state.start,"Unterminated string constant"),++this.state.pos)}return t+=this.input.slice(r,this.state.pos++),this.finishToken(R.string,t)},e.prototype.readTmplToken=function(){for(var e="",t=this.state.pos,r=!1;;){this.state.pos>=this.input.length&&this.raise(this.state.start,"Unterminated template");var n=this.input.charCodeAt(this.state.pos);if(96===n||36===n&&123===this.input.charCodeAt(this.state.pos+1))return this.state.pos===this.state.start&&this.match(R.template)?36===n?(this.state.pos+=2,this.finishToken(R.dollarBraceL)):(++this.state.pos,this.finishToken(R.backQuote)):(e+=this.input.slice(t,this.state.pos),this.finishToken(R.template,r?null:e));if(92===n){e+=this.input.slice(t,this.state.pos);var i=this.readEscapedChar(!0);null===i?r=!0:e+=i,t=this.state.pos}else if(o(n)){switch(e+=this.input.slice(t,this.state.pos),++this.state.pos,n){case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:e+="\n";break;default:e+=String.fromCharCode(n)}++this.state.curLine,this.state.lineStart=this.state.pos,t=this.state.pos}else++this.state.pos}},e.prototype.readEscapedChar=function(e){var t=!e,r=this.input.charCodeAt(++this.state.pos);switch(++this.state.pos,r){case 110:return"\n";case 114:return"\r";case 120:var n=this.readHexChar(2,t);return null===n?null:String.fromCharCode(n);case 117:var i=this.readCodePoint(t);return null===i?null:l(i);case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:return this.state.lineStart=this.state.pos,++this.state.curLine,"";default:if(r>=48&&r<=55){var s=this.state.pos-1,a=this.input.substr(this.state.pos-1,3).match(/^[0-7]+/)[0],o=parseInt(a,8);if(o>255&&(a=a.slice(0,-1),o=parseInt(a,8)),o>0){if(e)return this.state.invalidTemplateEscapePosition=s,null;this.state.strict?this.raise(s,"Octal literal in strict mode"):this.state.containsOctal||(this.state.containsOctal=!0,this.state.octalPosition=s)}return this.state.pos+=a.length-1,String.fromCharCode(o)}return String.fromCharCode(r)}},e.prototype.readHexChar=function(e,t){var r=this.state.pos,n=this.readInt(16,e);return null===n&&(t?this.raise(r,"Bad character escape sequence"):(this.state.pos=r-1,this.state.invalidTemplateEscapePosition=r-1)),n},e.prototype.readWord1=function(){this.state.containsEsc=!1;for(var e="",t=!0,r=this.state.pos;this.state.pos<this.input.length;){var n=this.fullCharCodeAtPos();if(s(n))this.state.pos+=n<=65535?1:2;else{if(92!==n)break;this.state.containsEsc=!0,e+=this.input.slice(r,this.state.pos);var a=this.state.pos;117!==this.input.charCodeAt(++this.state.pos)&&this.raise(this.state.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.state.pos;var o=this.readCodePoint(!0);(t?i:s)(o,!0)||this.raise(a,"Invalid Unicode escape"),e+=l(o),r=this.state.pos}t=!1}return e+this.input.slice(r,this.state.pos)},e.prototype.readWord=function(){var e=this.readWord1(),t=R.name;return!this.state.containsEsc&&this.isKeyword(e)&&(t=I[e]),this.finishToken(t,e)},e.prototype.braceIsBlock=function(e){if(e===R.colon){var t=this.curContext();if(t===U.braceStatement||t===U.braceExpression)return!t.isExpr}return e===R._return?M.test(this.input.slice(this.state.lastTokEnd,this.state.start)):e===R._else||e===R.semi||e===R.eof||e===R.parenR||(e===R.braceL?this.curContext()===U.braceStatement:!this.state.exprAllowed)},e.prototype.updateContext=function(e){var t=this.state.type,r=void 0;t.keyword&&e===R.dot?this.state.exprAllowed=!1:(r=t.updateContext)?r.call(this,e):this.state.exprAllowed=t.beforeExpr},e}(),K={},H=["jsx","doExpressions","objectRestSpread","decorators","classProperties","exportExtensions","asyncGenerators","functionBind","functionSent","dynamicImport","flow"],J=function(e){function t(r,n){w(this,t),r=a(r);var i=k(this,e.call(this,r,n));return i.options=r,i.inModule="module"===i.options.sourceType,i.input=n,i.plugins=i.loadPlugins(i.options.plugins),i.filename=r.sourceFilename,0===i.state.pos&&"#"===i.input[0]&&"!"===i.input[1]&&i.skipLineComment(2),i}return P(t,e),t.prototype.isReservedWord=function(e){return"await"===e?this.inModule:v[6](e)},t.prototype.hasPlugin=function(e){return!!(this.plugins["*"]&&H.indexOf(e)>-1)||!!this.plugins[e]},t.prototype.extend=function(e,t){this[e]=t(this[e])},t.prototype.loadAllPlugins=function(){var e=this,t=Object.keys(K).filter(function(e){return"flow"!==e&&"estree"!==e});t.push("flow"),t.forEach(function(t){var r=K[t];r&&r(e)})},t.prototype.loadPlugins=function(e){if(e.indexOf("*")>=0)return this.loadAllPlugins(),{"*":!0};var t={};e.indexOf("flow")>=0&&(e=e.filter(function(e){return"flow"!==e}),e.push("flow")),e.indexOf("estree")>=0&&(e=e.filter(function(e){return"estree"!==e}),e.unshift("estree"));for(var r=e,n=Array.isArray(r),i=0,r=n?r:r[Symbol.iterator]();;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;if(!t[a]){t[a]=!0;var o=K[a];o&&o(this)}}return t},t.prototype.parse=function(){var e=this.startNode(),t=this.startNode();return this.nextToken(),this.parseTopLevel(e,t)},t}(q),X=J.prototype;X.addExtra=function(e,t,r){if(e){(e.extra=e.extra||{})[t]=r}},X.isRelational=function(e){return this.match(R.relational)&&this.state.value===e},X.expectRelational=function(e){this.isRelational(e)?this.next():this.unexpected(null,R.relational)},X.isContextual=function(e){return this.match(R.name)&&this.state.value===e},X.eatContextual=function(e){return this.state.value===e&&this.eat(R.name)},X.expectContextual=function(e,t){this.eatContextual(e)||this.unexpected(null,t)},X.canInsertSemicolon=function(){return this.match(R.eof)||this.match(R.braceR)||M.test(this.input.slice(this.state.lastTokEnd,this.state.start))},X.isLineTerminator=function(){return this.eat(R.semi)||this.canInsertSemicolon()},X.semicolon=function(){this.isLineTerminator()||this.unexpected(null,R.semi)},X.expect=function(e,t){return this.eat(e)||this.unexpected(t,e)},X.unexpected=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"Unexpected token";t&&"object"===(void 0===t?"undefined":C(t))&&t.label&&(t="Unexpected token, expected "+t.label),this.raise(null!=e?e:this.state.start,t)};var z=J.prototype;z.parseTopLevel=function(e,t){return t.sourceType=this.options.sourceType,this.parseBlockBody(t,!0,!0,R.eof),e.program=this.finishNode(t,"Program"),e.comments=this.state.comments,e.tokens=this.state.tokens,this.finishNode(e,"File")};var $={kind:"loop"},Q={kind:"switch"};z.stmtToDirective=function(e){var t=e.expression,r=this.startNodeAt(t.start,t.loc.start),n=this.startNodeAt(e.start,e.loc.start),i=this.input.slice(t.start,t.end),s=r.value=i.slice(1,-1);return this.addExtra(r,"raw",i),this.addExtra(r,"rawValue",s),n.value=this.finishNodeAt(r,"DirectiveLiteral",t.end,t.loc.end),this.finishNodeAt(n,"Directive",e.end,e.loc.end)},z.parseStatement=function(e,t){this.match(R.at)&&this.parseDecorators(!0);var r=this.state.type,n=this.startNode();switch(r){case R._break:case R._continue:return this.parseBreakContinueStatement(n,r.keyword);case R._debugger:return this.parseDebuggerStatement(n);case R._do:return this.parseDoStatement(n);case R._for:return this.parseForStatement(n);case R._function:return e||this.unexpected(),this.parseFunctionStatement(n);case R._class:return e||this.unexpected(),this.parseClass(n,!0);case R._if:return this.parseIfStatement(n);case R._return:return this.parseReturnStatement(n);case R._switch:return this.parseSwitchStatement(n);case R._throw:return this.parseThrowStatement(n);case R._try:return this.parseTryStatement(n);case R._let:case R._const:e||this.unexpected();case R._var:return this.parseVarStatement(n,r);case R._while:return this.parseWhileStatement(n);case R._with:return this.parseWithStatement(n);case R.braceL:return this.parseBlock();case R.semi:return this.parseEmptyStatement(n);case R._export:case R._import:if(this.hasPlugin("dynamicImport")&&this.lookahead().type===R.parenL)break;return this.options.allowImportExportEverywhere||(t||this.raise(this.state.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.state.start,"'import' and 'export' may appear only with 'sourceType: \"module\"'")),r===R._import?this.parseImport(n):this.parseExport(n);case R.name:if("async"===this.state.value){var i=this.state.clone();if(this.next(),this.match(R._function)&&!this.canInsertSemicolon())return this.expect(R._function),this.parseFunction(n,!0,!1,!0);this.state=i}}var s=this.state.value,a=this.parseExpression();return r===R.name&&"Identifier"===a.type&&this.eat(R.colon)?this.parseLabeledStatement(n,s,a):this.parseExpressionStatement(n,a)},z.takeDecorators=function(e){this.state.decorators.length&&(e.decorators=this.state.decorators,this.state.decorators=[])},z.parseDecorators=function(e){for(;this.match(R.at);){var t=this.parseDecorator();this.state.decorators.push(t)}e&&this.match(R._export)||this.match(R._class)||this.raise(this.state.start,"Leading decorators must be attached to a class declaration")},z.parseDecorator=function(){this.hasPlugin("decorators")||this.unexpected();var e=this.startNode();return this.next(),e.expression=this.parseMaybeAssign(),this.finishNode(e,"Decorator")},z.parseBreakContinueStatement=function(e,t){var r="break"===t;this.next(),this.isLineTerminator()?e.label=null:this.match(R.name)?(e.label=this.parseIdentifier(),this.semicolon()):this.unexpected();var n=void 0;for(n=0;n<this.state.labels.length;++n){var i=this.state.labels[n];if(null==e.label||i.name===e.label.name){if(null!=i.kind&&(r||"loop"===i.kind))break;if(e.label&&r)break}}return n===this.state.labels.length&&this.raise(e.start,"Unsyntactic "+t),this.finishNode(e,r?"BreakStatement":"ContinueStatement")},z.parseDebuggerStatement=function(e){return this.next(),this.semicolon(),this.finishNode(e,"DebuggerStatement")},z.parseDoStatement=function(e){return this.next(),this.state.labels.push($),e.body=this.parseStatement(!1),this.state.labels.pop(),this.expect(R._while),e.test=this.parseParenExpression(),this.eat(R.semi),this.finishNode(e,"DoWhileStatement")},z.parseForStatement=function(e){this.next(),this.state.labels.push($);var t=!1;if(this.hasPlugin("asyncGenerators")&&this.state.inAsync&&this.isContextual("await")&&(t=!0,this.next()),this.expect(R.parenL),this.match(R.semi))return t&&this.unexpected(),this.parseFor(e,null);if(this.match(R._var)||this.match(R._let)||this.match(R._const)){var r=this.startNode(),n=this.state.type;return this.next(),(this.parseVar(r,!0,n),this.finishNode(r,"VariableDeclaration"),!this.match(R._in)&&!this.isContextual("of")||1!==r.declarations.length||r.declarations[0].init)?(t&&this.unexpected(),
this.parseFor(e,r)):this.parseForIn(e,r,t)}var i={start:0},s=this.parseExpression(!0,i);if(this.match(R._in)||this.isContextual("of")){var a=this.isContextual("of")?"for-of statement":"for-in statement";return this.toAssignable(s,void 0,a),this.checkLVal(s,void 0,void 0,a),this.parseForIn(e,s,t)}return i.start&&this.unexpected(i.start),t&&this.unexpected(),this.parseFor(e,s)},z.parseFunctionStatement=function(e){return this.next(),this.parseFunction(e,!0)},z.parseIfStatement=function(e){return this.next(),e.test=this.parseParenExpression(),e.consequent=this.parseStatement(!1),e.alternate=this.eat(R._else)?this.parseStatement(!1):null,this.finishNode(e,"IfStatement")},z.parseReturnStatement=function(e){return this.state.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.state.start,"'return' outside of function"),this.next(),this.isLineTerminator()?e.argument=null:(e.argument=this.parseExpression(),this.semicolon()),this.finishNode(e,"ReturnStatement")},z.parseSwitchStatement=function(e){this.next(),e.discriminant=this.parseParenExpression(),e.cases=[],this.expect(R.braceL),this.state.labels.push(Q);for(var t,r=void 0;!this.match(R.braceR);)if(this.match(R._case)||this.match(R._default)){var n=this.match(R._case);r&&this.finishNode(r,"SwitchCase"),e.cases.push(r=this.startNode()),r.consequent=[],this.next(),n?r.test=this.parseExpression():(t&&this.raise(this.state.lastTokStart,"Multiple default clauses"),t=!0,r.test=null),this.expect(R.colon)}else r?r.consequent.push(this.parseStatement(!0)):this.unexpected();return r&&this.finishNode(r,"SwitchCase"),this.next(),this.state.labels.pop(),this.finishNode(e,"SwitchStatement")},z.parseThrowStatement=function(e){return this.next(),M.test(this.input.slice(this.state.lastTokEnd,this.state.start))&&this.raise(this.state.lastTokEnd,"Illegal newline after throw"),e.argument=this.parseExpression(),this.semicolon(),this.finishNode(e,"ThrowStatement")};var Z=[];z.parseTryStatement=function(e){if(this.next(),e.block=this.parseBlock(),e.handler=null,this.match(R._catch)){var t=this.startNode();this.next(),this.expect(R.parenL),t.param=this.parseBindingAtom(),this.checkLVal(t.param,!0,Object.create(null),"catch clause"),this.expect(R.parenR),t.body=this.parseBlock(),e.handler=this.finishNode(t,"CatchClause")}return e.guardedHandlers=Z,e.finalizer=this.eat(R._finally)?this.parseBlock():null,e.handler||e.finalizer||this.raise(e.start,"Missing catch or finally clause"),this.finishNode(e,"TryStatement")},z.parseVarStatement=function(e,t){return this.next(),this.parseVar(e,!1,t),this.semicolon(),this.finishNode(e,"VariableDeclaration")},z.parseWhileStatement=function(e){return this.next(),e.test=this.parseParenExpression(),this.state.labels.push($),e.body=this.parseStatement(!1),this.state.labels.pop(),this.finishNode(e,"WhileStatement")},z.parseWithStatement=function(e){return this.state.strict&&this.raise(this.state.start,"'with' in strict mode"),this.next(),e.object=this.parseParenExpression(),e.body=this.parseStatement(!1),this.finishNode(e,"WithStatement")},z.parseEmptyStatement=function(e){return this.next(),this.finishNode(e,"EmptyStatement")},z.parseLabeledStatement=function(e,t,r){for(var n=this.state.labels,i=Array.isArray(n),s=0,n=i?n:n[Symbol.iterator]();;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}a.name===t&&this.raise(r.start,"Label '"+t+"' is already declared")}for(var o=this.state.type.isLoop?"loop":this.match(R._switch)?"switch":null,u=this.state.labels.length-1;u>=0;u--){var l=this.state.labels[u];if(l.statementStart!==e.start)break;l.statementStart=this.state.start,l.kind=o}return this.state.labels.push({name:t,kind:o,statementStart:this.state.start}),e.body=this.parseStatement(!0),this.state.labels.pop(),e.label=r,this.finishNode(e,"LabeledStatement")},z.parseExpressionStatement=function(e,t){return e.expression=t,this.semicolon(),this.finishNode(e,"ExpressionStatement")},z.parseBlock=function(e){var t=this.startNode();return this.expect(R.braceL),this.parseBlockBody(t,e,!1,R.braceR),this.finishNode(t,"BlockStatement")},z.isValidDirective=function(e){return"ExpressionStatement"===e.type&&"StringLiteral"===e.expression.type&&!e.expression.extra.parenthesized},z.parseBlockBody=function(e,t,r,n){e.body=[],e.directives=[];for(var i=!1,s=void 0,a=void 0;!this.eat(n);){i||!this.state.containsOctal||a||(a=this.state.octalPosition);var o=this.parseStatement(!0,r);if(t&&!i&&this.isValidDirective(o)){var u=this.stmtToDirective(o);e.directives.push(u),void 0===s&&"use strict"===u.value.value&&(s=this.state.strict,this.setStrict(!0),a&&this.raise(a,"Octal literal in strict mode"))}else i=!0,e.body.push(o)}!1===s&&this.setStrict(!1)},z.parseFor=function(e,t){return e.init=t,this.expect(R.semi),e.test=this.match(R.semi)?null:this.parseExpression(),this.expect(R.semi),e.update=this.match(R.parenR)?null:this.parseExpression(),this.expect(R.parenR),e.body=this.parseStatement(!1),this.state.labels.pop(),this.finishNode(e,"ForStatement")},z.parseForIn=function(e,t,r){var n=void 0;return r?(this.eatContextual("of"),n="ForAwaitStatement"):(n=this.match(R._in)?"ForInStatement":"ForOfStatement",this.next()),e.left=t,e.right=this.parseExpression(),this.expect(R.parenR),e.body=this.parseStatement(!1),this.state.labels.pop(),this.finishNode(e,n)},z.parseVar=function(e,t,r){for(e.declarations=[],e.kind=r.keyword;;){var n=this.startNode();if(this.parseVarHead(n),this.eat(R.eq)?n.init=this.parseMaybeAssign(t):r!==R._const||this.match(R._in)||this.isContextual("of")?"Identifier"===n.id.type||t&&(this.match(R._in)||this.isContextual("of"))?n.init=null:this.raise(this.state.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),e.declarations.push(this.finishNode(n,"VariableDeclarator")),!this.eat(R.comma))break}return e},z.parseVarHead=function(e){e.id=this.parseBindingAtom(),this.checkLVal(e.id,!0,void 0,"variable declaration")},z.parseFunction=function(e,t,r,n,i){var s=this.state.inMethod;return this.state.inMethod=!1,this.initFunction(e,n),this.match(R.star)&&(e.async&&!this.hasPlugin("asyncGenerators")?this.unexpected():(e.generator=!0,this.next())),!t||i||this.match(R.name)||this.match(R._yield)||this.unexpected(),(this.match(R.name)||this.match(R._yield))&&(e.id=this.parseBindingIdentifier()),this.parseFunctionParams(e),this.parseFunctionBody(e,r),this.state.inMethod=s,this.finishNode(e,t?"FunctionDeclaration":"FunctionExpression")},z.parseFunctionParams=function(e){this.expect(R.parenL),e.params=this.parseBindingList(R.parenR)},z.parseClass=function(e,t,r){return this.next(),this.takeDecorators(e),this.parseClassId(e,t,r),this.parseClassSuper(e),this.parseClassBody(e),this.finishNode(e,t?"ClassDeclaration":"ClassExpression")},z.isClassProperty=function(){return this.match(R.eq)||this.match(R.semi)||this.match(R.braceR)},z.isClassMethod=function(){return this.match(R.parenL)},z.isNonstaticConstructor=function(e){return!(e.computed||e.static||"constructor"!==e.key.name&&"constructor"!==e.key.value)},z.parseClassBody=function(e){var t=this.state.strict;this.state.strict=!0;var r=!1,n=!1,i=[],s=this.startNode();for(s.body=[],this.expect(R.braceL);!this.eat(R.braceR);)if(this.eat(R.semi))i.length>0&&this.raise(this.state.lastTokEnd,"Decorators must not be followed by a semicolon");else if(this.match(R.at))i.push(this.parseDecorator());else{var a=this.startNode();if(i.length&&(a.decorators=i,i=[]),a.static=!1,this.match(R.name)&&"static"===this.state.value){var o=this.parseIdentifier(!0);if(this.isClassMethod()){a.kind="method",a.computed=!1,a.key=o,this.parseClassMethod(s,a,!1,!1);continue}if(this.isClassProperty()){a.computed=!1,a.key=o,s.body.push(this.parseClassProperty(a));continue}a.static=!0}if(this.eat(R.star))a.kind="method",this.parsePropertyName(a),this.isNonstaticConstructor(a)&&this.raise(a.key.start,"Constructor can't be a generator"),a.computed||!a.static||"prototype"!==a.key.name&&"prototype"!==a.key.value||this.raise(a.key.start,"Classes may not have static property named prototype"),this.parseClassMethod(s,a,!0,!1);else{var u=this.match(R.name),l=this.parsePropertyName(a);if(a.computed||!a.static||"prototype"!==a.key.name&&"prototype"!==a.key.value||this.raise(a.key.start,"Classes may not have static property named prototype"),this.isClassMethod())this.isNonstaticConstructor(a)?(n?this.raise(l.start,"Duplicate constructor in the same class"):a.decorators&&this.raise(a.start,"You can't attach decorators to a class constructor"),n=!0,a.kind="constructor"):a.kind="method",this.parseClassMethod(s,a,!1,!1);else if(this.isClassProperty())this.isNonstaticConstructor(a)&&this.raise(a.key.start,"Classes may not have a non-static field named 'constructor'"),s.body.push(this.parseClassProperty(a));else if(u&&"async"===l.name&&!this.isLineTerminator()){var c=this.hasPlugin("asyncGenerators")&&this.eat(R.star);a.kind="method",this.parsePropertyName(a),this.isNonstaticConstructor(a)&&this.raise(a.key.start,"Constructor can't be an async function"),this.parseClassMethod(s,a,c,!0)}else!u||"get"!==l.name&&"set"!==l.name||this.isLineTerminator()&&this.match(R.star)?this.hasPlugin("classConstructorCall")&&u&&"call"===l.name&&this.match(R.name)&&"constructor"===this.state.value?(r?this.raise(a.start,"Duplicate constructor call in the same class"):a.decorators&&this.raise(a.start,"You can't attach decorators to a class constructor"),r=!0,a.kind="constructorCall",this.parsePropertyName(a),this.parseClassMethod(s,a,!1,!1)):this.isLineTerminator()?(this.isNonstaticConstructor(a)&&this.raise(a.key.start,"Classes may not have a non-static field named 'constructor'"),s.body.push(this.parseClassProperty(a))):this.unexpected():(a.kind=l.name,this.parsePropertyName(a),this.isNonstaticConstructor(a)&&this.raise(a.key.start,"Constructor can't have get/set modifier"),this.parseClassMethod(s,a,!1,!1),this.checkGetterSetterParamCount(a))}}i.length&&this.raise(this.state.start,"You have trailing decorators with no method"),e.body=this.finishNode(s,"ClassBody"),this.state.strict=t},z.parseClassProperty=function(e){return this.state.inClassProperty=!0,this.match(R.eq)?(this.hasPlugin("classProperties")||this.unexpected(),this.next(),e.value=this.parseMaybeAssign()):e.value=null,this.semicolon(),this.state.inClassProperty=!1,this.finishNode(e,"ClassProperty")},z.parseClassMethod=function(e,t,r,n){this.parseMethod(t,r,n),e.body.push(this.finishNode(t,"ClassMethod"))},z.parseClassId=function(e,t,r){this.match(R.name)?e.id=this.parseIdentifier():r||!t?e.id=null:this.unexpected()},z.parseClassSuper=function(e){e.superClass=this.eat(R._extends)?this.parseExprSubscripts():null},z.parseExport=function(e){if(this.next(),this.match(R.star)){var t=this.startNode();if(this.next(),!this.hasPlugin("exportExtensions")||!this.eatContextual("as"))return this.parseExportFrom(e,!0),this.finishNode(e,"ExportAllDeclaration");t.exported=this.parseIdentifier(),e.specifiers=[this.finishNode(t,"ExportNamespaceSpecifier")],this.parseExportSpecifiersMaybe(e),this.parseExportFrom(e,!0)}else if(this.hasPlugin("exportExtensions")&&this.isExportDefaultSpecifier()){var r=this.startNode();if(r.exported=this.parseIdentifier(!0),e.specifiers=[this.finishNode(r,"ExportDefaultSpecifier")],this.match(R.comma)&&this.lookahead().type===R.star){this.expect(R.comma);var n=this.startNode();this.expect(R.star),this.expectContextual("as"),n.exported=this.parseIdentifier(),e.specifiers.push(this.finishNode(n,"ExportNamespaceSpecifier"))}else this.parseExportSpecifiersMaybe(e);this.parseExportFrom(e,!0)}else{if(this.eat(R._default)){var i=this.startNode(),s=!1;return this.eat(R._function)?i=this.parseFunction(i,!0,!1,!1,!0):this.match(R._class)?i=this.parseClass(i,!0,!0):(s=!0,i=this.parseMaybeAssign()),e.declaration=i,s&&this.semicolon(),this.checkExport(e,!0,!0),this.finishNode(e,"ExportDefaultDeclaration")}this.shouldParseExportDeclaration()?(e.specifiers=[],e.source=null,e.declaration=this.parseExportDeclaration(e)):(e.declaration=null,e.specifiers=this.parseExportSpecifiers(),this.parseExportFrom(e))}return this.checkExport(e,!0),this.finishNode(e,"ExportNamedDeclaration")},z.parseExportDeclaration=function(){return this.parseStatement(!0)},z.isExportDefaultSpecifier=function(){if(this.match(R.name))return"async"!==this.state.value;if(!this.match(R._default))return!1;var e=this.lookahead();return e.type===R.comma||e.type===R.name&&"from"===e.value},z.parseExportSpecifiersMaybe=function(e){this.eat(R.comma)&&(e.specifiers=e.specifiers.concat(this.parseExportSpecifiers()))},z.parseExportFrom=function(e,t){this.eatContextual("from")?(e.source=this.match(R.string)?this.parseExprAtom():this.unexpected(),this.checkExport(e)):t?this.unexpected():e.source=null,this.semicolon()},z.shouldParseExportDeclaration=function(){return"var"===this.state.type.keyword||"const"===this.state.type.keyword||"let"===this.state.type.keyword||"function"===this.state.type.keyword||"class"===this.state.type.keyword||this.isContextual("async")},z.checkExport=function(e,t,r){if(t)if(r)this.checkDuplicateExports(e,"default");else if(e.specifiers&&e.specifiers.length)for(var n=e.specifiers,i=Array.isArray(n),s=0,n=i?n:n[Symbol.iterator]();;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;this.checkDuplicateExports(o,o.exported.name)}else if(e.declaration)if("FunctionDeclaration"===e.declaration.type||"ClassDeclaration"===e.declaration.type)this.checkDuplicateExports(e,e.declaration.id.name);else if("VariableDeclaration"===e.declaration.type)for(var u=e.declaration.declarations,l=Array.isArray(u),c=0,u=l?u:u[Symbol.iterator]();;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;this.checkDeclaration(p.id)}if(this.state.decorators.length){var d=e.declaration&&("ClassDeclaration"===e.declaration.type||"ClassExpression"===e.declaration.type);e.declaration&&d||this.raise(e.start,"You can only use decorators on an export when exporting a class"),this.takeDecorators(e.declaration)}},z.checkDeclaration=function(e){if("ObjectPattern"===e.type)for(var t=e.properties,r=Array.isArray(t),n=0,t=r?t:t[Symbol.iterator]();;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;this.checkDeclaration(s)}else if("ArrayPattern"===e.type)for(var a=e.elements,o=Array.isArray(a),u=0,a=o?a:a[Symbol.iterator]();;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;c&&this.checkDeclaration(c)}else"ObjectProperty"===e.type?this.checkDeclaration(e.value):"RestElement"===e.type||"RestProperty"===e.type?this.checkDeclaration(e.argument):"Identifier"===e.type&&this.checkDuplicateExports(e,e.name)},z.checkDuplicateExports=function(e,t){this.state.exportedIdentifiers.indexOf(t)>-1&&this.raiseDuplicateExportError(e,t),this.state.exportedIdentifiers.push(t)},z.raiseDuplicateExportError=function(e,t){this.raise(e.start,"default"===t?"Only one default export allowed per module.":"`"+t+"` has already been exported. Exported identifiers must be unique.")},z.parseExportSpecifiers=function(){var e=[],t=!0,r=void 0;for(this.expect(R.braceL);!this.eat(R.braceR);){if(t)t=!1;else if(this.expect(R.comma),this.eat(R.braceR))break;var n=this.match(R._default);n&&!r&&(r=!0);var i=this.startNode();i.local=this.parseIdentifier(n),i.exported=this.eatContextual("as")?this.parseIdentifier(!0):i.local.__clone(),e.push(this.finishNode(i,"ExportSpecifier"))}return r&&!this.isContextual("from")&&this.unexpected(),e},z.parseImport=function(e){return this.eat(R._import),this.match(R.string)?(e.specifiers=[],e.source=this.parseExprAtom()):(e.specifiers=[],this.parseImportSpecifiers(e),this.expectContextual("from"),e.source=this.match(R.string)?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(e,"ImportDeclaration")},z.parseImportSpecifiers=function(e){var t=!0;if(this.match(R.name)){var r=this.state.start,n=this.state.startLoc;if(e.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(),r,n)),!this.eat(R.comma))return}if(this.match(R.star)){var i=this.startNode();return this.next(),this.expectContextual("as"),i.local=this.parseIdentifier(),this.checkLVal(i.local,!0,void 0,"import namespace specifier"),void e.specifiers.push(this.finishNode(i,"ImportNamespaceSpecifier"))}for(this.expect(R.braceL);!this.eat(R.braceR);){if(t)t=!1;else if(this.eat(R.colon)&&this.unexpected(null,"ES2015 named imports do not destructure. Use another statement for destructuring after the import."),this.expect(R.comma),this.eat(R.braceR))break;this.parseImportSpecifier(e)}},z.parseImportSpecifier=function(e){var t=this.startNode();t.imported=this.parseIdentifier(!0),this.eatContextual("as")?t.local=this.parseIdentifier():(this.checkReservedWord(t.imported.name,t.start,!0,!0),t.local=t.imported.__clone()),this.checkLVal(t.local,!0,void 0,"import specifier"),e.specifiers.push(this.finishNode(t,"ImportSpecifier"))},z.parseImportSpecifierDefault=function(e,t,r){var n=this.startNodeAt(t,r);return n.local=e,this.checkLVal(n.local,!0,void 0,"default import specifier"),this.finishNode(n,"ImportDefaultSpecifier")};var ee=J.prototype;ee.toAssignable=function(e,t,r){if(e)switch(e.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":break;case"ObjectExpression":e.type="ObjectPattern";for(var n=e.properties,i=Array.isArray(n),s=0,n=i?n:n[Symbol.iterator]();;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;"ObjectMethod"===o.type?"get"===o.kind||"set"===o.kind?this.raise(o.key.start,"Object pattern can't contain getter or setter"):this.raise(o.key.start,"Object pattern can't contain methods"):this.toAssignable(o,t,"object destructuring pattern")}break;case"ObjectProperty":this.toAssignable(e.value,t,r);break;case"SpreadProperty":e.type="RestProperty";var u=e.argument;this.toAssignable(u,t,r);break;case"ArrayExpression":e.type="ArrayPattern",this.toAssignableList(e.elements,t,r);break;case"AssignmentExpression":"="===e.operator?(e.type="AssignmentPattern",delete e.operator):this.raise(e.left.end,"Only '=' operator can be used for specifying default value.");break;case"MemberExpression":if(!t)break;default:var l="Invalid left-hand side"+(r?" in "+r:"expression");this.raise(e.start,l)}return e},ee.toAssignableList=function(e,t,r){var n=e.length;if(n){var i=e[n-1];if(i&&"RestElement"===i.type)--n;else if(i&&"SpreadElement"===i.type){i.type="RestElement";var s=i.argument;this.toAssignable(s,t,r),"Identifier"!==s.type&&"MemberExpression"!==s.type&&"ArrayPattern"!==s.type&&this.unexpected(s.start),--n}}for(var a=0;a<n;a++){var o=e[a];o&&this.toAssignable(o,t,r)}return e},ee.toReferencedList=function(e){return e},ee.parseSpread=function(e){var t=this.startNode();return this.next(),t.argument=this.parseMaybeAssign(!1,e),this.finishNode(t,"SpreadElement")},ee.parseRest=function(){var e=this.startNode();return this.next(),e.argument=this.parseBindingIdentifier(),this.finishNode(e,"RestElement")},ee.shouldAllowYieldIdentifier=function(){return this.match(R._yield)&&!this.state.strict&&!this.state.inGenerator},ee.parseBindingIdentifier=function(){return this.parseIdentifier(this.shouldAllowYieldIdentifier())},ee.parseBindingAtom=function(){switch(this.state.type){case R._yield:(this.state.strict||this.state.inGenerator)&&this.unexpected();case R.name:return this.parseIdentifier(!0);case R.bracketL:var e=this.startNode();return this.next(),e.elements=this.parseBindingList(R.bracketR,!0),this.finishNode(e,"ArrayPattern");case R.braceL:return this.parseObj(!0);default:this.unexpected()}},ee.parseBindingList=function(e,t){for(var r=[],n=!0;!this.eat(e);)if(n?n=!1:this.expect(R.comma),t&&this.match(R.comma))r.push(null);else{if(this.eat(e))break;if(this.match(R.ellipsis)){r.push(this.parseAssignableListItemTypes(this.parseRest())),this.expect(e);break}for(var i=[];this.match(R.at);)i.push(this.parseDecorator());var s=this.parseMaybeDefault();i.length&&(s.decorators=i),this.parseAssignableListItemTypes(s),r.push(this.parseMaybeDefault(s.start,s.loc.start,s))}return r},ee.parseAssignableListItemTypes=function(e){return e},ee.parseMaybeDefault=function(e,t,r){if(t=t||this.state.startLoc,e=e||this.state.start,r=r||this.parseBindingAtom(),!this.eat(R.eq))return r;var n=this.startNodeAt(e,t);return n.left=r,n.right=this.parseMaybeAssign(),this.finishNode(n,"AssignmentPattern")},ee.checkLVal=function(e,t,r,n){switch(e.type){case"Identifier":if(this.checkReservedWord(e.name,e.start,!1,!0),r){var i="_"+e.name;r[i]?this.raise(e.start,"Argument name clash in strict mode"):r[i]=!0}break;case"MemberExpression":t&&this.raise(e.start,(t?"Binding":"Assigning to")+" member expression");break;case"ObjectPattern":for(var s=e.properties,a=Array.isArray(s),o=0,s=a?s:s[Symbol.iterator]();;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u;"ObjectProperty"===l.type&&(l=l.value),this.checkLVal(l,t,r,"object destructuring pattern")}break;case"ArrayPattern":for(var c=e.elements,f=Array.isArray(c),p=0,c=f?c:c[Symbol.iterator]();;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d;h&&this.checkLVal(h,t,r,"array destructuring pattern")}break;case"AssignmentPattern":this.checkLVal(e.left,t,r,"assignment pattern");break;case"RestProperty":this.checkLVal(e.argument,t,r,"rest property");break;case"RestElement":this.checkLVal(e.argument,t,r,"rest element");break;default:var m=(t?"Binding invalid":"Invalid")+" left-hand side"+(n?" in "+n:"expression");this.raise(e.start,m)}};var te=J.prototype;te.checkPropClash=function(e,t){if(!e.computed&&!e.kind){var r=e.key;"__proto__"===("Identifier"===r.type?r.name:String(r.value))&&(t.proto&&this.raise(r.start,"Redefinition of __proto__ property"),t.proto=!0)}},te.getExpression=function(){this.nextToken();var e=this.parseExpression();return this.match(R.eof)||this.unexpected(),e},te.parseExpression=function(e,t){var r=this.state.start,n=this.state.startLoc,i=this.parseMaybeAssign(e,t);if(this.match(R.comma)){var s=this.startNodeAt(r,n);for(s.expressions=[i];this.eat(R.comma);)s.expressions.push(this.parseMaybeAssign(e,t));return this.toReferencedList(s.expressions),this.finishNode(s,"SequenceExpression")}return i},te.parseMaybeAssign=function(e,t,r,n){var i=this.state.start,s=this.state.startLoc;if(this.match(R._yield)&&this.state.inGenerator){var a=this.parseYield();return r&&(a=r.call(this,a,i,s)),a}var o=void 0;t?o=!1:(t={start:0},o=!0),(this.match(R.parenL)||this.match(R.name))&&(this.state.potentialArrowAt=this.state.start);var u=this.parseMaybeConditional(e,t,n);if(r&&(u=r.call(this,u,i,s)),this.state.type.isAssign){var l=this.startNodeAt(i,s);if(l.operator=this.state.value,l.left=this.match(R.eq)?this.toAssignable(u,void 0,"assignment expression"):u,t.start=0,this.checkLVal(u,void 0,void 0,"assignment expression"),u.extra&&u.extra.parenthesized){var c=void 0;"ObjectPattern"===u.type?c="`({a}) = 0` use `({a} = 0)`":"ArrayPattern"===u.type&&(c="`([a]) = 0` use `([a] = 0)`"),c&&this.raise(u.start,"You're trying to assign to a parenthesized expression, eg. instead of "+c)}return this.next(),l.right=this.parseMaybeAssign(e),this.finishNode(l,"AssignmentExpression")}return o&&t.start&&this.unexpected(t.start),u},te.parseMaybeConditional=function(e,t,r){var n=this.state.start,i=this.state.startLoc,s=this.parseExprOps(e,t);return t&&t.start?s:this.parseConditional(s,e,n,i,r)},te.parseConditional=function(e,t,r,n){if(this.eat(R.question)){var i=this.startNodeAt(r,n);return i.test=e,i.consequent=this.parseMaybeAssign(),this.expect(R.colon),i.alternate=this.parseMaybeAssign(t),this.finishNode(i,"ConditionalExpression")}return e},te.parseExprOps=function(e,t){var r=this.state.start,n=this.state.startLoc,i=this.parseMaybeUnary(t);return t&&t.start?i:this.parseExprOp(i,r,n,-1,e)},te.parseExprOp=function(e,t,r,n,i){var s=this.state.type.binop;if(!(null==s||i&&this.match(R._in))&&s>n){var a=this.startNodeAt(t,r);a.left=e,a.operator=this.state.value,"**"!==a.operator||"UnaryExpression"!==e.type||!e.extra||e.extra.parenthesizedArgument||e.extra.parenthesized||this.raise(e.argument.start,"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");var o=this.state.type;this.next();var u=this.state.start,l=this.state.startLoc;return a.right=this.parseExprOp(this.parseMaybeUnary(),u,l,o.rightAssociative?s-1:s,i),this.finishNode(a,o===R.logicalOR||o===R.logicalAND?"LogicalExpression":"BinaryExpression"),this.parseExprOp(a,t,r,n,i)}return e},te.parseMaybeUnary=function(e){if(this.state.type.prefix){var t=this.startNode(),r=this.match(R.incDec);t.operator=this.state.value,t.prefix=!0,this.next();var n=this.state.type;return t.argument=this.parseMaybeUnary(),this.addExtra(t,"parenthesizedArgument",!(n!==R.parenL||t.argument.extra&&t.argument.extra.parenthesized)),e&&e.start&&this.unexpected(e.start),r?this.checkLVal(t.argument,void 0,void 0,"prefix operation"):this.state.strict&&"delete"===t.operator&&"Identifier"===t.argument.type&&this.raise(t.start,"Deleting local variable in strict mode"),this.finishNode(t,r?"UpdateExpression":"UnaryExpression")}var i=this.state.start,s=this.state.startLoc,a=this.parseExprSubscripts(e);if(e&&e.start)return a;for(;this.state.type.postfix&&!this.canInsertSemicolon();){var o=this.startNodeAt(i,s);o.operator=this.state.value,o.prefix=!1,o.argument=a,this.checkLVal(a,void 0,void 0,"postfix operation"),this.next(),a=this.finishNode(o,"UpdateExpression")}return a},te.parseExprSubscripts=function(e){var t=this.state.start,r=this.state.startLoc,n=this.state.potentialArrowAt,i=this.parseExprAtom(e);return"ArrowFunctionExpression"===i.type&&i.start===n?i:e&&e.start?i:this.parseSubscripts(i,t,r)},te.parseSubscripts=function(e,t,r,n){for(;;){if(!n&&this.eat(R.doubleColon)){var i=this.startNodeAt(t,r);return i.object=e,i.callee=this.parseNoCallExpr(),this.parseSubscripts(this.finishNode(i,"BindExpression"),t,r,n)}if(this.eat(R.dot)){var s=this.startNodeAt(t,r);s.object=e,s.property=this.parseIdentifier(!0),s.computed=!1,e=this.finishNode(s,"MemberExpression")}else if(this.eat(R.bracketL)){var a=this.startNodeAt(t,r);a.object=e,a.property=this.parseExpression(),a.computed=!0,this.expect(R.bracketR),e=this.finishNode(a,"MemberExpression")}else if(!n&&this.match(R.parenL)){var o=this.state.potentialArrowAt===e.start&&"Identifier"===e.type&&"async"===e.name&&!this.canInsertSemicolon();this.next();var u=this.startNodeAt(t,r);if(u.callee=e,u.arguments=this.parseCallExpressionArguments(R.parenR,o),"Import"===u.callee.type&&1!==u.arguments.length&&this.raise(u.start,"import() requires exactly one argument"),e=this.finishNode(u,"CallExpression"),o&&this.shouldParseAsyncArrow())return this.parseAsyncArrowFromCallExpression(this.startNodeAt(t,r),u);this.toReferencedList(u.arguments)}else{if(!this.match(R.backQuote))return e;var l=this.startNodeAt(t,r);l.tag=e,l.quasi=this.parseTemplate(!0),e=this.finishNode(l,"TaggedTemplateExpression")}}},te.parseCallExpressionArguments=function(e,t){for(var r=[],n=void 0,i=!0;!this.eat(e);){if(i)i=!1;else if(this.expect(R.comma),this.eat(e))break;this.match(R.parenL)&&!n&&(n=this.state.start),r.push(this.parseExprListItem(!1,t?{start:0}:void 0,t?{start:0}:void 0))}return t&&n&&this.shouldParseAsyncArrow()&&this.unexpected(),r},te.shouldParseAsyncArrow=function(){return this.match(R.arrow)},te.parseAsyncArrowFromCallExpression=function(e,t){return this.expect(R.arrow),this.parseArrowExpression(e,t.arguments,!0)},te.parseNoCallExpr=function(){var e=this.state.start,t=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),e,t,!0)},te.parseExprAtom=function(e){var t=this.state.potentialArrowAt===this.state.start,r=void 0;switch(this.state.type){case R._super:return this.state.inMethod||this.state.inClassProperty||this.options.allowSuperOutsideMethod||this.raise(this.state.start,"'super' outside of function or class"),r=this.startNode(),this.next(),this.match(R.parenL)||this.match(R.bracketL)||this.match(R.dot)||this.unexpected(),this.match(R.parenL)&&"constructor"!==this.state.inMethod&&!this.options.allowSuperOutsideMethod&&this.raise(r.start,"super() outside of class constructor"),this.finishNode(r,"Super");case R._import:return this.hasPlugin("dynamicImport")||this.unexpected(),r=this.startNode(),this.next(),this.match(R.parenL)||this.unexpected(null,R.parenL),this.finishNode(r,"Import");case R._this:return r=this.startNode(),this.next(),this.finishNode(r,"ThisExpression");case R._yield:this.state.inGenerator&&this.unexpected();case R.name:r=this.startNode();var n="await"===this.state.value&&this.state.inAsync,i=this.shouldAllowYieldIdentifier(),s=this.parseIdentifier(n||i);if("await"===s.name){if(this.state.inAsync||this.inModule)return this.parseAwait(r)}else{if("async"===s.name&&this.match(R._function)&&!this.canInsertSemicolon())return this.next(),this.parseFunction(r,!1,!1,!0);if(t&&"async"===s.name&&this.match(R.name)){var a=[this.parseIdentifier()];return this.expect(R.arrow),this.parseArrowExpression(r,a,!0)}}return t&&!this.canInsertSemicolon()&&this.eat(R.arrow)?this.parseArrowExpression(r,[s]):s;case R._do:if(this.hasPlugin("doExpressions")){var o=this.startNode();this.next();var u=this.state.inFunction,l=this.state.labels;return this.state.labels=[],this.state.inFunction=!1,o.body=this.parseBlock(!1,!0),this.state.inFunction=u,this.state.labels=l,this.finishNode(o,"DoExpression")}case R.regexp:var c=this.state.value;return r=this.parseLiteral(c.value,"RegExpLiteral"),r.pattern=c.pattern,r.flags=c.flags,r;case R.num:return this.parseLiteral(this.state.value,"NumericLiteral");case R.string:return this.parseLiteral(this.state.value,"StringLiteral");case R._null:return r=this.startNode(),this.next(),this.finishNode(r,"NullLiteral");case R._true:case R._false:return r=this.startNode(),r.value=this.match(R._true),this.next(),this.finishNode(r,"BooleanLiteral");case R.parenL:return this.parseParenAndDistinguishExpression(null,null,t);case R.bracketL:return r=this.startNode(),this.next(),r.elements=this.parseExprList(R.bracketR,!0,e),this.toReferencedList(r.elements),this.finishNode(r,"ArrayExpression");case R.braceL:return this.parseObj(!1,e);case R._function:return this.parseFunctionExpression();case R.at:this.parseDecorators();case R._class:return r=this.startNode(),this.takeDecorators(r),this.parseClass(r,!1);case R._new:return this.parseNew();case R.backQuote:return this.parseTemplate(!1);case R.doubleColon:r=this.startNode(),this.next(),r.object=null;var f=r.callee=this.parseNoCallExpr();if("MemberExpression"===f.type)return this.finishNode(r,"BindExpression");this.raise(f.start,"Binding should be performed on object property.");default:this.unexpected()}},te.parseFunctionExpression=function(){var e=this.startNode(),t=this.parseIdentifier(!0);return this.state.inGenerator&&this.eat(R.dot)&&this.hasPlugin("functionSent")?this.parseMetaProperty(e,t,"sent"):this.parseFunction(e,!1)},te.parseMetaProperty=function(e,t,r){return e.meta=t,e.property=this.parseIdentifier(!0),e.property.name!==r&&this.raise(e.property.start,"The only valid meta property for new is "+t.name+"."+r),this.finishNode(e,"MetaProperty")},te.parseLiteral=function(e,t,r,n){r=r||this.state.start,n=n||this.state.startLoc;var i=this.startNodeAt(r,n);return this.addExtra(i,"rawValue",e),this.addExtra(i,"raw",this.input.slice(r,this.state.end)),i.value=e,this.next(),this.finishNode(i,t)},te.parseParenExpression=function(){this.expect(R.parenL);var e=this.parseExpression();return this.expect(R.parenR),e},te.parseParenAndDistinguishExpression=function(e,t,r){e=e||this.state.start,t=t||this.state.startLoc;var n=void 0;this.expect(R.parenL);for(var i=this.state.start,s=this.state.startLoc,a=[],o={start:0},u={start:0},l=!0,c=void 0,f=void 0;!this.match(R.parenR);){if(l)l=!1;else if(this.expect(R.comma,u.start||null),this.match(R.parenR)){f=this.state.start;break}
if(this.match(R.ellipsis)){var p=this.state.start,d=this.state.startLoc;c=this.state.start,a.push(this.parseParenItem(this.parseRest(),p,d));break}a.push(this.parseMaybeAssign(!1,o,this.parseParenItem,u))}var h=this.state.start,m=this.state.startLoc;this.expect(R.parenR);var y=this.startNodeAt(e,t);if(r&&this.shouldParseArrow()&&(y=this.parseArrow(y))){for(var v=a,g=Array.isArray(v),b=0,v=g?v:v[Symbol.iterator]();;){var E;if(g){if(b>=v.length)break;E=v[b++]}else{if(b=v.next(),b.done)break;E=b.value}var x=E;x.extra&&x.extra.parenthesized&&this.unexpected(x.extra.parenStart)}return this.parseArrowExpression(y,a)}return a.length||this.unexpected(this.state.lastTokStart),f&&this.unexpected(f),c&&this.unexpected(c),o.start&&this.unexpected(o.start),u.start&&this.unexpected(u.start),a.length>1?(n=this.startNodeAt(i,s),n.expressions=a,this.toReferencedList(n.expressions),this.finishNodeAt(n,"SequenceExpression",h,m)):n=a[0],this.addExtra(n,"parenthesized",!0),this.addExtra(n,"parenStart",e),n},te.shouldParseArrow=function(){return!this.canInsertSemicolon()},te.parseArrow=function(e){if(this.eat(R.arrow))return e},te.parseParenItem=function(e){return e},te.parseNew=function(){var e=this.startNode(),t=this.parseIdentifier(!0);if(this.eat(R.dot)){var r=this.parseMetaProperty(e,t,"target");return this.state.inFunction||this.raise(r.property.start,"new.target can only be used in functions"),r}return e.callee=this.parseNoCallExpr(),this.eat(R.parenL)?(e.arguments=this.parseExprList(R.parenR),this.toReferencedList(e.arguments)):e.arguments=[],this.finishNode(e,"NewExpression")},te.parseTemplateElement=function(e){var t=this.startNode();return null===this.state.value&&(e&&this.hasPlugin("templateInvalidEscapes")?this.state.invalidTemplateEscapePosition=null:this.raise(this.state.invalidTemplateEscapePosition,"Invalid escape sequence in template")),t.value={raw:this.input.slice(this.state.start,this.state.end).replace(/\r\n?/g,"\n"),cooked:this.state.value},this.next(),t.tail=this.match(R.backQuote),this.finishNode(t,"TemplateElement")},te.parseTemplate=function(e){var t=this.startNode();this.next(),t.expressions=[];var r=this.parseTemplateElement(e);for(t.quasis=[r];!r.tail;)this.expect(R.dollarBraceL),t.expressions.push(this.parseExpression()),this.expect(R.braceR),t.quasis.push(r=this.parseTemplateElement(e));return this.next(),this.finishNode(t,"TemplateLiteral")},te.parseObj=function(e,t){var r=[],n=Object.create(null),i=!0,s=this.startNode();s.properties=[],this.next();for(var a=null;!this.eat(R.braceR);){if(i)i=!1;else if(this.expect(R.comma),this.eat(R.braceR))break;for(;this.match(R.at);)r.push(this.parseDecorator());var o=this.startNode(),u=!1,l=!1,c=void 0,f=void 0;if(r.length&&(o.decorators=r,r=[]),this.hasPlugin("objectRestSpread")&&this.match(R.ellipsis)){if(o=this.parseSpread(e?{start:0}:void 0),o.type=e?"RestProperty":"SpreadProperty",e&&this.toAssignable(o.argument,!0,"object pattern"),s.properties.push(o),!e)continue;var p=this.state.start;if(null===a){if(this.eat(R.braceR))break;if(this.match(R.comma)&&this.lookahead().type===R.braceR)continue;a=p;continue}this.unexpected(a,"Cannot have multiple rest elements when destructuring")}if(o.method=!1,o.shorthand=!1,(e||t)&&(c=this.state.start,f=this.state.startLoc),e||(u=this.eat(R.star)),!e&&this.isContextual("async")){u&&this.unexpected();var d=this.parseIdentifier();this.match(R.colon)||this.match(R.parenL)||this.match(R.braceR)||this.match(R.eq)||this.match(R.comma)?(o.key=d,o.computed=!1):(l=!0,this.hasPlugin("asyncGenerators")&&(u=this.eat(R.star)),this.parsePropertyName(o))}else this.parsePropertyName(o);this.parseObjPropValue(o,c,f,u,l,e,t),this.checkPropClash(o,n),o.shorthand&&this.addExtra(o,"shorthand",!0),s.properties.push(o)}return null!==a&&this.unexpected(a,"The rest element has to be the last element when destructuring"),r.length&&this.raise(this.state.start,"You have trailing decorators with no property"),this.finishNode(s,e?"ObjectPattern":"ObjectExpression")},te.isGetterOrSetterMethod=function(e,t){return!t&&!e.computed&&"Identifier"===e.key.type&&("get"===e.key.name||"set"===e.key.name)&&(this.match(R.string)||this.match(R.num)||this.match(R.bracketL)||this.match(R.name)||this.state.type.keyword)},te.checkGetterSetterParamCount=function(e){var t="get"===e.kind?0:1;if(e.params.length!==t){var r=e.start;"get"===e.kind?this.raise(r,"getter should have no params"):this.raise(r,"setter should have exactly one param")}},te.parseObjectMethod=function(e,t,r,n){return r||t||this.match(R.parenL)?(n&&this.unexpected(),e.kind="method",e.method=!0,this.parseMethod(e,t,r),this.finishNode(e,"ObjectMethod")):this.isGetterOrSetterMethod(e,n)?((t||r)&&this.unexpected(),e.kind=e.key.name,this.parsePropertyName(e),this.parseMethod(e),this.checkGetterSetterParamCount(e),this.finishNode(e,"ObjectMethod")):void 0},te.parseObjectProperty=function(e,t,r,n,i){return this.eat(R.colon)?(e.value=n?this.parseMaybeDefault(this.state.start,this.state.startLoc):this.parseMaybeAssign(!1,i),this.finishNode(e,"ObjectProperty")):e.computed||"Identifier"!==e.key.type?void 0:(this.checkReservedWord(e.key.name,e.key.start,!0,!0),n?e.value=this.parseMaybeDefault(t,r,e.key.__clone()):this.match(R.eq)&&i?(i.start||(i.start=this.state.start),e.value=this.parseMaybeDefault(t,r,e.key.__clone())):e.value=e.key.__clone(),e.shorthand=!0,this.finishNode(e,"ObjectProperty"))},te.parseObjPropValue=function(e,t,r,n,i,s,a){var o=this.parseObjectMethod(e,n,i,s)||this.parseObjectProperty(e,t,r,s,a);return o||this.unexpected(),o},te.parsePropertyName=function(e){if(this.eat(R.bracketL))e.computed=!0,e.key=this.parseMaybeAssign(),this.expect(R.bracketR);else{e.computed=!1;var t=this.state.inPropertyName;this.state.inPropertyName=!0,e.key=this.match(R.num)||this.match(R.string)?this.parseExprAtom():this.parseIdentifier(!0),this.state.inPropertyName=t}return e.key},te.initFunction=function(e,t){e.id=null,e.generator=!1,e.expression=!1,e.async=!!t},te.parseMethod=function(e,t,r){var n=this.state.inMethod;return this.state.inMethod=e.kind||!0,this.initFunction(e,r),this.expect(R.parenL),e.params=this.parseBindingList(R.parenR),e.generator=!!t,this.parseFunctionBody(e),this.state.inMethod=n,e},te.parseArrowExpression=function(e,t,r){return this.initFunction(e,r),e.params=this.toAssignableList(t,!0,"arrow function parameters"),this.parseFunctionBody(e,!0),this.finishNode(e,"ArrowFunctionExpression")},te.isStrictBody=function(e,t){if(!t&&e.body.directives.length)for(var r=e.body.directives,n=Array.isArray(r),i=0,r=n?r:r[Symbol.iterator]();;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;if("use strict"===a.value.value)return!0}return!1},te.parseFunctionBody=function(e,t){var r=t&&!this.match(R.braceL),n=this.state.inAsync;if(this.state.inAsync=e.async,r)e.body=this.parseMaybeAssign(),e.expression=!0;else{var i=this.state.inFunction,s=this.state.inGenerator,a=this.state.labels;this.state.inFunction=!0,this.state.inGenerator=e.generator,this.state.labels=[],e.body=this.parseBlock(!0),e.expression=!1,this.state.inFunction=i,this.state.inGenerator=s,this.state.labels=a}this.state.inAsync=n;var o=this.isStrictBody(e,r),u=this.state.strict||t||o;if(o&&e.id&&"Identifier"===e.id.type&&"yield"===e.id.name&&this.raise(e.id.start,"Binding yield in strict mode"),u){var l=Object.create(null),c=this.state.strict;o&&(this.state.strict=!0),e.id&&this.checkLVal(e.id,!0,void 0,"function name");for(var f=e.params,p=Array.isArray(f),d=0,f=p?f:f[Symbol.iterator]();;){var h;if(p){if(d>=f.length)break;h=f[d++]}else{if(d=f.next(),d.done)break;h=d.value}var m=h;o&&"Identifier"!==m.type&&this.raise(m.start,"Non-simple parameter in strict mode"),this.checkLVal(m,!0,l,"function parameter list")}this.state.strict=c}},te.parseExprList=function(e,t,r){for(var n=[],i=!0;!this.eat(e);){if(i)i=!1;else if(this.expect(R.comma),this.eat(e))break;n.push(this.parseExprListItem(t,r))}return n},te.parseExprListItem=function(e,t,r){return e&&this.match(R.comma)?null:this.match(R.ellipsis)?this.parseSpread(t):this.parseMaybeAssign(!1,t,this.parseParenItem,r)},te.parseIdentifier=function(e){var t=this.startNode();return e||this.checkReservedWord(this.state.value,this.state.start,!!this.state.type.keyword,!1),this.match(R.name)?t.name=this.state.value:this.state.type.keyword?t.name=this.state.type.keyword:this.unexpected(),!e&&"await"===t.name&&this.state.inAsync&&this.raise(t.start,"invalid use of await inside of an async function"),t.loc.identifierName=t.name,this.next(),this.finishNode(t,"Identifier")},te.checkReservedWord=function(e,t,r,n){(this.isReservedWord(e)||r&&this.isKeyword(e))&&this.raise(t,e+" is a reserved word"),this.state.strict&&(v.strict(e)||n&&v.strictBind(e))&&this.raise(t,e+" is a reserved word in strict mode")},te.parseAwait=function(e){return this.state.inAsync||this.unexpected(),this.match(R.star)&&this.raise(e.start,"await* has been removed from the async functions proposal. Use Promise.all() instead."),e.argument=this.parseMaybeUnary(),this.finishNode(e,"AwaitExpression")},te.parseYield=function(){var e=this.startNode();return this.next(),this.match(R.semi)||this.canInsertSemicolon()||!this.match(R.star)&&!this.state.type.startsExpr?(e.delegate=!1,e.argument=null):(e.delegate=this.eat(R.star),e.argument=this.parseMaybeAssign()),this.finishNode(e,"YieldExpression")};var re=J.prototype,ne=["leadingComments","trailingComments","innerComments"],ie=function(){function e(t,r,n){w(this,e),this.type="",this.start=t,this.end=0,this.loc=new G(r),n&&(this.loc.filename=n)}return e.prototype.__clone=function(){var t=new e;for(var r in this)ne.indexOf(r)<0&&(t[r]=this[r]);return t},e}();re.startNode=function(){return new ie(this.state.start,this.state.startLoc,this.filename)},re.startNodeAt=function(e,t){return new ie(e,t,this.filename)},re.finishNode=function(e,t){return c.call(this,e,t,this.state.lastTokEnd,this.state.lastTokEndLoc)},re.finishNodeAt=function(e,t,r,n){return c.call(this,e,t,r,n)},J.prototype.raise=function(e,t){var r=u(this.input,e);t+=" ("+r.line+":"+r.column+")";var n=new SyntaxError(t);throw n.pos=e,n.loc=r,n};var se=J.prototype;se.addComment=function(e){this.filename&&(e.loc.filename=this.filename),this.state.trailingComments.push(e),this.state.leadingComments.push(e)},se.processComment=function(e){if(!("Program"===e.type&&e.body.length>0)){var t=this.state.commentStack,r=void 0,n=void 0,i=void 0,s=void 0,a=void 0;if(this.state.trailingComments.length>0)this.state.trailingComments[0].start>=e.end?(i=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else{var o=f(t);t.length>0&&o.trailingComments&&o.trailingComments[0].start>=e.end&&(i=o.trailingComments,o.trailingComments=null)}for(t.length>0&&f(t).start>=e.start&&(r=t.pop());t.length>0&&f(t).start>=e.start;)n=t.pop();if(!n&&r&&(n=r),r&&this.state.leadingComments.length>0){var u=f(this.state.leadingComments);if("ObjectProperty"===r.type){if(u.start>=e.start&&this.state.commentPreviousNode){for(a=0;a<this.state.leadingComments.length;a++)this.state.leadingComments[a].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(a,1),a--);this.state.leadingComments.length>0&&(r.trailingComments=this.state.leadingComments,this.state.leadingComments=[])}}else if("CallExpression"===e.type&&e.arguments&&e.arguments.length){var l=f(e.arguments);l&&u.start>=l.start&&u.end<=e.end&&this.state.commentPreviousNode&&this.state.leadingComments.length>0&&(l.trailingComments=this.state.leadingComments,this.state.leadingComments=[])}}if(n){if(n.leadingComments)if(n!==e&&f(n.leadingComments).end<=e.start)e.leadingComments=n.leadingComments,n.leadingComments=null;else for(s=n.leadingComments.length-2;s>=0;--s)if(n.leadingComments[s].end<=e.start){e.leadingComments=n.leadingComments.splice(0,s+1);break}}else if(this.state.leadingComments.length>0)if(f(this.state.leadingComments).end<=e.start){if(this.state.commentPreviousNode)for(a=0;a<this.state.leadingComments.length;a++)this.state.leadingComments[a].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(a,1),a--);this.state.leadingComments.length>0&&(e.leadingComments=this.state.leadingComments,this.state.leadingComments=[])}else{for(s=0;s<this.state.leadingComments.length&&!(this.state.leadingComments[s].end>e.start);s++);e.leadingComments=this.state.leadingComments.slice(0,s),0===e.leadingComments.length&&(e.leadingComments=null),i=this.state.leadingComments.slice(s),0===i.length&&(i=null)}this.state.commentPreviousNode=e,i&&(i.length&&i[0].start>=e.start&&f(i).end<=e.end?e.innerComments=i:e.trailingComments=i),t.push(e)}};var ae=J.prototype;ae.estreeParseRegExpLiteral=function(e){var t=e.pattern,r=e.flags,n=null;try{n=new RegExp(t,r)}catch(e){}var i=this.estreeParseLiteral(n);return i.regex={pattern:t,flags:r},i},ae.estreeParseLiteral=function(e){return this.parseLiteral(e,"Literal")},ae.directiveToStmt=function(e){var t=e.value,r=this.startNodeAt(e.start,e.loc.start),n=this.startNodeAt(t.start,t.loc.start);return n.value=t.value,n.raw=t.extra.raw,r.expression=this.finishNodeAt(n,"Literal",t.end,t.loc.end),r.directive=t.extra.raw.slice(1,-1),this.finishNodeAt(r,"ExpressionStatement",e.end,e.loc.end)};var oe=function(e){e.extend("checkDeclaration",function(e){return function(t){p(t)?this.checkDeclaration(t.value):e.call(this,t)}}),e.extend("checkGetterSetterParamCount",function(){return function(e){var t="get"===e.kind?0:1;if(e.value.params.length!==t){var r=e.start;"get"===e.kind?this.raise(r,"getter should have no params"):this.raise(r,"setter should have exactly one param")}}}),e.extend("checkLVal",function(e){return function(t,r,n){var i=this;switch(t.type){case"ObjectPattern":t.properties.forEach(function(e){i.checkLVal("Property"===e.type?e.value:e,r,n,"object destructuring pattern")});break;default:for(var s=arguments.length,a=Array(s>3?s-3:0),o=3;o<s;o++)a[o-3]=arguments[o];e.call.apply(e,[this,t,r,n].concat(a))}}}),e.extend("checkPropClash",function(){return function(e,t){if(!e.computed&&p(e)){var r=e.key;"__proto__"===("Identifier"===r.type?r.name:String(r.value))&&(t.proto&&this.raise(r.start,"Redefinition of __proto__ property"),t.proto=!0)}}}),e.extend("isStrictBody",function(){return function(e,t){if(!t&&e.body.body.length>0)for(var r=e.body.body,n=Array.isArray(r),i=0,r=n?r:r[Symbol.iterator]();;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;if("ExpressionStatement"!==a.type||"Literal"!==a.expression.type)break;if("use strict"===a.expression.value)return!0}return!1}}),e.extend("isValidDirective",function(){return function(e){return!("ExpressionStatement"!==e.type||"Literal"!==e.expression.type||"string"!=typeof e.expression.value||e.expression.extra&&e.expression.extra.parenthesized)}}),e.extend("stmtToDirective",function(e){return function(t){var r=e.call(this,t),n=t.expression.value;return r.value.value=n,r}}),e.extend("parseBlockBody",function(e){return function(t){for(var r=this,n=arguments.length,i=Array(n>1?n-1:0),s=1;s<n;s++)i[s-1]=arguments[s];e.call.apply(e,[this,t].concat(i)),t.directives.reverse().forEach(function(e){t.body.unshift(r.directiveToStmt(e))}),delete t.directives}}),e.extend("parseClassMethod",function(){return function(e,t,r,n){this.parseMethod(t,r,n),t.typeParameters&&(t.value.typeParameters=t.typeParameters,delete t.typeParameters),e.body.push(this.finishNode(t,"MethodDefinition"))}}),e.extend("parseExprAtom",function(e){return function(){switch(this.state.type){case R.regexp:return this.estreeParseRegExpLiteral(this.state.value);case R.num:case R.string:return this.estreeParseLiteral(this.state.value);case R._null:return this.estreeParseLiteral(null);case R._true:return this.estreeParseLiteral(!0);case R._false:return this.estreeParseLiteral(!1);default:for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return e.call.apply(e,[this].concat(r))}}}),e.extend("parseLiteral",function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=e.call.apply(e,[this].concat(r));return i.raw=i.extra.raw,delete i.extra,i}}),e.extend("parseMethod",function(e){return function(t){var r=this.startNode();r.kind=t.kind;for(var n=arguments.length,i=Array(n>1?n-1:0),s=1;s<n;s++)i[s-1]=arguments[s];return r=e.call.apply(e,[this,r].concat(i)),delete r.kind,t.value=this.finishNode(r,"FunctionExpression"),t}}),e.extend("parseObjectMethod",function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=e.call.apply(e,[this].concat(r));return i&&("method"===i.kind&&(i.kind="init"),i.type="Property"),i}}),e.extend("parseObjectProperty",function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=e.call.apply(e,[this].concat(r));return i&&(i.kind="init",i.type="Property"),i}}),e.extend("toAssignable",function(e){return function(t,r){for(var n=arguments.length,i=Array(n>2?n-2:0),s=2;s<n;s++)i[s-2]=arguments[s];if(p(t))return this.toAssignable.apply(this,[t.value,r].concat(i)),t;if("ObjectExpression"===t.type){t.type="ObjectPattern";for(var a=t.properties,o=Array.isArray(a),u=0,a=o?a:a[Symbol.iterator]();;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;"get"===c.kind||"set"===c.kind?this.raise(c.key.start,"Object pattern can't contain getter or setter"):c.method?this.raise(c.key.start,"Object pattern can't contain methods"):this.toAssignable(c,r,"object destructuring pattern")}return t}return e.call.apply(e,[this,t,r].concat(i))}})},ue=["any","mixed","empty","bool","boolean","number","string","void","null"],le=J.prototype;le.flowParseTypeInitialiser=function(e){var t=this.state.inType;this.state.inType=!0,this.expect(e||R.colon);var r=this.flowParseType();return this.state.inType=t,r},le.flowParsePredicate=function(){var e=this.startNode(),t=this.state.startLoc,r=this.state.start;this.expect(R.modulo);var n=this.state.startLoc;return this.expectContextual("checks"),t.line===n.line&&t.column===n.column-1||this.raise(r,"Spaces between % and checks are not allowed here."),this.eat(R.parenL)?(e.expression=this.parseExpression(),this.expect(R.parenR),this.finishNode(e,"DeclaredPredicate")):this.finishNode(e,"InferredPredicate")},le.flowParseTypeAndPredicateInitialiser=function(){var e=this.state.inType;this.state.inType=!0,this.expect(R.colon);var t=null,r=null;return this.match(R.modulo)?(this.state.inType=e,r=this.flowParsePredicate()):(t=this.flowParseType(),this.state.inType=e,this.match(R.modulo)&&(r=this.flowParsePredicate())),[t,r]},le.flowParseDeclareClass=function(e){return this.next(),this.flowParseInterfaceish(e,!0),this.finishNode(e,"DeclareClass")},le.flowParseDeclareFunction=function(e){this.next();var t=e.id=this.parseIdentifier(),r=this.startNode(),n=this.startNode();this.isRelational("<")?r.typeParameters=this.flowParseTypeParameterDeclaration():r.typeParameters=null,this.expect(R.parenL);var i=this.flowParseFunctionTypeParams();r.params=i.params,r.rest=i.rest,this.expect(R.parenR);var s=null,a=this.flowParseTypeAndPredicateInitialiser();return r.returnType=a[0],s=a[1],n.typeAnnotation=this.finishNode(r,"FunctionTypeAnnotation"),n.predicate=s,t.typeAnnotation=this.finishNode(n,"TypeAnnotation"),this.finishNode(t,t.type),this.semicolon(),this.finishNode(e,"DeclareFunction")},le.flowParseDeclare=function(e){return this.match(R._class)?this.flowParseDeclareClass(e):this.match(R._function)?this.flowParseDeclareFunction(e):this.match(R._var)?this.flowParseDeclareVariable(e):this.isContextual("module")?this.lookahead().type===R.dot?this.flowParseDeclareModuleExports(e):this.flowParseDeclareModule(e):this.isContextual("type")?this.flowParseDeclareTypeAlias(e):this.isContextual("opaque")?this.flowParseDeclareOpaqueType(e):this.isContextual("interface")?this.flowParseDeclareInterface(e):this.match(R._export)?this.flowParseDeclareExportDeclaration(e):void this.unexpected()},le.flowParseDeclareExportDeclaration=function(e){if(this.expect(R._export),this.isContextual("opaque"))return e.declaration=this.flowParseDeclare(this.startNode()),e.default=!1,this.finishNode(e,"DeclareExportDeclaration");throw this.unexpected()},le.flowParseDeclareVariable=function(e){return this.next(),e.id=this.flowParseTypeAnnotatableIdentifier(),this.semicolon(),this.finishNode(e,"DeclareVariable")},le.flowParseDeclareModule=function(e){this.next(),this.match(R.string)?e.id=this.parseExprAtom():e.id=this.parseIdentifier();var t=e.body=this.startNode(),r=t.body=[];for(this.expect(R.braceL);!this.match(R.braceR);){var n=this.startNode();if(this.match(R._import)){var i=this.lookahead();"type"!==i.value&&"typeof"!==i.value&&this.unexpected(null,"Imports within a `declare module` body must always be `import type` or `import typeof`"),this.parseImport(n)}else this.expectContextual("declare","Only declares and type imports are allowed inside declare module"),n=this.flowParseDeclare(n,!0);r.push(n)}return this.expect(R.braceR),this.finishNode(t,"BlockStatement"),this.finishNode(e,"DeclareModule")},le.flowParseDeclareModuleExports=function(e){return this.expectContextual("module"),this.expect(R.dot),this.expectContextual("exports"),e.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(e,"DeclareModuleExports")},le.flowParseDeclareTypeAlias=function(e){return this.next(),this.flowParseTypeAlias(e),this.finishNode(e,"DeclareTypeAlias")},le.flowParseDeclareOpaqueType=function(e){return this.next(),this.flowParseOpaqueType(e,!0),this.finishNode(e,"DeclareOpaqueType")},le.flowParseDeclareInterface=function(e){return this.next(),this.flowParseInterfaceish(e),this.finishNode(e,"DeclareInterface")},le.flowParseInterfaceish=function(e){if(e.id=this.parseIdentifier(),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.extends=[],e.mixins=[],this.eat(R._extends))do{e.extends.push(this.flowParseInterfaceExtends())}while(this.eat(R.comma));if(this.isContextual("mixins")){this.next();do{e.mixins.push(this.flowParseInterfaceExtends())}while(this.eat(R.comma))}e.body=this.flowParseObjectType(!0,!1,!1)},le.flowParseInterfaceExtends=function(){var e=this.startNode();return e.id=this.flowParseQualifiedTypeIdentifier(),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterInstantiation():e.typeParameters=null,this.finishNode(e,"InterfaceExtends")},le.flowParseInterface=function(e){return this.flowParseInterfaceish(e,!1),this.finishNode(e,"InterfaceDeclaration")},le.flowParseRestrictedIdentifier=function(e){return ue.indexOf(this.state.value)>-1&&this.raise(this.state.start,"Cannot overwrite primitive type "+this.state.value),this.parseIdentifier(e)},le.flowParseTypeAlias=function(e){return e.id=this.flowParseRestrictedIdentifier(),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.right=this.flowParseTypeInitialiser(R.eq),this.semicolon(),this.finishNode(e,"TypeAlias")},le.flowParseOpaqueType=function(e,t){return this.expectContextual("type"),e.id=this.flowParseRestrictedIdentifier(),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.supertype=null,this.match(R.colon)&&(e.supertype=this.flowParseTypeInitialiser(R.colon)),e.impltype=null,t||(e.impltype=this.flowParseTypeInitialiser(R.eq)),this.semicolon(),this.finishNode(e,"OpaqueType")},le.flowParseTypeParameter=function(){var e=this.startNode(),t=this.flowParseVariance(),r=this.flowParseTypeAnnotatableIdentifier();return e.name=r.name,e.variance=t,e.bound=r.typeAnnotation,this.match(R.eq)&&(this.eat(R.eq),e.default=this.flowParseType()),this.finishNode(e,"TypeParameter")},le.flowParseTypeParameterDeclaration=function(){var e=this.state.inType,t=this.startNode();t.params=[],this.state.inType=!0,this.isRelational("<")||this.match(R.jsxTagStart)?this.next():this.unexpected();do{t.params.push(this.flowParseTypeParameter()),this.isRelational(">")||this.expect(R.comma)}while(!this.isRelational(">"));return this.expectRelational(">"),this.state.inType=e,this.finishNode(t,"TypeParameterDeclaration")},le.flowParseTypeParameterInstantiation=function(){var e=this.startNode(),t=this.state.inType;for(e.params=[],this.state.inType=!0,this.expectRelational("<");!this.isRelational(">");)e.params.push(this.flowParseType()),this.isRelational(">")||this.expect(R.comma);return this.expectRelational(">"),this.state.inType=t,this.finishNode(e,"TypeParameterInstantiation")},le.flowParseObjectPropertyKey=function(){return this.match(R.num)||this.match(R.string)?this.parseExprAtom():this.parseIdentifier(!0)},le.flowParseObjectTypeIndexer=function(e,t,r){return e.static=t,this.expect(R.bracketL),this.lookahead().type===R.colon?(e.id=this.flowParseObjectPropertyKey(),e.key=this.flowParseTypeInitialiser()):(e.id=null,e.key=this.flowParseType()),this.expect(R.bracketR),e.value=this.flowParseTypeInitialiser(),e.variance=r,this.flowObjectTypeSemicolon(),this.finishNode(e,"ObjectTypeIndexer")},le.flowParseObjectTypeMethodish=function(e){for(e.params=[],e.rest=null,e.typeParameters=null,this.isRelational("<")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(R.parenL);!this.match(R.parenR)&&!this.match(R.ellipsis);)e.params.push(this.flowParseFunctionTypeParam()),this.match(R.parenR)||this.expect(R.comma);return this.eat(R.ellipsis)&&(e.rest=this.flowParseFunctionTypeParam()),this.expect(R.parenR),e.returnType=this.flowParseTypeInitialiser(),this.finishNode(e,"FunctionTypeAnnotation")},le.flowParseObjectTypeMethod=function(e,t,r,n){var i=this.startNodeAt(e,t);return i.value=this.flowParseObjectTypeMethodish(this.startNodeAt(e,t)),i.static=r,i.key=n,i.optional=!1,this.flowObjectTypeSemicolon(),this.finishNode(i,"ObjectTypeProperty")},le.flowParseObjectTypeCallProperty=function(e,t){var r=this.startNode();return e.static=t,e.value=this.flowParseObjectTypeMethodish(r),this.flowObjectTypeSemicolon(),this.finishNode(e,"ObjectTypeCallProperty")},le.flowParseObjectType=function(e,t,r){var n=this.state.inType;this.state.inType=!0;var i=this.startNode(),s=void 0,a=void 0,o=!1;i.callProperties=[],i.properties=[],i.indexers=[];var u=void 0,l=void 0;for(t&&this.match(R.braceBarL)?(this.expect(R.braceBarL),u=R.braceBarR,l=!0):(this.expect(R.braceL),u=R.braceR,l=!1),i.exact=l;!this.match(u);){var c=!1,f=this.state.start,p=this.state.startLoc;s=this.startNode(),e&&this.isContextual("static")&&this.lookahead().type!==R.colon&&(this.next(),o=!0);var d=this.state.start,h=this.flowParseVariance();this.match(R.bracketL)?i.indexers.push(this.flowParseObjectTypeIndexer(s,o,h)):this.match(R.parenL)||this.isRelational("<")?(h&&this.unexpected(d),i.callProperties.push(this.flowParseObjectTypeCallProperty(s,o))):this.match(R.ellipsis)?(r||this.unexpected(null,"Spread operator cannot appear in class or interface definitions"),h&&this.unexpected(h.start,"Spread properties cannot have variance"),this.expect(R.ellipsis),s.argument=this.flowParseType(),this.flowObjectTypeSemicolon(),i.properties.push(this.finishNode(s,"ObjectTypeSpreadProperty"))):(a=this.flowParseObjectPropertyKey(),this.isRelational("<")||this.match(R.parenL)?(h&&this.unexpected(h.start),i.properties.push(this.flowParseObjectTypeMethod(f,p,o,a))):(this.eat(R.question)&&(c=!0),s.key=a,s.value=this.flowParseTypeInitialiser(),s.optional=c,s.static=o,s.variance=h,this.flowObjectTypeSemicolon(),i.properties.push(this.finishNode(s,"ObjectTypeProperty")))),o=!1}this.expect(u);var m=this.finishNode(i,"ObjectTypeAnnotation");return this.state.inType=n,m},le.flowObjectTypeSemicolon=function(){this.eat(R.semi)||this.eat(R.comma)||this.match(R.braceR)||this.match(R.braceBarR)||this.unexpected()},le.flowParseQualifiedTypeIdentifier=function(e,t,r){e=e||this.state.start,t=t||this.state.startLoc;for(var n=r||this.parseIdentifier();this.eat(R.dot);){var i=this.startNodeAt(e,t);i.qualification=n,i.id=this.parseIdentifier(),n=this.finishNode(i,"QualifiedTypeIdentifier")}return n},le.flowParseGenericType=function(e,t,r){var n=this.startNodeAt(e,t);return n.typeParameters=null,n.id=this.flowParseQualifiedTypeIdentifier(e,t,r),this.isRelational("<")&&(n.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(n,"GenericTypeAnnotation")},le.flowParseTypeofType=function(){var e=this.startNode();return this.expect(R._typeof),e.argument=this.flowParsePrimaryType(),this.finishNode(e,"TypeofTypeAnnotation")},le.flowParseTupleType=function(){var e=this.startNode();for(e.types=[],this.expect(R.bracketL);this.state.pos<this.input.length&&!this.match(R.bracketR)&&(e.types.push(this.flowParseType()),!this.match(R.bracketR));)this.expect(R.comma);return this.expect(R.bracketR),this.finishNode(e,"TupleTypeAnnotation")},le.flowParseFunctionTypeParam=function(){var e=null,t=!1,r=null,n=this.startNode(),i=this.lookahead();return i.type===R.colon||i.type===R.question?(e=this.parseIdentifier(),this.eat(R.question)&&(t=!0),r=this.flowParseTypeInitialiser()):r=this.flowParseType(),n.name=e,n.optional=t,n.typeAnnotation=r,this.finishNode(n,"FunctionTypeParam")},le.reinterpretTypeAsFunctionTypeParam=function(e){var t=this.startNodeAt(e.start,e.loc.start);return t.name=null,t.optional=!1,t.typeAnnotation=e,this.finishNode(t,"FunctionTypeParam")},le.flowParseFunctionTypeParams=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t={params:e,rest:null};!this.match(R.parenR)&&!this.match(R.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()),this.match(R.parenR)||this.expect(R.comma);return this.eat(R.ellipsis)&&(t.rest=this.flowParseFunctionTypeParam()),t},le.flowIdentToTypeAnnotation=function(e,t,r,n){switch(n.name){case"any":return this.finishNode(r,"AnyTypeAnnotation");case"void":return this.finishNode(r,"VoidTypeAnnotation");case"bool":case"boolean":return this.finishNode(r,"BooleanTypeAnnotation");case"mixed":return this.finishNode(r,"MixedTypeAnnotation");case"empty":return this.finishNode(r,"EmptyTypeAnnotation");case"number":return this.finishNode(r,"NumberTypeAnnotation");case"string":return this.finishNode(r,"StringTypeAnnotation");default:return this.flowParseGenericType(e,t,n)}},le.flowParsePrimaryType=function(){var e=this.state.start,t=this.state.startLoc,r=this.startNode(),n=void 0,i=void 0,s=!1,a=this.state.noAnonFunctionType;switch(this.state.type){case R.name:return this.flowIdentToTypeAnnotation(e,t,r,this.parseIdentifier());case R.braceL:return this.flowParseObjectType(!1,!1,!0);case R.braceBarL:return this.flowParseObjectType(!1,!0,!0);case R.bracketL:return this.flowParseTupleType();case R.relational:if("<"===this.state.value)return r.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(R.parenL),n=this.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,this.expect(R.parenR),this.expect(R.arrow),r.returnType=this.flowParseType(),this.finishNode(r,"FunctionTypeAnnotation");break;case R.parenL:if(this.next(),!this.match(R.parenR)&&!this.match(R.ellipsis))if(this.match(R.name)){var o=this.lookahead().type;s=o!==R.question&&o!==R.colon}else s=!0;if(s){if(this.state.noAnonFunctionType=!1,i=this.flowParseType(),this.state.noAnonFunctionType=a,this.state.noAnonFunctionType||!(this.match(R.comma)||this.match(R.parenR)&&this.lookahead().type===R.arrow))return this.expect(R.parenR),i;this.eat(R.comma)}return n=i?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i)]):this.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,this.expect(R.parenR),this.expect(R.arrow),r.returnType=this.flowParseType(),r.typeParameters=null,this.finishNode(r,"FunctionTypeAnnotation");case R.string:return this.parseLiteral(this.state.value,"StringLiteralTypeAnnotation");case R._true:case R._false:return r.value=this.match(R._true),this.next(),this.finishNode(r,"BooleanLiteralTypeAnnotation");case R.plusMin:if("-"===this.state.value)return this.next(),
this.match(R.num)||this.unexpected(null,"Unexpected token, expected number"),this.parseLiteral(-this.state.value,"NumericLiteralTypeAnnotation",r.start,r.loc.start);this.unexpected();case R.num:return this.parseLiteral(this.state.value,"NumericLiteralTypeAnnotation");case R._null:return r.value=this.match(R._null),this.next(),this.finishNode(r,"NullLiteralTypeAnnotation");case R._this:return r.value=this.match(R._this),this.next(),this.finishNode(r,"ThisTypeAnnotation");case R.star:return this.next(),this.finishNode(r,"ExistentialTypeParam");default:if("typeof"===this.state.type.keyword)return this.flowParseTypeofType()}this.unexpected()},le.flowParsePostfixType=function(){for(var e=this.state.start,t=this.state.startLoc,r=this.flowParsePrimaryType();!this.canInsertSemicolon()&&this.match(R.bracketL);){var n=this.startNodeAt(e,t);n.elementType=r,this.expect(R.bracketL),this.expect(R.bracketR),r=this.finishNode(n,"ArrayTypeAnnotation")}return r},le.flowParsePrefixType=function(){var e=this.startNode();return this.eat(R.question)?(e.typeAnnotation=this.flowParsePrefixType(),this.finishNode(e,"NullableTypeAnnotation")):this.flowParsePostfixType()},le.flowParseAnonFunctionWithoutParens=function(){var e=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(R.arrow)){var t=this.startNodeAt(e.start,e.loc.start);return t.params=[this.reinterpretTypeAsFunctionTypeParam(e)],t.rest=null,t.returnType=this.flowParseType(),t.typeParameters=null,this.finishNode(t,"FunctionTypeAnnotation")}return e},le.flowParseIntersectionType=function(){var e=this.startNode();this.eat(R.bitwiseAND);var t=this.flowParseAnonFunctionWithoutParens();for(e.types=[t];this.eat(R.bitwiseAND);)e.types.push(this.flowParseAnonFunctionWithoutParens());return 1===e.types.length?t:this.finishNode(e,"IntersectionTypeAnnotation")},le.flowParseUnionType=function(){var e=this.startNode();this.eat(R.bitwiseOR);var t=this.flowParseIntersectionType();for(e.types=[t];this.eat(R.bitwiseOR);)e.types.push(this.flowParseIntersectionType());return 1===e.types.length?t:this.finishNode(e,"UnionTypeAnnotation")},le.flowParseType=function(){var e=this.state.inType;this.state.inType=!0;var t=this.flowParseUnionType();return this.state.inType=e,t},le.flowParseTypeAnnotation=function(){var e=this.startNode();return e.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(e,"TypeAnnotation")},le.flowParseTypeAndPredicateAnnotation=function(){var e=this.startNode(),t=this.flowParseTypeAndPredicateInitialiser();return e.typeAnnotation=t[0],e.predicate=t[1],this.finishNode(e,"TypeAnnotation")},le.flowParseTypeAnnotatableIdentifier=function(){var e=this.flowParseRestrictedIdentifier();return this.match(R.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(e,e.type)),e},le.typeCastToParameter=function(e){return e.expression.typeAnnotation=e.typeAnnotation,this.finishNodeAt(e.expression,e.expression.type,e.typeAnnotation.end,e.typeAnnotation.loc.end)},le.flowParseVariance=function(){var e=null;return this.match(R.plusMin)&&("+"===this.state.value?e="plus":"-"===this.state.value&&(e="minus"),this.next()),e};var ce=function(e){e.extend("parseFunctionBody",function(e){return function(t,r){return this.match(R.colon)&&!r&&(t.returnType=this.flowParseTypeAndPredicateAnnotation()),e.call(this,t,r)}}),e.extend("parseStatement",function(e){return function(t,r){if(this.state.strict&&this.match(R.name)&&"interface"===this.state.value){var n=this.startNode();return this.next(),this.flowParseInterface(n)}return e.call(this,t,r)}}),e.extend("parseExpressionStatement",function(e){return function(t,r){if("Identifier"===r.type)if("declare"===r.name){if(this.match(R._class)||this.match(R.name)||this.match(R._function)||this.match(R._var)||this.match(R._export))return this.flowParseDeclare(t)}else if(this.match(R.name)){if("interface"===r.name)return this.flowParseInterface(t);if("type"===r.name)return this.flowParseTypeAlias(t);if("opaque"===r.name)return this.flowParseOpaqueType(t,!1)}return e.call(this,t,r)}}),e.extend("shouldParseExportDeclaration",function(e){return function(){return this.isContextual("type")||this.isContextual("interface")||this.isContextual("opaque")||e.call(this)}}),e.extend("isExportDefaultSpecifier",function(e){return function(){return(!this.match(R.name)||"type"!==this.state.value&&"interface"!==this.state.value&&"opaque"!==this.state.value)&&e.call(this)}}),e.extend("parseConditional",function(e){return function(t,r,n,i,s){if(s&&this.match(R.question)){var a=this.state.clone();try{return e.call(this,t,r,n,i)}catch(e){if(e instanceof SyntaxError)return this.state=a,s.start=e.pos||this.state.start,t;throw e}}return e.call(this,t,r,n,i)}}),e.extend("parseParenItem",function(e){return function(t,r,n){if(t=e.call(this,t,r,n),this.eat(R.question)&&(t.optional=!0),this.match(R.colon)){var i=this.startNodeAt(r,n);return i.expression=t,i.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(i,"TypeCastExpression")}return t}}),e.extend("parseExport",function(e){return function(t){return t=e.call(this,t),"ExportNamedDeclaration"===t.type&&(t.exportKind=t.exportKind||"value"),t}}),e.extend("parseExportDeclaration",function(e){return function(t){if(this.isContextual("type")){t.exportKind="type";var r=this.startNode();return this.next(),this.match(R.braceL)?(t.specifiers=this.parseExportSpecifiers(),this.parseExportFrom(t),null):this.flowParseTypeAlias(r)}if(this.isContextual("opaque")){t.exportKind="type";var n=this.startNode();return this.next(),this.flowParseOpaqueType(n,!1)}if(this.isContextual("interface")){t.exportKind="type";var i=this.startNode();return this.next(),this.flowParseInterface(i)}return e.call(this,t)}}),e.extend("parseClassId",function(e){return function(t){e.apply(this,arguments),this.isRelational("<")&&(t.typeParameters=this.flowParseTypeParameterDeclaration())}}),e.extend("isKeyword",function(e){return function(t){return(!this.state.inType||"void"!==t)&&e.call(this,t)}}),e.extend("readToken",function(e){return function(t){return!this.state.inType||62!==t&&60!==t?e.call(this,t):this.finishOp(R.relational,1)}}),e.extend("jsx_readToken",function(e){return function(){if(!this.state.inType)return e.call(this)}}),e.extend("toAssignable",function(e){return function(t,r,n){return"TypeCastExpression"===t.type?e.call(this,this.typeCastToParameter(t),r,n):e.call(this,t,r,n)}}),e.extend("toAssignableList",function(e){return function(t,r,n){for(var i=0;i<t.length;i++){var s=t[i];s&&"TypeCastExpression"===s.type&&(t[i]=this.typeCastToParameter(s))}return e.call(this,t,r,n)}}),e.extend("toReferencedList",function(){return function(e){for(var t=0;t<e.length;t++){var r=e[t];r&&r._exprListItem&&"TypeCastExpression"===r.type&&this.raise(r.start,"Unexpected type cast")}return e}}),e.extend("parseExprListItem",function(e){return function(){for(var t=this.startNode(),r=arguments.length,n=Array(r),i=0;i<r;i++)n[i]=arguments[i];var s=e.call.apply(e,[this].concat(n));return this.match(R.colon)?(t._exprListItem=!0,t.expression=s,t.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(t,"TypeCastExpression")):s}}),e.extend("checkLVal",function(e){return function(t){if("TypeCastExpression"!==t.type)return e.apply(this,arguments)}}),e.extend("parseClassProperty",function(e){return function(t){return delete t.variancePos,this.match(R.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),e.call(this,t)}}),e.extend("isClassMethod",function(e){return function(){return this.isRelational("<")||e.call(this)}}),e.extend("isClassProperty",function(e){return function(){return this.match(R.colon)||e.call(this)}}),e.extend("isNonstaticConstructor",function(e){return function(t){return!this.match(R.colon)&&e.call(this,t)}}),e.extend("parseClassMethod",function(e){return function(t,r){r.variance&&this.unexpected(r.variancePos),delete r.variance,delete r.variancePos,this.isRelational("<")&&(r.typeParameters=this.flowParseTypeParameterDeclaration());for(var n=arguments.length,i=Array(n>2?n-2:0),s=2;s<n;s++)i[s-2]=arguments[s];e.call.apply(e,[this,t,r].concat(i))}}),e.extend("parseClassSuper",function(e){return function(t,r){if(e.call(this,t,r),t.superClass&&this.isRelational("<")&&(t.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual("implements")){this.next();var n=t.implements=[];do{var i=this.startNode();i.id=this.parseIdentifier(),this.isRelational("<")?i.typeParameters=this.flowParseTypeParameterInstantiation():i.typeParameters=null,n.push(this.finishNode(i,"ClassImplements"))}while(this.eat(R.comma))}}}),e.extend("parsePropertyName",function(e){return function(t){var r=this.state.start,n=this.flowParseVariance(),i=e.call(this,t);return t.variance=n,t.variancePos=r,i}}),e.extend("parseObjPropValue",function(e){return function(t){t.variance&&this.unexpected(t.variancePos),delete t.variance,delete t.variancePos;var r=void 0;this.isRelational("<")&&(r=this.flowParseTypeParameterDeclaration(),this.match(R.parenL)||this.unexpected()),e.apply(this,arguments),r&&((t.value||t).typeParameters=r)}}),e.extend("parseAssignableListItemTypes",function(){return function(e){return this.eat(R.question)&&(e.optional=!0),this.match(R.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation()),this.finishNode(e,e.type),e}}),e.extend("parseMaybeDefault",function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=e.apply(this,r);return"AssignmentPattern"===i.type&&i.typeAnnotation&&i.right.start<i.typeAnnotation.start&&this.raise(i.typeAnnotation.start,"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`"),i}}),e.extend("parseImportSpecifiers",function(e){return function(t){t.importKind="value";var r=null;if(this.match(R._typeof)?r="typeof":this.isContextual("type")&&(r="type"),r){var n=this.lookahead();(n.type===R.name&&"from"!==n.value||n.type===R.braceL||n.type===R.star)&&(this.next(),t.importKind=r)}e.call(this,t)}}),e.extend("parseImportSpecifier",function(){return function(e){var t=this.startNode(),r=this.state.start,n=this.parseIdentifier(!0),i=null;"type"===n.name?i="type":"typeof"===n.name&&(i="typeof");var s=!1;if(this.isContextual("as")){var a=this.parseIdentifier(!0);null===i||this.match(R.name)||this.state.type.keyword?(t.imported=n,t.importKind=null,t.local=this.parseIdentifier()):(t.imported=a,t.importKind=i,t.local=a.__clone())}else null!==i&&(this.match(R.name)||this.state.type.keyword)?(t.imported=this.parseIdentifier(!0),t.importKind=i,this.eatContextual("as")?t.local=this.parseIdentifier():(s=!0,t.local=t.imported.__clone())):(s=!0,t.imported=n,t.importKind=null,t.local=t.imported.__clone());"type"!==e.importKind&&"typeof"!==e.importKind||"type"!==t.importKind&&"typeof"!==t.importKind||this.raise(r,"`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`"),s&&this.checkReservedWord(t.local.name,t.start,!0,!0),this.checkLVal(t.local,!0,void 0,"import specifier"),e.specifiers.push(this.finishNode(t,"ImportSpecifier"))}}),e.extend("parseFunctionParams",function(e){return function(t){this.isRelational("<")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),e.call(this,t)}}),e.extend("parseVarHead",function(e){return function(t){e.call(this,t),this.match(R.colon)&&(t.id.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(t.id,t.id.type))}}),e.extend("parseAsyncArrowFromCallExpression",function(e){return function(t,r){if(this.match(R.colon)){var n=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0,t.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=n}return e.call(this,t,r)}}),e.extend("shouldParseAsyncArrow",function(e){return function(){return this.match(R.colon)||e.call(this)}}),e.extend("parseMaybeAssign",function(e){return function(){for(var t=null,r=arguments.length,n=Array(r),i=0;i<r;i++)n[i]=arguments[i];if(R.jsxTagStart&&this.match(R.jsxTagStart)){var s=this.state.clone();try{return e.apply(this,n)}catch(e){if(!(e instanceof SyntaxError))throw e;this.state=s,this.state.context.length-=2,t=e}}if(null!=t||this.isRelational("<")){var a=void 0,o=void 0;try{o=this.flowParseTypeParameterDeclaration(),a=e.apply(this,n),a.typeParameters=o,a.start=o.start,a.loc.start=o.loc.start}catch(e){throw t||e}if("ArrowFunctionExpression"===a.type)return a;if(null!=t)throw t;this.raise(o.start,"Expected an arrow function after this type parameter declaration")}return e.apply(this,n)}}),e.extend("parseArrow",function(e){return function(t){if(this.match(R.colon)){var r=this.state.clone();try{var n=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0;var i=this.flowParseTypeAndPredicateAnnotation();this.state.noAnonFunctionType=n,this.canInsertSemicolon()&&this.unexpected(),this.match(R.arrow)||this.unexpected(),t.returnType=i}catch(e){if(!(e instanceof SyntaxError))throw e;this.state=r}}return e.call(this,t)}}),e.extend("shouldParseArrow",function(e){return function(){return this.match(R.colon)||e.call(this)}})},fe=String.fromCodePoint;if(!fe){var pe=String.fromCharCode,de=Math.floor;fe=function(){var e=[],t=void 0,r=void 0,n=-1,i=arguments.length;if(!i)return"";for(var s="";++n<i;){var a=Number(arguments[n]);if(!isFinite(a)||a<0||a>1114111||de(a)!=a)throw RangeError("Invalid code point: "+a);a<=65535?e.push(a):(a-=65536,t=55296+(a>>10),r=a%1024+56320,e.push(t,r)),(n+1==i||e.length>16384)&&(s+=pe.apply(null,e),e.length=0)}return s}}var he=fe,me={quot:'"',amp:"&",apos:"'",lt:"<",gt:">",nbsp:"",iexcl:"",cent:"",pound:"",curren:"",yen:"",brvbar:"",sect:"",uml:"",copy:"",ordf:"",laquo:"",not:"",shy:"",reg:"",macr:"",deg:"",plusmn:"",sup2:"",sup3:"",acute:"",micro:"",para:"",middot:"",cedil:"",sup1:"",ordm:"",raquo:"",frac14:"",frac12:"",frac34:"",iquest:"",Agrave:"",Aacute:"",Acirc:"",Atilde:"",Auml:"",Aring:"",AElig:"",Ccedil:"",Egrave:"",Eacute:"",Ecirc:"",Euml:"",Igrave:"",Iacute:"",Icirc:"",Iuml:"",ETH:"",Ntilde:"",Ograve:"",Oacute:"",Ocirc:"",Otilde:"",Ouml:"",times:"",Oslash:"",Ugrave:"",Uacute:"",Ucirc:"",Uuml:"",Yacute:"",THORN:"",szlig:"",agrave:"",aacute:"",acirc:"",atilde:"",auml:"",aring:"",aelig:"",ccedil:"",egrave:"",eacute:"",ecirc:"",euml:"",igrave:"",iacute:"",icirc:"",iuml:"",eth:"",ntilde:"",ograve:"",oacute:"",ocirc:"",otilde:"",ouml:"",divide:"",oslash:"",ugrave:"",uacute:"",ucirc:"",uuml:"",yacute:"",thorn:"",yuml:"",OElig:"",oelig:"",Scaron:"",scaron:"",Yuml:"",fnof:"",circ:"",tilde:"",Alpha:"",Beta:"",Gamma:"",Delta:"",Epsilon:"",Zeta:"",Eta:"",Theta:"",Iota:"",Kappa:"",Lambda:"",Mu:"",Nu:"",Xi:"",Omicron:"",Pi:"",Rho:"",Sigma:"",Tau:"",Upsilon:"",Phi:"",Chi:"",Psi:"",Omega:"",alpha:"",beta:"",gamma:"",delta:"",epsilon:"",zeta:"",eta:"",theta:"",iota:"",kappa:"",lambda:"",mu:"",nu:"",xi:"",omicron:"",pi:"",rho:"",sigmaf:"",sigma:"",tau:"",upsilon:"",phi:"",chi:"",psi:"",omega:"",thetasym:"",upsih:"",piv:"",ensp:"",emsp:"",thinsp:"",zwnj:"",zwj:"",lrm:"",rlm:"",ndash:"",mdash:"",lsquo:"",rsquo:"",sbquo:"",ldquo:"",rdquo:"",bdquo:"",dagger:"",Dagger:"",bull:"",hellip:"",permil:"",prime:"",Prime:"",lsaquo:"",rsaquo:"",oline:"",frasl:"",euro:"",image:"",weierp:"",real:"",trade:"",alefsym:"",larr:"",uarr:"",rarr:"",darr:"",harr:"",crarr:"",lArr:"",uArr:"",rArr:"",dArr:"",hArr:"",forall:"",part:"",exist:"",empty:"",nabla:"",isin:"",notin:"",ni:"",prod:"",sum:"",minus:"",lowast:"",radic:"",prop:"",infin:"",ang:"",and:"",or:"",cap:"",cup:"",int:"",there4:"",sim:"",cong:"",asymp:"",ne:"",equiv:"",le:"",ge:"",sub:"",sup:"",nsub:"",sube:"",supe:"",oplus:"",otimes:"",perp:"",sdot:"",lceil:"",rceil:"",lfloor:"",rfloor:"",lang:"",rang:"",loz:"",spades:"",clubs:"",hearts:"",diams:""},ye=/^[\da-fA-F]+$/,ve=/^\d+$/;U.j_oTag=new j("<tag",!1),U.j_cTag=new j("</tag",!1),U.j_expr=new j("<tag>...</tag>",!0,!0),R.jsxName=new T("jsxName"),R.jsxText=new T("jsxText",{beforeExpr:!0}),R.jsxTagStart=new T("jsxTagStart",{startsExpr:!0}),R.jsxTagEnd=new T("jsxTagEnd"),R.jsxTagStart.updateContext=function(){this.state.context.push(U.j_expr),this.state.context.push(U.j_oTag),this.state.exprAllowed=!1},R.jsxTagEnd.updateContext=function(e){var t=this.state.context.pop();t===U.j_oTag&&e===R.slash||t===U.j_cTag?(this.state.context.pop(),this.state.exprAllowed=this.curContext()===U.j_expr):this.state.exprAllowed=!0};var ge=J.prototype;ge.jsxReadToken=function(){for(var e="",t=this.state.pos;;){this.state.pos>=this.input.length&&this.raise(this.state.start,"Unterminated JSX contents");var r=this.input.charCodeAt(this.state.pos);switch(r){case 60:case 123:return this.state.pos===this.state.start?60===r&&this.state.exprAllowed?(++this.state.pos,this.finishToken(R.jsxTagStart)):this.getTokenFromCode(r):(e+=this.input.slice(t,this.state.pos),this.finishToken(R.jsxText,e));case 38:e+=this.input.slice(t,this.state.pos),e+=this.jsxReadEntity(),t=this.state.pos;break;default:o(r)?(e+=this.input.slice(t,this.state.pos),e+=this.jsxReadNewLine(!0),t=this.state.pos):++this.state.pos}}},ge.jsxReadNewLine=function(e){var t=this.input.charCodeAt(this.state.pos),r=void 0;return++this.state.pos,13===t&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,r=e?"\n":"\r\n"):r=String.fromCharCode(t),++this.state.curLine,this.state.lineStart=this.state.pos,r},ge.jsxReadString=function(e){for(var t="",r=++this.state.pos;;){this.state.pos>=this.input.length&&this.raise(this.state.start,"Unterminated string constant");var n=this.input.charCodeAt(this.state.pos);if(n===e)break;38===n?(t+=this.input.slice(r,this.state.pos),t+=this.jsxReadEntity(),r=this.state.pos):o(n)?(t+=this.input.slice(r,this.state.pos),t+=this.jsxReadNewLine(!1),r=this.state.pos):++this.state.pos}return t+=this.input.slice(r,this.state.pos++),this.finishToken(R.string,t)},ge.jsxReadEntity=function(){for(var e="",t=0,r=void 0,n=this.input[this.state.pos],i=++this.state.pos;this.state.pos<this.input.length&&t++<10;){if(";"===(n=this.input[this.state.pos++])){"#"===e[0]?"x"===e[1]?(e=e.substr(2),ye.test(e)&&(r=he(parseInt(e,16)))):(e=e.substr(1),ve.test(e)&&(r=he(parseInt(e,10)))):r=me[e];break}e+=n}return r||(this.state.pos=i,"&")},ge.jsxReadWord=function(){var e=void 0,t=this.state.pos;do{e=this.input.charCodeAt(++this.state.pos)}while(s(e)||45===e);return this.finishToken(R.jsxName,this.input.slice(t,this.state.pos))},ge.jsxParseIdentifier=function(){var e=this.startNode();return this.match(R.jsxName)?e.name=this.state.value:this.state.type.keyword?e.name=this.state.type.keyword:this.unexpected(),this.next(),this.finishNode(e,"JSXIdentifier")},ge.jsxParseNamespacedName=function(){var e=this.state.start,t=this.state.startLoc,r=this.jsxParseIdentifier();if(!this.eat(R.colon))return r;var n=this.startNodeAt(e,t);return n.namespace=r,n.name=this.jsxParseIdentifier(),this.finishNode(n,"JSXNamespacedName")},ge.jsxParseElementName=function(){for(var e=this.state.start,t=this.state.startLoc,r=this.jsxParseNamespacedName();this.eat(R.dot);){var n=this.startNodeAt(e,t);n.object=r,n.property=this.jsxParseIdentifier(),r=this.finishNode(n,"JSXMemberExpression")}return r},ge.jsxParseAttributeValue=function(){var e=void 0;switch(this.state.type){case R.braceL:if(e=this.jsxParseExpressionContainer(),"JSXEmptyExpression"!==e.expression.type)return e;this.raise(e.start,"JSX attributes must only be assigned a non-empty expression");case R.jsxTagStart:case R.string:return e=this.parseExprAtom(),e.extra=null,e;default:this.raise(this.state.start,"JSX value should be either an expression or a quoted JSX text")}},ge.jsxParseEmptyExpression=function(){var e=this.startNodeAt(this.state.lastTokEnd,this.state.lastTokEndLoc);return this.finishNodeAt(e,"JSXEmptyExpression",this.state.start,this.state.startLoc)},ge.jsxParseSpreadChild=function(){var e=this.startNode();return this.expect(R.braceL),this.expect(R.ellipsis),e.expression=this.parseExpression(),this.expect(R.braceR),this.finishNode(e,"JSXSpreadChild")},ge.jsxParseExpressionContainer=function(){var e=this.startNode();return this.next(),this.match(R.braceR)?e.expression=this.jsxParseEmptyExpression():e.expression=this.parseExpression(),this.expect(R.braceR),this.finishNode(e,"JSXExpressionContainer")},ge.jsxParseAttribute=function(){var e=this.startNode();return this.eat(R.braceL)?(this.expect(R.ellipsis),e.argument=this.parseMaybeAssign(),this.expect(R.braceR),this.finishNode(e,"JSXSpreadAttribute")):(e.name=this.jsxParseNamespacedName(),e.value=this.eat(R.eq)?this.jsxParseAttributeValue():null,this.finishNode(e,"JSXAttribute"))},ge.jsxParseOpeningElementAt=function(e,t){var r=this.startNodeAt(e,t);for(r.attributes=[],r.name=this.jsxParseElementName();!this.match(R.slash)&&!this.match(R.jsxTagEnd);)r.attributes.push(this.jsxParseAttribute());return r.selfClosing=this.eat(R.slash),this.expect(R.jsxTagEnd),this.finishNode(r,"JSXOpeningElement")},ge.jsxParseClosingElementAt=function(e,t){var r=this.startNodeAt(e,t);return r.name=this.jsxParseElementName(),this.expect(R.jsxTagEnd),this.finishNode(r,"JSXClosingElement")},ge.jsxParseElementAt=function(e,t){var r=this.startNodeAt(e,t),n=[],i=this.jsxParseOpeningElementAt(e,t),s=null;if(!i.selfClosing){e:for(;;)switch(this.state.type){case R.jsxTagStart:if(e=this.state.start,t=this.state.startLoc,this.next(),this.eat(R.slash)){s=this.jsxParseClosingElementAt(e,t);break e}n.push(this.jsxParseElementAt(e,t));break;case R.jsxText:n.push(this.parseExprAtom());break;case R.braceL:this.lookahead().type===R.ellipsis?n.push(this.jsxParseSpreadChild()):n.push(this.jsxParseExpressionContainer());break;default:this.unexpected()}d(s.name)!==d(i.name)&&this.raise(s.start,"Expected corresponding JSX closing tag for <"+d(i.name)+">")}return r.openingElement=i,r.closingElement=s,r.children=n,this.match(R.relational)&&"<"===this.state.value&&this.raise(this.state.start,"Adjacent JSX elements must be wrapped in an enclosing tag"),this.finishNode(r,"JSXElement")},ge.jsxParseElement=function(){var e=this.state.start,t=this.state.startLoc;return this.next(),this.jsxParseElementAt(e,t)};var be=function(e){e.extend("parseExprAtom",function(e){return function(t){if(this.match(R.jsxText)){var r=this.parseLiteral(this.state.value,"JSXText");return r.extra=null,r}return this.match(R.jsxTagStart)?this.jsxParseElement():e.call(this,t)}}),e.extend("readToken",function(e){return function(t){if(this.state.inPropertyName)return e.call(this,t);var r=this.curContext();if(r===U.j_expr)return this.jsxReadToken();if(r===U.j_oTag||r===U.j_cTag){if(i(t))return this.jsxReadWord();if(62===t)return++this.state.pos,this.finishToken(R.jsxTagEnd);if((34===t||39===t)&&r===U.j_oTag)return this.jsxReadString(t)}return 60===t&&this.state.exprAllowed?(++this.state.pos,this.finishToken(R.jsxTagStart)):e.call(this,t)}}),e.extend("updateContext",function(e){return function(t){if(this.match(R.braceL)){var r=this.curContext();r===U.j_oTag?this.state.context.push(U.braceExpression):r===U.j_expr?this.state.context.push(U.templateQuasi):e.call(this,t),this.state.exprAllowed=!0}else{if(!this.match(R.slash)||t!==R.jsxTagStart)return e.call(this,t);this.state.context.length-=2,this.state.context.push(U.j_cTag),this.state.exprAllowed=!1}}})};K.estree=oe,K.flow=ce,K.jsx=be,t.parse=h,t.parseExpression=m,t.tokTypes=R},function(e,t,r){"use strict";var n=r(21),i=r(431),s=r(141),a=r(150)("IE_PROTO"),o=function(){},u=function(){var e,t=r(230)("iframe"),n=s.length;for(t.style.display="none",r(426).appendChild(t),t.src="javascript:",e=t.contentWindow.document,e.open(),e.write("<script>document.F=Object<\/script>"),e.close(),u=e.F;n--;)delete u.prototype[s[n]];return u()};e.exports=Object.create||function(e,t){var r;return null!==e?(o.prototype=n(e),r=new o,o.prototype=null,r[a]=e):r=u(),void 0===t?r:i(r,t)}},function(e,t){"use strict";t.f={}.propertyIsEnumerable},function(e,t){"use strict";e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e,t,r){"use strict";var n=r(23).f,i=r(28),s=r(13)("toStringTag");e.exports=function(e,t,r){e&&!i(e=r?e:e.prototype,s)&&n(e,s,{configurable:!0,value:t})}},function(e,t,r){"use strict";var n=r(140);e.exports=function(e){return Object(n(e))}},function(e,t){"use strict";var r=0,n=Math.random();e.exports=function(e){return"Symbol(".concat(void 0===e?"":e,")_",(++r+n).toString(36))}},function(e,t){"use strict"},function(e,t,r){"use strict";!function(){t.ast=r(461),t.code=r(240),t.keyword=r(462)}()},function(e,t,r){"use strict";function n(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}var i=r(546),s=r(547),a=r(548),o=r(549),u=r(550);n.prototype.clear=i,n.prototype.delete=s,n.prototype.get=a,n.prototype.has=o,n.prototype.set=u,e.exports=n},function(e,t,r){"use strict";function n(e){var t=this.__data__=new i(e);this.size=t.size}var i=r(98),s=r(565),a=r(566),o=r(567),u=r(568),l=r(569);n.prototype.clear=s,n.prototype.delete=a,n.prototype.get=o,n.prototype.has=u,n.prototype.set=l,e.exports=n},function(e,t,r){"use strict";function n(e,t){for(var r=e.length;r--;)if(i(e[r][0],t))return r;return-1}var i=r(46);e.exports=n},function(e,t,r){"use strict";function n(e,t){return a(s(e,t,i),e+"")}var i=r(110),s=r(560),a=r(563);e.exports=n},function(e,t){"use strict";function r(e){return function(t){return e(t)}}e.exports=r},function(e,t,r){"use strict";function n(e){return i(function(t,r){var n=-1,i=r.length,a=i>1?r[i-1]:void 0,o=i>2?r[2]:void 0;for(a=e.length>3&&"function"==typeof a?(i--,a):void 0,o&&s(r[0],r[1],o)&&(a=i<3?void 0:a,i=1),t=Object(t);++n<i;){var u=r[n];u&&e(t,u,n,a)}return t})}var i=r(101),s=r(172);e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=e.__data__;return i(t)?r["string"==typeof t?"string":"hash"]:r.map}var i=r(544);e.exports=n},function(e,t){"use strict";function r(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||n)}var n=Object.prototype;e.exports=r},function(e,t,r){"use strict";var n=r(38),i=n(Object,"create");e.exports=i},function(e,t){"use strict";function r(e){var t=-1,r=Array(e.size);return e.forEach(function(e){r[++t]=e}),r}e.exports=r},function(e,t,r){"use strict";function n(e){if("string"==typeof e||i(e))return e;var t=e+"";return"0"==t&&1/e==-s?"-0":t}var i=r(62),s=1/0;e.exports=n},function(e,t,r){"use strict";function n(e){return i(e,s)}var i=r(164),s=4;e.exports=n},function(e,t){"use strict";function r(e){return e}e.exports=r},function(e,t,r){"use strict";function n(e,t,r,n){e=s(e)?e:u(e),r=r&&!n?o(r):0;var c=e.length;return r<0&&(r=l(c+r,0)),a(e)?r<=c&&e.indexOf(t,r)>-1:!!c&&i(e,t,r)>-1}var i=r(166),s=r(24),a=r(587),o=r(48),u=r(280),l=Math.max;e.exports=n},function(e,t,r){"use strict";var n=r(493),i=r(25),s=Object.prototype,a=s.hasOwnProperty,o=s.propertyIsEnumerable,u=n(function(){return arguments}())?n:function(e){return i(e)&&a.call(e,"callee")&&!o.call(e,"callee")};e.exports=u},function(e,t,r){(function(e){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(17),s=r(596),a="object"==n(t)&&t&&!t.nodeType&&t,o=a&&"object"==n(e)&&e&&!e.nodeType&&e,u=o&&o.exports===a,l=u?i.Buffer:void 0,c=l?l.isBuffer:void 0,f=c||s;e.exports=f}).call(t,r(39)(e))},function(e,t,r){"use strict";function n(e){return null==e?"":i(e)}var i=r(253);e.exports=n},96,function(e,t,r){"use strict";function n(e){return o.memberExpression(o.identifier("regeneratorRuntime"),o.identifier(e),!1)}function i(e){return e.isReferenced()||e.parentPath.isAssignmentExpression({left:e.node})}function s(e,t){t?e.replaceWith(t):e.remove()}t.__esModule=!0,t.runtimeProperty=n,t.isReference=i,t.replaceWithOrRemove=s;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a)},function(e,t,r){(function(e,n){"use strict";function i(e,r){var n={seen:[],stylize:a};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),m(r)?n.showHidden=r:r&&t._extend(n,r),x(n.showHidden)&&(n.showHidden=!1),x(n.depth)&&(n.depth=2),x(n.colors)&&(n.colors=!1),x(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=s),u(n,e,n.depth)}function s(e,t){var r=i.styles[t];return r?"["+i.colors[r][0]+"m"+e+"["+i.colors[r][1]+"m":e}function a(e,t){return e}function o(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}function u(e,r,n){if(e.customInspect&&r&&C(r.inspect)&&r.inspect!==t.inspect&&(!r.constructor||r.constructor.prototype!==r)){var i=r.inspect(n,e);return b(i)||(i=u(e,i,n)),i}var s=l(e,r);if(s)return s;var a=Object.keys(r),m=o(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(r)),D(r)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return c(r);if(0===a.length){if(C(r)){var y=r.name?": "+r.name:"";return e.stylize("[Function"+y+"]","special")}if(A(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(_(r))return e.stylize(Date.prototype.toString.call(r),"date");if(D(r))return c(r)}var v="",g=!1,E=["{","}"];if(h(r)&&(g=!0,E=["[","]"]),C(r)){v=" [Function"+(r.name?": "+r.name:"")+"]"}if(A(r)&&(v=" "+RegExp.prototype.toString.call(r)),_(r)&&(v=" "+Date.prototype.toUTCString.call(r)),D(r)&&(v=" "+c(r)),0===a.length&&(!g||0==r.length))return E[0]+v+E[1];if(n<0)return A(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special");e.seen.push(r);var x;return x=g?f(e,r,n,m,a):a.map(function(t){return p(e,r,n,m,t,g)}),e.seen.pop(),d(x,v,E)}function l(e,t){if(x(t))return e.stylize("undefined","undefined");if(b(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}return g(t)?e.stylize(""+t,"number"):m(t)?e.stylize(""+t,"boolean"):y(t)?e.stylize("null","null"):void 0}function c(e){return"["+Error.prototype.toString.call(e)+"]"}function f(e,t,r,n,i){for(var s=[],a=0,o=t.length;a<o;++a)T(t,String(a))?s.push(p(e,t,r,n,String(a),!0)):s.push("");return i.forEach(function(i){i.match(/^\d+$/)||s.push(p(e,t,r,n,i,!0))}),s}function p(e,t,r,n,i,s){var a,o,l;if(l=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]},l.get?o=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(o=e.stylize("[Setter]","special")),T(n,i)||(a="["+i+"]"),o||(e.seen.indexOf(l.value)<0?(o=y(r)?u(e,l.value,null):u(e,l.value,r-1),o.indexOf("\n")>-1&&(o=s?o.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+o.split("\n").map(function(e){return"   "+e}).join("\n"))):o=e.stylize("[Circular]","special")),x(a)){if(s&&i.match(/^\d+$/))return o;a=JSON.stringify(""+i),a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+o}function d(e,t,r){var n=0;return e.reduce(function(e,t){return n++,t.indexOf("\n")>=0&&n++,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1]:r[0]+t+" "+e.join(", ")+" "+r[1]}function h(e){return Array.isArray(e)}function m(e){return"boolean"==typeof e}function y(e){return null===e}function v(e){return null==e}function g(e){return"number"==typeof e}function b(e){return"string"==typeof e}function E(e){return"symbol"===(void 0===e?"undefined":O(e))}function x(e){return void 0===e}function A(e){return S(e)&&"[object RegExp]"===P(e)}function S(e){return"object"===(void 0===e?"undefined":O(e))&&null!==e}function _(e){return S(e)&&"[object Date]"===P(e)}function D(e){return S(e)&&("[object Error]"===P(e)||e instanceof Error)}function C(e){return"function"==typeof e}function w(e){
return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"===(void 0===e?"undefined":O(e))||void 0===e}function P(e){return Object.prototype.toString.call(e)}function k(e){return e<10?"0"+e.toString(10):e.toString(10)}function F(){var e=new Date,t=[k(e.getHours()),k(e.getMinutes()),k(e.getSeconds())].join(":");return[e.getDate(),M[e.getMonth()],t].join(" ")}function T(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var O="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},B=/%[sdj%]/g;t.format=function(e){if(!b(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(i(arguments[r]));return t.join(" ")}for(var r=1,n=arguments,s=n.length,a=String(e).replace(B,function(e){if("%%"===e)return"%";if(r>=s)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),o=n[r];r<s;o=n[++r])y(o)||!S(o)?a+=" "+o:a+=" "+i(o);return a},t.deprecate=function(r,i){function s(){if(!a){if(n.throwDeprecation)throw new Error(i);n.traceDeprecation?console.trace(i):console.error(i),a=!0}return r.apply(this,arguments)}if(x(e.process))return function(){return t.deprecate(r,i).apply(this,arguments)};if(!0===n.noDeprecation)return r;var a=!1;return s};var R,I={};t.debuglog=function(e){if(x(R)&&(R=n.env.NODE_DEBUG||""),e=e.toUpperCase(),!I[e])if(new RegExp("\\b"+e+"\\b","i").test(R)){var r=n.pid;I[e]=function(){var n=t.format.apply(t,arguments);console.error("%s %d: %s",e,r,n)}}else I[e]=function(){};return I[e]},t.inspect=i,i.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},i.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=h,t.isBoolean=m,t.isNull=y,t.isNullOrUndefined=v,t.isNumber=g,t.isString=b,t.isSymbol=E,t.isUndefined=x,t.isRegExp=A,t.isObject=S,t.isDate=_,t.isError=D,t.isFunction=C,t.isPrimitive=w,t.isBuffer=r(627);var M=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];t.log=function(){console.log("%s - %s",F(),t.format.apply(t,arguments))},t.inherits=r(626),t._extend=function(e,t){if(!t||!S(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e}}).call(t,function(){return this}(),r(8))},function(e,t,r){(function(n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var s=r(11),a=i(s);t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.cwd();if("object"===(void 0===u.default?"undefined":(0,a.default)(u.default)))return null;var r=f[t];if(!r){r=new u.default;var i=c.default.join(t,".babelrc");r.id=i,r.filename=i,r.paths=u.default._nodeModulePaths(t),f[t]=r}try{return u.default._resolveFilename(e,r)}catch(e){return null}};var o=r(115),u=i(o),l=r(19),c=i(l),f={};e.exports=t.default}).call(t,r(8))},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(133),s=n(i),a=r(3),o=n(a),u=r(42),l=n(u),c=r(41),f=n(c),p=function(e){function t(){(0,o.default)(this,t);var r=(0,l.default)(this,e.call(this));return r.dynamicData={},r}return(0,f.default)(t,e),t.prototype.setDynamic=function(e,t){this.dynamicData[e]=t},t.prototype.get=function(t){if(this.has(t))return e.prototype.get.call(this,t);if(Object.prototype.hasOwnProperty.call(this.dynamicData,t)){var r=this.dynamicData[t]();return this.set(t,r),r}},t}(s.default);t.default=p,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(239),o=n(a),u=(0,o.default)("babel:verbose"),l=(0,o.default)("babel"),c=[],f=function(){function e(t,r){(0,s.default)(this,e),this.filename=r,this.file=t}return e.prototype._buildMessage=function(e){var t="[BABEL] "+this.filename;return e&&(t+=": "+e),t},e.prototype.warn=function(e){console.warn(this._buildMessage(e))},e.prototype.error=function(e){throw new(arguments.length>1&&void 0!==arguments[1]?arguments[1]:Error)(this._buildMessage(e))},e.prototype.deprecate=function(e){this.file.opts&&this.file.opts.suppressDeprecationMessages||(e=this._buildMessage(e),c.indexOf(e)>=0||(c.push(e),console.error(e)))},e.prototype.verbose=function(e){u.enabled&&u(this._buildMessage(e))},e.prototype.debug=function(e){l.enabled&&l(this._buildMessage(e))},e.prototype.deopt=function(e,t){this.debug(t)},e}();t.default=f,e.exports=t.default},function(e,t,r){"use strict";function n(e,t){var r=e.node,n=r.source?r.source.value:null,i=t.metadata.modules.exports,s=e.get("declaration");if(s.isStatement()){var o=s.getBindingIdentifiers();for(var l in o)i.exported.push(l),i.specifiers.push({kind:"local",local:l,exported:e.isExportDefaultDeclaration()?"default":l})}if(e.isExportNamedDeclaration()&&r.specifiers)for(var c=r.specifiers,f=Array.isArray(c),p=0,c=f?c:(0,a.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d,m=h.exported.name;i.exported.push(m),u.isExportDefaultSpecifier(h)&&i.specifiers.push({kind:"external",local:m,exported:m,source:n}),u.isExportNamespaceSpecifier(h)&&i.specifiers.push({kind:"external-namespace",exported:m,source:n});var y=h.local;y&&(n&&i.specifiers.push({kind:"external",local:y.name,exported:m,source:n}),n||i.specifiers.push({kind:"local",local:y.name,exported:m}))}e.isExportAllDeclaration()&&i.specifiers.push({kind:"external-all",source:n})}function i(e){e.skip()}t.__esModule=!0,t.ImportDeclaration=t.ModuleDeclaration=void 0;var s=r(2),a=function(e){return e&&e.__esModule?e:{default:e}}(s);t.ExportDeclaration=n,t.Scope=i;var o=r(1),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(o);t.ModuleDeclaration={enter:function(e,t){var r=e.node;r.source&&(r.source.value=t.resolveModuleSource(r.source.value))}},t.ImportDeclaration={exit:function(e,t){var r=e.node,n=[],i=[];t.metadata.modules.imports.push({source:r.source.value,imported:i,specifiers:n});for(var s=e.get("specifiers"),o=Array.isArray(s),u=0,s=o?s:(0,a.default)(s);;){var l;if(o){if(u>=s.length)break;l=s[u++]}else{if(u=s.next(),u.done)break;l=u.value}var c=l,f=c.node.local.name;if(c.isImportDefaultSpecifier()&&(i.push("default"),n.push({kind:"named",imported:"default",local:f})),c.isImportSpecifier()){var p=c.node.imported.name;i.push(p),n.push({kind:"named",imported:p,local:f})}c.isImportNamespaceSpecifier()&&(i.push("*"),n.push({kind:"namespace",local:f}))}}}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var r=t||i.EXTENSIONS,n=D.default.extname(e);return(0,x.default)(r,n)}function s(e){return e?Array.isArray(e)?e:"string"==typeof e?e.split(","):[e]:[]}function a(e){if(!e)return new RegExp(/.^/);if(Array.isArray(e)&&(e=new RegExp(e.map(m.default).join("|"),"i")),"string"==typeof e){e=(0,w.default)(e),((0,v.default)(e,"./")||(0,v.default)(e,"*/"))&&(e=e.slice(2)),(0,v.default)(e,"**/")&&(e=e.slice(3));var t=b.default.makeRe(e,{nocase:!0});return new RegExp(t.source.slice(1,-1),"i")}if((0,S.default)(e))return e;throw new TypeError("illegal type for regexify")}function o(e,t){return e?"boolean"==typeof e?o([e],t):"string"==typeof e?o(s(e),t):Array.isArray(e)?(t&&(e=e.map(t)),e):[e]:[]}function u(e){return"true"===e||1==e||!("false"===e||0==e||!e)&&e}function l(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments[2];if(e=e.replace(/\\/g,"/"),r){for(var n=r,i=Array.isArray(n),s=0,n=i?n:(0,p.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}if(c(a,e))return!1}return!0}if(t.length)for(var o=t,u=Array.isArray(o),l=0,o=u?o:(0,p.default)(o);;){var f;if(u){if(l>=o.length)break;f=o[l++]}else{if(l=o.next(),l.done)break;f=l.value}var d=f;if(c(d,e))return!0}return!1}function c(e,t){return"function"==typeof e?e(t):e.test(t)}t.__esModule=!0,t.inspect=t.inherits=void 0;var f=r(2),p=n(f),d=r(117);Object.defineProperty(t,"inherits",{enumerable:!0,get:function(){return d.inherits}}),Object.defineProperty(t,"inspect",{enumerable:!0,get:function(){return d.inspect}}),t.canCompile=i,t.list=s,t.regexify=a,t.arrayify=o,t.booleanify=u,t.shouldIgnore=l;var h=r(577),m=n(h),y=r(595),v=n(y),g=r(601),b=n(g),E=r(111),x=n(E),A=r(276),S=n(A),_=r(19),D=n(_),C=r(284),w=n(C);i.EXTENSIONS=[".js",".jsx",".es6",".es"]},function(e,t,r){"use strict";function n(e){e.variance&&("plus"===e.variance?this.token("+"):"minus"===e.variance&&this.token("-")),this.word(e.name)}function i(e){this.token("..."),this.print(e.argument,e)}function s(e){var t=e.properties;this.token("{"),this.printInnerComments(e),t.length&&(this.space(),this.printList(t,e,{indent:!0,statement:!0}),this.space()),this.token("}")}function a(e){this.printJoin(e.decorators,e),this._method(e)}function o(e){if(this.printJoin(e.decorators,e),e.computed)this.token("["),this.print(e.key,e),this.token("]");else{if(m.isAssignmentPattern(e.value)&&m.isIdentifier(e.key)&&e.key.name===e.value.left.name)return void this.print(e.value,e);if(this.print(e.key,e),e.shorthand&&m.isIdentifier(e.key)&&m.isIdentifier(e.value)&&e.key.name===e.value.name)return}this.token(":"),this.space(),this.print(e.value,e)}function u(e){var t=e.elements,r=t.length;this.token("["),this.printInnerComments(e);for(var n=0;n<t.length;n++){var i=t[n];i?(n>0&&this.space(),this.print(i,e),n<r-1&&this.token(",")):this.token(",")}this.token("]")}function l(e){this.word("/"+e.pattern+"/"+e.flags)}function c(e){this.word(e.value?"true":"false")}function f(){this.word("null")}function p(e){var t=this.getPossibleRaw(e),r=e.value+"";null==t?this.number(r):this.format.minified?this.number(t.length<r.length?t:r):this.number(t)}function d(e,t){var r=this.getPossibleRaw(e);if(!this.format.minified&&null!=r)return void this.token(r);var n={quotes:m.isJSX(t)?"double":this.format.quotes,wrap:!0};this.format.jsonCompatibleStrings&&(n.json=!0);var i=(0,v.default)(e.value,n);return this.token(i)}t.__esModule=!0,t.ArrayPattern=t.ObjectPattern=t.RestProperty=t.SpreadProperty=t.SpreadElement=void 0,t.Identifier=n,t.RestElement=i,t.ObjectExpression=s,t.ObjectMethod=a,t.ObjectProperty=o,t.ArrayExpression=u,t.RegExpLiteral=l,t.BooleanLiteral=c,t.NullLiteral=f,t.NumericLiteral=p,t.StringLiteral=d;var h=r(1),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h),y=r(469),v=function(e){return e&&e.__esModule?e:{default:e}}(y);t.SpreadElement=i,t.SpreadProperty=i,t.RestProperty=i,t.ObjectPattern=s,t.ArrayPattern=u},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var r=e.node,n=r.body;r.async=!1;var i=f.functionExpression(null,[],f.blockStatement(n.body),!0);i.shadow=!0,n.body=[f.returnStatement(f.callExpression(f.callExpression(t,[i]),[]))],r.generator=!1}function s(e,t){var r=e.node,n=e.isFunctionDeclaration(),i=r.id,s=h;e.isArrowFunctionExpression()?e.arrowFunctionToShadowed():!n&&i&&(s=m),r.async=!1,r.generator=!0,r.id=null,n&&(r.type="FunctionExpression");var a=f.callExpression(t,[r]),u=s({NAME:i,REF:e.scope.generateUidIdentifier("ref"),FUNCTION:a,PARAMS:r.params.reduce(function(t,r){return t.done=t.done||f.isAssignmentPattern(r)||f.isRestElement(r),t.done||t.params.push(e.scope.generateUidIdentifier("x")),t},{params:[],done:!1}).params}).expression;if(n){var l=f.variableDeclaration("let",[f.variableDeclarator(f.identifier(i.name),f.callExpression(u,[]))]);l._blockHoist=!0,e.replaceWith(l)}else{var c=u.body.body[1].argument;i||(0,o.default)({node:c,parent:e.parent,scope:e.scope}),!c||c.id||r.params.length?e.replaceWith(f.callExpression(u,[])):e.replaceWith(a)}}t.__esModule=!0,t.default=function(e,t,r){r||(r={wrapAsync:t},t=null),e.traverse(y,{file:t,wrapAwait:r.wrapAwait}),e.isClassMethod()||e.isObjectMethod()?i(e,r.wrapAsync):s(e,r.wrapAsync)};var a=r(40),o=n(a),u=r(4),l=n(u),c=r(1),f=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(c),p=r(320),d=n(p),h=(0,l.default)("\n  (() => {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })\n"),m=(0,l.default)("\n  (() => {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })\n"),y={Function:function(e){if(e.isArrowFunctionExpression()&&!e.node.async)return void e.arrowFunctionToShadowed();e.skip()},AwaitExpression:function(e,t){var r=e.node,n=t.wrapAwait;r.type="YieldExpression",n&&(r.argument=f.callExpression(n,[r.argument]))},ForAwaitStatement:function(e,t){var r=t.file,n=t.wrapAwait,i=e.node,s=(0,d.default)(e,{getAsyncIterator:r.addHelper("asyncIterator"),wrapAwait:n}),a=s.declar,o=s.loop,u=o.body;e.ensureBlock(),a&&u.body.push(a),u.body=u.body.concat(i.body.body),f.inherits(o,i),f.inherits(o.body,i.body),s.replaceParent?(e.parentPath.replaceWithMultiple(s.node),e.remove()):e.replaceWithMultiple(s.node)}};e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("decorators")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("flow")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("jsx")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("trailingFunctionCommas")}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{inherits:r(67),visitor:{Function:function(e,t){e.node.async&&!e.node.generator&&(0,i.default)(e,t.file,{wrapAsync:t.addHelper("asyncToGenerator")})}}}};var n=r(124),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return c.isIdentifier(e)?e.name:e.value.toString()}t.__esModule=!0;var s=r(2),a=n(s),o=r(9),u=n(o);t.default=function(){return{visitor:{ObjectExpression:function(e){for(var t=e.node,r=t.properties.filter(function(e){return!c.isSpreadProperty(e)&&!e.computed}),n=(0,u.default)(null),s=(0,u.default)(null),o=(0,u.default)(null),l=r,f=Array.isArray(l),p=0,l=f?l:(0,a.default)(l);;){var d;if(f){if(p>=l.length)break;d=l[p++]}else{if(p=l.next(),p.done)break;d=p.value}var h=d,m=i(h.key),y=!1;switch(h.kind){case"get":(n[m]||s[m])&&(y=!0),s[m]=!0;break;case"set":(n[m]||o[m])&&(y=!0),o[m]=!0;break;default:(n[m]||s[m]||o[m])&&(y=!0),n[m]=!0}y&&(h.computed=!0,h.key=c.stringLiteral(m))}}}}};var l=r(1),c=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(l);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(9),s=n(i);t.default=function(e){function t(e){if(!e.isCallExpression())return!1;if(!e.get("callee").isIdentifier({name:"require"}))return!1;if(e.scope.getBinding("require"))return!1;var t=e.get("arguments");return 1===t.length&&!!t[0].isStringLiteral()}var n=e.types,i={ReferencedIdentifier:function(e){var t=e.node,r=e.scope;"exports"!==t.name||r.getBinding("exports")||(this.hasExports=!0),"module"!==t.name||r.getBinding("module")||(this.hasModule=!0)},CallExpression:function(e){t(e)&&(this.bareSources.push(e.node.arguments[0]),e.remove())},VariableDeclarator:function(e){var r=e.get("id");if(r.isIdentifier()){var n=e.get("init");if(t(n)){var i=n.node.arguments[0];this.sourceNames[i.value]=!0,this.sources.push([r.node,i]),e.remove()}}}};return{inherits:r(77),pre:function(){this.sources=[],this.sourceNames=(0,s.default)(null),this.bareSources=[],this.hasExports=!1,this.hasModule=!1},visitor:{Program:{exit:function(e){var t=this;if(!this.ran){this.ran=!0,e.traverse(i,this);var r=this.sources.map(function(e){return e[0]}),s=this.sources.map(function(e){return e[1]});s=s.concat(this.bareSources.filter(function(e){return!t.sourceNames[e.value]}));var a=this.getModuleName();a&&(a=n.stringLiteral(a)),this.hasExports&&(s.unshift(n.stringLiteral("exports")),r.unshift(n.identifier("exports"))),this.hasModule&&(s.unshift(n.stringLiteral("module")),r.unshift(n.identifier("module")));var o=e.node,c=l({PARAMS:r,BODY:o.body});c.expression.body.directives=o.directives,o.directives=[],o.body=[u({MODULE_NAME:a,SOURCES:s,FACTORY:c})]}}}}}};var a=r(4),o=n(a),u=(0,o.default)("\n  define(MODULE_NAME, [SOURCES], FACTORY);\n"),l=(0,o.default)("\n  (function (PARAMS) {\n    BODY;\n  })\n");e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{inherits:r(199),visitor:(0,i.default)({operator:"**",build:function(e,r){return t.callExpression(t.memberExpression(t.identifier("Math"),t.identifier("pow")),[e,r])}})}};var n=r(316),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";e.exports={default:r(406),__esModule:!0}},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t,r){for(var n=I.scope.get(e.node)||[],i=n,s=Array.isArray(i),a=0,i=s?i:(0,y.default)(i);;){var o;if(s){if(a>=i.length)break;o=i[a++]}else{if(a=i.next(),a.done)break;o=a.value}var u=o;if(u.parent===t&&u.path===e)return u}n.push(r),I.scope.has(e.node)||I.scope.set(e.node,n)}function a(e,t){if(R.isModuleDeclaration(e))if(e.source)a(e.source,t);else if(e.specifiers&&e.specifiers.length)for(var r=e.specifiers,n=Array.isArray(r),i=0,r=n?r:(0,y.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var o=s;a(o,t)}else e.declaration&&a(e.declaration,t);else if(R.isModuleSpecifier(e))a(e.local,t);else if(R.isMemberExpression(e))a(e.object,t),a(e.property,t);else if(R.isIdentifier(e))t.push(e.name);else if(R.isLiteral(e))t.push(e.value);else if(R.isCallExpression(e))a(e.callee,t);else if(R.isObjectExpression(e)||R.isObjectPattern(e))for(var u=e.properties,l=Array.isArray(u),c=0,u=l?u:(0,y.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;a(p.key||p.argument,t)}}t.__esModule=!0;var o=r(14),u=i(o),l=r(9),c=i(l),f=r(133),p=i(f),d=r(3),h=i(d),m=r(2),y=i(m),v=r(111),g=i(v),b=r(278),E=i(b),x=r(383),A=i(x),S=r(7),_=i(S),D=r(273),C=i(D),w=r(20),P=n(w),k=r(225),F=i(k),T=r(463),O=i(T),B=r(1),R=n(B),I=r(88),M=0,N={For:function(e){for(var t=R.FOR_INIT_KEYS,r=Array.isArray(t),n=0,t=r?t:(0,y.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i,a=e.get(s);a.isVar()&&e.scope.getFunctionParent().registerBinding("var",a)}},Declaration:function(e){e.isBlockScoped()||e.isExportDeclaration()&&e.get("declaration").isDeclaration()||e.scope.getFunctionParent().registerDeclaration(e)},ReferencedIdentifier:function(e,t){t.references.push(e)},ForXStatement:function(e,t){var r=e.get("left");(r.isPattern()||r.isIdentifier())&&t.constantViolations.push(r)},ExportDeclaration:{exit:function(e){var t=e.node,r=e.scope,n=t.declaration;if(R.isClassDeclaration(n)||R.isFunctionDeclaration(n)){var i=n.id;if(!i)return;var s=r.getBinding(i.name);s&&s.reference(e)}else if(R.isVariableDeclaration(n))for(var a=n.declarations,o=Array.isArray(a),u=0,a=o?a:(0,y.default)(a);;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l,f=R.getBindingIdentifiers(c);for(var p in f){var d=r.getBinding(p);d&&d.reference(e)}}}},LabeledStatement:function(e){e.scope.getProgramParent().addGlobal(e.node),e.scope.getBlockParent().registerDeclaration(e)},AssignmentExpression:function(e,t){t.assignments.push(e)},UpdateExpression:function(e,t){t.constantViolations.push(e.get("argument"))},UnaryExpression:function(e,t){"delete"===e.node.operator&&t.constantViolations.push(e.get("argument"))},BlockScoped:function(e){var t=e.scope;t.path===e&&(t=t.parent),t.getBlockParent().registerDeclaration(e)},ClassDeclaration:function(e){var t=e.node.id;if(t){var r=t.name;e.scope.bindings[r]=e.scope.getBinding(r)}},Block:function(e){for(var t=e.get("body"),r=t,n=Array.isArray(r),i=0,r=n?r:(0,y.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;a.isFunctionDeclaration()&&e.scope.getBlockParent().registerDeclaration(a)}}},L=0,j=function(){function e(t,r){if((0,h.default)(this,e),r&&r.block===t.node)return r;var n=s(t,r,this);if(n)return n;this.uid=L++,this.parent=r,this.hub=t.hub,this.parentBlock=t.parent,this.block=t.node,this.path=t,this.labels=new p.default}return e.prototype.traverse=function(e,t,r){(0,_.default)(e,t,this,r,this.path)},e.prototype.generateDeclaredUidIdentifier=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"temp",t=this.generateUidIdentifier(e);return this.push({id:t}),t},e.prototype.generateUidIdentifier=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"temp";return R.identifier(this.generateUid(e))},e.prototype.generateUid=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"temp";e=R.toIdentifier(e).replace(/^_+/,"").replace(/[0-9]+$/g,"");var t=void 0,r=0;do{t=this._generateUid(e,r),r++}while(this.hasLabel(t)||this.hasBinding(t)||this.hasGlobal(t)||this.hasReference(t));var n=this.getProgramParent();return n.references[t]=!0,n.uids[t]=!0,t},e.prototype._generateUid=function(e,t){var r=e;return t>1&&(r+=t),"_"+r},e.prototype.generateUidIdentifierBasedOnNode=function(e,t){var r=e;R.isAssignmentExpression(e)?r=e.left:R.isVariableDeclarator(e)?r=e.id:(R.isObjectProperty(r)||R.isObjectMethod(r))&&(r=r.key);var n=[];a(r,n);var i=n.join("$");return i=i.replace(/^_/,"")||t||"ref",this.generateUidIdentifier(i.slice(0,20))},e.prototype.isStatic=function(e){if(R.isThisExpression(e)||R.isSuper(e))return!0;if(R.isIdentifier(e)){var t=this.getBinding(e.name);return t?t.constant:this.hasBinding(e.name)}return!1},e.prototype.maybeGenerateMemoised=function(e,t){if(this.isStatic(e))return null;var r=this.generateUidIdentifierBasedOnNode(e);return t||this.push({id:r}),r},e.prototype.checkBlockScopedCollisions=function(e,t,r,n){if("param"!==t&&("hoisted"!==t||"let"!==e.kind)){if("let"===t||"let"===e.kind||"const"===e.kind||"module"===e.kind||"param"===e.kind&&("let"===t||"const"===t))throw this.hub.file.buildCodeFrameError(n,P.get("scopeDuplicateDeclaration",r),TypeError)}},e.prototype.rename=function(e,t,r){var n=this.getBinding(e);if(n)return t=t||this.generateUidIdentifier(e).name,new A.default(n,e,t).rename(r)},e.prototype._renameFromMap=function(e,t,r,n){e[t]&&(e[r]=n,e[t]=null)},e.prototype.dump=function(){var e=(0,E.default)("-",60);console.log(e);var t=this;do{console.log("#",t.block.type);for(var r in t.bindings){var n=t.bindings[r];console.log(" -",r,{constant:n.constant,references:n.references,violations:n.constantViolations.length,kind:n.kind})}}while(t=t.parent);console.log(e)},e.prototype.toArray=function(e,t){var r=this.hub.file;if(R.isIdentifier(e)){var n=this.getBinding(e.name);if(n&&n.constant&&n.path.isGenericType("Array"))return e}if(R.isArrayExpression(e))return e;if(R.isIdentifier(e,{name:"arguments"}))return R.callExpression(R.memberExpression(R.memberExpression(R.memberExpression(R.identifier("Array"),R.identifier("prototype")),R.identifier("slice")),R.identifier("call")),[e]);var i="toArray",s=[e];return!0===t?i="toConsumableArray":t&&(s.push(R.numericLiteral(t)),i="slicedToArray"),R.callExpression(r.addHelper(i),s)},e.prototype.hasLabel=function(e){return!!this.getLabel(e)},e.prototype.getLabel=function(e){return this.labels.get(e)},e.prototype.registerLabel=function(e){this.labels.set(e.node.label.name,e)},e.prototype.registerDeclaration=function(e){if(e.isLabeledStatement())this.registerLabel(e);else if(e.isFunctionDeclaration())this.registerBinding("hoisted",e.get("id"),e);else if(e.isVariableDeclaration())for(var t=e.get("declarations"),r=t,n=Array.isArray(r),i=0,r=n?r:(0,y.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;this.registerBinding(e.node.kind,a)}else if(e.isClassDeclaration())this.registerBinding("let",e);else if(e.isImportDeclaration())for(var o=e.get("specifiers"),u=o,l=Array.isArray(u),c=0,u=l?u:(0,y.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;this.registerBinding("module",p)}else if(e.isExportDeclaration()){var d=e.get("declaration");(d.isClassDeclaration()||d.isFunctionDeclaration()||d.isVariableDeclaration())&&this.registerDeclaration(d)}else this.registerBinding("unknown",e)},e.prototype.buildUndefinedNode=function(){return this.hasBinding("undefined")?R.unaryExpression("void",R.numericLiteral(0),!0):R.identifier("undefined")},e.prototype.registerConstantViolation=function(e){var t=e.getBindingIdentifiers();for(var r in t){var n=this.getBinding(r);n&&n.reassign(e)}},e.prototype.registerBinding=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;if(!e)throw new ReferenceError("no `kind`");if(t.isVariableDeclaration())for(var n=t.get("declarations"),i=n,s=Array.isArray(i),a=0,i=s?i:(0,y.default)(i);;){var o;if(s){if(a>=i.length)break;o=i[a++]}else{if(a=i.next(),a.done)break;o=a.value}var u=o;this.registerBinding(e,u)}else{var l=this.getProgramParent(),c=t.getBindingIdentifiers(!0);for(var f in c)for(var p=c[f],d=Array.isArray(p),h=0,p=d?p:(0,y.default)(p);;){var m;if(d){if(h>=p.length)break;m=p[h++]}else{if(h=p.next(),h.done)break;m=h.value}var v=m,g=this.getOwnBinding(f);if(g){if(g.identifier===v)continue;this.checkBlockScopedCollisions(g,e,f,v)}g&&g.path.isFlow()&&(g=null),l.references[f]=!0,this.bindings[f]=new F.default({identifier:v,existing:g,scope:this,path:r,kind:e})}}},e.prototype.addGlobal=function(e){this.globals[e.name]=e},e.prototype.hasUid=function(e){var t=this;do{if(t.uids[e])return!0}while(t=t.parent);return!1},e.prototype.hasGlobal=function(e){var t=this;do{if(t.globals[e])return!0}while(t=t.parent);return!1},e.prototype.hasReference=function(e){var t=this;do{if(t.references[e])return!0}while(t=t.parent);return!1},e.prototype.isPure=function(e,t){if(R.isIdentifier(e)){var r=this.getBinding(e.name);return!!r&&(!t||r.constant)}if(R.isClass(e))return!(e.superClass&&!this.isPure(e.superClass,t))&&this.isPure(e.body,t);if(R.isClassBody(e)){for(var n=e.body,i=Array.isArray(n),s=0,n=i?n:(0,y.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;if(!this.isPure(o,t))return!1}return!0}if(R.isBinary(e))return this.isPure(e.left,t)&&this.isPure(e.right,t);if(R.isArrayExpression(e)){for(var u=e.elements,l=Array.isArray(u),c=0,u=l?u:(0,y.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;if(!this.isPure(p,t))return!1}return!0}if(R.isObjectExpression(e)){for(var d=e.properties,h=Array.isArray(d),m=0,d=h?d:(0,y.default)(d);;){var v;if(h){if(m>=d.length)break;v=d[m++]}else{if(m=d.next(),m.done)break;v=m.value}var g=v;if(!this.isPure(g,t))return!1}return!0}return R.isClassMethod(e)?!(e.computed&&!this.isPure(e.key,t))&&("get"!==e.kind&&"set"!==e.kind):R.isClassProperty(e)||R.isObjectProperty(e)?!(e.computed&&!this.isPure(e.key,t))&&this.isPure(e.value,t):R.isUnaryExpression(e)?this.isPure(e.argument,t):R.isPureish(e)},e.prototype.setData=function(e,t){return this.data[e]=t},e.prototype.getData=function(e){var t=this;do{var r=t.data[e];if(null!=r)return r}while(t=t.parent)},e.prototype.removeData=function(e){var t=this;do{null!=t.data[e]&&(t.data[e]=null)}while(t=t.parent)},e.prototype.init=function(){this.references||this.crawl()},e.prototype.crawl=function(){M++,this._crawl(),M--},e.prototype._crawl=function(){var e=this.path;if(this.references=(0,c.default)(null),this.bindings=(0,c.default)(null),this.globals=(0,c.default)(null),this.uids=(0,c.default)(null),this.data=(0,c.default)(null),e.isLoop())for(var t=R.FOR_INIT_KEYS,r=Array.isArray(t),n=0,t=r?t:(0,y.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i,a=e.get(s);a.isBlockScoped()&&this.registerBinding(a.node.kind,a)}if(e.isFunctionExpression()&&e.has("id")&&(e.get("id").node[R.NOT_LOCAL_BINDING]||this.registerBinding("local",e.get("id"),e)),e.isClassExpression()&&e.has("id")&&(e.get("id").node[R.NOT_LOCAL_BINDING]||this.registerBinding("local",e)),e.isFunction())for(var o=e.get("params"),u=o,l=Array.isArray(u),f=0,u=l?u:(0,y.default)(u);;){var p;if(l){if(f>=u.length)break;p=u[f++]}else{if(f=u.next(),f.done)break;p=f.value}var d=p;this.registerBinding("param",d)}if(e.isCatchClause()&&this.registerBinding("let",e),!this.getProgramParent().crawling){var h={references:[],constantViolations:[],assignments:[]};this.crawling=!0,e.traverse(N,h),this.crawling=!1;for(var m=h.assignments,v=Array.isArray(m),g=0,m=v?m:(0,y.default)(m);;){var b;if(v){if(g>=m.length)break;b=m[g++]}else{if(g=m.next(),g.done)break;b=g.value}var E=b,x=E.getBindingIdentifiers(),A=void 0;for(var S in x)E.scope.getBinding(S)||(A=A||E.scope.getProgramParent(),A.addGlobal(x[S]));E.scope.registerConstantViolation(E)}for(var _=h.references,D=Array.isArray(_),C=0,_=D?_:(0,y.default)(_);;){var w;if(D){if(C>=_.length)break;w=_[C++]}else{if(C=_.next(),C.done)break;w=C.value}var P=w,k=P.scope.getBinding(P.node.name);k?k.reference(P):P.scope.getProgramParent().addGlobal(P.node)}for(var F=h.constantViolations,T=Array.isArray(F),O=0,F=T?F:(0,y.default)(F);;){var B;if(T){if(O>=F.length)break;B=F[O++]}else{if(O=F.next(),O.done)break;B=O.value}var I=B;I.scope.registerConstantViolation(I)}}},e.prototype.push=function(e){var t=this.path;t.isBlockStatement()||t.isProgram()||(t=this.getBlockParent().path),t.isSwitchStatement()&&(t=this.getFunctionParent().path),(t.isLoop()||t.isCatchClause()||t.isFunction())&&(R.ensureBlock(t.node),t=t.get("body"));var r=e.unique,n=e.kind||"var",i=null==e._blockHoist?2:e._blockHoist,s="declaration:"+n+":"+i,a=!r&&t.getData(s);if(!a){var o=R.variableDeclaration(n,[]);o._generated=!0,o._blockHoist=i;a=t.unshiftContainer("body",[o])[0],r||t.setData(s,a)}var u=R.variableDeclarator(e.id,e.init);a.node.declarations.push(u),this.registerBinding(n,a.get("declarations").pop())},e.prototype.getProgramParent=function(){var e=this;do{if(e.path.isProgram())return e}while(e=e.parent);throw new Error("We couldn't find a Function or Program...")},e.prototype.getFunctionParent=function(){var e=this;do{if(e.path.isFunctionParent())return e}while(e=e.parent);throw new Error("We couldn't find a Function or Program...")},e.prototype.getBlockParent=function(){var e=this;do{if(e.path.isBlockParent())return e}while(e=e.parent);throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")},e.prototype.getAllBindings=function(){var e=(0,c.default)(null),t=this;do{(0,C.default)(e,t.bindings),t=t.parent}while(t);return e},e.prototype.getAllBindingsOfKind=function(){for(var e=(0,c.default)(null),t=arguments,r=Array.isArray(t),n=0,t=r?t:(0,y.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i,a=this;do{for(var o in a.bindings){var u=a.bindings[o];u.kind===s&&(e[o]=u)}a=a.parent}while(a)}return e},e.prototype.bindingIdentifierEquals=function(e,t){
return this.getBindingIdentifier(e)===t},e.prototype.warnOnFlowBinding=function(e){return 0===M&&e&&e.path.isFlow()&&console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 7. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      "),e},e.prototype.getBinding=function(e){var t=this;do{var r=t.getOwnBinding(e);if(r)return this.warnOnFlowBinding(r)}while(t=t.parent)},e.prototype.getOwnBinding=function(e){return this.warnOnFlowBinding(this.bindings[e])},e.prototype.getBindingIdentifier=function(e){var t=this.getBinding(e);return t&&t.identifier},e.prototype.getOwnBindingIdentifier=function(e){var t=this.bindings[e];return t&&t.identifier},e.prototype.hasOwnBinding=function(e){return!!this.getOwnBinding(e)},e.prototype.hasBinding=function(t,r){return!!t&&(!!this.hasOwnBinding(t)||(!!this.parentHasBinding(t,r)||(!!this.hasUid(t)||(!(r||!(0,g.default)(e.globals,t))||!(r||!(0,g.default)(e.contextVariables,t))))))},e.prototype.parentHasBinding=function(e,t){return this.parent&&this.parent.hasBinding(e,t)},e.prototype.moveBindingTo=function(e,t){var r=this.getBinding(e);r&&(r.scope.removeOwnBinding(e),r.scope=t,t.bindings[e]=r)},e.prototype.removeOwnBinding=function(e){delete this.bindings[e]},e.prototype.removeBinding=function(e){var t=this.getBinding(e);t&&t.scope.removeOwnBinding(e);var r=this;do{r.uids[e]&&(r.uids[e]=!1)}while(r=r.parent)},e}();j.globals=(0,u.default)(O.default.builtin),j.contextVariables=["arguments","undefined","Infinity","NaN"],t.default=j,e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.NOT_LOCAL_BINDING=t.BLOCK_SCOPED_SYMBOL=t.INHERIT_KEYS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.NUMBER_UNARY_OPERATORS=t.BOOLEAN_UNARY_OPERATORS=t.BINARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.EQUALITY_BINARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.UPDATE_OPERATORS=t.LOGICAL_OPERATORS=t.COMMENT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.STATEMENT_OR_BLOCK_KEYS=void 0;var n=r(362),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=(t.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"],t.FLATTENABLE_KEYS=["body","expressions"],t.FOR_INIT_KEYS=["left","init"],t.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"],t.LOGICAL_OPERATORS=["||","&&"],t.UPDATE_OPERATORS=["++","--"],t.BOOLEAN_NUMBER_BINARY_OPERATORS=[">","<",">=","<="]),a=t.EQUALITY_BINARY_OPERATORS=["==","===","!=","!=="],o=t.COMPARISON_BINARY_OPERATORS=[].concat(a,["in","instanceof"]),u=t.BOOLEAN_BINARY_OPERATORS=[].concat(o,s),l=t.NUMBER_BINARY_OPERATORS=["-","/","%","*","**","&","|",">>",">>>","<<","^"],c=(t.BINARY_OPERATORS=["+"].concat(l,u),t.BOOLEAN_UNARY_OPERATORS=["delete","!"]),f=t.NUMBER_UNARY_OPERATORS=["+","-","++","--","~"],p=t.STRING_UNARY_OPERATORS=["typeof"];t.UNARY_OPERATORS=["void"].concat(c,f,p),t.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]},t.BLOCK_SCOPED_SYMBOL=(0,i.default)("var used to be block scoped"),t.NOT_LOCAL_BINDING=(0,i.default)("should not be considered a local binding")},function(e,t){"use strict";e.exports=function(e,t,r,n){if(!(e instanceof t)||void 0!==n&&n in e)throw TypeError(r+": incorrect invocation!");return e}},function(e,t,r){"use strict";var n=r(43),i=r(142),s=r(94),a=r(153),o=r(422);e.exports=function(e,t){var r=1==e,u=2==e,l=3==e,c=4==e,f=6==e,p=5==e||f,d=t||o;return function(t,o,h){for(var m,y,v=s(t),g=i(v),b=n(o,h,3),E=a(g.length),x=0,A=r?d(t,E):u?d(t,0):void 0;E>x;x++)if((p||x in g)&&(m=g[x],y=b(m,x,v),e))if(r)A[x]=y;else if(y)switch(e){case 3:return!0;case 5:return m;case 6:return x;case 2:A.push(m)}else if(c)return!1;return f?-1:l||c?c:A}}},function(e,t){"use strict";var r={}.toString;e.exports=function(e){return r.call(e).slice(8,-1)}},function(e,t,r){"use strict";var n=r(15),i=r(12),s=r(57),a=r(27),o=r(29),u=r(146),l=r(55),c=r(136),f=r(16),p=r(93),d=r(23).f,h=r(137)(0),m=r(22);e.exports=function(e,t,r,y,v,g){var b=n[e],E=b,x=v?"set":"add",A=E&&E.prototype,S={};return m&&"function"==typeof E&&(g||A.forEach&&!a(function(){(new E).entries().next()}))?(E=t(function(t,r){c(t,E,e,"_c"),t._c=new b,void 0!=r&&l(r,v,t[x],t)}),h("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","),function(e){var t="add"==e||"set"==e;e in A&&(!g||"clear"!=e)&&o(E.prototype,e,function(r,n){if(c(this,E,e),!t&&g&&!f(r))return"get"==e&&void 0;var i=this._c[e](0===r?0:r,n);return t?this:i})}),g||d(E.prototype,"size",{get:function(){return this._c.size}})):(E=y.getConstructor(t,e,v,x),u(E.prototype,r),s.NEED=!0),p(E,e),S[e]=E,i(i.G+i.W+i.F,S),g||y.setStrong(E,e,v),E}},function(e,t){"use strict";e.exports=function(e){if(void 0==e)throw TypeError("Can't call method on  "+e);return e}},function(e,t){"use strict";e.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(e,t,r){"use strict";var n=r(138);e.exports=Object("z").propertyIsEnumerable(0)?Object:function(e){return"String"==n(e)?e.split(""):Object(e)}},function(e,t,r){"use strict";var n=r(144),i=r(12),s=r(147),a=r(29),o=r(28),u=r(56),l=r(429),c=r(93),f=r(433),p=r(13)("iterator"),d=!([].keys&&"next"in[].keys()),h=function(){return this};e.exports=function(e,t,r,m,y,v,g){l(r,t,m);var b,E,x,A=function(e){if(!d&&e in C)return C[e];switch(e){case"keys":case"values":return function(){return new r(this,e)}}return function(){return new r(this,e)}},S=t+" Iterator",_="values"==y,D=!1,C=e.prototype,w=C[p]||C["@@iterator"]||y&&C[y],P=w||A(y),k=y?_?A("entries"):P:void 0,F="Array"==t?C.entries||w:w;if(F&&(x=f(F.call(new e)))!==Object.prototype&&x.next&&(c(x,S,!0),n||o(x,p)||a(x,p,h)),_&&w&&"values"!==w.name&&(D=!0,P=function(){return w.call(this)}),n&&!g||!d&&!D&&C[p]||a(C,p,P),u[t]=P,u[S]=h,y)if(b={values:_?P:A("values"),keys:v?P:A("keys"),entries:k},g)for(E in b)E in C||s(C,E,b[E]);else i(i.P+i.F*(d||D),t,b);return b}},function(e,t){"use strict";e.exports=!0},function(e,t){"use strict";t.f=Object.getOwnPropertySymbols},function(e,t,r){"use strict";var n=r(29);e.exports=function(e,t,r){for(var i in t)r&&e[i]?e[i]=t[i]:n(e,i,t[i]);return e}},function(e,t,r){"use strict";e.exports=r(29)},function(e,t,r){"use strict";var n=r(12),i=r(227),s=r(43),a=r(55);e.exports=function(e){n(n.S,e,{from:function(e){var t,r,n,o,u=arguments[1];return i(this),t=void 0!==u,t&&i(u),void 0==e?new this:(r=[],t?(n=0,o=s(u,arguments[2],2),a(e,!1,function(e){r.push(o(e,n++))})):a(e,!1,r.push,r),new this(r))}})}},function(e,t,r){"use strict";var n=r(12);e.exports=function(e){n(n.S,e,{of:function(){for(var e=arguments.length,t=Array(e);e--;)t[e]=arguments[e];return new this(t)}})}},function(e,t,r){"use strict";var n=r(151)("keys"),i=r(95);e.exports=function(e){return n[e]||(n[e]=i(e))}},function(e,t,r){"use strict";var n=r(15),i=n["__core-js_shared__"]||(n["__core-js_shared__"]={});e.exports=function(e){return i[e]||(i[e]={})}},function(e,t){"use strict";var r=Math.ceil,n=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?n:r)(e)}},function(e,t,r){"use strict";var n=r(152),i=Math.min;e.exports=function(e){return e>0?i(n(e),9007199254740991):0}},function(e,t,r){"use strict";var n=r(16);e.exports=function(e,t){if(!n(e))return e;var r,i;if(t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;if("function"==typeof(r=e.valueOf)&&!n(i=r.call(e)))return i;if(!t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;throw TypeError("Can't convert object to primitive value")}},function(e,t,r){"use strict";var n=r(15),i=r(5),s=r(144),a=r(156),o=r(23).f;e.exports=function(e){var t=i.Symbol||(i.Symbol=s?{}:n.Symbol||{});"_"==e.charAt(0)||e in t||o(t,e,{value:a.f(e)})}},function(e,t,r){"use strict";t.f=r(13)},function(e,t,r){"use strict";var n=r(437)(!0);r(143)(String,"String",function(e){this._t=String(e),this._i=0},function(){var e,t=this._t,r=this._i;return r>=t.length?{value:void 0,done:!0}:(e=n(t,r),this._i+=e.length,{value:e,done:!1})})},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(15),s=r(28),a=r(22),o=r(12),u=r(147),l=r(57).KEY,c=r(27),f=r(151),p=r(93),d=r(95),h=r(13),m=r(156),y=r(155),v=r(430),g=r(425),b=r(232),E=r(21),x=r(37),A=r(154),S=r(92),_=r(90),D=r(432),C=r(235),w=r(23),P=r(44),k=C.f,F=w.f,T=D.f,O=i.Symbol,B=i.JSON,R=B&&B.stringify,I=h("_hidden"),M=h("toPrimitive"),N={}.propertyIsEnumerable,L=f("symbol-registry"),j=f("symbols"),U=f("op-symbols"),V=Object.prototype,G="function"==typeof O,W=i.QObject,Y=!W||!W.prototype||!W.prototype.findChild,q=a&&c(function(){return 7!=_(F({},"a",{get:function(){return F(this,"a",{value:7}).a}})).a})?function(e,t,r){var n=k(V,t);n&&delete V[t],F(e,t,r),n&&e!==V&&F(V,t,n)}:F,K=function(e){var t=j[e]=_(O.prototype);return t._k=e,t},H=G&&"symbol"==n(O.iterator)?function(e){return"symbol"==(void 0===e?"undefined":n(e))}:function(e){return e instanceof O},J=function(e,t,r){return e===V&&J(U,t,r),E(e),t=A(t,!0),E(r),s(j,t)?(r.enumerable?(s(e,I)&&e[I][t]&&(e[I][t]=!1),r=_(r,{enumerable:S(0,!1)})):(s(e,I)||F(e,I,S(1,{})),e[I][t]=!0),q(e,t,r)):F(e,t,r)},X=function(e,t){E(e);for(var r,n=g(t=x(t)),i=0,s=n.length;s>i;)J(e,r=n[i++],t[r]);return e},z=function(e,t){return void 0===t?_(e):X(_(e),t)},$=function(e){var t=N.call(this,e=A(e,!0));return!(this===V&&s(j,e)&&!s(U,e))&&(!(t||!s(this,e)||!s(j,e)||s(this,I)&&this[I][e])||t)},Q=function(e,t){if(e=x(e),t=A(t,!0),e!==V||!s(j,t)||s(U,t)){var r=k(e,t);return!r||!s(j,t)||s(e,I)&&e[I][t]||(r.enumerable=!0),r}},Z=function(e){for(var t,r=T(x(e)),n=[],i=0;r.length>i;)s(j,t=r[i++])||t==I||t==l||n.push(t);return n},ee=function(e){for(var t,r=e===V,n=T(r?U:x(e)),i=[],a=0;n.length>a;)!s(j,t=n[a++])||r&&!s(V,t)||i.push(j[t]);return i};G||(O=function(){if(this instanceof O)throw TypeError("Symbol is not a constructor!");var e=d(arguments.length>0?arguments[0]:void 0),t=function t(r){this===V&&t.call(U,r),s(this,I)&&s(this[I],e)&&(this[I][e]=!1),q(this,e,S(1,r))};return a&&Y&&q(V,e,{configurable:!0,set:t}),K(e)},u(O.prototype,"toString",function(){return this._k}),C.f=Q,w.f=J,r(236).f=D.f=Z,r(91).f=$,r(145).f=ee,a&&!r(144)&&u(V,"propertyIsEnumerable",$,!0),m.f=function(e){return K(h(e))}),o(o.G+o.W+o.F*!G,{Symbol:O});for(var te="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),re=0;te.length>re;)h(te[re++]);for(var ne=P(h.store),ie=0;ne.length>ie;)y(ne[ie++]);o(o.S+o.F*!G,"Symbol",{for:function(e){return s(L,e+="")?L[e]:L[e]=O(e)},keyFor:function(e){if(H(e))return v(L,e);throw TypeError(e+" is not a symbol!")},useSetter:function(){Y=!0},useSimple:function(){Y=!1}}),o(o.S+o.F*!G,"Object",{create:z,defineProperty:J,defineProperties:X,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:ee}),B&&o(o.S+o.F*(!G||c(function(){var e=O();return"[null]"!=R([e])||"{}"!=R({a:e})||"{}"!=R(Object(e))})),"JSON",{stringify:function(e){if(void 0!==e&&!H(e)){for(var t,r,n=[e],i=1;arguments.length>i;)n.push(arguments[i++]);return t=n[1],"function"==typeof t&&(r=t),!r&&b(t)||(t=function(e,t){if(r&&(t=r.call(this,e,t)),!H(t))return t}),n[1]=t,R.apply(B,n)}}}),O.prototype[M]||r(29)(O.prototype,M,O.prototype.valueOf),p(O,"Symbol"),p(Math,"Math",!0),p(i.JSON,"JSON",!0)},function(e,t,r){"use strict";var n=r(38),i=r(17),s=n(i,"Map");e.exports=s},function(e,t,r){"use strict";function n(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}var i=r(551),s=r(552),a=r(553),o=r(554),u=r(555);n.prototype.clear=i,n.prototype.delete=s,n.prototype.get=a,n.prototype.has=o,n.prototype.set=u,e.exports=n},function(e,t){"use strict";function r(e,t){for(var r=-1,n=t.length,i=e.length;++r<n;)e[i+r]=t[r];return e}e.exports=r},function(e,t,r){"use strict";function n(e,t,r){var n=e[t];o.call(e,t)&&s(n,r)&&(void 0!==r||t in e)||i(e,t,r)}var i=r(163),s=r(46),a=Object.prototype,o=a.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e,t,r){"__proto__"==t&&i?i(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r}var i=r(259);e.exports=n},function(e,t,r){"use strict";function n(e,t,r,T,O,B){var R,I=t&S,M=t&_,N=t&D;if(r&&(R=O?r(e,T,O,B):r(e)),void 0!==R)return R;if(!x(e))return e;var L=b(e);if(L){if(R=y(e),!I)return c(e,R)}else{var j=m(e),U=j==w||j==P;if(E(e))return l(e,I);if(j==k||j==C||U&&!O){if(R=M||U?{}:g(e),!I)return M?p(e,u(R,e)):f(e,o(R,e))}else{if(!F[j])return O?e:{};R=v(e,j,n,I)}}B||(B=new i);var V=B.get(e);if(V)return V;B.set(e,R);var G=N?M?h:d:M?keysIn:A,W=L?void 0:G(e);return s(W||e,function(i,s){W&&(s=i,i=e[s]),a(R,s,n(i,t,r,s,e,B))}),R}var i=r(99),s=r(478),a=r(162),o=r(483),u=r(484),l=r(256),c=r(168),f=r(523),p=r(524),d=r(262),h=r(532),m=r(264),y=r(541),v=r(542),g=r(266),b=r(6),E=r(113),x=r(18),A=r(32),S=1,_=2,D=4,C="[object Arguments]",w="[object Function]",P="[object GeneratorFunction]",k="[object Object]",F={};F[C]=F["[object Array]"]=F["[object ArrayBuffer]"]=F["[object DataView]"]=F["[object Boolean]"]=F["[object Date]"]=F["[object Float32Array]"]=F["[object Float64Array]"]=F["[object Int8Array]"]=F["[object Int16Array]"]=F["[object Int32Array]"]=F["[object Map]"]=F["[object Number]"]=F[k]=F["[object RegExp]"]=F["[object Set]"]=F["[object String]"]=F["[object Symbol]"]=F["[object Uint8Array]"]=F["[object Uint8ClampedArray]"]=F["[object Uint16Array]"]=F["[object Uint32Array]"]=!0,F["[object Error]"]=F[w]=F["[object WeakMap]"]=!1,e.exports=n},function(e,t){"use strict";function r(e,t,r,n){for(var i=e.length,s=r+(n?1:-1);n?s--:++s<i;)if(t(e[s],s,e))return s;return-1}e.exports=r},function(e,t,r){"use strict";function n(e,t,r){return t===t?a(e,t,r):i(e,s,r)}var i=r(165),s=r(496),a=r(570);e.exports=n},function(e,t,r){"use strict";function n(e){var t=new e.constructor(e.byteLength);return new i(t).set(new i(e)),t}var i=r(243);e.exports=n},function(e,t){"use strict";function r(e,t){var r=-1,n=e.length;for(t||(t=Array(n));++r<n;)t[r]=e[r];return t}e.exports=r},function(e,t,r){"use strict";var n=r(271),i=n(Object.getPrototypeOf,Object);e.exports=i},function(e,t,r){"use strict";var n=r(479),i=r(279),s=Object.prototype,a=s.propertyIsEnumerable,o=Object.getOwnPropertySymbols,u=o?function(e){return null==e?[]:(e=Object(e),n(o(e),function(t){return a.call(e,t)}))}:i;e.exports=u},function(e,t){"use strict";function r(e,t){return!!(t=null==t?n:t)&&("number"==typeof e||i.test(e))&&e>-1&&e%1==0&&e<t}var n=9007199254740991,i=/^(?:0|[1-9]\d*)$/;e.exports=r},function(e,t,r){"use strict";function n(e,t,r){if(!u(r))return!1;var n=void 0===t?"undefined":i(t);return!!("number"==n?a(r)&&o(t,r.length):"string"==n&&t in r)&&s(r[t],e)}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=r(46),a=r(24),o=r(171),u=r(18);e.exports=n},function(e,t,r){"use strict";function n(e,t){if(s(e))return!1;var r=void 0===e?"undefined":i(e);return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=e&&!a(e))||(u.test(e)||!o.test(e)||null!=t&&e in Object(t))}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=r(6),a=r(62),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,u=/^\w*$/;e.exports=n},function(e,t,r){"use strict";var n=r(162),i=r(31),s=r(103),a=r(24),o=r(105),u=r(32),l=Object.prototype,c=l.hasOwnProperty,f=s(function(e,t){if(o(t)||a(t))return void i(t,u(t),e);for(var r in t)c.call(t,r)&&n(e,r,t[r])});e.exports=f},function(e,t,r){"use strict";function n(e){if(!s(e))return!1;var t=i(e);return t==o||t==u||t==a||t==l}var i=r(30),s=r(18),a="[object AsyncFunction]",o="[object Function]",u="[object GeneratorFunction]",l="[object Proxy]";e.exports=n},function(e,t){"use strict";function r(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=n}var n=9007199254740991;e.exports=r},function(e,t,r){"use strict";var n=r(499),i=r(102),s=r(270),a=s&&s.isTypedArray,o=a?i(a):n;e.exports=o},function(e,t,r){function n(e){return r(i(e))}function i(e){return s[e]||function(){throw new Error("Cannot find module '"+e+"'.")}()}var s={"./index":50,"./index.js":50,"./logger":120,"./logger.js":120,"./metadata":121,"./metadata.js":121,"./options/build-config-chain":51,"./options/build-config-chain.js":51,"./options/config":33,"./options/config.js":33,"./options/index":52,"./options/index.js":52,"./options/option-manager":34,"./options/option-manager.js":34,"./options/parsers":53,"./options/parsers.js":53,"./options/removed":54,"./options/removed.js":54};n.keys=function(){return Object.keys(s)},n.resolve=i,e.exports=n,n.id=178},function(e,t,r){function n(e){return r(i(e))}function i(e){return s[e]||function(){throw new Error("Cannot find module '"+e+"'.")}()}var s={"./build-config-chain":51,"./build-config-chain.js":51,"./config":33,"./config.js":33,"./index":52,"./index.js":52,"./option-manager":34,"./option-manager.js":34,"./parsers":53,"./parsers.js":53,"./removed":54,"./removed.js":54};n.keys=function(){return Object.keys(s)},n.resolve=i,e.exports=n,n.id=179},function(e,t){"use strict";e.exports=function(){return/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return{keyword:e.cyan,capitalized:e.yellow,jsx_tag:e.yellow,punctuator:e.yellow,number:e.magenta,string:e.green,regex:e.magenta,comment:e.grey,invalid:e.white.bgRed.bold,gutter:e.grey,marker:e.red.bold}}function s(e){var t=e.slice(-2),r=t[0],n=t[1],i=(0,o.matchToToken)(e);if("name"===i.type){if(c.default.keyword.isReservedWordES6(i.value))return"keyword";if(h.test(i.value)&&("<"===n[r-1]||"</"==n.substr(r-2,2)))return"jsx_tag";if(i.value[0]!==i.value[0].toLowerCase())return"capitalized"}return"punctuator"===i.type&&m.test(i.value)?"bracket":i.type}function a(e,t){return t.replace(u.default,function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=s(r),a=e[i];return a?r[0].split(d).map(function(e){return a(e)}).join("\n"):r[0]})}t.__esModule=!0,t.default=function(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};r=Math.max(r,0);var s=n.highlightCode&&p.default.supportsColor||n.forceColor,o=p.default;n.forceColor&&(o=new p.default.constructor({enabled:!0}));var u=function(e,t){return s?e(t):t},l=i(o);s&&(e=a(l,e));var c=n.linesAbove||2,f=n.linesBelow||3,h=e.split(d),m=Math.max(t-(c+1),0),y=Math.min(h.length,t+f);t||r||(m=0,y=h.length);var v=String(y).length,g=h.slice(m,y).map(function(e,n){var i=m+1+n,s=(" "+i).slice(-v),a=" "+s+" | ";if(i===t){var o="";if(r){var c=e.slice(0,r-1).replace(/[^\t]/g," ");o=["\n ",u(l.gutter,a.replace(/\d/g," ")),c,u(l.marker,"^")].join("")}return[u(l.marker,">"),u(l.gutter,a),e,o].join("")}return" "+u(l.gutter,a)+e}).join("\n");return s?o.reset(g):g};var o=r(468),u=n(o),l=r(97),c=n(l),f=r(401),p=n(f),d=/\r\n|[\n\r\u2028\u2029]/,h=/^[a-z][\w-]*$/i,m=/^[()\[\]{}]$/;e.exports=t.default},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e){throw new Error("The ("+e+") Babel 5 plugin is being run with Babel 6.")}function a(e,t,r){"function"==typeof t&&(r=t,t={}),t.filename=e,y.default.readFile(e,function(e,n){var i=void 0;if(!e)try{i=F(n,t)}catch(t){e=t}e?r(e):r(null,i)})}function o(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.filename=e,F(y.default.readFileSync(e,"utf8"),t)}t.__esModule=!0,t.transformFromAst=t.transform=t.analyse=t.Pipeline=t.OptionManager=t.traverse=t.types=t.messages=t.util=t.version=t.resolvePreset=t.resolvePlugin=t.template=t.buildExternalHelpers=t.options=t.File=void 0;var u=r(50);Object.defineProperty(t,"File",{enumerable:!0,get:function(){return i(u).default}});var l=r(33);Object.defineProperty(t,"options",{enumerable:!0,get:function(){return i(l).default}});var c=r(295);Object.defineProperty(t,"buildExternalHelpers",{enumerable:!0,get:function(){return i(c).default}});var f=r(4);Object.defineProperty(t,"template",{enumerable:!0,get:function(){return i(f).default}});var p=r(184);Object.defineProperty(t,"resolvePlugin",{enumerable:!0,get:function(){return i(p).default}});var d=r(185);Object.defineProperty(t,"resolvePreset",{enumerable:!0,get:function(){return i(d).default}});var h=r(628);Object.defineProperty(t,"version",{enumerable:!0,get:function(){return h.version}}),t.Plugin=s,t.transformFile=a,t.transformFileSync=o;var m=r(115),y=i(m),v=r(122),g=n(v),b=r(20),E=n(b),x=r(1),A=n(x),S=r(7),_=i(S),D=r(34),C=i(D),w=r(298),P=i(w);t.util=g,t.messages=E,t.types=A,t.traverse=_.default,t.OptionManager=C.default,t.Pipeline=P.default;var k=new P.default,F=(t.analyse=k.analyse.bind(k),t.transform=k.transform.bind(k));t.transformFromAst=k.transformFromAst.bind(k)},function(e,t,r){"use strict";function n(e,t){return e.reduce(function(e,r){return e||(0,s.default)(r,t)},null)}t.__esModule=!0,t.default=n;var i=r(118),s=function(e){return e&&e.__esModule?e:{default:e}}(i);e.exports=t.default},function(e,t,r){(function(n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.cwd();return(0,o.default)((0,l.default)(e),t)}t.__esModule=!0,t.default=s;var a=r(183),o=i(a),u=r(291),l=i(u);e.exports=t.default}).call(t,r(8))},function(e,t,r){(function(n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.cwd();return(0,o.default)((0,l.default)(e),t)}t.__esModule=!0,t.default=s;var a=r(183),o=i(a),u=r(292),l=i(u);e.exports=t.default}).call(t,r(8))},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t,r){var n="  ";if(e&&"string"==typeof e){var i=(0,d.default)(e).indent;i&&" "!==i&&(n=i)}var a={auxiliaryCommentBefore:t.auxiliaryCommentBefore,auxiliaryCommentAfter:t.auxiliaryCommentAfter,shouldPrintComment:t.shouldPrintComment,retainLines:t.retainLines,retainFunctionParens:t.retainFunctionParens,comments:null==t.comments||t.comments,compact:t.compact,minified:t.minified,concise:t.concise,quotes:t.quotes||s(e,r),jsonCompatibleStrings:t.jsonCompatibleStrings,indent:{adjustMultilineComment:!0,style:n,base:0},flowCommaSeparator:t.flowCommaSeparator};return a.minified?(a.compact=!0,a.shouldPrintComment=a.shouldPrintComment||function(){return a.comments}):a.shouldPrintComment=a.shouldPrintComment||function(e){return a.comments||e.indexOf("@license")>=0||e.indexOf("@preserve")>=0},"auto"===a.compact&&(a.compact=e.length>5e5,a.compact&&console.error("[BABEL] "+v.get("codeGeneratorDeopt",t.filename,"500KB"))),a.compact&&(a.indent.adjustMultilineComment=!1),a}function s(e,t){if(!e)return"double";for(var r={single:0,double:0},n=0,i=0;i<t.length;i++){var s=t[i];if("string"===s.type.label){if("'"===e.slice(s.start,s.end)[0]?r.single++:r.double++,++n>=3)break}}return r.single>r.double?"single":"double"}t.__esModule=!0,t.CodeGenerator=void 0;var a=r(3),o=n(a),u=r(42),l=n(u),c=r(41),f=n(c);t.default=function(e,t,r){return new E(e,t,r).generate()};var p=r(459),d=n(p),h=r(313),m=n(h),y=r(20),v=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(y),g=r(312),b=n(g),E=function(e){function t(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments[2];(0,o.default)(this,t);var a=r.tokens||[],u=i(s,n,a),c=n.sourceMaps?new m.default(n,s):null,f=(0,l.default)(this,e.call(this,u,c,a));return f.ast=r,f}return(0,f.default)(t,e),t.prototype.generate=function(){return e.prototype.generate.call(this,this.ast)},t}(b.default);t.CodeGenerator=function(){function e(t,r,n){(0,o.default)(this,e),this._generator=new E(t,r,n)}return e.prototype.generate=function(){return this._generator.generate()},e}()},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e){function t(e,t){var n=r[e];r[e]=n?function(e,r,i){var s=n(e,r,i);return null==s?t(e,r,i):s}:t}for(var r={},n=(0,m.default)(e),i=Array.isArray(n),s=0,n=i?n:(0,d.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a,u=x.FLIPPED_ALIAS_KEYS[o];if(u)for(var l=u,c=Array.isArray(l),f=0,l=c?l:(0,d.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var h=p;t(h,e[o])}else t(o,e[o])}return r}function a(e,t,r,n){var i=e[t.type];return i?i(t,r,n):null}function o(e){return!!x.isCallExpression(e)||!!x.isMemberExpression(e)&&(o(e.object)||!e.computed&&o(e.property))}function u(e,t,r){if(!e)return 0;x.isExpressionStatement(e)&&(e=e.expression);var n=a(S,e,t);if(!n){var i=a(_,e,t);if(i)for(var s=0;s<i.length&&!(n=u(i[s],e,r));s++);}return n&&n[r]||0}function l(e,t){return u(e,t,"before")}function c(e,t){return u(e,t,"after")}function f(e,t,r){return!!t&&(!(!x.isNewExpression(t)||t.callee!==e||!o(e))||a(A,e,t,r))}t.__esModule=!0;var p=r(2),d=i(p),h=r(14),m=i(h);t.needsWhitespace=u,t.needsWhitespaceBefore=l,t.needsWhitespaceAfter=c,t.needsParens=f;var y=r(311),v=i(y),g=r(310),b=n(g),E=r(1),x=n(E),A=s(b),S=s(v.default.nodes),_=s(v.default.list)},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return!v.isClassMethod(e)&&!v.isObjectMethod(e)||"get"!==e.kind&&"set"!==e.kind?"value":e.kind}function s(e,t,r,n,s){var a=v.toKeyAlias(t),o={};if((0,m.default)(e,a)&&(o=e[a]),e[a]=o,o._inherits=o._inherits||[],o._inherits.push(t),o._key=t.key,t.computed&&(o._computed=!0),t.decorators){var u=o.decorators=o.decorators||v.arrayExpression([]);u.elements=u.elements.concat(t.decorators.map(function(e){return e.expression}).reverse())}if(o.value||o.initializer)throw n.buildCodeFrameError(t,"Key conflict with sibling node");var l=void 0,c=void 0;(v.isObjectProperty(t)||v.isObjectMethod(t)||v.isClassMethod(t))&&(l=v.toComputedKey(t,t.key)),v.isObjectProperty(t)||v.isClassProperty(t)?c=t.value:(v.isObjectMethod(t)||v.isClassMethod(t))&&(c=v.functionExpression(null,t.params,t.body,t.generator,t.async),c.returnType=t.returnType);var f=i(t);return r&&"value"===f||(r=f),s&&v.isStringLiteral(l)&&("value"===r||"initializer"===r)&&v.isFunctionExpression(c)&&(c=(0,d.default)({id:l,node:c,scope:s})),c&&(v.inheritsComments(c,t),o[r]=c),o}function a(e){for(var t in e)if(e[t]._computed)return!0;return!1}function o(e){for(var t=v.arrayExpression([]),r=0;r<e.properties.length;r++){var n=e.properties[r],i=n.value;i.properties.unshift(v.objectProperty(v.identifier("key"),v.toComputedKey(n))),t.elements.push(i)}return t}function u(e){var t=v.objectExpression([]);return(0,f.default)(e).forEach(function(r){var n=e[r],i=v.objectExpression([]),s=v.objectProperty(n._key,i,n._computed);(0,f.default)(n).forEach(function(e){var t=n[e];if("_"!==e[0]){var r=t;(v.isClassMethod(t)||v.isClassProperty(t))&&(t=t.value);var s=v.objectProperty(v.identifier(e),t);v.inheritsComments(s,r),v.removeComments(r),i.properties.push(s)}}),t.properties.push(s)}),t}function l(e){return(0,f.default)(e).forEach(function(t){var r=e[t];r.value&&(r.writable=v.booleanLiteral(!0)),r.configurable=v.booleanLiteral(!0),r.enumerable=v.booleanLiteral(!0)}),u(e)}t.__esModule=!0;var c=r(14),f=n(c);t.push=s,t.hasComputed=a,t.toComputedObjectFromClass=o,t.toClassObject=u,t.toDefineObject=l;var p=r(40),d=n(p),h=r(274),m=n(h),y=r(1),v=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(y)},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){for(var t=e.params,r=0;r<t.length;r++){var n=t[r];if(i.isAssignmentPattern(n)||i.isRestElement(n))return r}return t.length};var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"var";e.traverse(o,{kind:r,emit:t})};var s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s),o={Scope:function(e,t){"let"===t.kind&&e.skip()},Function:function(e){e.skip()},VariableDeclaration:function(e,t){if(!t.kind||e.node.kind===t.kind){for(var r=[],n=e.get("declarations"),s=void 0,o=n,u=Array.isArray(o),l=0,o=u?o:(0,i.default)(o);;){var c;if(u){if(l>=o.length)break;c=o[l++]}else{if(l=o.next(),l.done)break;c=l.value}var f=c;s=f.node.id,f.node.init&&r.push(a.expressionStatement(a.assignmentExpression("=",f.node.id,f.node.init)));for(var p in f.getBindingIdentifiers())t.emit(a.identifier(p),p)}e.parentPath.isFor({left:e.node})?e.replaceWith(s):e.replaceWithMultiple(r)}}};e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e,t,r){return 1===r.length&&i.isSpreadElement(r[0])&&i.isIdentifier(r[0].argument,{name:"arguments"})?i.callExpression(i.memberExpression(e,i.identifier("apply")),[t,r[0].argument]):i.callExpression(i.memberExpression(e,i.identifier("call")),[t].concat(r))};var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);e.exports=t.default},function(e,t,r){"use strict";function n(e,t){return u.isRegExpLiteral(e)&&e.flags.indexOf(t)>=0}function i(e,t){var r=e.flags.split("");e.flags.indexOf(t)<0||((0,a.default)(r,t),e.flags=r.join(""))}t.__esModule=!0,t.is=n,t.pullFlag=i;var s=r(277),a=function(e){return e&&e.__esModule?e:{default:e}}(s),o=r(1),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(o)},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return!!v.isSuper(e)&&(!v.isMemberExpression(t,{computed:!1})&&!v.isCallExpression(t,{callee:e}))}function a(e){return v.isMemberExpression(e)&&v.isSuper(e.object)}function o(e,t){var r=t?e:v.memberExpression(e,v.identifier("prototype"));return v.logicalExpression("||",v.memberExpression(r,v.identifier("__proto__")),v.callExpression(v.memberExpression(v.identifier("Object"),v.identifier("getPrototypeOf")),[r]))}t.__esModule=!0;var u=r(3),l=i(u),c=r(10),f=i(c),p=r(191),d=i(p),h=r(20),m=n(h),y=r(1),v=n(y),g=(0,f.default)(),b={Function:function(e){e.inShadow("this")||e.skip()},ReturnStatement:function(e,t){e.inShadow("this")||t.returns.push(e)},ThisExpression:function(e,t){e.node[g]||t.thises.push(e)},enter:function(e,t){var r=t.specHandle;t.isLoose&&(r=t.looseHandle);var n=e.isCallExpression()&&e.get("callee").isSuper(),i=r.call(t,e);i&&(t.hasSuper=!0),n&&t.bareSupers.push(e),!0===i&&e.requeue(),!0!==i&&i&&(Array.isArray(i)?e.replaceWithMultiple(i):e.replaceWith(i))}},E=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];(0,l.default)(this,e),this.forceSuperMemoisation=t.forceSuperMemoisation,this.methodPath=t.methodPath,
this.methodNode=t.methodNode,this.superRef=t.superRef,this.isStatic=t.isStatic,this.hasSuper=!1,this.inClass=r,this.isLoose=t.isLoose,this.scope=this.methodPath.scope,this.file=t.file,this.opts=t,this.bareSupers=[],this.returns=[],this.thises=[]}return e.prototype.getObjectRef=function(){return this.opts.objectRef||this.opts.getObjectRef()},e.prototype.setSuperProperty=function(e,t,r){return v.callExpression(this.file.addHelper("set"),[o(this.getObjectRef(),this.isStatic),r?e:v.stringLiteral(e.name),t,v.thisExpression()])},e.prototype.getSuperProperty=function(e,t){return v.callExpression(this.file.addHelper("get"),[o(this.getObjectRef(),this.isStatic),t?e:v.stringLiteral(e.name),v.thisExpression()])},e.prototype.replace=function(){this.methodPath.traverse(b,this)},e.prototype.getLooseSuperProperty=function(e,t){var r=this.methodNode,n=this.superRef||v.identifier("Function");return t.property===e?void 0:v.isCallExpression(t,{callee:e})?void 0:v.isMemberExpression(t)&&!r.static?v.memberExpression(n,v.identifier("prototype")):n},e.prototype.looseHandle=function(e){var t=e.node;if(e.isSuper())return this.getLooseSuperProperty(t,e.parent);if(e.isCallExpression()){var r=t.callee;if(!v.isMemberExpression(r))return;if(!v.isSuper(r.object))return;return v.appendToMemberExpression(r,v.identifier("call")),t.arguments.unshift(v.thisExpression()),!0}},e.prototype.specHandleAssignmentExpression=function(e,t,r){return"="===r.operator?this.setSuperProperty(r.left.property,r.right,r.left.computed):(e=e||t.scope.generateUidIdentifier("ref"),[v.variableDeclaration("var",[v.variableDeclarator(e,r.left)]),v.expressionStatement(v.assignmentExpression("=",r.left,v.binaryExpression(r.operator[0],e,r.right)))])},e.prototype.specHandle=function(e){var t=void 0,r=void 0,n=void 0,i=e.parent,o=e.node;if(s(o,i))throw e.buildCodeFrameError(m.get("classesIllegalBareSuper"));if(v.isCallExpression(o)){var u=o.callee;if(v.isSuper(u))return;a(u)&&(t=u.property,r=u.computed,n=o.arguments)}else if(v.isMemberExpression(o)&&v.isSuper(o.object))t=o.property,r=o.computed;else{if(v.isUpdateExpression(o)&&a(o.argument)){var l=v.binaryExpression(o.operator[0],o.argument,v.numericLiteral(1));if(o.prefix)return this.specHandleAssignmentExpression(null,e,l);var c=e.scope.generateUidIdentifier("ref");return this.specHandleAssignmentExpression(c,e,l).concat(v.expressionStatement(c))}if(v.isAssignmentExpression(o)&&a(o.left))return this.specHandleAssignmentExpression(null,e,o)}if(t){var f=this.getSuperProperty(t,r);return n?this.optimiseCall(f,n):f}},e.prototype.optimiseCall=function(e,t){var r=v.thisExpression();return r[g]=!0,(0,d.default)(e,r,t)},e}();t.default=E,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=u.default[e];if(!t)throw new ReferenceError("Unknown helper "+e);return t().expression}t.__esModule=!0,t.list=void 0;var s=r(14),a=n(s);t.get=i;var o=r(321),u=n(o);t.list=(0,a.default)(u.default).map(function(e){return e.replace(/^_/,"")}).filter(function(e){return"__esModule"!==e});t.default=i},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("asyncGenerators")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("classConstructorCall")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("classProperties")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("doExpressions")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("exponentiationOperator")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("exportExtensions")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("functionBind")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("objectRestSpread")}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i),a=r(10),o=n(a);t.default=function(e){function t(e){for(var t=e.get("body.body"),r=t,n=Array.isArray(r),i=0,r=n?r:(0,s.default)(r);;){var a;if(n){if(i>=r.length)break;a=r[i++]}else{if(i=r.next(),i.done)break;a=i.value}var o=a;if("constructorCall"===o.node.kind)return o}return null}function n(e,t){var r=t,n=r.node,s=n.id||t.scope.generateUidIdentifier("class");t.parentPath.isExportDefaultDeclaration()&&(t=t.parentPath,t.insertAfter(i.exportDefaultDeclaration(s))),t.replaceWithMultiple(c({CLASS_REF:t.scope.generateUidIdentifier(s.name),CALL_REF:t.scope.generateUidIdentifier(s.name+"Call"),CALL:i.functionExpression(null,e.node.params,e.node.body),CLASS:i.toExpression(n),WRAPPER_REF:s})),e.remove()}var i=e.types,a=(0,o.default)();return{inherits:r(196),visitor:{Class:function(e){if(!e.node[a]){e.node[a]=!0;var r=t(e);r&&n(r,e)}}}}};var u=r(4),l=n(u),c=(0,l.default)("\n  let CLASS_REF = CLASS;\n  var CALL_REF = CALL;\n  var WRAPPER_REF = function (...args) {\n    if (this instanceof WRAPPER_REF) {\n      return Reflect.construct(CLASS_REF, args);\n    } else {\n      return CALL_REF.apply(this, args);\n    }\n  };\n  WRAPPER_REF.__proto__ = CLASS_REF;\n  WRAPPER_REF;\n");e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i);t.default=function(e){var t=e.types,n={Super:function(e){e.parentPath.isCallExpression({callee:e.node})&&this.push(e.parentPath)}},i={ReferencedIdentifier:function(e){this.scope.hasOwnBinding(e.node.name)&&(this.collision=!0,e.skip())}},a=(0,l.default)("\n    Object.defineProperty(REF, KEY, {\n      // configurable is false by default\n      enumerable: true,\n      writable: true,\n      value: VALUE\n    });\n  "),u=function(e,r){var n=r.key,i=r.value,s=r.computed;return a({REF:e,KEY:t.isIdentifier(n)&&!s?t.stringLiteral(n.name):n,VALUE:i||t.identifier("undefined")})},c=function(e,r){var n=r.key,i=r.value,s=r.computed;return t.expressionStatement(t.assignmentExpression("=",t.memberExpression(e,n,s||t.isLiteral(n)),i))};return{inherits:r(197),visitor:{Class:function(e,r){for(var a=r.opts.spec?u:c,l=!!e.node.superClass,f=void 0,p=[],d=e.get("body"),h=d.get("body"),m=Array.isArray(h),y=0,h=m?h:(0,s.default)(h);;){var v;if(m){if(y>=h.length)break;v=h[y++]}else{if(y=h.next(),y.done)break;v=y.value}var g=v;g.isClassProperty()?p.push(g):g.isClassMethod({kind:"constructor"})&&(f=g)}if(p.length){var b=[],E=void 0;e.isClassExpression()||!e.node.id?((0,o.default)(e),E=e.scope.generateUidIdentifier("class")):E=e.node.id;for(var x=[],A=p,S=Array.isArray(A),_=0,A=S?A:(0,s.default)(A);;){var D;if(S){if(_>=A.length)break;D=A[_++]}else{if(_=A.next(),_.done)break;D=_.value}var C=D,w=C.node;if(!(w.decorators&&w.decorators.length>0)&&(r.opts.spec||w.value)){if(w.static)b.push(a(E,w));else{if(!w.value)continue;x.push(a(t.thisExpression(),w))}}}if(x.length){if(!f){var P=t.classMethod("constructor",t.identifier("constructor"),[],t.blockStatement([]));l&&(P.params=[t.restElement(t.identifier("args"))],P.body.body.push(t.returnStatement(t.callExpression(t.super(),[t.spreadElement(t.identifier("args"))]))));f=d.unshiftContainer("body",P)[0]}for(var k={collision:!1,scope:f.scope},F=p,T=Array.isArray(F),O=0,F=T?F:(0,s.default)(F);;){var B;if(T){if(O>=F.length)break;B=F[O++]}else{if(O=F.next(),O.done)break;B=O.value}if(B.traverse(i,k),k.collision)break}if(k.collision){var R=e.scope.generateUidIdentifier("initialiseProps");b.push(t.variableDeclaration("var",[t.variableDeclarator(R,t.functionExpression(null,[],t.blockStatement(x)))])),x=[t.expressionStatement(t.callExpression(t.memberExpression(R,t.identifier("call")),[t.thisExpression()]))]}if(l){var I=[];f.traverse(n,I);for(var M=I,N=Array.isArray(M),L=0,M=N?M:(0,s.default)(M);;){var j;if(N){if(L>=M.length)break;j=M[L++]}else{if(L=M.next(),L.done)break;j=L.value}j.insertAfter(x)}}else f.get("body").unshiftContainer("body",x)}for(var U=p,V=Array.isArray(U),G=0,U=V?U:(0,s.default)(U);;){var W;if(V){if(G>=U.length)break;W=U[G++]}else{if(G=U.next(),G.done)break;W=G.value}W.remove()}b.length&&(e.isClassExpression()?(e.scope.push({id:E}),e.replaceWith(t.assignmentExpression("=",E,e.node))):(e.node.id||(e.node.id=E),e.parentPath.isExportDeclaration()&&(e=e.parentPath)),e.insertAfter(b))}},ArrowFunctionExpression:function(e){var t=e.get("body");if(t.isClassExpression()){t.get("body").get("body").some(function(e){return e.isClassProperty()})&&e.ensureBlock()}}}}};var a=r(40),o=n(a),u=r(4),l=n(u);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(9),s=n(i),a=r(2),o=n(a);t.default=function(e){function t(e){return e.reverse().map(function(e){return e.expression})}function n(e,r,n){var i=[],a=e.node.decorators;if(a){e.node.decorators=null,a=t(a);for(var l=a,c=Array.isArray(l),f=0,l=c?l:(0,o.default)(l);;){var d;if(c){if(f>=l.length)break;d=l[f++]}else{if(f=l.next(),f.done)break;d=f.value}var h=d;i.push(p({CLASS_REF:r,DECORATOR:h}))}}for(var m=(0,s.default)(null),y=e.get("body.body"),v=Array.isArray(y),g=0,y=v?y:(0,o.default)(y);;){var b;if(v){if(g>=y.length)break;b=y[g++]}else{if(g=y.next(),g.done)break;b=g.value}var E=b;if(E.node.decorators){var x=u.toKeyAlias(E.node);m[x]=m[x]||[],m[x].push(E.node),E.remove()}}for(var A in m){m[A]}return i}function i(e){if(e.isClass()){if(e.node.decorators)return!0;for(var t=e.node.body.body,r=Array.isArray(t),n=0,t=r?t:(0,o.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}if(i.decorators)return!0}}else if(e.isObjectExpression())for(var s=e.node.properties,a=Array.isArray(s),u=0,s=a?s:(0,o.default)(s);;){var l;if(a){if(u>=s.length)break;l=s[u++]}else{if(u=s.next(),u.done)break;l=u.value}var c=l;if(c.decorators)return!0}return!1}function a(e){throw e.buildCodeFrameError('Decorators are not officially supported yet in 6.x pending a proposal update.\nHowever, if you need to use them you can install the legacy decorators transform with:\n\nnpm install babel-plugin-transform-decorators-legacy --save-dev\n\nand add the following line to your .babelrc file:\n\n{\n  "plugins": ["transform-decorators-legacy"]\n}\n\nThe repo url is: https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy.\n    ')}var u=e.types;return{inherits:r(125),visitor:{ClassExpression:function(e){if(i(e)){a(e),(0,f.default)(e);var t=e.scope.generateDeclaredUidIdentifier("ref"),r=[];r.push(u.assignmentExpression("=",t,e.node)),r=r.concat(n(e,t,this)),r.push(t),e.replaceWith(u.sequenceExpression(r))}},ClassDeclaration:function(e){if(i(e)){a(e),(0,f.default)(e);var t=e.node.id,r=[];r=r.concat(n(e,t,this).map(function(e){return u.expressionStatement(e)})),r.push(u.expressionStatement(t)),e.insertAfter(r)}},ObjectExpression:function(e){i(e)&&a(e)}}}};var u=r(4),l=n(u),c=r(319),f=n(c),p=(0,l.default)("\n  CLASS_REF = DECORATOR(CLASS_REF) || CLASS_REF;\n");e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{inherits:r(198),visitor:{DoExpression:function(e){var t=e.node.body.body;t.length?e.replaceWithMultiple(t):e.replaceWith(e.scope.buildUndefinedNode())}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var s=r(2),a=i(s),o=r(3),u=i(o),l=r(7),c=r(193),f=i(c),p=r(191),d=i(p),h=r(188),m=n(h),y=r(4),v=i(y),g=r(1),b=n(g),E=(0,v.default)("\n  (function () {\n    super(...arguments);\n  })\n"),x={"FunctionExpression|FunctionDeclaration":function(e){e.is("shadow")||e.skip()},Method:function(e){e.skip()}},A=l.visitors.merge([x,{Super:function(e){if(this.isDerived&&!this.hasBareSuper&&!e.parentPath.isCallExpression({callee:e.node}))throw e.buildCodeFrameError("'super.*' is not allowed before super()")},CallExpression:{exit:function(e){if(e.get("callee").isSuper()&&(this.hasBareSuper=!0,!this.isDerived))throw e.buildCodeFrameError("super() is only allowed in a derived constructor")}},ThisExpression:function(e){if(this.isDerived&&!this.hasBareSuper&&!e.inShadow("this"))throw e.buildCodeFrameError("'this' is not allowed before super()")}}]),S=l.visitors.merge([x,{ThisExpression:function(e){this.superThises.push(e)}}]),_=function(){function e(t,r){(0,u.default)(this,e),this.parent=t.parent,this.scope=t.scope,this.node=t.node,this.path=t,this.file=r,this.clearDescriptors(),this.instancePropBody=[],this.instancePropRefs={},this.staticPropBody=[],this.body=[],this.bareSuperAfter=[],this.bareSupers=[],this.pushedConstructor=!1,this.pushedInherits=!1,this.isLoose=!1,this.superThises=[],this.classId=this.node.id,this.classRef=this.node.id?b.identifier(this.node.id.name):this.scope.generateUidIdentifier("class"),this.superName=this.node.superClass||b.identifier("Function"),this.isDerived=!!this.node.superClass}return e.prototype.run=function(){var e=this,t=this.superName,r=this.file,n=this.body,i=this.constructorBody=b.blockStatement([]);this.constructor=this.buildConstructor();var s=[],a=[];if(this.isDerived&&(a.push(t),t=this.scope.generateUidIdentifierBasedOnNode(t),s.push(t),this.superName=t),this.buildBody(),i.body.unshift(b.expressionStatement(b.callExpression(r.addHelper("classCallCheck"),[b.thisExpression(),this.classRef]))),n=n.concat(this.staticPropBody.map(function(t){return t(e.classRef)})),this.classId&&1===n.length)return b.toExpression(n[0]);n.push(b.returnStatement(this.classRef));var o=b.functionExpression(null,s,b.blockStatement(n));return o.shadow=!0,b.callExpression(o,a)},e.prototype.buildConstructor=function(){var e=b.functionDeclaration(this.classRef,[],this.constructorBody);return b.inherits(e,this.node),e},e.prototype.pushToMap=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"value",n=arguments[3],i=void 0;e.static?(this.hasStaticDescriptors=!0,i=this.staticMutatorMap):(this.hasInstanceDescriptors=!0,i=this.instanceMutatorMap);var s=m.push(i,e,r,this.file,n);return t&&(s.enumerable=b.booleanLiteral(!0)),s},e.prototype.constructorMeMaybe=function(){for(var e=!1,t=this.path.get("body.body"),r=t,n=Array.isArray(r),i=0,r=n?r:(0,a.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}if(e=s.equals("kind","constructor"))break}if(!e){var o=void 0,u=void 0;if(this.isDerived){var l=E().expression;o=l.params,u=l.body}else o=[],u=b.blockStatement([]);this.path.get("body").unshiftContainer("body",b.classMethod("constructor",b.identifier("constructor"),o,u))}},e.prototype.buildBody=function(){if(this.constructorMeMaybe(),this.pushBody(),this.verifyConstructor(),this.userConstructor){var e=this.constructorBody;e.body=e.body.concat(this.userConstructor.body.body),b.inherits(this.constructor,this.userConstructor),b.inherits(e,this.userConstructor.body)}this.pushDescriptors()},e.prototype.pushBody=function(){for(var e=this.path.get("body.body"),t=e,r=Array.isArray(t),n=0,t=r?t:(0,a.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i,o=s.node;if(s.isClassProperty())throw s.buildCodeFrameError("Missing class properties transform.");if(o.decorators)throw s.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");if(b.isClassMethod(o)){var u="constructor"===o.kind;if(u&&(s.traverse(A,this),!this.hasBareSuper&&this.isDerived))throw s.buildCodeFrameError("missing super() call in constructor");var l=new f.default({forceSuperMemoisation:u,methodPath:s,methodNode:o,objectRef:this.classRef,superRef:this.superName,isStatic:o.static,isLoose:this.isLoose,scope:this.scope,file:this.file},!0);l.replace(),u?this.pushConstructor(l,o,s):this.pushMethod(o,s)}}},e.prototype.clearDescriptors=function(){this.hasInstanceDescriptors=!1,this.hasStaticDescriptors=!1,this.instanceMutatorMap={},this.staticMutatorMap={}},e.prototype.pushDescriptors=function(){this.pushInherits();var e=this.body,t=void 0,r=void 0;if(this.hasInstanceDescriptors&&(t=m.toClassObject(this.instanceMutatorMap)),this.hasStaticDescriptors&&(r=m.toClassObject(this.staticMutatorMap)),t||r){t&&(t=m.toComputedObjectFromClass(t)),r&&(r=m.toComputedObjectFromClass(r));var n=b.nullLiteral(),i=[this.classRef,n,n,n,n];t&&(i[1]=t),r&&(i[2]=r),this.instanceInitializersId&&(i[3]=this.instanceInitializersId,e.unshift(this.buildObjectAssignment(this.instanceInitializersId))),this.staticInitializersId&&(i[4]=this.staticInitializersId,e.unshift(this.buildObjectAssignment(this.staticInitializersId)));for(var s=0,a=0;a<i.length;a++)i[a]!==n&&(s=a);i=i.slice(0,s+1),e.push(b.expressionStatement(b.callExpression(this.file.addHelper("createClass"),i)))}this.clearDescriptors()},e.prototype.buildObjectAssignment=function(e){return b.variableDeclaration("var",[b.variableDeclarator(e,b.objectExpression([]))])},e.prototype.wrapSuperCall=function(e,t,r,n){var i=e.node;this.isLoose?(i.arguments.unshift(b.thisExpression()),2===i.arguments.length&&b.isSpreadElement(i.arguments[1])&&b.isIdentifier(i.arguments[1].argument,{name:"arguments"})?(i.arguments[1]=i.arguments[1].argument,i.callee=b.memberExpression(t,b.identifier("apply"))):i.callee=b.memberExpression(t,b.identifier("call"))):i=(0,d.default)(b.logicalExpression("||",b.memberExpression(this.classRef,b.identifier("__proto__")),b.callExpression(b.memberExpression(b.identifier("Object"),b.identifier("getPrototypeOf")),[this.classRef])),b.thisExpression(),i.arguments);var s=b.callExpression(this.file.addHelper("possibleConstructorReturn"),[b.thisExpression(),i]),a=this.bareSuperAfter.map(function(e){return e(r)});e.parentPath.isExpressionStatement()&&e.parentPath.container===n.node.body&&n.node.body.length-1===e.parentPath.key?((this.superThises.length||a.length)&&(e.scope.push({id:r}),s=b.assignmentExpression("=",r,s)),a.length&&(s=b.toSequenceExpression([s].concat(a,[r]))),e.parentPath.replaceWith(b.returnStatement(s))):e.replaceWithMultiple([b.variableDeclaration("var",[b.variableDeclarator(r,s)])].concat(a,[b.expressionStatement(r)]))},e.prototype.verifyConstructor=function(){var e=this;if(this.isDerived){var t=this.userConstructorPath,r=t.get("body");t.traverse(S,this);for(var n=!!this.bareSupers.length,i=this.superName||b.identifier("Function"),s=t.scope.generateUidIdentifier("this"),o=this.bareSupers,u=Array.isArray(o),l=0,o=u?o:(0,a.default)(o);;){var c;if(u){if(l>=o.length)break;c=o[l++]}else{if(l=o.next(),l.done)break;c=l.value}var f=c;this.wrapSuperCall(f,i,s,r),n&&f.find(function(e){return e===t||(e.isLoop()||e.isConditional()?(n=!1,!0):void 0)})}for(var p=this.superThises,d=Array.isArray(p),h=0,p=d?p:(0,a.default)(p);;){var m;if(d){if(h>=p.length)break;m=p[h++]}else{if(h=p.next(),h.done)break;m=h.value}m.replaceWith(s)}var y=function(t){return b.callExpression(e.file.addHelper("possibleConstructorReturn"),[s].concat(t||[]))},v=r.get("body");v.length&&!v.pop().isReturnStatement()&&r.pushContainer("body",b.returnStatement(n?s:y()));for(var g=this.superReturns,E=Array.isArray(g),x=0,g=E?g:(0,a.default)(g);;){var A;if(E){if(x>=g.length)break;A=g[x++]}else{if(x=g.next(),x.done)break;A=x.value}var _=A;if(_.node.argument){var D=_.scope.generateDeclaredUidIdentifier("ret");_.get("argument").replaceWithMultiple([b.assignmentExpression("=",D,_.node.argument),y(D)])}else _.get("argument").replaceWith(y())}}},e.prototype.pushMethod=function(e,t){var r=t?t.scope:this.scope;"method"===e.kind&&this._processMethod(e,r)||this.pushToMap(e,!1,null,r)},e.prototype._processMethod=function(){return!1},e.prototype.pushConstructor=function(e,t,r){this.bareSupers=e.bareSupers,this.superReturns=e.returns,r.scope.hasOwnBinding(this.classRef.name)&&r.scope.rename(this.classRef.name);var n=this.constructor;this.userConstructorPath=r,this.userConstructor=t,this.hasConstructor=!0,b.inheritsComments(n,t),n._ignoreUserWhitespace=!0,n.params=t.params,b.inherits(n.body,t.body),n.body.directives=t.body.directives,this._pushConstructor()},e.prototype._pushConstructor=function(){this.pushedConstructor||(this.pushedConstructor=!0,(this.hasInstanceDescriptors||this.hasStaticDescriptors)&&this.pushDescriptors(),this.body.push(this.constructor),this.pushInherits())},e.prototype.pushInherits=function(){this.isDerived&&!this.pushedInherits&&(this.pushedInherits=!0,this.body.unshift(b.expressionStatement(b.callExpression(this.file.addHelper("inherits"),[this.classRef,this.superName]))))},e}();t.default=_,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(9),s=n(i),a=r(2),o=n(a),u=r(10),l=n(u);t.default=function(e){var t=e.types,r=(0,l.default)(),n={"AssignmentExpression|UpdateExpression":function(e){if(!e.node[r]){e.node[r]=!0;var n=e.get(e.isAssignmentExpression()?"left":"argument");if(n.isIdentifier()){var i=n.node.name;if(this.scope.getBinding(i)===e.scope.getBinding(i)){var s=this.exports[i];if(s){var a=e.node,u=e.isUpdateExpression()&&!a.prefix;u&&("++"===a.operator?a=t.binaryExpression("+",a.argument,t.numericLiteral(1)):"--"===a.operator?a=t.binaryExpression("-",a.argument,t.numericLiteral(1)):u=!1);for(var l=s,c=Array.isArray(l),f=0,l=c?l:(0,o.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var d=p;a=this.buildCall(d,a).expression}u&&(a=t.sequenceExpression([a,e.node])),e.replaceWith(a)}}}}}};return{visitor:{CallExpression:function(e,r){if(e.node.callee.type===y){var n=r.contextIdent;e.replaceWith(t.callExpression(t.memberExpression(n,t.identifier("import")),e.node.arguments))}},ReferencedIdentifier:function(e,r){"__moduleName"!=e.node.name||e.scope.hasBinding("__moduleName")||e.replaceWith(t.memberExpression(r.contextIdent,t.identifier("id")))},Program:{enter:function(e,t){t.contextIdent=e.scope.generateUidIdentifier("context")},exit:function(e,r){function i(e,t){p[e]=p[e]||[],p[e].push(t)}function a(e,t,r){var n=void 0;d.forEach(function(t){t.key===e&&(n=t)}),n||d.push(n={key:e,imports:[],exports:[]}),n[t]=n[t].concat(r)}function u(e,r){return t.expressionStatement(t.callExpression(l,[t.stringLiteral(e),r]))}for(var l=e.scope.generateUidIdentifier("export"),c=r.contextIdent,p=(0,s.default)(null),d=[],y=[],v=[],g=[],b=[],E=[],x=e.get("body"),A=!0,S=x,_=Array.isArray(S),D=0,S=_?S:(0,o.default)(S);;){var C;if(_){if(D>=S.length)break;C=S[D++]}else{if(D=S.next(),D.done)break;C=D.value}var w=C;if(w.isExportDeclaration()&&(w=w.get("declaration")),w.isVariableDeclaration()&&"var"!==w.node.kind){A=!1;break}}for(var P=x,k=Array.isArray(P),F=0,P=k?P:(0,o.default)(P);;){var T;if(k){if(F>=P.length)break;T=P[F++]}else{if(F=P.next(),F.done)break;T=F.value}var O=T;if(A&&O.isFunctionDeclaration())y.push(O.node),E.push(O);else if(O.isImportDeclaration()){var B=O.node.source.value;a(B,"imports",O.node.specifiers);for(var R in O.getBindingIdentifiers())O.scope.removeBinding(R),b.push(t.identifier(R));O.remove()}else if(O.isExportAllDeclaration())a(O.node.source.value,"exports",O.node),O.remove();else if(O.isExportDefaultDeclaration()){var I=O.get("declaration");if(I.isClassDeclaration()||I.isFunctionDeclaration()){var M=I.node.id,N=[];M?(N.push(I.node),N.push(u("default",M)),i(M.name,"default")):N.push(u("default",t.toExpression(I.node))),!A||I.isClassDeclaration()?O.replaceWithMultiple(N):(y=y.concat(N),E.push(O))}else O.replaceWith(u("default",I.node))}else if(O.isExportNamedDeclaration()){var L=O.get("declaration");if(L.node){O.replaceWith(L);var j=[],U=void 0;if(O.isFunction()){var V=L.node,G=V.id.name;if(A)i(G,G),y.push(V),y.push(u(G,V.id)),E.push(O);else{var W;W={},W[G]=V.id,U=W}}else U=L.getBindingIdentifiers();for(var Y in U)i(Y,Y),j.push(u(Y,t.identifier(Y)));O.insertAfter(j)}else{var q=O.node.specifiers;if(q&&q.length)if(O.node.source)a(O.node.source.value,"exports",q),O.remove();else{for(var K=[],H=q,J=Array.isArray(H),X=0,H=J?H:(0,o.default)(H);;){var z;if(J){if(X>=H.length)break;z=H[X++]}else{if(X=H.next(),X.done)break;z=X.value}var $=z;K.push(u($.exported.name,$.local)),i($.local.name,$.exported.name)}O.replaceWithMultiple(K)}}}}d.forEach(function(r){for(var n=[],i=e.scope.generateUidIdentifier(r.key),s=r.imports,a=Array.isArray(s),u=0,s=a?s:(0,o.default)(s);;){var c;if(a){if(u>=s.length)break;c=s[u++]}else{if(u=s.next(),u.done)break;c=u.value}var f=c;t.isImportNamespaceSpecifier(f)?n.push(t.expressionStatement(t.assignmentExpression("=",f.local,i))):t.isImportDefaultSpecifier(f)&&(f=t.importSpecifier(f.local,t.identifier("default"))),t.isImportSpecifier(f)&&n.push(t.expressionStatement(t.assignmentExpression("=",f.local,t.memberExpression(i,f.imported))))}if(r.exports.length){var p=e.scope.generateUidIdentifier("exportObj");n.push(t.variableDeclaration("var",[t.variableDeclarator(p,t.objectExpression([]))]));for(var d=r.exports,h=Array.isArray(d),y=0,d=h?d:(0,o.default)(d);;){var b;if(h){if(y>=d.length)break;b=d[y++]}else{if(y=d.next(),y.done)break;b=y.value}var E=b;t.isExportAllDeclaration(E)?n.push(m({KEY:e.scope.generateUidIdentifier("key"),EXPORT_OBJ:p,TARGET:i})):t.isExportSpecifier(E)&&n.push(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(p,E.exported),t.memberExpression(i,E.local))))}n.push(t.expressionStatement(t.callExpression(l,[p])))}g.push(t.stringLiteral(r.key)),v.push(t.functionExpression(null,[i],t.blockStatement(n)))});var Q=this.getModuleName();Q&&(Q=t.stringLiteral(Q)),A&&(0,f.default)(e,function(e){return b.push(e)}),b.length&&y.unshift(t.variableDeclaration("var",b.map(function(e){return t.variableDeclarator(e)}))),e.traverse(n,{exports:p,buildCall:u,scope:e.scope});for(var Z=E,ee=Array.isArray(Z),te=0,Z=ee?Z:(0,o.default)(Z);;){var re;if(ee){if(te>=Z.length)break;re=Z[te++]}else{if(te=Z.next(),te.done)break;re=te.value}re.remove()}e.node.body=[h({SYSTEM_REGISTER:t.memberExpression(t.identifier(r.opts.systemGlobal||"System"),t.identifier("register")),BEFORE_BODY:y,MODULE_NAME:Q,SETTERS:v,SOURCES:g,BODY:e.node.body,EXPORT_IDENTIFIER:l,CONTEXT_IDENTIFIER:c})]}}}}};var c=r(190),f=n(c),p=r(4),d=n(p),h=(0,d.default)('\n  SYSTEM_REGISTER(MODULE_NAME, [SOURCES], function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    "use strict";\n    BEFORE_BODY;\n    return {\n      setters: [SETTERS],\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n'),m=(0,d.default)('\n  for (var KEY in TARGET) {\n    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n'),y="Import";e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e){if(e.isExpressionStatement()){var t=e.get("expression");if(!t.isCallExpression())return!1;if(!t.get("callee").isIdentifier({name:"define"}))return!1;var r=t.get("arguments");return!(3===r.length&&!r.shift().isStringLiteral())&&(2===r.length&&(!!r.shift().isArrayExpression()&&!!r.shift().isFunctionExpression()))}}var i=e.types;return{inherits:r(131),visitor:{Program:{exit:function(e,r){var s=e.get("body").pop();if(t(s)){var l=s.node.expression,c=l.arguments,f=3===c.length?c.shift():null,p=l.arguments[0],d=l.arguments[1],h=r.opts.globals||{},m=p.elements.map(function(e){return"module"===e.value||"exports"===e.value?i.identifier(e.value):i.callExpression(i.identifier("require"),[e])}),y=p.elements.map(function(e){if("module"===e.value)return i.identifier("mod");if("exports"===e.value)return i.memberExpression(i.identifier("mod"),i.identifier("exports"));var t=void 0;if(r.opts.exactGlobals){var s=h[e.value];t=s?s.split(".").reduce(function(e,t){return i.memberExpression(e,i.identifier(t))},i.identifier("global")):i.memberExpression(i.identifier("global"),i.identifier(i.toIdentifier(e.value)))}else{var a=(0,n.basename)(e.value,(0,n.extname)(e.value)),o=h[a]||a;t=i.memberExpression(i.identifier("global"),i.identifier(i.toIdentifier(o)))}return t}),v=f?f.value:this.file.opts.basename,g=i.memberExpression(i.identifier("global"),i.identifier(i.toIdentifier(v))),b=null;if(r.opts.exactGlobals){var E=h[v];if(E){b=[];var x=E.split(".");g=x.slice(1).reduce(function(e,t){return b.push(a({GLOBAL_REFERENCE:e})),i.memberExpression(e,i.identifier(t))},i.memberExpression(i.identifier("global"),i.identifier(x[0])))}}var A=o({BROWSER_ARGUMENTS:y,PREREQUISITE_ASSIGNMENTS:b,GLOBAL_TO_ASSIGN:g});s.replaceWith(u({MODULE_NAME:f,AMD_ARGUMENTS:p,COMMON_ARGUMENTS:m,GLOBAL_EXPORT:A,FUNC:d}))}}}}}};var n=r(19),i=r(4),s=function(e){return e&&e.__esModule?e:{default:e}}(i),a=(0,s.default)("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n"),o=(0,s.default)("\n  var mod = { exports: {} };\n  factory(BROWSER_ARGUMENTS);\n  PREREQUISITE_ASSIGNMENTS\n  GLOBAL_TO_ASSIGN = mod.exports;\n"),u=(0,s.default)('\n  (function (global, factory) {\n    if (typeof define === "function" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== "undefined") {\n      factory(COMMON_ARGUMENTS);\n    } else {\n      GLOBAL_EXPORT\n    }\n  })(this, FUNC);\n');e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e,r,i){var s=e.specifiers[0];if(n.isExportNamespaceSpecifier(s)||n.isExportDefaultSpecifier(s)){var a=e.specifiers.shift(),o=i.generateUidIdentifier(a.exported.name),u=void 0;u=n.isExportNamespaceSpecifier(a)?n.importNamespaceSpecifier(o):n.importDefaultSpecifier(o),r.push(n.importDeclaration([u],e.source)),r.push(n.exportNamedDeclaration(null,[n.exportSpecifier(o,a.exported)])),t(e,r,i)}}var n=e.types;return{inherits:r(200),visitor:{ExportNamedDeclaration:function(e){var r=e.node,n=e.scope,i=[];t(r,i,n),i.length&&(r.specifiers.length>=1&&i.push(r),e.replaceWithMultiple(i))}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){var t=e.types;return{inherits:r(126),visitor:{Program:function(e,t){for(var r=t.file.ast.comments,n=r,s=Array.isArray(n),a=0,n=s?n:(0,i.default)(n);;){var o;if(s){if(a>=n.length)break;o=n[a++]}else{if(a=n.next(),a.done)break;o=a.value}var u=o;u.value.indexOf("@flow")>=0&&(u.value=u.value.replace("@flow",""),u.value.replace(/\*/g,"").trim()||(u.ignore=!0))}},Flow:function(e){e.remove()},ClassProperty:function(e){e.node.variance=null,e.node.typeAnnotation=null,e.node.value||e.remove()},Class:function(e){e.node.implements=null,e.get("body.body").forEach(function(e){e.isClassProperty()&&(e.node.typeAnnotation=null,e.node.value||e.remove())})},AssignmentPattern:function(e){e.node.left.optional=!1},Function:function(e){for(var t=e.node,r=0;r<t.params.length;r++){t.params[r].optional=!1}},TypeCastExpression:function(e){var r=e.node;do{r=r.expression}while(t.isTypeCastExpression(r));e.replaceWith(r)}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e){var t=e.path.getData("functionBind");return t||(t=e.generateDeclaredUidIdentifier("context"),e.path.setData("functionBind",t))}function n(e,t){var r=e.object||e.callee.object;return t.isStatic(r)&&r}function i(e,r){var i=n(e,r);if(i)return i;var a=t(r);return e.object?e.callee=s.sequenceExpression([s.assignmentExpression("=",a,e.object),e.callee]):e.callee.object=s.assignmentExpression("=",a,e.callee.object),a}var s=e.types;return{inherits:r(201),visitor:{CallExpression:function(e){var t=e.node,r=e.scope,n=t.callee;if(s.isBindExpression(n)){var a=i(n,r);t.callee=s.memberExpression(n.callee,s.identifier("call")),t.arguments.unshift(a)}},BindExpression:function(e){
var t=e.node,r=e.scope,n=i(t,r);e.replaceWith(s.callExpression(s.memberExpression(t.callee,s.identifier("bind")),[n]))}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e){var t=!1;return e.traverse({RestProperty:function(){t=!0,e.stop()}}),t}function n(e){for(var t=e.properties,r=Array.isArray(t),n=0,t=r?t:(0,i.default)(t);;){var s;if(r){if(n>=t.length)break;s=t[n++]}else{if(n=t.next(),n.done)break;s=n.value}var a=s;if(o.isSpreadProperty(a))return!0}return!1}function s(e,t,r){for(var n=t.pop(),s=[],a=t,u=Array.isArray(a),l=0,a=u?a:(0,i.default)(a);;){var c;if(u){if(l>=a.length)break;c=a[l++]}else{if(l=a.next(),l.done)break;c=l.value}var f=c,p=f.key;o.isIdentifier(p)&&!f.computed&&(p=o.stringLiteral(f.key.name)),s.push(p)}return[n.argument,o.callExpression(e.addHelper("objectWithoutProperties"),[r,o.arrayExpression(s)])]}function a(e,r,n,i){if(r.isAssignmentPattern())return void a(e,r.get("left"),n,i);if(r.isObjectPattern()&&t(r)){var s=e.scope.generateUidIdentifier("ref"),u=o.variableDeclaration("let",[o.variableDeclarator(r.node,s)]);u._blockHoist=n?i-n:1,e.ensureBlock(),e.get("body").unshiftContainer("body",u),r.replaceWith(s)}}var o=e.types;return{inherits:r(202),visitor:{Function:function(e){for(var t=e.get("params"),r=0;r<t.length;r++)a(t[r].parentPath,t[r],r,t.length)},VariableDeclarator:function(e,t){if(e.get("id").isObjectPattern()){var r=e;e.get("id").traverse({RestProperty:function(e){if(this.originalPath.node.id.properties.length>1&&!o.isIdentifier(this.originalPath.node.init)){var n=e.scope.generateUidIdentifierBasedOnNode(this.originalPath.node.init,"ref");return this.originalPath.insertBefore(o.variableDeclarator(n,this.originalPath.node.init)),void this.originalPath.replaceWith(o.variableDeclarator(this.originalPath.node.id,n))}var i=this.originalPath.node.init,a=[];e.findParent(function(e){if(e.isObjectProperty())a.unshift(e.node.key.name);else if(e.isVariableDeclarator())return!0}),a.length&&a.forEach(function(e){i=o.memberExpression(i,o.identifier(e))});var u=s(t,e.parentPath.node.properties,i),l=u[0],c=u[1];r.insertAfter(o.variableDeclarator(l,c)),r=r.getSibling(r.key+1),0===e.parentPath.node.properties.length&&e.findParent(function(e){return e.isObjectProperty()||e.isVariableDeclarator()}).remove()}},{originalPath:e})}},ExportNamedDeclaration:function(e){var r=e.get("declaration");if(r.isVariableDeclaration()&&t(r)){var n=[];for(var i in e.getOuterBindingIdentifiers(e)){var s=o.identifier(i);n.push(o.exportSpecifier(s,s))}e.replaceWith(r.node),e.insertAfter(o.exportNamedDeclaration(null,n))}},CatchClause:function(e){var t=e.get("param");a(t.parentPath,t)},AssignmentExpression:function(e,r){var n=e.get("left");if(n.isObjectPattern()&&t(n)){var i=[],a=void 0;(e.isCompletionRecord()||e.parentPath.isExpressionStatement())&&(a=e.scope.generateUidIdentifierBasedOnNode(e.node.right,"ref"),i.push(o.variableDeclaration("var",[o.variableDeclarator(a,e.node.right)])));var u=s(r,e.node.left.properties,a),l=u[0],c=u[1],f=o.clone(e.node);f.right=a,i.push(o.expressionStatement(f)),i.push(o.toStatement(o.assignmentExpression("=",l,c))),a&&i.push(o.expressionStatement(a)),e.replaceWithMultiple(i)}},ForXStatement:function(e){var r=e.node,n=e.scope,i=e.get("left"),s=r.left;if(o.isObjectPattern(s)&&t(i)){var a=n.generateUidIdentifier("ref");return r.left=o.variableDeclaration("var",[o.variableDeclarator(a)]),e.ensureBlock(),void r.body.body.unshift(o.variableDeclaration("var",[o.variableDeclarator(s,a)]))}if(o.isVariableDeclaration(s)){var u=s.declarations[0].id;if(o.isObjectPattern(u)){var l=n.generateUidIdentifier("ref");r.left=o.variableDeclaration(s.kind,[o.variableDeclarator(l,null)]),e.ensureBlock(),r.body.body.unshift(o.variableDeclaration(r.left.kind,[o.variableDeclarator(u,l)]))}}},ObjectExpression:function(e,t){function r(){u.length&&(a.push(o.objectExpression(u)),u=[])}if(n(e.node)){var s=t.opts.useBuiltIns||!1;if("boolean"!=typeof s)throw new Error("transform-object-rest-spread currently only accepts a boolean option for useBuiltIns (defaults to false)");for(var a=[],u=[],l=e.node.properties,c=Array.isArray(l),f=0,l=c?l:(0,i.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}var d=p;o.isSpreadProperty(d)?(r(),a.push(d.argument)):u.push(d)}r(),o.isObjectExpression(a[0])||a.unshift(o.objectExpression([]));var h=s?o.memberExpression(o.identifier("Object"),o.identifier("assign")):t.addHelper("extends");e.replaceWith(o.callExpression(h,a))}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e,t){for(var r=t.arguments[0].properties,i=!0,s=0;s<r.length;s++){var a=r[s],o=n.toComputedKey(a);if(n.isLiteral(o,{value:"displayName"})){i=!1;break}}i&&r.unshift(n.objectProperty(n.identifier("displayName"),n.stringLiteral(e)))}function r(e){if(!e||!n.isCallExpression(e))return!1;if(!s(e.callee)&&!a(e.callee))return!1;var t=e.arguments;if(1!==t.length)return!1;var r=t[0];return!!n.isObjectExpression(r)}var n=e.types,s=n.buildMatchMemberExpression("React.createClass"),a=function(e){return"createReactClass"===e.name};return{visitor:{ExportDefaultDeclaration:function(e,n){var s=e.node;if(r(s.declaration)){var a=n.file.opts.basename;"index"===a&&(a=i.default.basename(i.default.dirname(n.file.opts.filename))),t(a,s.declaration)}},CallExpression:function(e){var i=e.node;if(r(i)){var s=void 0;e.find(function(e){if(e.isAssignmentExpression())s=e.node.left;else if(e.isObjectProperty())s=e.node.key;else if(e.isVariableDeclarator())s=e.node.id;else if(e.isStatement())return!0;if(s)return!0}),s&&(n.isMemberExpression(s)&&(s=s.property),n.isIdentifier(s)&&t(s.name,i))}}}}};var n=r(19),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i);t.default=function(e){var t=e.types,r=/\*?\s*@jsx\s+([^\s]+)/,n=(0,l.default)({pre:function(e){var r=e.tagName,n=e.args;t.react.isCompatTag(r)?n.push(t.stringLiteral(r)):n.push(e.tagExpr)},post:function(e,t){e.callee=t.get("jsxIdentifier")()}});return n.Program=function(e,n){for(var i=n.file,a=n.opts.pragma||"React.createElement",o=i.ast.comments,u=Array.isArray(o),l=0,o=u?o:(0,s.default)(o);;){var c;if(u){if(l>=o.length)break;c=o[l++]}else{if(l=o.next(),l.done)break;c=l.value}var f=c,p=r.exec(f.value);if(p){if("React.DOM"===(a=p[1]))throw i.buildCodeFrameError(f,"The @jsx React.DOM pragma has been deprecated as of React 0.12");break}}n.set("jsxIdentifier",function(){return a.split(".").map(function(e){return t.identifier(e)}).reduce(function(e,r){return t.memberExpression(e,r)})})},{inherits:o.default,visitor:n}};var a=r(127),o=n(a),u=r(351),l=n(u);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(){return{visitor:{Program:function(e,t){if(!1!==t.opts.strict&&!1!==t.opts.strictMode){for(var r=e.node,n=r.directives,s=Array.isArray(n),o=0,n=s?n:(0,i.default)(n);;){var u;if(s){if(o>=n.length)break;u=n[o++]}else{if(o=n.next(),o.done)break;u=o.value}if("use strict"===u.value.value)return}e.unshiftContainer("directives",a.directive(a.directiveLiteral("use strict")))}}}}};var s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=["commonjs","amd","umd","systemjs"],n=!1,i="commonjs",s=!1;if(void 0!==t&&(void 0!==t.loose&&(n=t.loose),void 0!==t.modules&&(i=t.modules),void 0!==t.spec&&(s=t.spec)),"boolean"!=typeof n)throw new Error("Preset es2015 'loose' option must be a boolean.");if("boolean"!=typeof s)throw new Error("Preset es2015 'spec' option must be a boolean.");if(!1!==i&&-1===r.indexOf(i))throw new Error("Preset es2015 'modules' option must be 'false' to indicate no modules\nor a module type which be be one of: 'commonjs' (default), 'amd', 'umd', 'systemjs'");var o={loose:n};return{plugins:[[a.default,{loose:n,spec:s}],u.default,c.default,[p.default,{spec:s}],h.default,[y.default,o],g.default,E.default,A.default,[_.default,o],[C.default,o],P.default,F.default,O.default,[R.default,o],M.default,[L.default,o],U.default,G.default,"commonjs"===i&&[Y.default,o],"systemjs"===i&&[K.default,o],"amd"===i&&[J.default,o],"umd"===i&&[z.default,o],[Q.default,{async:!1,asyncGenerators:!1}]].filter(Boolean)}}t.__esModule=!0;var s=r(83),a=n(s),o=r(76),u=n(o),l=r(75),c=n(l),f=r(68),p=n(f),d=r(69),h=n(d),m=r(71),y=n(m),v=r(78),g=n(v),b=r(80),E=n(b),x=r(130),A=n(x),S=r(72),_=n(S),D=r(74),C=n(D),w=r(82),P=n(w),k=r(85),F=n(k),T=r(66),O=n(T),B=r(81),R=n(B),I=r(79),M=n(I),N=r(73),L=n(N),j=r(70),U=n(j),V=r(84),G=n(V),W=r(77),Y=n(W),q=r(208),K=n(q),H=r(131),J=n(H),X=r(209),z=n(X),$=r(86),Q=n($),Z=i({});t.default=Z,Object.defineProperty(Z,"buildPreset",{configurable:!0,writable:!0,enumerable:!1,value:i}),e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(132),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default={plugins:[i.default]},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(128),s=n(i),a=r(129),o=n(a);t.default={plugins:[s.default,o.default]},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(221),s=n(i),a=r(203),o=n(a),u=r(210),l=n(u);t.default={presets:[s.default],plugins:[o.default,l.default]},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(222),s=n(i),a=r(204),o=n(a),u=r(205),l=n(u),c=r(324),f=n(c);t.default={presets:[s.default],plugins:[f.default,o.default,l.default]},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(128),s=n(i),a=r(129),o=n(a),u=r(132),l=n(u),c=r(213),f=n(c),p=r(327),d=n(p);t.default={plugins:[s.default,o.default,l.default,d.default,f.default]},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(3),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=function e(t,r){(0,i.default)(this,e),this.file=t,this.options=r};t.default=s,e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.Flow=t.Pure=t.Generated=t.User=t.Var=t.BlockScoped=t.Referenced=t.Scope=t.Expression=t.Statement=t.BindingIdentifier=t.ReferencedMemberExpression=t.ReferencedIdentifier=void 0;var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);t.ReferencedIdentifier={types:["Identifier","JSXIdentifier"],checkPath:function(e,t){var r=e.node,s=e.parent;if(!i.isIdentifier(r,t)&&!i.isJSXMemberExpression(s,t)){if(!i.isJSXIdentifier(r,t))return!1;if(n.react.isCompatTag(r.name))return!1}return i.isReferenced(r,s)}},t.ReferencedMemberExpression={types:["MemberExpression"],checkPath:function(e){var t=e.node,r=e.parent;return i.isMemberExpression(t)&&i.isReferenced(t,r)}},t.BindingIdentifier={types:["Identifier"],checkPath:function(e){var t=e.node,r=e.parent;return i.isIdentifier(t)&&i.isBinding(t,r)}},t.Statement={types:["Statement"],checkPath:function(e){var t=e.node,r=e.parent;if(i.isStatement(t)){if(i.isVariableDeclaration(t)){if(i.isForXStatement(r,{left:t}))return!1;if(i.isForStatement(r,{init:t}))return!1}return!0}return!1}},t.Expression={types:["Expression"],checkPath:function(e){return e.isIdentifier()?e.isReferencedIdentifier():i.isExpression(e.node)}},t.Scope={types:["Scopable"],checkPath:function(e){return i.isScope(e.node,e.parent)}},t.Referenced={checkPath:function(e){return i.isReferenced(e.node,e.parent)}},t.BlockScoped={checkPath:function(e){return i.isBlockScoped(e.node)}},t.Var={types:["VariableDeclaration"],checkPath:function(e){return i.isVar(e.node)}},t.User={checkPath:function(e){return e.node&&!!e.node.loc}},t.Generated={checkPath:function(e){return!e.isUser()}},t.Pure={checkPath:function(e,t){return e.scope.isPure(e.node,t)}},t.Flow={types:["Flow","ImportDeclaration","ExportDeclaration","ImportSpecifier"],checkPath:function(e){var t=e.node;return!!i.isFlow(t)||(i.isImportDeclaration(t)?"type"===t.importKind||"typeof"===t.importKind:i.isExportDeclaration(t)?"type"===t.exportKind:!!i.isImportSpecifier(t)&&("type"===t.importKind||"typeof"===t.importKind))}}},function(e,t,r){"use strict";t.__esModule=!0;var n=r(3),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=function(){function e(t){var r=t.existing,n=t.identifier,s=t.scope,a=t.path,o=t.kind;(0,i.default)(this,e),this.identifier=n,this.scope=s,this.path=a,this.kind=o,this.constantViolations=[],this.constant=!0,this.referencePaths=[],this.referenced=!1,this.references=0,this.clearValue(),r&&(this.constantViolations=[].concat(r.path,r.constantViolations,this.constantViolations))}return e.prototype.deoptValue=function(){this.clearValue(),this.hasDeoptedValue=!0},e.prototype.setValue=function(e){this.hasDeoptedValue||(this.hasValue=!0,this.value=e)},e.prototype.clearValue=function(){this.hasDeoptedValue=!1,this.hasValue=!1,this.value=null},e.prototype.reassign=function(e){this.constant=!1,-1===this.constantViolations.indexOf(e)&&this.constantViolations.push(e)},e.prototype.reference=function(e){-1===this.referencePaths.indexOf(e)&&(this.referenced=!0,this.references++,this.referencePaths.push(e))},e.prototype.dereference=function(){this.references--,this.referenced=!!this.references},e}();t.default=s,e.exports=t.default},function(e,t,r){"use strict";function n(e,t,r){for(var n=[].concat(e),i=(0,a.default)(null);n.length;){var s=n.shift();if(s){var o=u.getBindingIdentifiers.keys[s.type];if(u.isIdentifier(s))if(t){var l=i[s.name]=i[s.name]||[];l.push(s)}else i[s.name]=s;else if(u.isExportDeclaration(s))u.isDeclaration(s.declaration)&&n.push(s.declaration);else{if(r){if(u.isFunctionDeclaration(s)){n.push(s.id);continue}if(u.isFunctionExpression(s))continue}if(o)for(var c=0;c<o.length;c++){var f=o[c];s[f]&&(n=n.concat(s[f]))}}}}return i}function i(e,t){return n(e,t,!0)}t.__esModule=!0;var s=r(9),a=function(e){return e&&e.__esModule?e:{default:e}}(s);t.getBindingIdentifiers=n,t.getOuterBindingIdentifiers=i;var o=r(1),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(o);n.keys={DeclareClass:["id"],DeclareFunction:["id"],DeclareModule:["id"],DeclareVariable:["id"],InterfaceDeclaration:["id"],TypeAlias:["id"],OpaqueType:["id"],CatchClause:["param"],LabeledStatement:["label"],UnaryExpression:["argument"],AssignmentExpression:["left"],ImportSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportDefaultSpecifier:["local"],ImportDeclaration:["specifiers"],ExportSpecifier:["exported"],ExportNamespaceSpecifier:["exported"],ExportDefaultSpecifier:["exported"],FunctionDeclaration:["id","params"],FunctionExpression:["id","params"],ClassDeclaration:["id"],ClassExpression:["id"],RestElement:["argument"],UpdateExpression:["argument"],RestProperty:["argument"],ObjectProperty:["value"],AssignmentPattern:["left"],ArrayPattern:["elements"],ObjectPattern:["properties"],VariableDeclaration:["declarations"],VariableDeclarator:["id"]}},function(e,t){"use strict";e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},function(e,t,r){"use strict";var n=r(138),i=r(13)("toStringTag"),s="Arguments"==n(function(){return arguments}()),a=function(e,t){try{return e[t]}catch(e){}};e.exports=function(e){var t,r,o;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=a(t=Object(e),i))?r:s?n(t):"Object"==(o=n(t))&&"function"==typeof t.callee?"Arguments":o}},function(e,t,r){"use strict";var n=r(146),i=r(57).getWeak,s=r(21),a=r(16),o=r(136),u=r(55),l=r(137),c=r(28),f=r(58),p=l(5),d=l(6),h=0,m=function(e){return e._l||(e._l=new y)},y=function(){this.a=[]},v=function(e,t){return p(e.a,function(e){return e[0]===t})};y.prototype={get:function(e){var t=v(this,e);if(t)return t[1]},has:function(e){return!!v(this,e)},set:function(e,t){var r=v(this,e);r?r[1]=t:this.a.push([e,t])},delete:function(e){var t=d(this.a,function(t){return t[0]===e});return~t&&this.a.splice(t,1),!!~t}},e.exports={getConstructor:function(e,t,r,s){var l=e(function(e,n){o(e,l,t,"_i"),e._t=t,e._i=h++,e._l=void 0,void 0!=n&&u(n,r,e[s],e)});return n(l.prototype,{delete:function(e){if(!a(e))return!1;var r=i(e);return!0===r?m(f(this,t)).delete(e):r&&c(r,this._i)&&delete r[this._i]},has:function(e){if(!a(e))return!1;var r=i(e);return!0===r?m(f(this,t)).has(e):r&&c(r,this._i)}}),l},def:function(e,t,r){var n=i(s(t),!0);return!0===n?m(e).set(t,r):n[e._i]=r,e},ufstore:m}},function(e,t,r){"use strict";var n=r(16),i=r(15).document,s=n(i)&&n(i.createElement);e.exports=function(e){return s?i.createElement(e):{}}},function(e,t,r){"use strict";e.exports=!r(22)&&!r(27)(function(){return 7!=Object.defineProperty(r(230)("div"),"a",{get:function(){return 7}}).a})},function(e,t,r){"use strict";var n=r(138);e.exports=Array.isArray||function(e){return"Array"==n(e)}},function(e,t){"use strict";e.exports=function(e,t){return{value:t,done:!!e}}},function(e,t,r){"use strict";var n=r(44),i=r(145),s=r(91),a=r(94),o=r(142),u=Object.assign;e.exports=!u||r(27)(function(){var e={},t={},r=Symbol(),n="abcdefghijklmnopqrst";return e[r]=7,n.split("").forEach(function(e){t[e]=e}),7!=u({},e)[r]||Object.keys(u({},t)).join("")!=n})?function(e,t){for(var r=a(e),u=arguments.length,l=1,c=i.f,f=s.f;u>l;)for(var p,d=o(arguments[l++]),h=c?n(d).concat(c(d)):n(d),m=h.length,y=0;m>y;)f.call(d,p=h[y++])&&(r[p]=d[p]);return r}:u},function(e,t,r){"use strict";var n=r(91),i=r(92),s=r(37),a=r(154),o=r(28),u=r(231),l=Object.getOwnPropertyDescriptor;t.f=r(22)?l:function(e,t){if(e=s(e),t=a(t,!0),u)try{return l(e,t)}catch(e){}if(o(e,t))return i(!n.f.call(e,t),e[t])}},function(e,t,r){"use strict";var n=r(237),i=r(141).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return n(e,i)}},function(e,t,r){"use strict";var n=r(28),i=r(37),s=r(420)(!1),a=r(150)("IE_PROTO");e.exports=function(e,t){var r,o=i(e),u=0,l=[];for(r in o)r!=a&&n(o,r)&&l.push(r);for(;t.length>u;)n(o,r=t[u++])&&(~s(l,r)||l.push(r));return l}},function(e,t,r){"use strict";var n=r(228),i=r(13)("iterator"),s=r(56);e.exports=r(5).getIteratorMethod=function(e){if(void 0!=e)return e[i]||e["@@iterator"]||s[n(e)]}},function(e,t,r){(function(n){"use strict";function i(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function s(e){var r=this.useColors;if(e[0]=(r?"%c":"")+this.namespace+(r?" %c":" ")+e[0]+(r?"%c ":" ")+"+"+t.humanize(this.diff),r){var n="color: "+this.color;e.splice(1,0,n,"color: inherit");var i=0,s=0;e[0].replace(/%[a-zA-Z%]/g,function(e){"%%"!==e&&(i++,"%c"===e&&(s=i))}),e.splice(s,0,n)}}function a(){return"object"===("undefined"==typeof console?"undefined":l(console))&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function o(e){try{null==e?t.storage.removeItem("debug"):t.storage.debug=e}catch(e){}}function u(){var e;try{e=t.storage.debug}catch(e){}return!e&&void 0!==n&&"env"in n&&(e=n.env.DEBUG),e}var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t=e.exports=r(458),t.log=a,t.formatArgs=s,t.save=o,t.load=u,t.useColors=i,t.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(e){}}(),t.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],t.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},t.enable(u())}).call(t,r(8))},function(e,t){"use strict";!function(){function t(e){return 48<=e&&e<=57}function r(e){return 48<=e&&e<=57||97<=e&&e<=102||65<=e&&e<=70}function n(e){return e>=48&&e<=55}function i(e){return 32===e||9===e||11===e||12===e||160===e||e>=5760&&d.indexOf(e)>=0}function s(e){return 10===e||13===e||8232===e||8233===e}function a(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(Math.floor((e-65536)/1024)+55296)+String.fromCharCode((e-65536)%1024+56320)}function o(e){return e<128?h[e]:p.NonAsciiIdentifierStart.test(a(e))}function u(e){return e<128?m[e]:p.NonAsciiIdentifierPart.test(a(e))}function l(e){return e<128?h[e]:f.NonAsciiIdentifierStart.test(a(e))}function c(e){return e<128?m[e]:f.NonAsciiIdentifierPart.test(a(e))}var f,p,d,h,m,y;for(p={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},f={
NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},d=[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],h=new Array(128),y=0;y<128;++y)h[y]=y>=97&&y<=122||y>=65&&y<=90||36===y||95===y;for(m=new Array(128),y=0;y<128;++y)m[y]=y>=97&&y<=122||y>=65&&y<=90||y>=48&&y<=57||36===y||95===y;e.exports={isDecimalDigit:t,isHexDigit:r,isOctalDigit:n,isWhiteSpace:i,isLineTerminator:s,isIdentifierStartES5:o,isIdentifierPartES5:u,isIdentifierStartES6:l,isIdentifierPartES6:c}}()},function(e,t,r){"use strict";var n=r(38),i=r(17),s=n(i,"Set");e.exports=s},function(e,t,r){"use strict";function n(e){var t=-1,r=null==e?0:e.length;for(this.__data__=new i;++t<r;)this.add(e[t])}var i=r(160),s=r(561),a=r(562);n.prototype.add=n.prototype.push=s,n.prototype.has=a,e.exports=n},function(e,t,r){"use strict";var n=r(17),i=n.Uint8Array;e.exports=i},function(e,t){"use strict";function r(e,t,r){switch(r.length){case 0:return e.call(t);case 1:return e.call(t,r[0]);case 2:return e.call(t,r[0],r[1]);case 3:return e.call(t,r[0],r[1],r[2])}return e.apply(t,r)}e.exports=r},function(e,t,r){"use strict";function n(e,t){var r=a(e),n=!r&&s(e),c=!r&&!n&&o(e),p=!r&&!n&&!c&&l(e),d=r||n||c||p,h=d?i(e.length,String):[],m=h.length;for(var y in e)!t&&!f.call(e,y)||d&&("length"==y||c&&("offset"==y||"parent"==y)||p&&("buffer"==y||"byteLength"==y||"byteOffset"==y)||u(y,m))||h.push(y);return h}var i=r(513),s=r(112),a=r(6),o=r(113),u=r(171),l=r(177),c=Object.prototype,f=c.hasOwnProperty;e.exports=n},function(e,t){"use strict";function r(e,t,r,n){var i=-1,s=null==e?0:e.length;for(n&&s&&(r=e[++i]);++i<s;)r=t(r,e[i],i,e);return r}e.exports=r},function(e,t,r){"use strict";function n(e,t,r){(void 0===r||s(e[t],r))&&(void 0!==r||t in e)||i(e,t,r)}var i=r(163),s=r(46);e.exports=n},function(e,t,r){"use strict";var n=r(527),i=n();e.exports=i},function(e,t,r){"use strict";function n(e,t){t=i(t,e);for(var r=0,n=t.length;null!=e&&r<n;)e=e[s(t[r++])];return r&&r==n?e:void 0}var i=r(255),s=r(108);e.exports=n},function(e,t,r){"use strict";function n(e,t,r){var n=t(e);return s(e)?n:i(n,r(e))}var i=r(161),s=r(6);e.exports=n},function(e,t,r){"use strict";function n(e,t,r,a,o){return e===t||(null==e||null==t||!s(e)&&!s(t)?e!==e&&t!==t:i(e,t,r,a,n,o))}var i=r(494),s=r(25);e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=-1,n=s(e)?Array(e.length):[];return i(e,function(e,i,s){n[++r]=t(e,i,s)}),n}var i=r(487),s=r(24);e.exports=n},function(e,t,r){"use strict";function n(e){if("string"==typeof e)return e;if(a(e))return s(e,n)+"";if(o(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-u?"-0":t}var i=r(45),s=r(60),a=r(6),o=r(62),u=1/0,l=i?i.prototype:void 0,c=l?l.toString:void 0;e.exports=n},function(e,t){"use strict";function r(e,t){return e.has(t)}e.exports=r},function(e,t,r){"use strict";function n(e,t){return i(e)?e:s(e,t)?[e]:a(o(e))}var i=r(6),s=r(173),a=r(571),o=r(114);e.exports=n},function(e,t,r){(function(e){"use strict";function n(e,t){if(t)return e.slice();var r=e.length,n=c?c(r):new e.constructor(r);return e.copy(n),n}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=r(17),a="object"==i(t)&&t&&!t.nodeType&&t,o=a&&"object"==i(e)&&e&&!e.nodeType&&e,u=o&&o.exports===a,l=u?s.Buffer:void 0,c=l?l.allocUnsafe:void 0;e.exports=n}).call(t,r(39)(e))},function(e,t,r){"use strict";function n(e,t){var r=t?i(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.length)}var i=r(167);e.exports=n},function(e,t,r){"use strict";function n(e){return function(t,r,n){var o=Object(t);if(!s(t)){var u=i(r,3);t=a(t),r=function(e){return u(o[e],e,o)}}var l=e(t,r,n);return l>-1?o[u?t[l]:l]:void 0}}var i=r(61),s=r(24),a=r(32);e.exports=n},function(e,t,r){"use strict";var n=r(38),i=function(){try{var e=n(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=i},function(e,t,r){"use strict";function n(e,t,r,n,l,c){var f=r&o,p=e.length,d=t.length;if(p!=d&&!(f&&d>p))return!1;var h=c.get(e);if(h&&c.get(t))return h==t;var m=-1,y=!0,v=r&u?new i:void 0;for(c.set(e,t),c.set(t,e);++m<p;){var g=e[m],b=t[m];if(n)var E=f?n(b,g,m,t,e,c):n(g,b,m,e,t,c);if(void 0!==E){if(E)continue;y=!1;break}if(v){if(!s(t,function(e,t){if(!a(v,t)&&(g===e||l(g,e,r,n,c)))return v.push(t)})){y=!1;break}}else if(g!==b&&!l(g,b,r,n,c)){y=!1;break}}return c.delete(e),c.delete(t),y}var i=r(242),s=r(482),a=r(254),o=1,u=2;e.exports=n},function(e,t){(function(t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n="object"==(void 0===t?"undefined":r(t))&&t&&t.Object===Object&&t;e.exports=n}).call(t,function(){return this}())},function(e,t,r){"use strict";function n(e){return i(e,a,s)}var i=r(250),s=r(170),a=r(32);e.exports=n},function(e,t,r){"use strict";var n=r(161),i=r(169),s=r(170),a=r(279),o=Object.getOwnPropertySymbols,u=o?function(e){for(var t=[];e;)n(t,s(e)),e=i(e);return t}:a;e.exports=u},function(e,t,r){"use strict";var n=r(472),i=r(159),s=r(474),a=r(241),o=r(475),u=r(30),l=r(272),c=l(n),f=l(i),p=l(s),d=l(a),h=l(o),m=u;(n&&"[object DataView]"!=m(new n(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||s&&"[object Promise]"!=m(s.resolve())||a&&"[object Set]"!=m(new a)||o&&"[object WeakMap]"!=m(new o))&&(m=function(e){var t=u(e),r="[object Object]"==t?e.constructor:void 0,n=r?l(r):"";if(n)switch(n){case c:return"[object DataView]";case f:return"[object Map]";case p:return"[object Promise]";case d:return"[object Set]";case h:return"[object WeakMap]"}return t}),e.exports=m},function(e,t,r){"use strict";function n(e,t,r){t=i(t,e);for(var n=-1,c=t.length,f=!1;++n<c;){var p=l(t[n]);if(!(f=null!=e&&r(e,p)))break;e=e[p]}return f||++n!=c?f:!!(c=null==e?0:e.length)&&u(c)&&o(p,c)&&(a(e)||s(e))}var i=r(255),s=r(112),a=r(6),o=r(171),u=r(176),l=r(108);e.exports=n},function(e,t,r){"use strict";function n(e){return"function"!=typeof e.constructor||a(e)?{}:i(s(e))}var i=r(486),s=r(169),a=r(105);e.exports=n},function(e,t,r){"use strict";function n(e){return e===e&&!i(e)}var i=r(18);e.exports=n},function(e,t){"use strict";function r(e){var t=-1,r=Array(e.size);return e.forEach(function(e,n){r[++t]=[n,e]}),r}e.exports=r},function(e,t){"use strict";function r(e,t){return function(r){return null!=r&&(r[e]===t&&(void 0!==t||e in Object(r)))}}e.exports=r},function(e,t,r){(function(e){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(261),s="object"==n(t)&&t&&!t.nodeType&&t,a=s&&"object"==n(e)&&e&&!e.nodeType&&e,o=a&&a.exports===s,u=o&&i.process,l=function(){try{return u&&u.binding&&u.binding("util")}catch(e){}}();e.exports=l}).call(t,r(39)(e))},function(e,t){"use strict";function r(e,t){return function(r){return e(t(r))}}e.exports=r},function(e,t){"use strict";function r(e){if(null!=e){try{return i.call(e)}catch(e){}try{return e+""}catch(e){}}return""}var n=Function.prototype,i=n.toString;e.exports=r},function(e,t,r){"use strict";var n=r(244),i=r(573),s=r(101),a=r(529),o=s(function(e){return e.push(void 0,a),n(i,void 0,e)});e.exports=o},function(e,t,r){"use strict";function n(e,t){return null!=e&&s(e,t,i)}var i=r(490),s=r(265);e.exports=n},function(e,t,r){"use strict";function n(e){if(!a(e)||i(e)!=o)return!1;var t=s(e);if(null===t)return!0;var r=f.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&c.call(r)==p}var i=r(30),s=r(169),a=r(25),o="[object Object]",u=Function.prototype,l=Object.prototype,c=u.toString,f=l.hasOwnProperty,p=c.call(Object);e.exports=n},function(e,t,r){"use strict";var n=r(498),i=r(102),s=r(270),a=s&&s.isRegExp,o=a?i(a):n;e.exports=o},function(e,t,r){"use strict";var n=r(101),i=r(593),s=n(i);e.exports=s},function(e,t,r){"use strict";function n(e,t,r){return t=(r?s(e,t,r):void 0===t)?1:a(t),i(o(e),t)}var i=r(510),s=r(172),a=r(48),o=r(114);e.exports=n},function(e,t){"use strict";function r(){return[]}e.exports=r},function(e,t,r){"use strict";function n(e){return null==e?[]:i(e,s(e))}var i=r(515),s=r(32);e.exports=n},function(e,t){"use strict";function r(e,t,r){if(c)try{c.call(l,e,t,{value:r})}catch(n){e[t]=r}else e[t]=r}function n(e){return e&&(r(e,"call",e.call),r(e,"apply",e.apply)),e}function i(e){return f?f.call(l,e):(m.prototype=e||null,new m)}function s(){do{var e=a(h.call(d.call(y(),36),2))}while(p.call(v,e));return v[e]=e}function a(e){var t={};return t[e]=!0,Object.keys(t)[0]}function o(e){return i(null)}function u(e){function t(t){function n(r,n){if(r===u)return n?i=null:i||(i=e(t))}var i;r(t,a,n)}function n(e){return p.call(e,a)||t(e),e[a](u)}var a=s(),u=i(null);return e=e||o,n.forget=function(e){p.call(e,a)&&e[a](u,!0)},n}var l=Object,c=Object.defineProperty,f=Object.create;n(c),n(f);var p=n(Object.prototype.hasOwnProperty),d=n(Number.prototype.toString),h=n(String.prototype.slice),m=function(){},y=Math.random,v=i(null);t.makeUniqueKey=s;var g=Object.getOwnPropertyNames;Object.getOwnPropertyNames=function(e){for(var t=g(e),r=0,n=0,i=t.length;r<i;++r)p.call(v,t[r])||(r>n&&(t[n]=t[r]),++n);return t.length=n,t},t.makeAccessor=u},function(e,t,r){var n;(function(e,i){"use strict";var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(a){var o="object"==s(t)&&t,u="object"==s(e)&&e&&e.exports==o&&e,l="object"==(void 0===i?"undefined":s(i))&&i;l.global!==l&&l.window!==l||(a=l);var c={rangeOrder:"A ranges `stop` value must be greater than or equal to the `start` value.",codePointRange:"Invalid code point value. Code points range from U+000000 to U+10FFFF."},f=/\\x00([^0123456789]|$)/g,p={},d=p.hasOwnProperty,h=function(e,t){for(var r=-1,n=e.length;++r<n;)t(e[r],r)},m=p.toString,y=function(e){return"[object Array]"==m.call(e)},v=function(e){return"number"==typeof e||"[object Number]"==m.call(e)},g=function(e,t){var r=String(e);return r.length<t?("0000"+r).slice(-t):r},b=function(e){return Number(e).toString(16).toUpperCase()},E=[].slice,x=function(e){for(var t,r=-1,n=e.length,i=n-1,s=[],a=!0,o=0;++r<n;)if(t=e[r],a)s.push(t),o=t,a=!1;else if(t==o+1){if(r!=i){o=t;continue}a=!0,s.push(t+1)}else s.push(o+1,t),o=t;return a||s.push(t+1),s},A=function(e,t){for(var r,n,i=0,s=e.length;i<s;){if(r=e[i],n=e[i+1],t>=r&&t<n)return t==r?n==r+1?(e.splice(i,2),e):(e[i]=t+1,e):t==n-1?(e[i+1]=t,e):(e.splice(i,2,r,t,t+1,n),e);i+=2}return e},S=function(e,t,r){if(r<t)throw Error(c.rangeOrder);for(var n,i,s=0;s<e.length;){if(n=e[s],i=e[s+1]-1,n>r)return e;if(t<=n&&r>=i)e.splice(s,2);else{if(t>=n&&r<i)return t==n?(e[s]=r+1,e[s+1]=i+1,e):(e.splice(s,2,n,t,r+1,i+1),e);if(t>=n&&t<=i)e[s+1]=t;else if(r>=n&&r<=i)return e[s]=r+1,e;s+=2}}return e},_=function(e,t){var r,n,i=0,s=null,a=e.length;if(t<0||t>1114111)throw RangeError(c.codePointRange);for(;i<a;){if(r=e[i],n=e[i+1],t>=r&&t<n)return e;if(t==r-1)return e[i]=t,e;if(r>t)return e.splice(null!=s?s+2:0,0,t,t+1),e;if(t==n)return t+1==e[i+2]?(e.splice(i,4,r,e[i+3]),e):(e[i+1]=t+1,e);s=i,i+=2}return e.push(t,t+1),e},D=function(e,t){for(var r,n,i=0,s=e.slice(),a=t.length;i<a;)r=t[i],n=t[i+1]-1,s=r==n?_(s,r):w(s,r,n),i+=2;return s},C=function(e,t){for(var r,n,i=0,s=e.slice(),a=t.length;i<a;)r=t[i],n=t[i+1]-1,s=r==n?A(s,r):S(s,r,n),i+=2;return s},w=function(e,t,r){if(r<t)throw Error(c.rangeOrder);if(t<0||t>1114111||r<0||r>1114111)throw RangeError(c.codePointRange);for(var n,i,s=0,a=!1,o=e.length;s<o;){if(n=e[s],i=e[s+1],a){if(n==r+1)return e.splice(s-1,2),e;if(n>r)return e;n>=t&&n<=r&&(i>t&&i-1<=r?(e.splice(s,2),s-=2):(e.splice(s-1,2),s-=2))}else{if(n==r+1)return e[s]=t,e;if(n>r)return e.splice(s,0,t,r+1),e;if(t>=n&&t<i&&r+1<=i)return e;t>=n&&t<i||i==t?(e[s+1]=r+1,a=!0):t<=n&&r+1>=i&&(e[s]=t,e[s+1]=r+1,a=!0)}s+=2}return a||e.push(t,r+1),e},P=function(e,t){var r=0,n=e.length,i=e[r],s=e[n-1];if(n>=2&&(t<i||t>s))return!1;for(;r<n;){if(i=e[r],s=e[r+1],t>=i&&t<s)return!0;r+=2}return!1},k=function(e,t){for(var r,n=0,i=t.length,s=[];n<i;)r=t[n],P(e,r)&&s.push(r),++n;return x(s)},F=function(e){return!e.length},T=function(e){return 2==e.length&&e[0]+1==e[1]},O=function(e){for(var t,r,n=0,i=[],s=e.length;n<s;){for(t=e[n],r=e[n+1];t<r;)i.push(t),++t;n+=2}return i},B=Math.floor,R=function(e){return parseInt(B((e-65536)/1024)+55296,10)},I=function(e){return parseInt((e-65536)%1024+56320,10)},M=String.fromCharCode,N=function(e){return 9==e?"\\t":10==e?"\\n":12==e?"\\f":13==e?"\\r":92==e?"\\\\":36==e||e>=40&&e<=43||45==e||46==e||63==e||e>=91&&e<=94||e>=123&&e<=125?"\\"+M(e):e>=32&&e<=126?M(e):e<=255?"\\x"+g(b(e),2):"\\u"+g(b(e),4)},L=function(e){return e<=65535?N(e):"\\u{"+e.toString(16).toUpperCase()+"}"},j=function(e){var t,r=e.length,n=e.charCodeAt(0);return n>=55296&&n<=56319&&r>1?(t=e.charCodeAt(1),1024*(n-55296)+t-56320+65536):n},U=function(e){var t,r,n="",i=0,s=e.length;if(T(e))return N(e[0]);for(;i<s;)t=e[i],r=e[i+1]-1,n+=t==r?N(t):t+1==r?N(t)+N(r):N(t)+"-"+N(r),i+=2;return"["+n+"]"},V=function(e){var t,r,n="",i=0,s=e.length;if(T(e))return L(e[0]);for(;i<s;)t=e[i],r=e[i+1]-1,n+=t==r?L(t):t+1==r?L(t)+L(r):L(t)+"-"+L(r),i+=2;return"["+n+"]"},G=function(e){for(var t,r,n=[],i=[],s=[],a=[],o=0,u=e.length;o<u;)t=e[o],r=e[o+1]-1,t<55296?(r<55296&&s.push(t,r+1),r>=55296&&r<=56319&&(s.push(t,55296),n.push(55296,r+1)),r>=56320&&r<=57343&&(s.push(t,55296),n.push(55296,56320),i.push(56320,r+1)),r>57343&&(s.push(t,55296),n.push(55296,56320),i.push(56320,57344),r<=65535?s.push(57344,r+1):(s.push(57344,65536),a.push(65536,r+1)))):t>=55296&&t<=56319?(r>=55296&&r<=56319&&n.push(t,r+1),r>=56320&&r<=57343&&(n.push(t,56320),i.push(56320,r+1)),r>57343&&(n.push(t,56320),i.push(56320,57344),r<=65535?s.push(57344,r+1):(s.push(57344,65536),a.push(65536,r+1)))):t>=56320&&t<=57343?(r>=56320&&r<=57343&&i.push(t,r+1),r>57343&&(i.push(t,57344),r<=65535?s.push(57344,r+1):(s.push(57344,65536),a.push(65536,r+1)))):t>57343&&t<=65535?r<=65535?s.push(t,r+1):(s.push(t,65536),a.push(65536,r+1)):a.push(t,r+1),o+=2;return{loneHighSurrogates:n,loneLowSurrogates:i,bmp:s,astral:a}},W=function(e){for(var t,r,n,i,s,a,o=[],u=[],l=!1,c=-1,f=e.length;++c<f;)if(t=e[c],r=e[c+1]){for(n=t[0],i=t[1],s=r[0],a=r[1],u=i;s&&n[0]==s[0]&&n[1]==s[1];)u=T(a)?_(u,a[0]):w(u,a[0],a[1]-1),++c,t=e[c],n=t[0],i=t[1],r=e[c+1],s=r&&r[0],a=r&&r[1],l=!0;o.push([n,l?u:i]),l=!1}else o.push(t);return Y(o)},Y=function(e){if(1==e.length)return e;for(var t=-1,r=-1;++t<e.length;){var n=e[t],i=n[1],s=i[0],a=i[1];for(r=t;++r<e.length;){var o=e[r],u=o[1],l=u[0],c=u[1];s==l&&a==c&&(T(o[0])?n[0]=_(n[0],o[0][0]):n[0]=w(n[0],o[0][0],o[0][1]-1),e.splice(r,1),--r)}}return e},q=function(e){if(!e.length)return[];for(var t,r,n,i,s,a,o=0,u=[],l=e.length;o<l;){t=e[o],r=e[o+1]-1,n=R(t),i=I(t),s=R(r),a=I(r);var c=56320==i,f=57343==a,p=!1;n==s||c&&f?(u.push([[n,s+1],[i,a+1]]),p=!0):u.push([[n,n+1],[i,57344]]),!p&&n+1<s&&(f?(u.push([[n+1,s+1],[56320,a+1]]),p=!0):u.push([[n+1,s],[56320,57344]])),p||u.push([[s,s+1],[56320,a+1]]),o+=2}return W(u)},K=function(e){var t=[];return h(e,function(e){var r=e[0],n=e[1];t.push(U(r)+U(n))}),t.join("|")},H=function(e,t,r){if(r)return V(e);var n=[],i=G(e),s=i.loneHighSurrogates,a=i.loneLowSurrogates,o=i.bmp,u=i.astral,l=!F(s),c=!F(a),f=q(u);return t&&(o=D(o,s),l=!1,o=D(o,a),c=!1),F(o)||n.push(U(o)),f.length&&n.push(K(f)),l&&n.push(U(s)+"(?![\\uDC00-\\uDFFF])"),c&&n.push("(?:[^\\uD800-\\uDBFF]|^)"+U(a)),n.join("|")},J=function e(t){return arguments.length>1&&(t=E.call(arguments)),this instanceof e?(this.data=[],t?this.add(t):this):(new e).add(t)};J.version="1.3.2";var X=J.prototype;!function(e,t){var r;for(r in t)d.call(t,r)&&(e[r]=t[r])}(X,{add:function(e){var t=this;return null==e?t:e instanceof J?(t.data=D(t.data,e.data),t):(arguments.length>1&&(e=E.call(arguments)),y(e)?(h(e,function(e){t.add(e)}),t):(t.data=_(t.data,v(e)?e:j(e)),t))},remove:function(e){var t=this;return null==e?t:e instanceof J?(t.data=C(t.data,e.data),t):(arguments.length>1&&(e=E.call(arguments)),y(e)?(h(e,function(e){t.remove(e)}),t):(t.data=A(t.data,v(e)?e:j(e)),t))},addRange:function(e,t){var r=this;return r.data=w(r.data,v(e)?e:j(e),v(t)?t:j(t)),r},removeRange:function(e,t){var r=this,n=v(e)?e:j(e),i=v(t)?t:j(t);return r.data=S(r.data,n,i),r},intersection:function(e){var t=this,r=e instanceof J?O(e.data):e;return t.data=k(t.data,r),t},contains:function(e){return P(this.data,v(e)?e:j(e))},clone:function(){var e=new J;return e.data=this.data.slice(0),e},toString:function(e){var t=H(this.data,!!e&&e.bmpOnly,!!e&&e.hasUnicodeFlag);return t?t.replace(f,"\\0$1"):"[]"},toRegExp:function(e){var t=this.toString(e&&-1!=e.indexOf("u")?{hasUnicodeFlag:!0}:null);return RegExp(t,e||"")},valueOf:function(){return O(this.data)}}),X.toArray=X.valueOf,"object"==s(r(49))&&r(49)?void 0!==(n=function(){return J}.call(t,r,t,e))&&(e.exports=n):o&&!o.nodeType?u?u.exports=J:o.regenerate=J:a.regenerate=J}(void 0)}).call(t,r(39)(e),function(){return this}())},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e){p.default.ok(this instanceof s),h.assertIdentifier(e),this.nextTempId=0,this.contextId=e,this.listing=[],this.marked=[!0],this.finalLoc=a(),this.tryEntries=[],this.leapManager=new y.LeapManager(this)}function a(){return h.numericLiteral(-1)}function o(e){return new Error("all declarations should have been transformed into assignments before the Exploder began its work: "+(0,c.default)(e))}function u(e){var t=e.type
;return"normal"===t?!x.call(e,"target"):"break"===t||"continue"===t?!x.call(e,"value")&&h.isLiteral(e.target):("return"===t||"throw"===t)&&(x.call(e,"value")&&!x.call(e,"target"))}var l=r(35),c=i(l),f=r(64),p=i(f),d=r(1),h=n(d),m=r(607),y=n(m),v=r(608),g=n(v),b=r(116),E=n(b),x=Object.prototype.hasOwnProperty,A=s.prototype;t.Emitter=s,A.mark=function(e){h.assertLiteral(e);var t=this.listing.length;return-1===e.value?e.value=t:p.default.strictEqual(e.value,t),this.marked[t]=!0,e},A.emit=function(e){h.isExpression(e)&&(e=h.expressionStatement(e)),h.assertStatement(e),this.listing.push(e)},A.emitAssign=function(e,t){return this.emit(this.assign(e,t)),e},A.assign=function(e,t){return h.expressionStatement(h.assignmentExpression("=",e,t))},A.contextProperty=function(e,t){return h.memberExpression(this.contextId,t?h.stringLiteral(e):h.identifier(e),!!t)},A.stop=function(e){e&&this.setReturnValue(e),this.jump(this.finalLoc)},A.setReturnValue=function(e){h.assertExpression(e.value),this.emitAssign(this.contextProperty("rval"),this.explodeExpression(e))},A.clearPendingException=function(e,t){h.assertLiteral(e);var r=h.callExpression(this.contextProperty("catch",!0),[e]);t?this.emitAssign(t,r):this.emit(r)},A.jump=function(e){this.emitAssign(this.contextProperty("next"),e),this.emit(h.breakStatement())},A.jumpIf=function(e,t){h.assertExpression(e),h.assertLiteral(t),this.emit(h.ifStatement(e,h.blockStatement([this.assign(this.contextProperty("next"),t),h.breakStatement()])))},A.jumpIfNot=function(e,t){h.assertExpression(e),h.assertLiteral(t);var r=void 0;r=h.isUnaryExpression(e)&&"!"===e.operator?e.argument:h.unaryExpression("!",e),this.emit(h.ifStatement(r,h.blockStatement([this.assign(this.contextProperty("next"),t),h.breakStatement()])))},A.makeTempVar=function(){return this.contextProperty("t"+this.nextTempId++)},A.getContextFunction=function(e){return h.functionExpression(e||null,[this.contextId],h.blockStatement([this.getDispatchLoop()]),!1,!1)},A.getDispatchLoop=function(){var e=this,t=[],r=void 0,n=!1;return e.listing.forEach(function(i,s){e.marked.hasOwnProperty(s)&&(t.push(h.switchCase(h.numericLiteral(s),r=[])),n=!1),n||(r.push(i),h.isCompletionStatement(i)&&(n=!0))}),this.finalLoc.value=this.listing.length,t.push(h.switchCase(this.finalLoc,[]),h.switchCase(h.stringLiteral("end"),[h.returnStatement(h.callExpression(this.contextProperty("stop"),[]))])),h.whileStatement(h.numericLiteral(1),h.switchStatement(h.assignmentExpression("=",this.contextProperty("prev"),this.contextProperty("next")),t))},A.getTryLocsList=function(){if(0===this.tryEntries.length)return null;var e=0;return h.arrayExpression(this.tryEntries.map(function(t){var r=t.firstLoc.value;p.default.ok(r>=e,"try entries out of order"),e=r;var n=t.catchEntry,i=t.finallyEntry,s=[t.firstLoc,n?n.firstLoc:null];return i&&(s[2]=i.firstLoc,s[3]=i.afterLoc),h.arrayExpression(s)}))},A.explode=function(e,t){var r=e.node,n=this;if(h.assertNode(r),h.isDeclaration(r))throw o(r);if(h.isStatement(r))return n.explodeStatement(e);if(h.isExpression(r))return n.explodeExpression(e,t);switch(r.type){case"Program":return e.get("body").map(n.explodeStatement,n);case"VariableDeclarator":throw o(r);case"Property":case"SwitchCase":case"CatchClause":throw new Error(r.type+" nodes should be handled by their parents");default:throw new Error("unknown Node of type "+(0,c.default)(r.type))}},A.explodeStatement=function(e,t){var r=e.node,n=this,i=void 0,s=void 0,o=void 0;if(h.assertStatement(r),t?h.assertIdentifier(t):t=null,h.isBlockStatement(r))return void e.get("body").forEach(function(e){n.explodeStatement(e)});if(!g.containsLeap(r))return void n.emit(r);switch(r.type){case"ExpressionStatement":n.explodeExpression(e.get("expression"),!0);break;case"LabeledStatement":s=a(),n.leapManager.withEntry(new y.LabeledEntry(s,r.label),function(){n.explodeStatement(e.get("body"),r.label)}),n.mark(s);break;case"WhileStatement":i=a(),s=a(),n.mark(i),n.jumpIfNot(n.explodeExpression(e.get("test")),s),n.leapManager.withEntry(new y.LoopEntry(s,i,t),function(){n.explodeStatement(e.get("body"))}),n.jump(i),n.mark(s);break;case"DoWhileStatement":var u=a(),l=a();s=a(),n.mark(u),n.leapManager.withEntry(new y.LoopEntry(s,l,t),function(){n.explode(e.get("body"))}),n.mark(l),n.jumpIf(n.explodeExpression(e.get("test")),u),n.mark(s);break;case"ForStatement":o=a();var f=a();s=a(),r.init&&n.explode(e.get("init"),!0),n.mark(o),r.test&&n.jumpIfNot(n.explodeExpression(e.get("test")),s),n.leapManager.withEntry(new y.LoopEntry(s,f,t),function(){n.explodeStatement(e.get("body"))}),n.mark(f),r.update&&n.explode(e.get("update"),!0),n.jump(o),n.mark(s);break;case"TypeCastExpression":return n.explodeExpression(e.get("expression"));case"ForInStatement":o=a(),s=a();var d=n.makeTempVar();n.emitAssign(d,h.callExpression(E.runtimeProperty("keys"),[n.explodeExpression(e.get("right"))])),n.mark(o);var m=n.makeTempVar();n.jumpIf(h.memberExpression(h.assignmentExpression("=",m,h.callExpression(d,[])),h.identifier("done"),!1),s),n.emitAssign(r.left,h.memberExpression(m,h.identifier("value"),!1)),n.leapManager.withEntry(new y.LoopEntry(s,o,t),function(){n.explodeStatement(e.get("body"))}),n.jump(o),n.mark(s);break;case"BreakStatement":n.emitAbruptCompletion({type:"break",target:n.leapManager.getBreakLoc(r.label)});break;case"ContinueStatement":n.emitAbruptCompletion({type:"continue",target:n.leapManager.getContinueLoc(r.label)});break;case"SwitchStatement":var v=n.emitAssign(n.makeTempVar(),n.explodeExpression(e.get("discriminant")));s=a();for(var b=a(),x=b,A=[],_=r.cases||[],D=_.length-1;D>=0;--D){var C=_[D];h.assertSwitchCase(C),C.test?x=h.conditionalExpression(h.binaryExpression("===",v,C.test),A[D]=a(),x):A[D]=b}var w=e.get("discriminant");E.replaceWithOrRemove(w,x),n.jump(n.explodeExpression(w)),n.leapManager.withEntry(new y.SwitchEntry(s),function(){e.get("cases").forEach(function(e){var t=e.key;n.mark(A[t]),e.get("consequent").forEach(function(e){n.explodeStatement(e)})})}),n.mark(s),-1===b.value&&(n.mark(b),p.default.strictEqual(s.value,b.value));break;case"IfStatement":var P=r.alternate&&a();s=a(),n.jumpIfNot(n.explodeExpression(e.get("test")),P||s),n.explodeStatement(e.get("consequent")),P&&(n.jump(s),n.mark(P),n.explodeStatement(e.get("alternate"))),n.mark(s);break;case"ReturnStatement":n.emitAbruptCompletion({type:"return",value:n.explodeExpression(e.get("argument"))});break;case"WithStatement":throw new Error("WithStatement not supported in generator functions.");case"TryStatement":s=a();var k=r.handler,F=k&&a(),T=F&&new y.CatchEntry(F,k.param),O=r.finalizer&&a(),B=O&&new y.FinallyEntry(O,s),R=new y.TryEntry(n.getUnmarkedCurrentLoc(),T,B);n.tryEntries.push(R),n.updateContextPrevLoc(R.firstLoc),n.leapManager.withEntry(R,function(){if(n.explodeStatement(e.get("block")),F){O?n.jump(O):n.jump(s),n.updateContextPrevLoc(n.mark(F));var t=e.get("handler.body"),r=n.makeTempVar();n.clearPendingException(R.firstLoc,r),t.traverse(S,{safeParam:r,catchParamName:k.param.name}),n.leapManager.withEntry(T,function(){n.explodeStatement(t)})}O&&(n.updateContextPrevLoc(n.mark(O)),n.leapManager.withEntry(B,function(){n.explodeStatement(e.get("finalizer"))}),n.emit(h.returnStatement(h.callExpression(n.contextProperty("finish"),[B.firstLoc]))))}),n.mark(s);break;case"ThrowStatement":n.emit(h.throwStatement(n.explodeExpression(e.get("argument"))));break;default:throw new Error("unknown Statement of type "+(0,c.default)(r.type))}};var S={Identifier:function(e,t){e.node.name===t.catchParamName&&E.isReference(e)&&E.replaceWithOrRemove(e,t.safeParam)},Scope:function(e,t){e.scope.hasOwnBinding(t.catchParamName)&&e.skip()}};A.emitAbruptCompletion=function(e){u(e)||p.default.ok(!1,"invalid completion record: "+(0,c.default)(e)),p.default.notStrictEqual(e.type,"normal","normal completions are not abrupt");var t=[h.stringLiteral(e.type)];"break"===e.type||"continue"===e.type?(h.assertLiteral(e.target),t[1]=e.target):"return"!==e.type&&"throw"!==e.type||e.value&&(h.assertExpression(e.value),t[1]=e.value),this.emit(h.returnStatement(h.callExpression(this.contextProperty("abrupt"),t)))},A.getUnmarkedCurrentLoc=function(){return h.numericLiteral(this.listing.length)},A.updateContextPrevLoc=function(e){e?(h.assertLiteral(e),-1===e.value?e.value=this.listing.length:p.default.strictEqual(e.value,this.listing.length)):e=this.getUnmarkedCurrentLoc(),this.emitAssign(this.contextProperty("prev"),e)},A.explodeExpression=function(e,t){function r(e){if(h.assertExpression(e),!t)return e;s.emit(e)}function n(e,t,r){p.default.ok(!r||!e,"Ignoring the result of a child expression but forcing it to be assigned to a temporary variable?");var n=s.explodeExpression(t,r);return r||(e||l&&!h.isLiteral(n))&&(n=s.emitAssign(e||s.makeTempVar(),n)),n}var i=e.node;if(!i)return i;h.assertExpression(i);var s=this,o=void 0,u=void 0;if(!g.containsLeap(i))return r(i);var l=g.containsLeap.onlyChildren(i);switch(i.type){case"MemberExpression":return r(h.memberExpression(s.explodeExpression(e.get("object")),i.computed?n(null,e.get("property")):i.property,i.computed));case"CallExpression":var f=e.get("callee"),d=e.get("arguments"),m=void 0,y=[],v=!1;if(d.forEach(function(e){v=v||g.containsLeap(e.node)}),h.isMemberExpression(f.node))if(v){var b=n(s.makeTempVar(),f.get("object")),E=f.node.computed?n(null,f.get("property")):f.node.property;y.unshift(b),m=h.memberExpression(h.memberExpression(b,E,f.node.computed),h.identifier("call"),!1)}else m=s.explodeExpression(f);else m=n(null,f),h.isMemberExpression(m)&&(m=h.sequenceExpression([h.numericLiteral(0),m]));return d.forEach(function(e){y.push(n(null,e))}),r(h.callExpression(m,y));case"NewExpression":return r(h.newExpression(n(null,e.get("callee")),e.get("arguments").map(function(e){return n(null,e)})));case"ObjectExpression":return r(h.objectExpression(e.get("properties").map(function(e){return e.isObjectProperty()?h.objectProperty(e.node.key,n(null,e.get("value")),e.node.computed):e.node})));case"ArrayExpression":return r(h.arrayExpression(e.get("elements").map(function(e){return n(null,e)})));case"SequenceExpression":var x=i.expressions.length-1;return e.get("expressions").forEach(function(e){e.key===x?o=s.explodeExpression(e,t):s.explodeExpression(e,!0)}),o;case"LogicalExpression":u=a(),t||(o=s.makeTempVar());var A=n(o,e.get("left"));return"&&"===i.operator?s.jumpIfNot(A,u):(p.default.strictEqual(i.operator,"||"),s.jumpIf(A,u)),n(o,e.get("right"),t),s.mark(u),o;case"ConditionalExpression":var S=a();u=a();var _=s.explodeExpression(e.get("test"));return s.jumpIfNot(_,S),t||(o=s.makeTempVar()),n(o,e.get("consequent"),t),s.jump(u),s.mark(S),n(o,e.get("alternate"),t),s.mark(u),o;case"UnaryExpression":return r(h.unaryExpression(i.operator,s.explodeExpression(e.get("argument")),!!i.prefix));case"BinaryExpression":return r(h.binaryExpression(i.operator,n(null,e.get("left")),n(null,e.get("right"))));case"AssignmentExpression":return r(h.assignmentExpression(i.operator,s.explodeExpression(e.get("left")),s.explodeExpression(e.get("right"))));case"UpdateExpression":return r(h.updateExpression(i.operator,s.explodeExpression(e.get("argument")),i.prefix));case"YieldExpression":u=a();var D=i.argument&&s.explodeExpression(e.get("argument"));if(D&&i.delegate){var C=s.makeTempVar();return s.emit(h.returnStatement(h.callExpression(s.contextProperty("delegateYield"),[D,h.stringLiteral(C.property.name),u]))),s.mark(u),C}return s.emitAssign(s.contextProperty("next"),u),s.emit(h.returnStatement(D||null)),s.mark(u),s.contextProperty("sent");default:throw new Error("unknown Expression of type "+(0,c.default)(i.type))}}},function(e,t){"use strict";e.exports=function(e){var t=/^\\\\\?\\/.test(e),r=/[^\x00-\x80]+/.test(e);return t||r?e:e.replace(/\\/g,"/")}},function(e,t,r){"use strict";function n(){this._array=[],this._set=Object.create(null)}var i=r(63),s=Object.prototype.hasOwnProperty;n.fromArray=function(e,t){for(var r=new n,i=0,s=e.length;i<s;i++)r.add(e[i],t);return r},n.prototype.size=function(){return Object.getOwnPropertyNames(this._set).length},n.prototype.add=function(e,t){var r=i.toSetString(e),n=s.call(this._set,r),a=this._array.length;n&&!t||this._array.push(e),n||(this._set[r]=a)},n.prototype.has=function(e){var t=i.toSetString(e);return s.call(this._set,t)},n.prototype.indexOf=function(e){var t=i.toSetString(e);if(s.call(this._set,t))return this._set[t];throw new Error('"'+e+'" is not in the set.')},n.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},n.prototype.toArray=function(){return this._array.slice()},t.ArraySet=n},function(e,t,r){"use strict";function n(e){return e<0?1+(-e<<1):0+(e<<1)}function i(e){var t=1==(1&e),r=e>>1;return t?-r:r}var s=r(616);t.encode=function(e){var t,r="",i=n(e);do{t=31&i,i>>>=5,i>0&&(t|=32),r+=s.encode(t)}while(i>0);return r},t.decode=function(e,t,r){var n,a,o=e.length,u=0,l=0;do{if(t>=o)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(a=s.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));n=!!(32&a),a&=31,u+=a<<l,l+=5}while(n);r.value=i(u),r.rest=t}},function(e,t,r){"use strict";function n(e){e||(e={}),this._file=s.getArg(e,"file",null),this._sourceRoot=s.getArg(e,"sourceRoot",null),this._skipValidation=s.getArg(e,"skipValidation",!1),this._sources=new a,this._names=new a,this._mappings=new o,this._sourcesContents=null}var i=r(286),s=r(63),a=r(285).ArraySet,o=r(618).MappingList;n.prototype._version=3,n.fromSourceMap=function(e){var t=e.sourceRoot,r=new n({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var n={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(n.source=e.source,null!=t&&(n.source=s.relative(t,n.source)),n.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(n.name=e.name)),r.addMapping(n)}),e.sources.forEach(function(t){var n=e.sourceContentFor(t);null!=n&&r.setSourceContent(t,n)}),r},n.prototype.addMapping=function(e){var t=s.getArg(e,"generated"),r=s.getArg(e,"original",null),n=s.getArg(e,"source",null),i=s.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,n,i),null!=n&&(n=String(n),this._sources.has(n)||this._sources.add(n)),null!=i&&(i=String(i),this._names.has(i)||this._names.add(i)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:n,name:i})},n.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=s.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[s.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[s.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},n.prototype.applySourceMap=function(e,t,r){var n=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');n=e.file}var i=this._sourceRoot;null!=i&&(n=s.relative(i,n));var o=new a,u=new a;this._mappings.unsortedForEach(function(t){if(t.source===n&&null!=t.originalLine){var a=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=a.source&&(t.source=a.source,null!=r&&(t.source=s.join(r,t.source)),null!=i&&(t.source=s.relative(i,t.source)),t.originalLine=a.line,t.originalColumn=a.column,null!=a.name&&(t.name=a.name))}var l=t.source;null==l||o.has(l)||o.add(l);var c=t.name;null==c||u.has(c)||u.add(c)},this),this._sources=o,this._names=u,e.sources.forEach(function(t){var n=e.sourceContentFor(t);null!=n&&(null!=r&&(t=s.join(r,t)),null!=i&&(t=s.relative(i,t)),this.setSourceContent(t,n))},this)},n.prototype._validateMapping=function(e,t,r,n){if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||n)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:n}))},n.prototype._serializeMappings=function(){for(var e,t,r,n,a=0,o=1,u=0,l=0,c=0,f=0,p="",d=this._mappings.toArray(),h=0,m=d.length;h<m;h++){if(t=d[h],e="",t.generatedLine!==o)for(a=0;t.generatedLine!==o;)e+=";",o++;else if(h>0){if(!s.compareByGeneratedPositionsInflated(t,d[h-1]))continue;e+=","}e+=i.encode(t.generatedColumn-a),a=t.generatedColumn,null!=t.source&&(n=this._sources.indexOf(t.source),e+=i.encode(n-f),f=n,e+=i.encode(t.originalLine-1-l),l=t.originalLine-1,e+=i.encode(t.originalColumn-u),u=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=i.encode(r-c),c=r)),p+=e}return p},n.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=s.relative(t,e));var r=s.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},n.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},n.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=n},function(e,t,r){"use strict";t.SourceMapGenerator=r(287).SourceMapGenerator,t.SourceMapConsumer=r(620).SourceMapConsumer,t.SourceNode=r(621).SourceNode},function(e,t,r){(function(e){"use strict";function t(){var e={modifiers:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},colors:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39]},bgColors:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49]}};return e.colors.grey=e.colors.gray,Object.keys(e).forEach(function(t){var r=e[t];Object.keys(r).forEach(function(t){var n=r[t];e[t]=r[t]={open:"["+n[0]+"m",close:"["+n[1]+"m"}}),Object.defineProperty(e,t,{value:r,enumerable:!1})}),e}Object.defineProperty(e,"exports",{enumerable:!0,get:t})}).call(t,r(39)(e))},function(e,t,r){"use strict";e.exports=r(182)},function(e,t){"use strict";function r(e){return["babel-plugin-"+e,e]}t.__esModule=!0,t.default=r,e.exports=t.default},function(e,t){"use strict";function r(e){var t=["babel-preset-"+e,e],r=e.match(/^(@[^\/]+)\/(.+)$/);if(r){var n=r[1],i=r[2];t.push(n+"/babel-preset-"+i)}return t}t.__esModule=!0,t.default=r,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i);t.default=function(e,t){if(e&&t)return(0,o.default)(e,t,function(e,t){if(t&&Array.isArray(e)){for(var r=t.slice(0),n=e,i=Array.isArray(n),a=0,n=i?n:(0,s.default)(n);;){var o;if(i){if(a>=n.length)break;o=n[a++]}else{if(a=n.next(),a.done)break;o=a.value}var u=o;r.indexOf(u)<0&&r.push(u)}return r}})};var a=r(590),o=n(a);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e,t,r){if(e){if("Program"===e.type)return i.file(e,t||[],r||[]);if("File"===e.type)return e}throw new Error("Not a valid ast?")};var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function s(e,t){var r=[],n=g.functionExpression(null,[g.identifier("global")],g.blockStatement(r)),i=g.program([g.expressionStatement(g.callExpression(n,[c.get("selfGlobal")]))]);return r.push(g.variableDeclaration("var",[g.variableDeclarator(e,g.assignmentExpression("=",g.memberExpression(g.identifier("global"),e),g.objectExpression([])))])),t(r),i}function a(e,t){var r=[];return r.push(g.variableDeclaration("var",[g.variableDeclarator(e,g.identifier("global"))])),t(r),g.program([b({FACTORY_PARAMETERS:g.identifier("global"),BROWSER_ARGUMENTS:g.assignmentExpression("=",g.memberExpression(g.identifier("root"),e),g.objectExpression([])),COMMON_ARGUMENTS:g.identifier("exports"),AMD_ARGUMENTS:g.arrayExpression([g.stringLiteral("exports")]),FACTORY_BODY:r,UMD_ROOT:g.identifier("this")})])}function o(e,t){var r=[];return r.push(g.variableDeclaration("var",[g.variableDeclarator(e,g.objectExpression([]))])),t(r),r.push(g.expressionStatement(e)),g.program(r)}function u(e,t,r){c.list.forEach(function(n){if(!(r&&r.indexOf(n)<0)){var i=g.identifier(n);e.push(g.expressionStatement(g.assignmentExpression("=",g.memberExpression(t,i),c.get(n))))}})}t.__esModule=!0,t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"global",r=g.identifier("babelHelpers"),n=function(t){return u(t,r,e)},i=void 0,l={global:s,umd:a,var:o}[t];if(!l)throw new Error(h.get("unsupportedOutputType",t));return i=l(r,n),(0,p.default)(i).code};var l=r(194),c=i(l),f=r(186),p=n(f),d=r(20),h=i(d),m=r(4),y=n(m),v=r(1),g=i(v),b=(0,y.default)('\n  (function (root, factory) {\n    if (typeof define === "function" && define.amd) {\n      define(AMD_ARGUMENTS, factory);\n    } else if (typeof exports === "object") {\n      factory(COMMON_ARGUMENTS);\n    } else {\n      factory(BROWSER_ARGUMENTS);\n    }\n  })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n    FACTORY_BODY\n  });\n');e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(65),s=n(i),a=r(594),o=n(a);t.default=new s.default({name:"internal.blockHoist",visitor:{Block:{exit:function(e){for(var t=e.node,r=!1,n=0;n<t.body.length;n++){var i=t.body[n];if(i&&null!=i._blockHoist){r=!0;break}}r&&(t.body=(0,o.default)(t.body,function(e){var t=e&&e._blockHoist;return null==t&&(t=1),!0===t&&(t=2),-1*t}))}}}}),e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){return!!e.is("_forceShadow")||t}function s(e,t){var r=e.inShadow(t);if(i(e,r)){var n=e.node._shadowedFunctionLiteral,s=void 0,a=!1,o=e.find(function(t){if(t.parentPath&&t.parentPath.isClassProperty()&&"value"===t.key)return!0;if(e===t)return!1;if((t.isProgram()||t.isFunction())&&(s=s||t),t.isProgram())return a=!0,!0;if(t.isFunction()&&!t.isArrowFunctionExpression()){if(n){if(t===n||t.node===n.node)return!0}else if(!t.is("shadow"))return!0;return a=!0,!1}return!1});if(n&&o.isProgram()&&!n.isProgram()&&(o=e.findParent(function(e){return e.isProgram()||e.isFunction()})),o!==s&&a){var u=o.getData(t);if(u)return e.replaceWith(u);var l=e.scope.generateUidIdentifier(t);o.setData(t,l);var c=o.findParent(function(e){return e.isClass()}),p=!!(c&&c.node&&c.node.superClass);if("this"===t&&o.isMethod({kind:"constructor"})&&p)o.scope.push({id:l}),o.traverse(d,{id:l});else{var h="this"===t?f.thisExpression():f.identifier(t);n&&(h._shadowedFunctionLiteral=n),o.scope.push({id:l,init:h})}return e.replaceWith(l)}}}t.__esModule=!0;var a=r(10),o=n(a),u=r(65),l=n(u),c=r(1),f=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(c),p=(0,o.default)("super this bound"),d={CallExpression:function(e){if(e.get("callee").isSuper()){var t=e.node;t[p]||(t[p]=!0,e.replaceWith(f.assignmentExpression("=",this.id,t)))}}};t.default=new l.default({name:"internal.shadowFunctions",visitor:{ThisExpression:function(e){s(e,"this")},ReferencedIdentifier:function(e){"arguments"===e.node.name&&s(e,"arguments")}}}),e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(294),o=n(a),u=r(65),l=n(u),c=r(50),f=n(c),p=function(){function e(){(0,s.default)(this,e)}return e.prototype.lint=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.code=!1,t.mode="lint",this.transform(e,t)},e.prototype.pretransform=function(e,t){var r=new f.default(t,this);return r.wrap(e,function(){return r.addCode(e),r.parseCode(e),r})},e.prototype.transform=function(e,t){var r=new f.default(t,this);return r.wrap(e,function(){return r.addCode(e),r.parseCode(e),r.transform()})},e.prototype.analyse=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments[2];return t.code=!1,r&&(t.plugins=t.plugins||[],t.plugins.push(new l.default({visitor:r}))),this.transform(e,t).metadata},e.prototype.transformFromAst=function(e,t,r){e=(0,o.default)(e);var n=new f.default(r,this);return n.wrap(t,function(){return n.addCode(t),n.addAst(e),n.transform()})},e}();t.default=p,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(42),o=n(a),u=r(41),l=n(u),c=r(119),f=n(c),p=r(50),d=(n(p),function(e){function t(r,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,s.default)(this,t);var a=(0,o.default)(this,e.call(this));return a.plugin=n,a.key=n.key,a.file=r,a.opts=i,a}return(0,l.default)(t,e),t.prototype.addHelper=function(){var e;return(e=this.file).addHelper.apply(e,arguments)},t.prototype.addImport=function(){var e;return(e=this.file).addImport.apply(e,arguments)},t.prototype.getModuleName=function(){var e;return(e=this.file).getModuleName.apply(e,arguments)},t.prototype.buildCodeFrameError=function(){var e;return(e=this.file).buildCodeFrameError.apply(e,arguments)},t}(f.default));t.default=d,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(625),o=n(a),u=/^[ \t]+$/,l=function(){function e(t){(0,s.default)(this,e),this._map=null,this._buf=[],this._last="",this._queue=[],this._position={line:1,column:0},this._sourcePosition={identifierName:null,line:null,column:null,filename:null},this._map=t}return e.prototype.get=function(){this._flush();var e=this._map,t={code:(0,o.default)(this._buf.join("")),map:null,rawMappings:e&&e.getRawMappings()};return e&&Object.defineProperty(t,"map",{configurable:!0,enumerable:!0,get:function(){return this.map=e.get()},set:function(e){Object.defineProperty(this,"map",{value:e,writable:!0})}}),t},e.prototype.append=function(e){this._flush();var t=this._sourcePosition,r=t.line,n=t.column,i=t.filename,s=t.identifierName;this._append(e,r,n,s,i)},e.prototype.queue=function(e){if("\n"===e)for(;this._queue.length>0&&u.test(this._queue[0][0]);)this._queue.shift();var t=this._sourcePosition,r=t.line,n=t.column,i=t.filename,s=t.identifierName;this._queue.unshift([e,r,n,s,i])},e.prototype._flush=function(){for(var e=void 0;e=this._queue.pop();)this._append.apply(this,e)},e.prototype._append=function(e,t,r,n,i){this._map&&"\n"!==e[0]&&this._map.mark(this._position.line,this._position.column,t,r,n,i),this._buf.push(e),this._last=e[e.length-1];for(var s=0;s<e.length;s++)"\n"===e[s]?(this._position.line++,this._position.column=0):this._position.column++},e.prototype.removeTrailingNewline=function(){this._queue.length>0&&"\n"===this._queue[0][0]&&this._queue.shift()},e.prototype.removeLastSemicolon=function(){this._queue.length>0&&";"===this._queue[0][0]&&this._queue.shift()},e.prototype.endsWith=function(e){if(1===e.length){var t=void 0;if(this._queue.length>0){var r=this._queue[0][0];t=r[r.length-1]}else t=this._last;return t===e}var n=this._last+this._queue.reduce(function(e,t){return t[0]+e},"");return e.length<=n.length&&n.slice(-e.length)===e},e.prototype.hasContent=function(){return this._queue.length>0||!!this._last},e.prototype.source=function(e,t){if(!e||t){var r=t?t[e]:null;this._sourcePosition.identifierName=t&&t.identifierName||null,this._sourcePosition.line=r?r.line:null,this._sourcePosition.column=r?r.column:null,this._sourcePosition.filename=t&&t.filename||null}},e.prototype.withSource=function(e,t,r){if(!this._map)return r();var n=this._sourcePosition.line,i=this._sourcePosition.column,s=this._sourcePosition.filename,a=this._sourcePosition.identifierName;this.source(e,t),r(),this._sourcePosition.line=n,this._sourcePosition.column=i,this._sourcePosition.filename=s,this._sourcePosition.identifierName=a},e.prototype.getCurrentColumn=function(){var e=this._queue.reduce(function(e,t){return t[0]+e},""),t=e.lastIndexOf("\n");return-1===t?this._position.column+e.length:e.length-1-t},e.prototype.getCurrentLine=function(){for(var e=this._queue.reduce(function(e,t){return t[0]+e},""),t=0,r=0;r<e.length;r++)"\n"===e[r]&&t++;return this._position.line+t},e}();t.default=l,e.exports=t.default},function(e,t,r){"use strict";function n(e){this.print(e.program,e)}function i(e){this.printInnerComments(e,!1),this.printSequence(e.directives,e),e.directives&&e.directives.length&&this.newline(),this.printSequence(e.body,e)}function s(e){this.token("{"),this.printInnerComments(e);var t=e.directives&&e.directives.length;e.body.length||t?(this.newline(),this.printSequence(e.directives,e,{indent:!0}),t&&this.newline(),this.printSequence(e.body,e,{indent:!0}),this.removeTrailingNewline(),this.source("end",e.loc),this.endsWith("\n")||this.newline(),this.rightBrace()):(this.source("end",e.loc),this.token("}"))}function a(){}function o(e){this.print(e.value,e),this.semicolon()}t.__esModule=!0,t.File=n,t.Program=i,t.BlockStatement=s,t.Noop=a,t.Directive=o;var u=r(123);Object.defineProperty(t,"DirectiveLiteral",{enumerable:!0,get:function(){return u.StringLiteral}})},function(e,t){"use strict";function r(e){this.printJoin(e.decorators,e),this.word("class"),e.id&&(this.space(),this.print(e.id,e)),this.print(e.typeParameters,e),e.superClass&&(this.space(),this.word("extends"),this.space(),this.print(e.superClass,e),this.print(e.superTypeParameters,e)),e.implements&&(this.space(),this.word("implements"),this.space(),this.printList(e.implements,e)),this.space(),this.print(e.body,e)}function n(e){this.token("{"),this.printInnerComments(e),0===e.body.length?this.token("}"):(this.newline(),this.indent(),this.printSequence(e.body,e),this.dedent(),this.endsWith("\n")||this.newline(),this.rightBrace())}function i(e){this.printJoin(e.decorators,e),e.static&&(this.word("static"),this.space()),e.computed?(this.token("["),this.print(e.key,e),this.token("]")):(this._variance(e),this.print(e.key,e)),this.print(e.typeAnnotation,e),e.value&&(this.space(),this.token("="),this.space(),this.print(e.value,e)),this.semicolon()}function s(e){this.printJoin(e.decorators,e),e.static&&(this.word("static"),this.space()),"constructorCall"===e.kind&&(this.word("call"),this.space()),this._method(e)}t.__esModule=!0,t.ClassDeclaration=r,t.ClassBody=n,t.ClassProperty=i,t.ClassMethod=s,t.ClassExpression=r},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){"void"===e.operator||"delete"===e.operator||"typeof"===e.operator?(this.word(e.operator),this.space()):this.token(e.operator),this.print(e.argument,e)}function s(e){this.word("do"),this.space(),this.print(e.body,e)}function a(e){this.token("("),this.print(e.expression,e),this.token(")")}function o(e){e.prefix?(this.token(e.operator),this.print(e.argument,e)):(this.print(e.argument,e),this.token(e.operator))}function u(e){this.print(e.test,e),this.space(),this.token("?"),this.space(),this.print(e.consequent,e),this.space(),this.token(":"),this.space(),this.print(e.alternate,e)}function l(e,t){this.word("new"),this.space(),this.print(e.callee,e),(0!==e.arguments.length||!this.format.minified||C.isCallExpression(t,{callee:e})||C.isMemberExpression(t)||C.isNewExpression(t))&&(this.token("("),this.printList(e.arguments,e),this.token(")"))}function c(e){this.printList(e.expressions,e)}function f(){
this.word("this")}function p(){this.word("super")}function d(e){this.token("@"),this.print(e.expression,e),this.newline()}function h(){this.token(","),this.newline(),this.endsWith("\n")||this.space()}function m(e){this.print(e.callee,e),this.token("(");var t=e._prettyCall,r=void 0;t&&(r=h,this.newline(),this.indent()),this.printList(e.arguments,e,{separator:r}),t&&(this.newline(),this.dedent()),this.token(")")}function y(){this.word("import")}function v(e){return function(t){if(this.word(e),t.delegate&&this.token("*"),t.argument){this.space();var r=this.startTerminatorless();this.print(t.argument,t),this.endTerminatorless(r)}}}function g(){this.semicolon(!0)}function b(e){this.print(e.expression,e),this.semicolon()}function E(e){this.print(e.left,e),e.left.optional&&this.token("?"),this.print(e.left.typeAnnotation,e),this.space(),this.token("="),this.space(),this.print(e.right,e)}function x(e,t){var r=this.inForStatementInitCounter&&"in"===e.operator&&!P.needsParens(e,t);r&&this.token("("),this.print(e.left,e),this.space(),"in"===e.operator||"instanceof"===e.operator?this.word(e.operator):this.token(e.operator),this.space(),this.print(e.right,e),r&&this.token(")")}function A(e){this.print(e.object,e),this.token("::"),this.print(e.callee,e)}function S(e){if(this.print(e.object,e),!e.computed&&C.isMemberExpression(e.property))throw new TypeError("Got a MemberExpression for MemberExpression property");var t=e.computed;C.isLiteral(e.property)&&"number"==typeof e.property.value&&(t=!0),t?(this.token("["),this.print(e.property,e),this.token("]")):(this.token("."),this.print(e.property,e))}function _(e){this.print(e.meta,e),this.token("."),this.print(e.property,e)}t.__esModule=!0,t.LogicalExpression=t.BinaryExpression=t.AwaitExpression=t.YieldExpression=void 0,t.UnaryExpression=i,t.DoExpression=s,t.ParenthesizedExpression=a,t.UpdateExpression=o,t.ConditionalExpression=u,t.NewExpression=l,t.SequenceExpression=c,t.ThisExpression=f,t.Super=p,t.Decorator=d,t.CallExpression=m,t.Import=y,t.EmptyStatement=g,t.ExpressionStatement=b,t.AssignmentPattern=E,t.AssignmentExpression=x,t.BindExpression=A,t.MemberExpression=S,t.MetaProperty=_;var D=r(1),C=n(D),w=r(187),P=n(w);t.YieldExpression=v("yield"),t.AwaitExpression=v("await");t.BinaryExpression=x,t.LogicalExpression=x},function(e,t,r){"use strict";function n(){this.word("any")}function i(e){this.print(e.elementType,e),this.token("["),this.token("]")}function s(){this.word("boolean")}function a(e){this.word(e.value?"true":"false")}function o(){this.word("null")}function u(e,t){Q.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("class"),this.space(),this._interfaceish(e)}function l(e,t){Q.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("function"),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation.typeAnnotation,e),this.semicolon()}function c(e){this.word("declare"),this.space(),this.InterfaceDeclaration(e)}function f(e){this.word("declare"),this.space(),this.word("module"),this.space(),this.print(e.id,e),this.space(),this.print(e.body,e)}function p(e){this.word("declare"),this.space(),this.word("module"),this.token("."),this.word("exports"),this.print(e.typeAnnotation,e)}function d(e){this.word("declare"),this.space(),this.TypeAlias(e)}function h(e,t){Q.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.OpaqueType(e)}function m(e,t){Q.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("var"),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation,e),this.semicolon()}function y(e){this.word("declare"),this.space(),this.word("export"),this.space(),e.default&&(this.word("default"),this.space()),v.apply(this,arguments)}function v(e){if(e.declaration){var t=e.declaration;this.print(t,e),Q.isStatement(t)||this.semicolon()}else this.token("{"),e.specifiers.length&&(this.space(),this.printList(e.specifiers,e),this.space()),this.token("}"),e.source&&(this.space(),this.word("from"),this.space(),this.print(e.source,e)),this.semicolon()}function g(){this.token("*")}function b(e,t){this.print(e.typeParameters,e),this.token("("),this.printList(e.params,e),e.rest&&(e.params.length&&(this.token(","),this.space()),this.token("..."),this.print(e.rest,e)),this.token(")"),"ObjectTypeCallProperty"===t.type||"DeclareFunction"===t.type?this.token(":"):(this.space(),this.token("=>")),this.space(),this.print(e.returnType,e)}function E(e){this.print(e.name,e),e.optional&&this.token("?"),this.token(":"),this.space(),this.print(e.typeAnnotation,e)}function x(e){this.print(e.id,e),this.print(e.typeParameters,e)}function A(e){this.print(e.id,e),this.print(e.typeParameters,e),e.extends.length&&(this.space(),this.word("extends"),this.space(),this.printList(e.extends,e)),e.mixins&&e.mixins.length&&(this.space(),this.word("mixins"),this.space(),this.printList(e.mixins,e)),this.space(),this.print(e.body,e)}function S(e){"plus"===e.variance?this.token("+"):"minus"===e.variance&&this.token("-")}function _(e){this.word("interface"),this.space(),this._interfaceish(e)}function D(){this.space(),this.token("&"),this.space()}function C(e){this.printJoin(e.types,e,{separator:D})}function w(){this.word("mixed")}function P(){this.word("empty")}function k(e){this.token("?"),this.print(e.typeAnnotation,e)}function F(){this.word("number")}function T(){this.word("string")}function O(){this.word("this")}function B(e){this.token("["),this.printList(e.types,e),this.token("]")}function R(e){this.word("typeof"),this.space(),this.print(e.argument,e)}function I(e){this.word("type"),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),this.space(),this.token("="),this.space(),this.print(e.right,e),this.semicolon()}function M(e){this.word("opaque"),this.space(),this.word("type"),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),e.supertype&&(this.token(":"),this.space(),this.print(e.supertype,e)),e.impltype&&(this.space(),this.token("="),this.space(),this.print(e.impltype,e)),this.semicolon()}function N(e){this.token(":"),this.space(),e.optional&&this.token("?"),this.print(e.typeAnnotation,e)}function L(e){this._variance(e),this.word(e.name),e.bound&&this.print(e.bound,e),e.default&&(this.space(),this.token("="),this.space(),this.print(e.default,e))}function j(e){this.token("<"),this.printList(e.params,e,{}),this.token(">")}function U(e){var t=this;e.exact?this.token("{|"):this.token("{");var r=e.properties.concat(e.callProperties,e.indexers);r.length&&(this.space(),this.printJoin(r,e,{addNewlines:function(e){if(e&&!r[0])return 1},indent:!0,statement:!0,iterator:function(){1!==r.length&&(t.format.flowCommaSeparator?t.token(","):t.semicolon(),t.space())}}),this.space()),e.exact?this.token("|}"):this.token("}")}function V(e){e.static&&(this.word("static"),this.space()),this.print(e.value,e)}function G(e){e.static&&(this.word("static"),this.space()),this._variance(e),this.token("["),this.print(e.id,e),this.token(":"),this.space(),this.print(e.key,e),this.token("]"),this.token(":"),this.space(),this.print(e.value,e)}function W(e){e.static&&(this.word("static"),this.space()),this._variance(e),this.print(e.key,e),e.optional&&this.token("?"),this.token(":"),this.space(),this.print(e.value,e)}function Y(e){this.token("..."),this.print(e.argument,e)}function q(e){this.print(e.qualification,e),this.token("."),this.print(e.id,e)}function K(){this.space(),this.token("|"),this.space()}function H(e){this.printJoin(e.types,e,{separator:K})}function J(e){this.token("("),this.print(e.expression,e),this.print(e.typeAnnotation,e),this.token(")")}function X(){this.word("void")}t.__esModule=!0,t.TypeParameterDeclaration=t.StringLiteralTypeAnnotation=t.NumericLiteralTypeAnnotation=t.GenericTypeAnnotation=t.ClassImplements=void 0,t.AnyTypeAnnotation=n,t.ArrayTypeAnnotation=i,t.BooleanTypeAnnotation=s,t.BooleanLiteralTypeAnnotation=a,t.NullLiteralTypeAnnotation=o,t.DeclareClass=u,t.DeclareFunction=l,t.DeclareInterface=c,t.DeclareModule=f,t.DeclareModuleExports=p,t.DeclareTypeAlias=d,t.DeclareOpaqueType=h,t.DeclareVariable=m,t.DeclareExportDeclaration=y,t.ExistentialTypeParam=g,t.FunctionTypeAnnotation=b,t.FunctionTypeParam=E,t.InterfaceExtends=x,t._interfaceish=A,t._variance=S,t.InterfaceDeclaration=_,t.IntersectionTypeAnnotation=C,t.MixedTypeAnnotation=w,t.EmptyTypeAnnotation=P,t.NullableTypeAnnotation=k;var z=r(123);Object.defineProperty(t,"NumericLiteralTypeAnnotation",{enumerable:!0,get:function(){return z.NumericLiteral}}),Object.defineProperty(t,"StringLiteralTypeAnnotation",{enumerable:!0,get:function(){return z.StringLiteral}}),t.NumberTypeAnnotation=F,t.StringTypeAnnotation=T,t.ThisTypeAnnotation=O,t.TupleTypeAnnotation=B,t.TypeofTypeAnnotation=R,t.TypeAlias=I,t.OpaqueType=M,t.TypeAnnotation=N,t.TypeParameter=L,t.TypeParameterInstantiation=j,t.ObjectTypeAnnotation=U,t.ObjectTypeCallProperty=V,t.ObjectTypeIndexer=G,t.ObjectTypeProperty=W,t.ObjectTypeSpreadProperty=Y,t.QualifiedTypeIdentifier=q,t.UnionTypeAnnotation=H,t.TypeCastExpression=J,t.VoidTypeAnnotation=X;var $=r(1),Q=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}($);t.ClassImplements=x,t.GenericTypeAnnotation=x,t.TypeParameterDeclaration=j},function(e,t,r){"use strict";function n(e){this.print(e.name,e),e.value&&(this.token("="),this.print(e.value,e))}function i(e){this.word(e.name)}function s(e){this.print(e.namespace,e),this.token(":"),this.print(e.name,e)}function a(e){this.print(e.object,e),this.token("."),this.print(e.property,e)}function o(e){this.token("{"),this.token("..."),this.print(e.argument,e),this.token("}")}function u(e){this.token("{"),this.print(e.expression,e),this.token("}")}function l(e){this.token("{"),this.token("..."),this.print(e.expression,e),this.token("}")}function c(e){this.token(e.value)}function f(e){var t=e.openingElement;if(this.print(t,e),!t.selfClosing){this.indent();for(var r=e.children,n=Array.isArray(r),i=0,r=n?r:(0,v.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;this.print(a,e)}this.dedent(),this.print(e.closingElement,e)}}function p(){this.space()}function d(e){this.token("<"),this.print(e.name,e),e.attributes.length>0&&(this.space(),this.printJoin(e.attributes,e,{separator:p})),e.selfClosing?(this.space(),this.token("/>")):this.token(">")}function h(e){this.token("</"),this.print(e.name,e),this.token(">")}function m(){}t.__esModule=!0;var y=r(2),v=function(e){return e&&e.__esModule?e:{default:e}}(y);t.JSXAttribute=n,t.JSXIdentifier=i,t.JSXNamespacedName=s,t.JSXMemberExpression=a,t.JSXSpreadAttribute=o,t.JSXExpressionContainer=u,t.JSXSpreadChild=l,t.JSXText=c,t.JSXElement=f,t.JSXOpeningElement=d,t.JSXClosingElement=h,t.JSXEmptyExpression=m},function(e,t,r){"use strict";function n(e){var t=this;this.print(e.typeParameters,e),this.token("("),this.printList(e.params,e,{iterator:function(e){e.optional&&t.token("?"),t.print(e.typeAnnotation,e)}}),this.token(")"),e.returnType&&this.print(e.returnType,e)}function i(e){var t=e.kind,r=e.key;"method"!==t&&"init"!==t||e.generator&&this.token("*"),"get"!==t&&"set"!==t||(this.word(t),this.space()),e.async&&(this.word("async"),this.space()),e.computed?(this.token("["),this.print(r,e),this.token("]")):this.print(r,e),this._params(e),this.space(),this.print(e.body,e)}function s(e){e.async&&(this.word("async"),this.space()),this.word("function"),e.generator&&this.token("*"),e.id?(this.space(),this.print(e.id,e)):this.space(),this._params(e),this.space(),this.print(e.body,e)}function a(e){e.async&&(this.word("async"),this.space());var t=e.params[0];1===e.params.length&&l.isIdentifier(t)&&!o(e,t)?this.print(t,e):this._params(e),this.space(),this.token("=>"),this.space(),this.print(e.body,e)}function o(e,t){return e.typeParameters||e.returnType||t.typeAnnotation||t.optional||t.trailingComments}t.__esModule=!0,t.FunctionDeclaration=void 0,t._params=n,t._method=i,t.FunctionExpression=s,t.ArrowFunctionExpression=a;var u=r(1),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(u);t.FunctionDeclaration=s},function(e,t,r){"use strict";function n(e){"type"!==e.importKind&&"typeof"!==e.importKind||(this.word(e.importKind),this.space()),this.print(e.imported,e),e.local&&e.local.name!==e.imported.name&&(this.space(),this.word("as"),this.space(),this.print(e.local,e))}function i(e){this.print(e.local,e)}function s(e){this.print(e.exported,e)}function a(e){this.print(e.local,e),e.exported&&e.local.name!==e.exported.name&&(this.space(),this.word("as"),this.space(),this.print(e.exported,e))}function o(e){this.token("*"),this.space(),this.word("as"),this.space(),this.print(e.exported,e)}function u(e){this.word("export"),this.space(),this.token("*"),this.space(),this.word("from"),this.space(),this.print(e.source,e),this.semicolon()}function l(){this.word("export"),this.space(),f.apply(this,arguments)}function c(){this.word("export"),this.space(),this.word("default"),this.space(),f.apply(this,arguments)}function f(e){if(e.declaration){var t=e.declaration;this.print(t,e),m.isStatement(t)||this.semicolon()}else{"type"===e.exportKind&&(this.word("type"),this.space());for(var r=e.specifiers.slice(0),n=!1;;){var i=r[0];if(!m.isExportDefaultSpecifier(i)&&!m.isExportNamespaceSpecifier(i))break;n=!0,this.print(r.shift(),e),r.length&&(this.token(","),this.space())}(r.length||!r.length&&!n)&&(this.token("{"),r.length&&(this.space(),this.printList(r,e),this.space()),this.token("}")),e.source&&(this.space(),this.word("from"),this.space(),this.print(e.source,e)),this.semicolon()}}function p(e){this.word("import"),this.space(),"type"!==e.importKind&&"typeof"!==e.importKind||(this.word(e.importKind),this.space());var t=e.specifiers.slice(0);if(t&&t.length){for(;;){var r=t[0];if(!m.isImportDefaultSpecifier(r)&&!m.isImportNamespaceSpecifier(r))break;this.print(t.shift(),e),t.length&&(this.token(","),this.space())}t.length&&(this.token("{"),this.space(),this.printList(t,e),this.space(),this.token("}")),this.space(),this.word("from"),this.space()}this.print(e.source,e),this.semicolon()}function d(e){this.token("*"),this.space(),this.word("as"),this.space(),this.print(e.local,e)}t.__esModule=!0,t.ImportSpecifier=n,t.ImportDefaultSpecifier=i,t.ExportDefaultSpecifier=s,t.ExportSpecifier=a,t.ExportNamespaceSpecifier=o,t.ExportAllDeclaration=u,t.ExportNamedDeclaration=l,t.ExportDefaultDeclaration=c,t.ImportDeclaration=p,t.ImportNamespaceSpecifier=d;var h=r(1),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h)},function(e,t,r){"use strict";function n(e){this.word("with"),this.space(),this.token("("),this.print(e.object,e),this.token(")"),this.printBlock(e)}function i(e){this.word("if"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.space();var t=e.alternate&&S.isIfStatement(s(e.consequent));t&&(this.token("{"),this.newline(),this.indent()),this.printAndIndentOnComments(e.consequent,e),t&&(this.dedent(),this.newline(),this.token("}")),e.alternate&&(this.endsWith("}")&&this.space(),this.word("else"),this.space(),this.printAndIndentOnComments(e.alternate,e))}function s(e){return S.isStatement(e.body)?s(e.body):e}function a(e){this.word("for"),this.space(),this.token("("),this.inForStatementInitCounter++,this.print(e.init,e),this.inForStatementInitCounter--,this.token(";"),e.test&&(this.space(),this.print(e.test,e)),this.token(";"),e.update&&(this.space(),this.print(e.update,e)),this.token(")"),this.printBlock(e)}function o(e){this.word("while"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.printBlock(e)}function u(e){this.word("do"),this.space(),this.print(e.body,e),this.space(),this.word("while"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.semicolon()}function l(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"label";return function(r){this.word(e);var n=r[t];if(n){this.space();var i=this.startTerminatorless();this.print(n,r),this.endTerminatorless(i)}this.semicolon()}}function c(e){this.print(e.label,e),this.token(":"),this.space(),this.print(e.body,e)}function f(e){this.word("try"),this.space(),this.print(e.block,e),this.space(),e.handlers?this.print(e.handlers[0],e):this.print(e.handler,e),e.finalizer&&(this.space(),this.word("finally"),this.space(),this.print(e.finalizer,e))}function p(e){this.word("catch"),this.space(),this.token("("),this.print(e.param,e),this.token(")"),this.space(),this.print(e.body,e)}function d(e){this.word("switch"),this.space(),this.token("("),this.print(e.discriminant,e),this.token(")"),this.space(),this.token("{"),this.printSequence(e.cases,e,{indent:!0,addNewlines:function(t,r){if(!t&&e.cases[e.cases.length-1]===r)return-1}}),this.token("}")}function h(e){e.test?(this.word("case"),this.space(),this.print(e.test,e),this.token(":")):(this.word("default"),this.token(":")),e.consequent.length&&(this.newline(),this.printSequence(e.consequent,e,{indent:!0}))}function m(){this.word("debugger"),this.semicolon()}function y(){if(this.token(","),this.newline(),this.endsWith("\n"))for(var e=0;e<4;e++)this.space(!0)}function v(){if(this.token(","),this.newline(),this.endsWith("\n"))for(var e=0;e<6;e++)this.space(!0)}function g(e,t){this.word(e.kind),this.space();var r=!1;if(!S.isFor(t))for(var n=e.declarations,i=Array.isArray(n),s=0,n=i?n:(0,x.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;o.init&&(r=!0)}var u=void 0;r&&(u="const"===e.kind?v:y),this.printList(e.declarations,e,{separator:u}),(!S.isFor(t)||t.left!==e&&t.init!==e)&&this.semicolon()}function b(e){this.print(e.id,e),this.print(e.id.typeAnnotation,e),e.init&&(this.space(),this.token("="),this.space(),this.print(e.init,e))}t.__esModule=!0,t.ThrowStatement=t.BreakStatement=t.ReturnStatement=t.ContinueStatement=t.ForAwaitStatement=t.ForOfStatement=t.ForInStatement=void 0;var E=r(2),x=function(e){return e&&e.__esModule?e:{default:e}}(E);t.WithStatement=n,t.IfStatement=i,t.ForStatement=a,t.WhileStatement=o,t.DoWhileStatement=u,t.LabeledStatement=c,t.TryStatement=f,t.CatchClause=p,t.SwitchStatement=d,t.SwitchCase=h,t.DebuggerStatement=m,t.VariableDeclaration=g,t.VariableDeclarator=b;var A=r(1),S=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(A),_=function(e){return function(t){this.word("for"),this.space(),"await"===e&&(this.word("await"),this.space()),this.token("("),this.print(t.left,t),this.space(),this.word("await"===e?"of":e),this.space(),this.print(t.right,t),this.token(")"),this.printBlock(t)}};t.ForInStatement=_("in"),t.ForOfStatement=_("of"),t.ForAwaitStatement=_("await"),t.ContinueStatement=l("continue"),t.ReturnStatement=l("return","argument"),t.BreakStatement=l("break"),t.ThrowStatement=l("throw","argument")},function(e,t){"use strict";function r(e){this.print(e.tag,e),this.print(e.quasi,e)}function n(e,t){var r=t.quasis[0]===e,n=t.quasis[t.quasis.length-1]===e,i=(r?"`":"}")+e.value.raw+(n?"`":"${");this.token(i)}function i(e){for(var t=e.quasis,r=0;r<t.length;r++)this.print(t[r],e),r+1<t.length&&this.print(e.expressions[r],e)}t.__esModule=!0,t.TaggedTemplateExpression=r,t.TemplateElement=n,t.TemplateLiteral=i},function(e,t,r){"use strict";function n(e,t){return b.isArrayTypeAnnotation(t)}function i(e,t){return b.isMemberExpression(t)&&t.object===e}function s(e,t,r){return v(r,{considerArrow:!0})}function a(e,t,r){return v(r)}function o(e,t){if((b.isCallExpression(t)||b.isNewExpression(t))&&t.callee===e||b.isUnaryLike(t)||b.isMemberExpression(t)&&t.object===e||b.isAwaitExpression(t))return!0;if(b.isBinary(t)){var r=t.operator,n=E[r],i=e.operator,s=E[i];if(n===s&&t.right===e&&!b.isLogicalExpression(t)||n>s)return!0}return!1}function u(e,t){return"in"===e.operator&&(b.isVariableDeclarator(t)||b.isFor(t))}function l(e,t){return!(b.isForStatement(t)||b.isThrowStatement(t)||b.isReturnStatement(t)||b.isIfStatement(t)&&t.test===e||b.isWhileStatement(t)&&t.test===e||b.isForInStatement(t)&&t.right===e||b.isSwitchStatement(t)&&t.discriminant===e||b.isExpressionStatement(t)&&t.expression===e)}function c(e,t){return b.isBinary(t)||b.isUnaryLike(t)||b.isCallExpression(t)||b.isMemberExpression(t)||b.isNewExpression(t)||b.isConditionalExpression(t)&&e===t.test}function f(e,t,r){return v(r,{considerDefaultExports:!0})}function p(e,t){return b.isMemberExpression(t,{object:e})||b.isCallExpression(t,{callee:e})||b.isNewExpression(t,{callee:e})}function d(e,t,r){return v(r,{considerDefaultExports:!0})}function h(e,t){return!!(b.isExportDeclaration(t)||b.isBinaryExpression(t)||b.isLogicalExpression(t)||b.isUnaryExpression(t)||b.isTaggedTemplateExpression(t))||p(e,t)}function m(e,t){return!!(b.isUnaryLike(t)||b.isBinary(t)||b.isConditionalExpression(t,{test:e})||b.isAwaitExpression(t))||p(e,t)}function y(e){return!!b.isObjectPattern(e.left)||m.apply(void 0,arguments)}function v(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.considerArrow,n=void 0!==r&&r,i=t.considerDefaultExports,s=void 0!==i&&i,a=e.length-1,o=e[a];a--;for(var u=e[a];a>0;){if(b.isExpressionStatement(u,{expression:o})||b.isTaggedTemplateExpression(u)||s&&b.isExportDefaultDeclaration(u,{declaration:o})||n&&b.isArrowFunctionExpression(u,{body:o}))return!0;if(!(b.isCallExpression(u,{callee:o})||b.isSequenceExpression(u)&&u.expressions[0]===o||b.isMemberExpression(u,{object:o})||b.isConditional(u,{test:o})||b.isBinary(u,{left:o})||b.isAssignmentExpression(u,{left:o})))return!1;o=u,a--,u=e[a]}return!1}t.__esModule=!0,t.AwaitExpression=t.FunctionTypeAnnotation=void 0,t.NullableTypeAnnotation=n,t.UpdateExpression=i,t.ObjectExpression=s,t.DoExpression=a,t.Binary=o,t.BinaryExpression=u,t.SequenceExpression=l,t.YieldExpression=c,t.ClassExpression=f,t.UnaryLike=p,t.FunctionExpression=d,t.ArrowFunctionExpression=h,t.ConditionalExpression=m,t.AssignmentExpression=y;var g=r(1),b=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(g),E={"||":0,"&&":1,"|":2,"^":3,"&":4,"==":5,"===":5,"!=":5,"!==":5,"<":6,">":6,"<=":6,">=":6,in:6,instanceof:6,">>":7,"<<":7,">>>":7,"+":8,"-":8,"*":9,"/":9,"%":9,"**":10};t.FunctionTypeAnnotation=n,t.AwaitExpression=c},function(e,t,r){"use strict";function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return l.isMemberExpression(e)?(n(e.object,t),e.computed&&n(e.property,t)):l.isBinary(e)||l.isAssignmentExpression(e)?(n(e.left,t),n(e.right,t)):l.isCallExpression(e)?(t.hasCall=!0,n(e.callee,t)):l.isFunction(e)?t.hasFunction=!0:l.isIdentifier(e)&&(t.hasHelper=t.hasHelper||i(e.callee)),t}function i(e){return l.isMemberExpression(e)?i(e.object)||i(e.property):l.isIdentifier(e)?"require"===e.name||"_"===e.name[0]:l.isCallExpression(e)?i(e.callee):!(!l.isBinary(e)&&!l.isAssignmentExpression(e))&&(l.isIdentifier(e.left)&&i(e.left)||i(e.right))}function s(e){return l.isLiteral(e)||l.isObjectExpression(e)||l.isArrayExpression(e)||l.isIdentifier(e)||l.isMemberExpression(e)}var a=r(588),o=function(e){return e&&e.__esModule?e:{default:e}}(a),u=r(1),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(u);t.nodes={AssignmentExpression:function(e){var t=n(e.right);if(t.hasCall&&t.hasHelper||t.hasFunction)return{before:t.hasFunction,after:!0}},SwitchCase:function(e,t){return{before:e.consequent.length||t.cases[0]===e}},LogicalExpression:function(e){if(l.isFunction(e.left)||l.isFunction(e.right))return{after:!0}},Literal:function(e){if("use strict"===e.value)return{after:!0}},CallExpression:function(e){if(l.isFunction(e.callee)||i(e))return{before:!0,after:!0}},VariableDeclaration:function(e){for(var t=0;t<e.declarations.length;t++){var r=e.declarations[t],a=i(r.id)&&!s(r.init);if(!a){var o=n(r.init);a=i(r.init)&&o.hasCall||o.hasFunction}if(a)return{before:!0,after:!0}}},IfStatement:function(e){if(l.isBlockStatement(e.consequent))return{before:!0,after:!0}}},t.nodes.ObjectProperty=t.nodes.ObjectTypeProperty=t.nodes.ObjectMethod=t.nodes.SpreadProperty=function(e,t){if(t.properties[0]===e)return{before:!0}},t.list={VariableDeclaration:function(e){return(0,o.default)(e.declarations,"init")},ArrayExpression:function(e){return e.elements},ObjectExpression:function(e){return e.properties}},[["Function",!0],["Class",!0],["Loop",!0],["LabeledStatement",!0],["SwitchStatement",!0],["TryStatement",!0]].forEach(function(e){var r=e[0],n=e[1];"boolean"==typeof n&&(n={after:n,before:n}),[r].concat(l.FLIPPED_ALIAS_KEYS[r]||[]).forEach(function(e){t.nodes[e]=function(){return n}})})},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(){this.token(","),this.space()}t.__esModule=!0;var a=r(87),o=i(a),u=r(2),l=i(u),c=r(35),f=i(c),p=r(365),d=i(p),h=r(3),m=i(h),y=r(579),v=i(y),g=r(581),b=i(g),E=r(586),x=i(E),A=r(278),S=i(A),_=r(300),D=i(_),C=r(187),w=n(C),P=r(314),k=i(P),F=r(1),T=n(F),O=/e/i,B=/\.0+$/,R=/^0[box]/,I=function(){function e(t,r,n){(0,m.default)(this,e),this.inForStatementInitCounter=0,this._printStack=[],this._indent=0,this._insideAux=!1,this._printedCommentStarts={},this._parenPushNewlineState=null,this._printAuxAfterOnNextUserNode=!1,this._printedComments=new d.default,this._endsWithInteger=!1,this._endsWithWord=!1,this.format=t||{},this._buf=new D.default(r),this._whitespace=n.length>0?new k.default(n):null}return e.prototype.generate=function(e){return this.print(e),this._maybeAddAuxComment(),this._buf.get()},e.prototype.indent=function(){this.format.compact||this.format.concise||this._indent++},e.prototype.dedent=function(){this.format.compact||this.format.concise||this._indent--},e.prototype.semicolon=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._maybeAddAuxComment(),this._append(";",!e)},e.prototype.rightBrace=function(){this.format.minified&&this._buf.removeLastSemicolon(),this.token("}")},e.prototype.space=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.format.compact||(this._buf.hasContent()&&!this.endsWith(" ")&&!this.endsWith("\n")||e)&&this._space()},e.prototype.word=function(e){this._endsWithWord&&this._space(),this._maybeAddAuxComment(),this._append(e),this._endsWithWord=!0},e.prototype.number=function(e){this.word(e),this._endsWithInteger=(0,x.default)(+e)&&!R.test(e)&&!O.test(e)&&!B.test(e)&&"."!==e[e.length-1]},e.prototype.token=function(e){("--"===e&&this.endsWith("!")||"+"===e[0]&&this.endsWith("+")||"-"===e[0]&&this.endsWith("-")||"."===e[0]&&this._endsWithInteger)&&this._space(),this._maybeAddAuxComment(),this._append(e)},e.prototype.newline=function(e){if(!this.format.retainLines&&!this.format.compact){if(this.format.concise)return void this.space();if(!(this.endsWith("\n\n")||("number"!=typeof e&&(e=1),e=Math.min(2,e),(this.endsWith("{\n")||this.endsWith(":\n"))&&e--,e<=0)))for(var t=0;t<e;t++)this._newline()}},e.prototype.endsWith=function(e){return this._buf.endsWith(e)},e.prototype.removeTrailingNewline=function(){this._buf.removeTrailingNewline()},e.prototype.source=function(e,t){this._catchUp(e,t),this._buf.source(e,t)},e.prototype.withSource=function(e,t,r){this._catchUp(e,t),this._buf.withSource(e,t,r)},e.prototype._space=function(){this._append(" ",!0)},e.prototype._newline=function(){this._append("\n",!0)},e.prototype._append=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._maybeAddParen(e),this._maybeIndent(e),t?this._buf.queue(e):this._buf.append(e),this._endsWithWord=!1,this._endsWithInteger=!1},e.prototype._maybeIndent=function(e){this._indent&&this.endsWith("\n")&&"\n"!==e[0]&&this._buf.queue(this._getIndent())},e.prototype._maybeAddParen=function(e){var t=this._parenPushNewlineState;if(t){this._parenPushNewlineState=null;var r=void 0;for(r=0;r<e.length&&" "===e[r];r++);if(r!==e.length){var n=e[r];"\n"!==n&&"/"!==n||(this.token("("),this.indent(),t.printed=!0)}}},e.prototype._catchUp=function(e,t){if(this.format.retainLines){var r=t?t[e]:null;if(r&&null!==r.line)for(var n=r.line-this._buf.getCurrentLine(),i=0;i<n;i++)this._newline()}},e.prototype._getIndent=function(){return(0,S.default)(this.format.indent.style,this._indent)},e.prototype.startTerminatorless=function(){return this._parenPushNewlineState={printed:!1}},e.prototype.endTerminatorless=function(e){e.printed&&(this.dedent(),this.newline(),this.token(")"))},e.prototype.print=function(e,t){var r=this;if(e){var n=this.format.concise;e._compact&&(this.format.concise=!0);if(!this[e.type])throw new ReferenceError("unknown node of type "+(0,f.default)(e.type)+" with constructor "+(0,f.default)(e&&e.constructor.name));this._printStack.push(e);var i=this._insideAux;this._insideAux=!e.loc,this._maybeAddAuxComment(this._insideAux&&!i);var s=w.needsParens(e,t,this._printStack);this.format.retainFunctionParens&&"FunctionExpression"===e.type&&e.extra&&e.extra.parenthesized&&(s=!0),s&&this.token("("),this._printLeadingComments(e,t);var a=T.isProgram(e)||T.isFile(e)?null:e.loc;this.withSource("start",a,function(){r[e.type](e,t)}),this._printTrailingComments(e,t),s&&this.token(")"),this._printStack.pop(),this.format.concise=n,this._insideAux=i}},e.prototype._maybeAddAuxComment=function(e){e&&this._printAuxBeforeComment(),this._insideAux||this._printAuxAfterComment()},e.prototype._printAuxBeforeComment=function(){if(!this._printAuxAfterOnNextUserNode){this._printAuxAfterOnNextUserNode=!0;var e=this.format.auxiliaryCommentBefore;e&&this._printComment({type:"CommentBlock",value:e})}},e.prototype._printAuxAfterComment=function(){if(this._printAuxAfterOnNextUserNode){this._printAuxAfterOnNextUserNode=!1;var e=this.format.auxiliaryCommentAfter;e&&this._printComment({type:"CommentBlock",value:e})}},e.prototype.getPossibleRaw=function(e){var t=e.extra;if(t&&null!=t.raw&&null!=t.rawValue&&e.value===t.rawValue)return t.raw},e.prototype.printJoin=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e&&e.length){r.indent&&this.indent();for(var n={addNewlines:r.addNewlines},i=0;i<e.length;i++){var s=e[i];s&&(r.statement&&this._printNewline(!0,s,t,n),this.print(s,t),r.iterator&&r.iterator(s,i),r.separator&&i<e.length-1&&r.separator.call(this),r.statement&&this._printNewline(!1,s,t,n))}r.indent&&this.dedent()}},e.prototype.printAndIndentOnComments=function(e,t){var r=!!e.leadingComments;r&&this.indent(),this.print(e,t),r&&this.dedent()},e.prototype.printBlock=function(e){var t=e.body;T.isEmptyStatement(t)||this.space(),this.print(t,e)},e.prototype._printTrailingComments=function(e,t){this._printComments(this._getComments(!1,e,t))},e.prototype._printLeadingComments=function(e,t){this._printComments(this._getComments(!0,e,t))},e.prototype.printInnerComments=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];e.innerComments&&(t&&this.indent(),this._printComments(e.innerComments),t&&this.dedent())},e.prototype.printSequence=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.statement=!0,this.printJoin(e,t,r)},e.prototype.printList=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return null==r.separator&&(r.separator=s),this.printJoin(e,t,r)},e.prototype._printNewline=function(e,t,r,n){var i=this;if(!this.format.retainLines&&!this.format.compact){if(this.format.concise)return void this.space();var s=0;if(null!=t.start&&!t._ignoreUserWhitespace&&this._whitespace)if(e){var a=t.leadingComments,o=a&&(0,v.default)(a,function(e){
return!!e.loc&&i.format.shouldPrintComment(e.value)});s=this._whitespace.getNewlinesBefore(o||t)}else{var u=t.trailingComments,l=u&&(0,b.default)(u,function(e){return!!e.loc&&i.format.shouldPrintComment(e.value)});s=this._whitespace.getNewlinesAfter(l||t)}else{e||s++,n.addNewlines&&(s+=n.addNewlines(e,t)||0);var c=w.needsWhitespaceAfter;e&&(c=w.needsWhitespaceBefore),c(t,r)&&s++,this._buf.hasContent()||(s=0)}this.newline(s)}},e.prototype._getComments=function(e,t){return t&&(e?t.leadingComments:t.trailingComments)||[]},e.prototype._printComment=function(e){var t=this;if(this.format.shouldPrintComment(e.value)&&!e.ignore&&!this._printedComments.has(e)){if(this._printedComments.add(e),null!=e.start){if(this._printedCommentStarts[e.start])return;this._printedCommentStarts[e.start]=!0}this.newline(this._whitespace?this._whitespace.getNewlinesBefore(e):0),this.endsWith("[")||this.endsWith("{")||this.space();var r="CommentLine"===e.type?"//"+e.value+"\n":"/*"+e.value+"*/";if("CommentBlock"===e.type&&this.format.indent.adjustMultilineComment){var n=e.loc&&e.loc.start.column;if(n){var i=new RegExp("\\n\\s{1,"+n+"}","g");r=r.replace(i,"\n")}var s=Math.max(this._getIndent().length,this._buf.getCurrentColumn());r=r.replace(/\n(?!$)/g,"\n"+(0,S.default)(" ",s))}this.withSource("start",e.loc,function(){t._append(r)}),this.newline((this._whitespace?this._whitespace.getNewlinesAfter(e):0)+("CommentLine"===e.type?-1:0))}},e.prototype._printComments=function(e){if(e&&e.length)for(var t=e,r=Array.isArray(t),n=0,t=r?t:(0,l.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;this._printComment(s)}},e}();t.default=I;for(var M=[r(309),r(303),r(308),r(302),r(306),r(307),r(123),r(304),r(301),r(305)],N=0;N<M.length;N++){var L=M[N];(0,o.default)(I.prototype,L)}e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(14),s=n(i),a=r(11),o=n(a),u=r(3),l=n(u),c=r(288),f=n(c),p=function(){function e(t,r){(0,l.default)(this,e),this._cachedMap=null,this._code=r,this._opts=t,this._rawMappings=[]}return e.prototype.get=function(){if(!this._cachedMap){var e=this._cachedMap=new f.default.SourceMapGenerator({file:this._opts.sourceMapTarget,sourceRoot:this._opts.sourceRoot}),t=this._code;"string"==typeof t?e.setSourceContent(this._opts.sourceFileName,t):"object"===(void 0===t?"undefined":(0,o.default)(t))&&(0,s.default)(t).forEach(function(r){e.setSourceContent(r,t[r])}),this._rawMappings.forEach(e.addMapping,e)}return this._cachedMap.toJSON()},e.prototype.getRawMappings=function(){return this._rawMappings.slice()},e.prototype.mark=function(e,t,r,n,i,s){this._lastGenLine!==e&&null===r||this._lastGenLine===e&&this._lastSourceLine===r&&this._lastSourceColumn===n||(this._cachedMap=null,this._lastGenLine=e,this._lastSourceLine=r,this._lastSourceColumn=n,this._rawMappings.push({name:i||void 0,generated:{line:e,column:t},source:null==r?void 0:s||this._opts.sourceFileName,original:null==r?void 0:{line:r,column:n}}))},e}();t.default=p,e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(3),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=function(){function e(t){(0,i.default)(this,e),this.tokens=t,this.used={}}return e.prototype.getNewlinesBefore=function(e){var t=void 0,r=void 0,n=this.tokens,i=this._findToken(function(t){return t.start-e.start},0,n.length);if(i>=0){for(;i&&e.start===n[i-1].start;)--i;t=n[i-1],r=n[i]}return this._getNewlinesBetween(t,r)},e.prototype.getNewlinesAfter=function(e){var t=void 0,r=void 0,n=this.tokens,i=this._findToken(function(t){return t.end-e.end},0,n.length);if(i>=0){for(;i&&e.end===n[i-1].end;)--i;t=n[i],r=n[i+1],","===r.type.label&&(r=n[i+2])}return r&&"eof"===r.type.label?1:this._getNewlinesBetween(t,r)},e.prototype._getNewlinesBetween=function(e,t){if(!t||!t.loc)return 0;for(var r=e?e.loc.end.line:1,n=t.loc.start.line,i=0,s=r;s<n;s++)void 0===this.used[s]&&(this.used[s]=!0,i++);return i},e.prototype._findToken=function(e,t,r){if(t>=r)return-1;var n=t+r>>>1,i=e(this.tokens[n]);return i<0?this._findToken(e,n+1,r):i>0?this._findToken(e,t,n):0===i?n:-1},e}();t.default=s,e.exports=t.default},function(e,t,r){"use strict";function n(e){for(var t=e,r=Array.isArray(t),n=0,t=r?t:(0,s.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var a=i,u=a.node,l=u.expression;if(o.isMemberExpression(l)){var c=a.scope.maybeGenerateMemoised(l.object),f=void 0,p=[];c?(f=c,p.push(o.assignmentExpression("=",c,l.object))):f=l.object,p.push(o.callExpression(o.memberExpression(o.memberExpression(f,l.property,l.computed),o.identifier("bind")),[f])),1===p.length?u.expression=p[0]:u.expression=o.sequenceExpression(p)}}}t.__esModule=!0;var i=r(2),s=function(e){return e&&e.__esModule?e:{default:e}}(i);t.default=n;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(t){return t&&t.operator===e.operator+"="}function r(e,t){return a.assignmentExpression("=",e,t)}var n={};return n.ExpressionStatement=function(n,s){if(!n.isCompletionRecord()){var o=n.node.expression;if(t(o)){var u=[],l=(0,i.default)(o.left,u,s,n.scope,!0);u.push(a.expressionStatement(r(l.ref,e.build(l.uid,o.right)))),n.replaceWithMultiple(u)}}},n.AssignmentExpression=function(n,s){var a=n.node,o=n.scope;if(t(a)){var u=[],l=(0,i.default)(a.left,u,s,o);u.push(r(l.ref,e.build(l.uid,a.right))),n.replaceWithMultiple(u)}},n.BinaryExpression=function(t){var r=t.node;r.operator===e.operator&&t.replaceWith(e.build(r.left,r.right))},n};var n=r(318),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.scope,r=e.node,n=a.functionExpression(null,[],r.body,r.generator,r.async),s=n,u=[];(0,i.default)(e,function(e){return t.push({id:e})});var l={foundThis:!1,foundArguments:!1};e.traverse(o,l),l.foundArguments&&(s=a.memberExpression(n,a.identifier("apply")),u=[],l.foundThis&&u.push(a.thisExpression()),l.foundArguments&&(l.foundThis||u.push(a.nullLiteral()),u.push(a.identifier("arguments"))));var c=a.callExpression(s,u);return r.generator&&(c=a.yieldExpression(c,!0)),a.returnStatement(c)};var n=r(190),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s),o={enter:function(e,t){e.isThisExpression()&&(t.foundThis=!0),e.isReferencedIdentifier({name:"arguments"})&&(t.foundArguments=!0)},Function:function(e){e.skip()}};e.exports=t.default},function(e,t,r){"use strict";function n(e,t,r,n){var i=void 0;if(a.isSuper(e))return e;if(a.isIdentifier(e)){if(n.hasBinding(e.name))return e;i=e}else{if(!a.isMemberExpression(e))throw new Error("We can't explode this node type "+e.type);if(i=e.object,a.isSuper(i)||a.isIdentifier(i)&&n.hasBinding(i.name))return i}var s=n.generateUidIdentifierBasedOnNode(i);return t.push(a.variableDeclaration("var",[a.variableDeclarator(s,i)])),s}function i(e,t,r,n){var i=e.property,s=a.toComputedKey(e,i);if(a.isLiteral(s)&&a.isPureish(s))return s;var o=n.generateUidIdentifierBasedOnNode(i);return t.push(a.variableDeclaration("var",[a.variableDeclarator(o,i)])),o}t.__esModule=!0,t.default=function(e,t,r,s,o){var u=void 0;u=a.isIdentifier(e)&&o?e:n(e,t,r,s);var l=void 0,c=void 0;if(a.isIdentifier(e))l=e,c=u;else{var f=i(e,t,r,s),p=e.computed||a.isLiteral(f);c=l=a.memberExpression(u,f,p)}return{uid:c,ref:l}};var s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i);t.default=function(e){function t(t){if(t.node&&!t.isPure()){var r=e.scope.generateDeclaredUidIdentifier();n.push(l.assignmentExpression("=",r,t.node)),t.replaceWith(r)}}function r(e){if(Array.isArray(e)&&e.length){e=e.reverse(),(0,o.default)(e);for(var r=e,n=Array.isArray(r),i=0,r=n?r:(0,s.default)(r);;){var a;if(n){if(i>=r.length)break;a=r[i++]}else{if(i=r.next(),i.done)break;a=i.value}t(a)}}}e.assertClass();var n=[];t(e.get("superClass")),r(e.get("decorators"));for(var i=e.get("body.body"),a=i,u=Array.isArray(a),c=0,a=u?a:(0,s.default)(a);;){var f;if(u){if(c>=a.length)break;f=a[c++]}else{if(c=a.next(),c.done)break;f=c.value}var p=f;p.is("computed")&&t(p.get("key")),p.has("decorators")&&r(e.get("decorators"))}n&&e.insertBefore(n.map(function(e){return l.expressionStatement(e)}))};var a=r(315),o=n(a),u=r(1),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(u);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.default=function(e,t){var r=e.node,n=e.scope,i=e.parent,a=n.generateUidIdentifier("step"),o=n.generateUidIdentifier("value"),u=r.left,p=void 0;s.isIdentifier(u)||s.isPattern(u)||s.isMemberExpression(u)?p=s.expressionStatement(s.assignmentExpression("=",u,o)):s.isVariableDeclaration(u)&&(p=s.variableDeclaration(u.kind,[s.variableDeclarator(u.declarations[0].id,o)]));var d=c();(0,l.default)(d,f,null,{ITERATOR_HAD_ERROR_KEY:n.generateUidIdentifier("didIteratorError"),ITERATOR_COMPLETION:n.generateUidIdentifier("iteratorNormalCompletion"),ITERATOR_ERROR_KEY:n.generateUidIdentifier("iteratorError"),ITERATOR_KEY:n.generateUidIdentifier("iterator"),GET_ITERATOR:t.getAsyncIterator,OBJECT:r.right,STEP_VALUE:o,STEP_KEY:a,AWAIT:t.wrapAwait}),d=d.body.body;var h=s.isLabeledStatement(i),m=d[3].block.body,y=m[0];return h&&(m[0]=s.labeledStatement(i.label,y)),{replaceParent:h,node:d,declar:p,loop:y}};var i=r(1),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(i),a=r(4),o=n(a),u=r(7),l=n(u),c=(0,o.default)("\n  function* wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY = undefined;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = yield AWAIT(ITERATOR_KEY.next()),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = yield AWAIT(STEP_KEY.value),\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return) {\n          yield AWAIT(ITERATOR_KEY.return());\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n"),f={noScope:!0,Identifier:function(e,t){e.node.name in t&&e.replaceInline(t[e.node.name])},CallExpression:function(e,t){var r=e.node.callee;s.isIdentifier(r)&&"AWAIT"===r.name&&!t.AWAIT&&e.replaceWith(e.node.arguments[0])}};e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(4),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s={};t.default=s,s.typeof=(0,i.default)('\n  (typeof Symbol === "function" && typeof Symbol.iterator === "symbol")\n    ? function (obj) { return typeof obj; }\n    : function (obj) {\n        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? "symbol"\n          : typeof obj;\n      };\n'),s.jsx=(0,i.default)('\n  (function () {\n    var REACT_ELEMENT_TYPE = (typeof Symbol === "function" && Symbol.for && Symbol.for("react.element")) || 0xeac7;\n\n    return function createRawReactElement (type, props, key, children) {\n      var defaultProps = type && type.defaultProps;\n      var childrenLength = arguments.length - 3;\n\n      if (!props && childrenLength !== 0) {\n        // If we\'re going to assign props.children, we create a new object now\n        // to avoid mutating defaultProps.\n        props = {};\n      }\n      if (props && defaultProps) {\n        for (var propName in defaultProps) {\n          if (props[propName] === void 0) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      } else if (!props) {\n        props = defaultProps || {};\n      }\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 3];\n        }\n        props.children = childArray;\n      }\n\n      return {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key === undefined ? null : \'\' + key,\n        ref: null,\n        props: props,\n        _owner: null,\n      };\n    };\n\n  })()\n'),s.asyncIterator=(0,i.default)('\n  (function (iterable) {\n    if (typeof Symbol === "function") {\n      if (Symbol.asyncIterator) {\n        var method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        return iterable[Symbol.iterator]();\n      }\n    }\n    throw new TypeError("Object is not async iterable");\n  })\n'),s.asyncGenerator=(0,i.default)('\n  (function () {\n    function AwaitValue(value) {\n      this.value = value;\n    }\n\n    function AsyncGenerator(gen) {\n      var front, back;\n\n      function send(key, arg) {\n        return new Promise(function (resolve, reject) {\n          var request = {\n            key: key,\n            arg: arg,\n            resolve: resolve,\n            reject: reject,\n            next: null\n          };\n\n          if (back) {\n            back = back.next = request;\n          } else {\n            front = back = request;\n            resume(key, arg);\n          }\n        });\n      }\n\n      function resume(key, arg) {\n        try {\n          var result = gen[key](arg)\n          var value = result.value;\n          if (value instanceof AwaitValue) {\n            Promise.resolve(value.value).then(\n              function (arg) { resume("next", arg); },\n              function (arg) { resume("throw", arg); });\n          } else {\n            settle(result.done ? "return" : "normal", result.value);\n          }\n        } catch (err) {\n          settle("throw", err);\n        }\n      }\n\n      function settle(type, value) {\n        switch (type) {\n          case "return":\n            front.resolve({ value: value, done: true });\n            break;\n          case "throw":\n            front.reject(value);\n            break;\n          default:\n            front.resolve({ value: value, done: false });\n            break;\n        }\n\n        front = front.next;\n        if (front) {\n          resume(front.key, front.arg);\n        } else {\n          back = null;\n        }\n      }\n\n      this._invoke = send;\n\n      // Hide "return" method if generator return is not supported\n      if (typeof gen.return !== "function") {\n        this.return = undefined;\n      }\n    }\n\n    if (typeof Symbol === "function" && Symbol.asyncIterator) {\n      AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n    }\n\n    AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };\n    AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };\n    AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };\n\n    return {\n      wrap: function (fn) {\n        return function () {\n          return new AsyncGenerator(fn.apply(this, arguments));\n        };\n      },\n      await: function (value) {\n        return new AwaitValue(value);\n      }\n    };\n\n  })()\n'),s.asyncGeneratorDelegate=(0,i.default)('\n  (function (inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === "function" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump("next", value);\n    };\n\n    if (typeof inner.throw === "function") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump("throw", value);\n      };\n    }\n\n    if (typeof inner.return === "function") {\n      iter.return = function (value) {\n        return pump("return", value);\n      };\n    }\n\n    return iter;\n  })\n'),s.asyncToGenerator=(0,i.default)('\n  (function (fn) {\n    return function () {\n      var gen = fn.apply(this, arguments);\n      return new Promise(function (resolve, reject) {\n        function step(key, arg) {\n          try {\n            var info = gen[key](arg);\n            var value = info.value;\n          } catch (error) {\n            reject(error);\n            return;\n          }\n\n          if (info.done) {\n            resolve(value);\n          } else {\n            return Promise.resolve(value).then(function (value) {\n              step("next", value);\n            }, function (err) {\n              step("throw", err);\n            });\n          }\n        }\n\n        return step("next");\n      });\n    };\n  })\n'),s.classCallCheck=(0,i.default)('\n  (function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError("Cannot call a class as a function");\n    }\n  });\n'),s.createClass=(0,i.default)('\n  (function() {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i ++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if ("value" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })()\n'),s.defineEnumerableProperties=(0,i.default)('\n  (function (obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ("value" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n    return obj;\n  })\n'),s.defaults=(0,i.default)("\n  (function (obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  })\n"),s.defineProperty=(0,i.default)("\n  (function (obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  });\n"),s.extends=(0,i.default)("\n  Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  })\n"),s.get=(0,i.default)('\n  (function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if ("value" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  });\n'),s.inherits=(0,i.default)('\n  (function (subClass, superClass) {\n    if (typeof superClass !== "function" && superClass !== null) {\n      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  })\n'),s.instanceof=(0,i.default)('\n  (function (left, right) {\n    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  });\n'),s.interopRequireDefault=(0,i.default)("\n  (function (obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  })\n"),s.interopRequireWildcard=(0,i.default)("\n  (function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n      newObj.default = obj;\n      return newObj;\n    }\n  })\n"),s.newArrowCheck=(0,i.default)('\n  (function (innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError("Cannot instantiate an arrow function");\n    }\n  });\n'),s.objectDestructuringEmpty=(0,i.default)('\n  (function (obj) {\n    if (obj == null) throw new TypeError("Cannot destructure undefined");\n  });\n'),s.objectWithoutProperties=(0,i.default)("\n  (function (obj, keys) {\n    var target = {};\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n    return target;\n  })\n"),s.possibleConstructorReturn=(0,i.default)('\n  (function (self, call) {\n    if (!self) {\n      throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n    }\n    return call && (typeof call === "object" || typeof call === "function") ? call : self;\n  });\n'),s.selfGlobal=(0,i.default)('\n  typeof global === "undefined" ? self : global\n'),s.set=(0,i.default)('\n  (function set(object, property, value, receiver) {\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent !== null) {\n        set(parent, property, value, receiver);\n      }\n    } else if ("value" in desc && desc.writable) {\n      desc.value = value;\n    } else {\n      var setter = desc.set;\n\n      if (setter !== undefined) {\n        setter.call(receiver, value);\n      }\n    }\n\n    return value;\n  });\n'),s.slicedToArray=(0,i.default)('\n  (function () {\n    // Broken out into a separate function to avoid deoptimizations due to the try/catch for the\n    // array iterator case.\n    function sliceIterator(arr, i) {\n      // this is an expanded form of `for...of` that properly supports abrupt completions of\n      // iterators etc. variable names have been minimised to reduce the size of this massive\n      // helper. sometimes spec compliancy is annoying :(\n      //\n      // _n = _iteratorNormalCompletion\n      // _d = _didIteratorError\n      // _e = _iteratorError\n      // _i = _iterator\n      // _s = _step\n\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i["return"]) _i["return"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError("Invalid attempt to destructure non-iterable instance");\n      }\n    };\n  })();\n'),s.slicedToArrayLoose=(0,i.default)('\n  (function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      var _arr = [];\n      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n        _arr.push(_step.value);\n        if (i && _arr.length === i) break;\n      }\n      return _arr;\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  });\n'),s.taggedTemplateLiteral=(0,i.default)("\n  (function (strings, raw) {\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  });\n"),s.taggedTemplateLiteralLoose=(0,i.default)("\n  (function (strings, raw) {\n    strings.raw = raw;\n    return strings;\n  });\n"),s.temporalRef=(0,i.default)('\n  (function (val, name, undef) {\n    if (val === undef) {\n      throw new ReferenceError(name + " is not defined - temporal dead zone");\n    } else {\n      return val;\n    }\n  })\n'),s.temporalUndefined=(0,i.default)("\n  ({})\n"),s.toArray=(0,i.default)("\n  (function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  });\n"),s.toConsumableArray=(0,i.default)("\n  (function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  });\n"),e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{pre:function(e){e.set("helpersNamespace",t.identifier("babelHelpers"))}}},e.exports=t.default},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(89);e.exports=function(e){var t=e.types,r={};return{visitor:{Identifier:function(e,s){if("MemberExpression"!==e.parent.type&&"ClassMethod"!==e.parent.type&&!e.isPure()&&s.opts.hasOwnProperty(e.node.name)){var a=s.opts[e.node.name];void 0!==a&&null!==a||(a=t.identifier(String(a)));var o=void 0===a?"undefined":n(a);"string"===o||"boolean"===o?a={type:o,replacement:a}:t.isNode(a)?a={type:"node",replacement:a}:"object"===o&&"node"===a.type&&"string"==typeof a.replacement&&(a.replacement=r[a.replacement]?r[a.replacement]:i.parseExpression(a.replacement));var u=a.replacement;switch(a.type){case"boolean":e.replaceWith(t.booleanLiteral(u));break;case"node":t.isNode(u)&&e.replaceWith(u);break;default:var l=String(u);e.replaceWith(t.stringLiteral(l))}}}}}}},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("dynamicImport")}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{manipulateOptions:function(e,t){t.plugins.push("functionSent")}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{inherits:r(67)}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types,n={Function:function(e){e.skip()},YieldExpression:function(e,r){var n=e.node;if(n.delegate){var i=r.addHelper("asyncGeneratorDelegate");n.argument=t.callExpression(i,[t.callExpression(r.addHelper("asyncIterator"),[n.argument]),t.memberExpression(r.addHelper("asyncGenerator"),t.identifier("await"))])}}};return{inherits:r(195),visitor:{Function:function(e,r){e.node.async&&e.node.generator&&(e.traverse(n,r),(0,i.default)(e,r.file,{wrapAsync:t.memberExpression(r.addHelper("asyncGenerator"),t.identifier("wrap")),wrapAwait:t.memberExpression(r.addHelper("asyncGenerator"),t.identifier("await"))}))}}}};var n=r(124),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return{inherits:r(67),visitor:{Function:function(e,t){e.node.async&&!e.node.generator&&(0,i.default)(e,t.file,{wrapAsync:t.addImport(t.opts.module,t.opts.method)})}}}};var n=r(124),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){function t(e,t){if(!t.applyDecoratedDescriptor){t.applyDecoratedDescriptor=e.scope.generateUidIdentifier("applyDecoratedDescriptor");var r=f({NAME:t.applyDecoratedDescriptor});e.scope.getProgramParent().path.unshiftContainer("body",r)}return t.applyDecoratedDescriptor}function n(e,t){if(!t.initializerDefineProp){t.initializerDefineProp=e.scope.generateUidIdentifier("initDefineProp");var r=c({NAME:t.initializerDefineProp});e.scope.getProgramParent().path.unshiftContainer("body",r)}return t.initializerDefineProp}function i(e,t){if(!t.initializerWarningHelper){t.initializerWarningHelper=e.scope.generateUidIdentifier("initializerWarningHelper");var r=l({NAME:t.initializerWarningHelper});e.scope.getProgramParent().path.unshiftContainer("body",r)}return t.initializerWarningHelper}function p(e){var t=(e.isClass()?[e].concat(e.get("body.body")):e.get("properties")).reduce(function(e,t){return e.concat(t.node.decorators||[])},[]),r=t.filter(function(e){return!v.isIdentifier(e.expression)});if(0!==r.length)return v.sequenceExpression(r.map(function(t){var r=t.expression,n=t.expression=e.scope.generateDeclaredUidIdentifier("dec");return v.assignmentExpression("=",n,r)}).concat([e.node]))}function d(e,t){var r=e.node.decorators||[];if(e.node.decorators=null,0!==r.length){var n=e.scope.generateDeclaredUidIdentifier("class");return r.map(function(e){return e.expression}).reverse().reduce(function(e,t){return s({CLASS_REF:n,DECORATOR:t,INNER:e}).expression},e.node)}}function h(e,t){if(e.node.body.body.some(function(e){return(e.decorators||[]).length>0}))return y(e,t,e.node.body.body)}function m(e,t){if(e.node.properties.some(function(e){return(e.decorators||[]).length>0}))return y(e,t,e.node.properties)}function y(e,r,n){var s=(e.scope.generateDeclaredUidIdentifier("desc"),e.scope.generateDeclaredUidIdentifier("value"),
e.scope.generateDeclaredUidIdentifier(e.isClass()?"class":"obj")),l=n.reduce(function(n,l){var c=l.decorators||[];if(l.decorators=null,0===c.length)return n;if(l.computed)throw e.buildCodeFrameError("Computed method/property decorators are not yet supported.");var f=v.isLiteral(l.key)?l.key:v.stringLiteral(l.key.name),p=e.isClass()&&!l.static?a({CLASS_REF:s}).expression:s;if(v.isClassProperty(l,{static:!1})){var d=e.scope.generateDeclaredUidIdentifier("descriptor"),h=l.value?v.functionExpression(null,[],v.blockStatement([v.returnStatement(l.value)])):v.nullLiteral();l.value=v.callExpression(i(e,r),[d,v.thisExpression()]),n=n.concat([v.assignmentExpression("=",d,v.callExpression(t(e,r),[p,f,v.arrayExpression(c.map(function(e){return e.expression})),v.objectExpression([v.objectProperty(v.identifier("enumerable"),v.booleanLiteral(!0)),v.objectProperty(v.identifier("initializer"),h)])]))])}else n=n.concat(v.callExpression(t(e,r),[p,f,v.arrayExpression(c.map(function(e){return e.expression})),v.isObjectProperty(l)||v.isClassProperty(l,{static:!0})?u({TEMP:e.scope.generateDeclaredUidIdentifier("init"),TARGET:p,PROPERTY:f}).expression:o({TARGET:p,PROPERTY:f}).expression,p]));return n},[]);return v.sequenceExpression([v.assignmentExpression("=",s,e.node),v.sequenceExpression(l),s])}var v=e.types;return{inherits:r(125),visitor:{ExportDefaultDeclaration:function(e){if(e.get("declaration").isClassDeclaration()){var t=e.node,r=t.declaration.id||e.scope.generateUidIdentifier("default");t.declaration.id=r,e.replaceWith(t.declaration),e.insertAfter(v.exportNamedDeclaration(null,[v.exportSpecifier(r,v.identifier("default"))]))}},ClassDeclaration:function(e){var t=e.node,r=t.id||e.scope.generateUidIdentifier("class");e.replaceWith(v.variableDeclaration("let",[v.variableDeclarator(r,v.toExpression(t))]))},ClassExpression:function(e,t){var r=p(e)||d(e,t)||h(e,t);r&&e.replaceWith(r)},ObjectExpression:function(e,t){var r=p(e)||m(e,t);r&&e.replaceWith(r)},AssignmentExpression:function(e,t){t.initializerWarningHelper&&e.get("left").isMemberExpression()&&e.get("left.property").isIdentifier()&&e.get("right").isCallExpression()&&e.get("right.callee").isIdentifier({name:t.initializerWarningHelper.name})&&e.replaceWith(v.callExpression(n(e,t),[e.get("left.object").node,v.stringLiteral(e.get("left.property").node.name),e.get("right.arguments")[0].node,e.get("right.arguments")[1].node]))}}}};var n=r(4),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=(0,i.default)("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"),a=(0,i.default)("\n  CLASS_REF.prototype;\n"),o=(0,i.default)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"),u=(0,i.default)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"),l=(0,i.default)("\n    function NAME(descriptor, context){\n        throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n    }\n"),c=(0,i.default)("\n    function NAME(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"),f=(0,i.default)("\n    function NAME(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object['ke' + 'ys'](descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            // This is a hack to avoid this being processed by 'transform-runtime'.\n            // See issue #9.\n            Object['define' + 'Property'](target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n")},function(e,t,r){"use strict";function n(e,t){var r=t._guessExecutionStatusRelativeTo(e);return"before"===r?"inside":"after"===r?"outside":"maybe"}function i(e,t){return o.callExpression(t.addHelper("temporalRef"),[e,o.stringLiteral(e.name),t.addHelper("temporalUndefined")])}function s(e,t,r){var n=r.letReferences[e.name];return!!n&&t.getBindingIdentifier(e.name)===n}t.__esModule=!0,t.visitor=void 0;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a);t.visitor={ReferencedIdentifier:function(e,t){if(this.file.opts.tdz){var r=e.node,a=e.parent,u=e.scope;if(!e.parentPath.isFor({left:r})&&s(r,u,t)){var l=u.getBinding(r.name).path,c=n(e,l);if("inside"!==c)if("maybe"===c){var f=i(r,t.file);if(l.parent._tdzThis=!0,e.skip(),e.parentPath.isUpdateExpression()){if(a._ignoreBlockScopingTDZ)return;e.parentPath.replaceWith(o.sequenceExpression([f,a]))}else e.replaceWith(f)}else"outside"===c&&e.replaceWith(o.throwStatement(o.inherits(o.newExpression(o.identifier("ReferenceError"),[o.stringLiteral(r.name+" is not defined - temporal dead zone")]),r)))}}},AssignmentExpression:{exit:function(e,t){if(this.file.opts.tdz){var r=e.node;if(!r._ignoreBlockScopingTDZ){var n=[],a=e.getBindingIdentifiers();for(var u in a){var l=a[u];s(l,e.scope,t)&&n.push(i(l,t.file))}n.length&&(r._ignoreBlockScopingTDZ=!0,n.push(r),e.replaceWithMultiple(n.map(o.expressionStatement)))}}}}}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(42),o=n(a),u=r(41),l=n(u),c=r(40),f=n(c),p=r(207),d=n(p),h=r(1),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h),y=function(e){function t(){(0,s.default)(this,t);var r=(0,o.default)(this,e.apply(this,arguments));return r.isLoose=!0,r}return(0,l.default)(t,e),t.prototype._processMethod=function(e,t){if(!e.decorators){var r=this.classRef;e.static||(r=m.memberExpression(r,m.identifier("prototype")));var n=m.memberExpression(r,e.key,e.computed||m.isLiteral(e.key)),i=m.functionExpression(null,e.params,e.body,e.generator,e.async);i.returnType=e.returnType;var s=m.toComputedKey(e,e.key);m.isStringLiteral(s)&&(i=(0,f.default)({node:i,id:s,scope:t}));var a=m.expressionStatement(m.assignmentExpression("=",n,i));return m.inheritsComments(a,e),this.body.push(a),!0}},t}(d.default);t.default=y,e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{BinaryExpression:function(e){var r=e.node;"instanceof"===r.operator&&e.replaceWith(t.callExpression(this.addHelper("instanceof"),[r.left,r.right]))}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){for(var t=e.params,r=Array.isArray(t),n=0,t=r?t:(0,o.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;if(!m.isIdentifier(s))return!0}return!1}function s(e,t){if(!e.hasOwnBinding(t.name))return!0;var r=e.getOwnBinding(t.name),n=r.kind;return"param"===n||"local"===n}t.__esModule=!0,t.visitor=void 0;var a=r(2),o=n(a),u=r(189),l=n(u),c=r(317),f=n(c),p=r(4),d=n(p),h=r(1),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h),y=(0,d.default)("\n  let VARIABLE_NAME =\n    ARGUMENTS.length > ARGUMENT_KEY && ARGUMENTS[ARGUMENT_KEY] !== undefined ?\n      ARGUMENTS[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n"),v=(0,d.default)("\n  let $0 = $1[$2];\n"),g={ReferencedIdentifier:function(e,t){var r=e.scope,n=e.node;"eval"!==n.name&&s(r,n)||(t.iife=!0,e.stop())},Scope:function(e){e.skip()}};t.visitor={Function:function(e){var t=e.node,r=e.scope;if(i(t)){e.ensureBlock();var n={iife:!1,scope:r},a=[],o=m.identifier("arguments");o._shadowedFunctionLiteral=e;for(var u=(0,l.default)(t),c=e.get("params"),p=0;p<c.length;p++){var d=c[p];if(d.isAssignmentPattern()){var h=d.get("left"),b=d.get("right");if(p>=u||h.isPattern()){var E=r.generateUidIdentifier("x");E._isDefaultPlaceholder=!0,t.params[p]=E}else t.params[p]=h.node;n.iife||(b.isIdentifier()&&!s(r,b.node)?n.iife=!0:b.traverse(g,n)),function(e,r,n){var i=y({VARIABLE_NAME:e,DEFAULT_VALUE:r,ARGUMENT_KEY:m.numericLiteral(n),ARGUMENTS:o});i._blockHoist=t.params.length-n,a.push(i)}(h.node,b.node,p)}else n.iife||d.isIdentifier()||d.traverse(g,n)}for(var x=u+1;x<t.params.length;x++){var A=t.params[x];if(!A._isDefaultPlaceholder){var S=v(A,o,m.numericLiteral(x));S._blockHoist=t.params.length-x,a.push(S)}}t.params=t.params.slice(0,u),n.iife?(a.push((0,f.default)(e,r)),e.set("body",m.blockStatement(a))):e.get("body").unshiftContainer("body",a)}}}},function(e,t,r){"use strict";t.__esModule=!0,t.visitor=void 0;var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n);t.visitor={Function:function(e){for(var t=e.get("params"),r=i.isRestElement(t[t.length-1])?1:0,n=t.length-r,s=0;s<n;s++){var a=t[s];if(a.isArrayPattern()||a.isObjectPattern()){var o=e.scope.generateUidIdentifier("ref"),u=i.variableDeclaration("let",[i.variableDeclarator(a.node,o)]);u._blockHoist=n-s,e.ensureBlock(),e.get("body").unshiftContainer("body",u),a.replaceWith(o)}}}}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){return p.isRestElement(e.params[e.params.length-1])}function s(e,t,r){var n=void 0;n=p.isNumericLiteral(e.parent.property)?p.numericLiteral(e.parent.property.value+r):0===r?e.parent.property:p.binaryExpression("+",e.parent.property,p.numericLiteral(r));var i=e.scope;if(i.isPure(n))e.parentPath.replaceWith(h({ARGUMENTS:t,INDEX:n}));else{var s=i.generateUidIdentifierBasedOnNode(n);i.push({id:s,kind:"var"}),e.parentPath.replaceWith(m({ARGUMENTS:t,INDEX:n,REF:s}))}}function a(e,t,r){r?e.parentPath.replaceWith(y({ARGUMENTS:t,OFFSET:p.numericLiteral(r)})):e.replaceWith(t)}t.__esModule=!0,t.visitor=void 0;var o=r(2),u=n(o),l=r(4),c=n(l),f=r(1),p=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(f),d=(0,c.default)("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n"),h=(0,c.default)("\n  ARGUMENTS.length <= INDEX ? undefined : ARGUMENTS[INDEX]\n"),m=(0,c.default)("\n  REF = INDEX, ARGUMENTS.length <= REF ? undefined : ARGUMENTS[REF]\n"),y=(0,c.default)("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n"),v={Scope:function(e,t){e.scope.bindingIdentifierEquals(t.name,t.outerBinding)||e.skip()},Flow:function(e){e.isTypeCastExpression()||e.skip()},"Function|ClassProperty":function(e,t){var r=t.noOptimise;t.noOptimise=!0,e.traverse(v,t),t.noOptimise=r,e.skip()},ReferencedIdentifier:function(e,t){var r=e.node;if("arguments"===r.name&&(t.deopted=!0),r.name===t.name)if(t.noOptimise)t.deopted=!0;else{var n=e.parentPath;if("params"===n.listKey&&n.key<t.offset)return;if(n.isMemberExpression({object:r})){var i=n.parentPath,s=!t.deopted&&!(i.isAssignmentExpression()&&n.node===i.node.left||i.isLVal()||i.isForXStatement()||i.isUpdateExpression()||i.isUnaryExpression({operator:"delete"})||(i.isCallExpression()||i.isNewExpression())&&n.node===i.node.callee);if(s)if(n.node.computed){if(n.get("property").isBaseType("number"))return void t.candidates.push({cause:"indexGetter",path:e})}else if("length"===n.node.property.name)return void t.candidates.push({cause:"lengthGetter",path:e})}if(0===t.offset&&n.isSpreadElement()){var a=n.parentPath;if(a.isCallExpression()&&1===a.node.arguments.length)return void t.candidates.push({cause:"argSpread",path:e})}t.references.push(e)}},BindingIdentifier:function(e,t){e.node.name===t.name&&(t.deopted=!0)}};t.visitor={Function:function(e){var t=e.node,r=e.scope;if(i(t)){var n=t.params.pop().argument,o=p.identifier("arguments");o._shadowedFunctionLiteral=e;var l={references:[],offset:t.params.length,argumentsNode:o,outerBinding:r.getBindingIdentifier(n.name),candidates:[],name:n.name,deopted:!1};if(e.traverse(v,l),l.deopted||l.references.length){l.references=l.references.concat(l.candidates.map(function(e){return e.path})),l.deopted=l.deopted||!!t.shadow;var c=p.numericLiteral(t.params.length),f=r.generateUidIdentifier("key"),h=r.generateUidIdentifier("len"),m=f,y=h;t.params.length&&(m=p.binaryExpression("-",f,c),y=p.conditionalExpression(p.binaryExpression(">",h,c),p.binaryExpression("-",h,c),p.numericLiteral(0)));var g=d({ARGUMENTS:o,ARRAY_KEY:m,ARRAY_LEN:y,START:c,ARRAY:n,KEY:f,LEN:h});if(l.deopted)g._blockHoist=t.params.length+1,t.body.body.unshift(g);else{g._blockHoist=1;var b=e.getEarliestCommonAncestorFrom(l.references).getStatementParent();b.findParent(function(e){if(!e.isLoop())return e.isFunction();b=e}),b.insertBefore(g)}}else for(var E=l.candidates,x=Array.isArray(E),A=0,E=x?E:(0,u.default)(E);;){var S;if(x){if(A>=E.length)break;S=E[A++]}else{if(A=E.next(),A.done)break;S=A.value}var _=S,D=_.path,C=_.cause;switch(C){case"indexGetter":s(D,o,l.offset);break;case"lengthGetter":a(D,o,l.offset);break;default:D.replaceWith(o)}}}}}},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{MemberExpression:{exit:function(e){var r=e.node,n=r.property;r.computed||!t.isIdentifier(n)||t.isValidIdentifier(n.name)||(r.property=t.stringLiteral(n.name),r.computed=!0)}}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{ObjectProperty:{exit:function(e){var r=e.node,n=r.key;r.computed||!t.isIdentifier(n)||t.isValidIdentifier(n.name)||(r.key=t.stringLiteral(n.name))}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){var t=e.types;return{visitor:{ObjectExpression:function(e,r){for(var n=e.node,s=!1,o=n.properties,u=Array.isArray(o),l=0,o=u?o:(0,i.default)(o);;){var c;if(u){if(l>=o.length)break;c=o[l++]}else{if(l=o.next(),l.done)break;c=l.value}var f=c;if("get"===f.kind||"set"===f.kind){s=!0;break}}if(s){var p={};n.properties=n.properties.filter(function(e){return!!(e.computed||"get"!==e.kind&&"set"!==e.kind)||(a.push(p,e,null,r),!1)}),e.replaceWith(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("defineProperties")),[n,a.toDefineObject(p)]))}}}}};var s=r(188),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.parse,r=e.traverse;return{visitor:{CallExpression:function(e){if(e.get("callee").isIdentifier({name:"eval"})&&1===e.node.arguments.length){var n=e.get("arguments")[0].evaluate();if(!n.confident)return;var i=n.value;if("string"!=typeof i)return;var s=t(i);return r.removeProperties(s),s.program}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e,t){e.addComment("trailing",n(e,t)),e.replaceWith(i.noop())}function n(e,t){var r=e.getSource().replace(/\*-\//g,"*-ESCAPED/").replace(/\*\//g,"*-/");return t&&t.optional&&(r="?"+r),":"!==r[0]&&(r=":: "+r),r}var i=e.types;return{inherits:r(126),visitor:{TypeCastExpression:function(e){var t=e.node;e.get("expression").addComment("trailing",n(e.get("typeAnnotation"))),e.replaceWith(i.parenthesizedExpression(t.expression))},Identifier:function(e){var t=e.node;t.optional&&!t.typeAnnotation&&e.addComment("trailing",":: ?")},AssignmentPattern:{exit:function(e){e.node.left.optional=!1}},Function:{exit:function(e){e.node.params.forEach(function(e){return e.optional=!1})}},ClassProperty:function(e){var r=e.node,n=e.parent;r.value||t(e,n)},"ExportNamedDeclaration|Flow":function(e){var r=e.node,n=e.parent;i.isExportNamedDeclaration(r)&&!i.isFlow(r.declaration)||t(e,n)},ImportDeclaration:function(e){var r=e.node,n=e.parent;i.isImportDeclaration(r)&&"type"!==r.importKind&&"typeof"!==r.importKind||t(e,n)}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{FunctionExpression:{exit:function(e){var r=e.node;r.id&&(r._ignoreUserWhitespace=!0,e.replaceWith(t.callExpression(t.functionExpression(null,[],t.blockStatement([t.toStatement(r),t.returnStatement(r.id)])),[])))}}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{CallExpression:function(e,t){e.get("callee").matchesPattern("Object.assign")&&(e.node.callee=t.addHelper("extends"))}}}},e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(){return{visitor:{CallExpression:function(e,t){e.get("callee").matchesPattern("Object.setPrototypeOf")&&(e.node.callee=t.addHelper("defaults"))}}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i);t.default=function(e){function t(e){return i.isLiteral(i.toComputedKey(e,e.key),{value:"__proto__"})}function r(e){var t=e.left;return i.isMemberExpression(t)&&i.isLiteral(i.toComputedKey(t,t.property),{value:"__proto__"})}function n(e,t,r){return i.expressionStatement(i.callExpression(r.addHelper("defaults"),[t,e.right]))}var i=e.types;return{visitor:{AssignmentExpression:function(e,t){if(r(e.node)){var s=[],a=e.node.left.object,o=e.scope.maybeGenerateMemoised(a);o&&s.push(i.expressionStatement(i.assignmentExpression("=",o,a))),s.push(n(e.node,o||a,t)),o&&s.push(o),e.replaceWithMultiple(s)}},ExpressionStatement:function(e,t){var s=e.node.expression;i.isAssignmentExpression(s,{operator:"="})&&r(s)&&e.replaceWith(n(s,s.left.object,t))},ObjectExpression:function(e,r){for(var n=void 0,a=e.node,u=a.properties,l=Array.isArray(u),c=0,u=l?u:(0,s.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;t(p)&&(n=p.value,(0,o.default)(a.properties,p))}if(n){var d=[i.objectExpression([]),n];a.properties.length&&d.push(a),e.replaceWith(i.callExpression(r.addHelper("extends"),d))}}}}};var a=r(277),o=n(a);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(11),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){var t=e.types,r={enter:function(e,r){var n=function(){r.isImmutable=!1,e.stop()};if(e.isJSXClosingElement())return void e.skip();if(e.isJSXIdentifier({name:"ref"})&&e.parentPath.isJSXAttribute({name:e.node}))return n();if(!(e.isJSXIdentifier()||e.isIdentifier()||e.isJSXMemberExpression()||e.isImmutable())){if(e.isPure()){var s=e.evaluate();if(s.confident){var a=s.value;if(!(a&&"object"===(void 0===a?"undefined":(0,i.default)(a))||"function"==typeof a))return}else if(t.isIdentifier(s.deopt))return}n()}}};return{visitor:{JSXElement:function(e){if(!e.node._hoisted){var t={isImmutable:!0};e.traverse(r,t),t.isImmutable?e.hoist():e.node._hoisted=!0}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(2),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default=function(e){function t(e){for(var t=0;t<e.length;t++){var n=e[t];if(s.isJSXSpreadAttribute(n))return!0;if(r(n,"ref"))return!0}return!1}function r(e,t){return s.isJSXAttribute(e)&&s.isJSXIdentifier(e.name,{name:t})}function n(e){var t=e.value;return t?(s.isJSXExpressionContainer(t)&&(t=t.expression),t):s.identifier("true")}var s=e.types;return{visitor:{JSXElement:function(e,a){var o=e.node,u=o.openingElement;if(!t(u.attributes)){var l=s.objectExpression([]),c=null,f=u.name;s.isJSXIdentifier(f)&&s.react.isCompatTag(f.name)&&(f=s.stringLiteral(f.name));for(var p=u.attributes,d=Array.isArray(p),h=0,p=d?p:(0,i.default)(p);;){var m;if(d){if(h>=p.length)break;m=p[h++]}else{if(h=p.next(),h.done)break;m=h.value}var y=m;if(r(y,"key"))c=n(y);else{var v=y.name.name,g=s.isValidIdentifier(v)?s.identifier(v):s.stringLiteral(v);!function(e,t,r){e.push(s.objectProperty(t,r))}(l.properties,g,n(y))}}var b=[f,l];if(c||o.children.length){var E=s.react.buildChildren(o);b.push.apply(b,[c||s.unaryExpression("void",s.numericLiteral(0),!0)].concat(E))}var x=s.callExpression(a.addHelper("jsx"),b);e.replaceWith(x)}}}}},e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{manipulateOptions:function(e,t){t.plugins.push("jsx")},visitor:(0,i.default)({pre:function(e){e.callee=e.tagExpr},post:function(e){t.react.isCompatTag(e.tagName)&&(e.call=t.callExpression(t.memberExpression(t.memberExpression(t.identifier("React"),t.identifier("DOM")),e.tagExpr,t.isLiteral(e.tagExpr)),e.args))}})}};var n=r(348),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){function t(e,r){if(a.isJSXIdentifier(e)){if("this"===e.name&&a.isReferenced(e,r))return a.thisExpression();if(!i.default.keyword.isIdentifierNameES6(e.name))return a.stringLiteral(e.name);e.type="Identifier"}else if(a.isJSXMemberExpression(e))return a.memberExpression(t(e.object,e),t(e.property,e));return e}function r(e){return a.isJSXExpressionContainer(e)?e.expression:e}function n(e){var t=r(e.value||a.booleanLiteral(!0));return a.isStringLiteral(t)&&!a.isJSXExpressionContainer(e.value)&&(t.value=t.value.replace(/\n\s+/g," ")),a.isValidIdentifier(e.name.name)?e.name.type="Identifier":e.name=a.stringLiteral(e.name.name),a.inherits(a.objectProperty(e.name,t),e)}function s(r,n){r.parent.children=a.react.buildChildren(r.parent);var i=t(r.node.name,r.node),s=[],u=void 0;a.isIdentifier(i)?u=i.name:a.isLiteral(i)&&(u=i.value);var l={tagExpr:i,tagName:u,args:s};e.pre&&e.pre(l,n);var c=r.node.attributes;return c=c.length?o(c,n):a.nullLiteral(),s.push(c),e.post&&e.post(l,n),l.call||a.callExpression(l.callee,s)}function o(e,t){function r(){i.length&&(s.push(a.objectExpression(i)),i=[])}var i=[],s=[],o=t.opts.useBuiltIns||!1;if("boolean"!=typeof o)throw new Error("transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)");for(;e.length;){var u=e.shift();a.isJSXSpreadAttribute(u)?(r(),s.push(u.argument)):i.push(n(u))}if(r(),1===s.length)e=s[0];else{a.isObjectExpression(s[0])||s.unshift(a.objectExpression([]));var l=o?a.memberExpression(a.identifier("Object"),a.identifier("assign")):t.addHelper("extends");e=a.callExpression(l,s)}return e}var u={};return u.JSXNamespacedName=function(e){throw e.buildCodeFrameError("Namespace tags are not supported. ReactJSX is not XML.")},u.JSXElement={exit:function(e,t){var r=s(e.get("openingElement"),t);r.arguments=r.arguments.concat(e.node.children),r.arguments.length>=3&&(r._prettyCall=!0),e.replaceWith(a.inherits(r,e.node))}},u};var n=r(97),i=function(e){return e&&e.__esModule?e:{default:e}}(n),s=r(1),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(s);e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){var t=e.types;return{visitor:{JSXOpeningElement:function(e){var n=e.node,i=t.jSXIdentifier(r),s=t.thisExpression();n.attributes.push(t.jSXAttribute(i,t.jSXExpressionContainer(s)))}}}};var r="__self";e.exports=t.default},function(e,t){"use strict";t.__esModule=!0,t.default=function(e){function t(e,t){var r=null!=t?i.numericLiteral(t):i.nullLiteral(),n=i.objectProperty(i.identifier("fileName"),e),s=i.objectProperty(i.identifier("lineNumber"),r);return i.objectExpression([n,s])}var i=e.types;return{visitor:{JSXOpeningElement:function(e,s){var a=i.jSXIdentifier(r),o=e.container.openingElement.loc;if(o){for(var u=e.container.openingElement.attributes,l=0;l<u.length;l++){var c=u[l].name;if(c&&c.name===r)return}if(!s.fileNameIdentifier){var f="unknown"!==s.file.log.filename?s.file.log.filename:null,p=e.scope.generateUidIdentifier(n);e.hub.file.scope.push({id:p,init:i.stringLiteral(f)}),s.fileNameIdentifier=p}var d=t(s.fileNameIdentifier,o.start.line);u.push(i.jSXAttribute(a,i.jSXExpressionContainer(d)))}}}}};var r="__source",n="_jsxFileName";e.exports=t.default},348,function(e,t){"use strict";e.exports={builtins:{Symbol:"symbol",Promise:"promise",Map:"map",WeakMap:"weak-map",Set:"set",WeakSet:"weak-set",Observable:"observable",setImmediate:"set-immediate",clearImmediate:"clear-immediate",asap:"asap"},methods:{Array:{concat:"array/concat",copyWithin:"array/copy-within",entries:"array/entries",every:"array/every",fill:"array/fill",filter:"array/filter",findIndex:"array/find-index",find:"array/find",forEach:"array/for-each",from:"array/from",includes:"array/includes",indexOf:"array/index-of",join:"array/join",keys:"array/keys",lastIndexOf:"array/last-index-of",map:"array/map",of:"array/of",pop:"array/pop",push:"array/push",reduceRight:"array/reduce-right",reduce:"array/reduce",reverse:"array/reverse",shift:"array/shift",slice:"array/slice",some:"array/some",sort:"array/sort",splice:"array/splice",unshift:"array/unshift",values:"array/values"},JSON:{stringify:"json/stringify"},Object:{assign:"object/assign",create:"object/create",defineProperties:"object/define-properties",defineProperty:"object/define-property",entries:"object/entries",freeze:"object/freeze",getOwnPropertyDescriptor:"object/get-own-property-descriptor",getOwnPropertyDescriptors:"object/get-own-property-descriptors",getOwnPropertyNames:"object/get-own-property-names",getOwnPropertySymbols:"object/get-own-property-symbols",getPrototypeOf:"object/get-prototype-of",isExtensible:"object/is-extensible",isFrozen:"object/is-frozen",isSealed:"object/is-sealed",is:"object/is",keys:"object/keys",preventExtensions:"object/prevent-extensions",seal:"object/seal",setPrototypeOf:"object/set-prototype-of",values:"object/values"},RegExp:{escape:"regexp/escape"},Math:{acosh:"math/acosh",asinh:"math/asinh",atanh:"math/atanh",cbrt:"math/cbrt",clz32:"math/clz32",cosh:"math/cosh",expm1:"math/expm1",fround:"math/fround",hypot:"math/hypot",imul:"math/imul",log10:"math/log10",log1p:"math/log1p",log2:"math/log2",sign:"math/sign",sinh:"math/sinh",tanh:"math/tanh",trunc:"math/trunc",iaddh:"math/iaddh",isubh:"math/isubh",imulh:"math/imulh",umulh:"math/umulh"},Symbol:{for:"symbol/for",hasInstance:"symbol/has-instance",isConcatSpreadable:"symbol/is-concat-spreadable",iterator:"symbol/iterator",keyFor:"symbol/key-for",match:"symbol/match",replace:"symbol/replace",search:"symbol/search",species:"symbol/species",split:"symbol/split",toPrimitive:"symbol/to-primitive",toStringTag:"symbol/to-string-tag",unscopables:"symbol/unscopables"},String:{at:"string/at",codePointAt:"string/code-point-at",endsWith:"string/ends-with",fromCodePoint:"string/from-code-point",includes:"string/includes",matchAll:"string/match-all",padLeft:"string/pad-left",padRight:"string/pad-right",padStart:"string/pad-start",padEnd:"string/pad-end",raw:"string/raw",repeat:"string/repeat",startsWith:"string/starts-with",trim:"string/trim",trimLeft:"string/trim-left",trimRight:"string/trim-right",trimStart:"string/trim-start",trimEnd:"string/trim-end"},Number:{EPSILON:"number/epsilon",isFinite:"number/is-finite",isInteger:"number/is-integer",isNaN:"number/is-nan",isSafeInteger:"number/is-safe-integer",MAX_SAFE_INTEGER:"number/max-safe-integer",MIN_SAFE_INTEGER:"number/min-safe-integer",parseFloat:"number/parse-float",parseInt:"number/parse-int"},Reflect:{apply:"reflect/apply",construct:"reflect/construct",defineProperty:"reflect/define-property",deleteProperty:"reflect/delete-property",enumerate:"reflect/enumerate",getOwnPropertyDescriptor:"reflect/get-own-property-descriptor",getPrototypeOf:"reflect/get-prototype-of",get:"reflect/get",has:"reflect/has",isExtensible:"reflect/is-extensible",ownKeys:"reflect/own-keys",preventExtensions:"reflect/prevent-extensions",setPrototypeOf:"reflect/set-prototype-of",set:"reflect/set",defineMetadata:"reflect/define-metadata",deleteMetadata:"reflect/delete-metadata",getMetadata:"reflect/get-metadata",getMetadataKeys:"reflect/get-metadata-keys",getOwnMetadata:"reflect/get-own-metadata",getOwnMetadataKeys:"reflect/get-own-metadata-keys",hasMetadata:"reflect/has-metadata",hasOwnMetadata:"reflect/has-own-metadata",metadata:"reflect/metadata"},System:{global:"system/global"},Error:{isError:"error/is-error"},Date:{},Function:{}}}},function(e,t,r){"use strict";t.__esModule=!0,t.definitions=void 0,t.default=function(e){function t(e){return e.moduleName||"babel-runtime"}function r(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var n=e.types,s=["interopRequireWildcard","interopRequireDefault"];return{pre:function(e){var r=t(this.opts);!1!==this.opts.helpers&&e.set("helperGenerator",function(t){if(s.indexOf(t)<0)return e.addImport(r+"/helpers/"+t,"default",t)}),this.setDynamic("regeneratorIdentifier",function(){return e.addImport(r+"/regenerator","default","regeneratorRuntime")})},visitor:{ReferencedIdentifier:function(e,s){var a=e.node,o=e.parent,u=e.scope;if("regeneratorRuntime"===a.name&&!1!==s.opts.regenerator)return void e.replaceWith(s.get("regeneratorIdentifier"));if(!1!==s.opts.polyfill&&!n.isMemberExpression(o)&&r(i.default.builtins,a.name)&&!u.getBindingIdentifier(a.name)){var l=t(s.opts);e.replaceWith(s.addImport(l+"/core-js/"+i.default.builtins[a.name],"default",a.name))}},CallExpression:function(e,r){if(!1!==r.opts.polyfill&&!e.node.arguments.length){var i=e.node.callee;if(n.isMemberExpression(i)&&i.computed&&e.get("callee.property").matchesPattern("Symbol.iterator")){var s=t(r.opts);e.replaceWith(n.callExpression(r.addImport(s+"/core-js/get-iterator","default","getIterator"),[i.object]))}}},BinaryExpression:function(e,r){if(!1!==r.opts.polyfill&&"in"===e.node.operator&&e.get("left").matchesPattern("Symbol.iterator")){var i=t(r.opts);e.replaceWith(n.callExpression(r.addImport(i+"/core-js/is-iterable","default","isIterable"),[e.node.right]))}},MemberExpression:{enter:function(e,s){if(!1!==s.opts.polyfill&&e.isReferenced()){var a=e.node,o=a.object,u=a.property;if(n.isReferenced(o,a)&&!a.computed&&r(i.default.methods,o.name)){var l=i.default.methods[o.name];if(r(l,u.name)&&!e.scope.getBindingIdentifier(o.name)){if("Object"===o.name&&"defineProperty"===u.name&&e.parentPath.isCallExpression()){var c=e.parentPath.node;if(3===c.arguments.length&&n.isLiteral(c.arguments[1]))return}var f=t(s.opts);e.replaceWith(s.addImport(f+"/core-js/"+l[u.name],"default",o.name+"$"+u.name))}}}},exit:function(e,s){if(!1!==s.opts.polyfill&&e.isReferenced()){var a=e.node,o=a.object;if(r(i.default.builtins,o.name)&&!e.scope.getBindingIdentifier(o.name)){var u=t(s.opts);e.replaceWith(n.memberExpression(s.addImport(u+"/core-js/"+i.default.builtins[o.name],"default",o.name),a.property,a.computed))}}}}}}};var n=r(352),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.definitions=i.default},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(e){var t=e.messages;return{visitor:{ReferencedIdentifier:function(e){var r=e.node,n=e.scope,s=n.getBinding(r.name)
;if(s&&"type"===s.kind&&!e.parentPath.isFlow())throw e.buildCodeFrameError(t.get("undeclaredVariableType",r.name),ReferenceError);if(!n.hasBinding(r.name)){var a=n.getAllBindings(),o=void 0,u=-1;for(var l in a){var c=(0,i.default)(r.name,l);c<=0||c>3||(c<=u||(o=l,u=c))}var f=void 0;throw f=o?t.get("undeclaredVariableSuggestion",r.name,o):t.get("undeclaredVariable",r.name),e.buildCodeFrameError(f,ReferenceError)}}}}};var n=r(471),i=function(e){return e&&e.__esModule?e:{default:e}}(n);e.exports=t.default},function(e,t,r){"use strict";t.__esModule=!0;var n=r(211),i=function(e){return e&&e.__esModule?e:{default:e}}(n);t.default={plugins:[i.default]},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{presets:[!1!==t.es2015&&[s.default.buildPreset,t.es2015],!1!==t.es2016&&o.default,!1!==t.es2017&&l.default].filter(Boolean)}};var i=r(217),s=n(i),a=r(218),o=n(a),u=r(219),l=n(u);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(355),s=n(i),a=r(215),o=n(a),u=r(127),l=n(u),c=r(214),f=n(c);t.default={presets:[s.default],plugins:[o.default,l.default,f.default],env:{development:{plugins:[]}}},e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(220),s=n(i),a=r(206),o=n(a),u=r(212),l=n(u);t.default={presets:[s.default],plugins:[o.default,l.default]},e.exports=t.default},function(e,t,r){"use strict";e.exports={default:r(407),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(410),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(412),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(413),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(415),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(416),__esModule:!0}},function(e,t,r){"use strict";e.exports={default:r(417),__esModule:!0}},function(e,t){"use strict";t.__esModule=!0,t.default=function(e,t){var r={};for(var n in e)t.indexOf(n)>=0||Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=e[n]);return r}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i),a=r(3),o=n(a),u=r(36),l=n(u),c=r(1),f=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(c),p=function(){function e(t,r,n,i){(0,o.default)(this,e),this.queue=null,this.parentPath=i,this.scope=t,this.state=n,this.opts=r}return e.prototype.shouldVisit=function(e){var t=this.opts;if(t.enter||t.exit)return!0;if(t[e.type])return!0;var r=f.VISITOR_KEYS[e.type];if(!r||!r.length)return!1;for(var n=r,i=Array.isArray(n),a=0,n=i?n:(0,s.default)(n);;){var o;if(i){if(a>=n.length)break;o=n[a++]}else{if(a=n.next(),a.done)break;o=a.value}if(e[o])return!0}return!1},e.prototype.create=function(e,t,r,n){return l.default.get({parentPath:this.parentPath,parent:e,container:t,key:r,listKey:n})},e.prototype.maybeQueue=function(e,t){if(this.trap)throw new Error("Infinite cycle detected");this.queue&&(t?this.queue.push(e):this.priorityQueue.push(e))},e.prototype.visitMultiple=function(e,t,r){if(0===e.length)return!1;for(var n=[],i=0;i<e.length;i++){var s=e[i];s&&this.shouldVisit(s)&&n.push(this.create(t,e,i,r))}return this.visitQueue(n)},e.prototype.visitSingle=function(e,t){return!!this.shouldVisit(e[t])&&this.visitQueue([this.create(e,e,t)])},e.prototype.visitQueue=function(e){this.queue=e,this.priorityQueue=[];for(var t=[],r=!1,n=e,i=Array.isArray(n),a=0,n=i?n:(0,s.default)(n);;){var o;if(i){if(a>=n.length)break;o=n[a++]}else{if(a=n.next(),a.done)break;o=a.value}var u=o;if(u.resync(),0!==u.contexts.length&&u.contexts[u.contexts.length-1]===this||u.pushContext(this),null!==u.key&&!(t.indexOf(u.node)>=0)){if(t.push(u.node),u.visit()){r=!0;break}if(this.priorityQueue.length&&(r=this.visitQueue(this.priorityQueue),this.priorityQueue=[],this.queue=e,r))break}}for(var l=e,c=Array.isArray(l),f=0,l=c?l:(0,s.default)(l);;){var p;if(c){if(f>=l.length)break;p=l[f++]}else{if(f=l.next(),f.done)break;p=f.value}p.popContext()}return this.queue=null,r},e.prototype.visit=function(e,t){var r=e[t];return!!r&&(Array.isArray(r)?this.visitMultiple(r,e,t):this.visitSingle(e,t))},e}();t.default=p,e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){for(var t=this;t=t.parentPath;)if(e(t))return t;return null}function s(e){var t=this;do{if(e(t))return t}while(t=t.parentPath);return null}function a(){return this.findParent(function(e){return e.isFunction()||e.isProgram()})}function o(){var e=this;do{if(Array.isArray(e.container))return e}while(e=e.parentPath)}function u(e){return this.getDeepestCommonAncestorFrom(e,function(e,t,r){for(var n=void 0,i=g.VISITOR_KEYS[e.type],s=r,a=Array.isArray(s),o=0,s=a?s:(0,y.default)(s);;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u,c=l[t+1];if(n)if(c.listKey&&n.listKey===c.listKey&&c.key<n.key)n=c;else{var f=i.indexOf(n.parentKey),p=i.indexOf(c.parentKey);f>p&&(n=c)}else n=c}return n})}function l(e,t){var r=this;if(!e.length)return this;if(1===e.length)return e[0];var n=1/0,i=void 0,s=void 0,a=e.map(function(e){var t=[];do{t.unshift(e)}while((e=e.parentPath)&&e!==r);return t.length<n&&(n=t.length),t}),o=a[0];e:for(var u=0;u<n;u++){for(var l=o[u],c=a,f=Array.isArray(c),p=0,c=f?c:(0,y.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d;if(h[u]!==l)break e}i=u,s=l}if(s)return t?t(s,i,a):s;throw new Error("Couldn't find intersection")}function c(){var e=this,t=[];do{t.push(e)}while(e=e.parentPath);return t}function f(e){return e.isDescendant(this)}function p(e){return!!this.findParent(function(t){return t===e})}function d(){for(var e=this;e;){for(var t=arguments,r=Array.isArray(t),n=0,t=r?t:(0,y.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;if(e.node.type===s)return!0}e=e.parentPath}return!1}function h(e){var t=this.isFunction()?this:this.findParent(function(e){return e.isFunction()});if(t){if(t.isFunctionExpression()||t.isFunctionDeclaration()){var r=t.node.shadow;if(r&&(!e||!1!==r[e]))return t}else if(t.isArrowFunctionExpression())return t;return null}}t.__esModule=!0;var m=r(2),y=n(m);t.findParent=i,t.find=s,t.getFunctionParent=a,t.getStatementParent=o,t.getEarliestCommonAncestorFrom=u,t.getDeepestCommonAncestorFrom=l,t.getAncestry=c,t.isAncestor=f,t.isDescendant=p,t.inType=d,t.inShadow=h;var v=r(1),g=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(v),b=r(36);n(b)},function(e,t){"use strict";function r(){if("string"!=typeof this.key){var e=this.node;if(e){var t=e.trailingComments,r=e.leadingComments;if(t||r){var n=this.getSibling(this.key-1),i=this.getSibling(this.key+1);n.node||(n=i),i.node||(i=n),n.addComments("trailing",r),i.addComments("leading",t)}}}}function n(e,t,r){this.addComments(e,[{type:r?"CommentLine":"CommentBlock",value:t}])}function i(e,t){if(t){var r=this.node;if(r){var n=e+"Comments";r[n]?r[n]=r[n].concat(t):r[n]=t}}}t.__esModule=!0,t.shareCommentsWithSiblings=r,t.addComment=n,t.addComments=i},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=this.opts;return this.debug(function(){return e}),!(!this.node||!this._call(t[e]))||!!this.node&&this._call(t[this.node.type]&&t[this.node.type][e])}function s(e){if(!e)return!1;for(var t=e,r=Array.isArray(t),n=0,t=r?t:(0,D.default)(t);;){var i;if(r){if(n>=t.length)break;i=t[n++]}else{if(n=t.next(),n.done)break;i=n.value}var s=i;if(s){var a=this.node;if(!a)return!0;if(s.call(this.state,this,this.state))throw new Error("Unexpected return value from visitor method "+s);if(this.node!==a)return!0;if(this.shouldStop||this.shouldSkip||this.removed)return!0}}return!1}function a(){var e=this.opts.blacklist;return e&&e.indexOf(this.node.type)>-1}function o(){return!!this.node&&(!this.isBlacklisted()&&((!this.opts.shouldSkip||!this.opts.shouldSkip(this))&&(this.call("enter")||this.shouldSkip?(this.debug(function(){return"Skip..."}),this.shouldStop):(this.debug(function(){return"Recursing into..."}),w.default.node(this.node,this.opts,this.scope,this.state,this,this.skipKeys),this.call("exit"),this.shouldStop))))}function u(){this.shouldSkip=!0}function l(e){this.skipKeys[e]=!0}function c(){this.shouldStop=!0,this.shouldSkip=!0}function f(){if(!this.opts||!this.opts.noScope){var e=this.context&&this.context.scope;if(!e)for(var t=this.parentPath;t&&!e;){if(t.opts&&t.opts.noScope)return;e=t.scope,t=t.parentPath}this.scope=this.getScope(e),this.scope&&this.scope.init()}}function p(e){return this.shouldSkip=!1,this.shouldStop=!1,this.removed=!1,this.skipKeys={},e&&(this.context=e,this.state=e.state,this.opts=e.opts),this.setScope(),this}function d(){this.removed||(this._resyncParent(),this._resyncList(),this._resyncKey())}function h(){this.parentPath&&(this.parent=this.parentPath.node)}function m(){if(this.container&&this.node!==this.container[this.key]){if(Array.isArray(this.container)){for(var e=0;e<this.container.length;e++)if(this.container[e]===this.node)return this.setKey(e)}else for(var t in this.container)if(this.container[t]===this.node)return this.setKey(t);this.key=null}}function y(){if(this.parent&&this.inList){var e=this.parent[this.listKey];this.container!==e&&(this.container=e||null)}}function v(){null!=this.key&&this.container&&this.container[this.key]===this.node||this._markRemoved()}function g(){this.contexts.pop(),this.setContext(this.contexts[this.contexts.length-1])}function b(e){this.contexts.push(e),this.setContext(e)}function E(e,t,r,n){this.inList=!!r,this.listKey=r,this.parentKey=r||n,this.container=t,this.parentPath=e||this.parentPath,this.setKey(n)}function x(e){this.key=e,this.node=this.container[this.key],this.type=this.node&&this.node.type}function A(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this;if(!e.removed)for(var t=this.contexts,r=t,n=Array.isArray(r),i=0,r=n?r:(0,D.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;a.maybeQueue(e)}}function S(){for(var e=this,t=this.contexts;!t.length;)e=e.parentPath,t=e.contexts;return t}t.__esModule=!0;var _=r(2),D=n(_);t.call=i,t._call=s,t.isBlacklisted=a,t.visit=o,t.skip=u,t.skipKey=l,t.stop=c,t.setScope=f,t.setContext=p,t.resync=d,t._resyncParent=h,t._resyncKey=m,t._resyncList=y,t._resyncRemoved=v,t.popContext=g,t.pushContext=b,t.setup=E,t.setKey=x,t.requeue=A,t._getQueueContexts=S;var C=r(7),w=n(C)},function(e,t,r){"use strict";function n(){var e=this.node,t=void 0;if(this.isMemberExpression())t=e.property;else{if(!this.isProperty()&&!this.isMethod())throw new ReferenceError("todo");t=e.key}return e.computed||o.isIdentifier(t)&&(t=o.stringLiteral(t.name)),t}function i(){return o.ensureBlock(this.node)}function s(){if(this.isArrowFunctionExpression()){this.ensureBlock();var e=this.node;e.expression=!1,e.type="FunctionExpression",e.shadow=e.shadow||!0}}t.__esModule=!0,t.toComputedKey=n,t.ensureBlock=i,t.arrowFunctionToShadowed=s;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a)},function(e,t,r){(function(e){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(){var e=this.evaluate();if(e.confident)return!!e.value}function s(){function t(e){i&&(s=e,i=!1)}function r(e){var r=e.node;if(a.has(r)){var s=a.get(r);return s.resolved?s.value:void t(e)}var o={resolved:!1};a.set(r,o);var u=n(e);return i&&(o.resolved=!0,o.value=u),u}function n(n){if(i){var s=n.node;if(n.isSequenceExpression()){var a=n.get("expressions");return r(a[a.length-1])}if(n.isStringLiteral()||n.isNumericLiteral()||n.isBooleanLiteral())return s.value;if(n.isNullLiteral())return null;if(n.isTemplateLiteral()){for(var u="",c=0,f=n.get("expressions"),h=s.quasis,m=Array.isArray(h),y=0,h=m?h:(0,l.default)(h);;){var v;if(m){if(y>=h.length)break;v=h[y++]}else{if(y=h.next(),y.done)break;v=y.value}var g=v;if(!i)break;u+=g.value.cooked;var b=f[c++];b&&(u+=String(r(b)))}if(!i)return;return u}if(n.isConditionalExpression()){var E=r(n.get("test"));if(!i)return;return r(E?n.get("consequent"):n.get("alternate"))}if(n.isExpressionWrapper())return r(n.get("expression"));if(n.isMemberExpression()&&!n.parentPath.isCallExpression({callee:s})){var x=n.get("property"),A=n.get("object");if(A.isLiteral()&&x.isIdentifier()){var S=A.node.value,_=void 0===S?"undefined":(0,o.default)(S);if("number"===_||"string"===_)return S[x.node.name]}}if(n.isReferencedIdentifier()){var D=n.scope.getBinding(s.name);if(D&&D.constantViolations.length>0)return t(D.path);if(D&&n.node.start<D.path.node.end)return t(D.path);if(D&&D.hasValue)return D.value;if("undefined"===s.name)return D?t(D.path):void 0;if("Infinity"===s.name)return D?t(D.path):1/0;if("NaN"===s.name)return D?t(D.path):NaN;var C=n.resolve();return C===n?t(n):r(C)}if(n.isUnaryExpression({prefix:!0})){if("void"===s.operator)return;var w=n.get("argument");if("typeof"===s.operator&&(w.isFunction()||w.isClass()))return"function";var P=r(w);if(!i)return;switch(s.operator){case"!":return!P;case"+":return+P;case"-":return-P;case"~":return~P;case"typeof":return void 0===P?"undefined":(0,o.default)(P)}}if(n.isArrayExpression()){for(var k=[],F=n.get("elements"),T=F,O=Array.isArray(T),B=0,T=O?T:(0,l.default)(T);;){var R;if(O){if(B>=T.length)break;R=T[B++]}else{if(B=T.next(),B.done)break;R=B.value}var I=R;if(I=I.evaluate(),!I.confident)return t(I);k.push(I.value)}return k}if(n.isObjectExpression()){for(var M={},N=n.get("properties"),L=N,j=Array.isArray(L),U=0,L=j?L:(0,l.default)(L);;){var V;if(j){if(U>=L.length)break;V=L[U++]}else{if(U=L.next(),U.done)break;V=U.value}var G=V;if(G.isObjectMethod()||G.isSpreadProperty())return t(G);var W=G.get("key"),Y=W;if(G.node.computed){if(Y=Y.evaluate(),!Y.confident)return t(W);Y=Y.value}else Y=Y.isIdentifier()?Y.node.name:Y.node.value;var q=G.get("value"),K=q.evaluate();if(!K.confident)return t(q);K=K.value,M[Y]=K}return M}if(n.isLogicalExpression()){var H=i,J=r(n.get("left")),X=i;i=H;var z=r(n.get("right")),$=i;switch(i=X&&$,s.operator){case"||":if(J&&X)return i=!0,J;if(!i)return;return J||z;case"&&":if((!J&&X||!z&&$)&&(i=!0),!i)return;return J&&z}}if(n.isBinaryExpression()){var Q=r(n.get("left"));if(!i)return;var Z=r(n.get("right"));if(!i)return;switch(s.operator){case"-":return Q-Z;case"+":return Q+Z;case"/":return Q/Z;case"*":return Q*Z;case"%":return Q%Z;case"**":return Math.pow(Q,Z);case"<":return Q<Z;case">":return Q>Z;case"<=":return Q<=Z;case">=":return Q>=Z;case"==":return Q==Z;case"!=":return Q!=Z;case"===":return Q===Z;case"!==":return Q!==Z;case"|":return Q|Z;case"&":return Q&Z;case"^":return Q^Z;case"<<":return Q<<Z;case">>":return Q>>Z;case">>>":return Q>>>Z}}if(n.isCallExpression()){var ee=n.get("callee"),te=void 0,re=void 0;if(ee.isIdentifier()&&!n.scope.getBinding(ee.node.name,!0)&&p.indexOf(ee.node.name)>=0&&(re=e[s.callee.name]),ee.isMemberExpression()){var ne=ee.get("object"),ie=ee.get("property");if(ne.isIdentifier()&&ie.isIdentifier()&&p.indexOf(ne.node.name)>=0&&d.indexOf(ie.node.name)<0&&(te=e[ne.node.name],re=te[ie.node.name]),ne.isLiteral()&&ie.isIdentifier()){var se=(0,o.default)(ne.node.value);"string"!==se&&"number"!==se||(te=ne.node.value,re=te[ie.node.name])}}if(re){var ae=n.get("arguments").map(r);if(!i)return;return re.apply(te,ae)}}t(n)}}var i=!0,s=void 0,a=new f.default,u=r(this);return i||(u=void 0),{confident:i,deopt:s,value:u}}t.__esModule=!0;var a=r(11),o=n(a),u=r(2),l=n(u),c=r(133),f=n(c);t.evaluateTruthy=i,t.evaluate=s;var p=["String","Number","Math"],d=["random"]}).call(t,function(){return this}())},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(){var e=this;do{if(!e.parentPath||Array.isArray(e.container)&&e.isStatement())break;e=e.parentPath}while(e);if(e&&(e.isProgram()||e.isFile()))throw new Error("File/Program node, we can't possibly find a statement parent to this");return e}function s(){return"left"===this.key?this.getSibling("right"):"right"===this.key?this.getSibling("left"):void 0}function a(){var e=[],t=function(t){t&&(e=e.concat(t.getCompletionRecords()))};if(this.isIfStatement())t(this.get("consequent")),t(this.get("alternate"));else if(this.isDoExpression()||this.isFor()||this.isWhile())t(this.get("body"));else if(this.isProgram()||this.isBlockStatement())t(this.get("body").pop());else{if(this.isFunction())return this.get("body").getCompletionRecords();this.isTryStatement()?(t(this.get("block")),t(this.get("handler")),t(this.get("finalizer"))):e.push(this)}return e}function o(e){return _.default.get({parentPath:this.parentPath,parent:this.parent,container:this.container,listKey:this.listKey,key:e})}function u(){return this.getSibling(this.key-1)}function l(){return this.getSibling(this.key+1)}function c(){for(var e=this.key,t=this.getSibling(++e),r=[];t.node;)r.push(t),t=this.getSibling(++e);return r}function f(){for(var e=this.key,t=this.getSibling(--e),r=[];t.node;)r.push(t),t=this.getSibling(--e);return r}function p(e,t){!0===t&&(t=this.context);var r=e.split(".");return 1===r.length?this._getKey(e,t):this._getPattern(r,t)}function d(e,t){var r=this,n=this.node,i=n[e];return Array.isArray(i)?i.map(function(s,a){return _.default.get({listKey:e,parentPath:r,parent:n,container:i,key:a}).setContext(t)}):_.default.get({parentPath:this,parent:n,container:n,key:e}).setContext(t)}function h(e,t){for(var r=this,n=e,i=Array.isArray(n),s=0,n=i?n:(0,A.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;r="."===o?r.parentPath:Array.isArray(r)?r[o]:r.get(o,t)}return r}function m(e){return C.getBindingIdentifiers(this.node,e)}function y(e){return C.getOuterBindingIdentifiers(this.node,e)}function v(){for(var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=this,n=[].concat(r),i=(0,E.default)(null);n.length;){var s=n.shift();if(s&&s.node){var a=C.getBindingIdentifiers.keys[s.node.type];if(s.isIdentifier())if(e){var o=i[s.node.name]=i[s.node.name]||[];o.push(s)}else i[s.node.name]=s;else if(s.isExportDeclaration()){var u=s.get("declaration");u.isDeclaration()&&n.push(u)}else{if(t){if(s.isFunctionDeclaration()){n.push(s.get("id"));continue}if(s.isFunctionExpression())continue}if(a)for(var l=0;l<a.length;l++){var c=a[l],f=s.get(c);(Array.isArray(f)||f.node)&&(n=n.concat(f))}}}}return i}function g(e){return this.getBindingIdentifierPaths(e,!0)}t.__esModule=!0;var b=r(9),E=n(b),x=r(2),A=n(x);t.getStatementParent=i,t.getOpposite=s,t.getCompletionRecords=a,t.getSibling=o,t.getPrevSibling=u,t.getNextSibling=l,t.getAllNextSiblings=c,t.getAllPrevSiblings=f,t.get=p,t._getKey=d,t._getPattern=h,t.getBindingIdentifiers=m,t.getOuterBindingIdentifiers=y,t.getBindingIdentifierPaths=v,t.getOuterBindingIdentifierPaths=g;var S=r(36),_=n(S),D=r(1),C=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(D)},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(){if(this.typeAnnotation)return this.typeAnnotation;var e=this._getTypeAnnotation()||y.anyTypeAnnotation();return y.isTypeAnnotation(e)&&(e=e.typeAnnotation),this.typeAnnotation=e}function s(){var e=this.node;{if(e){if(e.typeAnnotation)return e.typeAnnotation;var t=h[e.type];return t?t.call(this,e):(t=h[this.parentPath.type],t&&t.validParent?this.parentPath.getTypeAnnotation():void 0)}if("init"===this.key&&this.parentPath.isVariableDeclarator()){var r=this.parentPath.parentPath,n=r.parentPath;return"left"===r.key&&n.isForInStatement()?y.stringTypeAnnotation():"left"===r.key&&n.isForOfStatement()?y.anyTypeAnnotation():y.voidTypeAnnotation()}}}function a(e,t){return o(e,this.getTypeAnnotation(),t)}function o(e,t,r){if("string"===e)return y.isStringTypeAnnotation(t);if("number"===e)return y.isNumberTypeAnnotation(t);if("boolean"===e)return y.isBooleanTypeAnnotation(t);if("any"===e)return y.isAnyTypeAnnotation(t);if("mixed"===e)return y.isMixedTypeAnnotation(t);if("empty"===e)return y.isEmptyTypeAnnotation(t);if("void"===e)return y.isVoidTypeAnnotation(t);if(r)return!1;throw new Error("Unknown base type "+e)}function u(e){var t=this.getTypeAnnotation();if(y.isAnyTypeAnnotation(t))return!0;if(y.isUnionTypeAnnotation(t)){for(var r=t.types,n=Array.isArray(r),i=0,r=n?r:(0,p.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var a=s;if(y.isAnyTypeAnnotation(a)||o(e,a,!0))return!0}return!1}return o(e,t,!0)}function l(e){var t=this.getTypeAnnotation();if(e=e.getTypeAnnotation(),!y.isAnyTypeAnnotation(t)&&y.isFlowBaseAnnotation(t))return e.type===t.type}function c(e){var t=this.getTypeAnnotation();return y.isGenericTypeAnnotation(t)&&y.isIdentifier(t.id,{name:e})}t.__esModule=!0;var f=r(2),p=function(e){return e&&e.__esModule?e:{default:e}}(f);t.getTypeAnnotation=i,t._getTypeAnnotation=s,t.isBaseType=a,t.couldBeBaseType=u,t.baseTypeStrictlyMatches=l,t.isGenericType=c;var d=r(376),h=n(d),m=r(1),y=n(m)},function(e,t,r){"use strict";function n(e,t){var r=e.scope.getBinding(t),n=[];e.typeAnnotation=f.unionTypeAnnotation(n);var s=[],a=i(r,e,s),u=o(e,t);if(u){var c=i(r,u.ifStatement);a=a.filter(function(e){return c.indexOf(e)<0}),n.push(u.typeAnnotation)}if(a.length){a=a.concat(s);for(var p=a,d=Array.isArray(p),h=0,p=d?p:(0,l.default)(p);;){var m;if(d){if(h>=p.length)break;m=p[h++]}else{if(h=p.next(),h.done)break;m=h.value}var y=m;n.push(y.getTypeAnnotation())}}if(n.length)return f.createUnionTypeAnnotation(n)}function i(e,t,r){var n=e.constantViolations.slice();return n.unshift(e.path),n.filter(function(e){e=e.resolve();var n=e._guessExecutionStatusRelativeTo(t);return r&&"function"===n&&r.push(e),"before"===n})}function s(e,t){var r=t.node.operator,n=t.get("right").resolve(),i=t.get("left").resolve(),s=void 0;if(i.isIdentifier({name:e})?s=n:n.isIdentifier({name:e})&&(s=i),s)return"==="===r?s.getTypeAnnotation():f.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(r)>=0?f.numberTypeAnnotation():void 0;if("==="===r){var a=void 0,o=void 0;if(i.isUnaryExpression({operator:"typeof"})?(a=i,o=n):n.isUnaryExpression({operator:"typeof"})&&(a=n,o=i),(o||a)&&(o=o.resolve(),o.isLiteral())){if("string"==typeof o.node.value&&a.get("argument").isIdentifier({name:e}))return f.createTypeAnnotationBasedOnTypeof(o.node.value)}}}function a(e){for(var t=void 0;t=e.parentPath;){if(t.isIfStatement()||t.isConditionalExpression())return"test"===e.key?void 0:t;e=t}}function o(e,t){var r=a(e);if(r){var n=r.get("test"),i=[n],u=[];do{var l=i.shift().resolve();if(l.isLogicalExpression()&&(i.push(l.get("left")),i.push(l.get("right"))),l.isBinaryExpression()){var c=s(t,l);c&&u.push(c)}}while(i.length);return u.length?{typeAnnotation:f.createUnionTypeAnnotation(u),ifStatement:r}:o(r,t)}}t.__esModule=!0;var u=r(2),l=function(e){return e&&e.__esModule?e:{default:e}}(u);t.default=function(e){if(this.isReferenced()){var t=this.scope.getBinding(e.name);return t?t.identifier.typeAnnotation?t.identifier.typeAnnotation:n(this,e.name):"undefined"===e.name?f.voidTypeAnnotation():"NaN"===e.name||"Infinity"===e.name?f.numberTypeAnnotation():void e.name}};var c=r(1),f=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(c);e.exports=t.default},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(){return this.get("id").isIdentifier()?this.get("init").getTypeAnnotation():void 0}function s(e){return e.typeAnnotation}function a(e){if(this.get("callee").isIdentifier())return k.genericTypeAnnotation(e.callee)}function o(){return k.stringTypeAnnotation()}function u(e){var t=e.operator;return"void"===t?k.voidTypeAnnotation():k.NUMBER_UNARY_OPERATORS.indexOf(t)>=0?k.numberTypeAnnotation():k.STRING_UNARY_OPERATORS.indexOf(t)>=0?k.stringTypeAnnotation():k.BOOLEAN_UNARY_OPERATORS.indexOf(t)>=0?k.booleanTypeAnnotation():void 0}function l(e){var t=e.operator;if(k.NUMBER_BINARY_OPERATORS.indexOf(t)>=0)return k.numberTypeAnnotation();if(k.BOOLEAN_BINARY_OPERATORS.indexOf(t)>=0)return k.booleanTypeAnnotation();if("+"===t){var r=this.get("right"),n=this.get("left");return n.isBaseType("number")&&r.isBaseType("number")?k.numberTypeAnnotation():n.isBaseType("string")||r.isBaseType("string")?k.stringTypeAnnotation():k.unionTypeAnnotation([k.stringTypeAnnotation(),k.numberTypeAnnotation()])}}function c(){return k.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(),this.get("right").getTypeAnnotation()])}function f(){return k.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(),this.get("alternate").getTypeAnnotation()])}function p(){return this.get("expressions").pop().getTypeAnnotation()}function d(){return this.get("right").getTypeAnnotation()}function h(e){var t=e.operator;if("++"===t||"--"===t)return k.numberTypeAnnotation()}function m(){return k.stringTypeAnnotation()}function y(){return k.numberTypeAnnotation()}function v(){return k.booleanTypeAnnotation()}function g(){return k.nullLiteralTypeAnnotation()}function b(){return k.genericTypeAnnotation(k.identifier("RegExp"))}function E(){return k.genericTypeAnnotation(k.identifier("Object"))}function x(){return k.genericTypeAnnotation(k.identifier("Array"))}function A(){return x()}function S(){return k.genericTypeAnnotation(k.identifier("Function"))}function _(){return C(this.get("callee"))}function D(){return C(this.get("tag"))}function C(e){if(e=e.resolve(),e.isFunction()){if(e.is("async"))return e.is("generator")?k.genericTypeAnnotation(k.identifier("AsyncIterator")):k.genericTypeAnnotation(k.identifier("Promise"));if(e.node.returnType)return e.node.returnType}}t.__esModule=!0,t.ClassDeclaration=t.ClassExpression=t.FunctionDeclaration=t.ArrowFunctionExpression=t.FunctionExpression=t.Identifier=void 0;var w=r(375);Object.defineProperty(t,"Identifier",{enumerable:!0,get:function(){return n(w).default}}),t.VariableDeclarator=i,t.TypeCastExpression=s,t.NewExpression=a,t.TemplateLiteral=o,t.UnaryExpression=u,t.BinaryExpression=l,t.LogicalExpression=c,t.ConditionalExpression=f,t.SequenceExpression=p,t.AssignmentExpression=d,t.UpdateExpression=h,t.StringLiteral=m,t.NumericLiteral=y,t.BooleanLiteral=v,t.NullLiteral=g,t.RegExpLiteral=b,t.ObjectExpression=E,t.ArrayExpression=x,t.RestElement=A,t.CallExpression=_,t.TaggedTemplateExpression=D;var P=r(1),k=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(P);s.validParent=!0,A.validParent=!0,t.FunctionExpression=S,t.ArrowFunctionExpression=S,t.FunctionDeclaration=S,t.ClassExpression=S,t.ClassDeclaration=S},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){function r(e){var t=n[s];return"*"===t||e===t}if(!this.isMemberExpression())return!1;for(var n=e.split("."),i=[this.node],s=0;i.length;){var a=i.shift();if(t&&s===n.length)return!0;if(C.isIdentifier(a)){if(!r(a.name))return!1}else if(C.isLiteral(a)){if(!r(a.value))return!1}else{if(C.isMemberExpression(a)){if(a.computed&&!C.isLiteral(a.property))return!1;i.unshift(a.property),i.unshift(a.object);continue}if(!C.isThisExpression(a))return!1;if(!r("this"))return!1}if(++s>n.length)return!1}return s===n.length}function s(e){var t=this.node&&this.node[e];return t&&Array.isArray(t)?!!t.length:!!t}function a(){return this.scope.isStatic(this.node)}function o(e){return!this.has(e)}function u(e,t){return this.node[e]===t}function l(e){return C.isType(this.type,e)}function c(){return("init"===this.key||"left"===this.key)&&this.parentPath.isFor()}function f(e){return!("body"!==this.key||!this.parentPath.isArrowFunctionExpression())&&(this.isExpression()?C.isBlockStatement(e):!!this.isBlockStatement()&&C.isExpression(e))}function p(e){var t=this,r=!0;do{var n=t.container;if(t.isFunction()&&!r)return!!e;if(r=!1,Array.isArray(n)&&t.key!==n.length-1)return!1}while((t=t.parentPath)&&!t.isProgram());return!0}function d(){return!this.parentPath.isLabeledStatement()&&!C.isBlockStatement(this.container)&&(0,_.default)(C.STATEMENT_OR_BLOCK_KEYS,this.key)}function h(e,t){if(!this.isReferencedIdentifier())return!1;var r=this.scope.getBinding(this.node.name);if(!r||"module"!==r.kind)return!1;var n=r.path,i=n.parentPath;return!!i.isImportDeclaration()&&(i.node.source.value===e&&(!t||(!(!n.isImportDefaultSpecifier()||"default"!==t)||(!(!n.isImportNamespaceSpecifier()||"*"!==t)||!(!n.isImportSpecifier()||n.node.imported.name!==t)))))}function m(){var e=this.node;return e.end?this.hub.file.code.slice(e.start,e.end):""}function y(e){return"after"!==this._guessExecutionStatusRelativeTo(e)}function v(e){var t=e.scope.getFunctionParent(),r=this.scope.getFunctionParent();if(t.node!==r.node){var n=this._guessExecutionStatusRelativeToDifferentFunctions(t);if(n)return n;e=t.path}var i=e.getAncestry();if(i.indexOf(this)>=0)return"after";var s=this.getAncestry(),a=void 0,o=void 0,u=void 0;for(u=0;u<s.length;u++){var l=s[u];if((o=i.indexOf(l))>=0){a=l;break}}if(!a)return"before";var c=i[o-1],f=s[u-1];return c&&f?c.listKey&&c.container===f.container?c.key>f.key?"before":"after":C.VISITOR_KEYS[c.type].indexOf(c.key)>C.VISITOR_KEYS[f.type].indexOf(f.key)?"before":"after":"before"}function g(e){var t=e.path;if(t.isFunctionDeclaration()){var r=t.scope.getBinding(t.node.id.name);if(!r.references)return"before";for(var n=r.referencePaths,i=n,s=Array.isArray(i),a=0,i=s?i:(0,A.default)(i);;){var o;if(s){if(a>=i.length)break;o=i[a++]}else{if(a=i.next(),a.done)break;o=a.value}var u=o;if("callee"!==u.key||!u.parentPath.isCallExpression())return}for(var l=void 0,c=n,f=Array.isArray(c),p=0,c=f?c:(0,A.default)(c);;){var d;if(f){if(p>=c.length)break;d=c[p++]}else{if(p=c.next(),p.done)break;d=p.value}var h=d;if(!!!h.find(function(e){return e.node===t.node})){var m=this._guessExecutionStatusRelativeTo(h);if(l){if(l!==m)return}else l=m}}return l}}function b(e,t){return this._resolve(e,t)||this}function E(e,t){if(!(t&&t.indexOf(this)>=0))if(t=t||[],t.push(this),this.isVariableDeclarator()){if(this.get("id").isIdentifier())return this.get("init").resolve(e,t)}else if(this.isReferencedIdentifier()){var r=this.scope.getBinding(this.node.name);if(!r)return;if(!r.constant)return;if("module"===r.kind)return;if(r.path!==this){var n=r.path.resolve(e,t);if(this.find(function(e){return e.node===n.node}))return;return n}}else{if(this.isTypeCastExpression())return this.get("expression").resolve(e,t);if(e&&this.isMemberExpression()){var i=this.toComputedKey();if(!C.isLiteral(i))return;var s=i.value,a=this.get("object").resolve(e,t);if(a.isObjectExpression())for(var o=a.get("properties"),u=o,l=Array.isArray(u),c=0,u=l?u:(0,A.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;if(p.isProperty()){var d=p.get("key"),h=p.isnt("computed")&&d.isIdentifier({name:s});if(h=h||d.isLiteral({value:s}))return p.get("value").resolve(e,t)}}else if(a.isArrayExpression()&&!isNaN(+s)){var m=a.get("elements"),y=m[s];if(y)return y.resolve(e,t)}}}}t.__esModule=!0,t.is=void 0;var x=r(2),A=n(x);t.matchesPattern=i,t.has=s,t.isStatic=a,t.isnt=o,t.equals=u,t.isNodeType=l,t.canHaveVariableDeclarationOrExpression=c,t.canSwapBetweenExpressionAndStatement=f,t.isCompletionRecord=p,t.isStatementOrBlock=d,t.referencesImport=h,t.getSource=m,
t.willIMaybeExecuteBefore=y,t._guessExecutionStatusRelativeTo=v,t._guessExecutionStatusRelativeToDifferentFunctions=g,t.resolve=b,t._resolve=E;var S=r(111),_=n(S),D=r(1),C=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(D);t.is=s},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(2),s=n(i),a=r(3),o=n(a),u=r(1),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(u),c={ReferencedIdentifier:function(e,t){if(!e.isJSXIdentifier()||!u.react.isCompatTag(e.node.name)||e.parentPath.isJSXMemberExpression()){if("this"===e.node.name){var r=e.scope;do{if(r.path.isFunction()&&!r.path.isArrowFunctionExpression())break}while(r=r.parent);r&&t.breakOnScopePaths.push(r.path)}var n=e.scope.getBinding(e.node.name);n&&n===t.scope.getBinding(e.node.name)&&(t.bindings[e.node.name]=n)}}},f=function(){function e(t,r){(0,o.default)(this,e),this.breakOnScopePaths=[],this.bindings={},this.scopes=[],this.scope=r,this.path=t,this.attachAfter=!1}return e.prototype.isCompatibleScope=function(e){for(var t in this.bindings){var r=this.bindings[t];if(!e.bindingIdentifierEquals(t,r.identifier))return!1}return!0},e.prototype.getCompatibleScopes=function(){var e=this.path.scope;do{if(!this.isCompatibleScope(e))break;if(this.scopes.push(e),this.breakOnScopePaths.indexOf(e.path)>=0)break}while(e=e.parent)},e.prototype.getAttachmentPath=function(){var e=this._getAttachmentPath();if(e){var t=e.scope;if(t.path===e&&(t=e.scope.parent),t.path.isProgram()||t.path.isFunction())for(var r in this.bindings)if(t.hasOwnBinding(r)){var n=this.bindings[r];if("param"!==n.kind&&this.getAttachmentParentForPath(n.path).key>e.key){this.attachAfter=!0,e=n.path;for(var i=n.constantViolations,a=Array.isArray(i),o=0,i=a?i:(0,s.default)(i);;){var u;if(a){if(o>=i.length)break;u=i[o++]}else{if(o=i.next(),o.done)break;u=o.value}var l=u;this.getAttachmentParentForPath(l).key>e.key&&(e=l)}}}return e.parentPath.isExportDeclaration()&&(e=e.parentPath),e}},e.prototype._getAttachmentPath=function(){var e=this.scopes,t=e.pop();if(t){if(t.path.isFunction()){if(this.hasOwnParamBindings(t)){if(this.scope===t)return;return t.path.get("body").get("body")[0]}return this.getNextScopeAttachmentParent()}return t.path.isProgram()?this.getNextScopeAttachmentParent():void 0}},e.prototype.getNextScopeAttachmentParent=function(){var e=this.scopes.pop();if(e)return this.getAttachmentParentForPath(e.path)},e.prototype.getAttachmentParentForPath=function(e){do{if(!e.parentPath||Array.isArray(e.container)&&e.isStatement()||e.isVariableDeclarator()&&null!==e.parentPath.node&&e.parentPath.node.declarations.length>1)return e}while(e=e.parentPath)},e.prototype.hasOwnParamBindings=function(e){for(var t in this.bindings)if(e.hasOwnBinding(t)){var r=this.bindings[t];if("param"===r.kind&&r.constant)return!0}return!1},e.prototype.run=function(){var e=this.path.node;if(!e._hoisted){e._hoisted=!0,this.path.traverse(c,this),this.getCompatibleScopes();var t=this.getAttachmentPath();if(t&&t.getFunctionParent()!==this.path.getFunctionParent()){var r=t.scope.generateUidIdentifier("ref"),n=l.variableDeclarator(r,this.path.node);t[this.attachAfter?"insertAfter":"insertBefore"]([t.isVariableDeclarator()?n:l.variableDeclaration("var",[n])]);var i=this.path.parentPath;i.isJSXElement()&&this.path.container===i.node.children&&(r=l.JSXExpressionContainer(r)),this.path.replaceWith(r)}}},e}();t.default=f,e.exports=t.default},function(e,t){"use strict";t.__esModule=!0;t.hooks=[function(e,t){if("test"===e.key&&(t.isWhile()||t.isSwitchCase())||"declaration"===e.key&&t.isExportDeclaration()||"body"===e.key&&t.isLabeledStatement()||"declarations"===e.listKey&&t.isVariableDeclaration()&&1===t.node.declarations.length||"expression"===e.key&&t.isExpressionStatement())return t.remove(),!0},function(e,t){if(t.isSequenceExpression()&&1===t.node.expressions.length)return t.replaceWith(t.node.expressions[0]),!0},function(e,t){if(t.isBinary())return"left"===e.key?t.replaceWith(t.node.right):t.replaceWith(t.node.left),!0},function(e,t){if(t.isIfStatement()&&("consequent"===e.key||"alternate"===e.key)||"body"===e.key&&(t.isLoop()||t.isArrowFunctionExpression()))return e.replaceWith({type:"BlockStatement",body:[]}),!0}]},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){if(this._assertUnremoved(),e=this._verifyNodeList(e),this.parentPath.isExpressionStatement()||this.parentPath.isLabeledStatement())return this.parentPath.insertBefore(e);if(this.isNodeType("Expression")||this.parentPath.isForStatement()&&"init"===this.key)this.node&&e.push(this.node),this.replaceExpressionWithStatements(e);else{if(this._maybePopFromStatements(e),Array.isArray(this.container))return this._containerInsertBefore(e);if(!this.isStatementOrBlock())throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");this.node&&e.push(this.node),this._replaceWith(D.blockStatement(e))}return[this]}function s(e,t){this.updateSiblingKeys(e,t.length);for(var r=[],n=0;n<t.length;n++){var i=e+n,s=t[n];if(this.container.splice(i,0,s),this.context){var a=this.context.create(this.parent,this.container,i,this.listKey);this.context.queue&&a.pushContext(this.context),r.push(a)}else r.push(S.default.get({parentPath:this.parentPath,parent:this.parent,container:this.container,listKey:this.listKey,key:i}))}for(var o=this._getQueueContexts(),u=r,l=Array.isArray(u),c=0,u=l?u:(0,g.default)(u);;){var f;if(l){if(c>=u.length)break;f=u[c++]}else{if(c=u.next(),c.done)break;f=c.value}var p=f;p.setScope(),p.debug(function(){return"Inserted."});for(var d=o,h=Array.isArray(d),m=0,d=h?d:(0,g.default)(d);;){var y;if(h){if(m>=d.length)break;y=d[m++]}else{if(m=d.next(),m.done)break;y=m.value}y.maybeQueue(p,!0)}}return r}function a(e){return this._containerInsert(this.key,e)}function o(e){return this._containerInsert(this.key+1,e)}function u(e){var t=e[e.length-1];(D.isIdentifier(t)||D.isExpressionStatement(t)&&D.isIdentifier(t.expression))&&!this.isCompletionRecord()&&e.pop()}function l(e){if(this._assertUnremoved(),e=this._verifyNodeList(e),this.parentPath.isExpressionStatement()||this.parentPath.isLabeledStatement())return this.parentPath.insertAfter(e);if(this.isNodeType("Expression")||this.parentPath.isForStatement()&&"init"===this.key){if(this.node){var t=this.scope.generateDeclaredUidIdentifier();e.unshift(D.expressionStatement(D.assignmentExpression("=",t,this.node))),e.push(D.expressionStatement(t))}this.replaceExpressionWithStatements(e)}else{if(this._maybePopFromStatements(e),Array.isArray(this.container))return this._containerInsertAfter(e);if(!this.isStatementOrBlock())throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");this.node&&e.unshift(this.node),this._replaceWith(D.blockStatement(e))}return[this]}function c(e,t){if(this.parent)for(var r=b.path.get(this.parent),n=0;n<r.length;n++){var i=r[n];i.key>=e&&(i.key+=t)}}function f(e){if(!e)return[];e.constructor!==Array&&(e=[e]);for(var t=0;t<e.length;t++){var r=e[t],n=void 0;if(r?"object"!==(void 0===r?"undefined":(0,y.default)(r))?n="contains a non-object node":r.type?r instanceof S.default&&(n="has a NodePath when it expected a raw object"):n="without a type":n="has falsy node",n){var i=Array.isArray(r)?"array":void 0===r?"undefined":(0,y.default)(r);throw new Error("Node list "+n+" with the index of "+t+" and type of "+i)}}return e}function p(e,t){return this._assertUnremoved(),t=this._verifyNodeList(t),S.default.get({parentPath:this,parent:this.node,container:this.node[e],listKey:e,key:0}).insertBefore(t)}function d(e,t){this._assertUnremoved(),t=this._verifyNodeList(t);var r=this.node[e];return S.default.get({parentPath:this,parent:this.node,container:r,listKey:e,key:r.length}).replaceWithMultiple(t)}function h(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.scope;return new x.default(this,e).run()}t.__esModule=!0;var m=r(11),y=n(m),v=r(2),g=n(v);t.insertBefore=i,t._containerInsert=s,t._containerInsertBefore=a,t._containerInsertAfter=o,t._maybePopFromStatements=u,t.insertAfter=l,t.updateSiblingKeys=c,t._verifyNodeList=f,t.unshiftContainer=p,t.pushContainer=d,t.hoist=h;var b=r(88),E=r(378),x=n(E),A=r(36),S=n(A),_=r(1),D=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(_)},function(e,t,r){"use strict";function n(){if(this._assertUnremoved(),this.resync(),this._callRemovalHooks())return void this._markRemoved();this.shareCommentsWithSiblings(),this._remove(),this._markRemoved()}function i(){for(var e=c.hooks,t=Array.isArray(e),r=0,e=t?e:(0,l.default)(e);;){var n;if(t){if(r>=e.length)break;n=e[r++]}else{if(r=e.next(),r.done)break;n=r.value}if(n(this,this.parentPath))return!0}}function s(){Array.isArray(this.container)?(this.container.splice(this.key,1),this.updateSiblingKeys(this.key,-1)):this._replaceWith(null)}function a(){this.shouldSkip=!0,this.removed=!0,this.node=null}function o(){if(this.removed)throw this.buildCodeFrameError("NodePath has been removed so is read-only.")}t.__esModule=!0;var u=r(2),l=function(e){return e&&e.__esModule?e:{default:e}}(u);t.remove=n,t._callRemovalHooks=i,t._remove=s,t._markRemoved=a,t._assertUnremoved=o;var c=r(379)},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){this.resync(),e=this._verifyNodeList(e),E.inheritLeadingComments(e[0],this.node),E.inheritTrailingComments(e[e.length-1],this.node),this.node=this.container[this.key]=null,this.insertAfter(e),this.node?this.requeue():this.remove()}function s(e){this.resync();try{e="("+e+")",e=(0,g.parse)(e)}catch(r){var t=r.loc;throw t&&(r.message+=" - make sure this is an expression.",r.message+="\n"+(0,d.default)(e,t.line,t.column+1)),r}return e=e.program.body[0].expression,m.default.removeProperties(e),this.replaceWith(e)}function a(e){if(this.resync(),this.removed)throw new Error("You can't replace this node, we've already removed it");if(e instanceof v.default&&(e=e.node),!e)throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");if(this.node!==e){if(this.isProgram()&&!E.isProgram(e))throw new Error("You can only replace a Program root node with another Program node");if(Array.isArray(e))throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");if("string"==typeof e)throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");if(this.isNodeType("Statement")&&E.isExpression(e)&&(this.canHaveVariableDeclarationOrExpression()||this.canSwapBetweenExpressionAndStatement(e)||this.parentPath.isExportDefaultDeclaration()||(e=E.expressionStatement(e))),this.isNodeType("Expression")&&E.isStatement(e)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(e))return this.replaceExpressionWithStatements([e]);var t=this.node;t&&(E.inheritsComments(e,t),E.removeComments(t)),this._replaceWith(e),this.type=e.type,this.setScope(),this.requeue()}}function o(e){if(!this.container)throw new ReferenceError("Container is falsy");this.inList?E.validate(this.parent,this.key,[e]):E.validate(this.parent,this.key,e),this.debug(function(){return"Replace with "+(e&&e.type)}),this.node=this.container[this.key]=e}function u(e){this.resync();var t=E.toSequenceExpression(e,this.scope);if(E.isSequenceExpression(t)){var r=t.expressions;r.length>=2&&this.parentPath.isExpressionStatement()&&this._maybePopFromStatements(r),1===r.length?this.replaceWith(r[0]):this.replaceWith(t)}else{if(!t){var n=E.functionExpression(null,[],E.blockStatement(e));n.shadow=!0,this.replaceWith(E.callExpression(n,[])),this.traverse(x);for(var i=this.get("callee").getCompletionRecords(),s=i,a=Array.isArray(s),o=0,s=a?s:(0,f.default)(s);;){var u;if(a){if(o>=s.length)break;u=s[o++]}else{if(o=s.next(),o.done)break;u=o.value}var l=u;if(l.isExpressionStatement()){var c=l.findParent(function(e){return e.isLoop()});if(c){var p=c.getData("expressionReplacementReturnUid");if(p)p=E.identifier(p.name);else{var d=this.get("callee");p=d.scope.generateDeclaredUidIdentifier("ret"),d.get("body").pushContainer("body",E.returnStatement(p)),c.setData("expressionReplacementReturnUid",p)}l.get("expression").replaceWith(E.assignmentExpression("=",p,l.node.expression))}else l.replaceWith(E.returnStatement(l.node.expression))}}return this.node}this.replaceWith(t)}}function l(e){return this.resync(),Array.isArray(e)?Array.isArray(this.container)?(e=this._verifyNodeList(e),this._containerInsertAfter(e),this.remove()):this.replaceWithMultiple(e):this.replaceWith(e)}t.__esModule=!0;var c=r(2),f=n(c);t.replaceWithMultiple=i,t.replaceWithSourceString=s,t.replaceWith=a,t._replaceWith=o,t.replaceExpressionWithStatements=u,t.replaceInline=l;var p=r(181),d=n(p),h=r(7),m=n(h),y=r(36),v=n(y),g=r(89),b=r(1),E=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(b),x={Function:function(e){e.skip()},VariableDeclaration:function(e){if("var"===e.node.kind){var t=e.getBindingIdentifiers();for(var r in t)e.scope.push({id:t[r]});for(var n=[],i=e.node.declarations,s=Array.isArray(i),a=0,i=s?i:(0,f.default)(i);;){var o;if(s){if(a>=i.length)break;o=i[a++]}else{if(a=i.next(),a.done)break;o=a.value}var u=o;u.init&&n.push(E.expressionStatement(E.assignmentExpression("=",u.id,u.init)))}e.replaceWithMultiple(n)}}}},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var i=r(3),s=n(i),a=r(225),o=(n(a),r(1)),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(o),l={ReferencedIdentifier:function(e,t){var r=e.node;r.name===t.oldName&&(r.name=t.newName)},Scope:function(e,t){e.scope.bindingIdentifierEquals(t.oldName,t.binding.identifier)||e.skip()},"AssignmentExpression|Declaration":function(e,t){var r=e.getOuterBindingIdentifiers();for(var n in r)n===t.oldName&&(r[n].name=t.newName)}},c=function(){function e(t,r,n){(0,s.default)(this,e),this.newName=n,this.oldName=r,this.binding=t}return e.prototype.maybeConvertFromExportDeclaration=function(e){var t=e.parentPath.isExportDeclaration()&&e.parentPath;if(t){var r=t.isExportDefaultDeclaration();r&&(e.isFunctionDeclaration()||e.isClassDeclaration())&&!e.node.id&&(e.node.id=e.scope.generateUidIdentifier("default"));var n=e.getOuterBindingIdentifiers(),i=[];for(var s in n){var a=s===this.oldName?this.newName:s,o=r?"default":s;i.push(u.exportSpecifier(u.identifier(a),u.identifier(o)))}if(i.length){var l=u.exportNamedDeclaration(null,i);e.isFunctionDeclaration()&&(l._blockHoist=3),t.insertAfter(l),t.replaceWith(e.node)}}},e.prototype.rename=function(e){var t=this.binding,r=this.oldName,n=this.newName,i=t.scope,s=t.path,a=s.find(function(e){return e.isDeclaration()||e.isFunctionExpression()});a&&this.maybeConvertFromExportDeclaration(a),i.traverse(e||i.block,l,this),e||(i.removeOwnBinding(r),i.bindings[n]=t,this.binding.identifier.name=n),t.type},e}();t.default=c,e.exports=t.default},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e){if(e._exploded)return e;e._exploded=!0;for(var t in e)if(!d(t)){var r=t.split("|");if(1!==r.length){var n=e[t];delete e[t];for(var i=r,s=Array.isArray(i),o=0,i=s?i:(0,E.default)(i);;){var u;if(s){if(o>=i.length)break;u=i[o++]}else{if(o=i.next(),o.done)break;u=o.value}var l=u;e[l]=n}}}a(e),delete e.__esModule,c(e),f(e);for(var m=(0,g.default)(e),y=Array.isArray(m),v=0,m=y?m:(0,E.default)(m);;){var b;if(y){if(v>=m.length)break;b=m[v++]}else{if(v=m.next(),v.done)break;b=v.value}var x=b;if(!d(x)){var S=A[x];if(S){var _=e[x];for(var D in _)_[D]=p(S,_[D]);if(delete e[x],S.types)for(var w=S.types,k=Array.isArray(w),F=0,w=k?w:(0,E.default)(w);;){var T;if(k){if(F>=w.length)break;T=w[F++]}else{if(F=w.next(),F.done)break;T=F.value}var O=T;e[O]?h(e[O],_):e[O]=_}else h(e,_)}}}for(var B in e)if(!d(B)){var R=e[B],I=C.FLIPPED_ALIAS_KEYS[B],M=C.DEPRECATED_KEYS[B];if(M&&(console.trace("Visitor defined for "+B+" but it has been renamed to "+M),I=[M]),I){delete e[B];for(var N=I,L=Array.isArray(N),j=0,N=L?N:(0,E.default)(N);;){var U;if(L){if(j>=N.length)break;U=N[j++]}else{if(j=N.next(),j.done)break;U=j.value}var V=U,G=e[V];G?h(G,R):e[V]=(0,P.default)(R)}}}for(var W in e)d(W)||f(e[W]);return e}function a(e){if(!e._verified){if("function"==typeof e)throw new Error(_.get("traverseVerifyRootFunction"));for(var t in e)if("enter"!==t&&"exit"!==t||o(t,e[t]),!d(t)){if(C.TYPES.indexOf(t)<0)throw new Error(_.get("traverseVerifyNodeType",t));var r=e[t];if("object"===(void 0===r?"undefined":(0,y.default)(r)))for(var n in r){if("enter"!==n&&"exit"!==n)throw new Error(_.get("traverseVerifyVisitorProperty",t,n));o(t+"."+n,r[n])}}e._verified=!0}}function o(e,t){for(var r=[].concat(t),n=r,i=Array.isArray(n),s=0,n=i?n:(0,E.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;if("function"!=typeof o)throw new TypeError("Non-function found defined in "+e+" with type "+(void 0===o?"undefined":(0,y.default)(o)))}}function u(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments[2],n={},i=0;i<e.length;i++){var a=e[i],o=t[i];s(a);for(var u in a){var c=a[u];(o||r)&&(c=l(c,o,r));h(n[u]=n[u]||{},c)}}return n}function l(e,t,r){var n={};for(var i in e){(function(i){var s=e[i];if(!Array.isArray(s))return"continue";s=s.map(function(e){var n=e;return t&&(n=function(r){return e.call(t,r,t)}),r&&(n=r(t.key,i,n)),n}),n[i]=s})(i)}return n}function c(e){for(var t in e)if(!d(t)){var r=e[t];"function"==typeof r&&(e[t]={enter:r})}}function f(e){e.enter&&!Array.isArray(e.enter)&&(e.enter=[e.enter]),e.exit&&!Array.isArray(e.exit)&&(e.exit=[e.exit])}function p(e,t){var r=function(r){if(e.checkPath(r))return t.apply(this,arguments)};return r.toString=function(){return t.toString()},r}function d(e){return"_"===e[0]||("enter"===e||"exit"===e||"shouldSkip"===e||("blacklist"===e||"noScope"===e||"skipKeys"===e))}function h(e,t){for(var r in t)e[r]=[].concat(e[r]||[],t[r])}t.__esModule=!0;var m=r(11),y=i(m),v=r(14),g=i(v),b=r(2),E=i(b);t.explode=s,t.verify=a,t.merge=u;var x=r(224),A=n(x),S=r(20),_=n(S),D=r(1),C=n(D),w=r(109),P=i(w)},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.key||e.property;return e.computed||D.isIdentifier(t)&&(t=D.stringLiteral(t.name)),t}function s(e,t,r){for(var n=[],i=!0,a=e,o=Array.isArray(a),u=0,a=o?a:(0,b.default)(a);;){var l;if(o){if(u>=a.length)break;l=a[u++]}else{if(u=a.next(),u.done)break;l=u.value}var c=l;if(i=!1,D.isExpression(c))n.push(c);else if(D.isExpressionStatement(c))n.push(c.expression);else if(D.isVariableDeclaration(c)){if("var"!==c.kind)return;for(var f=c.declarations,p=Array.isArray(f),d=0,f=p?f:(0,b.default)(f);;){var h;if(p){if(d>=f.length)break;h=f[d++]}else{if(d=f.next(),d.done)break;h=d.value}var m=h,y=D.getBindingIdentifiers(m);for(var v in y)r.push({kind:c.kind,id:y[v]});m.init&&n.push(D.assignmentExpression("=",m.id,m.init))}i=!0}else if(D.isIfStatement(c)){var g=c.consequent?s([c.consequent],t,r):t.buildUndefinedNode(),E=c.alternate?s([c.alternate],t,r):t.buildUndefinedNode();if(!g||!E)return;n.push(D.conditionalExpression(c.test,g,E))}else if(D.isBlockStatement(c)){var x=s(c.body,t,r);if(!x)return;n.push(x)}else{if(!D.isEmptyStatement(c))return;i=!0}}return i&&n.push(t.buildUndefinedNode()),1===n.length?n[0]:D.sequenceExpression(n)}function a(e,t){if(e&&e.length){var r=[],n=s(e,t,r);if(n){for(var i=r,a=Array.isArray(i),o=0,i=a?i:(0,b.default)(i);;){var u;if(a){if(o>=i.length)break;u=i[o++]}else{if(o=i.next(),o.done)break;u=o.value}var l=u;t.push(l)}return n}}}function o(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.key,r=void 0;return"method"===e.kind?o.increment()+"":(r=D.isIdentifier(t)?t.name:D.isStringLiteral(t)?(0,v.default)(t.value):(0,v.default)(D.removePropertiesDeep(D.cloneDeep(t))),e.computed&&(r="["+r+"]"),e.static&&(r="static:"+r),r)}function u(e){return e+="",e=e.replace(/[^a-zA-Z0-9$_]/g,"-"),e=e.replace(/^[-0-9]+/,""),e=e.replace(/[-\s]+(.)?/g,function(e,t){return t?t.toUpperCase():""}),D.isValidIdentifier(e)||(e="_"+e),e||"_"}function l(e){return e=u(e),"eval"!==e&&"arguments"!==e||(e="_"+e),e}function c(e,t){if(D.isStatement(e))return e;var r=!1,n=void 0;if(D.isClass(e))r=!0,n="ClassDeclaration";else if(D.isFunction(e))r=!0,n="FunctionDeclaration";else if(D.isAssignmentExpression(e))return D.expressionStatement(e);if(r&&!e.id&&(n=!1),!n){if(t)return!1;throw new Error("cannot turn "+e.type+" to a statement")}return e.type=n,e}function f(e){if(D.isExpressionStatement(e)&&(e=e.expression),D.isExpression(e))return e;if(D.isClass(e)?e.type="ClassExpression":D.isFunction(e)&&(e.type="FunctionExpression"),!D.isExpression(e))throw new Error("cannot turn "+e.type+" to an expression");return e}function p(e,t){return D.isBlockStatement(e)?e:(D.isEmptyStatement(e)&&(e=[]),Array.isArray(e)||(D.isStatement(e)||(e=D.isFunction(t)?D.returnStatement(e):D.expressionStatement(e)),e=[e]),D.blockStatement(e))}function d(e){if(void 0===e)return D.identifier("undefined");if(!0===e||!1===e)return D.booleanLiteral(e);if(null===e)return D.nullLiteral();if("string"==typeof e)return D.stringLiteral(e);if("number"==typeof e)return D.numericLiteral(e);if((0,S.default)(e)){var t=e.source,r=e.toString().match(/\/([a-z]+|)$/)[1];return D.regExpLiteral(t,r)}if(Array.isArray(e))return D.arrayExpression(e.map(D.valueToNode));if((0,x.default)(e)){var n=[];for(var i in e){var s=void 0;s=D.isValidIdentifier(i)?D.identifier(i):D.stringLiteral(i),n.push(D.objectProperty(s,D.valueToNode(e[i])))}return D.objectExpression(n)}throw new Error("don't know how to turn this value into a node")}t.__esModule=!0;var h=r(359),m=n(h),y=r(35),v=n(y),g=r(2),b=n(g);t.toComputedKey=i,t.toSequenceExpression=a,t.toKeyAlias=o,t.toIdentifier=u,t.toBindingIdentifierName=l,t.toStatement=c,t.toExpression=f,t.toBlock=p,t.valueToNode=d;var E=r(275),x=n(E),A=r(276),S=n(A),_=r(1),D=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(_);o.uid=0,o.increment=function(){return o.uid>=m.default?o.uid=0:o.uid++}},function(e,t,r){"use strict";var n=r(1),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(n),s=r(135),a=r(26),o=function(e){return e&&e.__esModule?e:{default:e}}(a);(0,o.default)("ArrayExpression",{fields:{elements:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeOrValueType)("null","Expression","SpreadElement"))),default:[]}},visitor:["elements"],aliases:["Expression"]}),(0,o.default)("AssignmentExpression",{fields:{operator:{validate:(0,a.assertValueType)("string")},left:{validate:(0,a.assertNodeType)("LVal")},right:{validate:(0,a.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]}),(0,o.default)("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:a.assertOneOf.apply(void 0,s.BINARY_OPERATORS)},left:{validate:(0,a.assertNodeType)("Expression")},right:{validate:(0,a.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]}),(0,o.default)("Directive",{visitor:["value"],fields:{value:{validate:(0,a.assertNodeType)("DirectiveLiteral")}}}),(0,o.default)("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0,a.assertValueType)("string")}}}),(0,o.default)("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Directive"))),default:[]},body:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block","Statement"]}),(0,o.default)("BreakStatement",{visitor:["label"],fields:{label:{validate:(0,a.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),(0,o.default)("CallExpression",{visitor:["callee","arguments"],fields:{callee:{validate:(0,a.assertNodeType)("Expression")},arguments:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Expression","SpreadElement")))}},aliases:["Expression"]}),(0,o.default)("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0,a.assertNodeType)("Identifier")},body:{validate:(0,a.assertNodeType)("BlockStatement")}},aliases:["Scopable"]}),(0,o.default)("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0,a.assertNodeType)("Expression")},consequent:{validate:(0,a.assertNodeType)("Expression")},alternate:{validate:(0,a.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]}),(0,o.default)("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0,a.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),(0,o.default)("DebuggerStatement",{aliases:["Statement"]}),(0,o.default)("DoWhileStatement",{visitor:["test","body"],fields:{test:{validate:(0,a.assertNodeType)("Expression")},body:{validate:(0,a.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]}),(0,o.default)("EmptyStatement",{aliases:["Statement"]}),(0,o.default)("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0,a.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]}),(0,o.default)("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0,a.assertNodeType)("Program")}}}),(0,o.default)("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:(0,a.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0,a.assertNodeType)("Expression")},body:{validate:(0,a.assertNodeType)("Statement")}}}),(0,o.default)("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0,a.assertNodeType)("VariableDeclaration","Expression"),optional:!0},test:{validate:(0,a.assertNodeType)("Expression"),optional:!0},update:{validate:(0,a.assertNodeType)("Expression"),optional:!0},body:{validate:(0,a.assertNodeType)("Statement")}}}),(0,o.default)("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","params","body","returnType","typeParameters"],fields:{id:{validate:(0,a.assertNodeType)("Identifier")},params:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("LVal")))},body:{validate:(0,a.assertNodeType)("BlockStatement")},generator:{default:!1,validate:(0,a.assertValueType)("boolean")},async:{default:!1,validate:(0,a.assertValueType)("boolean")}},aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"]}),(0,o.default)("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:{id:{validate:(0,a.assertNodeType)("Identifier"),optional:!0},params:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("LVal")))},body:{validate:(0,a.assertNodeType)("BlockStatement")},generator:{default:!1,validate:(0,a.assertValueType)("boolean")},async:{default:!1,validate:(0,a.assertValueType)("boolean")}}}),(0,o.default)("Identifier",{builder:["name"],visitor:["typeAnnotation"],aliases:["Expression","LVal"],fields:{name:{validate:function(e,t,r){i.isValidIdentifier(r)}},decorators:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Decorator")))}}}),(0,o.default)("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0,a.assertNodeType)("Expression")},consequent:{validate:(0,a.assertNodeType)("Statement")},alternate:{optional:!0,validate:(0,a.assertNodeType)("Statement")}}}),(0,o.default)("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0,a.assertNodeType)("Identifier")},body:{validate:(0,a.assertNodeType)("Statement")}}}),(0,o.default)("StringLiteral",{builder:["value"],fields:{value:{validate:(0,a.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0,o.default)("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0,a.assertValueType)("number")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0,o.default)("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]}),(0,o.default)("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0,a.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0,o.default)("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Literal"],fields:{pattern:{validate:(0,a.assertValueType)("string")},flags:{validate:(0,a.assertValueType)("string"),default:""}}}),(0,o.default)("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:a.assertOneOf.apply(void 0,s.LOGICAL_OPERATORS)},left:{validate:(0,a.assertNodeType)("Expression")},right:{validate:(0,a.assertNodeType)("Expression")}}}),(0,o.default)("MemberExpression",{builder:["object","property","computed"],visitor:["object","property"],aliases:["Expression","LVal"],fields:{object:{validate:(0,a.assertNodeType)("Expression")},property:{validate:function(e,t,r){var n=e.computed?"Expression":"Identifier";(0,a.assertNodeType)(n)(e,t,r)}},computed:{default:!1}}}),(0,o.default)("NewExpression",{visitor:["callee","arguments"],aliases:["Expression"],fields:{callee:{validate:(0,a.assertNodeType)("Expression")},arguments:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Expression","SpreadElement")))}}}),(0,o.default)("Program",{visitor:["directives","body"],builder:["body","directives"],fields:{directives:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Directive"))),default:[]},body:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block","FunctionParent"]}),(0,o.default)("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("ObjectMethod","ObjectProperty","SpreadProperty")))}}}),(0,o.default)("ObjectMethod",{builder:["kind","key","params","body","computed"],fields:{kind:{validate:(0,a.chain)((0,a.assertValueType)("string"),(0,a.assertOneOf)("method","get","set")),default:"method"},computed:{validate:(0,a.assertValueType)("boolean"),default:!1},key:{validate:function(e,t,r){var n=e.computed?["Expression"]:["Identifier","StringLiteral","NumericLiteral"];a.assertNodeType.apply(void 0,n)(e,t,r)}},decorators:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Decorator")))},
body:{validate:(0,a.assertNodeType)("BlockStatement")},generator:{default:!1,validate:(0,a.assertValueType)("boolean")},async:{default:!1,validate:(0,a.assertValueType)("boolean")}},visitor:["key","params","body","decorators","returnType","typeParameters"],aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]}),(0,o.default)("ObjectProperty",{builder:["key","value","computed","shorthand","decorators"],fields:{computed:{validate:(0,a.assertValueType)("boolean"),default:!1},key:{validate:function(e,t,r){var n=e.computed?["Expression"]:["Identifier","StringLiteral","NumericLiteral"];a.assertNodeType.apply(void 0,n)(e,t,r)}},value:{validate:(0,a.assertNodeType)("Expression","Pattern","RestElement")},shorthand:{validate:(0,a.assertValueType)("boolean"),default:!1},decorators:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Decorator"))),optional:!0}},visitor:["key","value","decorators"],aliases:["UserWhitespacable","Property","ObjectMember"]}),(0,o.default)("RestElement",{visitor:["argument","typeAnnotation"],aliases:["LVal"],fields:{argument:{validate:(0,a.assertNodeType)("LVal")},decorators:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Decorator")))}}}),(0,o.default)("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,a.assertNodeType)("Expression"),optional:!0}}}),(0,o.default)("SequenceExpression",{visitor:["expressions"],fields:{expressions:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Expression")))}},aliases:["Expression"]}),(0,o.default)("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0,a.assertNodeType)("Expression"),optional:!0},consequent:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("Statement")))}}}),(0,o.default)("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0,a.assertNodeType)("Expression")},cases:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("SwitchCase")))}}}),(0,o.default)("ThisExpression",{aliases:["Expression"]}),(0,o.default)("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,a.assertNodeType)("Expression")}}}),(0,o.default)("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{body:{validate:(0,a.assertNodeType)("BlockStatement")},handler:{optional:!0,handler:(0,a.assertNodeType)("BlockStatement")},finalizer:{optional:!0,validate:(0,a.assertNodeType)("BlockStatement")}}}),(0,o.default)("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!0},argument:{validate:(0,a.assertNodeType)("Expression")},operator:{validate:a.assertOneOf.apply(void 0,s.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]}),(0,o.default)("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!1},argument:{validate:(0,a.assertNodeType)("Expression")},operator:{validate:a.assertOneOf.apply(void 0,s.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]}),(0,o.default)("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{kind:{validate:(0,a.chain)((0,a.assertValueType)("string"),(0,a.assertOneOf)("var","let","const"))},declarations:{validate:(0,a.chain)((0,a.assertValueType)("array"),(0,a.assertEach)((0,a.assertNodeType)("VariableDeclarator")))}}}),(0,o.default)("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:(0,a.assertNodeType)("LVal")},init:{optional:!0,validate:(0,a.assertNodeType)("Expression")}}}),(0,o.default)("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0,a.assertNodeType)("Expression")},body:{validate:(0,a.assertNodeType)("BlockStatement","Statement")}}}),(0,o.default)("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{object:(0,a.assertNodeType)("Expression")},body:{validate:(0,a.assertNodeType)("BlockStatement","Statement")}}})},function(e,t,r){"use strict";var n=r(26),i=function(e){return e&&e.__esModule?e:{default:e}}(n);(0,i.default)("AssignmentPattern",{visitor:["left","right"],aliases:["Pattern","LVal"],fields:{left:{validate:(0,n.assertNodeType)("Identifier")},right:{validate:(0,n.assertNodeType)("Expression")},decorators:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Decorator")))}}}),(0,i.default)("ArrayPattern",{visitor:["elements","typeAnnotation"],aliases:["Pattern","LVal"],fields:{elements:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Identifier","Pattern","RestElement")))},decorators:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Decorator")))}}}),(0,i.default)("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["params","body","returnType","typeParameters"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:{params:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("LVal")))},body:{validate:(0,n.assertNodeType)("BlockStatement","Expression")},async:{validate:(0,n.assertValueType)("boolean"),default:!1}}}),(0,i.default)("ClassBody",{visitor:["body"],fields:{body:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("ClassMethod","ClassProperty")))}}}),(0,i.default)("ClassDeclaration",{builder:["id","superClass","body","decorators"],visitor:["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],aliases:["Scopable","Class","Statement","Declaration","Pureish"],fields:{id:{validate:(0,n.assertNodeType)("Identifier")},body:{validate:(0,n.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,n.assertNodeType)("Expression")},decorators:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Decorator")))}}}),(0,i.default)("ClassExpression",{inherits:"ClassDeclaration",aliases:["Scopable","Class","Expression","Pureish"],fields:{id:{optional:!0,validate:(0,n.assertNodeType)("Identifier")},body:{validate:(0,n.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,n.assertNodeType)("Expression")},decorators:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Decorator")))}}}),(0,i.default)("ExportAllDeclaration",{visitor:["source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{source:{validate:(0,n.assertNodeType)("StringLiteral")}}}),(0,i.default)("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{validate:(0,n.assertNodeType)("FunctionDeclaration","ClassDeclaration","Expression")}}}),(0,i.default)("ExportNamedDeclaration",{visitor:["declaration","specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{validate:(0,n.assertNodeType)("Declaration"),optional:!0},specifiers:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("ExportSpecifier")))},source:{validate:(0,n.assertNodeType)("StringLiteral"),optional:!0}}}),(0,i.default)("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,n.assertNodeType)("Identifier")},exported:{validate:(0,n.assertNodeType)("Identifier")}}}),(0,i.default)("ForOfStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:(0,n.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0,n.assertNodeType)("Expression")},body:{validate:(0,n.assertNodeType)("Statement")}}}),(0,i.default)("ImportDeclaration",{visitor:["specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration"],fields:{specifiers:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier")))},source:{validate:(0,n.assertNodeType)("StringLiteral")}}}),(0,i.default)("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,n.assertNodeType)("Identifier")}}}),(0,i.default)("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,n.assertNodeType)("Identifier")}}}),(0,i.default)("ImportSpecifier",{visitor:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,n.assertNodeType)("Identifier")},imported:{validate:(0,n.assertNodeType)("Identifier")},importKind:{validate:(0,n.assertOneOf)(null,"type","typeof")}}}),(0,i.default)("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:(0,n.assertValueType)("string")},property:{validate:(0,n.assertValueType)("string")}}}),(0,i.default)("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static"],visitor:["key","params","body","decorators","returnType","typeParameters"],fields:{kind:{validate:(0,n.chain)((0,n.assertValueType)("string"),(0,n.assertOneOf)("get","set","method","constructor")),default:"method"},computed:{default:!1,validate:(0,n.assertValueType)("boolean")},static:{default:!1,validate:(0,n.assertValueType)("boolean")},key:{validate:function(e,t,r){var i=e.computed?["Expression"]:["Identifier","StringLiteral","NumericLiteral"];n.assertNodeType.apply(void 0,i)(e,t,r)}},params:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("LVal")))},body:{validate:(0,n.assertNodeType)("BlockStatement")},generator:{default:!1,validate:(0,n.assertValueType)("boolean")},async:{default:!1,validate:(0,n.assertValueType)("boolean")}}}),(0,i.default)("ObjectPattern",{visitor:["properties","typeAnnotation"],aliases:["Pattern","LVal"],fields:{properties:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("RestProperty","Property")))},decorators:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Decorator")))}}}),(0,i.default)("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],fields:{argument:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("Super",{aliases:["Expression"]}),(0,i.default)("TaggedTemplateExpression",{visitor:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0,n.assertNodeType)("Expression")},quasi:{validate:(0,n.assertNodeType)("TemplateLiteral")}}}),(0,i.default)("TemplateElement",{builder:["value","tail"],fields:{value:{},tail:{validate:(0,n.assertValueType)("boolean"),default:!1}}}),(0,i.default)("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("TemplateElement")))},expressions:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("Expression")))}}}),(0,i.default)("YieldExpression",{builder:["argument","delegate"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{delegate:{validate:(0,n.assertValueType)("boolean"),default:!1},argument:{optional:!0,validate:(0,n.assertNodeType)("Expression")}}})},function(e,t,r){"use strict";var n=r(26),i=function(e){return e&&e.__esModule?e:{default:e}}(n);(0,i.default)("AwaitExpression",{builder:["argument"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{argument:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("ForAwaitStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:(0,n.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0,n.assertNodeType)("Expression")},body:{validate:(0,n.assertNodeType)("Statement")}}}),(0,i.default)("BindExpression",{visitor:["object","callee"],aliases:["Expression"],fields:{}}),(0,i.default)("Import",{aliases:["Expression"]}),(0,i.default)("Decorator",{visitor:["expression"],fields:{expression:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("DoExpression",{visitor:["body"],aliases:["Expression"],fields:{body:{validate:(0,n.assertNodeType)("BlockStatement")}}}),(0,i.default)("ExportDefaultSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0,n.assertNodeType)("Identifier")}}}),(0,i.default)("ExportNamespaceSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0,n.assertNodeType)("Identifier")}}}),(0,i.default)("RestProperty",{visitor:["argument"],aliases:["UnaryLike"],fields:{argument:{validate:(0,n.assertNodeType)("LVal")}}}),(0,i.default)("SpreadProperty",{visitor:["argument"],aliases:["UnaryLike"],fields:{argument:{validate:(0,n.assertNodeType)("Expression")}}})},function(e,t,r){"use strict";var n=r(26),i=function(e){return e&&e.__esModule?e:{default:e}}(n);(0,i.default)("AnyTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("ArrayTypeAnnotation",{visitor:["elementType"],aliases:["Flow"],fields:{}}),(0,i.default)("BooleanTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("BooleanLiteralTypeAnnotation",{aliases:["Flow"],fields:{}}),(0,i.default)("NullLiteralTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("ClassImplements",{visitor:["id","typeParameters"],aliases:["Flow"],fields:{}}),(0,i.default)("ClassProperty",{visitor:["key","value","typeAnnotation","decorators"],builder:["key","value","typeAnnotation","decorators","computed"],aliases:["Property"],fields:{computed:{validate:(0,n.assertValueType)("boolean"),default:!1}}}),(0,i.default)("DeclareClass",{visitor:["id","typeParameters","extends","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareFunction",{visitor:["id"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareInterface",{visitor:["id","typeParameters","extends","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareModule",{visitor:["id","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareModuleExports",{visitor:["typeAnnotation"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareTypeAlias",{visitor:["id","typeParameters","right"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareOpaqueType",{visitor:["id","typeParameters","supertype"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareVariable",{visitor:["id"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("DeclareExportDeclaration",{visitor:["declaration","specifiers","source"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("ExistentialTypeParam",{aliases:["Flow"]}),(0,i.default)("FunctionTypeAnnotation",{visitor:["typeParameters","params","rest","returnType"],aliases:["Flow"],fields:{}}),(0,i.default)("FunctionTypeParam",{visitor:["name","typeAnnotation"],aliases:["Flow"],fields:{}}),(0,i.default)("GenericTypeAnnotation",{visitor:["id","typeParameters"],aliases:["Flow"],fields:{}}),(0,i.default)("InterfaceExtends",{visitor:["id","typeParameters"],aliases:["Flow"],fields:{}}),(0,i.default)("InterfaceDeclaration",{visitor:["id","typeParameters","extends","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("IntersectionTypeAnnotation",{visitor:["types"],aliases:["Flow"],fields:{}}),(0,i.default)("MixedTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"]}),(0,i.default)("EmptyTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"]}),(0,i.default)("NullableTypeAnnotation",{visitor:["typeAnnotation"],aliases:["Flow"],fields:{}}),(0,i.default)("NumericLiteralTypeAnnotation",{aliases:["Flow"],fields:{}}),(0,i.default)("NumberTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("StringLiteralTypeAnnotation",{aliases:["Flow"],fields:{}}),(0,i.default)("StringTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("ThisTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}}),(0,i.default)("TupleTypeAnnotation",{visitor:["types"],aliases:["Flow"],fields:{}}),(0,i.default)("TypeofTypeAnnotation",{visitor:["argument"],aliases:["Flow"],fields:{}}),(0,i.default)("TypeAlias",{visitor:["id","typeParameters","right"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("OpaqueType",{visitor:["id","typeParameters","impltype","supertype"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{}}),(0,i.default)("TypeAnnotation",{visitor:["typeAnnotation"],aliases:["Flow"],fields:{}}),(0,i.default)("TypeCastExpression",{visitor:["expression","typeAnnotation"],aliases:["Flow","ExpressionWrapper","Expression"],fields:{}}),(0,i.default)("TypeParameter",{visitor:["bound"],aliases:["Flow"],fields:{}}),(0,i.default)("TypeParameterDeclaration",{visitor:["params"],aliases:["Flow"],fields:{}}),(0,i.default)("TypeParameterInstantiation",{visitor:["params"],aliases:["Flow"],fields:{}}),(0,i.default)("ObjectTypeAnnotation",{visitor:["properties","indexers","callProperties"],aliases:["Flow"],fields:{}}),(0,i.default)("ObjectTypeCallProperty",{visitor:["value"],aliases:["Flow","UserWhitespacable"],fields:{}}),(0,i.default)("ObjectTypeIndexer",{visitor:["id","key","value"],aliases:["Flow","UserWhitespacable"],fields:{}}),(0,i.default)("ObjectTypeProperty",{visitor:["key","value"],aliases:["Flow","UserWhitespacable"],fields:{}}),(0,i.default)("ObjectTypeSpreadProperty",{visitor:["argument"],aliases:["Flow","UserWhitespacable"],fields:{}}),(0,i.default)("QualifiedTypeIdentifier",{visitor:["id","qualification"],aliases:["Flow"],fields:{}}),(0,i.default)("UnionTypeAnnotation",{visitor:["types"],aliases:["Flow"],fields:{}}),(0,i.default)("VoidTypeAnnotation",{aliases:["Flow","FlowBaseAnnotation"],fields:{}})},function(e,t,r){"use strict";r(26),r(386),r(387),r(389),r(391),r(392),r(388)},function(e,t,r){"use strict";var n=r(26),i=function(e){return e&&e.__esModule?e:{default:e}}(n);(0,i.default)("JSXAttribute",{visitor:["name","value"],aliases:["JSX","Immutable"],fields:{name:{validate:(0,n.assertNodeType)("JSXIdentifier","JSXNamespacedName")},value:{optional:!0,validate:(0,n.assertNodeType)("JSXElement","StringLiteral","JSXExpressionContainer")}}}),(0,i.default)("JSXClosingElement",{visitor:["name"],aliases:["JSX","Immutable"],fields:{name:{validate:(0,n.assertNodeType)("JSXIdentifier","JSXMemberExpression")}}}),(0,i.default)("JSXElement",{builder:["openingElement","closingElement","children","selfClosing"],visitor:["openingElement","children","closingElement"],aliases:["JSX","Immutable","Expression"],fields:{openingElement:{validate:(0,n.assertNodeType)("JSXOpeningElement")},closingElement:{optional:!0,validate:(0,n.assertNodeType)("JSXClosingElement")},children:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement")))}}}),(0,i.default)("JSXEmptyExpression",{aliases:["JSX","Expression"]}),(0,i.default)("JSXExpressionContainer",{visitor:["expression"],aliases:["JSX","Immutable"],fields:{expression:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("JSXSpreadChild",{visitor:["expression"],aliases:["JSX","Immutable"],fields:{expression:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("JSXIdentifier",{builder:["name"],aliases:["JSX","Expression"],fields:{name:{validate:(0,n.assertValueType)("string")}}}),(0,i.default)("JSXMemberExpression",{visitor:["object","property"],aliases:["JSX","Expression"],fields:{object:{validate:(0,n.assertNodeType)("JSXMemberExpression","JSXIdentifier")},property:{validate:(0,n.assertNodeType)("JSXIdentifier")}}}),(0,i.default)("JSXNamespacedName",{visitor:["namespace","name"],aliases:["JSX"],fields:{namespace:{validate:(0,n.assertNodeType)("JSXIdentifier")},name:{validate:(0,n.assertNodeType)("JSXIdentifier")}}}),(0,i.default)("JSXOpeningElement",{builder:["name","attributes","selfClosing"],visitor:["name","attributes"],aliases:["JSX","Immutable"],fields:{name:{validate:(0,n.assertNodeType)("JSXIdentifier","JSXMemberExpression")},selfClosing:{default:!1,validate:(0,n.assertValueType)("boolean")},attributes:{validate:(0,n.chain)((0,n.assertValueType)("array"),(0,n.assertEach)((0,n.assertNodeType)("JSXAttribute","JSXSpreadAttribute")))}}}),(0,i.default)("JSXSpreadAttribute",{visitor:["argument"],aliases:["JSX"],fields:{argument:{validate:(0,n.assertNodeType)("Expression")}}}),(0,i.default)("JSXText",{aliases:["JSX","Immutable"],builder:["value"],fields:{value:{validate:(0,n.assertValueType)("string")}}})},function(e,t,r){"use strict";var n=r(26),i=function(e){return e&&e.__esModule?e:{default:e}}(n);(0,i.default)("Noop",{visitor:[]}),(0,i.default)("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0,n.assertNodeType)("Expression")}}})},function(e,t,r){"use strict";function n(e){var t=i(e);return 1===t.length?t[0]:o.unionTypeAnnotation(t)}function i(e){for(var t={},r={},n=[],s=[],a=0;a<e.length;a++){var u=e[a];if(u&&!(s.indexOf(u)>=0)){if(o.isAnyTypeAnnotation(u))return[u];if(o.isFlowBaseAnnotation(u))r[u.type]=u;else if(o.isUnionTypeAnnotation(u))n.indexOf(u.types)<0&&(e=e.concat(u.types),n.push(u.types));else if(o.isGenericTypeAnnotation(u)){var l=u.id.name;if(t[l]){var c=t[l];c.typeParameters?u.typeParameters&&(c.typeParameters.params=i(c.typeParameters.params.concat(u.typeParameters.params))):c=u.typeParameters}else t[l]=u}else s.push(u)}}for(var f in r)s.push(r[f]);for(var p in t)s.push(t[p]);return s}function s(e){if("string"===e)return o.stringTypeAnnotation();if("number"===e)return o.numberTypeAnnotation();if("undefined"===e)return o.voidTypeAnnotation();if("boolean"===e)return o.booleanTypeAnnotation();if("function"===e)return o.genericTypeAnnotation(o.identifier("Function"));if("object"===e)return o.genericTypeAnnotation(o.identifier("Object"));if("symbol"===e)return o.genericTypeAnnotation(o.identifier("Symbol"));throw new Error("Invalid typeof value")}t.__esModule=!0,t.createUnionTypeAnnotation=n,t.removeTypeDuplicates=i,t.createTypeAnnotationBasedOnTypeof=s;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a)},function(e,t,r){"use strict";function n(e){return!!e&&/^[a-z]|\-/.test(e)}function i(e,t){for(var r=e.value.split(/\r\n|\n|\r/),n=0,i=0;i<r.length;i++)r[i].match(/[^ \t]/)&&(n=i);for(var s="",a=0;a<r.length;a++){var u=r[a],l=0===a,c=a===r.length-1,f=a===n,p=u.replace(/\t/g," ");l||(p=p.replace(/^[ ]+/,"")),c||(p=p.replace(/[ ]+$/,"")),p&&(f||(p+=" "),s+=p)}s&&t.push(o.stringLiteral(s))}function s(e){for(var t=[],r=0;r<e.children.length;r++){var n=e.children[r];o.isJSXText(n)?i(n,t):(o.isJSXExpressionContainer(n)&&(n=n.expression),o.isJSXEmptyExpression(n)||t.push(n))}return t}t.__esModule=!0,t.isReactComponent=void 0,t.isCompatTag=n,t.buildChildren=s;var a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a);t.isReactComponent=o.buildMatchMemberExpression("React.Component")},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var r=E.getBindingIdentifiers.keys[t.type];if(r)for(var n=0;n<r.length;n++){var i=r[n],s=t[i];if(Array.isArray(s)){if(s.indexOf(e)>=0)return!0}else if(s===e)return!0}return!1}function s(e,t){switch(t.type){case"BindExpression":return t.object===e||t.callee===e;case"MemberExpression":case"JSXMemberExpression":return!(t.property!==e||!t.computed)||t.object===e;case"MetaProperty":return!1;case"ObjectProperty":if(t.key===e)return t.computed;case"VariableDeclarator":return t.id!==e;case"ArrowFunctionExpression":case"FunctionDeclaration":case"FunctionExpression":for(var r=t.params,n=Array.isArray(r),i=0,r=n?r:(0,b.default)(r);;){var s;if(n){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}if(s===e)return!1}return t.id!==e;case"ExportSpecifier":return!t.source&&t.local===e;case"ExportNamespaceSpecifier":case"ExportDefaultSpecifier":return!1;case"JSXAttribute":return t.name!==e;case"ClassProperty":return t.key===e?t.computed:t.value===e;case"ImportDefaultSpecifier":case"ImportNamespaceSpecifier":case"ImportSpecifier":return!1;case"ClassDeclaration":case"ClassExpression":return t.id!==e;case"ClassMethod":case"ObjectMethod":return t.key===e&&t.computed;case"LabeledStatement":return!1;case"CatchClause":return t.param!==e;case"RestElement":return!1;case"AssignmentExpression":case"AssignmentPattern":return t.right===e;case"ObjectPattern":case"ArrayPattern":return!1}return!0}function a(e){return"string"==typeof e&&!A.default.keyword.isReservedWordES6(e,!0)&&("await"!==e&&A.default.keyword.isIdentifierNameES6(e))}function o(e){return _.isVariableDeclaration(e)&&("var"!==e.kind||e[D.BLOCK_SCOPED_SYMBOL])}function u(e){return _.isFunctionDeclaration(e)||_.isClassDeclaration(e)||_.isLet(e)}function l(e){return _.isVariableDeclaration(e,{kind:"var"})&&!e[D.BLOCK_SCOPED_SYMBOL]}function c(e){return _.isImportDefaultSpecifier(e)||_.isIdentifier(e.imported||e.exported,{name:"default"})}function f(e,t){return(!_.isBlockStatement(e)||!_.isFunction(t,{body:e}))&&_.isScopable(e)}function p(e){return!!_.isType(e.type,"Immutable")||!!_.isIdentifier(e)&&"undefined"===e.name}function d(e,t){if("object"!==(void 0===e?"undefined":(0,v.default)(e))||"object"!==(void 0===e?"undefined":(0,v.default)(e))||null==e||null==t)return e===t;if(e.type!==t.type)return!1;for(var r=(0,m.default)(_.NODE_FIELDS[e.type]||e.type),n=r,i=Array.isArray(n),s=0,n=i?n:(0,b.default)(n);;){var a;if(i){if(s>=n.length)break;a=n[s++]}else{if(s=n.next(),s.done)break;a=s.value}var o=a;if((0,v.default)(e[o])!==(0,v.default)(t[o]))return!1;if(Array.isArray(e[o])){if(!Array.isArray(t[o]))return!1;if(e[o].length!==t[o].length)return!1;for(var u=0;u<e[o].length;u++)if(!d(e[o][u],t[o][u]))return!1}else if(!d(e[o],t[o]))return!1}return!0}t.__esModule=!0;var h=r(14),m=n(h),y=r(11),v=n(y),g=r(2),b=n(g);t.isBinding=i,t.isReferenced=s,t.isValidIdentifier=a,t.isLet=o,t.isBlockScoped=u,t.isVar=l,t.isSpecifierDefault=c,t.isScope=f,t.isImmutable=p,t.isNodesEquivalent=d;var E=r(226),x=r(97),A=n(x),S=r(1),_=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(S),D=r(135)},function(e,t){"use strict";function r(e,t,r){e instanceof RegExp&&(e=n(e,r)),t instanceof RegExp&&(t=n(t,r));var s=i(e,t,r);return s&&{start:s[0],end:s[1],pre:r.slice(0,s[0]),body:r.slice(s[0]+e.length,s[1]),post:r.slice(s[1]+t.length)}}function n(e,t){var r=t.match(e);return r?r[0]:null}function i(e,t,r){var n,i,s,a,o,u=r.indexOf(e),l=r.indexOf(t,u+1),c=u;if(u>=0&&l>0){for(n=[],s=r.length;c>=0&&!o;)c==u?(n.push(c),u=r.indexOf(e,c+1)):1==n.length?o=[n.pop(),l]:(i=n.pop(),i<s&&(s=i,a=l),l=r.indexOf(t,c+1)),c=u<l&&u>=0?u:l;n.length&&(o=[s,a])}return o}e.exports=r,r.range=i},function(e,t){"use strict";function r(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function n(e){return 3*e.length/4-r(e)}function i(e){var t,n,i,s,a,o=e.length;s=r(e),a=new c(3*o/4-s),n=s>0?o-4:o;var u=0;for(t=0;t<n;t+=4)i=l[e.charCodeAt(t)]<<18|l[e.charCodeAt(t+1)]<<12|l[e.charCodeAt(t+2)]<<6|l[e.charCodeAt(t+3)],a[u++]=i>>16&255,a[u++]=i>>8&255,a[u++]=255&i;return 2===s?(i=l[e.charCodeAt(t)]<<2|l[e.charCodeAt(t+1)]>>4,a[u++]=255&i):1===s&&(i=l[e.charCodeAt(t)]<<10|l[e.charCodeAt(t+1)]<<4|l[e.charCodeAt(t+2)]>>2,a[u++]=i>>8&255,a[u++]=255&i),a}function s(e){return u[e>>18&63]+u[e>>12&63]+u[e>>6&63]+u[63&e]}function a(e,t,r){for(var n,i=[],a=t;a<r;a+=3)n=(e[a]<<16)+(e[a+1]<<8)+e[a+2],i.push(s(n));return i.join("")}function o(e){for(var t,r=e.length,n=r%3,i="",s=[],o=0,l=r-n;o<l;o+=16383)s.push(a(e,o,o+16383>l?l:o+16383));return 1===n?(t=e[r-1],i+=u[t>>2],i+=u[t<<4&63],i+="=="):2===n&&(t=(e[r-2]<<8)+e[r-1],i+=u[t>>10],i+=u[t>>4&63],i+=u[t<<2&63],i+="="),s.push(i),s.join("")}t.byteLength=n,t.toByteArray=i,t.fromByteArray=o;for(var u=[],l=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=0,d=f.length;p<d;++p)u[p]=f[p],l[f.charCodeAt(p)]=p;l["-".charCodeAt(0)]=62,l["_".charCodeAt(0)]=63},function(e,t,r){"use strict";function n(e){return parseInt(e,10)==e?parseInt(e,10):e.charCodeAt(0)}function i(e){return e.split("\\\\").join(m).split("\\{").join(y).split("\\}").join(v).split("\\,").join(g).split("\\.").join(b)}function s(e){return e.split(m).join("\\").split(y).join("{").split(v).join("}").split(g).join(",").split(b).join(".")}function a(e){if(!e)return[""];var t=[],r=h("{","}",e);if(!r)return e.split(",");var n=r.pre,i=r.body,s=r.post,o=n.split(",");o[o.length-1]+="{"+i+"}";var u=a(s);return s.length&&(o[o.length-1]+=u.shift(),o.push.apply(o,u)),t.push.apply(t,o),t}function o(e){return e?("{}"===e.substr(0,2)&&(e="\\{\\}"+e.substr(2)),p(i(e),!0).map(s)):[]}function u(e){return"{"+e+"}"}function l(e){return/^-?0\d/.test(e)}function c(e,t){return e<=t}function f(e,t){return e>=t}function p(e,t){var r=[],i=h("{","}",e);if(!i||/\$$/.test(i.pre))return[e];var s=/^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(i.body),o=/^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(i.body),m=s||o,y=i.body.indexOf(",")>=0;if(!m&&!y)return i.post.match(/,.*\}/)?(e=i.pre+"{"+i.body+v+i.post,p(e)):[e];var g;if(m)g=i.body.split(/\.\./);else if(g=a(i.body),1===g.length&&(g=p(g[0],!1).map(u),1===g.length)){var b=i.post.length?p(i.post,!1):[""];return b.map(function(e){return i.pre+g[0]+e})}var E,x=i.pre,b=i.post.length?p(i.post,!1):[""];if(m){var A=n(g[0]),S=n(g[1]),_=Math.max(g[0].length,g[1].length),D=3==g.length?Math.abs(n(g[2])):1,C=c;S<A&&(D*=-1,C=f);var w=g.some(l);E=[];for(var P=A;C(P,S);P+=D){var k;if(o)"\\"===(k=String.fromCharCode(P))&&(k="");else if(k=String(P),w){var F=_-k.length;if(F>0){var T=new Array(F+1).join("0");k=P<0?"-"+T+k.slice(1):T+k}}E.push(k)}}else E=d(g,function(e){return p(e,!1)});for(var O=0;O<E.length;O++)for(var B=0;B<b.length;B++){var R=x+E[O]+b[B];(!t||m||R)&&r.push(R)}return r}var d=r(402),h=r(396);e.exports=o;var m="\0SLASH"+Math.random()+"\0",y="\0OPEN"+Math.random()+"\0",v="\0CLOSE"+Math.random()+"\0",g="\0COMMA"+Math.random()+"\0",b="\0PERIOD"+Math.random()+"\0"},function(e,t,r){(function(e){"use strict";function n(){return s.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function i(e,t){if(n()<t)throw new RangeError("Invalid typed array length");return s.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t),e.__proto__=s.prototype):(null===e&&(e=new s(t)),e.length=t),e}function s(e,t,r){if(!(s.TYPED_ARRAY_SUPPORT||this instanceof s))return new s(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return l(this,e)}return a(this,e,t,r)}function a(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number')
;return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?p(e,t,r,n):"string"==typeof t?c(e,t,r):d(e,t)}function o(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function u(e,t,r,n){return o(t),t<=0?i(e,t):void 0!==r?"string"==typeof n?i(e,t).fill(r,n):i(e,t).fill(r):i(e,t)}function l(e,t){if(o(t),e=i(e,t<0?0:0|h(t)),!s.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function c(e,t,r){if("string"==typeof r&&""!==r||(r="utf8"),!s.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|y(t,r);e=i(e,n);var a=e.write(t,r);return a!==n&&(e=e.slice(0,a)),e}function f(e,t){var r=t.length<0?0:0|h(t.length);e=i(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function p(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");return t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n),s.TYPED_ARRAY_SUPPORT?(e=t,e.__proto__=s.prototype):e=f(e,t),e}function d(e,t){if(s.isBuffer(t)){var r=0|h(t.length);return e=i(e,r),0===e.length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||X(t.length)?i(e,0):f(e,t);if("Buffer"===t.type&&Q(t.data))return f(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function h(e){if(e>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|e}function m(e){return+e!=e&&(e=0),s.alloc(+e)}function y(e,t){if(s.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return Y(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return H(e).length;default:if(n)return Y(e).length;t=(""+t).toLowerCase(),n=!0}}function v(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if(r>>>=0,t>>>=0,r<=t)return"";for(e||(e="utf8");;)switch(e){case"hex":return O(this,t,r);case"utf8":case"utf-8":return P(this,t,r);case"ascii":return F(this,t,r);case"latin1":case"binary":return T(this,t,r);case"base64":return w(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function g(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function b(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=s.from(t,n)),s.isBuffer(t))return 0===t.length?-1:E(e,t,r,n,i);if("number"==typeof t)return t&=255,s.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):E(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function E(e,t,r,n,i){function s(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,o=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,o/=2,u/=2,r/=2}var l;if(i){var c=-1;for(l=r;l<o;l++)if(s(e,l)===s(t,-1===c?0:l-c)){if(-1===c&&(c=l),l-c+1===u)return c*a}else-1!==c&&(l-=l-c),c=-1}else for(r+u>o&&(r=o-u),l=r;l>=0;l--){for(var f=!0,p=0;p<u;p++)if(s(e,l+p)!==s(t,p)){f=!1;break}if(f)return l}return-1}function x(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var s=t.length;if(s%2!=0)throw new TypeError("Invalid hex string");n>s/2&&(n=s/2);for(var a=0;a<n;++a){var o=parseInt(t.substr(2*a,2),16);if(isNaN(o))return a;e[r+a]=o}return a}function A(e,t,r,n){return J(Y(t,e.length-r),e,r,n)}function S(e,t,r,n){return J(q(t),e,r,n)}function _(e,t,r,n){return S(e,t,r,n)}function D(e,t,r,n){return J(H(t),e,r,n)}function C(e,t,r,n){return J(K(t,e.length-r),e,r,n)}function w(e,t,r){return 0===t&&r===e.length?z.fromByteArray(e):z.fromByteArray(e.slice(t,r))}function P(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var s=e[i],a=null,o=s>239?4:s>223?3:s>191?2:1;if(i+o<=r){var u,l,c,f;switch(o){case 1:s<128&&(a=s);break;case 2:u=e[i+1],128==(192&u)&&(f=(31&s)<<6|63&u)>127&&(a=f);break;case 3:u=e[i+1],l=e[i+2],128==(192&u)&&128==(192&l)&&(f=(15&s)<<12|(63&u)<<6|63&l)>2047&&(f<55296||f>57343)&&(a=f);break;case 4:u=e[i+1],l=e[i+2],c=e[i+3],128==(192&u)&&128==(192&l)&&128==(192&c)&&(f=(15&s)<<18|(63&u)<<12|(63&l)<<6|63&c)>65535&&f<1114112&&(a=f)}}null===a?(a=65533,o=1):a>65535&&(a-=65536,n.push(a>>>10&1023|55296),a=56320|1023&a),n.push(a),i+=o}return k(n)}function k(e){var t=e.length;if(t<=Z)return String.fromCharCode.apply(String,e);for(var r="",n=0;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=Z));return r}function F(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function T(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function O(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",s=t;s<r;++s)i+=W(e[s]);return i}function B(e,t,r){for(var n=e.slice(t,r),i="",s=0;s<n.length;s+=2)i+=String.fromCharCode(n[s]+256*n[s+1]);return i}function R(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function I(e,t,r,n,i,a){if(!s.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<a)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function M(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,s=Math.min(e.length-r,2);i<s;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function N(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,s=Math.min(e.length-r,4);i<s;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function L(e,t,r,n,i,s){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function j(e,t,r,n,i){return i||L(e,t,r,4,3.4028234663852886e38,-3.4028234663852886e38),$.write(e,t,r,n,23,4),r+4}function U(e,t,r,n,i){return i||L(e,t,r,8,1.7976931348623157e308,-1.7976931348623157e308),$.write(e,t,r,n,52,8),r+8}function V(e){if(e=G(e).replace(ee,""),e.length<2)return"";for(;e.length%4!=0;)e+="=";return e}function G(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}function W(e){return e<16?"0"+e.toString(16):e.toString(16)}function Y(e,t){t=t||1/0;for(var r,n=e.length,i=null,s=[],a=0;a<n;++a){if((r=e.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&s.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&s.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&s.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&s.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;s.push(r)}else if(r<2048){if((t-=2)<0)break;s.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;s.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;s.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return s}function q(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function K(e,t){for(var r,n,i,s=[],a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,i=r%256,s.push(i),s.push(n);return s}function H(e){return z.toByteArray(V(e))}function J(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function X(e){return e!==e}var z=r(397),$=r(465),Q=r(400);t.Buffer=s,t.SlowBuffer=m,t.INSPECT_MAX_BYTES=50,s.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=n(),s.poolSize=8192,s._augment=function(e){return e.__proto__=s.prototype,e},s.from=function(e,t,r){return a(null,e,t,r)},s.TYPED_ARRAY_SUPPORT&&(s.prototype.__proto__=Uint8Array.prototype,s.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&s[Symbol.species]===s&&Object.defineProperty(s,Symbol.species,{value:null,configurable:!0})),s.alloc=function(e,t,r){return u(null,e,t,r)},s.allocUnsafe=function(e){return l(null,e)},s.allocUnsafeSlow=function(e){return l(null,e)},s.isBuffer=function(e){return!(null==e||!e._isBuffer)},s.compare=function(e,t){if(!s.isBuffer(e)||!s.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,a=Math.min(r,n);i<a;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},s.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},s.concat=function(e,t){if(!Q(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return s.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=s.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var a=e[r];if(!s.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(n,i),i+=a.length}return n},s.byteLength=y,s.prototype._isBuffer=!0,s.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)g(this,t,t+1);return this},s.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},s.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},s.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?P(this,0,e):v.apply(this,arguments)},s.prototype.equals=function(e){if(!s.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===s.compare(this,e)},s.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},s.prototype.compare=function(e,t,r,n,i){if(!s.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;for(var a=i-n,o=r-t,u=Math.min(a,o),l=this.slice(n,i),c=e.slice(t,r),f=0;f<u;++f)if(l[f]!==c[f]){a=l[f],o=c[f];break}return a<o?-1:o<a?1:0},s.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},s.prototype.indexOf=function(e,t,r){return b(this,e,t,r,!0)},s.prototype.lastIndexOf=function(e,t,r){return b(this,e,t,r,!1)},s.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var s=!1;;)switch(n){case"hex":return x(this,e,t,r);case"utf8":case"utf-8":return A(this,e,t,r);case"ascii":return S(this,e,t,r);case"latin1":case"binary":return _(this,e,t,r);case"base64":return D(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,e,t,r);default:if(s)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),s=!0}},s.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var Z=4096;s.prototype.slice=function(e,t){var r=this.length;e=~~e,t=void 0===t?r:~~t,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),t<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);var n;if(s.TYPED_ARRAY_SUPPORT)n=this.subarray(e,t),n.__proto__=s.prototype;else{var i=t-e;n=new s(i,void 0);for(var a=0;a<i;++a)n[a]=this[a+e]}return n},s.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var n=this[e],i=1,s=0;++s<t&&(i*=256);)n+=this[e+s]*i;return n},s.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},s.prototype.readUInt8=function(e,t){return t||R(e,1,this.length),this[e]},s.prototype.readUInt16LE=function(e,t){return t||R(e,2,this.length),this[e]|this[e+1]<<8},s.prototype.readUInt16BE=function(e,t){return t||R(e,2,this.length),this[e]<<8|this[e+1]},s.prototype.readUInt32LE=function(e,t){return t||R(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},s.prototype.readUInt32BE=function(e,t){return t||R(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},s.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var n=this[e],i=1,s=0;++s<t&&(i*=256);)n+=this[e+s]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n},s.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var n=t,i=1,s=this[e+--n];n>0&&(i*=256);)s+=this[e+--n]*i;return i*=128,s>=i&&(s-=Math.pow(2,8*t)),s},s.prototype.readInt8=function(e,t){return t||R(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},s.prototype.readInt16LE=function(e,t){t||R(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt16BE=function(e,t){t||R(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt32LE=function(e,t){return t||R(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},s.prototype.readInt32BE=function(e,t){return t||R(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},s.prototype.readFloatLE=function(e,t){return t||R(e,4,this.length),$.read(this,e,!0,23,4)},s.prototype.readFloatBE=function(e,t){return t||R(e,4,this.length),$.read(this,e,!1,23,4)},s.prototype.readDoubleLE=function(e,t){return t||R(e,8,this.length),$.read(this,e,!0,52,8)},s.prototype.readDoubleBE=function(e,t){return t||R(e,8,this.length),$.read(this,e,!1,52,8)},s.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t|=0,r|=0,!n){I(this,e,t,r,Math.pow(2,8*r)-1,0)}var i=1,s=0;for(this[t]=255&e;++s<r&&(i*=256);)this[t+s]=e/i&255;return t+r},s.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t|=0,r|=0,!n){I(this,e,t,r,Math.pow(2,8*r)-1,0)}var i=r-1,s=1;for(this[t+i]=255&e;--i>=0&&(s*=256);)this[t+i]=e/s&255;return t+r},s.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,1,255,0),s.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},s.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,2,65535,0),s.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):M(this,e,t,!0),t+2},s.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,2,65535,0),s.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):M(this,e,t,!1),t+2},s.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,4,4294967295,0),s.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):N(this,e,t,!0),t+4},s.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,4,4294967295,0),s.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):N(this,e,t,!1),t+4},s.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);I(this,e,t,r,i-1,-i)}var s=0,a=1,o=0;for(this[t]=255&e;++s<r&&(a*=256);)e<0&&0===o&&0!==this[t+s-1]&&(o=1),this[t+s]=(e/a>>0)-o&255;return t+r},s.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);I(this,e,t,r,i-1,-i)}var s=r-1,a=1,o=0;for(this[t+s]=255&e;--s>=0&&(a*=256);)e<0&&0===o&&0!==this[t+s+1]&&(o=1),this[t+s]=(e/a>>0)-o&255;return t+r},s.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,1,127,-128),s.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},s.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,2,32767,-32768),s.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):M(this,e,t,!0),t+2},s.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,2,32767,-32768),s.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):M(this,e,t,!1),t+2},s.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,4,2147483647,-2147483648),s.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):N(this,e,t,!0),t+4},s.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||I(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),s.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):N(this,e,t,!1),t+4},s.prototype.writeFloatLE=function(e,t,r){return j(this,e,t,!0,r)},s.prototype.writeFloatBE=function(e,t,r){return j(this,e,t,!1,r)},s.prototype.writeDoubleLE=function(e,t,r){return U(this,e,t,!0,r)},s.prototype.writeDoubleBE=function(e,t,r){return U(this,e,t,!1,r)},s.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,a=n-r;if(this===e&&r<t&&t<n)for(i=a-1;i>=0;--i)e[i+t]=this[i+r];else if(a<1e3||!s.TYPED_ARRAY_SUPPORT)for(i=0;i<a;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+a),t);return a},s.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!s.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0);var a;if("number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var o=s.isBuffer(e)?e:Y(new s(e,n).toString()),u=o.length;for(a=0;a<r-t;++a)this[a+t]=o[a%u]}return this};var ee=/[^+\/0-9A-Za-z-_]/g}).call(t,function(){return this}())},function(e,t){"use strict";var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){(function(t){"use strict";function n(e){this.enabled=e&&void 0!==e.enabled?e.enabled:c}function i(e){var t=function e(){return s.apply(e,arguments)};return t._styles=e,t.enabled=this.enabled,t.__proto__=h,t}function s(){var e=arguments,t=e.length,r=0!==t&&String(arguments[0]);if(t>1)for(var n=1;n<t;n++)r+=" "+e[n];if(!this.enabled||!r)return r;var i=this._styles,s=i.length,a=o.dim.open;for(!p||-1===i.indexOf("gray")&&-1===i.indexOf("grey")||(o.dim.open="");s--;){var u=o[i[s]];r=u.open+r.replace(u.closeRe,u.open)+u.close}return o.dim.open=a,r}var a=r(460),o=r(289),u=r(622),l=r(464),c=r(623),f=Object.defineProperties,p="win32"===t.platform&&!/^xterm/i.test(t.env.TERM);p&&(o.blue.open="[94m");var d=function(){var e={};return Object.keys(o).forEach(function(t){o[t].closeRe=new RegExp(a(o[t].close),"g"),e[t]={get:function(){return i.call(this,this._styles.concat(t))}}}),e}(),h=f(function(){},d);f(n.prototype,function(){var e={};return Object.keys(d).forEach(function(t){e[t]={get:function(){return i.call(this,[t])}}}),e}()),e.exports=new n,e.exports.styles=o,e.exports.hasColor=l,e.exports.stripColor=u,e.exports.supportsColor=c}).call(t,r(8))},function(e,t){"use strict";e.exports=function(e,t){for(var n=[],i=0;i<e.length;i++){var s=t(e[i],i);r(s)?n.push.apply(n,s):n.push(s)}return n};var r=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,r){(function(e){"use strict";function n(t){return new e(t,"base64").toString()}function i(e){return e.split(",").pop()}function s(e,r){var n=t.mapFileCommentRegex.exec(e),i=n[1]||n[2],s=u.resolve(r,i);try{return o.readFileSync(s,"utf8")}catch(e){throw new Error("An error occurred while trying to read the map file at "+s+"\n"+e)}}function a(e,t){t=t||{},t.isFileComment&&(e=s(e,t.commentFileDir)),t.hasComment&&(e=i(e)),t.isEncoded&&(e=n(e)),(t.isJSON||t.isEncoded)&&(e=JSON.parse(e)),this.sourcemap=e}var o=r(115),u=r(19);Object.defineProperty(t,"commentRegex",{get:function(){return/^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm}}),Object.defineProperty(t,"mapFileCommentRegex",{get:function(){return/(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm}}),a.prototype.toJSON=function(e){return JSON.stringify(this.sourcemap,null,e)},a.prototype.toBase64=function(){var t=this.toJSON();return new e(t).toString("base64")},a.prototype.toComment=function(e){var t=this.toBase64(),r="sourceMappingURL=data:application/json;charset=utf-8;base64,"+t;return e&&e.multiline?"/*# "+r+" */":"//# "+r},a.prototype.toObject=function(){return JSON.parse(this.toJSON())},a.prototype.addProperty=function(e,t){if(this.sourcemap.hasOwnProperty(e))throw new Error("property %s already exists on the sourcemap, use set property instead");return this.setProperty(e,t)},a.prototype.setProperty=function(e,t){return this.sourcemap[e]=t,this},a.prototype.getProperty=function(e){return this.sourcemap[e]},t.fromObject=function(e){return new a(e)},t.fromJSON=function(e){return new a(e,{isJSON:!0})},t.fromBase64=function(e){return new a(e,{isEncoded:!0})},t.fromComment=function(e){return e=e.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),new a(e,{isEncoded:!0,hasComment:!0})},t.fromMapFileComment=function(e,t){return new a(e,{commentFileDir:t,isFileComment:!0,isJSON:!0})},t.fromSource=function(e){var r=e.match(t.commentRegex);return r?t.fromComment(r.pop()):null},t.fromMapFileSource=function(e,r){var n=e.match(t.mapFileCommentRegex);return n?t.fromMapFileComment(n.pop(),r):null},t.removeComments=function(e){return e.replace(t.commentRegex,"")},t.removeMapFileComments=function(e){return e.replace(t.mapFileCommentRegex,"")},t.generateMapFileComment=function(e,t){var r="sourceMappingURL="+e;return t&&t.multiline?"/*# "+r+" */":"//# "+r}}).call(t,r(399).Buffer)},function(e,t,r){"use strict";r(59),r(157),e.exports=r(439)},function(e,t,r){"use strict";var n=r(5),i=n.JSON||(n.JSON={stringify:JSON.stringify});e.exports=function(e){return i.stringify.apply(i,arguments)}},function(e,t,r){"use strict";r(96),r(157),r(59),r(441),r(451),r(450),r(449),e.exports=r(5).Map},function(e,t,r){"use strict";r(442),e.exports=9007199254740991},function(e,t,r){"use strict";r(443),e.exports=r(5).Object.assign},function(e,t,r){"use strict";r(444);var n=r(5).Object;e.exports=function(e,t){return n.create(e,t)}},function(e,t,r){"use strict";r(158),e.exports=r(5).Object.getOwnPropertySymbols},function(e,t,r){"use strict";r(445),e.exports=r(5).Object.keys},function(e,t,r){"use strict";r(446),e.exports=r(5).Object.setPrototypeOf},function(e,t,r){"use strict";r(158),e.exports=r(5).Symbol.for},function(e,t,r){"use strict";r(158),r(96),r(452),r(453),e.exports=r(5).Symbol},function(e,t,r){"use strict";r(157),r(59),e.exports=r(156).f("iterator")},function(e,t,r){"use strict";r(96),r(59),r(447),r(455),r(454),e.exports=r(5).WeakMap},function(e,t,r){"use strict";r(96),r(59),r(448),r(457),r(456),e.exports=r(5).WeakSet},function(e,t){"use strict";e.exports=function(){}},function(e,t,r){"use strict";var n=r(55);e.exports=function(e,t){var r=[];return n(e,!1,r.push,r,t),r}},function(e,t,r){"use strict";var n=r(37),i=r(153),s=r(438);e.exports=function(e){return function(t,r,a){var o,u=n(t),l=i(u.length),c=s(a,l);if(e&&r!=r){for(;l>c;)if((o=u[c++])!=o)return!0}else for(;l>c;c++)if((e||c in u)&&u[c]===r)return e||c||0;return!e&&-1}}},function(e,t,r){"use strict";var n=r(16),i=r(232),s=r(13)("species");e.exports=function(e){var t;return i(e)&&(t=e.constructor,"function"!=typeof t||t!==Array&&!i(t.prototype)||(t=void 0),n(t)&&null===(t=t[s])&&(t=void 0)),void 0===t?Array:t}},function(e,t,r){"use strict";var n=r(421);e.exports=function(e,t){return new(n(e))(t)}},function(e,t,r){"use strict";var n=r(23).f,i=r(90),s=r(146),a=r(43),o=r(136),u=r(55),l=r(143),c=r(233),f=r(436),p=r(22),d=r(57).fastKey,h=r(58),m=p?"_s":"size",y=function(e,t){var r,n=d(t);if("F"!==n)return e._i[n];for(r=e._f;r;r=r.n)if(r.k==t)return r};e.exports={getConstructor:function(e,t,r,l){var c=e(function(e,n){o(e,c,t,"_i"),e._t=t,e._i=i(null),e._f=void 0,e._l=void 0,e[m]=0,void 0!=n&&u(n,r,e[l],e)});return s(c.prototype,{clear:function(){for(var e=h(this,t),r=e._i,n=e._f;n;n=n.n)n.r=!0,n.p&&(n.p=n.p.n=void 0),delete r[n.i];e._f=e._l=void 0,e[m]=0},delete:function(e){var r=h(this,t),n=y(r,e);if(n){var i=n.n,s=n.p;delete r._i[n.i],n.r=!0,s&&(s.n=i),i&&(i.p=s),r._f==n&&(r._f=i),r._l==n&&(r._l=s),r[m]--}return!!n},forEach:function(e){h(this,t);for(var r,n=a(e,arguments.length>1?arguments[1]:void 0,3);r=r?r.n:this._f;)for(n(r.v,r.k,this);r&&r.r;)r=r.p},has:function(e){return!!y(h(this,t),e)}}),p&&n(c.prototype,"size",{get:function(){return h(this,t)[m]}}),c},def:function(e,t,r){var n,i,s=y(e,t);return s?s.v=r:(e._l=s={i:i=d(t,!0),k:t,v:r,p:n=e._l,n:void 0,r:!1},e._f||(e._f=s),n&&(n.n=s),e[m]++,"F"!==i&&(e._i[i]=s)),e},getEntry:y,setStrong:function(e,t,r){l(e,t,function(e,r){this._t=h(e,t),this._k=r,this._l=void 0},function(){for(var e=this,t=e._k,r=e._l;r&&r.r;)r=r.p;return e._t&&(e._l=r=r?r.n:e._t._f)?"keys"==t?c(0,r.k):"values"==t?c(0,r.v):c(0,[r.k,r.v]):(e._t=void 0,c(1))},r?"entries":"values",!r,!0),f(t)}}},function(e,t,r){"use strict";var n=r(228),i=r(419);e.exports=function(e){return function(){if(n(this)!=e)throw TypeError(e+"#toJSON isn't generic");return i(this)}}},function(e,t,r){"use strict";var n=r(44),i=r(145),s=r(91);e.exports=function(e){var t=n(e),r=i.f;if(r)for(var a,o=r(e),u=s.f,l=0;o.length>l;)u.call(e,a=o[l++])&&t.push(a);return t}},function(e,t,r){"use strict";var n=r(15).document;e.exports=n&&n.documentElement},function(e,t,r){"use strict";var n=r(56),i=r(13)("iterator"),s=Array.prototype;e.exports=function(e){return void 0!==e&&(n.Array===e||s[i]===e)}},function(e,t,r){"use strict";var n=r(21);e.exports=function(e,t,r,i){try{return i?t(n(r)[0],r[1]):t(r)}catch(t){var s=e.return;throw void 0!==s&&n(s.call(e)),t}}},function(e,t,r){"use strict";var n=r(90),i=r(92),s=r(93),a={};r(29)(a,r(13)("iterator"),function(){return this}),e.exports=function(e,t,r){e.prototype=n(a,{next:i(1,r)}),s(e,t+" Iterator")}},function(e,t,r){"use strict";var n=r(44),i=r(37);e.exports=function(e,t){for(var r,s=i(e),a=n(s),o=a.length,u=0;o>u;)if(s[r=a[u++]]===t)return r}},function(e,t,r){"use strict";var n=r(23),i=r(21),s=r(44);e.exports=r(22)?Object.defineProperties:function(e,t){i(e);for(var r,a=s(t),o=a.length,u=0;o>u;)n.f(e,r=a[u++],t[r]);return e}},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(37),s=r(236).f,a={}.toString,o="object"==("undefined"==typeof window?"undefined":n(window))&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],u=function(e){try{return s(e)}catch(e){return o.slice()}};e.exports.f=function(e){return o&&"[object Window]"==a.call(e)?u(e):s(i(e))}},function(e,t,r){"use strict";var n=r(28),i=r(94),s=r(150)("IE_PROTO"),a=Object.prototype;e.exports=Object.getPrototypeOf||function(e){return e=i(e),n(e,s)?e[s]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?a:null}},function(e,t,r){"use strict";var n=r(12),i=r(5),s=r(27);e.exports=function(e,t){var r=(i.Object||{})[e]||Object[e],a={};a[e]=t(r),n(n.S+n.F*s(function(){r(1)}),"Object",a)}},function(e,t,r){"use strict";var n=r(16),i=r(21),s=function(e,t){if(i(e),!n(t)&&null!==t)throw TypeError(t+": can't set as prototype!")};e.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(e,t,n){try{n=r(43)(Function.call,r(235).f(Object.prototype,"__proto__").set,2),n(e,[]),t=!(e instanceof Array)}catch(e){t=!0}return function(e,r){return s(e,r),t?e.__proto__=r:n(e,r),e}}({},!1):void 0),check:s}},function(e,t,r){"use strict";var n=r(15),i=r(5),s=r(23),a=r(22),o=r(13)("species");e.exports=function(e){var t="function"==typeof i[e]?i[e]:n[e];a&&t&&!t[o]&&s.f(t,o,{configurable:!0,get:function(){return this}})}},function(e,t,r){"use strict";var n=r(152),i=r(140);e.exports=function(e){return function(t,r){var s,a,o=String(i(t)),u=n(r),l=o.length;return u<0||u>=l?e?"":void 0:(s=o.charCodeAt(u),s<55296||s>56319||u+1===l||(a=o.charCodeAt(u+1))<56320||a>57343?e?o.charAt(u):s:e?o.slice(u,u+2):a-56320+(s-55296<<10)+65536)}}},function(e,t,r){"use strict";var n=r(152),i=Math.max,s=Math.min;e.exports=function(e,t){return e=n(e),e<0?i(e+t,0):s(e,t)}},function(e,t,r){"use strict";var n=r(21),i=r(238);e.exports=r(5).getIterator=function(e){var t=i(e);if("function"!=typeof t)throw TypeError(e+" is not iterable!");return n(t.call(e))}},function(e,t,r){"use strict";var n=r(418),i=r(233),s=r(56),a=r(37);e.exports=r(143)(Array,"Array",function(e,t){this._t=a(e),this._i=0,this._k=t},function(){var e=this._t,t=this._k,r=this._i++;return!e||r>=e.length?(this._t=void 0,i(1)):"keys"==t?i(0,r):"values"==t?i(0,e[r]):i(0,[r,e[r]])},"values"),s.Arguments=s.Array,n("keys"),n("values"),n("entries")},function(e,t,r){"use strict";var n=r(423),i=r(58);e.exports=r(139)("Map",function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},{get:function(e){var t=n.getEntry(i(this,"Map"),e);return t&&t.v},set:function(e,t){return n.def(i(this,"Map"),0===e?0:e,t)}},n,!0)},function(e,t,r){"use strict";var n=r(12);n(n.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(e,t,r){"use strict";var n=r(12);n(n.S+n.F,"Object",{assign:r(234)})},function(e,t,r){"use strict";var n=r(12);n(n.S,"Object",{create:r(90)})},function(e,t,r){"use strict";var n=r(94),i=r(44);r(434)("keys",function(){return function(e){return i(n(e))}})},function(e,t,r){"use strict";var n=r(12);n(n.S,"Object",{setPrototypeOf:r(435).set})},function(e,t,r){"use strict";var n,i=r(137)(0),s=r(147),a=r(57),o=r(234),u=r(229),l=r(16),c=r(27),f=r(58),p=a.getWeak,d=Object.isExtensible,h=u.ufstore,m={},y=function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},v={get:function(e){if(l(e)){var t=p(e);return!0===t?h(f(this,"WeakMap")).get(e):t?t[this._i]:void 0}},set:function(e,t){return u.def(f(this,"WeakMap"),e,t)}},g=e.exports=r(139)("WeakMap",y,v,u,!0,!0);c(function(){return 7!=(new g).set((Object.freeze||Object)(m),7).get(m)})&&(n=u.getConstructor(y,"WeakMap"),o(n.prototype,v),a.NEED=!0,i(["delete","has","get","set"],function(e){var t=g.prototype,r=t[e];s(t,e,function(t,i){if(l(t)&&!d(t)){this._f||(this._f=new n);var s=this._f[e](t,i);return"set"==e?this:s}return r.call(this,t,i)})}))},function(e,t,r){"use strict"
;var n=r(229),i=r(58);r(139)("WeakSet",function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},{add:function(e){return n.def(i(this,"WeakSet"),e,!0)}},n,!1,!0)},function(e,t,r){"use strict";r(148)("Map")},function(e,t,r){"use strict";r(149)("Map")},function(e,t,r){"use strict";var n=r(12);n(n.P+n.R,"Map",{toJSON:r(424)("Map")})},function(e,t,r){"use strict";r(155)("asyncIterator")},function(e,t,r){"use strict";r(155)("observable")},function(e,t,r){"use strict";r(148)("WeakMap")},function(e,t,r){"use strict";r(149)("WeakMap")},function(e,t,r){"use strict";r(148)("WeakSet")},function(e,t,r){"use strict";r(149)("WeakSet")},function(e,t,r){"use strict";function n(e){var r,n=0;for(r in e)n=(n<<5)-n+e.charCodeAt(r),n|=0;return t.colors[Math.abs(n)%t.colors.length]}function i(e){function r(){if(r.enabled){var e=r,n=+new Date,i=n-(l||n);e.diff=i,e.prev=l,e.curr=n,l=n;for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=t.coerce(s[0]),"string"!=typeof s[0]&&s.unshift("%O");var o=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(r,n){if("%%"===r)return r;o++;var i=t.formatters[n];if("function"==typeof i){var a=s[o];r=i.call(e,a),s.splice(o,1),o--}return r}),t.formatArgs.call(e,s);(r.log||t.log||console.log.bind(console)).apply(e,s)}}return r.namespace=e,r.enabled=t.enabled(e),r.useColors=t.useColors(),r.color=n(e),"function"==typeof t.init&&t.init(r),r}function s(e){t.save(e),t.names=[],t.skips=[];for(var r=("string"==typeof e?e:"").split(/[\s,]+/),n=r.length,i=0;i<n;i++)r[i]&&(e=r[i].replace(/\*/g,".*?"),"-"===e[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")))}function a(){t.enable("")}function o(e){var r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return!1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return!0;return!1}function u(e){return e instanceof Error?e.stack||e.message:e}t=e.exports=i.debug=i.default=i,t.coerce=u,t.disable=a,t.enable=s,t.enabled=o,t.humanize=r(602),t.names=[],t.skips=[],t.formatters={};var l},function(e,t,r){"use strict";function n(e){var t=0,r=0,n=0;for(var i in e){var s=e[i],a=s[0],o=s[1];(a>r||a===r&&o>n)&&(r=a,n=o,t=Number(i))}return t}var i=r(615),s=/^(?:( )+|\t+)/;e.exports=function(e){if("string"!=typeof e)throw new TypeError("Expected a string");var t,r,a=0,o=0,u=0,l={};e.split(/\n/g).forEach(function(e){if(e){var n,i=e.match(s);i?(n=i[0].length,i[1]?o++:a++):n=0;var c=n-u;u=n,c?(r=c>0,t=l[r?c:-c],t?t[0]++:t=l[c]=[1,0]):t&&(t[1]+=Number(r))}});var c,f,p=n(l);return p?o>=a?(c="space",f=i(" ",p)):(c="tab",f=i("\t",p)):(c=null,f=""),{amount:p,type:c,indent:f}}},function(e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.exports=function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(r,"\\$&")}},function(e,t){"use strict";!function(){function t(e){if(null==e)return!1;switch(e.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return!0}return!1}function r(e){if(null==e)return!1;switch(e.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return!0}return!1}function n(e){if(null==e)return!1;switch(e.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return!0}return!1}function i(e){return n(e)||null!=e&&"FunctionDeclaration"===e.type}function s(e){switch(e.type){case"IfStatement":return null!=e.alternate?e.alternate:e.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return e.body}return null}function a(e){var t;if("IfStatement"!==e.type)return!1;if(null==e.alternate)return!1;t=e.consequent;do{if("IfStatement"===t.type&&null==t.alternate)return!0;t=s(t)}while(t);return!1}e.exports={isExpression:t,isStatement:n,isIterationStatement:r,isSourceElement:i,isProblematicIfStatement:a,trailingStatement:s}}()},function(e,t,r){"use strict";!function(){function t(e){switch(e){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return!0;default:return!1}}function n(e,t){return!(!t&&"yield"===e)&&i(e,t)}function i(e,r){if(r&&t(e))return!0;switch(e.length){case 2:return"if"===e||"in"===e||"do"===e;case 3:return"var"===e||"for"===e||"new"===e||"try"===e;case 4:return"this"===e||"else"===e||"case"===e||"void"===e||"with"===e||"enum"===e;case 5:return"while"===e||"break"===e||"catch"===e||"throw"===e||"const"===e||"yield"===e||"class"===e||"super"===e;case 6:return"return"===e||"typeof"===e||"delete"===e||"switch"===e||"export"===e||"import"===e;case 7:return"default"===e||"finally"===e||"extends"===e;case 8:return"function"===e||"continue"===e||"debugger"===e;case 10:return"instanceof"===e;default:return!1}}function s(e,t){return"null"===e||"true"===e||"false"===e||n(e,t)}function a(e,t){return"null"===e||"true"===e||"false"===e||i(e,t)}function o(e){return"eval"===e||"arguments"===e}function u(e){var t,r,n;if(0===e.length)return!1;if(n=e.charCodeAt(0),!d.isIdentifierStartES5(n))return!1;for(t=1,r=e.length;t<r;++t)if(n=e.charCodeAt(t),!d.isIdentifierPartES5(n))return!1;return!0}function l(e,t){return 1024*(e-55296)+(t-56320)+65536}function c(e){var t,r,n,i,s;if(0===e.length)return!1;for(s=d.isIdentifierStartES6,t=0,r=e.length;t<r;++t){if(55296<=(n=e.charCodeAt(t))&&n<=56319){if(++t>=r)return!1;if(!(56320<=(i=e.charCodeAt(t))&&i<=57343))return!1;n=l(n,i)}if(!s(n))return!1;s=d.isIdentifierPartES6}return!0}function f(e,t){return u(e)&&!s(e,t)}function p(e,t){return c(e)&&!a(e,t)}var d=r(240);e.exports={isKeywordES5:n,isKeywordES6:i,isReservedWordES5:s,isReservedWordES6:a,isRestrictedWord:o,isIdentifierNameES5:u,isIdentifierNameES6:c,isIdentifierES5:f,isIdentifierES6:p}}()},function(e,t,r){"use strict";e.exports=r(630)},function(e,t,r){"use strict";var n=r(180),i=new RegExp(n().source);e.exports=i.test.bind(i)},function(e,t){"use strict";t.read=function(e,t,r,n,i){var s,a,o=8*i-n-1,u=(1<<o)-1,l=u>>1,c=-7,f=r?i-1:0,p=r?-1:1,d=e[t+f];for(f+=p,s=d&(1<<-c)-1,d>>=-c,c+=o;c>0;s=256*s+e[t+f],f+=p,c-=8);for(a=s&(1<<-c)-1,s>>=-c,c+=n;c>0;a=256*a+e[t+f],f+=p,c-=8);if(0===s)s=1-l;else{if(s===u)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),s-=l}return(d?-1:1)*a*Math.pow(2,s-n)},t.write=function(e,t,r,n,i,s){var a,o,u,l=8*s-i-1,c=(1<<l)-1,f=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:s-1,h=n?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-a))<1&&(a--,u*=2),t+=a+f>=1?p/u:p*Math.pow(2,1-f),t*u>=2&&(a++,u/=2),a+f>=c?(o=0,a=c):a+f>=1?(o=(t*u-1)*Math.pow(2,i),a+=f):(o=t*Math.pow(2,f-1)*Math.pow(2,i),a=0));i>=8;e[r+d]=255&o,d+=h,o/=256,i-=8);for(a=a<<i|o,l+=i;l>0;e[r+d]=255&a,d+=h,a/=256,l-=8);e[r+d-h]|=128*m}},function(e,t,r){"use strict";var n=function(e,t,r,n,i,s,a,o){if(!e){var u;if(void 0===t)u=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[r,n,i,s,a,o],c=0;u=new Error(t.replace(/%s/g,function(){return l[c++]})),u.name="Invariant Violation"}throw u.framesToPop=1,u}};e.exports=n},function(e,t,r){"use strict";var n=r(603);e.exports=Number.isFinite||function(e){return!("number"!=typeof e||n(e)||e===1/0||e===-1/0)}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=/((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g,t.matchToToken=function(e){var t={type:"invalid",value:e[0]};return e[1]?(t.type="string",t.closed=!(!e[3]&&!e[4])):e[5]?t.type="comment":e[6]?(t.type="comment",t.closed=!!e[7]):e[8]?t.type="regex":e[9]?t.type="number":e[10]?t.type="name":e[11]?t.type="punctuator":e[12]&&(t.type="whitespace"),t}},function(e,t,r){var n;(function(e,i){"use strict";var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(a){var o="object"==s(t)&&t,u="object"==s(e)&&e&&e.exports==o&&e,l="object"==(void 0===i?"undefined":s(i))&&i;l.global!==l&&l.window!==l||(a=l);var c={},f=c.hasOwnProperty,p=function(e,t){var r;for(r in e)f.call(e,r)&&t(r,e[r])},d=function(e,t){return t?(p(t,function(t,r){e[t]=r}),e):e},h=function(e,t){for(var r=e.length,n=-1;++n<r;)t(e[n])},m=c.toString,y=function(e){return"[object Array]"==m.call(e)},v=function(e){return"[object Object]"==m.call(e)},g=function(e){return"string"==typeof e||"[object String]"==m.call(e)},b=function(e){return"number"==typeof e||"[object Number]"==m.call(e)},E=function(e){return"function"==typeof e||"[object Function]"==m.call(e)},x=function(e){return"[object Map]"==m.call(e)},A=function(e){return"[object Set]"==m.call(e)},S={'"':'\\"',"'":"\\'","\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},_=/["'\\\b\f\n\r\t]/,D=/[0-9]/,C=/[ !#-&\(-\[\]-~]/,w=function e(t,r){var n={escapeEverything:!1,escapeEtago:!1,quotes:"single",wrap:!1,es6:!1,json:!1,compact:!0,lowercaseHex:!1,numbers:"decimal",indent:"\t",__indent__:"",__inline1__:!1,__inline2__:!1},i=r&&r.json;i&&(n.quotes="double",n.wrap=!0),r=d(n,r),"single"!=r.quotes&&"double"!=r.quotes&&(r.quotes="single");var s,a="double"==r.quotes?'"':"'",o=r.compact,u=r.indent,l=r.lowercaseHex,c="",f=r.__inline1__,m=r.__inline2__,w=o?"":"\n",P=!0,k="binary"==r.numbers,F="octal"==r.numbers,T="decimal"==r.numbers,O="hexadecimal"==r.numbers;if(i&&t&&E(t.toJSON)&&(t=t.toJSON()),!g(t)){if(x(t))return 0==t.size?"new Map()":(o||(r.__inline1__=!0),"new Map("+e(Array.from(t),r)+")");if(A(t))return 0==t.size?"new Set()":"new Set("+e(Array.from(t),r)+")";if(y(t))return s=[],r.wrap=!0,f?(r.__inline1__=!1,r.__inline2__=!0):(c=r.__indent__,u+=c,r.__indent__=u),h(t,function(t){P=!1,m&&(r.__inline2__=!1),s.push((o||m?"":u)+e(t,r))}),P?"[]":m?"["+s.join(", ")+"]":"["+w+s.join(","+w)+w+(o?"":c)+"]";if(!b(t))return v(t)?(s=[],r.wrap=!0,c=r.__indent__,u+=c,r.__indent__=u,p(t,function(t,n){P=!1,s.push((o?"":u)+e(t,r)+":"+(o?"":" ")+e(n,r))}),P?"{}":"{"+w+s.join(","+w)+w+(o?"":c)+"}"):i?JSON.stringify(t)||"null":String(t);if(i)return JSON.stringify(t);if(T)return String(t);if(O){var B=t.toString(16);return l||(B=B.toUpperCase()),"0x"+B}if(k)return"0b"+t.toString(2);if(F)return"0o"+t.toString(8)}var R,I,M,N=t,L=-1,j=N.length;for(s="";++L<j;){var U=N.charAt(L);if(r.es6&&(R=N.charCodeAt(L))>=55296&&R<=56319&&j>L+1&&(I=N.charCodeAt(L+1))>=56320&&I<=57343){M=1024*(R-55296)+I-56320+65536;var V=M.toString(16);l||(V=V.toUpperCase()),s+="\\u{"+V+"}",L++}else{if(!r.escapeEverything){if(C.test(U)){s+=U;continue}if('"'==U){s+=a==U?'\\"':U;continue}if("'"==U){s+=a==U?"\\'":U;continue}}if("\0"!=U||i||D.test(N.charAt(L+1)))if(_.test(U))s+=S[U];else{var G=U.charCodeAt(0),V=G.toString(16);l||(V=V.toUpperCase());var W=V.length>2||i,Y="\\"+(W?"u":"x")+("0000"+V).slice(W?-4:-2);s+=Y}else s+="\\0"}}return r.wrap&&(s=a+s+a),r.escapeEtago?s.replace(/<\/(script|style)/gi,"<\\/$1"):s};w.version="1.3.0","object"==s(r(49))&&r(49)?void 0!==(n=function(){return w}.call(t,r,t,e))&&(e.exports=n):o&&!o.nodeType?u?u.exports=w:o.jsesc=w:a.jsesc=w}(void 0)}).call(t,r(39)(e),function(){return this}())},function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i="object"===n(t)?t:{};i.parse=function(){var e,t,r,i,s,a,o={"'":"'",'"':'"',"\\":"\\","/":"/","\n":"",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},u=[" ","\t","\r","\n","\v","\f","","\ufeff"],l=function(e){return""===e?"EOF":"'"+e+"'"},c=function(n){var i=new SyntaxError;throw i.message=n+" at line "+t+" column "+r+" of the JSON5 data. Still to read: "+JSON.stringify(s.substring(e-1,e+19)),i.at=e,i.lineNumber=t,i.columnNumber=r,i},f=function(n){return n&&n!==i&&c("Expected "+l(n)+" instead of "+l(i)),i=s.charAt(e),e++,r++,("\n"===i||"\r"===i&&"\n"!==p())&&(t++,r=0),i},p=function(){return s.charAt(e)},d=function(){var e=i;for("_"!==i&&"$"!==i&&(i<"a"||i>"z")&&(i<"A"||i>"Z")&&c("Bad identifier as unquoted key");f()&&("_"===i||"$"===i||i>="a"&&i<="z"||i>="A"&&i<="Z"||i>="0"&&i<="9");)e+=i;return e},h=function(){var e,t="",r="",n=10;if("-"!==i&&"+"!==i||(t=i,f(i)),"I"===i)return e=E(),("number"!=typeof e||isNaN(e))&&c("Unexpected word for number"),"-"===t?-e:e;if("N"===i)return e=E(),isNaN(e)||c("expected word to be NaN"),e;switch("0"===i&&(r+=i,f(),"x"===i||"X"===i?(r+=i,f(),n=16):i>="0"&&i<="9"&&c("Octal literal")),n){case 10:for(;i>="0"&&i<="9";)r+=i,f();if("."===i)for(r+=".";f()&&i>="0"&&i<="9";)r+=i;if("e"===i||"E"===i)for(r+=i,f(),"-"!==i&&"+"!==i||(r+=i,f());i>="0"&&i<="9";)r+=i,f();break;case 16:for(;i>="0"&&i<="9"||i>="A"&&i<="F"||i>="a"&&i<="f";)r+=i,f()}if(e="-"===t?-r:+r,isFinite(e))return e;c("Bad number")},m=function(){var e,t,r,n,s="";if('"'===i||"'"===i)for(r=i;f();){if(i===r)return f(),s;if("\\"===i)if(f(),"u"===i){for(n=0,t=0;t<4&&(e=parseInt(f(),16),isFinite(e));t+=1)n=16*n+e;s+=String.fromCharCode(n)}else if("\r"===i)"\n"===p()&&f();else{if("string"!=typeof o[i])break;s+=o[i]}else{if("\n"===i)break;s+=i}}c("Bad string")},y=function(){"/"!==i&&c("Not an inline comment");do{if(f(),"\n"===i||"\r"===i)return void f()}while(i)},v=function(){"*"!==i&&c("Not a block comment");do{for(f();"*"===i;)if(f("*"),"/"===i)return void f("/")}while(i);c("Unterminated block comment")},g=function(){"/"!==i&&c("Not a comment"),f("/"),"/"===i?y():"*"===i?v():c("Unrecognized comment")},b=function(){for(;i;)if("/"===i)g();else{if(!(u.indexOf(i)>=0))return;f()}},E=function(){switch(i){case"t":return f("t"),f("r"),f("u"),f("e"),!0;case"f":return f("f"),f("a"),f("l"),f("s"),f("e"),!1;case"n":return f("n"),f("u"),f("l"),f("l"),null;case"I":return f("I"),f("n"),f("f"),f("i"),f("n"),f("i"),f("t"),f("y"),1/0;case"N":return f("N"),f("a"),f("N"),NaN}c("Unexpected "+l(i))},x=function(){var e=[];if("["===i)for(f("["),b();i;){if("]"===i)return f("]"),e;if(","===i?c("Missing array element"):e.push(a()),b(),","!==i)return f("]"),e;f(","),b()}c("Bad array")},A=function(){var e,t={};if("{"===i)for(f("{"),b();i;){if("}"===i)return f("}"),t;if(e='"'===i||"'"===i?m():d(),b(),f(":"),t[e]=a(),b(),","!==i)return f("}"),t;f(","),b()}c("Bad object")};return a=function(){switch(b(),i){case"{":return A();case"[":return x();case'"':case"'":return m();case"-":case"+":case".":return h();default:return i>="0"&&i<="9"?h():E()}},function(o,u){var l;return s=String(o),e=0,t=1,r=1,i=" ",l=a(),b(),i&&c("Syntax error"),"function"==typeof u?function e(t,r){var i,s,a=t[r];if(a&&"object"===(void 0===a?"undefined":n(a)))for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&(s=e(a,i),void 0!==s?a[i]=s:delete a[i]);return u.call(t,r,a)}({"":l},""):l}}(),i.stringify=function(e,t,r){function s(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||e>="0"&&e<="9"||"_"===e||"$"===e}function a(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"===e||"$"===e}function o(e){if("string"!=typeof e)return!1;if(!a(e[0]))return!1;for(var t=1,r=e.length;t<r;){if(!s(e[t]))return!1;t++}return!0}function u(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}function l(e){return"[object Date]"===Object.prototype.toString.call(e)}function c(e){for(var t=0;t<y.length;t++)if(y[t]===e)throw new TypeError("Converting circular structure to JSON")}function f(e,t,r){if(!e)return"";e.length>10&&(e=e.substring(0,10));for(var n=r?"":"\n",i=0;i<t;i++)n+=e;return n}function p(e){return v.lastIndex=0,v.test(e)?'"'+e.replace(v,function(e){var t=g[e];return"string"==typeof t?t:"\\u"+("0000"+e.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+e+'"'}function d(e,t,r){var i,s,a=h(e,t,r);switch(a&&!l(a)&&(a=a.valueOf()),void 0===a?"undefined":n(a)){case"boolean":return a.toString();case"number":return isNaN(a)||!isFinite(a)?"null":a.toString();case"string":return p(a.toString());case"object":if(null===a)return"null";if(u(a)){c(a),i="[",y.push(a);for(var v=0;v<a.length;v++)s=d(a,v,!1),i+=f(m,y.length),i+=null===s||void 0===s?"null":s,v<a.length-1?i+=",":m&&(i+="\n");y.pop(),a.length&&(i+=f(m,y.length,!0)),i+="]"}else{c(a),i="{";var g=!1;y.push(a);for(var b in a)if(a.hasOwnProperty(b)){var E=d(a,b,!1);r=!1,void 0!==E&&null!==E&&(i+=f(m,y.length),g=!0,t=o(b)?b:p(b),i+=t+":"+(m?" ":"")+E+",")}y.pop(),i=g?i.substring(0,i.length-1)+f(m,y.length)+"}":"{}"}return i;default:return}}if(t&&"function"!=typeof t&&!u(t))throw new Error("Replacer must be a function or an array");var h=function(e,r,n){var i=e[r];return i&&i.toJSON&&"function"==typeof i.toJSON&&(i=i.toJSON()),"function"==typeof t?t.call(e,r,i):t?n||u(e)||t.indexOf(r)>=0?i:void 0:i};i.isWord=o;var m,y=[];r&&("string"==typeof r?m=r:"number"==typeof r&&r>=0&&(m=f(" ",r,!0)));var v=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,g={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},b={"":e};return void 0===e?h(b,"",!0):d(b,"",!0)}},function(e,t){"use strict";var r=[],n=[];e.exports=function(e,t){if(e===t)return 0;var i=e.length,s=t.length;if(0===i)return s;if(0===s)return i;for(var a,o,u,l,c=0,f=0;c<i;)n[c]=e.charCodeAt(c),r[c]=++c;for(;f<s;)for(a=t.charCodeAt(f),u=f++,o=f,c=0;c<i;c++)l=a===n[c]?u:u+1,u=r[c],o=r[c]=u>o?l>o?o+1:l:l>u?u+1:l;return o}},function(e,t,r){"use strict";var n=r(38),i=r(17),s=n(i,"DataView");e.exports=s},function(e,t,r){"use strict";function n(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}var i=r(536),s=r(537),a=r(538),o=r(539),u=r(540);n.prototype.clear=i,n.prototype.delete=s,n.prototype.get=a,n.prototype.has=o,n.prototype.set=u,e.exports=n},function(e,t,r){"use strict";var n=r(38),i=r(17),s=n(i,"Promise");e.exports=s},function(e,t,r){"use strict";var n=r(38),i=r(17),s=n(i,"WeakMap");e.exports=s},function(e,t){"use strict";function r(e,t){return e.set(t[0],t[1]),e}e.exports=r},function(e,t){"use strict";function r(e,t){return e.add(t),e}e.exports=r},function(e,t){"use strict";function r(e,t){for(var r=-1,n=null==e?0:e.length;++r<n&&!1!==t(e[r],r,e););return e}e.exports=r},function(e,t){"use strict";function r(e,t){for(var r=-1,n=null==e?0:e.length,i=0,s=[];++r<n;){var a=e[r];t(a,r,e)&&(s[i++]=a)}return s}e.exports=r},function(e,t,r){"use strict";function n(e,t){return!!(null==e?0:e.length)&&i(e,t,0)>-1}var i=r(166);e.exports=n},function(e,t){"use strict";function r(e,t,r){for(var n=-1,i=null==e?0:e.length;++n<i;)if(r(t,e[n]))return!0;return!1}e.exports=r},function(e,t){"use strict";function r(e,t){for(var r=-1,n=null==e?0:e.length;++r<n;)if(t(e[r],r,e))return!0;return!1}e.exports=r},function(e,t,r){"use strict";function n(e,t){return e&&i(t,s(t),e)}var i=r(31),s=r(32);e.exports=n},function(e,t,r){"use strict";function n(e,t){return e&&i(t,s(t),e)}var i=r(31),s=r(47);e.exports=n},function(e,t){"use strict";function r(e,t,r){return e===e&&(void 0!==r&&(e=e<=r?e:r),void 0!==t&&(e=e>=t?e:t)),e}e.exports=r},function(e,t,r){"use strict";var n=r(18),i=Object.create,s=function(){function e(){}return function(t){if(!n(t))return{};if(i)return i(t);e.prototype=t;var r=new e;return e.prototype=void 0,r}}();e.exports=s},function(e,t,r){"use strict";var n=r(489),i=r(526),s=i(n);e.exports=s},function(e,t,r){"use strict";function n(e,t,r,a,o){var u=-1,l=e.length;for(r||(r=s),o||(o=[]);++u<l;){var c=e[u];t>0&&r(c)?t>1?n(c,t-1,r,a,o):i(o,c):a||(o[o.length]=c)}return o}var i=r(161),s=r(543);e.exports=n},function(e,t,r){"use strict";function n(e,t){return e&&i(e,t,s)}var i=r(248),s=r(32);e.exports=n},function(e,t){"use strict";function r(e,t){return null!=e&&i.call(e,t)}var n=Object.prototype,i=n.hasOwnProperty;e.exports=r},function(e,t){"use strict";function r(e,t){return null!=e&&t in Object(e)}e.exports=r},function(e,t){"use strict";function r(e,t,r,n){for(var i=r-1,s=e.length;++i<s;)if(n(e[i],t))return i;return-1}e.exports=r},function(e,t,r){"use strict";function n(e){return s(e)&&i(e)==a}var i=r(30),s=r(25),a="[object Arguments]";e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n,y,g){var b=l(e),E=l(t),x=b?h:u(e),A=E?h:u(t);x=x==d?m:x,A=A==d?m:A;var S=x==m,_=A==m,D=x==A;if(D&&c(e)){if(!c(t))return!1;b=!0,S=!1}if(D&&!S)return g||(g=new i),b||f(e)?s(e,t,r,n,y,g):a(e,t,x,r,n,y,g);if(!(r&p)){var C=S&&v.call(e,"__wrapped__"),w=_&&v.call(t,"__wrapped__");if(C||w){var P=C?e.value():e,k=w?t.value():t;return g||(g=new i),y(P,k,r,n,g)}}return!!D&&(g||(g=new i),o(e,t,r,n,y,g))}var i=r(99),s=r(260),a=r(530),o=r(531),u=r(264),l=r(6),c=r(113),f=r(177),p=1,d="[object Arguments]",h="[object Array]",m="[object Object]",y=Object.prototype,v=y.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n){var u=r.length,l=u,c=!n;if(null==e)return!l;for(e=Object(e);u--;){var f=r[u];if(c&&f[2]?f[1]!==e[f[0]]:!(f[0]in e))return!1}for(;++u<l;){f=r[u];var p=f[0],d=e[p],h=f[1];if(c&&f[2]){if(void 0===d&&!(p in e))return!1}else{var m=new i;if(n)var y=n(d,h,p,e,t,m);if(!(void 0===y?s(h,d,a|o,n,m):y))return!1}}return!0}var i=r(99),s=r(251),a=1,o=2;e.exports=n},function(e,t){"use strict";function r(e){return e!==e}e.exports=r},function(e,t,r){"use strict";function n(e){return!(!a(e)||s(e))&&(i(e)?h:l).test(o(e))}var i=r(175),s=r(545),a=r(18),o=r(272),u=/[\\^$.*+?()[\]{}|]/g,l=/^\[object .+?Constructor\]$/,c=Function.prototype,f=Object.prototype,p=c.toString,d=f.hasOwnProperty,h=RegExp("^"+p.call(d).replace(u,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=n},function(e,t,r){"use strict";function n(e){return s(e)&&i(e)==a}var i=r(30),s=r(25),a="[object RegExp]";e.exports=n},function(e,t,r){"use strict";function n(e){return a(e)&&s(e.length)&&!!o[i(e)]}var i=r(30),s=r(176),a=r(25),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,e.exports=n},function(e,t,r){"use strict";function n(e){if(!i(e))return s(e);var t=[];for(var r in Object(e))o.call(e,r)&&"constructor"!=r&&t.push(r);return t}var i=r(105),s=r(557),a=Object.prototype,o=a.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e){if(!i(e))return a(e);var t=s(e),r=[];for(var n in e)("constructor"!=n||!t&&u.call(e,n))&&r.push(n);return r}var i=r(18),s=r(105),a=r(558),o=Object.prototype,u=o.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e){var t=s(e);return 1==t.length&&t[0][2]?a(t[0][0],t[0][1]):function(r){return r===e||i(r,e,t)}}var i=r(495),s=r(533),a=r(269);e.exports=n},function(e,t,r){"use strict";function n(e,t){return o(e)&&u(t)?l(c(e),t):function(r){var n=s(r,e);return void 0===n&&n===t?a(r,e):i(t,n,f|p)}}var i=r(251),s=r(583),a=r(584),o=r(173),u=r(267),l=r(269),c=r(108),f=1,p=2;e.exports=n},function(e,t,r){"use strict";function n(e,t,r,c,f){e!==t&&a(t,function(a,l){if(u(a))f||(f=new i),o(e,t,l,r,n,c,f);else{var p=c?c(e[l],a,l+"",e,t,f):void 0;void 0===p&&(p=a),s(e,l,p)}},l)}var i=r(99),s=r(247),a=r(248),o=r(505),u=r(18),l=r(47);e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n,g,b,E){var x=e[r],A=t[r],S=E.get(A);if(S)return void i(e,r,S);var _=b?b(x,A,r+"",e,t,E):void 0,D=void 0===_;if(D){var C=c(A),w=!C&&p(A),P=!C&&!w&&y(A);_=A,C||w||P?c(x)?_=x:f(x)?_=o(x):w?(D=!1,_=s(A,!0)):P?(D=!1,_=a(A,!0)):_=[]:m(A)||l(A)?(_=x,l(x)?_=v(x):(!h(x)||n&&d(x))&&(_=u(A))):D=!1}D&&(E.set(A,_),g(_,A,n,b,E),E.delete(A)),i(e,r,_)}var i=r(247),s=r(256),a=r(257),o=r(168),u=r(266),l=r(112),c=r(6),f=r(585),p=r(113),d=r(175),h=r(18),m=r(275),y=r(177),v=r(599);e.exports=n},function(e,t,r){"use strict";function n(e,t,r){var n=-1;t=i(t.length?t:[c],u(s));var f=a(e,function(e,r,s){return{criteria:i(t,function(t){return t(e)}),index:++n,value:e}});return o(f,function(e,t){return l(e,t,r)})}var i=r(60),s=r(61),a=r(252),o=r(512),u=r(102),l=r(522),c=r(110);e.exports=n},function(e,t){"use strict";function r(e){return function(t){return null==t?void 0:t[e]}}e.exports=r},function(e,t,r){"use strict";function n(e){return function(t){return i(t,e)}}var i=r(249);e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n){var l=n?a:s,f=-1,p=t.length,d=e;for(e===t&&(t=u(t)),r&&(d=i(e,o(r)));++f<p;)for(var h=0,m=t[f],y=r?r(m):m;(h=l(d,y,h,n))>-1;)d!==e&&c.call(d,h,1),c.call(e,h,1);return e}var i=r(60),s=r(166),a=r(492),o=r(102),u=r(168),l=Array.prototype,c=l.splice;e.exports=n},function(e,t){"use strict";function r(e,t){var r="";if(!e||t<1||t>n)return r;do{t%2&&(r+=e),(t=i(t/2))&&(e+=e)}while(t);return r}var n=9007199254740991,i=Math.floor;e.exports=r},function(e,t,r){"use strict";var n=r(576),i=r(259),s=r(110),a=i?function(e,t){return i(e,"toString",{configurable:!0,enumerable:!1,value:n(t),writable:!0})}:s;e.exports=a},function(e,t){"use strict";function r(e,t){var r=e.length;for(e.sort(t);r--;)e[r]=e[r].value;return e}e.exports=r},function(e,t){"use strict";function r(e,t){for(var r=-1,n=Array(e);++r<e;)n[r]=t(r);return n}e.exports=r},function(e,t,r){"use strict";function n(e,t,r){var n=-1,f=s,p=e.length,d=!0,h=[],m=h;if(r)d=!1,f=a;else if(p>=c){var y=t?null:u(e);if(y)return l(y);d=!1,f=o,m=new i}else m=t?[]:h;e:for(;++n<p;){var v=e[n],g=t?t(v):v;if(v=r||0!==v?v:0,d&&g===g){for(var b=m.length;b--;)if(m[b]===g)continue e;t&&m.push(g),h.push(v)}else f(m,g,r)||(m!==h&&m.push(g),h.push(v))}return h}var i=r(242),s=r(480),a=r(481),o=r(254),u=r(528),l=r(107),c=200;e.exports=n},function(e,t,r){"use strict";function n(e,t){return i(t,function(t){return e[t]})}var i=r(60);e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=t?i(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.byteLength)}var i=r(167);e.exports=n},function(e,t,r){"use strict";function n(e,t,r){var n=t?r(a(e),o):a(e);return s(n,i,new e.constructor)}var i=r(476),s=r(246),a=r(268),o=1;e.exports=n},function(e,t){"use strict";function r(e){var t=new e.constructor(e.source,n.exec(e));return t.lastIndex=e.lastIndex,t}var n=/\w*$/;e.exports=r},function(e,t,r){"use strict";function n(e,t,r){var n=t?r(a(e),o):a(e);return s(n,i,new e.constructor)}var i=r(477),s=r(246),a=r(107),o=1;e.exports=n},function(e,t,r){"use strict";function n(e){return a?Object(a.call(e)):{}}var i=r(45),s=i?i.prototype:void 0,a=s?s.valueOf:void 0;e.exports=n},function(e,t,r){"use strict";function n(e,t){if(e!==t){var r=void 0!==e,n=null===e,s=e===e,a=i(e),o=void 0!==t,u=null===t,l=t===t,c=i(t);if(!u&&!c&&!a&&e>t||a&&o&&l&&!u&&!c||n&&o&&l||!r&&l||!s)return 1;if(!n&&!a&&!c&&e<t||c&&r&&s&&!n&&!a||u&&r&&s||!o&&s||!l)return-1}return 0}var i=r(62);e.exports=n},function(e,t,r){"use strict";function n(e,t,r){for(var n=-1,s=e.criteria,a=t.criteria,o=s.length,u=r.length;++n<o;){var l=i(s[n],a[n]);if(l){if(n>=u)return l;return l*("desc"==r[n]?-1:1)}}return e.index-t.index}var i=r(521);e.exports=n},function(e,t,r){"use strict";function n(e,t){return i(e,s(e),t)}var i=r(31),s=r(170);e.exports=n},function(e,t,r){"use strict";function n(e,t){return i(e,s(e),t)}var i=r(31),s=r(263);e.exports=n},function(e,t,r){"use strict";var n=r(17),i=n["__core-js_shared__"];e.exports=i},function(e,t,r){"use strict";function n(e,t){return function(r,n){if(null==r)return r;if(!i(r))return e(r,n);for(var s=r.length,a=t?s:-1,o=Object(r);(t?a--:++a<s)&&!1!==n(o[a],a,o););return r}}var i=r(24);e.exports=n},function(e,t){"use strict";function r(e){return function(t,r,n){for(var i=-1,s=Object(t),a=n(t),o=a.length;o--;){var u=a[e?o:++i];if(!1===r(s[u],u,s))break}return t}}e.exports=r},function(e,t,r){"use strict";var n=r(241),i=r(591),s=r(107),a=n&&1/s(new n([,-0]))[1]==1/0?function(e){return new n(e)}:i;e.exports=a},function(e,t,r){"use strict";function n(e,t,r,n){return void 0===e||i(e,s[r])&&!a.call(n,r)?t:e}var i=r(46),s=Object.prototype,a=s.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n,i,S,D){switch(r){case A:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case x:return!(e.byteLength!=t.byteLength||!S(new s(e),new s(t)));case p:case d:case y:return a(+e,+t);case h:return e.name==t.name&&e.message==t.message;case v:case b:return e==t+"";case m:var C=u;case g:var w=n&c;if(C||(C=l),e.size!=t.size&&!w)return!1;var P=D.get(e);if(P)return P==t;n|=f,D.set(e,t);var k=o(C(e),C(t),n,i,S,D);return D.delete(e),k;case E:if(_)return _.call(e)==_.call(t)}return!1}var i=r(45),s=r(243),a=r(46),o=r(260),u=r(268),l=r(107),c=1,f=2,p="[object Boolean]",d="[object Date]",h="[object Error]",m="[object Map]",y="[object Number]",v="[object RegExp]",g="[object Set]",b="[object String]",E="[object Symbol]",x="[object ArrayBuffer]",A="[object DataView]",S=i?i.prototype:void 0,_=S?S.valueOf:void 0;e.exports=n},function(e,t,r){"use strict";function n(e,t,r,n,a,u){var l=r&s,c=i(e),f=c.length;if(f!=i(t).length&&!l)return!1;for(var p=f;p--;){var d=c[p];if(!(l?d in t:o.call(t,d)))return!1}var h=u.get(e);if(h&&u.get(t))return h==t;var m=!0;u.set(e,t),u.set(t,e);for(var y=l;++p<f;){d=c[p];var v=e[d],g=t[d];if(n)var b=l?n(g,v,d,t,e,u):n(v,g,d,e,t,u);if(!(void 0===b?v===g||a(v,g,r,n,u):b)){m=!1;break}y||(y="constructor"==d)}if(m&&!y){var E=e.constructor,x=t.constructor;E!=x&&"constructor"in e&&"constructor"in t&&!("function"==typeof E&&E instanceof E&&"function"==typeof x&&x instanceof x)&&(m=!1)}return u.delete(e),u.delete(t),m}var i=r(262),s=1,a=Object.prototype,o=a.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e){return i(e,a,s)}var i=r(250),s=r(263),a=r(47);e.exports=n},function(e,t,r){"use strict";function n(e){for(var t=s(e),r=t.length;r--;){var n=t[r],a=e[n];t[r]=[n,a,i(a)]}return t}var i=r(267),s=r(32);e.exports=n},function(e,t,r){"use strict";function n(e){var t=a.call(e,u),r=e[u];try{e[u]=void 0;var n=!0}catch(e){}var i=o.call(e);return n&&(t?e[u]=r:delete e[u]),i}var i=r(45),s=Object.prototype,a=s.hasOwnProperty,o=s.toString,u=i?i.toStringTag:void 0;e.exports=n},function(e,t){"use strict";function r(e,t){return null==e?void 0:e[t]}e.exports=r},function(e,t,r){"use strict";function n(){this.__data__=i?i(null):{},this.size=0}var i=r(106);e.exports=n},function(e,t){"use strict";function r(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}e.exports=r},function(e,t,r){"use strict";function n(e){var t=this.__data__;if(i){var r=t[e];return r===s?void 0:r}return o.call(t,e)?t[e]:void 0}var i=r(106),s="__lodash_hash_undefined__",a=Object.prototype,o=a.hasOwnProperty;e.exports=n},function(e,t,r){"use strict"
;function n(e){var t=this.__data__;return i?void 0!==t[e]:a.call(t,e)}var i=r(106),s=Object.prototype,a=s.hasOwnProperty;e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=i&&void 0===t?s:t,this}var i=r(106),s="__lodash_hash_undefined__";e.exports=n},function(e,t){"use strict";function r(e){var t=e.length,r=e.constructor(t);return t&&"string"==typeof e[0]&&i.call(e,"index")&&(r.index=e.index,r.input=e.input),r}var n=Object.prototype,i=n.hasOwnProperty;e.exports=r},function(e,t,r){"use strict";function n(e,t,r,n){var F=e.constructor;switch(t){case b:return i(e);case f:case p:return new F(+e);case E:return s(e,n);case x:case A:case S:case _:case D:case C:case w:case P:case k:return c(e,n);case d:return a(e,n,r);case h:case v:return new F(e);case m:return o(e);case y:return u(e,n,r);case g:return l(e)}}var i=r(167),s=r(516),a=r(517),o=r(518),u=r(519),l=r(520),c=r(257),f="[object Boolean]",p="[object Date]",d="[object Map]",h="[object Number]",m="[object RegExp]",y="[object Set]",v="[object String]",g="[object Symbol]",b="[object ArrayBuffer]",E="[object DataView]",x="[object Float32Array]",A="[object Float64Array]",S="[object Int8Array]",_="[object Int16Array]",D="[object Int32Array]",C="[object Uint8Array]",w="[object Uint8ClampedArray]",P="[object Uint16Array]",k="[object Uint32Array]";e.exports=n},function(e,t,r){"use strict";function n(e){return a(e)||s(e)||!!(o&&e&&e[o])}var i=r(45),s=r(112),a=r(6),o=i?i.isConcatSpreadable:void 0;e.exports=n},function(e,t){"use strict";function r(e){var t=void 0===e?"undefined":n(e);return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=r},function(e,t,r){"use strict";function n(e){return!!s&&s in e}var i=r(525),s=function(){var e=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();e.exports=n},function(e,t){"use strict";function r(){this.__data__=[],this.size=0}e.exports=r},function(e,t,r){"use strict";function n(e){var t=this.__data__,r=i(t,e);return!(r<0)&&(r==t.length-1?t.pop():a.call(t,r,1),--this.size,!0)}var i=r(100),s=Array.prototype,a=s.splice;e.exports=n},function(e,t,r){"use strict";function n(e){var t=this.__data__,r=i(t,e);return r<0?void 0:t[r][1]}var i=r(100);e.exports=n},function(e,t,r){"use strict";function n(e){return i(this.__data__,e)>-1}var i=r(100);e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=this.__data__,n=i(r,e);return n<0?(++this.size,r.push([e,t])):r[n][1]=t,this}var i=r(100);e.exports=n},function(e,t,r){"use strict";function n(){this.size=0,this.__data__={hash:new i,map:new(a||s),string:new i}}var i=r(473),s=r(98),a=r(159);e.exports=n},function(e,t,r){"use strict";function n(e){var t=i(this,e).delete(e);return this.size-=t?1:0,t}var i=r(104);e.exports=n},function(e,t,r){"use strict";function n(e){return i(this,e).get(e)}var i=r(104);e.exports=n},function(e,t,r){"use strict";function n(e){return i(this,e).has(e)}var i=r(104);e.exports=n},function(e,t,r){"use strict";function n(e,t){var r=i(this,e),n=r.size;return r.set(e,t),this.size+=r.size==n?0:1,this}var i=r(104);e.exports=n},function(e,t,r){"use strict";function n(e){var t=i(e,function(e){return r.size===s&&r.clear(),e}),r=t.cache;return t}var i=r(589),s=500;e.exports=n},function(e,t,r){"use strict";var n=r(271),i=n(Object.keys,Object);e.exports=i},function(e,t){"use strict";function r(e){var t=[];if(null!=e)for(var r in Object(e))t.push(r);return t}e.exports=r},function(e,t){"use strict";function r(e){return i.call(e)}var n=Object.prototype,i=n.toString;e.exports=r},function(e,t,r){"use strict";function n(e,t,r){return t=s(void 0===t?e.length-1:t,0),function(){for(var n=arguments,a=-1,o=s(n.length-t,0),u=Array(o);++a<o;)u[a]=n[t+a];a=-1;for(var l=Array(t+1);++a<t;)l[a]=n[a];return l[t]=r(u),i(e,this,l)}}var i=r(244),s=Math.max;e.exports=n},function(e,t){"use strict";function r(e){return this.__data__.set(e,n),this}var n="__lodash_hash_undefined__";e.exports=r},function(e,t){"use strict";function r(e){return this.__data__.has(e)}e.exports=r},function(e,t,r){"use strict";var n=r(511),i=r(564),s=i(n);e.exports=s},function(e,t){"use strict";function r(e){var t=0,r=0;return function(){var a=s(),o=i-(a-r);if(r=a,o>0){if(++t>=n)return arguments[0]}else t=0;return e.apply(void 0,arguments)}}var n=800,i=16,s=Date.now;e.exports=r},function(e,t,r){"use strict";function n(){this.__data__=new i,this.size=0}var i=r(98);e.exports=n},function(e,t){"use strict";function r(e){var t=this.__data__,r=t.delete(e);return this.size=t.size,r}e.exports=r},function(e,t){"use strict";function r(e){return this.__data__.get(e)}e.exports=r},function(e,t){"use strict";function r(e){return this.__data__.has(e)}e.exports=r},function(e,t,r){"use strict";function n(e,t){var r=this.__data__;if(r instanceof i){var n=r.__data__;if(!s||n.length<o-1)return n.push([e,t]),this.size=++r.size,this;r=this.__data__=new a(n)}return r.set(e,t),this.size=r.size,this}var i=r(98),s=r(159),a=r(160),o=200;e.exports=n},function(e,t){"use strict";function r(e,t,r){for(var n=r-1,i=e.length;++n<i;)if(e[n]===t)return n;return-1}e.exports=r},function(e,t,r){"use strict";var n=r(556),i=/^\./,s=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=n(function(e){var t=[];return i.test(e)&&t.push(""),e.replace(s,function(e,r,n,i){t.push(n?i.replace(a,"$1"):r||e)}),t});e.exports=o},function(e,t,r){"use strict";var n=r(31),i=r(103),s=r(47),a=i(function(e,t){n(t,s(t),e)});e.exports=a},function(e,t,r){"use strict";var n=r(31),i=r(103),s=r(47),a=i(function(e,t,r,i){n(t,s(t),e,i)});e.exports=a},function(e,t,r){"use strict";function n(e){return i(e,s|a)}var i=r(164),s=1,a=4;e.exports=n},function(e,t,r){"use strict";function n(e,t){return t="function"==typeof t?t:void 0,i(e,s|a,t)}var i=r(164),s=1,a=4;e.exports=n},function(e,t){"use strict";function r(e){return function(){return e}}e.exports=r},function(e,t,r){"use strict";function n(e){return e=i(e),e&&a.test(e)?e.replace(s,"\\$&"):e}var i=r(114),s=/[\\^$.*+?()[\]{}|]/g,a=RegExp(s.source);e.exports=n},function(e,t,r){"use strict";e.exports=r(572)},function(e,t,r){"use strict";var n=r(258),i=r(580),s=n(i);e.exports=s},function(e,t,r){"use strict";function n(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var u=null==r?0:a(r);return u<0&&(u=o(n+u,0)),i(e,s(t,3),u)}var i=r(165),s=r(61),a=r(48),o=Math.max;e.exports=n},function(e,t,r){"use strict";var n=r(258),i=r(582),s=n(i);e.exports=s},function(e,t,r){"use strict";function n(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var l=n-1;return void 0!==r&&(l=a(r),l=r<0?o(n+l,0):u(l,n-1)),i(e,s(t,3),l,!0)}var i=r(165),s=r(61),a=r(48),o=Math.max,u=Math.min;e.exports=n},function(e,t,r){"use strict";function n(e,t,r){var n=null==e?void 0:i(e,t);return void 0===n?r:n}var i=r(249);e.exports=n},function(e,t,r){"use strict";function n(e,t){return null!=e&&s(e,t,i)}var i=r(491),s=r(265);e.exports=n},function(e,t,r){"use strict";function n(e){return s(e)&&i(e)}var i=r(24),s=r(25);e.exports=n},function(e,t,r){"use strict";function n(e){return"number"==typeof e&&e==i(e)}var i=r(48);e.exports=n},function(e,t,r){"use strict";function n(e){return"string"==typeof e||!s(e)&&a(e)&&i(e)==o}var i=r(30),s=r(6),a=r(25),o="[object String]";e.exports=n},function(e,t,r){"use strict";function n(e,t){return(o(e)?i:a)(e,s(t,3))}var i=r(60),s=r(61),a=r(252),o=r(6);e.exports=n},function(e,t,r){"use strict";function n(e,t){if("function"!=typeof e||null!=t&&"function"!=typeof t)throw new TypeError(s);var r=function r(){var n=arguments,i=t?t.apply(this,n):n[0],s=r.cache;if(s.has(i))return s.get(i);var a=e.apply(this,n);return r.cache=s.set(i,a)||s,a};return r.cache=new(n.Cache||i),r}var i=r(160),s="Expected a function";n.Cache=i,e.exports=n},function(e,t,r){"use strict";var n=r(504),i=r(103),s=i(function(e,t,r,i){n(e,t,r,i)});e.exports=s},function(e,t){"use strict";function r(){}e.exports=r},function(e,t,r){"use strict";function n(e){return a(e)?i(o(e)):s(e)}var i=r(507),s=r(508),a=r(173),o=r(108);e.exports=n},function(e,t,r){"use strict";function n(e,t){return e&&e.length&&t&&t.length?i(e,t):e}var i=r(509);e.exports=n},function(e,t,r){"use strict";var n=r(488),i=r(506),s=r(101),a=r(172),o=s(function(e,t){if(null==e)return[];var r=t.length;return r>1&&a(e,t[0],t[1])?t=[]:r>2&&a(t[0],t[1],t[2])&&(t=[t[0]]),i(e,n(t,1),[])});e.exports=o},function(e,t,r){"use strict";function n(e,t,r){return e=o(e),r=null==r?0:i(a(r),0,e.length),t=s(t),e.slice(r,r+t.length)==t}var i=r(485),s=r(253),a=r(48),o=r(114);e.exports=n},function(e,t){"use strict";function r(){return!1}e.exports=r},function(e,t,r){"use strict";function n(e){if(!e)return 0===e?e:0;if((e=i(e))===s||e===-s){return(e<0?-1:1)*a}return e===e?e:0}var i=r(598),s=1/0,a=1.7976931348623157e308;e.exports=n},function(e,t,r){"use strict";function n(e){if("number"==typeof e)return e;if(s(e))return a;if(i(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=i(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(o,"");var r=l.test(e);return r||c.test(e)?f(e.slice(2),r?2:8):u.test(e)?a:+e}var i=r(18),s=r(62),a=NaN,o=/^\s+|\s+$/g,u=/^[-+]0x[0-9a-f]+$/i,l=/^0b[01]+$/i,c=/^0o[0-7]+$/i,f=parseInt;e.exports=n},function(e,t,r){"use strict";function n(e){return i(e,s(e))}var i=r(31),s=r(47);e.exports=n},function(e,t,r){"use strict";function n(e){return e&&e.length?i(e):[]}var i=r(514);e.exports=n},function(e,t,r){"use strict";function n(e,t){return t=t||{},function(r,n,i){return s(r,e,t)}}function i(e,t){e=e||{},t=t||{};var r={};return Object.keys(t).forEach(function(e){r[e]=t[e]}),Object.keys(e).forEach(function(t){r[t]=e[t]}),r}function s(e,t,r){if("string"!=typeof t)throw new TypeError("glob pattern string required");return r||(r={}),!(!r.nocomment&&"#"===t.charAt(0))&&(""===t.trim()?""===e:new a(t,r).match(e))}function a(e,t){if(!(this instanceof a))return new a(e,t);if("string"!=typeof e)throw new TypeError("glob pattern string required");t||(t={}),e=e.trim(),"/"!==m.sep&&(e=e.split(m.sep).join("/")),this.options=t,this.set=[],this.pattern=e,this.regexp=null,this.negate=!1,this.comment=!1,this.empty=!1,this.make()}function o(){if(!this._made){var e=this.pattern,t=this.options;if(!t.nocomment&&"#"===e.charAt(0))return void(this.comment=!0);if(!e)return void(this.empty=!0);this.parseNegate();var r=this.globSet=this.braceExpand();t.debug&&(this.debug=console.error),this.debug(this.pattern,r),r=this.globParts=r.map(function(e){return e.split(_)}),this.debug(this.pattern,r),r=r.map(function(e,t,r){return e.map(this.parse,this)},this),this.debug(this.pattern,r),r=r.filter(function(e){return-1===e.indexOf(!1)}),this.debug(this.pattern,r),this.set=r}}function u(){var e=this.pattern,t=!1,r=this.options,n=0;if(!r.nonegate){for(var i=0,s=e.length;i<s&&"!"===e.charAt(i);i++)t=!t,n++;n&&(this.pattern=e.substr(n)),this.negate=t}}function l(e,t){if(t||(t=this instanceof a?this.options:{}),void 0===(e=void 0===e?this.pattern:e))throw new TypeError("undefined pattern");return t.nobrace||!e.match(/\{.*\}/)?[e]:v(e)}function c(e,t){function r(){if(i){switch(i){case"*":a+=E,o=!0;break;case"?":a+=b,o=!0;break;default:a+="\\"+i}v.debug("clearStateChar %j %j",i,a),i=!1}}if(e.length>65536)throw new TypeError("pattern is too long");var n=this.options;if(!n.noglobstar&&"**"===e)return y;if(""===e)return"";for(var i,s,a="",o=!!n.nocase,u=!1,l=[],c=[],f=!1,p=-1,h=-1,m="."===e.charAt(0)?"":n.dot?"(?!(?:^|\\/)\\.{1,2}(?:$|\\/))":"(?!\\.)",v=this,x=0,A=e.length;x<A&&(s=e.charAt(x));x++)if(this.debug("%s\t%s %s %j",e,x,a,s),u&&S[s])a+="\\"+s,u=!1;else switch(s){case"/":return!1;case"\\":r(),u=!0;continue;case"?":case"*":case"+":case"@":case"!":if(this.debug("%s\t%s %s %j <-- stateChar",e,x,a,s),f){this.debug("  in class"),"!"===s&&x===h+1&&(s="^"),a+=s;continue}v.debug("call clearStateChar %j",i),r(),i=s,n.noext&&r();continue;case"(":if(f){a+="(";continue}if(!i){a+="\\(";continue}l.push({type:i,start:x-1,reStart:a.length,open:g[i].open,close:g[i].close}),a+="!"===i?"(?:(?!(?:":"(?:",this.debug("plType %j %j",i,a),i=!1;continue;case")":if(f||!l.length){a+="\\)";continue}r(),o=!0;var _=l.pop();a+=_.close,"!"===_.type&&c.push(_),_.reEnd=a.length;continue;case"|":if(f||!l.length||u){a+="\\|",u=!1;continue}r(),a+="|";continue;case"[":if(r(),f){a+="\\"+s;continue}f=!0,h=x,p=a.length,a+=s;continue;case"]":if(x===h+1||!f){a+="\\"+s,u=!1;continue}if(f){var C=e.substring(h+1,x);try{RegExp("["+C+"]")}catch(e){var w=this.parse(C,D);a=a.substr(0,p)+"\\["+w[0]+"\\]",o=o||w[1],f=!1;continue}}o=!0,f=!1,a+=s;continue;default:r(),u?u=!1:!S[s]||"^"===s&&f||(a+="\\"),a+=s}for(f&&(C=e.substr(h+1),w=this.parse(C,D),a=a.substr(0,p)+"\\["+w[0],o=o||w[1]),_=l.pop();_;_=l.pop()){var P=a.slice(_.reStart+_.open.length);this.debug("setting tail",a,_),P=P.replace(/((?:\\{2}){0,64})(\\?)\|/g,function(e,t,r){return r||(r="\\"),t+t+r+"|"}),this.debug("tail=%j\n   %s",P,P,_,a);var k="*"===_.type?E:"?"===_.type?b:"\\"+_.type;o=!0,a=a.slice(0,_.reStart)+k+"\\("+P}r(),u&&(a+="\\\\");var F=!1;switch(a.charAt(0)){case".":case"[":case"(":F=!0}for(var T=c.length-1;T>-1;T--){var O=c[T],B=a.slice(0,O.reStart),R=a.slice(O.reStart,O.reEnd-8),I=a.slice(O.reEnd-8,O.reEnd),M=a.slice(O.reEnd);I+=M;var N=B.split("(").length-1,L=M;for(x=0;x<N;x++)L=L.replace(/\)[+*?]?/,"");M=L;var j="";""===M&&t!==D&&(j="$");a=B+R+M+j+I}if(""!==a&&o&&(a="(?=.)"+a),F&&(a=m+a),t===D)return[a,o];if(!o)return d(e);var U=n.nocase?"i":"";try{var V=new RegExp("^"+a+"$",U)}catch(e){return new RegExp("$.")}return V._glob=e,V._src=a,V}function f(){if(this.regexp||!1===this.regexp)return this.regexp;var e=this.set;if(!e.length)return this.regexp=!1,this.regexp;var t=this.options,r=t.noglobstar?E:t.dot?x:A,n=t.nocase?"i":"",i=e.map(function(e){return e.map(function(e){return e===y?r:"string"==typeof e?h(e):e._src}).join("\\/")}).join("|");i="^(?:"+i+")$",this.negate&&(i="^(?!"+i+").*$");try{this.regexp=new RegExp(i,n)}catch(e){this.regexp=!1}return this.regexp}function p(e,t){if(this.debug("match",e,this.pattern),this.comment)return!1;if(this.empty)return""===e;if("/"===e&&t)return!0;var r=this.options;"/"!==m.sep&&(e=e.split(m.sep).join("/")),e=e.split(_),this.debug(this.pattern,"split",e);var n=this.set;this.debug(this.pattern,"set",n);var i,s;for(s=e.length-1;s>=0&&!(i=e[s]);s--);for(s=0;s<n.length;s++){var a=n[s],o=e;r.matchBase&&1===a.length&&(o=[i]);if(this.matchOne(o,a,t))return!!r.flipNegate||!this.negate}return!r.flipNegate&&this.negate}function d(e){return e.replace(/\\(.)/g,"$1")}function h(e){return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}e.exports=s,s.Minimatch=a;var m={sep:"/"};try{m=r(19)}catch(e){}var y=s.GLOBSTAR=a.GLOBSTAR={},v=r(398),g={"!":{open:"(?:(?!(?:",close:"))[^/]*?)"},"?":{open:"(?:",close:")?"},"+":{open:"(?:",close:")+"},"*":{open:"(?:",close:")*"},"@":{open:"(?:",close:")"}},b="[^/]",E=b+"*?",x="(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",A="(?:(?!(?:\\/|^)\\.).)*?",S=function(e){return e.split("").reduce(function(e,t){return e[t]=!0,e},{})}("().*{}+?[]^$\\!"),_=/\/+/;s.filter=n,s.defaults=function(e){if(!e||!Object.keys(e).length)return s;var t=s,r=function(r,n,s){return t.minimatch(r,n,i(e,s))};return r.Minimatch=function(r,n){return new t.Minimatch(r,i(e,n))},r},a.defaults=function(e){return e&&Object.keys(e).length?s.defaults(e).Minimatch:a},a.prototype.debug=function(){},a.prototype.make=o,a.prototype.parseNegate=u,s.braceExpand=function(e,t){return l(e,t)},a.prototype.braceExpand=l,a.prototype.parse=c;var D={};s.makeRe=function(e,t){return new a(e,t||{}).makeRe()},a.prototype.makeRe=f,s.match=function(e,t,r){r=r||{};var n=new a(t,r);return e=e.filter(function(e){return n.match(e)}),n.options.nonull&&!e.length&&e.push(t),e},a.prototype.match=p,a.prototype.matchOne=function(e,t,r){var n=this.options;this.debug("matchOne",{this:this,file:e,pattern:t}),this.debug("matchOne",e.length,t.length);for(var i=0,s=0,a=e.length,o=t.length;i<a&&s<o;i++,s++){this.debug("matchOne loop");var u=t[s],l=e[i];if(this.debug(t,u,l),!1===u)return!1;if(u===y){this.debug("GLOBSTAR",[t,u,l]);var c=i,f=s+1;if(f===o){for(this.debug("** at the end");i<a;i++)if("."===e[i]||".."===e[i]||!n.dot&&"."===e[i].charAt(0))return!1;return!0}for(;c<a;){var p=e[c];if(this.debug("\nglobstar while",e,c,t,f,p),this.matchOne(e.slice(c),t.slice(f),r))return this.debug("globstar found match!",c,a,p),!0;if("."===p||".."===p||!n.dot&&"."===p.charAt(0)){this.debug("dot detected!",e,c,t,f);break}this.debug("globstar swallow a segment, and continue"),c++}return!(!r||(this.debug("\n>>> no match, partial?",e,c,t,f),c!==a))}var d;if("string"==typeof u?(d=n.nocase?l.toLowerCase()===u.toLowerCase():l===u,this.debug("string match",u,l,d)):(d=l.match(u),this.debug("pattern match",u,l,d)),!d)return!1}if(i===a&&s===o)return!0;if(i===a)return r;if(s===o){return i===a-1&&""===e[i]}throw new Error("wtf?")}},function(e,t){"use strict";function r(e){if(e=String(e),!(e.length>100)){var t=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(t){var r=parseFloat(t[1]);switch((t[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return r*f;case"days":case"day":case"d":return r*c;case"hours":case"hour":case"hrs":case"hr":case"h":return r*l;case"minutes":case"minute":case"mins":case"min":case"m":return r*u;case"seconds":case"second":case"secs":case"sec":case"s":return r*o;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}}}function n(e){return e>=c?Math.round(e/c)+"d":e>=l?Math.round(e/l)+"h":e>=u?Math.round(e/u)+"m":e>=o?Math.round(e/o)+"s":e+"ms"}function i(e){return s(e,c,"day")||s(e,l,"hour")||s(e,u,"minute")||s(e,o,"second")||e+" ms"}function s(e,t,r){if(!(e<t))return e<1.5*t?Math.floor(e/t)+" "+r:Math.ceil(e/t)+" "+r+"s"}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o=1e3,u=60*o,l=60*u,c=24*l,f=365.25*c;e.exports=function(e,t){t=t||{};var s=void 0===e?"undefined":a(e);if("string"===s&&e.length>0)return r(e);if("number"===s&&!1===isNaN(e))return t.long?i(e):n(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},function(e,t){"use strict";e.exports=Number.isNaN||function(e){return e!==e}},function(e,t,r){(function(t){"use strict";function r(e){return"/"===e.charAt(0)}function n(e){var t=/^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/,r=t.exec(e),n=r[1]||"",i=Boolean(n&&":"!==n.charAt(1));return Boolean(r[2]||i)}e.exports="win32"===t.platform?n:r,e.exports.posix=r,e.exports.win32=n}).call(t,r(8))},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}var i=r(14),s=function(e){return e&&e.__esModule?e:{default:e}}(i),a=r(1),o=n(a),u=r(116),l=n(u),c=Object.prototype.hasOwnProperty;t.hoist=function(e){function t(e,t){o.assertVariableDeclaration(e);var n=[];return e.declarations.forEach(function(e){r[e.id.name]=o.identifier(e.id.name),e.init?n.push(o.assignmentExpression("=",e.id,e.init)):t&&n.push(e.id)}),0===n.length?null:1===n.length?n[0]:o.sequenceExpression(n)}o.assertFunction(e.node);var r={};e.get("body").traverse({VariableDeclaration:{exit:function(e){var r=t(e.node,!1);null===r?e.remove():l.replaceWithOrRemove(e,o.expressionStatement(r)),e.skip()}},ForStatement:function(e){var r=e.node.init;o.isVariableDeclaration(r)&&l.replaceWithOrRemove(e.get("init"),t(r,!1))},ForXStatement:function(e){var r=e.get("left");r.isVariableDeclaration()&&l.replaceWithOrRemove(r,t(r.node,!0))},FunctionDeclaration:function(e){var t=e.node;r[t.id.name]=t.id;var n=o.expressionStatement(o.assignmentExpression("=",t.id,o.functionExpression(t.id,t.params,t.body,t.generator,t.expression)));e.parentPath.isBlockStatement()?(e.parentPath.unshiftContainer("body",n),e.remove()):l.replaceWithOrRemove(e,n),e.skip()},FunctionExpression:function(e){e.skip()}});var n={};e.get("params").forEach(function(e){var t=e.node;o.isIdentifier(t)&&(n[t.name]=t)});var i=[];return(0,s.default)(r).forEach(function(e){c.call(n,e)||i.push(o.variableDeclarator(r[e],null))}),0===i.length?null:o.variableDeclaration("var",i)}},function(e,t,r){"use strict";t.__esModule=!0,t.default=function(){return r(610)}},function(e,t,r){"use strict";function n(){d.default.ok(this instanceof n)}function i(e){n.call(this),m.assertLiteral(e),this.returnLoc=e}function s(e,t,r){n.call(this),m.assertLiteral(e),m.assertLiteral(t),r?m.assertIdentifier(r):r=null,this.breakLoc=e,this.continueLoc=t,this.label=r}function a(e){n.call(this),m.assertLiteral(e),this.breakLoc=e}function o(e,t,r){n.call(this),m.assertLiteral(e),t?d.default.ok(t instanceof u):t=null,r?d.default.ok(r instanceof l):r=null,d.default.ok(t||r),this.firstLoc=e,this.catchEntry=t,this.finallyEntry=r}function u(e,t){n.call(this),m.assertLiteral(e),m.assertIdentifier(t),this.firstLoc=e,this.paramId=t}function l(e,t){n.call(this),m.assertLiteral(e),m.assertLiteral(t),this.firstLoc=e,this.afterLoc=t}function c(e,t){n.call(this),m.assertLiteral(e),m.assertIdentifier(t),this.breakLoc=e,this.label=t}function f(e){d.default.ok(this instanceof f);var t=r(283).Emitter;d.default.ok(e instanceof t),this.emitter=e,this.entryStack=[new i(e.finalLoc)]}var p=r(64),d=function(e){return e&&e.__esModule?e:{default:e}}(p),h=r(1),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(h),y=r(117);(0,y.inherits)(i,n),t.FunctionEntry=i,(0,y.inherits)(s,n),t.LoopEntry=s,(0,y.inherits)(a,n),t.SwitchEntry=a,(0,y.inherits)(o,n),t.TryEntry=o,(0,y.inherits)(u,n),t.CatchEntry=u,(0,y.inherits)(l,n),t.FinallyEntry=l,(0,y.inherits)(c,n),t.LabeledEntry=c;var v=f.prototype;t.LeapManager=f,v.withEntry=function(e,t){d.default.ok(e instanceof n),this.entryStack.push(e);try{t.call(this.emitter)}finally{var r=this.entryStack.pop();d.default.strictEqual(r,e)}},v._findLeapLocation=function(e,t){for(var r=this.entryStack.length-1;r>=0;--r){var n=this.entryStack[r],i=n[e];if(i)if(t){if(n.label&&n.label.name===t.name)return i}else if(!(n instanceof c))return i}return null},v.getBreakLoc=function(e){return this._findLeapLocation("breakLoc",e)},v.getContinueLoc=function(e){return this._findLeapLocation("continueLoc",e)}},function(e,t,r){"use strict";function n(e,t){function r(e){function t(e){return r||(Array.isArray(e)?e.some(t):o.isNode(e)&&(s.default.strictEqual(r,!1),r=n(e))),r}o.assertNode(e);var r=!1,i=o.VISITOR_KEYS[e.type];if(i)for(var a=0;a<i.length;a++){var u=i[a],l=e[u];t(l)}return r}function n(n){o.assertNode(n);var i=u(n);return l.call(i,e)?i[e]:l.call(c,n.type)?i[e]=!1:l.call(t,n.type)?i[e]=!0:i[e]=r(n)}return n.onlyChildren=r,n}var i=r(64),s=function(e){return e&&e.__esModule?e:{default:e}}(i),a=r(1),o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(a),u=r(281).makeAccessor(),l=Object.prototype.hasOwnProperty,c={FunctionExpression:!0,ArrowFunctionExpression:!0},f={CallExpression:!0,ForInStatement:!0,UnaryExpression:!0,BinaryExpression:!0,AssignmentExpression:!0,UpdateExpression:!0,NewExpression:!0},p={YieldExpression:!0,BreakStatement:!0,ContinueStatement:!0,ReturnStatement:!0,ThrowStatement:!0};for(var d in p)l.call(p,d)&&(f[d]=p[d]);t.hasSideEffects=n("hasSideEffects",f),t.containsLeap=n("containsLeap",p)},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){if(!e.node||!a.isFunction(e.node))throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");if(!a.isObjectMethod(e.node))return e;if(!e.node.generator)return e;var t=e.node.params.map(function(e){return a.cloneDeep(e)}),r=a.functionExpression(null,t,a.cloneDeep(e.node.body),e.node.generator,e.node.async);return u.replaceWithOrRemove(e,a.objectProperty(a.cloneDeep(e.node.key),r,e.node.computed,!1)),e.get("value")}t.__esModule=!0,t.default=i;var s=r(1),a=n(s),o=r(116),u=n(o)},function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function i(e){return e&&e.__esModule?e:{default:e}}function s(e){var t=e.node;return f.assertFunction(t),t.id||(t.id=e.scope.parent.generateUidIdentifier("callee")),t.generator&&f.isFunctionDeclaration(t)?a(e):t.id}function a(e){var t=e.node;f.assertIdentifier(t.id);var r=e.findParent(function(e){return e.isProgram()||e.isBlockStatement()});if(!r)return t.id;var n=r.node;l.default.ok(Array.isArray(n.body));var i=g(n);i.decl||(i.decl=f.variableDeclaration("var",[]),r.unshiftContainer("body",i.decl),i.declPath=r.get("body.0")),l.default.strictEqual(i.declPath.node,i.decl);var s=r.scope.generateUidIdentifier("marked"),a=f.callExpression(v.runtimeProperty("mark"),[t.id]),o=i.decl.declarations.push(f.variableDeclarator(s,a))-1,u=i.declPath.get("declarations."+o+".init");return l.default.strictEqual(u.node,a),u.addComment("leading","#__PURE__"),s}function o(e,t){var r={didRenameArguments:!1,argsId:t};return e.traverse(b,r),r.didRenameArguments}var u=r(64),l=i(u),c=r(1),f=n(c),p=r(605),d=r(283),h=r(609),m=i(h),y=r(116),v=n(y);t.name="regenerator-transform",t.visitor={Function:{exit:function(e,t){var r=e.node;if(r.generator){if(r.async){if(!1===t.opts.asyncGenerators)return}else if(!1===t.opts.generators)return}else{if(!r.async)return;if(!1===t.opts.async)return}e=(0,m.default)(e),r=e.node;var n=e.scope.generateUidIdentifier("context"),i=e.scope.generateUidIdentifier("args");e.ensureBlock();var a=e.get("body");r.async&&a.traverse(x),a.traverse(E,{context:n});var u=[],l=[];a.get("body").forEach(function(e){var t=e.node;f.isExpressionStatement(t)&&f.isStringLiteral(t.expression)?u.push(t):t&&null!=t._blockHoist?u.push(t):l.push(t)}),u.length>0&&(a.node.body=l);var c=s(e);f.assertIdentifier(r.id);var h=f.identifier(r.id.name+"$"),y=(0,p.hoist)(e);if(o(e,i)){y=y||f.variableDeclaration("var",[]);var g=f.identifier("arguments");g._shadowedFunctionLiteral=e,y.declarations.push(f.variableDeclarator(i,g))}var b=new d.Emitter(n);b.explode(e.get("body")),y&&y.declarations.length>0&&u.push(y);var A=[b.getContextFunction(h),r.generator?c:f.nullLiteral(),f.thisExpression()],S=b.getTryLocsList();S&&A.push(S);var _=f.callExpression(v.runtimeProperty(r.async?"async":"wrap"),A);u.push(f.returnStatement(_)),r.body=f.blockStatement(u);var D=a.node.directives;D&&(r.body.directives=D);var C=r.generator;C&&(r.generator=!1),r.async&&(r.async=!1),C&&f.isExpression(r)&&(v.replaceWithOrRemove(e,f.callExpression(v.runtimeProperty("mark"),[r])),e.addComment("leading","#__PURE__")),e.requeue()}}};var g=r(281).makeAccessor(),b={"FunctionExpression|FunctionDeclaration":function(e){e.skip()},Identifier:function(e,t){"arguments"===e.node.name&&v.isReference(e)&&(v.replaceWithOrRemove(e,t.argsId),t.didRenameArguments=!0)}},E={MetaProperty:function(e){var t=e.node;"function"===t.meta.name&&"sent"===t.property.name&&v.replaceWithOrRemove(e,f.memberExpression(this.context,f.identifier("_sent")))}},x={Function:function(e){e.skip()},AwaitExpression:function(e){var t=e.node.argument;v.replaceWithOrRemove(e,f.yieldExpression(f.callExpression(v.runtimeProperty("awrap"),[t]),!1))}}},function(e,t,r){"use strict";var n=r(282);t.REGULAR={d:n().addRange(48,57),D:n().addRange(0,47).addRange(58,65535),s:n(32,160,5760,8239,8287,12288,65279).addRange(9,13).addRange(8192,8202).addRange(8232,8233),S:n().addRange(0,8).addRange(14,31).addRange(33,159).addRange(161,5759).addRange(5761,8191).addRange(8203,8231).addRange(8234,8238).addRange(8240,8286).addRange(8288,12287).addRange(12289,65278).addRange(65280,65535),w:n(95).addRange(48,57).addRange(65,90).addRange(97,122),W:n(96).addRange(0,47).addRange(58,64).addRange(91,94).addRange(123,65535)},t.UNICODE={d:n().addRange(48,57),D:n().addRange(0,47).addRange(58,1114111),s:n(32,160,5760,8239,8287,12288,65279).addRange(9,13).addRange(8192,8202).addRange(8232,8233),S:n().addRange(0,8).addRange(14,31).addRange(33,159).addRange(161,5759).addRange(5761,8191).addRange(8203,8231).addRange(8234,8238).addRange(8240,8286).addRange(8288,12287).addRange(12289,65278).addRange(65280,1114111),w:n(95).addRange(48,57).addRange(65,90).addRange(97,122),W:n(96).addRange(0,47).addRange(58,64).addRange(91,94).addRange(123,1114111)},t.UNICODE_IGNORE_CASE={d:n().addRange(48,57),D:n().addRange(0,47).addRange(58,1114111),s:n(32,160,5760,8239,8287,12288,65279).addRange(9,13).addRange(8192,8202).addRange(8232,8233),S:n().addRange(0,8).addRange(14,31).addRange(33,159).addRange(161,5759).addRange(5761,8191).addRange(8203,8231).addRange(8234,8238).addRange(8240,8286).addRange(8288,12287).addRange(12289,65278).addRange(65280,1114111),w:n(95,383,8490).addRange(48,57).addRange(65,90).addRange(97,122),W:n(75,83,96).addRange(0,47).addRange(58,64).addRange(91,94).addRange(123,1114111)}},function(e,t,r){"use strict";function n(e){return S?A?m.UNICODE_IGNORE_CASE[e]:m.UNICODE[e]:m.REGULAR[e]}function i(e,t){return v.call(e,t)}function s(e,t){for(var r in t)e[r]=t[r]}function a(e,t){if(t){var r=p(t,"");switch(r.type){case"characterClass":case"group":case"value":break;default:r=o(r,t)}s(e,r)}}function o(e,t){return{type:"group",behavior:"ignore",body:[e],raw:"(?:"+t+")"}}function u(e){return!!i(h,e)&&h[e]}function l(e){var t=d();e.body.forEach(function(e){switch(e.type){case"value":if(t.add(e.codePoint),A&&S){var r=u(e.codePoint);r&&t.add(r)}break;case"characterClassRange":var i=e.min.codePoint,s=e.max.codePoint;t.addRange(i,s),A&&S&&t.iuAddRange(i,s);break;case"characterClassEscape":t.add(n(e.value));break;default:throw Error("Unknown term type: "+e.type)}});return e.negative&&(t=(S?g:b).clone().remove(t)),a(e,t.toString()),e}function c(e){switch(e.type){case"dot":a(e,(S?E:x).toString());break;case"characterClass":e=l(e);break;case"characterClassEscape":a(e,n(e.value).toString());break;case"alternative":case"disjunction":case"group":case"quantifier":e.body=e.body.map(c);break;case"value":var t=e.codePoint,r=d(t);if(A&&S){var i=u(t);i&&r.add(i)}a(e,r.toString());break;case"anchor":case"empty":case"group":case"reference":break;default:throw Error("Unknown term type: "+e.type)}return e}var f=r(613).generate,p=r(614).parse,d=r(282),h=r(631),m=r(611),y={},v=y.hasOwnProperty,g=d().addRange(0,1114111),b=d().addRange(0,65535),E=g.clone().remove(10,13,8232,8233),x=E.clone().intersection(b);d.prototype.iuAddRange=function(e,t){var r=this;do{var n=u(e);n&&r.add(n)}while(++e<=t);return r};var A=!1,S=!1;e.exports=function(e,t){var r=p(e,t);return A=!!t&&t.indexOf("i")>-1,S=!!t&&t.indexOf("u")>-1,s(r,c(r)),f(r)}},function(e,t,r){var n;(function(e,i){"use strict";var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};(function(){function a(){var e,t,r=[],n=-1,i=arguments.length;if(!i)return"";for(var s="";++n<i;){var a=Number(arguments[n]);if(!isFinite(a)||a<0||a>1114111||k(a)!=a)throw RangeError("Invalid code point: "+a);a<=65535?r.push(a):(a-=65536,e=55296+(a>>10),t=a%1024+56320,r.push(e,t)),(n+1==i||r.length>16384)&&(s+=P.apply(null,r),r.length=0)}return s}function o(e,t){if(-1==t.indexOf("|")){if(e==t)return;throw Error("Invalid node type: "+e)}if(t=o.hasOwnProperty(t)?o[t]:o[t]=RegExp("^(?:"+t+")$"),!t.test(e))throw Error("Invalid node type: "+e)
}function u(e){var t=e.type;if(u.hasOwnProperty(t)&&"function"==typeof u[t])return u[t](e);throw Error("Invalid node type: "+t)}function l(e){o(e.type,"alternative");var t=e.body,r=t?t.length:0;if(1==r)return x(t[0]);for(var n=-1,i="";++n<r;)i+=x(t[n]);return i}function c(e){switch(o(e.type,"anchor"),e.kind){case"start":return"^";case"end":return"$";case"boundary":return"\\b";case"not-boundary":return"\\B";default:throw Error("Invalid assertion")}}function f(e){return o(e.type,"anchor|characterClass|characterClassEscape|dot|group|reference|value"),u(e)}function p(e){o(e.type,"characterClass");var t=e.body,r=t?t.length:0,n=-1,i="[";for(e.negative&&(i+="^");++n<r;)i+=m(t[n]);return i+="]"}function d(e){return o(e.type,"characterClassEscape"),"\\"+e.value}function h(e){o(e.type,"characterClassRange");var t=e.min,r=e.max;if("characterClassRange"==t.type||"characterClassRange"==r.type)throw Error("Invalid character class range");return m(t)+"-"+m(r)}function m(e){return o(e.type,"anchor|characterClassEscape|characterClassRange|dot|value"),u(e)}function y(e){o(e.type,"disjunction");var t=e.body,r=t?t.length:0;if(0==r)throw Error("No body");if(1==r)return u(t[0]);for(var n=-1,i="";++n<r;)0!=n&&(i+="|"),i+=u(t[n]);return i}function v(e){return o(e.type,"dot"),"."}function g(e){o(e.type,"group");var t="(";switch(e.behavior){case"normal":break;case"ignore":t+="?:";break;case"lookahead":t+="?=";break;case"negativeLookahead":t+="?!";break;default:throw Error("Invalid behaviour: "+e.behaviour)}var r=e.body,n=r?r.length:0;if(1==n)t+=u(r[0]);else for(var i=-1;++i<n;)t+=u(r[i]);return t+=")"}function b(e){o(e.type,"quantifier");var t="",r=e.min,n=e.max;switch(n){case void 0:case null:switch(r){case 0:t="*";break;case 1:t="+";break;default:t="{"+r+",}"}break;default:t=r==n?"{"+r+"}":0==r&&1==n?"?":"{"+r+","+n+"}"}return e.greedy||(t+="?"),f(e.body[0])+t}function E(e){return o(e.type,"reference"),"\\"+e.matchIndex}function x(e){return o(e.type,"anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value"),u(e)}function A(e){o(e.type,"value");var t=e.kind,r=e.codePoint;switch(t){case"controlLetter":return"\\c"+a(r+64);case"hexadecimalEscape":return"\\x"+("00"+r.toString(16).toUpperCase()).slice(-2);case"identifier":return"\\"+a(r);case"null":return"\\"+r;case"octal":return"\\"+r.toString(8);case"singleEscape":switch(r){case 8:return"\\b";case 9:return"\\t";case 10:return"\\n";case 11:return"\\v";case 12:return"\\f";case 13:return"\\r";default:throw Error("Invalid codepoint: "+r)}case"symbol":return a(r);case"unicodeEscape":return"\\u"+("0000"+r.toString(16).toUpperCase()).slice(-4);case"unicodeCodePointEscape":return"\\u{"+r.toString(16).toUpperCase()+"}";default:throw Error("Unsupported node kind: "+t)}}var S={function:!0,object:!0},_=S["undefined"==typeof window?"undefined":s(window)]&&window||this,D=S[s(t)]&&t,C=S[s(e)]&&e&&!e.nodeType&&e,w=D&&C&&"object"==(void 0===i?"undefined":s(i))&&i;!w||w.global!==w&&w.window!==w&&w.self!==w||(_=w);var P=String.fromCharCode,k=Math.floor;u.alternative=l,u.anchor=c,u.characterClass=p,u.characterClassEscape=d,u.characterClassRange=h,u.disjunction=y,u.dot=v,u.group=g,u.quantifier=b,u.reference=E,u.value=A,"object"==s(r(49))&&r(49)?void 0!==(n=function(){return{generate:u}}.call(t,r,t,e))&&(e.exports=n):D&&C?D.generate=u:_.regjsgen={generate:u}}).call(void 0)}).call(t,r(39)(e),function(){return this}())},function(e,t){"use strict";!function(){function t(e,t){function r(t){return t.raw=e.substring(t.range[0],t.range[1]),t}function n(e,t){return e.range[0]=t,r(e)}function i(e,t){return r({type:"anchor",kind:e,range:[$-t,$]})}function s(e,t,n,i){return r({type:"value",kind:e,codePoint:t,range:[n,i]})}function a(e,t,r,n){return n=n||0,s(e,t,$-(r.length+n),$)}function o(e){var t=e[0],r=t.charCodeAt(0);if(z){var n;if(1===t.length&&r>=55296&&r<=56319&&(n=x().charCodeAt(0))>=56320&&n<=57343)return $++,s("symbol",1024*(r-55296)+n-56320+65536,$-2,$)}return s("symbol",r,$-1,$)}function u(e,t,n){return r({type:"disjunction",body:e,range:[t,n]})}function l(){return r({type:"dot",range:[$-1,$]})}function c(e){return r({type:"characterClassEscape",value:e,range:[$-2,$]})}function f(e){return r({type:"reference",matchIndex:parseInt(e,10),range:[$-1-e.length,$]})}function p(e,t,n,i){return r({type:"group",behavior:e,body:t,range:[n,i]})}function d(e,t,n,i){return null==i&&(n=$-1,i=$),r({type:"quantifier",min:e,max:t,greedy:!0,body:null,range:[n,i]})}function h(e,t,n){return r({type:"alternative",body:e,range:[t,n]})}function m(e,t,n,i){return r({type:"characterClass",body:e,negative:t,range:[n,i]})}function y(e,t,n,i){return e.codePoint>t.codePoint&&K("invalid range in character class",e.raw+"-"+t.raw,n,i),r({type:"characterClassRange",min:e,max:t,range:[n,i]})}function v(e){return"alternative"===e.type?e.body:[e]}function g(t){t=t||1;var r=e.substring($,$+t);return $+=t||1,r}function b(e){E(e)||K("character",e)}function E(t){if(e.indexOf(t,$)===$)return g(t.length)}function x(){return e[$]}function A(t){return e.indexOf(t,$)===$}function S(t){return e[$+1]===t}function _(t){var r=e.substring($),n=r.match(t);return n&&(n.range=[],n.range[0]=$,g(n[0].length),n.range[1]=$),n}function D(){var e=[],t=$;for(e.push(C());E("|");)e.push(C());return 1===e.length?e[0]:u(e,t,$)}function C(){for(var e,t=[],r=$;e=w();)t.push(e);return 1===t.length?t[0]:h(t,r,$)}function w(){if($>=e.length||A("|")||A(")"))return null;var t=k();if(t)return t;var r=T();r||K("Expected atom");var i=F()||!1;return i?(i.body=v(r),n(i,r.range[0]),i):r}function P(e,t,r,n){var i=null,s=$;if(E(e))i=t;else{if(!E(r))return!1;i=n}var a=D();a||K("Expected disjunction"),b(")");var o=p(i,v(a),s,$);return"normal"==i&&X&&J++,o}function k(){return E("^")?i("start",1):E("$")?i("end",1):E("\\b")?i("boundary",2):E("\\B")?i("not-boundary",2):P("(?=","lookahead","(?!","negativeLookahead")}function F(){var e,t,r,n,i=$;return E("*")?t=d(0):E("+")?t=d(1):E("?")?t=d(0,1):(e=_(/^\{([0-9]+)\}/))?(r=parseInt(e[1],10),t=d(r,r,e.range[0],e.range[1])):(e=_(/^\{([0-9]+),\}/))?(r=parseInt(e[1],10),t=d(r,void 0,e.range[0],e.range[1])):(e=_(/^\{([0-9]+),([0-9]+)\}/))&&(r=parseInt(e[1],10),n=parseInt(e[2],10),r>n&&K("numbers out of order in {} quantifier","",i,$),t=d(r,n,e.range[0],e.range[1])),t&&E("?")&&(t.greedy=!1,t.range[1]+=1),t}function T(){var e;return(e=_(/^[^^$\\.*+?(){[|]/))?o(e):E(".")?l():E("\\")?(e=R(),e||K("atomEscape"),e):(e=j())?e:P("(?:","ignore","(","normal")}function O(e){if(z){var t,n;if("unicodeEscape"==e.kind&&(t=e.codePoint)>=55296&&t<=56319&&A("\\")&&S("u")){var i=$;$++;var s=B();"unicodeEscape"==s.kind&&(n=s.codePoint)>=56320&&n<=57343?(e.range[1]=s.range[1],e.codePoint=1024*(t-55296)+n-56320+65536,e.type="value",e.kind="unicodeCodePointEscape",r(e)):$=i}}return e}function B(){return R(!0)}function R(e){var t,r=$;if(t=I())return t;if(e){if(E("b"))return a("singleEscape",8,"\\b");E("B")&&K("\\B not possible inside of CharacterClass","",r)}return t=M()}function I(){var e,t;if(e=_(/^(?!0)\d+/)){t=e[0];var r=parseInt(e[0],10);return r<=J?f(e[0]):(H.push(r),g(-e[0].length),(e=_(/^[0-7]{1,3}/))?a("octal",parseInt(e[0],8),e[0],1):(e=o(_(/^[89]/)),n(e,e.range[0]-1)))}return(e=_(/^[0-7]{1,3}/))?(t=e[0],/^0{1,3}$/.test(t)?a("null",0,"0",t.length+1):a("octal",parseInt(t,8),t,1)):!!(e=_(/^[dDsSwW]/))&&c(e[0])}function M(){var e;if(e=_(/^[fnrtv]/)){var t=0;switch(e[0]){case"t":t=9;break;case"n":t=10;break;case"v":t=11;break;case"f":t=12;break;case"r":t=13}return a("singleEscape",t,"\\"+e[0])}return(e=_(/^c([a-zA-Z])/))?a("controlLetter",e[1].charCodeAt(0)%32,e[1],2):(e=_(/^x([0-9a-fA-F]{2})/))?a("hexadecimalEscape",parseInt(e[1],16),e[1],2):(e=_(/^u([0-9a-fA-F]{4})/))?O(a("unicodeEscape",parseInt(e[1],16),e[1],2)):z&&(e=_(/^u\{([0-9a-fA-F]+)\}/))?a("unicodeCodePointEscape",parseInt(e[1],16),e[1],4):L()}function N(e){var t=new RegExp("[--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]");return 36===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=48&&e<=57||92===e||e>=128&&t.test(String.fromCharCode(e))}function L(){var e;return N(x())?E("")?a("identifier",8204,""):E("")?a("identifier",8205,""):null:(e=g(),a("identifier",e.charCodeAt(0),e,1))}function j(){var e,t=$;return(e=_(/^\[\^/))?(e=U(),b("]"),m(e,!0,t,$)):E("[")?(e=U(),b("]"),m(e,!1,t,$)):null}function U(){var e;return A("]")?[]:(e=G(),e||K("nonEmptyClassRanges"),e)}function V(e){var t,r,n;if(A("-")&&!S("]")){b("-"),n=Y(),n||K("classAtom"),r=$;var i=U();return i||K("classRanges"),t=e.range[0],"empty"===i.type?[y(e,n,t,r)]:[y(e,n,t,r)].concat(i)}return n=W(),n||K("nonEmptyClassRangesNoDash"),[e].concat(n)}function G(){var e=Y();return e||K("classAtom"),A("]")?[e]:V(e)}function W(){var e=Y();return e||K("classAtom"),A("]")?e:V(e)}function Y(){return E("-")?o("-"):q()}function q(){var e;return(e=_(/^[^\\\]-]/))?o(e[0]):E("\\")?(e=B(),e||K("classEscape"),O(e)):void 0}function K(t,r,n,i){n=null==n?$:n,i=null==i?n:i;var s=Math.max(0,n-10),a=Math.min(i+10,e.length),o="    "+e.substring(s,a),u="    "+new Array(n-s+1).join(" ")+"^";throw SyntaxError(t+" at position "+n+(r?": "+r:"")+"\n"+o+"\n"+u)}var H=[],J=0,X=!0,z=-1!==(t||"").indexOf("u"),$=0;""===(e=String(e))&&(e="(?:)");var Q=D();Q.range[1]!==e.length&&K("Could not parse entire input - got stuck","",Q.range[1]);for(var Z=0;Z<H.length;Z++)if(H[Z]<=J)return $=0,X=!1,D();return Q}var r={parse:t};void 0!==e&&e.exports?e.exports=r:window.regjsparser=r}()},function(e,t,r){"use strict";var n=r(467);e.exports=function(e,t){if("string"!=typeof e)throw new TypeError("Expected `input` to be a string");if(t<0||!n(t))throw new TypeError("Expected `count` to be a positive finite number");var r="";do{1&t&&(r+=e),e+=e}while(t>>=1);return r}},function(e,t){"use strict";var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<r.length)return r[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1}},function(e,t){"use strict";function r(e,n,i,s,a,o){var u=Math.floor((n-e)/2)+e,l=a(i,s[u],!0);return 0===l?u:l>0?n-u>1?r(u,n,i,s,a,o):o==t.LEAST_UPPER_BOUND?n<s.length?n:-1:u:u-e>1?r(e,u,i,s,a,o):o==t.LEAST_UPPER_BOUND?u:e<0?-1:e}t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,n,i,s){if(0===n.length)return-1;var a=r(-1,n.length,e,n,i,s||t.GREATEST_LOWER_BOUND);if(a<0)return-1;for(;a-1>=0&&0===i(n[a],n[a-1],!0);)--a;return a}},function(e,t,r){"use strict";function n(e,t){var r=e.generatedLine,n=t.generatedLine,i=e.generatedColumn,a=t.generatedColumn;return n>r||n==r&&a>=i||s.compareByGeneratedPositionsInflated(e,t)<=0}function i(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}var s=r(63);i.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},i.prototype.add=function(e){n(this._last,e)?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},i.prototype.toArray=function(){return this._sorted||(this._array.sort(s.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.MappingList=i},function(e,t){"use strict";function r(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function n(e,t){return Math.round(e+Math.random()*(t-e))}function i(e,t,s,a){if(s<a){var o=n(s,a),u=s-1;r(e,o,a);for(var l=e[a],c=s;c<a;c++)t(e[c],l)<=0&&(u+=1,r(e,u,c));r(e,u+1,c);var f=u+1;i(e,t,s,f-1),i(e,t,f+1,a)}}t.quickSort=function(e,t){i(e,t,0,e.length-1)}},function(e,t,r){"use strict";function n(e){var t=e;return"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,""))),null!=t.sections?new a(t):new i(t)}function i(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=o.getArg(t,"version"),n=o.getArg(t,"sources"),i=o.getArg(t,"names",[]),s=o.getArg(t,"sourceRoot",null),a=o.getArg(t,"sourcesContent",null),u=o.getArg(t,"mappings"),c=o.getArg(t,"file",null);if(r!=this._version)throw new Error("Unsupported version: "+r);n=n.map(String).map(o.normalize).map(function(e){return s&&o.isAbsolute(s)&&o.isAbsolute(e)?o.relative(s,e):e}),this._names=l.fromArray(i.map(String),!0),this._sources=l.fromArray(n,!0),this.sourceRoot=s,this.sourcesContent=a,this._mappings=u,this.file=c}function s(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function a(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=o.getArg(t,"version"),i=o.getArg(t,"sections");if(r!=this._version)throw new Error("Unsupported version: "+r);this._sources=new l,this._names=new l;var s={line:-1,column:0};this._sections=i.map(function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var t=o.getArg(e,"offset"),r=o.getArg(t,"line"),i=o.getArg(t,"column");if(r<s.line||r===s.line&&i<s.column)throw new Error("Section offsets must be ordered and non-overlapping.");return s=t,{generatedOffset:{generatedLine:r+1,generatedColumn:i+1},consumer:new n(o.getArg(e,"map"))}})}var o=r(63),u=r(617),l=r(285).ArraySet,c=r(286),f=r(619).quickSort;n.fromSourceMap=function(e){return i.fromSourceMap(e)},n.prototype._version=3,n.prototype.__generatedMappings=null,Object.defineProperty(n.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),n.prototype.__originalMappings=null,Object.defineProperty(n.prototype,"_originalMappings",{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),n.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return";"===r||","===r},n.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},n.GENERATED_ORDER=1,n.ORIGINAL_ORDER=2,n.GREATEST_LOWER_BOUND=1,n.LEAST_UPPER_BOUND=2,n.prototype.eachMapping=function(e,t,r){var i,s=t||null,a=r||n.GENERATED_ORDER;switch(a){case n.GENERATED_ORDER:i=this._generatedMappings;break;case n.ORIGINAL_ORDER:i=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var u=this.sourceRoot;i.map(function(e){var t=null===e.source?null:this._sources.at(e.source);return null!=t&&null!=u&&(t=o.join(u,t)),{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}},this).forEach(e,s)},n.prototype.allGeneratedPositionsFor=function(e){var t=o.getArg(e,"line"),r={source:o.getArg(e,"source"),originalLine:t,originalColumn:o.getArg(e,"column",0)};if(null!=this.sourceRoot&&(r.source=o.relative(this.sourceRoot,r.source)),!this._sources.has(r.source))return[];r.source=this._sources.indexOf(r.source);var n=[],i=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,u.LEAST_UPPER_BOUND);if(i>=0){var s=this._originalMappings[i];if(void 0===e.column)for(var a=s.originalLine;s&&s.originalLine===a;)n.push({line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}),s=this._originalMappings[++i];else for(var l=s.originalColumn;s&&s.originalLine===t&&s.originalColumn==l;)n.push({line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}),s=this._originalMappings[++i]}return n},t.SourceMapConsumer=n,i.prototype=Object.create(n.prototype),i.prototype.consumer=n,i.fromSourceMap=function(e){var t=Object.create(i.prototype),r=t._names=l.fromArray(e._names.toArray(),!0),n=t._sources=l.fromArray(e._sources.toArray(),!0);t.sourceRoot=e._sourceRoot,t.sourcesContent=e._generateSourcesContent(t._sources.toArray(),t.sourceRoot),t.file=e._file;for(var a=e._mappings.toArray().slice(),u=t.__generatedMappings=[],c=t.__originalMappings=[],p=0,d=a.length;p<d;p++){var h=a[p],m=new s;m.generatedLine=h.generatedLine,m.generatedColumn=h.generatedColumn,h.source&&(m.source=n.indexOf(h.source),m.originalLine=h.originalLine,m.originalColumn=h.originalColumn,h.name&&(m.name=r.indexOf(h.name)),c.push(m)),u.push(m)}return f(t.__originalMappings,o.compareByOriginalPositions),t},i.prototype._version=3,Object.defineProperty(i.prototype,"sources",{get:function(){return this._sources.toArray().map(function(e){return null!=this.sourceRoot?o.join(this.sourceRoot,e):e},this)}}),i.prototype._parseMappings=function(e,t){for(var r,n,i,a,u,l=1,p=0,d=0,h=0,m=0,y=0,v=e.length,g=0,b={},E={},x=[],A=[];g<v;)if(";"===e.charAt(g))l++,g++,p=0;else if(","===e.charAt(g))g++;else{for(r=new s,r.generatedLine=l,a=g;a<v&&!this._charIsMappingSeparator(e,a);a++);if(n=e.slice(g,a),i=b[n])g+=n.length;else{for(i=[];g<a;)c.decode(e,g,E),u=E.value,g=E.rest,i.push(u);if(2===i.length)throw new Error("Found a source, but no line and column");if(3===i.length)throw new Error("Found a source and line, but no column");b[n]=i}r.generatedColumn=p+i[0],p=r.generatedColumn,i.length>1&&(r.source=m+i[1],m+=i[1],r.originalLine=d+i[2],d=r.originalLine,r.originalLine+=1,r.originalColumn=h+i[3],h=r.originalColumn,i.length>4&&(r.name=y+i[4],y+=i[4])),A.push(r),"number"==typeof r.originalLine&&x.push(r)}f(A,o.compareByGeneratedPositionsDeflated),this.__generatedMappings=A,f(x,o.compareByOriginalPositions),this.__originalMappings=x},i.prototype._findMapping=function(e,t,r,n,i,s){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[n]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[n]);return u.search(e,t,i,s)},i.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},i.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",o.compareByGeneratedPositionsDeflated,o.getArg(e,"bias",n.GREATEST_LOWER_BOUND));if(r>=0){var i=this._generatedMappings[r];if(i.generatedLine===t.generatedLine){var s=o.getArg(i,"source",null);null!==s&&(s=this._sources.at(s),null!=this.sourceRoot&&(s=o.join(this.sourceRoot,s)));var a=o.getArg(i,"name",null);return null!==a&&(a=this._names.at(a)),{source:s,line:o.getArg(i,"originalLine",null),column:o.getArg(i,"originalColumn",null),name:a}}}return{source:null,line:null,column:null,name:null}},i.prototype.hasContentsOfAllSources=function(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return null==e}))},i.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(e=o.relative(this.sourceRoot,e)),this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];var r;if(null!=this.sourceRoot&&(r=o.urlParse(this.sourceRoot))){var n=e.replace(/^file:\/\//,"");if("file"==r.scheme&&this._sources.has(n))return this.sourcesContent[this._sources.indexOf(n)];if((!r.path||"/"==r.path)&&this._sources.has("/"+e))return this.sourcesContent[this._sources.indexOf("/"+e)]}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},i.prototype.generatedPositionFor=function(e){var t=o.getArg(e,"source");if(null!=this.sourceRoot&&(t=o.relative(this.sourceRoot,t)),!this._sources.has(t))return{line:null,column:null,lastColumn:null};t=this._sources.indexOf(t);var r={source:t,originalLine:o.getArg(e,"line"),originalColumn:o.getArg(e,"column")},i=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,o.getArg(e,"bias",n.GREATEST_LOWER_BOUND));if(i>=0){var s=this._originalMappings[i];if(s.source===r.source)return{line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},t.BasicSourceMapConsumer=i,a.prototype=Object.create(n.prototype),a.prototype.constructor=n,a.prototype._version=3,Object.defineProperty(a.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),a.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=u.search(t,this._sections,function(e,t){var r=e.generatedLine-t.generatedOffset.generatedLine;return r||e.generatedColumn-t.generatedOffset.generatedColumn}),n=this._sections[r];return n?n.consumer.originalPositionFor({line:t.generatedLine-(n.generatedOffset.generatedLine-1),column:t.generatedColumn-(n.generatedOffset.generatedLine===t.generatedLine?n.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},a.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})},a.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var n=this._sections[r],i=n.consumer.sourceContentFor(e,!0);if(i)return i}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},a.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer.sources.indexOf(o.getArg(e,"source"))){var n=r.consumer.generatedPositionFor(e);if(n){return{line:n.line+(r.generatedOffset.generatedLine-1),column:n.column+(r.generatedOffset.generatedLine===n.line?r.generatedOffset.generatedColumn-1:0)}}}}return{line:null,column:null}},a.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var n=this._sections[r],i=n.consumer._generatedMappings,s=0;s<i.length;s++){var a=i[s],u=n.consumer._sources.at(a.source);null!==n.consumer.sourceRoot&&(u=o.join(n.consumer.sourceRoot,u)),this._sources.add(u),u=this._sources.indexOf(u);var l=n.consumer._names.at(a.name);this._names.add(l),l=this._names.indexOf(l);var c={source:u,generatedLine:a.generatedLine+(n.generatedOffset.generatedLine-1),generatedColumn:a.generatedColumn+(n.generatedOffset.generatedLine===a.generatedLine?n.generatedOffset.generatedColumn-1:0),originalLine:a.originalLine,originalColumn:a.originalColumn,name:l};this.__generatedMappings.push(c),"number"==typeof c.originalLine&&this.__originalMappings.push(c)}f(this.__generatedMappings,o.compareByGeneratedPositionsDeflated),f(this.__originalMappings,o.compareByOriginalPositions)},t.IndexedSourceMapConsumer=a},function(e,t,r){"use strict";function n(e,t,r,n,i){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==i?null:i,this[o]=!0,null!=n&&this.add(n)}var i=r(287).SourceMapGenerator,s=r(63),a=/(\r?\n)/,o="$$$isSourceNode$$$";n.fromStringWithSourceMap=function(e,t,r){function i(e,t){if(null===e||void 0===e.source)o.add(t);else{var i=r?s.join(r,e.source):e.source;o.add(new n(e.originalLine,e.originalColumn,i,t,e.name))}}var o=new n,u=e.split(a),l=function(){return u.shift()+(u.shift()||"")},c=1,f=0,p=null;return t.eachMapping(function(e){if(null!==p){if(!(c<e.generatedLine)){var t=u[0],r=t.substr(0,e.generatedColumn-f);return u[0]=t.substr(e.generatedColumn-f),f=e.generatedColumn,i(p,r),void(p=e)}i(p,l()),c++,f=0}for(;c<e.generatedLine;)o.add(l()),c++;if(f<e.generatedColumn){var t=u[0];o.add(t.substr(0,e.generatedColumn)),u[0]=t.substr(e.generatedColumn),f=e.generatedColumn}p=e},this),u.length>0&&(p&&i(p,l()),o.add(u.join(""))),t.sources.forEach(function(e){var n=t.sourceContentFor(e);null!=n&&(null!=r&&(e=s.join(r,e)),o.setSourceContent(e,n))}),o},n.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},n.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},n.prototype.walk=function(e){for(var t,r=0,n=this.children.length;r<n;r++)t=this.children[r],t[o]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},n.prototype.join=function(e){var t,r,n=this.children.length;if(n>0){for(t=[],r=0;r<n-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},n.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[o]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},n.prototype.setSourceContent=function(e,t){this.sourceContents[s.toSetString(e)]=t},n.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][o]&&this.children[t].walkSourceContents(e);for(var n=Object.keys(this.sourceContents),t=0,r=n.length;t<r;t++)e(s.fromSetString(n[t]),this.sourceContents[n[t]])},n.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},n.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new i(e),n=!1,s=null,a=null,o=null,u=null;return this.walk(function(e,i){t.code+=e,null!==i.source&&null!==i.line&&null!==i.column?(s===i.source&&a===i.line&&o===i.column&&u===i.name||r.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name}),s=i.source,a=i.line,o=i.column,u=i.name,n=!0):n&&(r.addMapping({generated:{line:t.line,column:t.column}}),s=null,n=!1);for(var l=0,c=e.length;l<c;l++)10===e.charCodeAt(l)?(t.line++,t.column=0,l+1===c?(s=null,n=!1):n&&r.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}},t.SourceNode=n},function(e,t,r){"use strict";var n=r(180)();e.exports=function(e){return"string"==typeof e?e.replace(n,""):e}},function(e,t,r){(function(t){"use strict";var r=t.argv,n=r.indexOf("--"),i=function(e){e="--"+e;var t=r.indexOf(e);return-1!==t&&(-1===n||t<n)};e.exports=function(){return"FORCE_COLOR"in t.env||!(i("no-color")||i("no-colors")||i("color=false"))&&(!!(i("color")||i("colors")||i("color=true")||i("color=always"))||!(t.stdout&&!t.stdout.isTTY)&&("win32"===t.platform||("COLORTERM"in t.env||"dumb"!==t.env.TERM&&!!/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(t.env.TERM))))}()}).call(t,r(8))},function(e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=function e(t){function n(){}function i(){return r(s.foo)}n.prototype=t;var s=new n;return i(),i(),t}},function(e,t){"use strict";e.exports=function(e){for(var t=e.length;/[\s\uFEFF\u00A0]/.test(e[t-1]);)t--;return e.slice(0,t)}},function(e,t){"use strict";"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},function(e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};e.exports=function(e){return e&&"object"===(void 0===e?"undefined":r(e))&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.version="6.26.0"},function(e,t){"use strict";function r(e,t){var r=void 0;return null!=t.url?r=t.url:(r="Inline Babel script",++p>1&&(r+=" ("+p+")")),e(t.content,l({filename:r},n(t))).code}function n(e){return{presets:e.presets||["react","es2015"],plugins:e.plugins||["transform-class-properties","transform-object-rest-spread","transform-flow-strip-types"],sourceMaps:"inline"}}function i(e,t){var n=document.createElement("script");n.text=r(e,t),f.appendChild(n)}function s(e,t,r){var n=new XMLHttpRequest;return n.open("GET",e,!0),"overrideMimeType"in n&&n.overrideMimeType("text/plain"),n.onreadystatechange=function(){if(4===n.readyState){if(0!==n.status&&200!==n.status)throw r(),new Error("Could not load "+e);t(n.responseText)}},n.send(null)}function a(e,t){var r=e.getAttribute(t);return""===r?[]:r?r.split(",").map(function(e){return e.trim()}):null}function o(e,t){function r(){var t,r;for(r=0;r<o;r++)if(t=n[r],t.loaded&&!t.executed)t.executed=!0,i(e,t);else if(!t.loaded&&!t.error&&!t.async)break}var n=[],o=t.length;t.forEach(function(e,t){var i={async:e.hasAttribute("async"),error:!1,executed:!1,plugins:a(e,"data-plugins"),presets:a(e,"data-presets")};e.src?(n[t]=l({},i,{content:null,loaded:!1,url:e.src}),s(e.src,function(e){n[t].loaded=!0,n[t].content=e,r()},function(){n[t].error=!0,r()})):n[t]=l({},i,{content:e.innerHTML,loaded:!0,url:null})}),r()}function u(e,t){f=document.getElementsByTagName("head")[0],t||(t=document.getElementsByTagName("script"));for(var r=[],n=0;n<t.length;n++){var i=t.item(n),s=i.type.split(";")[0];-1!==c.indexOf(s)&&r.push(i)}0!==r.length&&(console.warn("You are using the in-browser Babel transformer. Be sure to precompile your scripts for production - https://babeljs.io/docs/setup/"),o(e,r))}Object.defineProperty(t,"__esModule",{value:!0});var l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};t.runScripts=u;var c=["text/jsx","text/babel"],f=void 0,p=0},function(e,t){e.exports={builtin:{Array:!1,ArrayBuffer:!1,Boolean:!1,constructor:!1,DataView:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,escape:!1,eval:!1,EvalError:!1,Float32Array:!1,Float64Array:!1,Function:!1,hasOwnProperty:!1,Infinity:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,isFinite:!1,isNaN:!1,isPrototypeOf:!1,JSON:!1,Map:!1,Math:!1,NaN:!1,Number:!1,Object:!1,parseFloat:!1,parseInt:!1,Promise:!1,propertyIsEnumerable:!1,Proxy:!1,RangeError:!1,ReferenceError:!1,Reflect:!1,RegExp:!1,Set:!1,String:!1,Symbol:!1,SyntaxError:!1,System:!1,toLocaleString:!1,toString:!1,TypeError:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1,undefined:!1,unescape:!1,URIError:!1,
valueOf:!1,WeakMap:!1,WeakSet:!1},es5:{Array:!1,Boolean:!1,constructor:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,escape:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,Infinity:!1,isFinite:!1,isNaN:!1,isPrototypeOf:!1,JSON:!1,Math:!1,NaN:!1,Number:!1,Object:!1,parseFloat:!1,parseInt:!1,propertyIsEnumerable:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,toLocaleString:!1,toString:!1,TypeError:!1,undefined:!1,unescape:!1,URIError:!1,valueOf:!1},es6:{Array:!1,ArrayBuffer:!1,Boolean:!1,constructor:!1,DataView:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,escape:!1,eval:!1,EvalError:!1,Float32Array:!1,Float64Array:!1,Function:!1,hasOwnProperty:!1,Infinity:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,isFinite:!1,isNaN:!1,isPrototypeOf:!1,JSON:!1,Map:!1,Math:!1,NaN:!1,Number:!1,Object:!1,parseFloat:!1,parseInt:!1,Promise:!1,propertyIsEnumerable:!1,Proxy:!1,RangeError:!1,ReferenceError:!1,Reflect:!1,RegExp:!1,Set:!1,String:!1,Symbol:!1,SyntaxError:!1,System:!1,toLocaleString:!1,toString:!1,TypeError:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1,undefined:!1,unescape:!1,URIError:!1,valueOf:!1,WeakMap:!1,WeakSet:!1},browser:{addEventListener:!1,alert:!1,AnalyserNode:!1,Animation:!1,AnimationEffectReadOnly:!1,AnimationEffectTiming:!1,AnimationEffectTimingReadOnly:!1,AnimationEvent:!1,AnimationPlaybackEvent:!1,AnimationTimeline:!1,applicationCache:!1,ApplicationCache:!1,ApplicationCacheErrorEvent:!1,atob:!1,Attr:!1,Audio:!1,AudioBuffer:!1,AudioBufferSourceNode:!1,AudioContext:!1,AudioDestinationNode:!1,AudioListener:!1,AudioNode:!1,AudioParam:!1,AudioProcessingEvent:!1,AutocompleteErrorEvent:!1,BarProp:!1,BatteryManager:!1,BeforeUnloadEvent:!1,BiquadFilterNode:!1,Blob:!1,blur:!1,btoa:!1,Cache:!1,caches:!1,CacheStorage:!1,cancelAnimationFrame:!1,cancelIdleCallback:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,CDATASection:!1,ChannelMergerNode:!1,ChannelSplitterNode:!1,CharacterData:!1,clearInterval:!1,clearTimeout:!1,clientInformation:!1,ClientRect:!1,ClientRectList:!1,ClipboardEvent:!1,close:!1,closed:!1,CloseEvent:!1,Comment:!1,CompositionEvent:!1,confirm:!1,console:!1,ConvolverNode:!1,createImageBitmap:!1,Credential:!1,CredentialsContainer:!1,crypto:!1,Crypto:!1,CryptoKey:!1,CSS:!1,CSSAnimation:!1,CSSFontFaceRule:!1,CSSImportRule:!1,CSSKeyframeRule:!1,CSSKeyframesRule:!1,CSSMediaRule:!1,CSSPageRule:!1,CSSRule:!1,CSSRuleList:!1,CSSStyleDeclaration:!1,CSSStyleRule:!1,CSSStyleSheet:!1,CSSSupportsRule:!1,CSSTransition:!1,CSSUnknownRule:!1,CSSViewportRule:!1,customElements:!1,CustomEvent:!1,DataTransfer:!1,DataTransferItem:!1,DataTransferItemList:!1,Debug:!1,defaultStatus:!1,defaultstatus:!1,DelayNode:!1,DeviceMotionEvent:!1,DeviceOrientationEvent:!1,devicePixelRatio:!1,dispatchEvent:!1,document:!1,Document:!1,DocumentFragment:!1,DocumentTimeline:!1,DocumentType:!1,DOMError:!1,DOMException:!1,DOMImplementation:!1,DOMParser:!1,DOMSettableTokenList:!1,DOMStringList:!1,DOMStringMap:!1,DOMTokenList:!1,DragEvent:!1,DynamicsCompressorNode:!1,Element:!1,ElementTimeControl:!1,ErrorEvent:!1,event:!1,Event:!1,EventSource:!1,EventTarget:!1,external:!1,FederatedCredential:!1,fetch:!1,File:!1,FileError:!1,FileList:!1,FileReader:!1,find:!1,focus:!1,FocusEvent:!1,FontFace:!1,FormData:!1,frameElement:!1,frames:!1,GainNode:!1,Gamepad:!1,GamepadButton:!1,GamepadEvent:!1,getComputedStyle:!1,getSelection:!1,HashChangeEvent:!1,Headers:!1,history:!1,History:!1,HTMLAllCollection:!1,HTMLAnchorElement:!1,HTMLAppletElement:!1,HTMLAreaElement:!1,HTMLAudioElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLCollection:!1,HTMLContentElement:!1,HTMLDataListElement:!1,HTMLDetailsElement:!1,HTMLDialogElement:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLDocument:!1,HTMLElement:!1,HTMLEmbedElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormControlsCollection:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLKeygenElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMarqueeElement:!1,HTMLMediaElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLMeterElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLOptionsCollection:!1,HTMLOutputElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPictureElement:!1,HTMLPreElement:!1,HTMLProgressElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLShadowElement:!1,HTMLSourceElement:!1,HTMLSpanElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTemplateElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLTrackElement:!1,HTMLUListElement:!1,HTMLUnknownElement:!1,HTMLVideoElement:!1,IDBCursor:!1,IDBCursorWithValue:!1,IDBDatabase:!1,IDBEnvironment:!1,IDBFactory:!1,IDBIndex:!1,IDBKeyRange:!1,IDBObjectStore:!1,IDBOpenDBRequest:!1,IDBRequest:!1,IDBTransaction:!1,IDBVersionChangeEvent:!1,Image:!1,ImageBitmap:!1,ImageData:!1,indexedDB:!1,innerHeight:!1,innerWidth:!1,InputEvent:!1,InputMethodContext:!1,IntersectionObserver:!1,IntersectionObserverEntry:!1,Intl:!1,KeyboardEvent:!1,KeyframeEffect:!1,KeyframeEffectReadOnly:!1,length:!1,localStorage:!1,location:!1,Location:!1,locationbar:!1,matchMedia:!1,MediaElementAudioSourceNode:!1,MediaEncryptedEvent:!1,MediaError:!1,MediaKeyError:!1,MediaKeyEvent:!1,MediaKeyMessageEvent:!1,MediaKeys:!1,MediaKeySession:!1,MediaKeyStatusMap:!1,MediaKeySystemAccess:!1,MediaList:!1,MediaQueryList:!1,MediaQueryListEvent:!1,MediaSource:!1,MediaRecorder:!1,MediaStream:!1,MediaStreamAudioDestinationNode:!1,MediaStreamAudioSourceNode:!1,MediaStreamEvent:!1,MediaStreamTrack:!1,menubar:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MIDIAccess:!1,MIDIConnectionEvent:!1,MIDIInput:!1,MIDIInputMap:!1,MIDIMessageEvent:!1,MIDIOutput:!1,MIDIOutputMap:!1,MIDIPort:!1,MimeType:!1,MimeTypeArray:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationEvent:!1,MutationObserver:!1,MutationRecord:!1,name:!1,NamedNodeMap:!1,navigator:!1,Navigator:!1,Node:!1,NodeFilter:!1,NodeIterator:!1,NodeList:!1,Notification:!1,OfflineAudioCompletionEvent:!1,OfflineAudioContext:!1,offscreenBuffering:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,opera:!1,Option:!1,OscillatorNode:!1,outerHeight:!1,outerWidth:!1,PageTransitionEvent:!1,pageXOffset:!1,pageYOffset:!1,parent:!1,PasswordCredential:!1,Path2D:!1,performance:!1,Performance:!1,PerformanceEntry:!1,PerformanceMark:!1,PerformanceMeasure:!1,PerformanceNavigation:!1,PerformanceResourceTiming:!1,PerformanceTiming:!1,PeriodicWave:!1,Permissions:!1,PermissionStatus:!1,personalbar:!1,Plugin:!1,PluginArray:!1,PopStateEvent:!1,postMessage:!1,print:!1,ProcessingInstruction:!1,ProgressEvent:!1,PromiseRejectionEvent:!1,prompt:!1,PushManager:!1,PushSubscription:!1,RadioNodeList:!1,Range:!1,ReadableByteStream:!1,ReadableStream:!1,removeEventListener:!1,Request:!1,requestAnimationFrame:!1,requestIdleCallback:!1,resizeBy:!1,resizeTo:!1,Response:!1,RTCIceCandidate:!1,RTCSessionDescription:!1,RTCPeerConnection:!1,screen:!1,Screen:!1,screenLeft:!1,ScreenOrientation:!1,screenTop:!1,screenX:!1,screenY:!1,ScriptProcessorNode:!1,scroll:!1,scrollbars:!1,scrollBy:!1,scrollTo:!1,scrollX:!1,scrollY:!1,SecurityPolicyViolationEvent:!1,Selection:!1,self:!1,ServiceWorker:!1,ServiceWorkerContainer:!1,ServiceWorkerRegistration:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,ShadowRoot:!1,SharedKeyframeList:!1,SharedWorker:!1,showModalDialog:!1,SiteBoundCredential:!1,speechSynthesis:!1,SpeechSynthesisEvent:!1,SpeechSynthesisUtterance:!1,status:!1,statusbar:!1,stop:!1,Storage:!1,StorageEvent:!1,styleMedia:!1,StyleSheet:!1,StyleSheetList:!1,SubtleCrypto:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimationElement:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCSSRule:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDiscardElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGEvent:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEDropShadowElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGeometryElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGGraphicsElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLinearGradientElement:!1,SVGLineElement:!1,SVGLocatable:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGMPathElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSVGElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformable:!1,SVGTransformList:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGUnitTypes:!1,SVGURIReference:!1,SVGUseElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGVKernElement:!1,SVGZoomAndPan:!1,SVGZoomEvent:!1,Text:!1,TextDecoder:!1,TextEncoder:!1,TextEvent:!1,TextMetrics:!1,TextTrack:!1,TextTrackCue:!1,TextTrackCueList:!1,TextTrackList:!1,TimeEvent:!1,TimeRanges:!1,toolbar:!1,top:!1,Touch:!1,TouchEvent:!1,TouchList:!1,TrackEvent:!1,TransitionEvent:!1,TreeWalker:!1,UIEvent:!1,URL:!1,URLSearchParams:!1,ValidityState:!1,VTTCue:!1,WaveShaperNode:!1,WebGLActiveInfo:!1,WebGLBuffer:!1,WebGLContextEvent:!1,WebGLFramebuffer:!1,WebGLProgram:!1,WebGLRenderbuffer:!1,WebGLRenderingContext:!1,WebGLShader:!1,WebGLShaderPrecisionFormat:!1,WebGLTexture:!1,WebGLUniformLocation:!1,WebSocket:!1,WheelEvent:!1,window:!1,Window:!1,Worker:!1,XDomainRequest:!1,XMLDocument:!1,XMLHttpRequest:!1,XMLHttpRequestEventTarget:!1,XMLHttpRequestProgressEvent:!1,XMLHttpRequestUpload:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1,XSLTProcessor:!1},worker:{applicationCache:!1,atob:!1,Blob:!1,BroadcastChannel:!1,btoa:!1,Cache:!1,caches:!1,clearInterval:!1,clearTimeout:!1,close:!0,console:!1,fetch:!1,FileReaderSync:!1,FormData:!1,Headers:!1,IDBCursor:!1,IDBCursorWithValue:!1,IDBDatabase:!1,IDBFactory:!1,IDBIndex:!1,IDBKeyRange:!1,IDBObjectStore:!1,IDBOpenDBRequest:!1,IDBRequest:!1,IDBTransaction:!1,IDBVersionChangeEvent:!1,ImageData:!1,importScripts:!0,indexedDB:!1,location:!1,MessageChannel:!1,MessagePort:!1,name:!1,navigator:!1,Notification:!1,onclose:!0,onconnect:!0,onerror:!0,onlanguagechange:!0,onmessage:!0,onoffline:!0,ononline:!0,onrejectionhandled:!0,onunhandledrejection:!0,performance:!1,Performance:!1,PerformanceEntry:!1,PerformanceMark:!1,PerformanceMeasure:!1,PerformanceNavigation:!1,PerformanceResourceTiming:!1,PerformanceTiming:!1,postMessage:!0,Promise:!1,Request:!1,Response:!1,self:!0,ServiceWorkerRegistration:!1,setInterval:!1,setTimeout:!1,TextDecoder:!1,TextEncoder:!1,URL:!1,URLSearchParams:!1,WebSocket:!1,Worker:!1,XMLHttpRequest:!1},node:{__dirname:!1,__filename:!1,arguments:!1,Buffer:!1,clearImmediate:!1,clearInterval:!1,clearTimeout:!1,console:!1,exports:!0,GLOBAL:!1,global:!1,Intl:!1,module:!1,process:!1,require:!1,root:!1,setImmediate:!1,setInterval:!1,setTimeout:!1},commonjs:{exports:!0,module:!1,require:!1,global:!1},amd:{define:!1,require:!1},mocha:{after:!1,afterEach:!1,before:!1,beforeEach:!1,context:!1,describe:!1,it:!1,mocha:!1,run:!1,setup:!1,specify:!1,suite:!1,suiteSetup:!1,suiteTeardown:!1,teardown:!1,test:!1,xcontext:!1,xdescribe:!1,xit:!1,xspecify:!1},jasmine:{afterAll:!1,afterEach:!1,beforeAll:!1,beforeEach:!1,describe:!1,expect:!1,fail:!1,fdescribe:!1,fit:!1,it:!1,jasmine:!1,pending:!1,runs:!1,spyOn:!1,spyOnProperty:!1,waits:!1,waitsFor:!1,xdescribe:!1,xit:!1},jest:{afterAll:!1,afterEach:!1,beforeAll:!1,beforeEach:!1,check:!1,describe:!1,expect:!1,gen:!1,it:!1,fdescribe:!1,fit:!1,jest:!1,pit:!1,require:!1,test:!1,xdescribe:!1,xit:!1,xtest:!1},qunit:{asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notOk:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,throws:!1},phantomjs:{console:!0,exports:!0,phantom:!0,require:!0,WebPage:!0},couch:{emit:!1,exports:!1,getRow:!1,log:!1,module:!1,provides:!1,require:!1,respond:!1,send:!1,start:!1,sum:!1},rhino:{defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},nashorn:{__DIR__:!1,__FILE__:!1,__LINE__:!1,com:!1,edu:!1,exit:!1,Java:!1,java:!1,javafx:!1,JavaImporter:!1,javax:!1,JSAdapter:!1,load:!1,loadWithNewGlobal:!1,org:!1,Packages:!1,print:!1,quit:!1},wsh:{ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WScript:!0,WSH:!0,XDomainRequest:!0},jquery:{$:!1,jQuery:!1},yui:{Y:!1,YUI:!1,YUI_config:!1},shelljs:{cat:!1,cd:!1,chmod:!1,config:!1,cp:!1,dirs:!1,echo:!1,env:!1,error:!1,exec:!1,exit:!1,find:!1,grep:!1,ls:!1,ln:!1,mkdir:!1,mv:!1,popd:!1,pushd:!1,pwd:!1,rm:!1,sed:!1,set:!1,target:!1,tempdir:!1,test:!1,touch:!1,which:!1},prototypejs:{$:!1,$$:!1,$A:!1,$break:!1,$continue:!1,$F:!1,$H:!1,$R:!1,$w:!1,Abstract:!1,Ajax:!1,Autocompleter:!1,Builder:!1,Class:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Element:!1,Enumerable:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Scriptaculous:!1,Selector:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Template:!1,Toggle:!1,Try:!1},meteor:{$:!1,_:!1,Accounts:!1,AccountsClient:!1,AccountsServer:!1,AccountsCommon:!1,App:!1,Assets:!1,Blaze:!1,check:!1,Cordova:!1,DDP:!1,DDPServer:!1,DDPRateLimiter:!1,Deps:!1,EJSON:!1,Email:!1,HTTP:!1,Log:!1,Match:!1,Meteor:!1,Mongo:!1,MongoInternals:!1,Npm:!1,Package:!1,Plugin:!1,process:!1,Random:!1,ReactiveDict:!1,ReactiveVar:!1,Router:!1,ServiceConfiguration:!1,Session:!1,share:!1,Spacebars:!1,Template:!1,Tinytest:!1,Tracker:!1,UI:!1,Utils:!1,WebApp:!1,WebAppInternals:!1},mongo:{_isWindows:!1,_rand:!1,BulkWriteResult:!1,cat:!1,cd:!1,connect:!1,db:!1,getHostName:!1,getMemInfo:!1,hostname:!1,ISODate:!1,listFiles:!1,load:!1,ls:!1,md5sumFile:!1,mkdir:!1,Mongo:!1,NumberInt:!1,NumberLong:!1,ObjectId:!1,PlanCache:!1,print:!1,printjson:!1,pwd:!1,quit:!1,removeFile:!1,rs:!1,sh:!1,UUID:!1,version:!1,WriteResult:!1},applescript:{$:!1,Application:!1,Automation:!1,console:!1,delay:!1,Library:!1,ObjC:!1,ObjectSpecifier:!1,Path:!1,Progress:!1,Ref:!1},serviceworker:{caches:!1,Cache:!1,CacheStorage:!1,Client:!1,clients:!1,Clients:!1,ExtendableEvent:!1,ExtendableMessageEvent:!1,FetchEvent:!1,importScripts:!1,registration:!1,self:!1,ServiceWorker:!1,ServiceWorkerContainer:!1,ServiceWorkerGlobalScope:!1,ServiceWorkerMessageEvent:!1,ServiceWorkerRegistration:!1,skipWaiting:!1,WindowClient:!1},atomtest:{advanceClock:!1,fakeClearInterval:!1,fakeClearTimeout:!1,fakeSetInterval:!1,fakeSetTimeout:!1,resetTimeouts:!1,waitsForPromise:!1},embertest:{andThen:!1,click:!1,currentPath:!1,currentRouteName:!1,currentURL:!1,fillIn:!1,find:!1,findWithAssert:!1,keyEvent:!1,pauseTest:!1,resumeTest:!1,triggerEvent:!1,visit:!1},protractor:{$:!1,$$:!1,browser:!1,By:!1,by:!1,DartObject:!1,element:!1,protractor:!1},"shared-node-browser":{clearInterval:!1,clearTimeout:!1,console:!1,setInterval:!1,setTimeout:!1},webextensions:{browser:!1,chrome:!1,opr:!1},greasemonkey:{GM_addStyle:!1,GM_deleteValue:!1,GM_getResourceText:!1,GM_getResourceURL:!1,GM_getValue:!1,GM_info:!1,GM_listValues:!1,GM_log:!1,GM_openInTab:!1,GM_registerMenuCommand:!1,GM_setClipboard:!1,GM_setValue:!1,GM_xmlhttpRequest:!1,unsafeWindow:!1}}},function(e,t){e.exports={75:8490,83:383,107:8490,115:383,181:924,197:8491,383:83,452:453,453:452,455:456,456:455,458:459,459:458,497:498,498:497,837:8126,914:976,917:1013,920:1012,921:8126,922:1008,924:181,928:982,929:1009,931:962,934:981,937:8486,962:931,976:914,977:1012,981:934,982:928,1008:922,1009:929,1012:[920,977],1013:917,7776:7835,7835:7776,8126:[837,921],8486:937,8490:75,8491:197,66560:66600,66561:66601,66562:66602,66563:66603,66564:66604,66565:66605,66566:66606,66567:66607,66568:66608,66569:66609,66570:66610,66571:66611,66572:66612,66573:66613,66574:66614,66575:66615,66576:66616,66577:66617,66578:66618,66579:66619,66580:66620,66581:66621,66582:66622,66583:66623,66584:66624,66585:66625,66586:66626,66587:66627,66588:66628,66589:66629,66590:66630,66591:66631,66592:66632,66593:66633,66594:66634,66595:66635,66596:66636,66597:66637,66598:66638,66599:66639,66600:66560,66601:66561,66602:66562,66603:66563,66604:66564,66605:66565,66606:66566,66607:66567,66608:66568,66609:66569,66610:66570,66611:66571,66612:66572,66613:66573,66614:66574,66615:66575,66616:66576,66617:66577,66618:66578,66619:66579,66620:66580,66621:66581,66622:66582,66623:66583,66624:66584,66625:66585,66626:66586,66627:66587,66628:66588,66629:66589,66630:66590,66631:66591,66632:66592,66633:66593,66634:66594,66635:66595,66636:66596,66637:66597,66638:66598,66639:66599,68736:68800,68737:68801,68738:68802,68739:68803,68740:68804,68741:68805,68742:68806,68743:68807,68744:68808,68745:68809,68746:68810,68747:68811,68748:68812,68749:68813,68750:68814,68751:68815,68752:68816,68753:68817,68754:68818,68755:68819,68756:68820,68757:68821,68758:68822,68759:68823,68760:68824,68761:68825,68762:68826,68763:68827,68764:68828,68765:68829,68766:68830,68767:68831,68768:68832,68769:68833,68770:68834,68771:68835,68772:68836,68773:68837,68774:68838,68775:68839,68776:68840,68777:68841,68778:68842,68779:68843,68780:68844,68781:68845,68782:68846,68783:68847,68784:68848,68785:68849,68786:68850,68800:68736,68801:68737,68802:68738,68803:68739,68804:68740,68805:68741,68806:68742,68807:68743,68808:68744,68809:68745,68810:68746,68811:68747,68812:68748,68813:68749,68814:68750,68815:68751,68816:68752,68817:68753,68818:68754,68819:68755,68820:68756,68821:68757,68822:68758,68823:68759,68824:68760,68825:68761,68826:68762,68827:68763,68828:68764,68829:68765,68830:68766,68831:68767,68832:68768,68833:68769,68834:68770,68835:68771,68836:68772,68837:68773,68838:68774,68839:68775,68840:68776,68841:68777,68842:68778,68843:68779,68844:68780,68845:68781,68846:68782,68847:68783,68848:68784,68849:68785,68850:68786,71840:71872,71841:71873,71842:71874,71843:71875,71844:71876,71845:71877,71846:71878,71847:71879,71848:71880,71849:71881,71850:71882,71851:71883,71852:71884,71853:71885,71854:71886,71855:71887,71856:71888,71857:71889,71858:71890,71859:71891,71860:71892,71861:71893,71862:71894,71863:71895,71864:71896,71865:71897,71866:71898,71867:71899,71868:71900,71869:71901,71870:71902,71871:71903,71872:71840,71873:71841,71874:71842,71875:71843,71876:71844,71877:71845,71878:71846,71879:71847,71880:71848,71881:71849,71882:71850,71883:71851,71884:71852,71885:71853,71886:71854,71887:71855,71888:71856,71889:71857,71890:71858,71891:71859,71892:71860,71893:71861,71894:71862,71895:71863,71896:71864,71897:71865,71898:71866,71899:71867,71900:71868,71901:71869,71902:71870,71903:71871}}]))});
/*
 * SystemJS v0.19.47
 */
(function() {
function bootstrap() {// from https://gist.github.com/Yaffle/1088850
(function(global) {
function URLPolyfill(url, baseURL) {
  if (typeof url != 'string')
    throw new TypeError('URL must be a string');
  var m = String(url).replace(/^\s+|\s+$/g, "").replace(/\\/g, '/').match(/^([^:\/?#]+:)?(?:\/\/(?:([^:@\/?#]*)(?::([^:@\/?#]*))?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
  if (!m)
    throw new RangeError('Invalid URL format');
  var protocol = m[1] || "";
  var username = m[2] || "";
  var password = m[3] || "";
  var host = m[4] || "";
  var hostname = m[5] || "";
  var port = m[6] || "";
  var pathname = m[7] || "";
  var search = m[8] || "";
  var hash = m[9] || "";
  if (baseURL !== undefined) {
    var base = baseURL instanceof URLPolyfill ? baseURL : new URLPolyfill(baseURL);
    var flag = !protocol && !host && !username;
    if (flag && !pathname && !search)
      search = base.search;
    if (flag && pathname[0] !== "/")
      pathname = (pathname ? (((base.host || base.username) && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + pathname) : base.pathname);
    // dot segments removal
    var output = [];
    pathname.replace(/^(\.\.?(\/|$))+/, "")
      .replace(/\/(\.(\/|$))+/g, "/")
      .replace(/\/\.\.$/, "/../")
      .replace(/\/?[^\/]*/g, function (p) {
        if (p === "/..")
          output.pop();
        else
          output.push(p);
      });
    pathname = output.join("").replace(/^\//, pathname[0] === "/" ? "/" : "");
    if (flag) {
      port = base.port;
      hostname = base.hostname;
      host = base.host;
      password = base.password;
      username = base.username;
    }
    if (!protocol)
      protocol = base.protocol;
  }

  // convert URLs to use / always
  pathname = pathname.replace(/\\/g, '/');

  this.origin = host ? protocol + (protocol !== "" || host !== "" ? "//" : "") + host : "";
  this.href = protocol + (protocol && host || protocol == "file:" ? "//" : "") + (username !== "" ? username + (password !== "" ? ":" + password : "") + "@" : "") + host + pathname + search + hash;
  this.protocol = protocol;
  this.username = username;
  this.password = password;
  this.host = host;
  this.hostname = hostname;
  this.port = port;
  this.pathname = pathname;
  this.search = search;
  this.hash = hash;
}
global.URLPolyfill = URLPolyfill;
})(typeof self != 'undefined' ? self : global);
(function(__global) {

  var isWorker = typeof window == 'undefined' && typeof self != 'undefined' && typeof importScripts != 'undefined';
  var isBrowser = typeof window != 'undefined' && typeof document != 'undefined';
  var isWindows = typeof process != 'undefined' && typeof process.platform != 'undefined' && !!process.platform.match(/^win/);

  if (!__global.console)
    __global.console = { assert: function() {} };

  // IE8 support
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, thisLen = this.length; i < thisLen; i++) {
      if (this[i] === item) {
        return i;
      }
    }
    return -1;
  };

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  var errArgs = new Error(0, '_').fileName == '_';

  function addToError(err, msg) {
    // parse the stack removing loader code lines for simplification
    if (!err.originalErr) {
      var stack = ((err.message || err) + (err.stack ? '\n' + err.stack : '')).toString().split('\n');
      var newStack = [];
      for (var i = 0; i < stack.length; i++) {
        if (typeof $__curScript == 'undefined' || stack[i].indexOf($__curScript.src) == -1)
          newStack.push(stack[i]);
      }
    }

    var newMsg = '(SystemJS) ' + (newStack ? newStack.join('\n\t') : err.message.substr(11)) + '\n\t' + msg;

    // Convert file:/// URLs to paths in Node
    if (!isBrowser)
      newMsg = newMsg.replace(isWindows ? /file:\/\/\//g : /file:\/\//g, '');

    var newErr = errArgs ? new Error(newMsg, err.fileName, err.lineNumber) : new Error(newMsg);

    newErr.stack = newMsg;

    // track the original error
    newErr.originalErr = err.originalErr || err;

    return newErr;
  }

  function __eval(source, debugName, context) {
    try {
      new Function(source).call(context);
    }
    catch(e) {
      throw addToError(e, 'Evaluating ' + debugName);
    }
  }

  var baseURI;

  // environent baseURI detection
  if (typeof document != 'undefined' && document.getElementsByTagName) {
    baseURI = document.baseURI;

    if (!baseURI) {
      var bases = document.getElementsByTagName('base');
      baseURI = bases[0] && bases[0].href || window.location.href;
    }
  }
  else if (typeof location != 'undefined') {
    baseURI = __global.location.href;
  }

  // sanitize out the hash and querystring
  if (baseURI) {
    baseURI = baseURI.split('#')[0].split('?')[0];
    baseURI = baseURI.substr(0, baseURI.lastIndexOf('/') + 1);
  }
  else if (typeof process != 'undefined' && process.cwd) {
    baseURI = 'file://' + (isWindows ? '/' : '') + process.cwd() + '/';
    if (isWindows)
      baseURI = baseURI.replace(/\\/g, '/');
  }
  else {
    throw new TypeError('No environment baseURI');
  }

  try {
    var nativeURL = new __global.URL('test:///').protocol == 'test:';
  }
  catch(e) {}

  var URL = nativeURL ? __global.URL : __global.URLPolyfill;

/*
*********************************************************************************************

  Dynamic Module Loader Polyfill

    - Implemented exactly to the former 2014-08-24 ES6 Specification Draft Rev 27, Section 15
      http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#august_24_2014_draft_rev_27

    - Functions are commented with their spec numbers, with spec differences commented.

    - Spec bugs are commented in this code with links.

    - Abstract functions have been combined where possible, and their associated functions
      commented.

    - Realm implementation is entirely omitted.

*********************************************************************************************
*/

function Module() {}
// http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag
defineProperty(Module.prototype, 'toString', {
  value: function() {
    return 'Module';
  }
});
function Loader(options) {
  this._loader = {
    loaderObj: this,
    loads: [],
    modules: {},
    importPromises: {},
    moduleRecords: {}
  };

  // 26.3.3.6
  defineProperty(this, 'global', {
    get: function() {
      return __global;
    }
  });

  // 26.3.3.13 realm not implemented
}

(function() {

// Some Helpers

// logs a linkset snapshot for debugging
/* function snapshot(loader) {
  console.log('---Snapshot---');
  for (var i = 0; i < loader.loads.length; i++) {
    var load = loader.loads[i];
    var linkSetLog = '  ' + load.name + ' (' + load.status + '): ';

    for (var j = 0; j < load.linkSets.length; j++) {
      linkSetLog += '{' + logloads(load.linkSets[j].loads) + '} ';
    }
    console.log(linkSetLog);
  }
  console.log('');
}
function logloads(loads) {
  var log = '';
  for (var k = 0; k < loads.length; k++)
    log += loads[k].name + (k != loads.length - 1 ? ' ' : '');
  return log;
} */


/* function checkInvariants() {
  // see https://bugs.ecmascript.org/show_bug.cgi?id=2603#c1

  var loads = System._loader.loads;
  var linkSets = [];

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    console.assert(load.status == 'loading' || load.status == 'loaded', 'Each load is loading or loaded');

    for (var j = 0; j < load.linkSets.length; j++) {
      var linkSet = load.linkSets[j];

      for (var k = 0; k < linkSet.loads.length; k++)
        console.assert(loads.indexOf(linkSet.loads[k]) != -1, 'linkSet loads are a subset of loader loads');

      if (linkSets.indexOf(linkSet) == -1)
        linkSets.push(linkSet);
    }
  }

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    for (var j = 0; j < linkSets.length; j++) {
      var linkSet = linkSets[j];

      if (linkSet.loads.indexOf(load) != -1)
        console.assert(load.linkSets.indexOf(linkSet) != -1, 'linkSet contains load -> load contains linkSet');

      if (load.linkSets.indexOf(linkSet) != -1)
        console.assert(linkSet.loads.indexOf(load) != -1, 'load contains linkSet -> linkSet contains load');
    }
  }

  for (var i = 0; i < linkSets.length; i++) {
    var linkSet = linkSets[i];
    for (var j = 0; j < linkSet.loads.length; j++) {
      var load = linkSet.loads[j];

      for (var k = 0; k < load.dependencies.length; k++) {
        var depName = load.dependencies[k].value;
        var depLoad;
        for (var l = 0; l < loads.length; l++) {
          if (loads[l].name != depName)
            continue;
          depLoad = loads[l];
          break;
        }

        // loading records are allowed not to have their dependencies yet
        // if (load.status != 'loading')
        //  console.assert(depLoad, 'depLoad found');

        // console.assert(linkSet.loads.indexOf(depLoad) != -1, 'linkset contains all dependencies');
      }
    }
  }
} */

  // 15.2.3 - Runtime Semantics: Loader State

  // 15.2.3.11
  function createLoaderLoad(object) {
    return {
      // modules is an object for ES5 implementation
      modules: {},
      loads: [],
      loaderObj: object
    };
  }

  // 15.2.3.2 Load Records and LoadRequest Objects

  var anonCnt = 0;

  // 15.2.3.2.1
  function createLoad(name) {
    return {
      status: 'loading',
      name: name || '<Anonymous' + ++anonCnt + '>',
      linkSets: [],
      dependencies: [],
      metadata: {}
    };
  }

  // 15.2.3.2.2 createLoadRequestObject, absorbed into calling functions

  // 15.2.4

  // 15.2.4.1
  function loadModule(loader, name, options) {
    return new Promise(asyncStartLoadPartwayThrough({
      step: options.address ? 'fetch' : 'locate',
      loader: loader,
      moduleName: name,
      // allow metadata for import https://bugs.ecmascript.org/show_bug.cgi?id=3091
      moduleMetadata: options && options.metadata || {},
      moduleSource: options.source,
      moduleAddress: options.address
    }));
  }

  // 15.2.4.2
  function requestLoad(loader, request, refererName, refererAddress) {
    // 15.2.4.2.1 CallNormalize
    return new Promise(function(resolve, reject) {
      resolve(loader.loaderObj.normalize(request, refererName, refererAddress));
    })
    // 15.2.4.2.2 GetOrCreateLoad
    .then(function(name) {
      var load;
      if (loader.modules[name]) {
        load = createLoad(name);
        load.status = 'linked';
        // https://bugs.ecmascript.org/show_bug.cgi?id=2795
        load.module = loader.modules[name];
        return load;
      }

      for (var i = 0, l = loader.loads.length; i < l; i++) {
        load = loader.loads[i];
        if (load.name != name)
          continue;
        return load;
      }

      load = createLoad(name);
      loader.loads.push(load);

      proceedToLocate(loader, load);

      return load;
    });
  }

  // 15.2.4.3
  function proceedToLocate(loader, load) {
    proceedToFetch(loader, load,
      Promise.resolve()
      // 15.2.4.3.1 CallLocate
      .then(function() {
        return loader.loaderObj.locate({ name: load.name, metadata: load.metadata });
      })
    );
  }

  // 15.2.4.4
  function proceedToFetch(loader, load, p) {
    proceedToTranslate(loader, load,
      p
      // 15.2.4.4.1 CallFetch
      .then(function(address) {
        // adjusted, see https://bugs.ecmascript.org/show_bug.cgi?id=2602
        if (load.status != 'loading')
          return;
        load.address = address;

        return loader.loaderObj.fetch({ name: load.name, metadata: load.metadata, address: address });
      })
    );
  }

  // 15.2.4.5
  function proceedToTranslate(loader, load, p) {
    p
    // 15.2.4.5.1 CallTranslate
    .then(function(source) {
      if (load.status != 'loading')
        return;

      load.address = load.address || load.name;

      return Promise.resolve(loader.loaderObj.translate({ name: load.name, metadata: load.metadata, address: load.address, source: source }))

      // 15.2.4.5.2 CallInstantiate
      .then(function(source) {
        load.source = source;
        return loader.loaderObj.instantiate({ name: load.name, metadata: load.metadata, address: load.address, source: source });
      })

      // 15.2.4.5.3 InstantiateSucceeded
      .then(function(instantiateResult) {
        if (instantiateResult === undefined)
          throw new TypeError('Declarative modules unsupported in the polyfill.');

        if (typeof instantiateResult != 'object')
          throw new TypeError('Invalid instantiate return value');

        load.depsList = instantiateResult.deps || [];
        load.execute = instantiateResult.execute;
      })
      // 15.2.4.6 ProcessLoadDependencies
      .then(function() {
        load.dependencies = [];
        var depsList = load.depsList;

        var loadPromises = [];
        for (var i = 0, l = depsList.length; i < l; i++) (function(request, index) {
          loadPromises.push(
            requestLoad(loader, request, load.name, load.address)

            // 15.2.4.6.1 AddDependencyLoad (load is parentLoad)
            .then(function(depLoad) {

              // adjusted from spec to maintain dependency order
              // this is due to the System.register internal implementation needs
              load.dependencies[index] = {
                key: request,
                value: depLoad.name
              };

              if (depLoad.status != 'linked') {
                var linkSets = load.linkSets.concat([]);
                for (var i = 0, l = linkSets.length; i < l; i++)
                  addLoadToLinkSet(linkSets[i], depLoad);
              }

              // console.log('AddDependencyLoad ' + depLoad.name + ' for ' + load.name);
              // snapshot(loader);
            })
          );
        })(depsList[i], i);

        return Promise.all(loadPromises);
      })

      // 15.2.4.6.2 LoadSucceeded
      .then(function() {
        // console.log('LoadSucceeded ' + load.name);
        // snapshot(loader);

        load.status = 'loaded';

        var linkSets = load.linkSets.concat([]);
        for (var i = 0, l = linkSets.length; i < l; i++)
          updateLinkSetOnLoad(linkSets[i], load);
      });
    })
    // 15.2.4.5.4 LoadFailed
    ['catch'](function(exc) {
      load.status = 'failed';
      load.exception = exc;

      var linkSets = load.linkSets.concat([]);
      for (var i = 0, l = linkSets.length; i < l; i++) {
        linkSetFailed(linkSets[i], load, exc);
      }
    });
  }

  // 15.2.4.7 PromiseOfStartLoadPartwayThrough absorbed into calling functions

  // 15.2.4.7.1
  function asyncStartLoadPartwayThrough(stepState) {
    return function(resolve, reject) {
      var loader = stepState.loader;
      var name = stepState.moduleName;
      var step = stepState.step;

      if (loader.modules[name])
        throw new TypeError('"' + name + '" already exists in the module table');

      // adjusted to pick up existing loads
      var existingLoad;
      for (var i = 0, l = loader.loads.length; i < l; i++) {
        if (loader.loads[i].name == name) {
          existingLoad = loader.loads[i];

          if (step == 'translate' && !existingLoad.source) {
            existingLoad.address = stepState.moduleAddress;
            proceedToTranslate(loader, existingLoad, Promise.resolve(stepState.moduleSource));
          }

          // a primary load -> use that existing linkset if it is for the direct load here
          // otherwise create a new linkset unit
          if (existingLoad.linkSets.length && existingLoad.linkSets[0].loads[0].name == existingLoad.name)
            return existingLoad.linkSets[0].done.then(function() {
              resolve(existingLoad);
            });
        }
      }

      var load = existingLoad || createLoad(name);

      load.metadata = stepState.moduleMetadata;

      var linkSet = createLinkSet(loader, load);

      loader.loads.push(load);

      resolve(linkSet.done);

      if (step == 'locate')
        proceedToLocate(loader, load);

      else if (step == 'fetch')
        proceedToFetch(loader, load, Promise.resolve(stepState.moduleAddress));

      else {
        load.address = stepState.moduleAddress;
        proceedToTranslate(loader, load, Promise.resolve(stepState.moduleSource));
      }
    }
  }

  // Declarative linking functions run through alternative implementation:
  // 15.2.5.1.1 CreateModuleLinkageRecord not implemented
  // 15.2.5.1.2 LookupExport not implemented
  // 15.2.5.1.3 LookupModuleDependency not implemented

  // 15.2.5.2.1
  function createLinkSet(loader, startingLoad) {
    var linkSet = {
      loader: loader,
      loads: [],
      startingLoad: startingLoad, // added see spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
      loadingCount: 0
    };
    linkSet.done = new Promise(function(resolve, reject) {
      linkSet.resolve = resolve;
      linkSet.reject = reject;
    });
    addLoadToLinkSet(linkSet, startingLoad);
    return linkSet;
  }
  // 15.2.5.2.2
  function addLoadToLinkSet(linkSet, load) {
    if (load.status == 'failed')
      return;

    for (var i = 0, l = linkSet.loads.length; i < l; i++)
      if (linkSet.loads[i] == load)
        return;

    linkSet.loads.push(load);
    load.linkSets.push(linkSet);

    // adjustment, see https://bugs.ecmascript.org/show_bug.cgi?id=2603
    if (load.status != 'loaded') {
      linkSet.loadingCount++;
    }

    var loader = linkSet.loader;

    for (var i = 0, l = load.dependencies.length; i < l; i++) {
      if (!load.dependencies[i])
        continue;

      var name = load.dependencies[i].value;

      if (loader.modules[name])
        continue;

      for (var j = 0, d = loader.loads.length; j < d; j++) {
        if (loader.loads[j].name != name)
          continue;

        addLoadToLinkSet(linkSet, loader.loads[j]);
        break;
      }
    }
    // console.log('add to linkset ' + load.name);
    // snapshot(linkSet.loader);
  }

  // linking errors can be generic or load-specific
  // this is necessary for debugging info
  function doLink(linkSet) {
    var error = false;
    try {
      link(linkSet, function(load, exc) {
        linkSetFailed(linkSet, load, exc);
        error = true;
      });
    }
    catch(e) {
      linkSetFailed(linkSet, null, e);
      error = true;
    }
    return error;
  }

  // 15.2.5.2.3
  function updateLinkSetOnLoad(linkSet, load) {
    // console.log('update linkset on load ' + load.name);
    // snapshot(linkSet.loader);
    linkSet.loadingCount--;

    if (linkSet.loadingCount > 0)
      return;

    // adjusted for spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
    var startingLoad = linkSet.startingLoad;

    // non-executing link variation for loader tracing
    // on the server. Not in spec.
    /***/
    if (linkSet.loader.loaderObj.execute === false) {
      var loads = [].concat(linkSet.loads);
      for (var i = 0, l = loads.length; i < l; i++) {
        var load = loads[i];
        load.module = {
          name: load.name,
          module: _newModule({}),
          evaluated: true
        };
        load.status = 'linked';
        finishLoad(linkSet.loader, load);
      }
      return linkSet.resolve(startingLoad);
    }
    /***/

    var abrupt = doLink(linkSet);

    if (abrupt)
      return;

    linkSet.resolve(startingLoad);
  }

  // 15.2.5.2.4
  function linkSetFailed(linkSet, load, exc) {
    var loader = linkSet.loader;
    var requests;

    checkError:
    if (load) {
      if (linkSet.loads[0].name == load.name) {
        exc = addToError(exc, 'Error loading ' + load.name);
      }
      else {
        for (var i = 0; i < linkSet.loads.length; i++) {
          var pLoad = linkSet.loads[i];
          for (var j = 0; j < pLoad.dependencies.length; j++) {
            var dep = pLoad.dependencies[j];
            if (dep.value == load.name) {
              exc = addToError(exc, 'Error loading ' + load.name + ' as "' + dep.key + '" from ' + pLoad.name);
              break checkError;
            }
          }
        }
        exc = addToError(exc, 'Error loading ' + load.name + ' from ' + linkSet.loads[0].name);
      }
    }
    else {
      exc = addToError(exc, 'Error linking ' + linkSet.loads[0].name);
    }


    var loads = linkSet.loads.concat([]);
    for (var i = 0, l = loads.length; i < l; i++) {
      var load = loads[i];

      // store all failed load records
      loader.loaderObj.failed = loader.loaderObj.failed || [];
      if (indexOf.call(loader.loaderObj.failed, load) == -1)
        loader.loaderObj.failed.push(load);

      var linkIndex = indexOf.call(load.linkSets, linkSet);
      load.linkSets.splice(linkIndex, 1);
      if (load.linkSets.length == 0) {
        var globalLoadsIndex = indexOf.call(linkSet.loader.loads, load);
        if (globalLoadsIndex != -1)
          linkSet.loader.loads.splice(globalLoadsIndex, 1);
      }
    }
    linkSet.reject(exc);
  }

  // 15.2.5.2.5
  function finishLoad(loader, load) {
    // add to global trace if tracing
    if (loader.loaderObj.trace) {
      if (!loader.loaderObj.loads)
        loader.loaderObj.loads = {};
      var depMap = {};
      load.dependencies.forEach(function(dep) {
        depMap[dep.key] = dep.value;
      });
      loader.loaderObj.loads[load.name] = {
        name: load.name,
        deps: load.dependencies.map(function(dep){ return dep.key }),
        depMap: depMap,
        address: load.address,
        metadata: load.metadata,
        source: load.source
      };
    }
    // if not anonymous, add to the module table
    if (load.name) {
      loader.modules[load.name] = load.module;
    }
    var loadIndex = indexOf.call(loader.loads, load);
    if (loadIndex != -1)
      loader.loads.splice(loadIndex, 1);
    for (var i = 0, l = load.linkSets.length; i < l; i++) {
      loadIndex = indexOf.call(load.linkSets[i].loads, load);
      if (loadIndex != -1)
        load.linkSets[i].loads.splice(loadIndex, 1);
    }
    load.linkSets.splice(0, load.linkSets.length);
  }

  function doDynamicExecute(linkSet, load, linkError) {
    try {
      var module = load.execute();
    }
    catch(e) {
      linkError(load, e);
      return;
    }
    if (!module || !(module instanceof Module))
      linkError(load, new TypeError('Execution must define a Module instance'));
    else
      return module;
  }

  // 26.3 Loader

  // 26.3.1.1
  // defined at top

  // importPromises adds ability to import a module twice without error - https://bugs.ecmascript.org/show_bug.cgi?id=2601
  function createImportPromise(loader, name, promise) {
    var importPromises = loader._loader.importPromises;
    return importPromises[name] = promise.then(function(m) {
      importPromises[name] = undefined;
      return m;
    }, function(e) {
      importPromises[name] = undefined;
      throw e;
    });
  }

  Loader.prototype = {
    // 26.3.3.1
    constructor: Loader,
    // 26.3.3.2
    define: function(name, source, options) {
      // check if already defined
      if (this._loader.importPromises[name])
        throw new TypeError('Module is already loading.');
      return createImportPromise(this, name, new Promise(asyncStartLoadPartwayThrough({
        step: 'translate',
        loader: this._loader,
        moduleName: name,
        moduleMetadata: options && options.metadata || {},
        moduleSource: source,
        moduleAddress: options && options.address
      })));
    },
    // 26.3.3.3
    'delete': function(name) {
      var loader = this._loader;
      delete loader.importPromises[name];
      delete loader.moduleRecords[name];
      return loader.modules[name] ? delete loader.modules[name] : false;
    },
    // 26.3.3.4 entries not implemented
    // 26.3.3.5
    get: function(key) {
      if (!this._loader.modules[key])
        return;
      return this._loader.modules[key].module;
    },
    // 26.3.3.7
    has: function(name) {
      return !!this._loader.modules[name];
    },
    // 26.3.3.8
    'import': function(name, parentName, parentAddress) {
      if (typeof parentName == 'object')
        parentName = parentName.name;

      // run normalize first
      var loaderObj = this;

      // added, see https://bugs.ecmascript.org/show_bug.cgi?id=2659
      return Promise.resolve(loaderObj.normalize(name, parentName))
      .then(function(name) {
        var loader = loaderObj._loader;

        if (loader.modules[name])
          return loader.modules[name].module;

        return loader.importPromises[name] || createImportPromise(loaderObj, name,
          loadModule(loader, name, {})
          .then(function(load) {
            delete loader.importPromises[name];
            return load.module.module;
          }));
      });
    },
    // 26.3.3.9 keys not implemented
    // 26.3.3.10
    load: function(name) {
      var loader = this._loader;
      if (loader.modules[name])
        return Promise.resolve();
      return (loader.importPromises[name] || createImportPromise(this, name, new Promise(asyncStartLoadPartwayThrough({
        step: 'locate',
        loader: loader,
        moduleName: name,
        moduleMetadata: {},
        moduleSource: undefined,
        moduleAddress: undefined
      }))
      .then(function(load) {
        delete loader.importPromises[name];
        return load.module.module;
      })))
      .then(function () {});
    },
    // 26.3.3.11
    module: function(source, options) {
      var load = createLoad();
      load.address = options && options.address;
      var linkSet = createLinkSet(this._loader, load);
      var sourcePromise = Promise.resolve(source);
      var loader = this._loader;
      var p = linkSet.done.then(function() {
        return load.module.module;
      });
      proceedToTranslate(loader, load, sourcePromise);
      return p;
    },
    // 26.3.3.12
    newModule: function (obj) {
      if (typeof obj != 'object')
        throw new TypeError('Expected object');

      var m = new Module();

      var pNames = [];
      if (Object.getOwnPropertyNames && obj != null)
        pNames = Object.getOwnPropertyNames(obj);
      else
        for (var key in obj)
          pNames.push(key);

      for (var i = 0; i < pNames.length; i++) (function(key) {
        defineProperty(m, key, {
          configurable: false,
          enumerable: true,
          get: function () {
            return obj[key];
          },
          set: function() {
            throw new Error('Module exports cannot be changed externally.');
          }
        });
      })(pNames[i]);

      if (Object.freeze)
        Object.freeze(m);

      return m;
    },
    // 26.3.3.14
    set: function(name, module) {
      if (!(module instanceof Module))
        throw new TypeError('Loader.set(' + name + ', module) must be a module');
      this._loader.modules[name] = {
        module: module
      };
    },
    // 26.3.3.15 values not implemented
    // 26.3.3.16 @@iterator not implemented
    // 26.3.3.17 @@toStringTag not implemented

    // 26.3.3.18.1
    normalize: function(name, referrerName, referrerAddress) {},
    // 26.3.3.18.2
    locate: function(load) {
      return load.name;
    },
    // 26.3.3.18.3
    fetch: function(load) {
    },
    // 26.3.3.18.4
    translate: function(load) {
      return load.source;
    },
    // 26.3.3.18.5
    instantiate: function(load) {
    }
  };

  var _newModule = Loader.prototype.newModule;

/*
 * ES6 Module Declarative Linking Code
 */
  function link(linkSet, linkError) {

    var loader = linkSet.loader;

    if (!linkSet.loads.length)
      return;

    var loads = linkSet.loads.concat([]);

    for (var i = 0; i < loads.length; i++) {
      var load = loads[i];

      var module = doDynamicExecute(linkSet, load, linkError);
      if (!module)
        return;
      load.module = {
        name: load.name,
        module: module
      };
      load.status = 'linked';

      finishLoad(loader, load);
    }
  }

})();

var System;
  var fetchTextFromURL;
  if (typeof XMLHttpRequest != 'undefined') {
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      var xhr = new XMLHttpRequest();
      var sameDomain = true;
      var doTimeout = false;
      if (!('withCredentials' in xhr)) {
        // check if same domain
        var domainCheck = /^(\w+:)?\/\/([^\/]+)/.exec(url);
        if (domainCheck) {
          sameDomain = domainCheck[2] === window.location.host;
          if (domainCheck[1])
            sameDomain &= domainCheck[1] === window.location.protocol;
        }
      }
      if (!sameDomain && typeof XDomainRequest != 'undefined') {
        xhr = new XDomainRequest();
        xhr.onload = load;
        xhr.onerror = error;
        xhr.ontimeout = error;
        xhr.onprogress = function() {};
        xhr.timeout = 0;
        doTimeout = true;
      }
      function load() {
        fulfill(xhr.responseText);
      }
      function error() {
        reject(new Error('XHR error' + (xhr.status ? ' (' + xhr.status + (xhr.statusText ? ' ' + xhr.statusText  : '') + ')' : '') + ' loading ' + url));
      }

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          // in Chrome on file:/// URLs, status is 0
          if (xhr.status == 0) {
            if (xhr.responseText) {
              load();
            }
            else {
              // when responseText is empty, wait for load or error event
              // to inform if it is a 404 or empty file
              xhr.addEventListener('error', error);
              xhr.addEventListener('load', load);
            }
          }
          else if (xhr.status === 200) {
            load();
          }
          else {
            error();
          }
        }
      };
      xhr.open("GET", url, true);

      if (xhr.setRequestHeader) {
        xhr.setRequestHeader('Accept', 'application/x-es-module, */*');
        // can set "authorization: true" to enable withCredentials only
        if (authorization) {
          if (typeof authorization == 'string')
            xhr.setRequestHeader('Authorization', authorization);
          xhr.withCredentials = true;
        }
      }

      if (doTimeout) {
        setTimeout(function() {
          xhr.send();
        }, 0);
      } else {
        xhr.send(null);
      }
    };
  }
  else if (typeof require != 'undefined' && typeof process != 'undefined') {
    var fs;
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      if (url.substr(0, 8) != 'file:///')
        throw new Error('Unable to fetch "' + url + '". Only file URLs of the form file:/// allowed running in Node.');
      fs = fs || require('fs');
      if (isWindows)
        url = url.replace(/\//g, '\\').substr(8);
      else
        url = url.substr(7);
      return fs.readFile(url, function(err, data) {
        if (err) {
          return reject(err);
        }
        else {
          // Strip Byte Order Mark out if it's the leading char
          var dataString = data + '';
          if (dataString[0] === '\ufeff')
            dataString = dataString.substr(1);

          fulfill(dataString);
        }
      });
    };
  }
  else if (typeof self != 'undefined' && typeof self.fetch != 'undefined') {
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      var opts = {
        headers: {'Accept': 'application/x-es-module, */*'}
      };

      if (authorization) {
        if (typeof authorization == 'string')
          opts.headers['Authorization'] = authorization;
        opts.credentials = 'include';
      }

      fetch(url, opts)
        .then(function (r) {
          if (r.ok) {
            return r.text();
          } else {
            throw new Error('Fetch error: ' + r.status + ' ' + r.statusText);
          }
        })
        .then(fulfill, reject);
    }
  }
  else {
    throw new TypeError('No environment fetch API available.');
  }
/*
 * Traceur, Babel and TypeScript transpile hook for Loader
 */
var transpile = (function() {

  // use Traceur by default
  Loader.prototype.transpiler = 'traceur';

  function transpile(load) {
    var self = this;

    return Promise.resolve(__global[self.transpiler == 'typescript' ? 'ts' : self.transpiler]
        || (self.pluginLoader || self)['import'](self.transpiler))
    .then(function(transpiler) {
      if (transpiler.__useDefault)
        transpiler = transpiler['default'];

      var transpileFunction;
      if (transpiler.Compiler)
        transpileFunction = traceurTranspile;
      else if (transpiler.createLanguageService)
        transpileFunction = typescriptTranspile;
      else
        transpileFunction = babelTranspile;

      // note __moduleName will be part of the transformer meta in future when we have the spec for this
      return '(function(__moduleName){' + transpileFunction.call(self, load, transpiler) + '\n})("' + load.name + '");\n//# sourceURL=' + load.address + '!transpiled';
    });
  };

  function traceurTranspile(load, traceur) {
    var options = this.traceurOptions || {};
    options.modules = 'instantiate';
    options.script = false;
    if (options.sourceMaps === undefined)
      options.sourceMaps = 'inline';
    options.filename = load.address;
    options.inputSourceMap = load.metadata.sourceMap;
    options.moduleName = false;

    var compiler = new traceur.Compiler(options);

    return doTraceurCompile(load.source, compiler, options.filename);
  }
  function doTraceurCompile(source, compiler, filename) {
    try {
      return compiler.compile(source, filename);
    }
    catch(e) {
      // on older versions of traceur (<0.9.3), an array of errors is thrown
      // rather than a single error.
      if (e.length) {
        throw e[0];
      }
      throw e;
    }
  }

  function babelTranspile(load, babel) {
    var options = this.babelOptions || {};
    options.modules = 'system';
    if (options.sourceMap === undefined)
      options.sourceMap = 'inline';
    options.inputSourceMap = load.metadata.sourceMap;
    options.filename = load.address;
    options.code = true;
    options.ast = false;

    return babel.transform(load.source, options).code;
  }

  function typescriptTranspile(load, ts) {
    var options = this.typescriptOptions || {};
    options.target = options.target || ts.ScriptTarget.ES5;
    if (options.sourceMap === undefined)
      options.sourceMap = true;
    if (options.sourceMap && options.inlineSourceMap !== false)
      options.inlineSourceMap = true;

    options.module = ts.ModuleKind.System;

    return ts.transpile(load.source, options, load.address);
  }

  return transpile;
})();
// SystemJS Loader Class and Extension helpers
function SystemJSLoader() {
  Loader.call(this);

  this.paths = {};
  this._loader.paths = {};

  systemJSConstructor.call(this);
}

// inline Object.create-style class extension
function SystemProto() {};
SystemProto.prototype = Loader.prototype;
SystemJSLoader.prototype = new SystemProto();
SystemJSLoader.prototype.constructor = SystemJSLoader;

var systemJSConstructor;

function hook(name, hook) {
  SystemJSLoader.prototype[name] = hook(SystemJSLoader.prototype[name] || function() {});
}
function hookConstructor(hook) {
  systemJSConstructor = hook(systemJSConstructor || function() {});
}


var absURLRegEx = /^[^\/]+:\/\//;
function isAbsolute(name) {
  return name.match(absURLRegEx);
}
function isRel(name) {
  return (name[0] == '.' && (!name[1] || name[1] == '/' || name[1] == '.')) || name[0] == '/';
}
function isPlain(name) {
  return !isRel(name) && !isAbsolute(name);
}

var baseURIObj = new URL(baseURI);

function urlResolve(name, parent) {
  // url resolution shortpaths
  if (name[0] == '.') {
    // dot-relative url normalization
    if (name[1] == '/' && name[2] != '.')
      return (parent && parent.substr(0, parent.lastIndexOf('/') + 1) || baseURI) + name.substr(2);
  }
  else if (name[0] != '/' && name.indexOf(':') == -1) {
    // plain parent normalization
    return (parent && parent.substr(0, parent.lastIndexOf('/') + 1) || baseURI) + name;
  }

  return new URL(name, parent && parent.replace(/#/g, '%05') || baseURIObj).href.replace(/%05/g, '#');
}

// NB no specification provided for System.paths, used ideas discussed in https://github.com/jorendorff/js-loaders/issues/25
function applyPaths(loader, name) {
  // most specific (most number of slashes in path) match wins
  var pathMatch = '', wildcard, maxWildcardPrefixLen = 0;

  var paths = loader.paths;
  var pathsCache = loader._loader.paths;

  // check to see if we have a paths entry
  for (var p in paths) {
    if (paths.hasOwnProperty && !paths.hasOwnProperty(p))
      continue;

    // paths sanitization
    var path = paths[p];
    if (path !== pathsCache[p])
      path = paths[p] = pathsCache[p] = urlResolve(paths[p], isRel(paths[p]) ? baseURI : loader.baseURL);

    // exact path match
    if (p.indexOf('*') === -1) {
      if (name == p)
        return paths[p];

      // support trailing / in paths rules
      else if (name.substr(0, p.length - 1) == p.substr(0, p.length - 1) && (name.length < p.length || name[p.length - 1] == p[p.length - 1]) && (paths[p][paths[p].length - 1] == '/' || paths[p] == '')) {
        return paths[p].substr(0, paths[p].length - 1) + (name.length > p.length ? (paths[p] && '/' || '') + name.substr(p.length) : '');
      }
    }
    // wildcard path match
    else {
      var pathParts = p.split('*');
      if (pathParts.length > 2)
        throw new TypeError('Only one wildcard in a path is permitted');

      var wildcardPrefixLen = pathParts[0].length;
      if (wildcardPrefixLen >= maxWildcardPrefixLen &&
          name.substr(0, pathParts[0].length) == pathParts[0] &&
          name.substr(name.length - pathParts[1].length) == pathParts[1]) {
            maxWildcardPrefixLen = wildcardPrefixLen;
            pathMatch = p;
            wildcard = name.substr(pathParts[0].length, name.length - pathParts[1].length - pathParts[0].length);
          }
    }
  }

  var outPath = paths[pathMatch];
  if (typeof wildcard == 'string')
    outPath = outPath.replace('*', wildcard);

  return outPath;
}

function dedupe(deps) {
  var newDeps = [];
  for (var i = 0, l = deps.length; i < l; i++)
    if (indexOf.call(newDeps, deps[i]) == -1)
      newDeps.push(deps[i])
  return newDeps;
}

function group(deps) {
  var names = [];
  var indices = [];
  for (var i = 0, l = deps.length; i < l; i++) {
    var index = indexOf.call(names, deps[i]);
    if (index === -1) {
      names.push(deps[i]);
      indices.push([i]);
    }
    else {
      indices[index].push(i);
    }
  }
  return { names: names, indices: indices };
}

var getOwnPropertyDescriptor = true;
try {
  Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
}
catch(e) {
  getOwnPropertyDescriptor = false;
}

// converts any module.exports object into an object ready for SystemJS.newModule
function getESModule(exports) {
  var esModule = {};
  // don't trigger getters/setters in environments that support them
  if ((typeof exports == 'object' || typeof exports == 'function') && exports !== __global) {
      if (getOwnPropertyDescriptor) {
        for (var p in exports) {
          // The default property is copied to esModule later on
          if (p === 'default')
            continue;
          defineOrCopyProperty(esModule, exports, p);
        }
      }
      else {
        extend(esModule, exports);
      }
  }
  esModule['default'] = exports;
  defineProperty(esModule, '__useDefault', {
    value: true
  });
  return esModule;
}

function defineOrCopyProperty(targetObj, sourceObj, propName) {
  try {
    var d;
    if (d = Object.getOwnPropertyDescriptor(sourceObj, propName))
      defineProperty(targetObj, propName, d);
  }
  catch (ex) {
    // Object.getOwnPropertyDescriptor threw an exception, fall back to normal set property
    // we dont need hasOwnProperty here because getOwnPropertyDescriptor would have returned undefined above
    targetObj[propName] = sourceObj[propName];
    return false;
  }
}

function extend(a, b, prepend) {
  var hasOwnProperty = b && b.hasOwnProperty;
  for (var p in b) {
    if (hasOwnProperty && !b.hasOwnProperty(p))
      continue;
    if (!prepend || !(p in a))
      a[p] = b[p];
  }
  return a;
}

// meta first-level extends where:
// array + array appends
// object + object extends
// other properties replace
function extendMeta(a, b, prepend) {
  var hasOwnProperty = b && b.hasOwnProperty;
  for (var p in b) {
    if (hasOwnProperty && !b.hasOwnProperty(p))
      continue;
    var val = b[p];
    if (!(p in a))
      a[p] = val;
    else if (val instanceof Array && a[p] instanceof Array)
      a[p] = [].concat(prepend ? val : a[p]).concat(prepend ? a[p] : val);
    else if (typeof val == 'object' && val !== null && typeof a[p] == 'object')
      a[p] = extend(extend({}, a[p]), val, prepend);
    else if (!prepend)
      a[p] = val;
  }
}

function extendPkgConfig(pkgCfgA, pkgCfgB, pkgName, loader, warnInvalidProperties) {
  for (var prop in pkgCfgB) {
    if (indexOf.call(['main', 'format', 'defaultExtension', 'basePath'], prop) != -1) {
      pkgCfgA[prop] = pkgCfgB[prop];
    }
    else if (prop == 'map') {
      extend(pkgCfgA.map = pkgCfgA.map || {}, pkgCfgB.map);
    }
    else if (prop == 'meta') {
      extend(pkgCfgA.meta = pkgCfgA.meta || {}, pkgCfgB.meta);
    }
    else if (prop == 'depCache') {
      for (var d in pkgCfgB.depCache) {
        var dNormalized;

        if (d.substr(0, 2) == './')
          dNormalized = pkgName + '/' + d.substr(2);
        else
          dNormalized = coreResolve.call(loader, d);
        loader.depCache[dNormalized] = (loader.depCache[dNormalized] || []).concat(pkgCfgB.depCache[d]);
      }
    }
    else if (warnInvalidProperties && indexOf.call(['browserConfig', 'nodeConfig', 'devConfig', 'productionConfig'], prop) == -1 &&
        (!pkgCfgB.hasOwnProperty || pkgCfgB.hasOwnProperty(prop))) {
      warn.call(loader, '"' + prop + '" is not a valid package configuration option in package ' + pkgName);
    }
  }
}

// deeply-merge (to first level) config with any existing package config
function setPkgConfig(loader, pkgName, cfg, prependConfig) {
  var pkg;

  // first package is config by reference for fast path, cloned after that
  if (!loader.packages[pkgName]) {
    pkg = loader.packages[pkgName] = cfg;
  }
  else {
    var basePkg = loader.packages[pkgName];
    pkg = loader.packages[pkgName] = {};

    extendPkgConfig(pkg, prependConfig ? cfg : basePkg, pkgName, loader, prependConfig);
    extendPkgConfig(pkg, prependConfig ? basePkg : cfg, pkgName, loader, !prependConfig);
  }

  // main object becomes main map
  if (typeof pkg.main == 'object') {
    pkg.map = pkg.map || {};
    pkg.map['./@main'] = pkg.main;
    pkg.main['default'] = pkg.main['default'] || './';
    pkg.main = '@main';
  }

  return pkg;
}

function warn(msg) {
  if (this.warnings && typeof console != 'undefined' && console.warn)
    console.warn(msg);
}

function createInstantiate (load, result) {
  load.metadata.entry = createEntry();
  load.metadata.entry.execute = function() {
    return result;
  }
  load.metadata.entry.deps = [];
  load.metadata.format = 'defined';
}
// we define a __exec for globally-scoped execution
// used by module format implementations
var __exec;

(function() {

  var hasBuffer = typeof Buffer != 'undefined';
  try {
    if (hasBuffer && new Buffer('a').toString('base64') != 'YQ==')
      hasBuffer = false;
  }
  catch(e) {
    hasBuffer = false;
  }

  var sourceMapPrefix = '\n//# sourceMappingURL=data:application/json;base64,';
  function inlineSourceMap(sourceMapString) {
    if (hasBuffer)
      return sourceMapPrefix + new Buffer(sourceMapString).toString('base64');
    else if (typeof btoa != 'undefined')
      return sourceMapPrefix + btoa(unescape(encodeURIComponent(sourceMapString)));
    else
      return '';
  }

  function getSource(load, wrap) {
    var lastLineIndex = load.source.lastIndexOf('\n');

    // wrap ES formats with a System closure for System global encapsulation
    if (load.metadata.format == 'global')
      wrap = false;

    var sourceMap = load.metadata.sourceMap;
    if (sourceMap) {
      if (typeof sourceMap != 'object')
        throw new TypeError('load.metadata.sourceMap must be set to an object.');

      sourceMap = JSON.stringify(sourceMap);
    }

    return (wrap ? '(function(System, SystemJS) {' : '') + load.source + (wrap ? '\n})(System, System);' : '')
        // adds the sourceURL comment if not already present
        + (load.source.substr(lastLineIndex, 15) != '\n//# sourceURL='
          ? '\n//# sourceURL=' + load.address + (sourceMap ? '!transpiled' : '') : '')
        // add sourceMappingURL if load.metadata.sourceMap is set
        + (sourceMap && inlineSourceMap(sourceMap) || '');
  }

  var curLoad;

  // System.register, System.registerDynamic, AMD define pipeline
  // if currently evalling code here, immediately reduce the registered entry against the load record
  hook('pushRegister_', function() {
    return function(register) {
      if (!curLoad)
        return false;

      this.reduceRegister_(curLoad, register);
      return true;
    };
  });

  // System clobbering protection (mostly for Traceur)
  var curSystem;
  var callCounter = 0;
  function preExec(loader, load) {
    curLoad = load;
    if (callCounter++ == 0)
      curSystem = __global.System;
    __global.System = __global.SystemJS = loader;
  }
  function postExec() {
    if (--callCounter == 0)
      __global.System = __global.SystemJS = curSystem;
    curLoad = undefined;
  }

  var useVm;
  var vm;
  __exec = function(load) {
    if (!load.source)
      return;
    if ((load.metadata.integrity || load.metadata.nonce) && supportsScriptExec)
      return scriptExec.call(this, load);
    try {
      preExec(this, load);
      curLoad = load;
      // global scoped eval for node (avoids require scope leak)
      if (!vm && this._nodeRequire) {
        vm = this._nodeRequire('vm');
        useVm = vm.runInThisContext("typeof System !== 'undefined' && System") === this;
      }
      if (useVm)
        vm.runInThisContext(getSource(load, true), { filename: load.address + (load.metadata.sourceMap ? '!transpiled' : '') });
      else
        (0, eval)(getSource(load, true));
      postExec();
    }
    catch(e) {
      postExec();
      throw addToError(e, 'Evaluating ' + load.address);
    }
  };

  var supportsScriptExec = false;
  if (isBrowser && typeof document != 'undefined' && document.getElementsByTagName) {
    if (!(window.chrome && window.chrome.extension || navigator.userAgent.match(/^Node\.js/)))
      supportsScriptExec = true;
  }

  // script execution via injecting a script tag into the page
  // this allows CSP integrity and nonce to be set for CSP environments
  var head;
  function scriptExec(load) {
    if (!head)
      head = document.head || document.body || document.documentElement;

    var script = document.createElement('script');
    script.text = getSource(load, false);
    var onerror = window.onerror;
    var e;
    window.onerror = function(_e) {
      e = addToError(_e, 'Evaluating ' + load.address);
      if (onerror)
        onerror.apply(this, arguments);
    }
    preExec(this, load);

    if (load.metadata.integrity)
      script.setAttribute('integrity', load.metadata.integrity);
    if (load.metadata.nonce)
      script.setAttribute('nonce', load.metadata.nonce);

    head.appendChild(script);
    head.removeChild(script);
    postExec();
    window.onerror = onerror;
    if (e)
      throw e;
  }

})();
function readMemberExpression(p, value) {
  var pParts = p.split('.');
  while (pParts.length)
    value = value[pParts.shift()];
  return value;
}

function getMapMatch(map, name) {
  var bestMatch, bestMatchLength = 0;

  for (var p in map) {
    if (name.substr(0, p.length) == p && (name.length == p.length || name[p.length] == '/')) {
      var curMatchLength = p.split('/').length;
      if (curMatchLength <= bestMatchLength)
        continue;
      bestMatch = p;
      bestMatchLength = curMatchLength;
    }
  }

  return bestMatch;
}

function prepareBaseURL(loader) {
  // ensure baseURl is fully normalized
  if (this._loader.baseURL !== this.baseURL) {
    if (this.baseURL[this.baseURL.length - 1] != '/')
      this.baseURL += '/';

    this._loader.baseURL = this.baseURL = new URL(this.baseURL, baseURIObj).href;
  }
}

var envModule;
function setProduction(isProduction, isBuilder) {
  this.set('@system-env', envModule = this.newModule({
    browser: isBrowser,
    node: !!this._nodeRequire,
    production: !isBuilder && isProduction,
    dev: isBuilder || !isProduction,
    build: isBuilder,
    'default': true
  }));
}

hookConstructor(function(constructor) {
  return function() {
    constructor.call(this);

    // support baseURL
    this.baseURL = baseURI;

    // support map and paths
    this.map = {};

    // make the location of the system.js script accessible
    if (typeof $__curScript != 'undefined')
      this.scriptSrc = $__curScript.src;

    // global behaviour flags
    this.warnings = false;
    this.defaultJSExtensions = false;
    this.pluginFirst = false;
    this.loaderErrorStack = false;

    // by default load ".json" files as json
    // leading * meta doesn't need normalization
    // NB add this in next breaking release
    // this.meta['*.json'] = { format: 'json' };

    // support the empty module, as a concept
    this.set('@empty', this.newModule({}));

    setProduction.call(this, false, false);
  };
});

// include the node require since we're overriding it
if (typeof require != 'undefined' && typeof process != 'undefined' && !process.browser)
  SystemJSLoader.prototype._nodeRequire = require;

/*
  Core SystemJS Normalization

  If a name is relative, we apply URL normalization to the page
  If a name is an absolute URL, we leave it as-is

  Plain names (neither of the above) run through the map and paths
  normalization phases.

  The paths normalization phase applies last (paths extension), which
  defines the `decanonicalize` function and normalizes everything into
  a URL.
 */

var parentModuleContext;
function getNodeModule(name, baseURL) {
  if (!isPlain(name))
    throw new Error('Node module ' + name + ' can\'t be loaded as it is not a package require.');

  if (!parentModuleContext) {
    var Module = this._nodeRequire('module');
    var base = baseURL.substr(isWindows ? 8 : 7);
    parentModuleContext = new Module(base);
    parentModuleContext.paths = Module._nodeModulePaths(base);
  }
  return parentModuleContext.require(name);
}

function coreResolve(name, parentName) {
  // standard URL resolution
  if (isRel(name))
    return urlResolve(name, parentName);
  else if (isAbsolute(name))
    return name;

  // plain names not starting with './', '://' and '/' go through custom resolution
  var mapMatch = getMapMatch(this.map, name);

  if (mapMatch) {
    name = this.map[mapMatch] + name.substr(mapMatch.length);

    if (isRel(name))
      return urlResolve(name);
    else if (isAbsolute(name))
      return name;
  }

  if (this.has(name))
    return name;

  // dynamically load node-core modules when requiring `@node/fs` for example
  if (name.substr(0, 6) == '@node/') {
    if (!this._nodeRequire)
      throw new TypeError('Error loading ' + name + '. Can only load node core modules in Node.');
    if (this.builder)
      this.set(name, this.newModule({}));
    else
      this.set(name, this.newModule(getESModule(getNodeModule.call(this, name.substr(6), this.baseURL))));
    return name;
  }

  // prepare the baseURL to ensure it is normalized
  prepareBaseURL.call(this);

  return applyPaths(this, name) || this.baseURL + name;
}

hook('normalize', function(normalize) {
  return function(name, parentName, skipExt) {
    var resolved = coreResolve.call(this, name, parentName);
    if (this.defaultJSExtensions && !skipExt && resolved.substr(resolved.length - 3, 3) != '.js' && !isPlain(resolved))
      resolved += '.js';
    return resolved;
  };
});

// percent encode just '#' in urls if using HTTP requests
var httpRequest = typeof XMLHttpRequest != 'undefined';
hook('locate', function(locate) {
  return function(load) {
    return Promise.resolve(locate.call(this, load))
    .then(function(address) {
      if (httpRequest)
        return address.replace(/#/g, '%23');
      return address;
    });
  };
});

/*
 * Fetch with authorization
 */
hook('fetch', function() {
  return function(load) {
    return new Promise(function(resolve, reject) {
      fetchTextFromURL(load.address, load.metadata.authorization, resolve, reject);
    });
  };
});

/*
  __useDefault

  When a module object looks like:
  newModule(
    __useDefault: true,
    default: 'some-module'
  })

  Then importing that module provides the 'some-module'
  result directly instead of the full module.

  Useful for eg module.exports = function() {}
*/
hook('import', function(systemImport) {
  return function(name, parentName, parentAddress) {
    if (parentName && parentName.name)
      warn.call(this, 'SystemJS.import(name, { name: parentName }) is deprecated for SystemJS.import(name, parentName), while importing ' + name + ' from ' + parentName.name);
    return systemImport.call(this, name, parentName, parentAddress).then(function(module) {
      return module.__useDefault ? module['default'] : module;
    });
  };
});

/*
 * Allow format: 'detect' meta to enable format detection
 */
hook('translate', function(systemTranslate) {
  return function(load) {
    if (load.metadata.format == 'detect')
      load.metadata.format = undefined;
    return systemTranslate.apply(this, arguments);
  };
});


/*
 * JSON format support
 *
 * Supports loading JSON files as a module format itself
 *
 * Usage:
 *
 * SystemJS.config({
 *   meta: {
 *     '*.json': { format: 'json' }
 *   }
 * });
 *
 * Module is returned as if written:
 *
 * export default {JSON}
 *
 * No named exports are provided
 *
 * Files ending in ".json" are treated as json automatically by SystemJS
 */
hook('instantiate', function(instantiate) {
  return function(load) {
    if (load.metadata.format == 'json' && !this.builder) {
      var entry = load.metadata.entry = createEntry();
      entry.deps = [];
      entry.execute = function() {
        try {
          return JSON.parse(load.source);
        }
        catch(e) {
          throw new Error("Invalid JSON file " + load.name);
        }
      };
    }
  };
})

/*
 Extend config merging one deep only

  loader.config({
    some: 'random',
    config: 'here',
    deep: {
      config: { too: 'too' }
    }
  });

  <=>

  loader.some = 'random';
  loader.config = 'here'
  loader.deep = loader.deep || {};
  loader.deep.config = { too: 'too' };


  Normalizes meta and package configs allowing for:

  SystemJS.config({
    meta: {
      './index.js': {}
    }
  });

  To become

  SystemJS.meta['https://thissite.com/index.js'] = {};

  For easy normalization canonicalization with latest URL support.

*/
function envSet(loader, cfg, envCallback) {
  if (envModule.browser && cfg.browserConfig)
    envCallback(cfg.browserConfig);
  if (envModule.node && cfg.nodeConfig)
    envCallback(cfg.nodeConfig);
  if (envModule.dev && cfg.devConfig)
    envCallback(cfg.devConfig);
  if (envModule.build && cfg.buildConfig)
    envCallback(cfg.buildConfig);
  if (envModule.production && cfg.productionConfig)
    envCallback(cfg.productionConfig);
}

SystemJSLoader.prototype.getConfig = function(name) {
  var cfg = {};
  var loader = this;
  for (var p in loader) {
    if (loader.hasOwnProperty && !loader.hasOwnProperty(p) || p in SystemJSLoader.prototype && p != 'transpiler')
      continue;
    if (indexOf.call(['_loader', 'amdDefine', 'amdRequire', 'defined', 'failed', 'version', 'loads'], p) == -1)
      cfg[p] = loader[p];
  }
  cfg.production = envModule.production;
  return cfg;
};

var curCurScript;
SystemJSLoader.prototype.config = function(cfg, isEnvConfig) {
  var loader = this;

  if ('loaderErrorStack' in cfg) {
    curCurScript = $__curScript;
    if (cfg.loaderErrorStack)
      $__curScript = undefined;
    else
      $__curScript = curCurScript;
  }

  if ('warnings' in cfg)
    loader.warnings = cfg.warnings;

  // transpiler deprecation path
  if (cfg.transpilerRuntime === false)
    loader._loader.loadedTranspilerRuntime = true;

  if ('production' in cfg || 'build' in cfg)
    setProduction.call(loader, !!cfg.production, !!(cfg.build || envModule && envModule.build));

  if (!isEnvConfig) {
    // if using nodeConfig / browserConfig / productionConfig, take baseURL from there
    // these exceptions will be unnecessary when we can properly implement config queuings
    var baseURL;
    envSet(loader, cfg, function(cfg) {
      baseURL = baseURL || cfg.baseURL;
    });
    baseURL = baseURL || cfg.baseURL;

    // always configure baseURL first
    if (baseURL) {
      var hasConfig = false;
      function checkHasConfig(obj) {
        for (var p in obj)
          if (obj.hasOwnProperty(p))
            return true;
      }
      if (checkHasConfig(loader.packages) || checkHasConfig(loader.meta) || checkHasConfig(loader.depCache) || checkHasConfig(loader.bundles) || checkHasConfig(loader.packageConfigPaths))
        throw new TypeError('Incorrect configuration order. The baseURL must be configured with the first SystemJS.config call.');

      this.baseURL = baseURL;
      prepareBaseURL.call(this);
    }

    if (cfg.paths)
      extend(loader.paths, cfg.paths);

    envSet(loader, cfg, function(cfg) {
      if (cfg.paths)
        extend(loader.paths, cfg.paths);
    });

    // warn on wildcard path deprecations
    if (this.warnings) {
      for (var p in loader.paths)
        if (p.indexOf('*') != -1)
          warn.call(loader, 'Paths configuration "' + p + '" -> "' + loader.paths[p] + '" uses wildcards which are being deprecated for just leaving a trailing "/" to indicate folder paths.');
    }
  }

  if (cfg.defaultJSExtensions) {
    loader.defaultJSExtensions = cfg.defaultJSExtensions;
    warn.call(loader, 'The defaultJSExtensions configuration option is deprecated, use packages configuration instead.');
  }

  if (cfg.pluginFirst)
    loader.pluginFirst = cfg.pluginFirst;

  if (cfg.map) {
    for (var p in cfg.map) {
      var v = cfg.map[p];

      // object map backwards-compat into packages configuration
      if (typeof v !== 'string') {
        var defaultJSExtension = loader.defaultJSExtensions && p.substr(p.length - 3, 3) != '.js';
        var prop = loader.decanonicalize(p);
        if (defaultJSExtension && prop.substr(prop.length - 3, 3) == '.js')
          prop = prop.substr(0, prop.length - 3);

        // if a package main, revert it
        var pkgMatch = '';
        for (var pkg in loader.packages) {
          if (prop.substr(0, pkg.length) == pkg
              && (!prop[pkg.length] || prop[pkg.length] == '/')
              && pkgMatch.split('/').length < pkg.split('/').length)
            pkgMatch = pkg;
        }
        if (pkgMatch && loader.packages[pkgMatch].main)
          prop = prop.substr(0, prop.length - loader.packages[pkgMatch].main.length - 1);

        var pkg = loader.packages[prop] = loader.packages[prop] || {};
        pkg.map = v;
      }
      else {
        loader.map[p] = v;
      }
    }
  }

  if (cfg.packageConfigPaths) {
    var packageConfigPaths = [];
    for (var i = 0; i < cfg.packageConfigPaths.length; i++) {
      var path = cfg.packageConfigPaths[i];
      var packageLength = Math.max(path.lastIndexOf('*') + 1, path.lastIndexOf('/'));
      var normalized = coreResolve.call(loader, path.substr(0, packageLength));
      packageConfigPaths[i] = normalized + path.substr(packageLength);
    }
    loader.packageConfigPaths = packageConfigPaths;
  }

  if (cfg.bundles) {
    for (var p in cfg.bundles) {
      var bundle = [];
      for (var i = 0; i < cfg.bundles[p].length; i++) {
        var defaultJSExtension = loader.defaultJSExtensions && cfg.bundles[p][i].substr(cfg.bundles[p][i].length - 3, 3) != '.js';
        var normalizedBundleDep = loader.decanonicalize(cfg.bundles[p][i]);
        if (defaultJSExtension && normalizedBundleDep.substr(normalizedBundleDep.length - 3, 3) == '.js')
          normalizedBundleDep = normalizedBundleDep.substr(0, normalizedBundleDep.length - 3);
        bundle.push(normalizedBundleDep);
      }
      loader.bundles[p] = bundle;
    }
  }

  if (cfg.packages) {
    for (var p in cfg.packages) {
      if (p.match(/^([^\/]+:)?\/\/$/))
        throw new TypeError('"' + p + '" is not a valid package name.');

      var prop = coreResolve.call(loader, p);

      // allow trailing slash in packages
      if (prop[prop.length - 1] == '/')
        prop = prop.substr(0, prop.length - 1);

      setPkgConfig(loader, prop, cfg.packages[p], false);
    }
  }

  for (var c in cfg) {
    var v = cfg[c];

    if (indexOf.call(['baseURL', 'map', 'packages', 'bundles', 'paths', 'warnings', 'packageConfigPaths',
          'loaderErrorStack', 'browserConfig', 'nodeConfig', 'devConfig', 'buildConfig', 'productionConfig'], c) != -1)
      continue;

    if (typeof v != 'object' || v instanceof Array) {
      loader[c] = v;
    }
    else {
      loader[c] = loader[c] || {};

      for (var p in v) {
        // base-level wildcard meta does not normalize to retain catch-all quality
        if (c == 'meta' && p[0] == '*') {
          extend(loader[c][p] = loader[c][p] || {}, v[p]);
        }
        else if (c == 'meta') {
          // meta can go through global map, with defaultJSExtensions adding
          var resolved = coreResolve.call(loader, p);
          if (loader.defaultJSExtensions && resolved.substr(resolved.length - 3, 3) != '.js' && !isPlain(resolved))
            resolved += '.js';
          extend(loader[c][resolved] = loader[c][resolved] || {}, v[p]);
        }
        else if (c == 'depCache') {
          var defaultJSExtension = loader.defaultJSExtensions && p.substr(p.length - 3, 3) != '.js';
          var prop = loader.decanonicalize(p);
          if (defaultJSExtension && prop.substr(prop.length - 3, 3) == '.js')
            prop = prop.substr(0, prop.length - 3);
          loader[c][prop] = [].concat(v[p]);
        }
        else {
          loader[c][p] = v[p];
        }
      }
    }
  }

  envSet(loader, cfg, function(cfg) {
    loader.config(cfg, true);
  });
};
/*
 * Package Configuration Extension
 *
 * Example:
 *
 * SystemJS.packages = {
 *   jquery: {
 *     main: 'index.js', // when not set, package name is requested directly
 *     format: 'amd',
 *     defaultExtension: 'ts', // defaults to 'js', can be set to false
 *     modules: {
 *       '*.ts': {
 *         loader: 'typescript'
 *       },
 *       'vendor/sizzle.js': {
 *         format: 'global'
 *       }
 *     },
 *     map: {
 *        // map internal require('sizzle') to local require('./vendor/sizzle')
 *        sizzle: './vendor/sizzle.js',
 *        // map any internal or external require of 'jquery/vendor/another' to 'another/index.js'
 *        './vendor/another.js': './another/index.js',
 *        // test.js / test -> lib/test.js
 *        './test.js': './lib/test.js',
 *
 *        // environment-specific map configurations
 *        './index.js': {
 *          '~browser': './index-node.js',
 *          './custom-condition.js|~export': './index-custom.js'
 *        }
 *     },
 *     // allows for setting package-prefixed depCache
 *     // keys are normalized module names relative to the package itself
 *     depCache: {
 *       // import 'package/index.js' loads in parallel package/lib/test.js,package/vendor/sizzle.js
 *       './index.js': ['./test'],
 *       './test.js': ['external-dep'],
 *       'external-dep/path.js': ['./another.js']
 *     }
 *   }
 * };
 *
 * Then:
 *   import 'jquery'                       -> jquery/index.js
 *   import 'jquery/submodule'             -> jquery/submodule.js
 *   import 'jquery/submodule.ts'          -> jquery/submodule.ts loaded as typescript
 *   import 'jquery/vendor/another'        -> another/index.js
 *
 * Detailed Behaviours
 * - main can have a leading "./" can be added optionally
 * - map and defaultExtension are applied to the main
 * - defaultExtension adds the extension only if the exact extension is not present
 * - defaultJSExtensions applies after map when defaultExtension is not set
 * - if a meta value is available for a module, map and defaultExtension are skipped
 * - like global map, package map also applies to subpaths (sizzle/x, ./vendor/another/sub)
 * - condition module map is '@env' module in package or '@system-env' globally
 * - map targets support conditional interpolation ('./x': './x.#{|env}.js')
 * - internal package map targets cannot use boolean conditionals
 *
 * Package Configuration Loading
 *
 * Not all packages may already have their configuration present in the System config
 * For these cases, a list of packageConfigPaths can be provided, which when matched against
 * a request, will first request a ".json" file by the package name to derive the package
 * configuration from. This allows dynamic loading of non-predetermined code, a key use
 * case in SystemJS.
 *
 * Example:
 *
 *   SystemJS.packageConfigPaths = ['packages/test/package.json', 'packages/*.json'];
 *
 *   // will first request 'packages/new-package/package.json' for the package config
 *   // before completing the package request to 'packages/new-package/path'
 *   SystemJS.import('packages/new-package/path');
 *
 *   // will first request 'packages/test/package.json' before the main
 *   SystemJS.import('packages/test');
 *
 * When a package matches packageConfigPaths, it will always send a config request for
 * the package configuration.
 * The package name itself is taken to be the match up to and including the last wildcard
 * or trailing slash.
 * The most specific package config path will be used.
 * Any existing package configurations for the package will deeply merge with the
 * package config, with the existing package configurations taking preference.
 * To opt-out of the package configuration request for a package that matches
 * packageConfigPaths, use the { configured: true } package config option.
 *
 */
(function() {

  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.packages = {};
      this.packageConfigPaths = [];
    };
  });

  function getPackage(loader, normalized) {
    // use most specific package
    var curPkg, curPkgLen = 0, pkgLen;
    for (var p in loader.packages) {
      if (normalized.substr(0, p.length) === p && (normalized.length === p.length || normalized[p.length] === '/')) {
        pkgLen = p.split('/').length;
        if (pkgLen > curPkgLen) {
          curPkg = p;
          curPkgLen = pkgLen;
        }
      }
    }
    return curPkg;
  }

  function addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions) {
    // don't apply extensions to folders or if defaultExtension = false
    if (!subPath || subPath[subPath.length - 1] == '/' || skipExtensions || pkg.defaultExtension === false)
      return subPath;

    var metaMatch = false;

    // exact meta or meta with any content after the last wildcard skips extension
    if (pkg.meta)
      getMetaMatches(pkg.meta, subPath, function(metaPattern, matchMeta, matchDepth) {
        if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1)
          return metaMatch = true;
      });

    // exact global meta or meta with any content after the last wildcard skips extension
    if (!metaMatch && loader.meta)
      getMetaMatches(loader.meta, pkgName + '/' + subPath, function(metaPattern, matchMeta, matchDepth) {
        if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1)
          return metaMatch = true;
      });

    if (metaMatch)
      return subPath;

    // work out what the defaultExtension is and add if not there already
    // NB reconsider if default should really be ".js"?
    var defaultExtension = '.' + (pkg.defaultExtension || 'js');
    if (subPath.substr(subPath.length - defaultExtension.length) != defaultExtension)
      return subPath + defaultExtension;
    else
      return subPath;
  }

  function applyPackageConfigSync(loader, pkg, pkgName, subPath, skipExtensions) {
    // main
    if (!subPath) {
      if (pkg.main)
        subPath = pkg.main.substr(0, 2) == './' ? pkg.main.substr(2) : pkg.main;
      // also no submap if name is package itself (import 'pkg' -> 'path/to/pkg.js')
      else
        // NB can add a default package main convention here when defaultJSExtensions is deprecated
        // if it becomes internal to the package then it would no longer be an exit path
        return pkgName + (loader.defaultJSExtensions ? '.js' : '');
    }

    // map config checking without then with extensions
    if (pkg.map) {
      var mapPath = './' + subPath;

      var mapMatch = getMapMatch(pkg.map, mapPath);

      // we then check map with the default extension adding
      if (!mapMatch) {
        mapPath = './' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
        if (mapPath != './' + subPath)
          mapMatch = getMapMatch(pkg.map, mapPath);
      }
      if (mapMatch) {
        var mapped = doMapSync(loader, pkg, pkgName, mapMatch, mapPath, skipExtensions);
        if (mapped)
          return mapped;
      }
    }

    // normal package resolution
    return pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
  }

  function validMapping(mapMatch, mapped, pkgName, path) {
    // disallow internal to subpath maps
    if (mapMatch == '.')
      throw new Error('Package ' + pkgName + ' has a map entry for "." which is not permitted.');
    
    // allow internal ./x -> ./x/y or ./x/ -> ./x/y recursive maps
    // but only if the path is exactly ./x and not ./x/z
    if (mapped.substr(0, mapMatch.length) == mapMatch && path.length > mapMatch.length)
      return false;

    return true;
  }

  function doMapSync(loader, pkg, pkgName, mapMatch, path, skipExtensions) {
    if (path[path.length - 1] == '/')
      path = path.substr(0, path.length - 1);
    var mapped = pkg.map[mapMatch];

    if (typeof mapped == 'object')
      throw new Error('Synchronous conditional normalization not supported sync normalizing ' + mapMatch + ' in ' + pkgName);

    if (!validMapping(mapMatch, mapped, pkgName, path) || typeof mapped != 'string')
      return;

    // package map to main / base-level
    if (mapped == '.')
      mapped = pkgName;

    // internal package map
    else if (mapped.substr(0, 2) == './')
      return pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, mapped.substr(2) + path.substr(mapMatch.length), skipExtensions);
    
    // external map reference
    return loader.normalizeSync(mapped + path.substr(mapMatch.length), pkgName + '/');
  }

  function applyPackageConfig(loader, pkg, pkgName, subPath, skipExtensions) {
    // main
    if (!subPath) {
      if (pkg.main)
        subPath = pkg.main.substr(0, 2) == './' ? pkg.main.substr(2) : pkg.main;
      // also no submap if name is package itself (import 'pkg' -> 'path/to/pkg.js')
      else
        // NB can add a default package main convention here when defaultJSExtensions is deprecated
        // if it becomes internal to the package then it would no longer be an exit path
        return Promise.resolve(pkgName + (loader.defaultJSExtensions ? '.js' : ''));
    }

    // map config checking without then with extensions
    var mapPath, mapMatch;

    if (pkg.map) {
      mapPath = './' + subPath;
      mapMatch = getMapMatch(pkg.map, mapPath);

      // we then check map with the default extension adding
      if (!mapMatch) {
        mapPath = './' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
        if (mapPath != './' + subPath)
          mapMatch = getMapMatch(pkg.map, mapPath);
      }
    }

    return (mapMatch ? doMap(loader, pkg, pkgName, mapMatch, mapPath, skipExtensions) : Promise.resolve())
    .then(function(mapped) {
      if (mapped)
        return Promise.resolve(mapped);

      // normal package resolution / fallback resolution for no conditional match
      return Promise.resolve(pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions));
    });
  }

  function doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions) {
    // NB the interpolation cases should strictly skip subsequent interpolation
    // package map to main / base-level
    if (mapped == '.')
      mapped = pkgName;
    
    // internal package map
    else if (mapped.substr(0, 2) == './')
      return Promise.resolve(pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, mapped.substr(2) + path.substr(mapMatch.length), skipExtensions))
      .then(function(name) {
        return interpolateConditional.call(loader, name, pkgName + '/');
      });
    
    // external map reference
    return loader.normalize(mapped + path.substr(mapMatch.length), pkgName + '/');
  }

  function doMap(loader, pkg, pkgName, mapMatch, path, skipExtensions) {
    if (path[path.length - 1] == '/')
      path = path.substr(0, path.length - 1);

    var mapped = pkg.map[mapMatch];

    if (typeof mapped == 'string') {
      if (!validMapping(mapMatch, mapped, pkgName, path))
        return Promise.resolve();
      return doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions);
    }

    // we use a special conditional syntax to allow the builder to handle conditional branch points further
    if (loader.builder)
      return Promise.resolve(pkgName + '/#:' + path);

    // we load all conditions upfront
    var conditionPromises = [];
    var conditions = [];
    for (var e in mapped) {
      var c = parseCondition(e);
      conditions.push({
        condition: c,
        map: mapped[e]
      });
      conditionPromises.push(loader['import'](c.module, pkgName));
    }

    // map object -> conditional map
    return Promise.all(conditionPromises)
    .then(function(conditionValues) {
      // first map condition to match is used
      for (var i = 0; i < conditions.length; i++) {
        var c = conditions[i].condition;
        var value = readMemberExpression(c.prop, conditionValues[i]);
        if (!c.negate && value || c.negate && !value)
          return conditions[i].map;
      }
    })
    .then(function(mapped) {
      if (mapped) {
        if (!validMapping(mapMatch, mapped, pkgName, path))
          return;
        return doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions);
      }

      // no environment match -> fallback to original subPath by returning undefined
    });
  }

  // normalizeSync = decanonicalize + package resolution
  SystemJSLoader.prototype.normalizeSync = SystemJSLoader.prototype.decanonicalize = SystemJSLoader.prototype.normalize;

  // decanonicalize must JUST handle package defaultExtension: false case when defaultJSExtensions is set
  // to be deprecated!
  hook('decanonicalize', function(decanonicalize) {
    return function(name, parentName) {
      if (this.builder)
        return decanonicalize.call(this, name, parentName, true);

      var decanonicalized = decanonicalize.call(this, name, parentName, false);

      if (!this.defaultJSExtensions)
        return decanonicalized;
    
      var pkgName = getPackage(this, decanonicalized);

      var pkg = this.packages[pkgName];
      var defaultExtension = pkg && pkg.defaultExtension;

      if (defaultExtension == undefined && pkg && pkg.meta)
        getMetaMatches(pkg.meta, decanonicalized.substr(pkgName), function(metaPattern, matchMeta, matchDepth) {
          if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1) {
            defaultExtension = false;
            return true;
          }
        });
      
      if ((defaultExtension === false || defaultExtension && defaultExtension != '.js') && name.substr(name.length - 3, 3) != '.js' && decanonicalized.substr(decanonicalized.length - 3, 3) == '.js')
        decanonicalized = decanonicalized.substr(0, decanonicalized.length - 3);

      return decanonicalized;
    };
  });

  hook('normalizeSync', function(normalizeSync) {
    return function(name, parentName, isPlugin) {
      var loader = this;
      isPlugin = isPlugin === true;

      // apply contextual package map first
      // (we assume the parent package config has already been loaded)
      if (parentName)
        var parentPackageName = getPackage(loader, parentName) ||
            loader.defaultJSExtensions && parentName.substr(parentName.length - 3, 3) == '.js' &&
            getPackage(loader, parentName.substr(0, parentName.length - 3));

      var parentPackage = parentPackageName && loader.packages[parentPackageName];

      // ignore . since internal maps handled by standard package resolution
      if (parentPackage && name[0] != '.') {
        var parentMap = parentPackage.map;
        var parentMapMatch = parentMap && getMapMatch(parentMap, name);

        if (parentMapMatch && typeof parentMap[parentMapMatch] == 'string') {
          var mapped = doMapSync(loader, parentPackage, parentPackageName, parentMapMatch, name, isPlugin);      
          if (mapped)
            return mapped;
        }
      }

      var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';

      // apply map, core, paths, contextual package map
      var normalized = normalizeSync.call(loader, name, parentName, false);

      // undo defaultJSExtension
      if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) != '.js')
        defaultJSExtension = false;
      if (defaultJSExtension)
        normalized = normalized.substr(0, normalized.length - 3);

      var pkgConfigMatch = getPackageConfigMatch(loader, normalized);
      var pkgName = pkgConfigMatch && pkgConfigMatch.packageName || getPackage(loader, normalized);

      if (!pkgName)
        return normalized + (defaultJSExtension ? '.js' : '');

      var subPath = normalized.substr(pkgName.length + 1);

      return applyPackageConfigSync(loader, loader.packages[pkgName] || {}, pkgName, subPath, isPlugin);
    };
  });

  hook('normalize', function(normalize) {
    return function(name, parentName, isPlugin) {
      var loader = this;
      isPlugin = isPlugin === true;

      return Promise.resolve()
      .then(function() {
        // apply contextual package map first
        // (we assume the parent package config has already been loaded)
        if (parentName)
          var parentPackageName = getPackage(loader, parentName) ||
              loader.defaultJSExtensions && parentName.substr(parentName.length - 3, 3) == '.js' &&
              getPackage(loader, parentName.substr(0, parentName.length - 3));

        var parentPackage = parentPackageName && loader.packages[parentPackageName];

        // ignore . since internal maps handled by standard package resolution
        if (parentPackage && name.substr(0, 2) != './') {
          var parentMap = parentPackage.map;
          var parentMapMatch = parentMap && getMapMatch(parentMap, name);

          if (parentMapMatch)
            return doMap(loader, parentPackage, parentPackageName, parentMapMatch, name, isPlugin);
        }

        return Promise.resolve();
      })
      .then(function(mapped) {
        if (mapped)
          return mapped;

        var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';

        // apply map, core, paths, contextual package map
        var normalized = normalize.call(loader, name, parentName, false);

        // undo defaultJSExtension
        if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) != '.js')
          defaultJSExtension = false;
        if (defaultJSExtension)
          normalized = normalized.substr(0, normalized.length - 3);

        var pkgConfigMatch = getPackageConfigMatch(loader, normalized);
        var pkgName = pkgConfigMatch && pkgConfigMatch.packageName || getPackage(loader, normalized);

        if (!pkgName)
          return Promise.resolve(normalized + (defaultJSExtension ? '.js' : ''));

        var pkg = loader.packages[pkgName];

        // if package is already configured or not a dynamic config package, use existing package config
        var isConfigured = pkg && (pkg.configured || !pkgConfigMatch);
        return (isConfigured ? Promise.resolve(pkg) : loadPackageConfigPath(loader, pkgName, pkgConfigMatch.configPath))
        .then(function(pkg) {
          var subPath = normalized.substr(pkgName.length + 1);

          return applyPackageConfig(loader, pkg, pkgName, subPath, isPlugin);
        });
      });
    };
  });

  // check if the given normalized name matches a packageConfigPath
  // if so, loads the config
  var packageConfigPaths = {};

  // data object for quick checks against package paths
  function createPkgConfigPathObj(path) {
    var lastWildcard = path.lastIndexOf('*');
    var length = Math.max(lastWildcard + 1, path.lastIndexOf('/'));
    return {
      length: length,
      regEx: new RegExp('^(' + path.substr(0, length).replace(/[.+?^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '[^\\/]+') + ')(\\/|$)'),
      wildcard: lastWildcard != -1
    };
  }

  // most specific match wins
  function getPackageConfigMatch(loader, normalized) {
    var pkgName, exactMatch = false, configPath;
    for (var i = 0; i < loader.packageConfigPaths.length; i++) {
      var packageConfigPath = loader.packageConfigPaths[i];
      var p = packageConfigPaths[packageConfigPath] || (packageConfigPaths[packageConfigPath] = createPkgConfigPathObj(packageConfigPath));
      if (normalized.length < p.length)
        continue;
      var match = normalized.match(p.regEx);
      if (match && (!pkgName || (!(exactMatch && p.wildcard) && pkgName.length < match[1].length))) {
        pkgName = match[1];
        exactMatch = !p.wildcard;
        configPath = pkgName + packageConfigPath.substr(p.length);
      }
    }

    if (!pkgName)
      return;

    return {
      packageName: pkgName,
      configPath: configPath
    };
  }

  function loadPackageConfigPath(loader, pkgName, pkgConfigPath) {
    var configLoader = loader.pluginLoader || loader;

    // NB remove this when json is default
    (configLoader.meta[pkgConfigPath] = configLoader.meta[pkgConfigPath] || {}).format = 'json';
    configLoader.meta[pkgConfigPath].loader = null;

    return configLoader.load(pkgConfigPath)
    .then(function() {
      var cfg = configLoader.get(pkgConfigPath)['default'];

      // support "systemjs" prefixing
      if (cfg.systemjs)
        cfg = cfg.systemjs;

      // modules backwards compatibility
      if (cfg.modules) {
        cfg.meta = cfg.modules;
        warn.call(loader, 'Package config file ' + pkgConfigPath + ' is configured with "modules", which is deprecated as it has been renamed to "meta".');
      }

      return setPkgConfig(loader, pkgName, cfg, true);
    });
  }

  function getMetaMatches(pkgMeta, subPath, matchFn) {
    // wildcard meta
    var meta = {};
    var wildcardIndex;
    for (var module in pkgMeta) {
      // allow meta to start with ./ for flexibility
      var dotRel = module.substr(0, 2) == './' ? './' : '';
      if (dotRel)
        module = module.substr(2);

      wildcardIndex = module.indexOf('*');
      if (wildcardIndex === -1)
        continue;

      if (module.substr(0, wildcardIndex) == subPath.substr(0, wildcardIndex)
          && module.substr(wildcardIndex + 1) == subPath.substr(subPath.length - module.length + wildcardIndex + 1)) {
        // alow match function to return true for an exit path
        if (matchFn(module, pkgMeta[dotRel + module], module.split('/').length))
          return;
      }
    }
    // exact meta
    var exactMeta = pkgMeta[subPath] && pkgMeta.hasOwnProperty && pkgMeta.hasOwnProperty(subPath) ? pkgMeta[subPath] : pkgMeta['./' + subPath];
    if (exactMeta)
      matchFn(exactMeta, exactMeta, 0);
  }

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      return Promise.resolve(locate.call(this, load))
      .then(function(address) {
        var pkgName = getPackage(loader, load.name);
        if (pkgName) {
          var pkg = loader.packages[pkgName];
          var subPath = load.name.substr(pkgName.length + 1);

          var meta = {};
          if (pkg.meta) {
            var bestDepth = 0;

            // NB support a main shorthand in meta here?
            getMetaMatches(pkg.meta, subPath, function(metaPattern, matchMeta, matchDepth) {
              if (matchDepth > bestDepth)
                bestDepth = matchDepth;
              extendMeta(meta, matchMeta, matchDepth && bestDepth > matchDepth);
            });

            extendMeta(load.metadata, meta);
          }

          // format
          if (pkg.format && !load.metadata.loader)
            load.metadata.format = load.metadata.format || pkg.format;
        }

        return address;
      });
    };
  });

})();
/*
 * Script tag fetch
 *
 * When load.metadata.scriptLoad is true, we load via script tag injection.
 */
(function() {

  if (typeof document != 'undefined')
    var head = document.getElementsByTagName('head')[0];

  var curSystem;
  var curRequire;

  // if doing worker executing, this is set to the load record being executed
  var workerLoad = null;
  
  // interactive mode handling method courtesy RequireJS
  var ieEvents = head && (function() {
    var s = document.createElement('script');
    var isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]';
    return s.attachEvent && !(s.attachEvent.toString && s.attachEvent.toString().indexOf('[native code') < 0) && !isOpera;
  })();

  // IE interactive-only part
  // we store loading scripts array as { script: <script>, load: {...} }
  var interactiveLoadingScripts = [];
  var interactiveScript;
  function getInteractiveScriptLoad() {
    if (interactiveScript && interactiveScript.script.readyState === 'interactive')
      return interactiveScript.load;

    for (var i = 0; i < interactiveLoadingScripts.length; i++)
      if (interactiveLoadingScripts[i].script.readyState == 'interactive') {
        interactiveScript = interactiveLoadingScripts[i];
        return interactiveScript.load;
      }
  }
  
  // System.register, System.registerDynamic, AMD define pipeline
  // this is called by the above methods when they execute
  // we then run the reduceRegister_ collection function either immediately
  // if we are in IE and know the currently executing script (interactive)
  // or later if we need to wait for the synchronous load callback to know the script
  var loadingCnt = 0;
  var registerQueue = [];
  hook('pushRegister_', function(pushRegister) {
    return function(register) {
      // if using eval-execution then skip
      if (pushRegister.call(this, register))
        return false;

      // if using worker execution, then we're done
      if (workerLoad)
        this.reduceRegister_(workerLoad, register);

      // detect if we know the currently executing load (IE)
      // if so, immediately call reduceRegister
      else if (ieEvents)
        this.reduceRegister_(getInteractiveScriptLoad(), register);

      // otherwise, add to our execution queue
      // to call reduceRegister on sync script load event
      else if (loadingCnt)
        registerQueue.push(register);

      // if we're not currently loading anything though
      // then do the reduction against a null load
      // (out of band named define or named register)
      // note even in non-script environments, this catch is used
      else
        this.reduceRegister_(null, register);

      return true;
    };
  });

  function webWorkerImport(loader, load) {
    return new Promise(function(resolve, reject) {
      if (load.metadata.integrity)
        reject(new Error('Subresource integrity checking is not supported in web workers.'));

      workerLoad = load;
      try {
        importScripts(load.address);
      }
      catch(e) {
        workerLoad = null;
        reject(e);
      }
      workerLoad = null;

      // if nothing registered, then something went wrong
      if (!load.metadata.entry)
        reject(new Error(load.address + ' did not call System.register or AMD define. If loading a global, ensure the meta format is set to global.'));

      resolve('');
    });
  }

  // override fetch to use script injection
  hook('fetch', function(fetch) {
    return function(load) {
      var loader = this;

      if (load.metadata.format == 'json' || !load.metadata.scriptLoad || (!isBrowser && !isWorker))
        return fetch.call(this, load);

      if (isWorker)
        return webWorkerImport(loader, load);

      return new Promise(function(resolve, reject) {
        var s = document.createElement('script');
        
        s.async = true;

        if (load.metadata.crossOrigin)
          s.crossOrigin = load.metadata.crossOrigin;

        if (load.metadata.integrity)
          s.setAttribute('integrity', load.metadata.integrity);

        if (ieEvents) {
          s.attachEvent('onreadystatechange', complete);
          interactiveLoadingScripts.push({
            script: s,
            load: load
          });
        }
        else {
          s.addEventListener('load', complete, false);
          s.addEventListener('error', error, false);
        }

        loadingCnt++;

        curSystem = __global.System;
        curRequire = __global.require;

        s.src = load.address;
        head.appendChild(s);

        function complete(evt) {
          if (s.readyState && s.readyState != 'loaded' && s.readyState != 'complete')
            return;

          loadingCnt--;

          // complete call is sync on execution finish
          // (in ie already done reductions)
          if (!load.metadata.entry && !registerQueue.length) {
            loader.reduceRegister_(load);
          }
          else if (!ieEvents) {
            for (var i = 0; i < registerQueue.length; i++)
              loader.reduceRegister_(load, registerQueue[i]);
            registerQueue = [];
          }

          cleanup();

          // if nothing registered, then something went wrong
          if (!load.metadata.entry && !load.metadata.bundle)
            reject(new Error(load.name + ' did not call System.register or AMD define. If loading a global module configure the global name via the meta exports property for script injection support.'));

          resolve('');
        }

        function error(evt) {
          cleanup();
          reject(new Error('Unable to load script ' + load.address));
        }

        function cleanup() {
          __global.System = curSystem;
          __global.require = curRequire;

          if (s.detachEvent) {
            s.detachEvent('onreadystatechange', complete);
            for (var i = 0; i < interactiveLoadingScripts.length; i++)
              if (interactiveLoadingScripts[i].script == s) {
                if (interactiveScript && interactiveScript.script == s)
                  interactiveScript = null;
                interactiveLoadingScripts.splice(i, 1);
              }
          }
          else {
            s.removeEventListener('load', complete, false);
            s.removeEventListener('error', error, false);
          }

          head.removeChild(s);
        }
      });
    };
  });
})();
/*
 * Instantiate registry extension
 *
 * Supports Traceur System.register 'instantiate' output for loading ES6 as ES5.
 *
 * - Creates the loader.register function
 * - Also supports metadata.format = 'register' in instantiate for anonymous register modules
 * - Also supports metadata.deps, metadata.execute and metadata.executingRequire
 *     for handling dynamic modules alongside register-transformed ES6 modules
 *
 *
 * The code here replicates the ES6 linking groups algorithm to ensure that
 * circular ES6 compiled into System.register can work alongside circular AMD
 * and CommonJS, identically to the actual ES6 loader.
 *
 */


/*
 * Registry side table entries in loader.defined
 * Registry Entry Contains:
 *    - name
 *    - deps
 *    - declare for declarative modules
 *    - execute for dynamic modules, different to declarative execute on module
 *    - executingRequire indicates require drives execution for circularity of dynamic modules
 *    - declarative optional boolean indicating which of the above
 *
 * Can preload modules directly on SystemJS.defined['my/module'] = { deps, execute, executingRequire }
 *
 * Then the entry gets populated with derived information during processing:
 *    - normalizedDeps derived from deps, created in instantiate
 *    - groupIndex used by group linking algorithm
 *    - evaluated indicating whether evaluation has happend
 *    - module the module record object, containing:
 *      - exports actual module exports
 *
 *    For dynamic we track the es module with:
 *    - esModule actual es module value
 *    - esmExports whether to extend the esModule with named exports
 *
 *    Then for declarative only we track dynamic bindings with the 'module' records:
 *      - name
 *      - exports
 *      - setters declarative setter functions
 *      - dependencies, module records of dependencies
 *      - importers, module records of dependents
 *
 * After linked and evaluated, entries are removed, declarative module records remain in separate
 * module binding table
 *
 */

var leadingCommentAndMetaRegEx = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)*\s*/;
function detectRegisterFormat(source) {
  var leadingCommentAndMeta = source.match(leadingCommentAndMetaRegEx);
  return leadingCommentAndMeta && source.substr(leadingCommentAndMeta[0].length, 15) == 'System.register';
}

function createEntry() {
  return {
    name: null,
    deps: null,
    originalIndices: null,
    declare: null,
    execute: null,
    executingRequire: false,
    declarative: false,
    normalizedDeps: null,
    groupIndex: null,
    evaluated: false,
    module: null,
    esModule: null,
    esmExports: false
  };
}

(function() {

  /*
   * There are two variations of System.register:
   * 1. System.register for ES6 conversion (2-3 params) - System.register([name, ]deps, declare)
   *    see https://github.com/ModuleLoader/es6-module-loader/wiki/System.register-Explained
   *
   * 2. System.registerDynamic for dynamic modules (3-4 params) - System.registerDynamic([name, ]deps, executingRequire, execute)
   * the true or false statement
   *
   * this extension implements the linking algorithm for the two variations identical to the spec
   * allowing compiled ES6 circular references to work alongside AMD and CJS circular references.
   *
   */
  SystemJSLoader.prototype.register = function(name, deps, declare) {
    if (typeof name != 'string') {
      declare = deps;
      deps = name;
      name = null;
    }

    // dynamic backwards-compatibility
    // can be deprecated eventually
    if (typeof declare == 'boolean')
      return this.registerDynamic.apply(this, arguments);

    var entry = createEntry();
    // ideally wouldn't apply map config to bundle names but
    // dependencies go through map regardless so we can't restrict
    // could reconsider in shift to new spec
    entry.name = name && (this.decanonicalize || this.normalize).call(this, name);
    entry.declarative = true;
    entry.deps = deps;
    entry.declare = declare;

    this.pushRegister_({
      amd: false,
      entry: entry
    });
  };
  SystemJSLoader.prototype.registerDynamic = function(name, deps, declare, execute) {
    if (typeof name != 'string') {
      execute = declare;
      declare = deps;
      deps = name;
      name = null;
    }

    // dynamic
    var entry = createEntry();
    entry.name = name && (this.decanonicalize || this.normalize).call(this, name);
    entry.deps = deps;
    entry.execute = execute;
    entry.executingRequire = declare;

    this.pushRegister_({
      amd: false,
      entry: entry
    });
  };
  hook('reduceRegister_', function() {
    return function(load, register) {
      if (!register)
        return;

      var entry = register.entry;
      var curMeta = load && load.metadata;

      // named register
      if (entry.name) {
        if (!(entry.name in this.defined))
          this.defined[entry.name] = entry;

        if (curMeta)
          curMeta.bundle = true;
      }
      // anonymous register
      if (!entry.name || load && !curMeta.entry && entry.name == load.name) {
        if (!curMeta)
          throw new TypeError('Invalid System.register call. Anonymous System.register calls can only be made by modules loaded by SystemJS.import and not via script tags.');
        if (curMeta.entry) {
          if (curMeta.format == 'register')
            throw new Error('Multiple anonymous System.register calls in module ' + load.name + '. If loading a bundle, ensure all the System.register calls are named.');
          else
            throw new Error('Module ' + load.name + ' interpreted as ' + curMeta.format + ' module format, but called System.register.');
        }
        if (!curMeta.format)
          curMeta.format = 'register';
        curMeta.entry = entry;
      }
    };
  });

  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);

      this.defined = {};
      this._loader.moduleRecords = {};
    };
  });

  function buildGroups(entry, loader, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === null || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== null) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new Error("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, loader, groups);
    }
  }

  function link(name, startEntry, loader) {
    // skip if already linked
    if (startEntry.module)
      return;

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, loader, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry, loader);
        else
          linkDynamicModule(entry, loader);
      }
      curGroupDeclarative = !curGroupDeclarative;
    }
  }

  // module binding records
  function ModuleRecord() {}
  defineProperty(ModuleRecord, 'toString', {
    value: function() {
      return 'Module';
    }
  });

  function getOrCreateModuleRecord(name, moduleRecords) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: new ModuleRecord(), // start from an empty module and extend
      importers: []
    });
  }

  function linkDeclarativeModule(entry, loader) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var moduleRecords = loader._loader.moduleRecords;
    var module = entry.module = getOrCreateModuleRecord(entry.name, moduleRecords);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(__global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          var setter = importerModule.setters[importerIndex];
          if (setter)
            setter(exports);
        }
      }

      module.locked = false;
      return value;
    }, { id: entry.name });

    if (typeof declaration == 'function')
      declaration = { setters: [], execute: declaration };

    // allowing undefined declaration was a mistake! To be deprecated.
    declaration = declaration || { setters: [], execute: function() {} };

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute) {
      throw new TypeError('Invalid System.register form for ' + entry.name);
    }

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      // dynamic, already linked in our registry
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the loader registry
      else if (!depEntry) {
        depExports = loader.get(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry, loader);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else {
        module.dependencies.push(null);
      }

      // run setters for all entries with the matching dependency name
      var originalIndices = entry.originalIndices[i];
      for (var j = 0, len = originalIndices.length; j < len; ++j) {
        var index = originalIndices[j];
        if (module.setters[index]) {
          module.setters[index](depExports);
        }
      }
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name, loader) {
    var exports;
    var entry = loader.defined[name];

    if (!entry) {
      exports = loader.get(name);
      if (!exports)
        throw new Error('Unable to load dependency ' + name + '.');
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, entry, [], loader);

      else if (!entry.evaluated)
        linkDynamicModule(entry, loader);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry, loader) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        // we know we only need to link dynamic due to linking algorithm
        var depEntry = loader.defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry, loader);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(__global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i], loader);
      }
      // try and normalize the dependency to see if we have another form
      var nameNormalized = loader.normalizeSync(name, entry.name);
      if (indexOf.call(entry.normalizedDeps, nameNormalized) != -1)
        return getModule(nameNormalized, loader);

      throw new Error('Module ' + name + ' not declared as a dependency of ' + entry.name);
    }, exports, module);

    if (output !== undefined)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;

    // __esModule flag treats as already-named
    if (exports && (exports.__esModule || exports instanceof Module))
      entry.esModule = loader.newModule(exports);
    // set module as 'default' export, then fake named exports by iterating properties
    else if (entry.esmExports && exports !== __global)
      entry.esModule = loader.newModule(getESModule(exports));
    // just use the 'default' export
    else
      entry.esModule = loader.newModule({ 'default': exports, __useDefault: true });
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, entry, seen, loader) {
    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!loader.defined[depName])
          loader.get(depName);
        else
          ensureEvaluated(depName, loader.defined[depName], seen, loader);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(__global);
  }

  // override the delete method to also clear the register caches
  hook('delete', function(del) {
    return function(name) {
      delete this._loader.moduleRecords[name];
      delete this.defined[name];
      return del.call(this, name);
    };
  });

  hook('fetch', function(fetch) {
    return function(load) {
      if (this.defined[load.name]) {
        load.metadata.format = 'defined';
        return '';
      }

      load.metadata.deps = load.metadata.deps || [];

      return fetch.call(this, load);
    };
  });

  hook('translate', function(translate) {
    // we run the meta detection here (register is after meta)
    return function(load) {
      load.metadata.deps = load.metadata.deps || [];
      return Promise.resolve(translate.apply(this, arguments)).then(function(source) {
        // run detection for register format
        if (load.metadata.format == 'register' || load.metadata.format == 'system' || !load.metadata.format && detectRegisterFormat(load.source))
          load.metadata.format = 'register';
        return source;
      });
    };
  });

  // implement a perforance shortpath for System.load with no deps
  hook('load', function(doLoad) {
    return function(normalized) {
      var loader = this;
      var entry = loader.defined[normalized];

      if (!entry || entry.deps.length)
        return doLoad.apply(this, arguments);

      entry.originalIndices = entry.normalizedDeps = [];

      // recursively ensure that the module and all its
      // dependencies are linked (with dependency group handling)
      link(normalized, entry, loader);

      // now handle dependency execution in correct order
      ensureEvaluated(normalized, entry, [], loader);
      if (!entry.esModule)
        entry.esModule = loader.newModule(entry.module.exports);

      // remove from the registry
      if (!loader.trace)
        loader.defined[normalized] = undefined;

      // return the defined module object
      loader.set(normalized, entry.esModule);

      return Promise.resolve();
    };
  });

  hook('instantiate', function(instantiate) {
    return function(load) {
      if (load.metadata.format == 'detect')
        load.metadata.format = undefined;

      // assumes previous instantiate is sync
      // (core json support)
      instantiate.call(this, load);

      var loader = this;

      var entry;

      // first we check if this module has already been defined in the registry
      if (loader.defined[load.name]) {
        entry = loader.defined[load.name];
        // don't support deps for ES modules
        if (!entry.declarative)
          entry.deps = entry.deps.concat(load.metadata.deps);
        entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // picked up already by an anonymous System.register script injection
      // or via the dynamic formats
      else if (load.metadata.entry) {
        entry = load.metadata.entry;
        entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // Contains System.register calls
      // (dont run bundles in the builder)
      else if (!(loader.builder && load.metadata.bundle)
          && (load.metadata.format == 'register' || load.metadata.format == 'esm' || load.metadata.format == 'es6')) {

        if (typeof __exec != 'undefined')
          __exec.call(loader, load);

        if (!load.metadata.entry && !load.metadata.bundle)
          throw new Error(load.name + ' detected as ' + load.metadata.format + ' but didn\'t execute.');

        entry = load.metadata.entry;

        // support metadata deps for System.register
        if (entry && load.metadata.deps)
          entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // named bundles are just an empty module
      if (!entry) {
        entry = createEntry();
        entry.deps = load.metadata.deps;
        entry.execute = function() {};
      }

      // place this module onto defined for circular references
      loader.defined[load.name] = entry;

      var grouped = group(entry.deps);

      entry.deps = grouped.names;
      entry.originalIndices = grouped.indices;
      entry.name = load.name;
      entry.esmExports = load.metadata.esmExports !== false;

      // first, normalize all dependencies
      var normalizePromises = [];
      for (var i = 0, l = entry.deps.length; i < l; i++)
        normalizePromises.push(Promise.resolve(loader.normalize(entry.deps[i], load.name)));

      return Promise.all(normalizePromises).then(function(normalizedDeps) {

        entry.normalizedDeps = normalizedDeps;

        return {
          deps: entry.deps,
          execute: function() {
            // recursively ensure that the module and all its
            // dependencies are linked (with dependency group handling)
            link(load.name, entry, loader);

            // now handle dependency execution in correct order
            ensureEvaluated(load.name, entry, [], loader);

            if (!entry.esModule)
              entry.esModule = loader.newModule(entry.module.exports);

            // remove from the registry
            if (!loader.trace)
              loader.defined[load.name] = undefined;

            // return the defined module object
            return entry.esModule;
          }
        };
      });
    };
  });
})();
/*
 * Extension to detect ES6 and auto-load Traceur or Babel for processing
 */
(function() {
  // good enough ES6 module detection regex - format detections not designed to be accurate, but to handle the 99% use case
  var esmRegEx = /(^\s*|[}\);\n]\s*)(import\s*(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s*from\s*['"]|\{)|export\s+\*\s+from\s+["']|export\s*(\{|default|function|class|var|const|let|async\s+function))/;

  var traceurRuntimeRegEx = /\$traceurRuntime\s*\./;
  var babelHelpersRegEx = /babelHelpers\s*\./;

  hook('translate', function(translate) {
    return function(load) {
      var loader = this;
      var args = arguments;
      return translate.apply(loader, args)
      .then(function(source) {
        // detect & transpile ES6
        if (load.metadata.format == 'esm' || load.metadata.format == 'es6' || !load.metadata.format && source.match(esmRegEx)) {
          if (load.metadata.format == 'es6')
            warn.call(loader, 'Module ' + load.name + ' has metadata setting its format to "es6", which is deprecated.\nThis should be updated to "esm".');

          load.metadata.format = 'esm';

          if (load.metadata.deps) {
            var depInject = '';
            for (var i = 0; i < load.metadata.deps.length; i++)
              depInject += 'import "' + load.metadata.deps[i] + '"; ';
            load.source = depInject + source;
          }

          if (loader.transpiler === false) {
            // we accept translation to esm for builds though to enable eg rollup optimizations
            if (loader.builder)
              return source;
            throw new TypeError('Unable to dynamically transpile ES module as SystemJS.transpiler set to false.');
          }

          // setting _loader.loadedTranspiler = false tells the next block to
          // do checks for setting transpiler metadata
          loader._loader.loadedTranspiler = loader._loader.loadedTranspiler || false;
          if (loader.pluginLoader)
            loader.pluginLoader._loader.loadedTranspiler = loader._loader.loadedTranspiler || false;

          // do transpilation
          return (loader._loader.transpilerPromise || (
            loader._loader.transpilerPromise = Promise.resolve(
              __global[loader.transpiler == 'typescript' ? 'ts' : loader.transpiler] || (loader.pluginLoader || loader).normalize(loader.transpiler)
              .then(function(normalized) {
                loader._loader.transpilerNormalized = normalized;
                return (loader.pluginLoader || loader).load(normalized)
                .then(function() {
                  return (loader.pluginLoader || loader).get(normalized);
                });
              })
          ))).then(function(transpiler) {
            loader._loader.loadedTranspilerRuntime = true;

            if (typeof transpiler.default === 'function' && !__global[loader.transpiler == 'typescript' ? 'ts' : loader.transpiler]) {
              // instantiate plugins dont build
              if (loader.builder)
                return source;
              return Promise.resolve(transpiler.default.call(loader, load.address, load.name))
              .then(function (result) {
                createInstantiate(load, result);
                return '';
              });
            }

            // translate hooks means this is a transpiler plugin instead of a raw implementation
            if (transpiler.translate) {
              // if transpiler is the same as the plugin loader, then don't run twice
              if (transpiler == load.metadata.loaderModule)
                return load.source;

              // convert the source map into an object for transpilation chaining
              if (typeof load.metadata.sourceMap == 'string')
                load.metadata.sourceMap = JSON.parse(load.metadata.sourceMap);

              return Promise.resolve(transpiler.translate.apply(loader, args))
              .then(function(source) {
                // sanitize sourceMap if an object not a JSON string
                var sourceMap = load.metadata.sourceMap;
                if (sourceMap && typeof sourceMap == 'object') {
                  var originalName = load.address.split('!')[0];

                  // force set the filename of the original file
                  if (!sourceMap.file || sourceMap.file == load.address)
                    sourceMap.file = originalName + '!transpiled';

                  // force set the sources list if only one source
                  if (!sourceMap.sources || sourceMap.sources.length <= 1 && (!sourceMap.sources[0] || sourceMap.sources[0] == load.address))
                    sourceMap.sources = [originalName];
                }

                if (load.metadata.format == 'esm' && !loader.builder && detectRegisterFormat(source))
                  load.metadata.format = 'register';
                return source;
              });
            }

            // legacy builder support
            if (loader.builder)
              load.metadata.originalSource = load.source;

            // defined in es6-module-loader/src/transpile.js
            return transpile.call(loader, load)
            .then(function(source) {
              // clear sourceMap as transpiler embeds it
              load.metadata.sourceMap = undefined;
              return source;
            });
          }, function(err) {
            throw addToError(err, 'Unable to load transpiler to transpile ' + load.name);
          });
        }

        // skip transpiler and transpiler runtime loading when transpiler is disabled
        if (loader.transpiler === false)
          return source;

        // load the transpiler correctly
        if (loader._loader.loadedTranspiler === false && (loader.transpiler == 'traceur' || loader.transpiler == 'typescript' || loader.transpiler == 'babel')
            && load.name == loader.normalizeSync(loader.transpiler)) {

          // always load transpiler as a global
          if (source.length > 100 && !load.metadata.format) {
            load.metadata.format = 'global';

            if (loader.transpiler === 'traceur')
              load.metadata.exports = 'traceur';
            if (loader.transpiler === 'typescript')
              load.metadata.exports = 'ts';
          }

          loader._loader.loadedTranspiler = true;
        }

        // load the transpiler runtime correctly
        if (loader._loader.loadedTranspilerRuntime === false) {
          if (load.name == loader.normalizeSync('traceur-runtime')
              || load.name == loader.normalizeSync('babel/external-helpers*')) {
            if (source.length > 100)
              load.metadata.format = load.metadata.format || 'global';

            loader._loader.loadedTranspilerRuntime = true;
          }
        }

        // detect transpiler runtime usage to load runtimes
        if ((load.metadata.format == 'register' || load.metadata.bundle) && loader._loader.loadedTranspilerRuntime !== true) {
          if (loader.transpiler == 'traceur' && !__global.$traceurRuntime && load.source.match(traceurRuntimeRegEx)) {
            loader._loader.loadedTranspilerRuntime = loader._loader.loadedTranspilerRuntime || false;
            return loader['import']('traceur-runtime').then(function() {
              return source;
            });
          }
          if (loader.transpiler == 'babel' && !__global.babelHelpers && load.source.match(babelHelpersRegEx)) {
            loader._loader.loadedTranspilerRuntime = loader._loader.loadedTranspilerRuntime || false;
            return loader['import']('babel/external-helpers').then(function() {
              return source;
            });
          }
        }

        return source;
      });
    };
  });

})();
/*
  SystemJS Global Format

  Supports
    metadata.deps
    metadata.globals
    metadata.exports

  Without metadata.exports, detects writes to the global object.
*/
var __globalName = typeof self != 'undefined' ? 'self' : 'global';

hook('fetch', function(fetch) {
  return function(load) {
    if (load.metadata.exports && !load.metadata.format)
      load.metadata.format = 'global';
    return fetch.call(this, load);
  };
});

// ideally we could support script loading for globals, but the issue with that is that
// we can't do it with AMD support side-by-side since AMD support means defining the
// global define, and global support means not definining it, yet we don't have any hook
// into the "pre-execution" phase of a script tag being loaded to handle both cases
hook('instantiate', function(instantiate) {
  return function(load) {
    var loader = this;

    if (!load.metadata.format)
      load.metadata.format = 'global';

    // global is a fallback module format
    if (load.metadata.format == 'global' && !load.metadata.entry) {

      var entry = createEntry();

      load.metadata.entry = entry;

      entry.deps = [];

      for (var g in load.metadata.globals) {
        var gl = load.metadata.globals[g];
        if (gl)
          entry.deps.push(gl);
      }

      entry.execute = function(require, exports, module) {

        var globals;
        if (load.metadata.globals) {
          globals = {};
          for (var g in load.metadata.globals)
            if (load.metadata.globals[g])
              globals[g] = require(load.metadata.globals[g]);
        }
        
        var exportName = load.metadata.exports;

        if (exportName)
          load.source += '\n' + __globalName + '["' + exportName + '"] = ' + exportName + ';';

        var retrieveGlobal = loader.get('@@global-helpers').prepareGlobal(module.id, exportName, globals, !!load.metadata.encapsulateGlobal);
        __exec.call(loader, load);

        return retrieveGlobal();
      }
    }
    return instantiate.call(this, load);
  };
});


function getGlobalValue(exports) {
  if (typeof exports == 'string')
    return readMemberExpression(exports, __global);

  if (!(exports instanceof Array))
    throw new Error('Global exports must be a string or array.');

  var globalValue = {};
  var first = true;
  for (var i = 0; i < exports.length; i++) {
    var val = readMemberExpression(exports[i], __global);
    if (first) {
      globalValue['default'] = val;
      first = false;
    }
    globalValue[exports[i].split('.').pop()] = val;
  }
  return globalValue;
}

hook('reduceRegister_', function(reduceRegister) {
  return function(load, register) {
    if (register || (!load.metadata.exports && !(isWorker && load.metadata.format == 'global')))
      return reduceRegister.call(this, load, register);

    load.metadata.format = 'global';
    var entry = load.metadata.entry = createEntry();
    entry.deps = load.metadata.deps;
    var globalValue = getGlobalValue(load.metadata.exports);
    entry.execute = function() {
      return globalValue;
    };
  };
});

hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(loader);

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    // bare minimum ignores
    var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'frameElement', 'external', 
      'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB', 'mozInnerScreenY', 'mozInnerScreenX'];

    var globalSnapshot;

    function forEachGlobal(callback) {
      if (Object.keys)
        Object.keys(__global).forEach(callback);
      else
        for (var g in __global) {
          if (!hasOwnProperty.call(__global, g))
            continue;
          callback(g);
        }
    }

    function forEachGlobalValue(callback) {
      forEachGlobal(function(globalName) {
        if (indexOf.call(ignoredGlobalProps, globalName) != -1)
          return;
        try {
          var value = __global[globalName];
        }
        catch (e) {
          ignoredGlobalProps.push(globalName);
        }
        callback(globalName, value);
      });
    }

    loader.set('@@global-helpers', loader.newModule({
      prepareGlobal: function(moduleName, exports, globals, encapsulate) {
        // disable module detection
        var curDefine = __global.define;
        
        __global.define = undefined;

        // set globals
        var oldGlobals;
        if (globals) {
          oldGlobals = {};
          for (var g in globals) {
            oldGlobals[g] = __global[g];
            __global[g] = globals[g];
          }
        }

        // store a complete copy of the global object in order to detect changes
        if (!exports) {
          globalSnapshot = {};

          forEachGlobalValue(function(name, value) {
            globalSnapshot[name] = value;
          });
        }

        // return function to retrieve global
        return function() {
          var globalValue = exports ? getGlobalValue(exports) : {};

          var singleGlobal;
          var multipleExports = !!exports;

          if (!exports || encapsulate)
            forEachGlobalValue(function(name, value) {
              if (globalSnapshot[name] === value)
                return;
              if (typeof value == 'undefined')
                return;
              
              // allow global encapsulation where globals are removed
              if (encapsulate)
                __global[name] = undefined;

              if (!exports) {
                globalValue[name] = value;

                if (typeof singleGlobal != 'undefined') {
                  if (!multipleExports && singleGlobal !== value)
                    multipleExports = true;
                }
                else {
                  singleGlobal = value;
                }
              }
            });

          globalValue = multipleExports ? globalValue : singleGlobal;

          // revert globals
          if (oldGlobals) {
            for (var g in oldGlobals)
              __global[g] = oldGlobals[g];
          }
          __global.define = curDefine;

          return globalValue;
        };
      }
    }));
  };
});
/*
  SystemJS CommonJS Format
*/
(function() {
  // CJS Module Format
  // require('...') || exports[''] = ... || exports.asd = ... || module.exports = ...
  var cjsExportsRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])(exports\s*(\[['"]|\.)|module(\.exports|\['exports'\]|\["exports"\])\s*(\[['"]|[=,\.]))/;
  // RegEx adjusted from https://github.com/jbrantly/yabble/blob/master/lib/yabble.js#L339
  var cjsRequireRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g;
  var commentRegEx = /(^|[^\\])(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;

  var stringRegEx = /("[^"\\\n\r]*(\\.[^"\\\n\r]*)*"|'[^'\\\n\r]*(\\.[^'\\\n\r]*)*')/g;

  // used to support leading #!/usr/bin/env in scripts as supported in Node
  var hashBangRegEx = /^\#\!.*/;

  function getCJSDeps(source) {
    cjsRequireRegEx.lastIndex = commentRegEx.lastIndex = stringRegEx.lastIndex = 0;

    var deps = [];

    var match;

    // track string and comment locations for unminified source    
    var stringLocations = [], commentLocations = [];

    function inLocation(locations, match) {
      for (var i = 0; i < locations.length; i++)
        if (locations[i][0] < match.index && locations[i][1] > match.index)
          return true;
      return false;
    }

    if (source.length / source.split('\n').length < 200) {
      while (match = stringRegEx.exec(source))
        stringLocations.push([match.index, match.index + match[0].length]);

      // TODO: track template literals here before comments
      
      while (match = commentRegEx.exec(source)) {
        // only track comments not starting in strings
        if (!inLocation(stringLocations, match))
          commentLocations.push([match.index + match[1].length, match.index + match[0].length - 1]);
      }
    }

    while (match = cjsRequireRegEx.exec(source)) {
      // ensure we're not within a string or comment location
      if (!inLocation(stringLocations, match) && !inLocation(commentLocations, match)) {
        var dep = match[1].substr(1, match[1].length - 2);
        // skip cases like require('" + file + "')
        if (dep.match(/"|'/))
          continue;
        // trailing slash requires are removed as they don't map mains in SystemJS
        if (dep[dep.length - 1] == '/')
          dep = dep.substr(0, dep.length - 1);
        deps.push(dep);
      }
    }

    return deps;
  }

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      if (!load.metadata.format) {
        cjsExportsRegEx.lastIndex = 0;
        cjsRequireRegEx.lastIndex = 0;
        if (cjsRequireRegEx.exec(load.source) || cjsExportsRegEx.exec(load.source))
          load.metadata.format = 'cjs';
      }

      if (load.metadata.format == 'cjs') {
        var metaDeps = load.metadata.deps;
        var deps = load.metadata.cjsRequireDetection === false ? [] : getCJSDeps(load.source);

        for (var g in load.metadata.globals)
          if (load.metadata.globals[g])
            deps.push(load.metadata.globals[g]);

        var entry = createEntry();

        load.metadata.entry = entry;

        entry.deps = deps;
        entry.executingRequire = true;
        entry.execute = function(_require, exports, module) {
          function require(name) {
            if (name[name.length - 1] == '/')
              name = name.substr(0, name.length - 1);
            return _require.apply(this, arguments);
          }
          require.resolve = function(name) {
            return loader.get('@@cjs-helpers').requireResolve(name, module.id);
          };
          // support module.paths ish
          module.paths = [];
          module.require = _require;

          // ensure meta deps execute first
          if (!load.metadata.cjsDeferDepsExecute)
            for (var i = 0; i < metaDeps.length; i++)
              require(metaDeps[i]);

          var pathVars = loader.get('@@cjs-helpers').getPathVars(module.id);
          var __cjsWrapper = {
            exports: exports,
            args: [require, exports, module, pathVars.filename, pathVars.dirname, __global, __global]
          };

          var cjsWrapper = "(function(require, exports, module, __filename, __dirname, global, GLOBAL";

          // add metadata.globals to the wrapper arguments
          if (load.metadata.globals)
            for (var g in load.metadata.globals) {
              __cjsWrapper.args.push(require(load.metadata.globals[g]));
              cjsWrapper += ", " + g;
            }

          // disable AMD detection
          var define = __global.define;
          __global.define = undefined;
          __global.__cjsWrapper = __cjsWrapper;

          load.source = cjsWrapper + ") {" + load.source.replace(hashBangRegEx, '') + "\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);";

          __exec.call(loader, load);

          __global.__cjsWrapper = undefined;
          __global.define = define;
        };
      }

      return instantiate.call(loader, load);
    };
  });
})();
hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(loader);

    if (typeof window != 'undefined' && typeof document != 'undefined' && window.location)
      var windowOrigin = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');

    function stripOrigin(path) {
      if (path.substr(0, 8) == 'file:///')
        return path.substr(7 + !!isWindows);
      
      if (windowOrigin && path.substr(0, windowOrigin.length) == windowOrigin)
        return path.substr(windowOrigin.length);

      return path;
    }

    loader.set('@@cjs-helpers', loader.newModule({
      requireResolve: function(request, parentId) {
        return stripOrigin(loader.normalizeSync(request, parentId));
      },
      getPathVars: function(moduleId) {
        // remove any plugin syntax
        var pluginIndex = moduleId.lastIndexOf('!');
        var filename;
        if (pluginIndex != -1)
          filename = moduleId.substr(0, pluginIndex);
        else
          filename = moduleId;

        var dirname = filename.split('/');
        dirname.pop();
        dirname = dirname.join('/');

        return {
          filename: stripOrigin(filename),
          dirname: stripOrigin(dirname)
        };
      }
    }))
  };
});/*
 * AMD Helper function module
 * Separated into its own file as this is the part needed for full AMD support in SFX builds
 * NB since implementations have now diverged this can be merged back with amd.js
 */

hook('fetch', function(fetch) {
  return function(load) {
    // script load implies define global leak
    if (load.metadata.scriptLoad && isBrowser)
      __global.define = this.amdDefine;
    return fetch.call(this, load);
  };
});
 
hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(this);

    var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
    var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
    var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";
    var fnBracketRegEx = /\(([^\)]*)\)/;
    var wsRegEx = /^\s+|\s+$/g;
    
    var requireRegExs = {};

    function getCJSDeps(source, requireIndex) {

      // remove comments
      source = source.replace(commentRegEx, '');

      // determine the require alias
      var params = source.match(fnBracketRegEx);
      var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

      // find or generate the regex for this requireAlias
      var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

      requireRegEx.lastIndex = 0;

      var deps = [];

      var match;
      while (match = requireRegEx.exec(source))
        deps.push(match[2] || match[3]);

      return deps;
    }

    /*
      AMD-compatible require
      To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
    */
    function require(names, callback, errback, referer) {
      // in amd, first arg can be a config object... we just ignore
      if (typeof names == 'object' && !(names instanceof Array))
        return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

      // amd require
      if (typeof names == 'string' && typeof callback == 'function')
        names = [names];
      if (names instanceof Array) {
        var dynamicRequires = [];
        for (var i = 0; i < names.length; i++)
          dynamicRequires.push(loader['import'](names[i], referer));
        Promise.all(dynamicRequires).then(function(modules) {
          if (callback)
            callback.apply(null, modules);
        }, errback);
      }

      // commonjs require
      else if (typeof names == 'string') {
        var defaultJSExtension = loader.defaultJSExtensions && names.substr(names.length - 3, 3) != '.js';
        var normalized = loader.decanonicalize(names, referer);
        if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) == '.js')
          normalized = normalized.substr(0, normalized.length - 3);
        var module = loader.get(normalized);
        if (!module)
          throw new Error('Module not already loaded loading "' + names + '" as ' + normalized + (referer ? ' from "' + referer + '".' : '.'));
        return module.__useDefault ? module['default'] : module;
      }

      else
        throw new TypeError('Invalid require');
    }

    function define(name, deps, factory) {
      if (typeof name != 'string') {
        factory = deps;
        deps = name;
        name = null;
      }
      if (!(deps instanceof Array)) {
        factory = deps;
        deps = ['require', 'exports', 'module'].splice(0, factory.length);
      }

      if (typeof factory != 'function')
        factory = (function(factory) {
          return function() { return factory; }
        })(factory);

      // in IE8, a trailing comma becomes a trailing undefined entry
      if (deps[deps.length - 1] === undefined)
        deps.pop();

      // remove system dependencies
      var requireIndex, exportsIndex, moduleIndex;
      
      if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
        
        deps.splice(requireIndex, 1);

        // only trace cjs requires for non-named
        // named defines assume the trace has already been done
        if (!name)
          deps = deps.concat(getCJSDeps(factory.toString(), requireIndex));
      }

      if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
        deps.splice(exportsIndex, 1);
      
      if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
        deps.splice(moduleIndex, 1);

      function execute(req, exports, module) {
        var depValues = [];
        for (var i = 0; i < deps.length; i++)
          depValues.push(req(deps[i]));

        module.uri = module.id;

        module.config = function() {};

        // add back in system dependencies
        if (moduleIndex != -1)
          depValues.splice(moduleIndex, 0, module);
        
        if (exportsIndex != -1)
          depValues.splice(exportsIndex, 0, exports);
        
        if (requireIndex != -1) {
          function contextualRequire(names, callback, errback) {
            if (typeof names == 'string' && typeof callback != 'function')
              return req(names);
            return require.call(loader, names, callback, errback, module.id);
          }
          contextualRequire.toUrl = function(name) {
            // normalize without defaultJSExtensions
            var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';
            var url = loader.decanonicalize(name, module.id);
            if (defaultJSExtension && url.substr(url.length - 3, 3) == '.js')
              url = url.substr(0, url.length - 3);
            return url;
          };
          depValues.splice(requireIndex, 0, contextualRequire);
        }

        // set global require to AMD require
        var curRequire = __global.require;
        __global.require = require;

        var output = factory.apply(exportsIndex == -1 ? __global : exports, depValues);

        __global.require = curRequire;

        if (typeof output == 'undefined' && module)
          output = module.exports;

        if (typeof output != 'undefined')
          return output;
      }

      var entry = createEntry();
      entry.name = name && (loader.decanonicalize || loader.normalize).call(loader, name);
      entry.deps = deps;
      entry.execute = execute;

      loader.pushRegister_({
        amd: true,
        entry: entry
      });
    }
    define.amd = {};

    // reduction function to attach defines to a load record
    hook('reduceRegister_', function(reduceRegister) {
      return function(load, register) {
        // only handle AMD registers here
        if (!register || !register.amd)
          return reduceRegister.call(this, load, register);

        var curMeta = load && load.metadata;
        var entry = register.entry;

        if (curMeta) {
          if (!curMeta.format || curMeta.format == 'detect')
            curMeta.format = 'amd';
          else if (!entry.name && curMeta.format != 'amd')
            throw new Error('AMD define called while executing ' + curMeta.format + ' module ' + load.name);
        }

        // anonymous define
        if (!entry.name) {
          if (!curMeta)
            throw new TypeError('Unexpected anonymous AMD define.');

          if (curMeta.entry && !curMeta.entry.name)
            throw new Error('Multiple anonymous defines in module ' + load.name);
          
          curMeta.entry = entry;
        }
        // named define
        else {
          // if we don't have any other defines, 
          // then let this be an anonymous define
          // this is just to support single modules of the form:
          // define('jquery')
          // still loading anonymously
          // because it is done widely enough to be useful
          // as soon as there is more than one define, this gets removed though
          if (curMeta) {
            if (!curMeta.entry && !curMeta.bundle)
              curMeta.entry = entry;
            else if (curMeta.entry && curMeta.entry.name && curMeta.entry.name != load.name)
              curMeta.entry = undefined;

            // note this is now a bundle
            curMeta.bundle = true;
          }

          // define the module through the register registry
          if (!(entry.name in this.defined))
            this.defined[entry.name] = entry;
        }
      };
    });

    loader.amdDefine = define;
    loader.amdRequire = require;
  };
});/*
  SystemJS AMD Format
*/
(function() {
  // AMD Module Format Detection RegEx
  // define([.., .., ..], ...)
  // define(varName); || define(function(require, exports) {}); || define({})
  var amdRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/;

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      
      if (load.metadata.format == 'amd' || !load.metadata.format && load.source.match(amdRegEx)) {
        load.metadata.format = 'amd';
        
        if (!loader.builder && loader.execute !== false) {
          var curDefine = __global.define;
          __global.define = this.amdDefine;

          try {
            __exec.call(loader, load);
          }
          finally {
            __global.define = curDefine;
          }

          if (!load.metadata.entry && !load.metadata.bundle)
            throw new TypeError('AMD module ' + load.name + ' did not define');
        }
        else {
          load.metadata.execute = function() {
            return load.metadata.builderExecute.apply(this, arguments);
          };
        }
      }

      return instantiate.call(loader, load);
    };
  });

})();
/*
  SystemJS Loader Plugin Support

  Supports plugin loader syntax with "!", or via metadata.loader

  The plugin name is loaded as a module itself, and can override standard loader hooks
  for the plugin resource. See the plugin section of the systemjs readme.
*/

(function() {
  function getParentName(loader, parentName) {
    // if parent is a plugin, normalize against the parent plugin argument only
    if (parentName) {
      var parentPluginIndex;
      if (loader.pluginFirst) {
        if ((parentPluginIndex = parentName.lastIndexOf('!')) != -1)
          return parentName.substr(parentPluginIndex + 1);
      }
      else {
        if ((parentPluginIndex = parentName.indexOf('!')) != -1)
          return parentName.substr(0, parentPluginIndex);
      }

      return parentName;
    }
  }

  function parsePlugin(loader, name) {
    var argumentName;
    var pluginName;

    var pluginIndex = name.lastIndexOf('!');

    if (pluginIndex == -1)
      return;

    if (loader.pluginFirst) {
      argumentName = name.substr(pluginIndex + 1);
      pluginName = name.substr(0, pluginIndex);
    }
    else {
      argumentName = name.substr(0, pluginIndex);
      pluginName = name.substr(pluginIndex + 1) || argumentName.substr(argumentName.lastIndexOf('.') + 1);
    }

    return {
      argument: argumentName,
      plugin: pluginName
    };
  }

  // put name back together after parts have been normalized
  function combinePluginParts(loader, argumentName, pluginName, defaultExtension) {
    if (defaultExtension && argumentName.substr(argumentName.length - 3, 3) == '.js')
      argumentName = argumentName.substr(0, argumentName.length - 3);

    if (loader.pluginFirst) {
      return pluginName + '!' + argumentName;
    }
    else {
      return argumentName + '!' + pluginName;
    }
  }

  // note if normalize will add a default js extension
  // if so, remove for backwards compat
  // this is strange and sucks, but will be deprecated
  function checkDefaultExtension(loader, arg) {
    return loader.defaultJSExtensions && arg.substr(arg.length - 3, 3) != '.js';
  }

  function createNormalizeSync(normalizeSync) {
    return function(name, parentName, isPlugin) {
      var loader = this;

      var parsed = parsePlugin(loader, name);
      parentName = getParentName(this, parentName);

      if (!parsed)
        return normalizeSync.call(this, name, parentName, isPlugin);

      // if this is a plugin, normalize the plugin name and the argument
      var argumentName = loader.normalizeSync(parsed.argument, parentName, true);
      var pluginName = loader.normalizeSync(parsed.plugin, parentName, true);
      return combinePluginParts(loader, argumentName, pluginName, checkDefaultExtension(loader, parsed.argument));
    };
  }

  hook('decanonicalize', createNormalizeSync);
  hook('normalizeSync', createNormalizeSync);

  hook('normalize', function(normalize) {
    return function(name, parentName, isPlugin) {
      var loader = this;

      parentName = getParentName(this, parentName);

      var parsed = parsePlugin(loader, name);

      if (!parsed)
        return normalize.call(loader, name, parentName, isPlugin);

      return Promise.all([
        loader.normalize(parsed.argument, parentName, true),
        loader.normalize(parsed.plugin, parentName, false)
      ])
      .then(function(normalized) {
        return combinePluginParts(loader, normalized[0], normalized[1], checkDefaultExtension(loader, parsed.argument));
      });
    }
  });

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;

      var name = load.name;

      // plugin syntax
      var pluginSyntaxIndex;
      if (loader.pluginFirst) {
        if ((pluginSyntaxIndex = name.indexOf('!')) != -1) {
          load.metadata.loader = name.substr(0, pluginSyntaxIndex);
          load.name = name.substr(pluginSyntaxIndex + 1);
        }
      }
      else {
        if ((pluginSyntaxIndex = name.lastIndexOf('!')) != -1) {
          load.metadata.loader = name.substr(pluginSyntaxIndex + 1);
          load.name = name.substr(0, pluginSyntaxIndex);
        }
      }

      return locate.call(loader, load)
      .then(function(address) {
        if (pluginSyntaxIndex != -1 || !load.metadata.loader)
          return address;

        // normalize plugin relative to parent in locate here when
        // using plugin via loader metadata
        return (loader.pluginLoader || loader).normalize(load.metadata.loader, load.name)
        .then(function(loaderNormalized) {
          load.metadata.loader = loaderNormalized;
          return address;
        });
      })
      .then(function(address) {
        var plugin = load.metadata.loader;

        if (!plugin)
          return address;

        // don't allow a plugin to load itself
        if (load.name == plugin)
          throw new Error('Plugin ' + plugin + ' cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.');

        // only fetch the plugin itself if this name isn't defined
        if (loader.defined && loader.defined[name])
          return address;

        var pluginLoader = loader.pluginLoader || loader;

        // load the plugin module and run standard locate
        return pluginLoader['import'](plugin)
        .then(function(loaderModule) {
          // store the plugin module itself on the metadata
          load.metadata.loaderModule = loaderModule;

          load.address = address;
          if (loaderModule.locate)
            return loaderModule.locate.call(loader, load);

          return address;
        });
      });
    };
  });

  hook('fetch', function(fetch) {
    return function(load) {
      var loader = this;
      if (load.metadata.loaderModule && load.metadata.format != 'defined') {
        if (typeof load.metadata.loaderModule === 'function' || load.metadata.loaderModule instanceof Module && typeof load.metadata.loaderModule.default === 'function')
          return '';
        load.metadata.scriptLoad = false;
        if (load.metadata.loaderModule.fetch)
          return load.metadata.loaderModule.fetch.call(loader, load, function(load) {
            return fetch.call(loader, load);
          });
      }
      return fetch.call(loader, load);
    };
  });

  hook('translate', function(translate) {
    return function(load) {
      var loader = this;
      var args = arguments;
      if (load.metadata.loaderModule && load.metadata.loaderModule.translate && load.metadata.format != 'defined') {
        return Promise.resolve(load.metadata.loaderModule.translate.apply(loader, args)).then(function(result) {
          var sourceMap = load.metadata.sourceMap;

          // sanitize sourceMap if an object not a JSON string
          if (sourceMap) {
            if (typeof sourceMap != 'object')
              throw new Error('load.metadata.sourceMap must be set to an object.');

            var originalName = load.address.split('!')[0];

            // force set the filename of the original file
            if (!sourceMap.file || sourceMap.file == load.address)
              sourceMap.file = originalName + '!transpiled';

            // force set the sources list if only one source
            if (!sourceMap.sources || sourceMap.sources.length <= 1 && (!sourceMap.sources[0] || sourceMap.sources[0] == load.address))
              sourceMap.sources = [originalName];
          }

          // if running on file:/// URLs, sourcesContent is necessary
          // load.metadata.sourceMap.sourcesContent = [load.source];

          if (typeof result == 'string')
            load.source = result;

          return translate.apply(loader, args);
        });
      }
      return translate.apply(loader, args);
    };
  });

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      var calledInstantiate = false;

      if (load.metadata.loaderModule && !loader.builder && load.metadata.format != 'defined') {
        if (load.metadata.loaderModule.instantiate)
          return Promise.resolve(load.metadata.loaderModule.instantiate.call(loader, load, function(load) {
            if (calledInstantiate)
              throw new Error('Instantiate must only be called once.');
            calledInstantiate = true;
            return instantiate.call(loader, load);
          })).then(function(result) {
            if (calledInstantiate)
              return result;

            if (result !== undefined)
              createInstantiate(load, result);
            return instantiate.call(loader, load);
          });
        else if (typeof load.metadata.loaderModule === 'function' || load.metadata.loaderModule instanceof Module && typeof load.metadata.loaderModule.default === 'function')
          return Promise.resolve((load.metadata.loaderModule.default || load.metadata.loaderModule).call(loader, load.address, load.name))
          .then(function (result) {
            if (result !== undefined)
              createInstantiate(load, result);
            return instantiate.call(loader, load);
          });
      }
      return instantiate.call(loader, load);
    };
  });

})();
/*
 * Conditions Extension
 *
 *   Allows a condition module to alter the resolution of an import via syntax:
 *
 *     import $ from 'jquery/#{browser}';
 *
 *   Will first load the module 'browser' via `SystemJS.import('browser')` and 
 *   take the default export of that module.
 *   If the default export is not a string, an error is thrown.
 * 
 *   We then substitute the string into the require to get the conditional resolution
 *   enabling environment-specific variations like:
 * 
 *     import $ from 'jquery/ie'
 *     import $ from 'jquery/firefox'
 *     import $ from 'jquery/chrome'
 *     import $ from 'jquery/safari'
 *
 *   It can be useful for a condition module to define multiple conditions.
 *   This can be done via the `|` modifier to specify an export member expression:
 *
 *     import 'jquery/#{./browser.js|grade.version}'
 *
 *   Where the `grade` export `version` member in the `browser.js` module  is substituted.
 *
 *
 * Boolean Conditionals
 *
 *   For polyfill modules, that are used as imports but have no module value,
 *   a binary conditional allows a module not to be loaded at all if not needed:
 *
 *     import 'es5-shim#?./conditions.js|needs-es5shim'
 *
 *   These conditions can also be negated via:
 *     
 *     import 'es5-shim#?./conditions.js|~es6'
 *
 */

  var sysConditions = ['browser', 'node', 'dev', 'build', 'production', 'default'];

  function parseCondition(condition) {
    var conditionExport, conditionModule, negation;

    var negation = condition[0] == '~';
    var conditionExportIndex = condition.lastIndexOf('|');
    if (conditionExportIndex != -1) {
      conditionExport = condition.substr(conditionExportIndex + 1);
      conditionModule = condition.substr(negation, conditionExportIndex - negation);
      
      if (negation)
        warn.call(this, 'Condition negation form "' + condition + '" is deprecated for "' + conditionModule + '|~' + conditionExport + '"');

      if (conditionExport[0] == '~') {
        negation = true;
        conditionExport = conditionExport.substr(1);
      }
    }
    else {
      conditionExport = 'default';
      conditionModule = condition.substr(negation);
      if (sysConditions.indexOf(conditionModule) != -1) {
        conditionExport = conditionModule;
        conditionModule = null;
      }
    }

    return {
      module: conditionModule || '@system-env',
      prop: conditionExport,
      negate: negation
    };
  }

  function serializeCondition(conditionObj) {
    return conditionObj.module + '|' + (conditionObj.negate ? '~' : '') + conditionObj.prop;
  }

  function resolveCondition(conditionObj, parentName, bool) {
    var self = this;
    return this.normalize(conditionObj.module, parentName)
    .then(function(normalizedCondition) {
      return self.load(normalizedCondition)
      .then(function(q) {
        var m = readMemberExpression(conditionObj.prop, self.get(normalizedCondition));

        if (bool && typeof m != 'boolean')
          throw new TypeError('Condition ' + serializeCondition(conditionObj) + ' did not resolve to a boolean.');

        return conditionObj.negate ? !m : m;
      });
    });
  }

  var interpolationRegEx = /#\{[^\}]+\}/;
  function interpolateConditional(name, parentName) {
    // first we normalize the conditional
    var conditionalMatch = name.match(interpolationRegEx);

    if (!conditionalMatch)
      return Promise.resolve(name);

    var conditionObj = parseCondition.call(this, conditionalMatch[0].substr(2, conditionalMatch[0].length - 3));

    // in builds, return normalized conditional
    if (this.builder)
      return this['normalize'](conditionObj.module, parentName)
      .then(function(conditionModule) {
        conditionObj.module = conditionModule;
        return name.replace(interpolationRegEx, '#{' + serializeCondition(conditionObj) + '}');
      });

    return resolveCondition.call(this, conditionObj, parentName, false)
    .then(function(conditionValue) {
      if (typeof conditionValue !== 'string')
        throw new TypeError('The condition value for ' + name + ' doesn\'t resolve to a string.');

      if (conditionValue.indexOf('/') != -1)
        throw new TypeError('Unabled to interpolate conditional ' + name + (parentName ? ' in ' + parentName : '') + '\n\tThe condition value ' + conditionValue + ' cannot contain a "/" separator.');

      return name.replace(interpolationRegEx, conditionValue);
    });
  }

  function booleanConditional(name, parentName) {
    // first we normalize the conditional
    var booleanIndex = name.lastIndexOf('#?');

    if (booleanIndex == -1)
      return Promise.resolve(name);

    var conditionObj = parseCondition.call(this, name.substr(booleanIndex + 2));

    // in builds, return normalized conditional
    if (this.builder)
      return this['normalize'](conditionObj.module, parentName)
      .then(function(conditionModule) {
        conditionObj.module = conditionModule;
        return name.substr(0, booleanIndex) + '#?' + serializeCondition(conditionObj);
      });

    return resolveCondition.call(this, conditionObj, parentName, true)
    .then(function(conditionValue) {
      return conditionValue ? name.substr(0, booleanIndex) : '@empty';
    });
  }

  // normalizeSync does not parse conditionals at all although it could
  hook('normalize', function(normalize) {
    return function(name, parentName, skipExt) {
      var loader = this;
      return booleanConditional.call(loader, name, parentName)
      .then(function(name) {
        return normalize.call(loader, name, parentName, skipExt);
      })
      .then(function(normalized) {
        return interpolateConditional.call(loader, normalized, parentName);
      });
    };
  });
/*
 * Alias Extension
 *
 * Allows a module to be a plain copy of another module by module name
 *
 * SystemJS.meta['mybootstrapalias'] = { alias: 'bootstrap' };
 *
 */
(function() {
  // aliases
  hook('fetch', function(fetch) {
    return function(load) {
      var alias = load.metadata.alias;
      var aliasDeps = load.metadata.deps || [];
      if (alias) {
        load.metadata.format = 'defined';
        var entry = createEntry();
        this.defined[load.name] = entry;
        entry.declarative = true;
        entry.deps = aliasDeps.concat([alias]);
        entry.declare = function(_export) {
          return {
            setters: [function(module) {
              for (var p in module)
                _export(p, module[p]);
              if (module.__useDefault)
                entry.module.exports.__useDefault = true;
            }],
            execute: function() {}
          };
        };
        return '';
      }

      return fetch.call(this, load);
    };
  });
})();/*
 * Meta Extension
 *
 * Sets default metadata on a load record (load.metadata) from
 * loader.metadata via SystemJS.meta function.
 *
 *
 * Also provides an inline meta syntax for module meta in source.
 *
 * Eg:
 *
 * loader.meta({
 *   'my/module': { deps: ['jquery'] }
 *   'my/*': { format: 'amd' }
 * });
 *
 * Which in turn populates loader.metadata.
 *
 * load.metadata.deps and load.metadata.format will then be set
 * for 'my/module'
 *
 * The same meta could be set with a my/module.js file containing:
 *
 * my/module.js
 *   "format amd";
 *   "deps[] jquery";
 *   "globals.some value"
 *   console.log('this is my/module');
 *
 * Configuration meta always takes preference to inline meta.
 *
 * Multiple matches in wildcards are supported and ammend the meta.
 *
 *
 * The benefits of the function form is that paths are URL-normalized
 * supporting say
 *
 * loader.meta({ './app': { format: 'cjs' } });
 *
 * Instead of needing to set against the absolute URL (https://site.com/app.js)
 *
 */

(function() {

  hookConstructor(function(constructor) {
    return function() {
      this.meta = {};
      constructor.call(this);
    };
  });

  hook('locate', function(locate) {
    return function(load) {
      var meta = this.meta;
      var name = load.name;

      // NB for perf, maybe introduce a fast-path wildcard lookup cache here
      // which is checked first

      // apply wildcard metas
      var bestDepth = 0;
      var wildcardIndex;
      for (var module in meta) {
        wildcardIndex = module.indexOf('*');
        if (wildcardIndex === -1)
          continue;
        if (module.substr(0, wildcardIndex) === name.substr(0, wildcardIndex)
            && module.substr(wildcardIndex + 1) === name.substr(name.length - module.length + wildcardIndex + 1)) {
          var depth = module.split('/').length;
          if (depth > bestDepth)
            bestDepth = depth;
          extendMeta(load.metadata, meta[module], bestDepth != depth);
        }
      }

      // apply exact meta
      if (meta[name])
        extendMeta(load.metadata, meta[name]);

      return locate.call(this, load);
    };
  });

  // detect any meta header syntax
  // only set if not already set
  var metaRegEx = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/;
  var metaPartRegEx = /\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;

  function setMetaProperty(target, p, value) {
    var pParts = p.split('.');
    var curPart;
    while (pParts.length > 1) {
      curPart = pParts.shift();
      target = target[curPart] = target[curPart] || {};
    }
    curPart = pParts.shift();
    if (!(curPart in target))
      target[curPart] = value;
  }

  hook('translate', function(translate) {
    return function(load) {
      // shortpath for bundled
      if (load.metadata.format == 'defined') {
        load.metadata.deps = load.metadata.deps || [];
        return Promise.resolve(load.source);
      }

      // NB meta will be post-translate pending transpiler conversion to plugins
      var meta = load.source.match(metaRegEx);
      if (meta) {
        var metaParts = meta[0].match(metaPartRegEx);

        for (var i = 0; i < metaParts.length; i++) {
          var curPart = metaParts[i];
          var len = curPart.length;

          var firstChar = curPart.substr(0, 1);
          if (curPart.substr(len - 1, 1) == ';')
            len--;

          if (firstChar != '"' && firstChar != "'")
            continue;

          var metaString = curPart.substr(1, curPart.length - 3);
          var metaName = metaString.substr(0, metaString.indexOf(' '));

          if (metaName) {
            var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);

            if (metaName.substr(metaName.length - 2, 2) == '[]') {
              metaName = metaName.substr(0, metaName.length - 2);
              load.metadata[metaName] = load.metadata[metaName] || [];
              load.metadata[metaName].push(metaValue);
            }
            else if (load.metadata[metaName] instanceof Array) {
              // temporary backwards compat for previous "deps" syntax
              warn.call(this, 'Module ' + load.name + ' contains deprecated "deps ' + metaValue + '" meta syntax.\nThis should be updated to "deps[] ' + metaValue + '" for pushing to array meta.');
              load.metadata[metaName].push(metaValue);
            }
            else {
              setMetaProperty(load.metadata, metaName, metaValue);
            }
          }
          else {
            load.metadata[metaString] = true;
          }
        }
      }

      return translate.apply(this, arguments);
    };
  });
})();
/*
  System bundles

  Allows a bundle module to be specified which will be dynamically 
  loaded before trying to load a given module.

  For example:
  SystemJS.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']

  Will result in a load to "mybundle" whenever a load to "jquery"
  or "bootstrap/js/bootstrap" is made.

  In this way, the bundle becomes the request that provides the module
*/

(function() {
  // bundles support (just like RequireJS)
  // bundle name is module name of bundle itself
  // bundle is array of modules defined by the bundle
  // when a module in the bundle is requested, the bundle is loaded instead
  // of the form SystemJS.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']
  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.bundles = {};
      this._loader.loadedBundles = {};
    };
  });

  // assign bundle metadata for bundle loads
  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      var matched = false;

      if (!(load.name in loader.defined))
        for (var b in loader.bundles) {
          for (var i = 0; i < loader.bundles[b].length; i++) {
            var curModule = loader.bundles[b][i];

            if (curModule == load.name) {
              matched = true;
              break;
            }

            // wildcard in bundles does not include / boundaries
            if (curModule.indexOf('*') != -1) {
              var parts = curModule.split('*');
              if (parts.length != 2) {
                loader.bundles[b].splice(i--, 1);
                continue;
              }
              
              if (load.name.substring(0, parts[0].length) == parts[0] &&
                  load.name.substr(load.name.length - parts[1].length, parts[1].length) == parts[1] &&
                  load.name.substr(parts[0].length, load.name.length - parts[1].length - parts[0].length).indexOf('/') == -1) {
                matched = true;
                break;
              }
            }
          }

          if (matched)
            return loader['import'](b)
            .then(function() {
              return locate.call(loader, load);
            });
        }

      return locate.call(loader, load);
    };
  });
})();
/*
 * Dependency Tree Cache
 * 
 * Allows a build to pre-populate a dependency trace tree on the loader of 
 * the expected dependency tree, to be loaded upfront when requesting the
 * module, avoinding the n round trips latency of module loading, where 
 * n is the dependency tree depth.
 *
 * eg:
 * SystemJS.depCache = {
 *  'app': ['normalized', 'deps'],
 *  'normalized': ['another'],
 *  'deps': ['tree']
 * };
 * 
 * SystemJS.import('app') 
 * // simultaneously starts loading all of:
 * // 'normalized', 'deps', 'another', 'tree'
 * // before "app" source is even loaded
 *
 */

(function() {
  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.depCache = {};
    }
  });

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      // load direct deps, in turn will pick up their trace trees
      var deps = loader.depCache[load.name];
      if (deps)
        for (var i = 0; i < deps.length; i++)
          loader['import'](deps[i], load.name);

      return locate.call(loader, load);
    };
  });
})();
  
System = new SystemJSLoader();

__global.SystemJS = System;
System.version = '0.19.47 Standard';
  if (typeof module == 'object' && module.exports && typeof exports == 'object')
    module.exports = System;

  __global.System = System;

})(typeof self != 'undefined' ? self : global);}

// auto-load Promise polyfill if needed in the browser
var doPolyfill = typeof Promise === 'undefined';

// document.write
if (typeof document !== 'undefined') {
  var scripts = document.getElementsByTagName('script');
  $__curScript = scripts[scripts.length - 1];
  if (document.currentScript && ($__curScript.defer || $__curScript.async))
    $__curScript = document.currentScript;
  if (!$__curScript.src)
    $__curScript = undefined;
  if (doPolyfill) {
    var curPath = $__curScript.src;
    var basePath = curPath.substr(0, curPath.lastIndexOf('/') + 1);
    window.systemJSBootstrap = bootstrap;
    document.write(
      '<' + 'script type="text/javascript" src="' + basePath + 'system-polyfills.js">' + '<' + '/script>'
    );
  }
  else {
    bootstrap();
  }
}
// importScripts
else if (typeof importScripts !== 'undefined') {
  var basePath = '';
  try {
    throw new Error('_');
  } catch (e) {
    e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/, function(m, url) {
      $__curScript = { src: url };
      basePath = url.replace(/\/[^\/]*$/, '/');
    });
  }
  if (doPolyfill)
    importScripts(basePath + 'system-polyfills.js');
  bootstrap();
}
else {
  $__curScript = typeof __filename != 'undefined' ? { src: __filename } : null;
  bootstrap();
}


})();

!function(e){"use strict";function t(e,t,r,i){var o=Object.create((t||n).prototype),a=new p(i||[]);return o._invoke=c(e,r,a),o}function r(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}function n(){}function i(){}function o(){}function a(e){["next","throw","return"].forEach(function(t){e[t]=function(e){return this._invoke(t,e)}})}function s(e){this.arg=e}function u(e){function t(t,r){var o=e[t](r),a=o.value;return a instanceof s?Promise.resolve(a.arg).then(n,i):Promise.resolve(a).then(function(e){return o.value=e,o})}"object"==typeof process&&process.domain&&(t=process.domain.bind(t));var r,n=t.bind(e,"next"),i=t.bind(e,"throw");t.bind(e,"return");this._invoke=function(e,n){function i(){return t(e,n)}return r=r?r.then(i,i):new Promise(function(e){e(i())})}}function c(e,t,n){var i=_;return function(o,a){if(i===w)throw new Error("Generator is already running");if(i===k){if("throw"===o)throw a;return h()}for(;;){var s=n.delegate;if(s){if("return"===o||"throw"===o&&s.iterator[o]===m){n.delegate=null;var u=s.iterator.return;if(u&&"throw"===(c=r(u,s.iterator,a)).type){o="throw",a=c.arg;continue}if("return"===o)continue}if("throw"===(c=r(s.iterator[o],s.iterator,a)).type){n.delegate=null,o="throw",a=c.arg;continue}if(o="next",a=m,!(l=c.arg).done)return i=x,l;n[s.resultName]=l.value,n.next=s.nextLoc,n.delegate=null}if("next"===o)n._sent=a,n.sent=i===x?a:m;else if("throw"===o){if(i===_)throw i=k,a;n.dispatchException(a)&&(o="next",a=m)}else"return"===o&&n.abrupt("return",a);i=w;var c=r(e,t,n);if("normal"===c.type){i=n.done?k:x;var l={value:c.arg,done:n.done};if(c.arg!==E)return l;n.delegate&&"next"===o&&(a=m)}else"throw"===c.type&&(i=k,o="throw",a=c.arg)}}}function l(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function f(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function p(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(l,this),this.reset(!0)}function d(e){if(e){var t=e[y];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,n=function t(){for(;++r<e.length;)if(v.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=m,t.done=!0,t};return n.next=n}}return{next:h}}function h(){return{value:m,done:!0}}var m,v=Object.prototype.hasOwnProperty,y="function"==typeof Symbol&&Symbol.iterator||"@@iterator",g="object"==typeof module,b=e.regeneratorRuntime;if(b)g&&(module.exports=b);else{(b=e.regeneratorRuntime=g?module.exports:{}).wrap=t;var _="suspendedStart",x="suspendedYield",w="executing",k="completed",E={},S=o.prototype=n.prototype;i.prototype=S.constructor=o,o.constructor=i,i.displayName="GeneratorFunction",b.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===i||"GeneratorFunction"===(t.displayName||t.name))},b.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,o):e.__proto__=o,e.prototype=Object.create(S),e},b.awrap=function(e){return new s(e)},a(u.prototype),b.async=function(e,r,n,i){var o=new u(t(e,r,n,i));return b.isGeneratorFunction(r)?o:o.next().then(function(e){return e.done?e.value:o.next()})},a(S),S[y]=function(){return this},S.toString=function(){return"[object Generator]"},b.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},b.values=d,p.prototype={constructor:p,reset:function(e){if(this.prev=0,this.next=0,this.sent=m,this.done=!1,this.delegate=null,this.tryEntries.forEach(f),!e)for(var t in this)"t"===t.charAt(0)&&v.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=m)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){function t(t,n){return o.type="throw",o.arg=e,r.next=t,!!n}if(this.done)throw e;for(var r=this,n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var a=v.call(i,"catchLoc"),s=v.call(i,"finallyLoc");if(a&&s){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(a){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&v.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=t&&t<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=e,o.arg=t,i?this.next=i.finallyLoc:this.complete(o),E},complete:function(e,t){if("throw"===e.type)throw e.arg;"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=e.arg,this.next="end"):"normal"===e.type&&t&&(this.next=t)},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),f(r),E}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var i=n.arg;f(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,r){return this.delegate={iterator:d(e),resultName:t,nextLoc:r},E}}}}("object"==typeof global?global:"object"==typeof window?window:"object"==typeof self?self:this),function(){var GLOBAL="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;void 0===GLOBAL.lively&&(GLOBAL.lively={}),function(){this.lively=this.lively||{},function(exports){"use strict";function Empty(){return function(){}}function K(){return function(e){return e}}function Null(){return function(){return null}}function False(){return function(){return!1}}function True(){return function(){return!0}}function notYetImplemented(){return function(){throw new Error("Not yet implemented")}}function all(e){var t=[];for(var r in e)e.__lookupGetter__(r)||"function"!=typeof e[r]||t.push(r);return t}function own(e){var t=[];for(var r in e)!e.__lookupGetter__(r)&&e.hasOwnProperty(r)&&"function"==typeof e[r]&&t.push(r);return t}function argumentNames(e){if(e.superclass)return[];var t=e.toString(),r="",n=t.match(/(?:\(([^\)]*)\)|([^\(\)-+!]+))\s*=>/);if(n)r=n[1]||n[2]||"";else{var i=t.match(/^[\s\(]*function[^(]*\(([^)]*)\)/);i&&i[1]&&(r=i[1])}return r.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g,"").replace(/\s+/g,"").split(",").map(function(e){return e.trim()}).filter(function(e){return!!e})}function qualifiedMethodName(e){var t="";return e.declaredClass?t+=e.declaredClass+">>":e.declaredObject&&(t+=e.declaredObject+"."),t+(e.methodName||e.displayName||e.name||"anonymous")}function extractBody(e){for(var t=String(e).replace(/^function[^\{]+\{\s*/,"").replace(/\}$/,"").trim(),r=t.split(/\n|\r/),n=void 0,i=0;i<r.length;i++){var o=r[i].match(/^(\s+)[^\s]/);o&&(void 0===n||o[1].length<n.length)&&(n=o[1])}return n?t.replace(new RegExp("^"+n,"gm"),""):t}function timeToRun(e){var t=Date.now();return e(),Date.now()-t}function timeToRunN$1(e,t){for(var r=Date.now(),n=0;n<t;n++)e();return(Date.now()-r)/t}function delay(e,t){var r=Array.prototype.slice.call(arguments),n=r.shift(),t=1e3*r.shift();return setTimeout(function(){return n.apply(n,r)},t)}function throttle(e,t){var r,n,i,o,a,s,u=debounce(t,function(){a=o=!1});return function(){r=this,n=arguments;return i||(i=setTimeout(function(){i=null,a&&e.apply(r,n),u()},t)),o?a=!0:s=e.apply(r,n),u(),o=!0,s}}function debounce(e,t,r){var n;return function(){var i=this,o=arguments;r&&!n&&t.apply(i,o),clearTimeout(n),n=setTimeout(function(){n=null,r||t.apply(i,o)},e)}}function throttleNamed(e,t,r){var n=_throttledByName;return n[e]?n[e]:n[e]=throttle(function(){debounceNamed(e,t,function(){delete n[e]})(),r.apply(this,arguments)},t)}function debounceNamed(e,t,r,n){var i=_debouncedByName;return i[e]?i[e]:i[e]=debounce(t,function(){delete i[e],r.apply(this,arguments)},n)}function createQueue(e,t){var r=_queues,n=r[e]||(r[e]={_workerActive:!1,worker:t,tasks:[],drain:null,push:function(e){n.tasks.push(e),n.activateWorker()},pushAll:function(e){e.forEach(function(e){n.tasks.push(e)}),n.activateWorker()},pushNoActivate:function(e){n.tasks.push(e)},handleError:function(e){e&&console.error("Error in queue: "+e)},activateWorker:function(){function t(e){n.handleError(e),n.activateWorker()}var i=n.tasks,o=n._workerActive;if(0===i.length)o&&(n._workerActive=!1,"function"==typeof n.drain&&n.drain()),delete r[e];else{o||(n._workerActive=!0);try{n.worker(i.shift(),t)}catch(e){t(e)}}}});return n}function workerWithCallbackQueue(e,t,r){function n(){c&&clearTimeout(c),s=!0,delete o[e]}function i(t){s||(n(),a.callbacks.forEach(function(r){try{r.apply(null,t)}catch(t){console.error("Error when invoking callbacks in queueUntil ["+e+"]:\n"+String(t.stack||t))}}))}var o=_queueUntilCallbacks,a=o[e];if(!!a)return a;var s=!1,u=!1;if(r)var c=setTimeout(function(){s||i([new Error("timeout")])},r);return a=o[e]={callbacks:[],cancel:function(){u=!0,n()},whenDone:function(e){return a.callbacks.push(e),a}},setTimeout(function(){if(!u)try{t(function(){i(arguments)})}catch(e){i([e])}},0),a}function _composeAsyncDefaultEndCallback(e,t){e&&console.error("lively.lang.composeAsync error",e)}function composeAsync(){var e,t,r=Array.prototype.slice,n=r.call(arguments),i=_composeAsyncDefaultEndCallback,o=i,a=new Promise(function(r,n){e=r,t=n});return n.reverse().reduce(function(e,s,u){var c=!1;return function(){function l(){c=!0;var n=r.call(arguments),i=n.shift();i?(o(i),t(i)):e.apply(null,n)}var f=r.call(arguments);if(o===i&&u===n.length-1){for(;f.length&&"function"!=typeof f[f.length-1];)f.pop();"function"==typeof f[f.length-1]&&(o=f.pop())}if("function"==typeof s)try{var p=s.apply(this,f.concat([l]));p&&"function"==typeof p.then&&"function"==typeof p.catch&&p.then(function(e){return l(null,e)}).catch(function(e){return l(e)})}catch(e){console.error("composeAsync: ",e.stack||e),c||(o(e),t(e))}else if(s&&"function"==typeof s.then&&"function"==typeof s.catch)s.then(function(e){l(null,e)}).catch(function(e){l(e)});else{var d=new Error("Invalid argument to composeAsync: "+s);o(d),t(d)}return a}},function(){var t=r.call(arguments);o.apply(null,[null].concat(t)),e(t[0])})}function compose(){return Array.prototype.slice.call(arguments).reverse().reduce(function(e,t){return function(){return e(t.apply(this,arguments))}},function(e){return e})}function flip(e){return function(){var t=Array.prototype.slice.call(arguments),r=[t[1],t[0]].concat(t.slice(2));return e.apply(null,r)}}function withNull(e){return e=e||function(){},function(){var t=lively.lang.arr.from(arguments);e.apply(null,[null].concat(t))}}function waitFor(e,t,r){var n=Date.now(),i=50;r||(r=t,t=e,e=void 0),function o(){if(t())return r();if(e){var a=Date.now()-n,s=e-a;if(s<=0)return r(new Error("timeout"));s<i&&(i=s)}setTimeout(o,i)}()}function waitForAll(e,t,r){function n(e,t,n,a){if(o.length){var s=null,u=o.indexOf(e);u>-1&&o.splice(u,1),n?(o.length=0,s=new Error("in waitForAll at"+("number"==typeof t?" "+t:"")+": \n"+(n.stack||String(n)))):a&&(i[t]=a),o.length||setTimeout(function(){r(s,i)},0)}}r||(r=t,t=e,e=null),e=e||{};var i=t.map(function(){return null});if(t.length){var o=Array.prototype.slice.call(t);t.forEach(function(e,t){try{e(function(){var r=Array.prototype.slice.call(arguments),i=r.shift();n(e,t,i,r)})}catch(r){n(e,t,r,null)}}),e.timeout&&setTimeout(function(){if(o.length){var e=i.map(function(e,t){return null===e&&t}).filter(function(e){return"number"==typeof e}).join(", ");n(null,null,new Error("waitForAll timed out, functions at "+e+" not done"),null)}},e.timeout)}else r(null,i)}function curry(e,t,r,n){function i(){return e.apply(this,o.concat(Array.prototype.slice.call(arguments)))}if(arguments.length<=1)return arguments[0];var o=Array.prototype.slice.call(arguments),e=o.shift();return i.isWrapper=!0,i.originalFunction=e,i}function wrap(e,t){var r=e,n=function(){var e=Array.prototype.slice.call(arguments),n=t.isWrapper?e:[r.bind(this)].concat(e);return t.apply(this,n)};return n.isWrapper=!0,n.originalFunction=r,n}function getOriginal(e){for(;e.originalFunction;)e=e.originalFunction;return e}function wrapperChain(e){var t=[];do{t.push(e),e=e.originalFunction}while(e);return t}function replaceMethodForOneCall(e,t,r){r.originalFunction=e[t];var n=e.hasOwnProperty(t);return e[t]=function(){return n?e[t]=r.originalFunction:delete e[t],r.apply(this,arguments)},e}function once(e){if(e){if("function"!=typeof e)throw new Error("once() expecting a function");var t,r=!1;return function(){return r?t:(r=!0,t=e.apply(this,arguments))}}}function either(){var e=!1;return Array.prototype.slice.call(arguments).map(function(t){return function(){if(!e)return e=!0,t.apply(this,arguments)}})}function eitherNamed(e,t){var r=Array.prototype.slice.call(arguments),n=_eitherNameRegistry,e=r.shift(),i=n[e]||(n[e]={wasCalled:!1,callsLeft:0});return i.callsLeft++,function(){if(i.callsLeft--,i.callsLeft<=0&&delete n[e],!i.wasCalled)return i.wasCalled=!0,t.apply(this,arguments)}}function evalJS(src){return eval(src)}function fromString(e){return evalJS("("+e.toString()+");")}function asScript(e,t){return Closure.fromFunction(e,t).recreateFunc()}function asScriptOf(e,t,r,n){var i=r||e.name;if(!i)throw Error("Function that wants to be a script needs a name: "+this);var o=Object.getPrototypeOf(t),a={this:t};if(n&&(a=merge([a,n])),o&&o[i]){var s=function(){try{return Object.getPrototypeOf(t)[i].apply(t,arguments)}catch(e){return void 0!==("undefined"==typeof $world?"undefined":_typeof($world))?$world.logError(e,"Error in $super call"):console.error("Error in $super call: "+e+"\n"+e.stack),null}};a.$super=Closure.fromFunction(s,{obj:t,name:i}).recreateFunc()}return addToObject(asScript(e,a),t,i)}function addToObject(e,t,r){e.displayName=r;var n=t.attributeConnections?t.attributeConnections.filter(function(e){return"update"===e.getSourceAttrName()}):[];return n&&n.forEach(function(e){e.disconnect()}),t[r]=e,(void 0===t?"undefined":_typeof(t))&&(e.declaredObject=safeToString(t)),"undefined"!=typeof lively&&t&&lively.Tracing&&lively.Tracing.stackTracingEnabled&&lively.Tracing.instrumentMethod(t,r,{declaredObject:safeToString(t)}),n&&n.forEach(function(e){e.connect()}),e}function binds(e,t){return Closure.fromFunction(e,t||{}).recreateFunc()}function setLocalVarValue(e,t,r){e.hasLivelyClosure&&(e.livelyClosure.funcProperties[t]=r)}function getVarMapping(e){return e.hasLivelyClosure?e.livelyClosure.varMapping:e.isWrapper?e.originalFunction.varMapping:e.varMapping?e.varMapping:{}}function setProperty(e,t,r){e[t]=r,e.hasLivelyClosure&&(e.livelyClosure.funcProperties[t]=r)}function functionNames(e){for(var t=[],r=e.prototype;r;)t=Object.keys(r).reduce(function(e,t){return"function"==typeof r[t]&&-1===e.indexOf(t)&&e.push(t),e},t),r=Object.getPrototypeOf(r);return t}function localFunctionNames(e){return Object.keys(e.prototype).filter(function(t){return"function"==typeof e.prototype[t]})}function logErrors(e,t){var r=function(r){var n=Array.prototype.slice.call(arguments);n.shift();try{return r.apply(e,n)}catch(r){if("undefined"!=typeof lively&&lively.morphic&&lively.morphic.World&&lively.morphic.World.current())throw lively.morphic.World.current().logError(r),r;throw t?console.warn("ERROR: %s.%s(%s): err: %s %s",e,t,n,r,r.stack||""):console.warn("ERROR: %s %s",r,r.stack||""),r}};r.methodName="$logErrorsAdvice";var n=wrap(e,r);return n.originalFunction=e,n.methodName="$logErrorsWrapper",n}function logCompletion(e,t){var r=function(r){var n=Array.prototype.slice.call(arguments);n.shift();try{var i=r.apply(e,n)}catch(e){throw console.warn("failed to load "+t+": "+e),"undefined"!=typeof lively&&lively.lang.Execution&&lively.lang.Execution.showStack(),e}return console.log("completed "+t),i};r.methodName="$logCompletionAdvice::"+t;var n=wrap(e,r);return n.methodName="$logCompletionWrapper::"+t,n.originalFunction=e,n}function logCalls(e,t){var r=e,n=function(n){var o=Array.prototype.slice.call(arguments);return o.shift(),i=n.apply(e,o),t?console.warn("%s(%s) -> %s",qualifiedMethodName(r),o,i):console.log("%s(%s) -> %s",qualifiedMethodName(r),o,i),i};n.methodName="$logCallsAdvice::"+qualifiedMethodName(e);var i=wrap(e,n);return i.originalFunction=e,i.methodName="$logCallsWrapper::"+qualifiedMethodName(e),i}function traceCalls(e,t){return wrap(e,function(r){var n=Array.prototype.slice.call(arguments);n.shift(),t.push(n);var i=r.apply(e,n);return t.pop(),i})}function webkitStack(){try{throw new Error}catch(e){return String(e.stack).split(/\n/).slice(2).map(function(e){return e.replace(/^\s*at\s*([^\s]+).*/,"$1")}).join("\n")}}function range(e,t,r){r=r||0;var n=[];if(e<=t){r<=0&&(r=-r||1);for(i=e;i<=t;i+=r)n.push(i)}else{r>=0&&(r=-r||-1);for(var i=e;i>=t;i+=r)n.push(i)}return n}function withN(e,t){for(var r=new Array(e);e>0;)r[--e]=t;return r}function genN(e,t){for(var r=new Array(e);e>0;)r[--e]=t(e);return r}function filter(e,t,r){return e.filter(t,r)}function findAndGet(e,t){var r;return e.find(function(e,n){return r=t(e,n)}),r}function filterByKey(e,t){return e.filter(function(e){return!!e[t]})}function grep(e,t,r){return"string"==typeof t&&(t=new RegExp(t,"i")),e.filter(t.test.bind(t))}function mask(e,t){return e.filter(function(e,r){return!!t[r]})}function reject(e,t,r){return e.filter(function(e,n){return!t.call(r,e,n)})}function rejectByKey(e,t){return e.filter(function(e){return!e[t]})}function without(e,t){return e.filter(function(e){return e!==t})}function withoutAll(e,t){return e.filter(function(e){return-1===t.indexOf(e)})}function uniq(e,t){if(!e.length)return e;var r=[e[0]];if(t)for(var n=1;n<e.length;n++){var i=e[n];i!==r[r.length]&&r.push(i)}else for(var o=1;o<e.length;o++){var a=e[o];-1===r.indexOf(a)&&r.push(a)}return r}function uniqBy(e,t,r){for(var n=e.slice(),i=n.length;i--;)for(var o=e[i],a=i+1;a<n.length;a++)t.call(r,o,n[a])&&n.splice(a--,1);return n}function uniqByKey(e,t){for(var r={},n=[],i=0;i<e.length;i++){var o=e[i];r[o[t]]||(r[o[t]]=!0,n.push(o))}return n}function compact(e){return e.filter(Boolean)}function mutableCompact(e){for(var t=0,r=0,n=e.length;t<n;)e.hasOwnProperty(t)&&(e[r++]=e[t]),t++;for(;r++<n;)e.pop();return e}function forEach$1(e,t,r){return e.forEach(t,r)}function zip(){var e=Array.from(arguments),t=e.shift(),r="function"==typeof last(e)?e.pop():function(e){return e},n=[t].concat(e).map(function(e){return Array.from(e)});return t.map(function(e,t){return r(pluck(n,t),t)})}function flatten(e,t){if("number"==typeof t){if(t<=0)return e;t--}return e.reduce(function(e,r){return e.concat(Array.isArray(r)?flatten(r,t):[r])},[])}function flatmap(e,t,r){for(var n=[],i=0;i<e.length;i++)n.push.apply(n,t.call(r,e[i],i));return n}function interpose(e,t){return e.reduce(function(e,r){return e.length>0&&e.push(t),e.push(r),e},[])}function delimWith(e,t){return interpose(e,t)}function map$1(e,t,r){return e.map(t,r)}function invoke(e,t,r,n,i,o,a,s){return e.map(function(e){return e[t](r,n,i,o,a,s)})}function pluck(e,t){return e.map(function(e){return e[t]})}function reduce(e,t,r,n){return e.reduce(t,r,n)}function reduceRight(e,t,r,n){return e.reduceRight(t,r,n)}function some(e,t,r){return e.some(t,r)}function every(e,t,r){return e.every(t,r)}function equals$2(e,t){var r=e.length;if(!t||r!==t.length)return!1;for(var n=0;n<r;n++){if(e[n]&&t[n]&&e[n].equals&&t[n].equals){if(e[n].equals(t[n]))continue;return!1}if(e[n]!=t[n])return!1}return!0}function deepEquals(e,t){var r=e.length;if(!t||r!==t.length)return!1;for(var n=0;n<r;n++)if(!equals$1(e[n],t[n]))return!1;return!0}function isSorted(e,t){if(t){for(r=1;r<e.length;r++)if(e[r-1]<e[r])return!1}else for(var r=1;r<e.length;r++)if(e[r-1]>e[r])return!1;return!0}function sort(e,t){return e.sort(t)}function sortBy(e,t,r){return pluck(e.map(function(e,n){return{value:e,criteria:t.call(r,e,n)}}).sort(function(e,t){var r=e.criteria,n=t.criteria;return r<n?-1:r>n?1:0}),"value")}function sortByKey(e,t){return sortBy(e,function(e){return e[t]})}function reverse(e){return e.reverse()}function reversed(e){return e.slice().reverse()}function reMatches$1(e,t,r){return r=r||String,e.map(function(e){return r(e).match(t)})}function first(e){return e[0]}function last(e){return e[e.length-1]}function intersect(e,t){return uniq(e).filter(function(e){return t.indexOf(e)>-1})}function union(e,t){for(var r=e.slice(),n=0;n<t.length;n++){var i=t[n];-1===r.indexOf(i)&&r.push(i)}return r}function pushAt(e,t,r){e.splice(r,0,t)}function removeAt(e,t){e.splice(t,1)}function remove(e,t){var r=e.indexOf(t);return r>=0&&removeAt(e,r),t}function pushAll$1(e,t){return e.push.apply(e,t),e}function pushAllAt(e,t,r){e.splice.apply(e,[r,0].concat(t))}function pushIfNotIncluded(e,t){e.includes(t)||e.push(t)}function replaceAt(e,t,r){e.splice(r,1,t)}function clear(e){return e.length=0,e}function isSubset(e,t){for(var r=0;r<e.length;r++)if(!t.includes(e[r]))return!1;return!0}function doAndContinue(e,t,r,n){return r=r||Null,n=n||GLOBAL$1,t=t||function(e,t,r){t.call(n,e,r)},e.reduceRight(function(e,r,i){return function(){t.call(n,e,r,i)}},r)()}function nestedDelay(e,t,r,n,i,o){return n=n||function(){},e.clone().reverse().reduce(function(e,n,a){return function(){t.call(i||GLOBAL$1,n,a),o&&a%o!=0?e():e.delay(r)}},n)()}function forEachShowingProgress(){var e,t,r,n,i,o=Array.from(arguments),a=o.shift(),s=a.length,u=!1;if(1===o.length?(e=o[0].progressBar,t=o[0].iterator,r=o[0].labelFunction,n=o[0].whenDone,i=o[0].context):(e=o[0],t=o[1],r=o[2],n=o[3],i=o[4]),i||(i="undefined"!=typeof window?window:global),r||(r=function(e){return e}),!e){u=!0;var c=("undefined"!=typeof window?window:global).lively&&lively.morphic&&lively.morphic.World.current();e=c?c.addProgressBar():{setValue:function(e){},setLabel:function(){},remove:function(){}}}return e.setValue(0),a.reduceRight(function(n,o,a){return function(){try{e.setValue(a/s),r&&e.setLabel(r.call(i,o,a)),t.call(i,o,a)}catch(e){console.error("Error in forEachShowingProgress at %s (%s)\n%s\n%s",a,o,e,e.stack)}n.delay(0)}},function(){e.setValue(1),u&&function(){e.remove()}.delay(0),n&&n.call(i)})(),a}function swap(e,t,r){t<0&&(t=e.length+t),r<0&&(r=e.length+r);var n=e[t];return e[t]=e[r],e[r]=n,e}function rotate(e,t){return t=t||1,e.slice(t).concat(e.slice(0,t))}function groupBy(e,t,r){return Group.fromArray(e,t,r)}function groupByKey(e,t){return groupBy(e,function(e){return e[t]})}function partition(e,t,r){t=t||function(e){return e};var n=[],i=[];return e.forEach(function(e,o){(t.call(r,e,o)?n:i).push(e)}),[n,i]}function batchify(e,t,r){function n(e,i){if(!i.length)return[e,[]];var o=i[0],a=i.slice(1),s=e.concat([o]);if(t.call(r,s))return n(s,a);var u=n(e,a);return[u[0],[o].concat(u[1])]}function i(e,t){if(!t.length)return e;var r=n([],t);if(!r[0].length)throw new Error("Batchify constrained does not ensure consumption of at least one item per batch!");return i(e.concat([r[0]]),r[1])}return i([],e)}function toTuples(e,t){return t=t||1,range(0,Math.ceil(e.length/t)-1).map(function(r){return e.slice(r*t,r*t+t)},e)}function combinationsPick(e,t){for(var r=e.map(function(e,r){return e[t[r]]}),n=t.slice(),i=e.length;i--;i>=0){var o=e[i],a=n[i]+1;if(o[a]){n[i]=a;break}if(0===i){n=void 0;break}n[i]=0}return[r,n]}function combinations(e){for(var t=e.reduce(function(e,t){return e*t.length},1),r=e.map(function(e){return 0}),n=new Array(t),i=0;i<t;i++){var o=combinationsPick(e,r);n[i]=o[0],r=o[1]}return n}function take(e,t){return e.slice(0,t)}function drop(e,t){return e.slice(t)}function takeWhile(e,t,r){for(var n=0;n<e.length&&t.call(r,e[n],n);n++);return e.slice(0,n)}function dropWhile(e,t,r){for(var n=0;n<e.length&&t.call(r,e[n],n);n++);return e.slice(n)}function shuffle(e){for(var t=range(0,e.length-1),r=Array(e.length),n=0;n<e.length;n++)r[t.splice(Math.round(Math.random()*(t.length-1)),1)]=e[n];return r}function max(e,t,r){t=t||function(e){return e};var n;return e.reduce(function(e,i,o){var a=t.call(r,i,o);return"number"!=typeof a||a<=e?e:(n=i,a)},-1/0),n}function min(e,t,r){return t=t||function(e){return e},max(e,function(e,n){return-t.call(r,e,n)})}function sum(e){for(var t=0,r=0;r<e.length;r++)t+=e[r];return t}function count$1(e,t){return e.reduce(function(e,r){return r===t?e+1:e},0)}function size$1(e){return e.length}function histogram(e,t){if(void 0===t||"number"==typeof t){var r=t||Math.ceil(Math.log(e.length)/Math.log(2)+1),n=Math.ceil(Math.round(e.length/r));return range(0,r-1).map(function(t){return e.slice(t*n,(t+1)*n)})}if(t instanceof Array){var i=t;return e.reduce(function(e,t){if(t<i[1])return e[0].push(t),e;for(var r=1;r<i.length;r++)if(t>=i[r]&&(!i[r+1]||t<=i[r+1]))return e[r].push(t),e;throw new Error("Histogram creation: Cannot group data "+t+" into thresholds "+i)},range(1,i.length).map(function(){return[]}))}}function clone$1(e){return[].concat(e)}function toArray$3(e){return from(e)}function each(e,t,r){return e.forEach(t,r)}function all$1(e,t,r){return e.every(t,r)}function any(e,t,r){return e.some(t,r)}function collect(e,t,r){return e.map(t,r)}function findAll(e,t,r){return e.filter(t,r)}function inject(e,t,r,n){return n&&(r=r.bind(n)),e.reduce(r,t)}function mapAsyncSeries(e,t,r){function n(e,t){if(!o&&(e||t)){o=!0;try{r(e,i)}catch(e){console.error("Error in mapAsyncSeries - callback invocation error:\n"+(e.stack||e))}}}var i=[],o=!1;return e.reduceRight(function(e,r,a){if(!o)return function(o,s){if(o)return n(o);a>0&&i.push(s);try{t(r,a,once(e))}catch(e){n(e)}}},function(e,t){i.push(t),n(e,!0)})()}function mapAsync(e,t,r,n){function i(){for(;l<t.parallel&&c<e.length;)f[c++]()}function o(t,r){if(!(s.indexOf(t)>-1||(s.push(t),l--,u)))if(!r&&s.length<e.length)i();else{u=!0;try{n&&n(r,a)}catch(e){console.error("Error in mapAsync - main callback invocation error:\n"+(e.stack||e))}}}if("function"==typeof t&&(n=r,r=t,t=null),t=t||{},!e.length)return n&&n(null,[]);t.parallel||(t.parallel=1/0);var a=[],s=[],u=!1,c=0,l=0,f=e.map(function(e,t){return function(){l++;try{r(e,t,once(function(e,r){a[t]=e||r,o(t,e)}))}catch(e){o(t,e)}}});return i()}function print$1(e){if(e&&Array.isArray(e))return"["+e.map(print$1)+"]";if("string"!=typeof e)return String(e);var t=String(e);return t=t.replace(/\n/g,"\\n\\\n"),t=t.replace(/(")/g,"\\$1"),t='"'+t+'"'}function indent$1(e,t,r){if(!r||r<=0)return e;for(;r>0;)r--,e=t+e;return e}function isArray$$1(e){return Array.isArray(e)}function isElement(e){return e&&1==e.nodeType}function isFunction(e){return e instanceof Function}function isBoolean(e){return"boolean"==typeof e}function isString(e){return"string"==typeof e}function isNumber(e){return"number"==typeof e}function isUndefined(e){return void 0===e}function isRegExp(e){return e instanceof RegExp}function isObject(e){return"object"==(void 0===e?"undefined":_typeof(e))}function isPrimitive(e){if(!e)return!0;switch(void 0===e?"undefined":_typeof(e)){case"string":case"number":case"boolean":return!0}return!1}function isEmpty(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function equals$1(e,t){if(e===t)return!0;if(!e||!t)return e==t;if(Array.isArray(e))return deepEquals(e,t);switch(e.constructor){case String:case Date:case Boolean:case Number:return e==t}if("function"==typeof e.isEqualNode)return e.isEqualNode(t);if("function"==typeof e.equals)return e.equals(t);var r=[];for(var n in e)if(r.push(n),"function"!=typeof e[n]&&!equals$1(e[n],t[n]))return!1;for(var n in t)if(-1===r.indexOf(n)&&"function"!=typeof t[n]&&!equals$1(t[n],e[n]))return!1;return!0}function values(e){return e?Object.keys(e).map(function(t){return e[t]}):[]}function select(e,t){for(var r={},n=0;n<t.length;n++)r[t[n]]=e[t[n]];return r}function dissoc(e,t){for(var r=getOwnPropertyDescriptors(e=e||{}),n=0;n<t.length;n++)t[n]in r&&delete r[t[n]];return Object.defineProperties({},r)}function addScript(e,t,r,n){return asScriptOf(fromString(t),e,r,n)}function extend(e,t){for(var r=null,n=1;n<arguments.length;n++)if("string"!=typeof arguments[n]){var t=arguments[n];for(var i in t){var o=t.__lookupGetter__(i),a=t.__lookupSetter__(i);if(o&&e.__defineGetter__(i,o),a&&e.__defineSetter__(i,a),!o&&!a){var s=t[i];e[i]=s,r&&r.push(i),"function"==typeof s&&(s.displayName||(s.displayName=i),"undefined"!=typeof lively&&lively.Module&&lively.Module.current&&(s.sourceModule=lively.Module.current()))}}}else{var u=arguments[n];e.categories||(e.categories={}),e.categories[u]||(e.categories[u]=[]),r=e.categories[u]}return e}function clone$$1(e){if(isPrimitive(e))return e;if(Array.isArray(e))return Array.prototype.slice.call(e);var t={};for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r]);return t}function extract(e,t,r){for(var n={},i=0;i<t.length;i++)t[i]in e&&(n[t[i]]=r?r(t[i],e[t[i]]):e[t[i]]);return n}function inspect(e,t,r){if(t=t||{},r=r||0,t.customPrinter){var n=t._ignoreSignal||(t._ignoreSignal={}),i=function(e){return inspect(e,t,r+1)},o=t.customPrinter(e,n,i);if(o!==n)return o}if(!e)return print$1(e);if("function"==typeof e)return t.printFunctionSource?String(e):"function"+(e.name?" "+e.name:"")+"("+argumentNames(e).join(",")+") {/*...*/}";switch(e.constructor){case String:case Boolean:case RegExp:case Number:return print$1(e)}if("function"==typeof e.serializeExpr)return e.serializeExpr();var a=e&&Array.isArray(e),s=a?"[":"{",u=a?"]":"}";if(t.maxDepth&&r>=t.maxDepth)return s+"/*...*/"+u;var c=[];if(0===(c=a?e.map(function(e){return inspect(e,t,r+1)}):Object.keys(e).sort(function(t,r){var n="function"==typeof e[t];return n===("function"==typeof e[r])?t<r?-1:t>r?1:0:n?1:-1}).map(function(n,i){a&&inspect(e[n],t,r+1);var o=inspect(e[n],t,r+1);return t.escapeKeys?JSON.stringify(n):n+": "+o})).length)return s+u;var l=c.join(", "),f=(!a||t.newLineInArrays)&&(!t.minLengthForNewLine||l.length>=t.minLengthForNewLine),p=indent$1("",t.indent||"  ",r),d=indent$1("",t.indent||"  ",r+1),h=f&&!a?"\n"+d:"",m=f?"\n"+d:"",v=f&&!a?"\n"+p:"";return f&&(l=c.join(","+m)),s+h+l+v+u}function merge(e){return arguments.length>1?merge(Array.prototype.slice.call(arguments)):Array.isArray(e[0])?Array.prototype.concat.apply([],e):e.reduce(function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e},{})}function deepMerge(e,t){if(!e)return t;if(!t)return e;if(Array.isArray(e)){if(!Array.isArray(t))return t;var r=e.map(function(e,r){return deepMerge(e,t[r])});return t.length>e.length&&(r=r.concat(t.slice(e.length))),r}return"object"!==(void 0===e?"undefined":_typeof(e))||"object"!==(void 0===t?"undefined":_typeof(t))?t:Object.keys(e).concat(Object.keys(t)).reduce(function(r,n){return e[n]?t[n]?"object"!==_typeof(e[n])||"object"!==_typeof(t[n])?r[n]=t[n]:r[n]=deepMerge(e[n],t[n]):r[n]=e[n]:r[n]=t[n],r},{})}function sortKeysWithBeforeAndAfterConstraints(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1];var t=[],r=[],n=[];for(var i in e){var o=e[i],a=o.hasOwnProperty("before")?o.before:o.before=[],s=o.hasOwnProperty("after")?o.after:o.after=[];t.push(i),r.push(o);for(var u=a.length;u--;){var c=a[u],l=e[c];l?(l.hasOwnProperty("after")||(l.after=[]),l.after.push(i)):(console.warn("[initializeProperties] "+this+" sortProperties: Property "+i+" requires to be initialized before "+c+" but that property cannot be found."),a.splice(u,1))}for(var f=s.length;f--;){var p=s[f];e[p]||(console.warn("[initializeProperties] "+this+" sortProperties: Property "+i+" requires to be initialized after "+p+" but that property cannot be found."),s.splice(f,1))}n.push(i)}for(var d=[],h=[],m=n.length+1;n.length;){if(m===n.length)throw new Error("Circular dependencies in handler order, could not resolve properties "+n.map(function(t){var r=e[t].before,n=e[t].after;if(!(r&&r.length||n&&n.length))return"";var i=t+"\n";return r&&r.length&&(i+="  - before "+r.join(",")+"\n"),n&&n.length&&(i+="  - after "+n.join(",")+"\n"),i}).join(""));m=n.length;for(var v=[],y=n.length;y--;){var g=n[y];isSubset(e[g].after,h)&&(n.splice(y,1),h.push(g),v.push(g))}d.push(v)}return flatten(d,1)}function inherit(e){return Object.create(e)}function valuesInPropertyHierarchy(e,t){for(var r=[],n=e;n;)n.hasOwnProperty(t)&&r.unshift(n[t]),n=Object.getPrototypeOf(n);return r}function mergePropertyInHierarchy(e,t){return merge(valuesInPropertyHierarchy(e,t))}function deepCopy(e){if(!e||"object"!==(void 0===e?"undefined":_typeof(e))||e instanceof RegExp)return e;var t=Array.isArray(e)?Array(e.length):{};for(var r in e)e.hasOwnProperty(r)&&(t[r]=deepCopy(e[r]));return t}function typeStringOf(e){return null===e?"null":void 0===e?"undefined":e.constructor.name}function shortPrintStringOf(e){function t(e,t,n,i){e.constructor.name===t&&(r+=n,(e.length||Object.keys(e).length)&&(r+="..."),r+=i)}if(!isMutableType(e))return safeToString(e);if("Object"!==e.constructor.name&&!Array.isArray(e)&&e.constructor.name)return e.constructor.name?e.constructor.name:Object.prototype.toString.call(e).split(" ")[1].split("]")[0];var r="";return t(e,"Object","{","}"),t(e,"Array","[","]"),r}function isMutableType(e){return-1===["null","undefined","Boolean","Number","String"].indexOf(typeStringOf(e))}function safeToString(e){try{return(e?e.toString():String(e)).replace("\n","")}catch(e){return"<error printing object>"}}function asObject(e){switch(void 0===e?"undefined":_typeof(e)){case"string":return new String(e);case"boolean":return new Boolean(e);case"number":return new Number(e);default:return e}}function newKeyIn(e){var t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"_",n=1;do{t=r+"-"+n++}while(t in e);return t}function format(){return formatFromArray(Array.prototype.slice.call(arguments))}function formatFromArray(e){function t(e,t){return""+e}function r(e,t){return e.toString()}function n(e,t){return inspect(e)}var i=e.shift();i||console.log("Error in Strings>>formatFromArray, first arg is undefined");for(var o={s:t,d:r,i:r,f:function(e,t,r){return r>-1?e.toFixed(r):e.toString()},o:n},a=/((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/,s=function(e){for(var t=[],r=a.exec(e);r;r=a.exec(e)){var i=r[8]||r[5],s=i in o?o[i]:n,u=r[3]?parseInt(r[3]):"."==r[4]?-1:0;t.push(e.substr(0,"%"==r[0][0]?r.index:r.index+1)),t.push({appender:s,precision:u}),e=e.substr(r.index+r[0].length)}return e&&t.push(e.toString()),t}(i),u="",c=0,l=0;l<s.length;++l){var f=s[l];if(f&&"object"==(void 0===f?"undefined":_typeof(f))){var p=e[c++];u+=(f.appender||t)(p,u,f.precision)}else u+=t(f)}return u}function indent(e,t,r){if(!r||r<=0)return e;for(var n="";r>0;)r--,n+=t;return lines(e).map(function(e){return n+e}).join("\n")}function minIndent(e,t){t||(t="  ");var r=new RegExp("^("+t+")*","gm");return min(e.match(r).map(function(e){return Math.floor(e.length/t.length)}))}function changeIndent(e,t,r){t||(t="  "),r||(r=0);var n=minIndent(e,t);if(n===r)return e;if(n<r)return indent(e,t,r-n);var i=t.repeat(n-r);return lines(e).map(function(e){return e.slice(i.length)}).join("\n")}function quote(e){return'"'+e.replace(/"/g,'\\"')+'"'}function print(e){if(e&&Array.isArray(e))return"["+e.map(print)+"]";if("string"!=typeof e)return String(e);var t=String(e);return t=t.replace(/\n/g,"\\n\\\n"),t=t.replace(/(")/g,"\\$1"),t='"'+t+'"'}function printNested(e,t){return t=t||0,e.reduce(function(e,r){return e+=Array.isArray(r)?printNested(r,t+1):indent(r+"\n","  ",t)},"")}function pad(e,t,r){return r?" ".repeat(t)+e:e+" ".repeat(t)}function printTable(e,t){function r(e){return!o&&(!!a||t&&Array.isArray(t.align)&&"right"===t.align[e])}var n=[],i=t&&t.separator||" ",o=!t||!t.align||"left"===t.align,a=t&&"right"===t.align;return e.forEach(function(e){e.forEach(function(e,t){void 0===n[t]&&(n[t]=0),n[t]=Math.max(n[t],String(e).length)})}),e.map(function(e){return e.map(function(e,t){var i=String(e);return pad(i,n[t]-i.length,r(t))}).join(i)}).join("\n")}function printTree(e,t,r,n){function i(e,a,s){o[a]=n.repeat(e)+t(s,e);var u=r(s,e),c=a+1;if(!u||!u.length)return c;var l=c,f=u.length-1;return u.forEach(function(t,r){c=i(e+1,c,t);for(var a=f===r,s=o[l].split(""),u=e*n.length+1,p=e*n.length+n.length,r=u;r<p;r++)s[r]="-";a&&(s[e*n.length]="\\"),o[l]=s.join(""),a||o.slice(l,c).forEach(function(t,r){var i=t.split("");i[e*n.length]="|",o[l+r]=i.join("")}),l=c}),c}var o=[];return n=n||"  ",i(0,0,e),o.join("\n")}function toArray$1(e){return e.split("")}function lines(e){return e.split(/\n\r?/)}function paragraphs(e,t){function r(e){return/^\s*$/.test(e)}var n=t?t.sep:"\n\n";return t&&t.keepEmptyLines?e.split("\n").concat("").reduce(function(e,t){var n=e[0],i=e[1];return r(i)===r(t)?i+="\n"+t:(i.length&&n.push(i),i=t),[n,i]},[[],""])[0]:e.split(new RegExp(n+"+"))}function nonEmptyLines(e){return lines(e).compact()}function tokens(e,t){return e.split(t||/\s+/).filter(function(e){return!/^\s*$/.test(e)})}function tableize(e,t){for(var r=(t=t||{}).cellSplitter||/\s+/,n=/^\s*$/,i=!t.hasOwnProperty("convertTypes")||!!t.convertTypes,o=lines(e),a=[],s=0;s<o.length;s++){var u=tokens(o[s],r);i&&(u=u.map(function(e){if(e.match(n))return e;var t=Number(e);if(!isNaN(t))return t;var r=new Date(e);return isNaN(+r)?e.trim():r})),u.length>0&&a.push(u)}return a}function unescapeCharacterEntities(e){if("undefined"==typeof document)throw new Error("Cannot unescapeCharacterEntities");var t=document.createElement("div");return t.innerHTML=e,t.textContent}function toQueryParams(e,t){var r=e.trim().match(/([^?#]*)(#.*)?$/);return r?r[1].split(t||"&").inject({},function(e,t){if((t=t.split("="))[0]){var r=decodeURIComponent(t.shift()),n=t.length>1?t.join("="):t[0];void 0!=n&&(n=decodeURIComponent(n)),r in e?(Array.isArray(e[r])||(e[r]=[e[r]]),e[r].push(n)):e[r]=n}return e}):{}}function normalizePath$1(e){var t=e.match(urlStartRe),r=t?t[0]:null,n=r?e.slice(r.length):e;do{n=(e=n).replace(pathDoubleDotRe,"")}while(n!=e);return n=n.replace(pathDoubleSlashRe,"$1/"),n=n.replace(pathDotRe,"/"),r&&(n=r+n),n}function joinPath(){return normalizePath$1(Array.prototype.slice.call(arguments).reduce(function(e,t){return"string"==typeof t?e.replace(/\/*$/,"")+"/"+t.replace(/^\/*/,""):e}))}function newUUID(){return newUUIDTemplate.replace(newUUIDRe,newUUIDReplacer).toUpperCase()}function createDataURI(e,t){return"data:"+(t=t||"text/plain")+";base64,"+btoa(e)}function hashCode(e){var t=0,r=e.length;if(0==r)return t;for(var n=0;n<r;n++)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t}function md5(e){function t(e,t,r,n,i,o){return t=c(c(t,e),c(n,o)),c(t<<i|t>>>32-i,r)}function r(e,r,n,i,o,a,s){return t(r&n|~r&i,e,r,o,a,s)}function n(e,r,n,i,o,a,s){return t(r&i|n&~i,e,r,o,a,s)}function i(e,r,n,i,o,a,s){return t(r^n^i,e,r,o,a,s)}function o(e,r,n,i,o,a,s){return t(n^(r|~i),e,r,o,a,s)}function a(e,t){var a=e[0],s=e[1],u=e[2],l=e[3];s=o(s=o(s=o(s=o(s=i(s=i(s=i(s=i(s=n(s=n(s=n(s=n(s=r(s=r(s=r(s=r(s,u=r(u,l=r(l,a=r(a,s,u,l,t[0],7,-680876936),s,u,t[1],12,-389564586),a,s,t[2],17,606105819),l,a,t[3],22,-1044525330),u=r(u,l=r(l,a=r(a,s,u,l,t[4],7,-176418897),s,u,t[5],12,1200080426),a,s,t[6],17,-1473231341),l,a,t[7],22,-45705983),u=r(u,l=r(l,a=r(a,s,u,l,t[8],7,1770035416),s,u,t[9],12,-1958414417),a,s,t[10],17,-42063),l,a,t[11],22,-1990404162),u=r(u,l=r(l,a=r(a,s,u,l,t[12],7,1804603682),s,u,t[13],12,-40341101),a,s,t[14],17,-1502002290),l,a,t[15],22,1236535329),u=n(u,l=n(l,a=n(a,s,u,l,t[1],5,-165796510),s,u,t[6],9,-1069501632),a,s,t[11],14,643717713),l,a,t[0],20,-373897302),u=n(u,l=n(l,a=n(a,s,u,l,t[5],5,-701558691),s,u,t[10],9,38016083),a,s,t[15],14,-660478335),l,a,t[4],20,-405537848),u=n(u,l=n(l,a=n(a,s,u,l,t[9],5,568446438),s,u,t[14],9,-1019803690),a,s,t[3],14,-187363961),l,a,t[8],20,1163531501),u=n(u,l=n(l,a=n(a,s,u,l,t[13],5,-1444681467),s,u,t[2],9,-51403784),a,s,t[7],14,1735328473),l,a,t[12],20,-1926607734),u=i(u,l=i(l,a=i(a,s,u,l,t[5],4,-378558),s,u,t[8],11,-2022574463),a,s,t[11],16,1839030562),l,a,t[14],23,-35309556),u=i(u,l=i(l,a=i(a,s,u,l,t[1],4,-1530992060),s,u,t[4],11,1272893353),a,s,t[7],16,-155497632),l,a,t[10],23,-1094730640),u=i(u,l=i(l,a=i(a,s,u,l,t[13],4,681279174),s,u,t[0],11,-358537222),a,s,t[3],16,-722521979),l,a,t[6],23,76029189),u=i(u,l=i(l,a=i(a,s,u,l,t[9],4,-640364487),s,u,t[12],11,-421815835),a,s,t[15],16,530742520),l,a,t[2],23,-995338651),u=o(u,l=o(l,a=o(a,s,u,l,t[0],6,-198630844),s,u,t[7],10,1126891415),a,s,t[14],15,-1416354905),l,a,t[5],21,-57434055),u=o(u,l=o(l,a=o(a,s,u,l,t[12],6,1700485571),s,u,t[3],10,-1894986606),a,s,t[10],15,-1051523),l,a,t[1],21,-2054922799),u=o(u,l=o(l,a=o(a,s,u,l,t[8],6,1873313359),s,u,t[15],10,-30611744),a,s,t[6],15,-1560198380),l,a,t[13],21,1309151649),u=o(u,l=o(l,a=o(a,s,u,l,t[4],6,-145523070),s,u,t[11],10,-1120210379),a,s,t[2],15,718787259),l,a,t[9],21,-343485551),e[0]=c(a,e[0]),e[1]=c(s,e[1]),e[2]=c(u,e[2]),e[3]=c(l,e[3])}function s(e){var t,r=[];for(t=0;t<64;t+=4)r[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return r}function u(e){for(var t="",r=0;r<4;r++)t+=l[e>>8*r+4&15]+l[e>>8*r&15];return t}var c=function(e,t){var r=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(r>>16)<<16|65535&r},l="0123456789abcdef".split("");return function(e){for(var t=e.length,r=0;r<t;r++)e[r]=u(e[r]);return e.join("")}(function(e){var t,r=e.length,n=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=r;t+=64)a(n,s(e.substring(t-64,t)));var i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],o=(e=e.substring(t-64)).length;for(t=0;t<o;t++)i[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(i[t>>2]|=128<<(t%4<<3),t>55)for(a(n,i),t=16;t--;)i[t]=0;return i[14]=8*r,a(n,i),n}(e))}function reMatches$$1(e,t){var r=[];return e.replace(t,function(e,t){r.push({match:e,start:t,end:t+e.length})}),r}function stringMatch(e,t,r){function n(e,t,r,n,i){return n=n||0,i=i||0,[e.slice(0,t),e.slice(t+n,r-i),e.slice(r)]}function i(e,t){if(t.constructor!==RegExp){if(0===e.indexOf(t))return{match:t,rest:e.slice(t.length)};for(var r=0;r<t.length;r++)if(t[r]!=e[r])return{match:null,pos:r};return{match:null}}var n=reMatches$$1(e,t);return n&&n.length&&0===n[0].start?{match:n[0].match,rest:e.slice(n[0].end)}:{match:null}}function o(e,t){for(var r=0,n=0;n<t.length;n++){var o=t[n],a=i(e,o);if(!a.match)return{matched:!1,pos:r+(a.pos||0),pattern:o};r+=a.match.length,e=a.rest}return e.length?{matched:!1,pos:r}:{matched:!0}}function a(e){var t=reMatches$$1(e,/__\//g),r=reMatches$$1(e,/\/__/g);if(t.length!==r.length)throw new Error("pattern invalid: "+e+" cannot be split into __/.../__ embedded RegExps\nstarts: "+JSON.stringify(t)+"\nvs ends:\n"+JSON.stringify(r));var i=0;return t.reduce(function(e,t,o){var a=r[o],s=n(e.pop(),t.start-i,a.end-i,3,3);s[0].length&&(e.push(s[0]),i+=s[0].length);try{s[1].length&&(e.push(new RegExp(s[1])),i+=s[1].length+3+3)}catch(e){throw new Error("Cannot create pattern re from: "+inspect(s))}return s[2].length&&e.push(s[2]),e},[e])}return(r=r||{}).normalizeWhiteSpace&&(e=e.replace(/\s+/g," ")),r.ignoreIndent&&(e=e.replace(/^\s+/gm,""),t=t.replace(/^\s+/gm,"")),e==t?{matched:!0}:function(e,t){var r=o(e,a(t));return r.matched?r:(r.error=e.slice(0,r.pos)+"<--UNMATCHED--\x3e"+e.slice(r.pos),r)}(e,t)}function peekRight(e,t,r){if(e=e.slice(t),"string"==typeof r){var n=e.indexOf(r);return-1===n?null:n+t}if(r.constructor===RegExp){var i=reMatches$$1(e,r);return i[0]?i[0].start:null}return null}function peekLeft(e,t,r){if(e=e.slice(0,t),"string"==typeof r){var n=e.lastIndexOf(r);return-1===n?null:n}if(r.constructor===RegExp){var i=reMatches$$1(e,r);return last(i)?last(i).start:null}return null}function lineIndexComputer(e){var t=lineRanges(e);return function(e){for(var r=0;r<t.length;r++){var n=t[r];if(e>=n[0]&&e<n[1])return r}return-1}}function lineNumberToIndexesComputer(e){return function(t){return lineRanges(e)[t]}}function lineRanges(e){for(var t=0,r=0,n=lines(e),i=[],o=0;o<n.length;o++)r=t+n[o].length+1,i.push([t,r]),t=r;return i}function findLineWithIndexInLineRanges(e,t){var r=e.length;if(0===r)return-1;for(var n=0,i=r;;){var o=n+Math.floor((i-n)/2),a=slicedToArray(e[o],2),s=a[0],u=a[1];if(t<s){if(0===o)return-1;i=o}else{if(!(t>u))return o;n=o}}return-1}function regexIndexOf(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=this.substring(r||0).search(t);return n>=0?n+(r||0):n}function regexLastIndexOf(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.length;t=t.global?t:new RegExp(t.source,"g"+(t.ignoreCase?"i":"")+(t.multiLine?"m":""));for(var n,i=this.substring(0,r+1),o=-1,a=0;null!=(n=t.exec(i));)o=n.index,t.lastIndex=++a;return o}function diff(e,t){return"undefined"==typeof JsDiff?"diff not supported":JsDiff.convertChangesToXML(JsDiff.diffWordsWithSpace(e,t))}function empty(e){return""==e}function startsWithVowel(e){var t=e[0];return"A"===t||"E"===t||"I"===t||"O"===t||"U"===t||"a"===t||"e"===t||"i"===t||"o"===t||"u"===t||!1}function withDecimalPrecision(e,t){var r=parseFloat(e);return isNaN(r)?e:r.toFixed(t)}function capitalize(e){return e.length?e.charAt(0).toUpperCase()+e.slice(1):e}function camelCaseString(e){return e.split(" ").invoke("capitalize").join("")}function camelize(e){var t=e.split("-"),r=t.length;if(1==r)return t[0];for(var n="-"==e.charAt(0)?t[0].charAt(0).toUpperCase()+t[0].substring(1):t[0],i=1;i<r;i++)n+=t[i].charAt(0).toUpperCase()+t[i].substring(1);return n}function truncate(e,t,r){return t=t||30,r=void 0===r?"...":r,e.length>t?e.slice(0,t-r.length)+r:String(e)}function truncateLeft(e,t,r){return t=t||30,r=void 0===r?"...":r,e.length>t?r+e.slice(-t):String(e)}function regExpEscape(e){return e.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")}function succ(e){return e.slice(0,e.length-1)+String.fromCharCode(e.charCodeAt(e.length-1)+1)}function digitValue(e){return e.charCodeAt(0)-"0".charCodeAt(0)}function longestCommonSubstring(e,t){for(var r=[],n=0;n<e.length;n++){r[n]=[];for(var i=0;i<t.length;i++)r[n][i]=0}for(var o=0;o<e.length;o++)r[o][0]=0;for(var a=1;a<e.length;a++)for(var s=1;s<t.length;s++)r[a][s]=e[a-1]==t[s-1]?r[a-1][s-1]+1:0;for(var u=-1,c=-1,l=-1,f=0;f<e.length;f++)for(var p=0;p<t.length;p++){var d=r[f][p];u<d&&(u=d,c=f-d,l=p-d)}return{length:u,indexA:c,indexB:l,string:u>0?e.slice(c,c+u):""}}function applyChange(e,t){return"insert"===t.action?e.slice(0,t.start)+t.lines.join("\n")+e.slice(t.start):"remove"===t.action?e.slice(0,t.start)+e.slice(t.end):e}function applyChanges(e,t){return t.reduce(function(t,r){return applyChange(e,r)},e)}function levenshtein(e,t){if(0===e.length)return t.length;if(0===t.length)return e.length;var r,n,i,o,a,s;for(e.length>t.length&&(r=e,e=t,t=r),s=Array(e.length+1),n=0;n<=e.length;n++)s[n]=n;for(n=1;n<=t.length;n++){for(o=n,i=1;i<=e.length;i++)a=t[n-1]===e[i-1]?s[i-1]:Math.min(s[i-1]+1,Math.min(o+1,s[i]+1)),s[i-1]=o,o=a;s[e.length]=o}return s[e.length]}function random(e,t){return e=e||0,t=t||100,Math.round(Math.random()*(t-e)+e)}function randomSmallerInteger(e){return Math.floor(Math.random()*e)}function humanReadableByteSize(e){function t(e){return Math.round(100*e)/100}return e<1e3?String(t(e))+"B":(e/=1024)<1e3?String(t(e))+"KB":(e/=1024,String(t(e))+"MB")}function average(e){return e.reduce(function(e,t){return e+t},0)/e.length}function averageInc(e,t,r){return(e-t)/r+t}function median(e){var t=e.sort(function(e,t){return t-e}),r=e.length;return r%2==0?.5*(t[r/2-1]+t[r/2]):t[(r-1)/2]}function between(e,t,r,n){n=n||0;var i,o;return t<r?(i=t,o=r):(o=t,i=r),o-e+n>=0&&i-e-n<=0}function sort$1(e){return e.sort(function(e,t){return e-t})}function parseLength(e,t){t=t||"px";var r=e.match(/([0-9\.]+)\s*(.*)/);if(r&&r[1]){var n=parseFloat(r[1]),i=r[2];return convertLength(n,i,t)}}function roundTo(e,t){return t=1/t,Math.round(e*t)/t}function detent(e,t,r,n){var i=roundTo(e,r);return Math.abs(e-i)<t/2?i:n?e:i+(e-(e<i?i-t/2:i+t/2))*r/(r-t)}function toDegrees(e){return 180*e/Math.PI%360}function toRadians(e){return e/180*Math.PI}function backoff(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4,n=Math.min(r,t*Math.pow(2,e)),i=n/2+Math.round(Math.random()*(n/2));return Math.min(r,t+Math.random()*(3*i-t))}function all$2(e,t){var r=[];for(var n in e)!e.__lookupGetter__(n)&&"function"==typeof e[n]||t&&!t(n,e)||r.push(n);return r}function allOwnPropertiesOrFunctions(e,t){return Object.getOwnPropertyNames(e).reduce(function(r,n){return t&&!t(e,n)||r.push(n),r},[])}function own$1(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&(e.__lookupGetter__(r)||"function"!==e[r])&&t.push(r);return t}function forEachOwn(e,t,r){var n=[];for(var i in e)if(e.hasOwnProperty(i)){var o=e[i];"function"!==o&&n.push(t.call(r||this,i,o))}return n}function nameFor(e,t){for(var r in e)if(e[r]===t)return r}function values$1(e){var t=[];for(var r in e)t.push(e[r]);return t}function ownValues(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&t.push(e[r]);return t}function any$1(e,t){for(var r in e)if(t(e,r))return!0;return!1}function allProperties(e,t){var r=[];for(var n in e)t&&!t(e,n)||r.push(n);return r}function hash(e){return Object.keys(e).sort().join("").hashCode()}function format$1(e,t,r){return dateFormat(e,t,r)}function equals$3(e,t){return t&&t instanceof Date&&t.getTime()===e.getTime()}function relativeTo(e,t){if(!(t instanceof Date))return"";if(t<e)return"";if(t===e)return"now";var r="min",n="sec",i="hour",o="day",a=t-e,s=Math.round(a/1e3),u=s%60,c=Math.floor(s/60)%60,l=Math.floor(s/60/60)%24,f=Math.floor(s/60/60/24),p=[];return f>0&&(p.push(f),f>1&&(o+="s"),p.push(o)),l>0&&f<2&&(p.push(l),l>1&&(i+="s"),p.push(i)),c>0&&l<3&&0===f&&(p.push(c),c>1&&(r+="s"),p.push(r)),u>0&&c<3&&0===l&&0===f&&(p.push(u),u>1&&(n+="s"),p.push(n)),p.join(" ")}function promise(e){return"function"==typeof e?promise.convertCallbackFun(e):Promise.resolve(e)}function delay$1(e,t){return new Promise(function(r){return setTimeout(r,e,t)})}function delayReject(e,t){return new Promise(function(r,n){return setTimeout(n,e,t)})}function timeout(e,t){return new Promise(function(r,n){var i=!1;setTimeout(function(){return!i&&(i=!0)&&n(new Error("Promise timed out"))},e),t.then(function(e){return!i&&(i=!0)&&r(e)},function(e){return!i&&(i=!0)&&n(e)})})}function waitFor$1(e,t,r){return"function"==typeof e&&(t=e,e=void 0),new Promise(function(n,i){var o=!1,a=!1,s=void 0,u=void 0,c=setInterval(function(){if(o)return clearInterval(c);try{u=t()}catch(e){s=e}if(u||s||a)return o=!0,clearInterval(c),s?i(s):a?void 0===r?i(new Error("timeout")):n(r):n(u)},10);"number"==typeof e&&setTimeout(function(){return a=!0},e)})}function deferred(){var e,t,r=new Promise(function(r,n){e=r,t=n});return{resolve:e,reject:t,promise:r}}function convertCallbackFun(e){return function(){var t=Array.from(arguments),r=this;return new Promise(function(n,i){t.push(function(e,t){return e?i(e):n(t)}),e.apply(r,t)})}}function convertCallbackFunWithManyArgs(e){return function(){var t=Array.from(arguments),r=this;return new Promise(function(n,i){t.push(function(){var e=Array.from(arguments),t=e.shift();return t?i(t):n(e)}),e.apply(r,t)})}}function _chainResolveNext(e,t,r,n,i){var o=e.shift();if(o)try{Promise.resolve(o(t,r)).then(function(t){return _chainResolveNext(e,t,r,n,i)}).catch(function(e){i(e)})}catch(e){i(e)}else n(t)}function chain$1(e){return new Promise(function(t,r){return _chainResolveNext(e.slice(),void 0,{},t,r)})}function promise_finally(e,t){return Promise.resolve(e).then(function(e){try{t()}catch(e){console.error("Error in promise finally: "+e.stack||e)}return e}).catch(function(e){try{t()}catch(e){console.error("Error in promise finally: "+e.stack||e)}throw e})}function parallel(e){function t(){n--;try{var t=a++;e[t]().then(function(e){n++,i[t]=e,0==--s?u():r()}).catch(function(e){return c(e)})}catch(e){c(e)}}function r(){for(;!o&&s>0&&a<e.length&&n>0;)t()}var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0;if(!e.length)return Promise.resolve([]);var i=[],o=null,a=0,s=e.length,u=void 0,c=void 0;return new Promise(function(e,t){u=function(){return e(i)},c=function(e){return t(o=e)},r()})}function Path(e,t){return e instanceof Path?e:this instanceof Path?(this.setSplitter(t||"."),void this.fromPath(e)):new Path(e,t)}function clone$2(e){var t={};for(var r in e)t[r]=e[r].slice();return t}function without$1(e,t){var r={};for(var n in e)if(!t.includes(n)){r[n]=[];for(var i=e[n],o=0;o<i.length;o++){var a=i[o];t.includes(a)||r[n].push(a)}}return r}function hull(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;if(!Array.isArray(e[t]))return[];for(var i=[],o={},a={},s=0;s<r.length;s++)a[r[s]]=!0;for(var u=e[t].slice(),c={},l=u.length;l--;){var f=u[l];f in a?u.splice(l,1):c[f]=1}if(r)for(;;){if(0===u.length)break;for(var p=0;p<u.length;p++){var d=u.shift();if(!(d in o||d in a)){var h=c[d]||0;if(!(h>n)){i.push(d),o[d]=!0;var m=e[d];if(m)for(var v=0;v<m.length;v++){var y=m[v];y in o||y in c||(c[y]=h+1,u.push(y))}}}}}return i}function subgraphReachableBy(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;r&&(e=without$1(e,r));for(var i=[t],o=0,a={};i.length&&o++<n;){var s=i.shift();if(!a[s]){var u=e[s]||[];a[s]=u,i.push.apply(i,toConsumableArray(u))}}return a}function invert(e){var t={};for(var r in e)for(var n=e[r],i=0;i<n.length;i++){var o=n[i];t[o]?t[o].push(r):t[o]=[r]}return t}function sortByReference(e,t){var r=[],n={},i={},o={};for(var a in e){n.hasOwnProperty(a)||(n[a]=!0,r.push(a));var s=e[a],u={};if(s){i[a]=[];var c=!0,l=!1,f=void 0;try{for(var p,d=s[Symbol.iterator]();!(c=(p=d.next()).done);c=!0){var h=p.value;if(!u.hasOwnProperty(h)&&a!==h){var m=o[h]||(o[h]=[]);m.includes(a)||m.push(a),u[h]=!0,i[a].push(h),n.hasOwnProperty(h)||(n[h]=!0,r.push(h))}}}catch(e){l=!0,f=e}finally{try{!c&&d.return&&d.return()}finally{if(l)throw f}}}}for(var v=[];r.length;){for(var y=1/0,g=[],b=[],_=[],x=0;x<r.length;x++){var w=i[F=r[x]]||[];if(!(w.length>y))if(w.length!==y||w.some(function(e){return g.includes(e)}))y=w.length,g=[F],b=[x],_=(o[F]||[]).slice();else{var k;g.push(F),b.push(x),(k=_).push.apply(k,toConsumableArray(o[F]||[]))}}for(x=b.length;x--;)o[F=r[b[x]]]=[],r.splice(b[x],1);var E=!0,S=!1,A=void 0;try{for(var D,C=_[Symbol.iterator]();!(E=(D=C.next()).done);E=!0){var F=D.value;i[F]=i[F].filter(function(e){return!g.includes(e)})}}catch(e){S=!0,A=e}finally{try{!E&&C.return&&C.return()}finally{if(S)throw A}}v.push(g)}return v}function reduce$1(e,t,r,n,i,o){function a(r){s.indexOf(r)>-1||(n=e.call(o,n,r,u++),s=s.concat([r]),withoutAll(t[r]||[],s).forEach(function(e){return a(e)}))}var s=i||[],u=0;return a(r),n}function random$1(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,t={},r=range(1,e).map(String),n=0;n<r.length;n++){var i=Math.floor(Math.random()*e);t[r[n]]=shuffle(r).slice(0,i)}return t}function isInterval(e){return Array.isArray(e)&&e.length>=2&&e[0]<=e[1]}function sort$2(e){return e.sort(compare)}function compare(e,t){return e[0]<t[0]?e[1]<t[0]?-3:e[1]===t[0]?-2:-1:e[0]===t[0]?e[1]===t[1]?0:e[1]<t[1]?-1:1:-1*compare(t,e)}function coalesce(e,t,r){switch(this.compare(e,t)){case-3:case 3:return null;case 0:return r&&r(e,t,e),e;case 2:case 1:var n=e;e=t,t=n;case-2:case-1:var i=[e[0],Math.max(e[1],t[1])];return r&&r(e,t,i),i;default:throw new Error("Interval compare failed")}}function coalesceOverlapping(e,t){for(var r=[],n=e.length;n>0;){var i=e.shift();n--;for(var o=0;o<n;o++){var a=coalesce(i,e[o],t);a&&(i=a,e.splice(o,1),n--,o--)}r.push(i)}return this.sort(r)}function mergeOverlapping(e,t,r){for(var n=[];e.length>0;){var i=e.shift(),o=t.map(function(e){var t=compare(i,e);return-1===t||0===t||1===t});n.push(r(i,o[0])),n.push(i)}return n}function intervalsInRangeDo(e,t,r,n,i,o){o=o||GLOBAL$2,r=this.sort(r);for(var a,s=[];a=r.shift();)if(!(a[1]<e)){a[0]<e&&((a=Array.prototype.slice.call(a))[0]=e);var u=t<a[0]?t:a[0];if(e<u&&s.push(n.call(o,[e,u],!0)),t<a[1]&&((a=Array.prototype.slice.call(a))[1]=t),a[0]===a[1]){var c;i&&(c=s.slice(-1)[0])&&i.call(o,c,a,c)}else s.push(n.call(o,a,!1));if((e=a[1])>=t)break}return e<t&&s.push(n.call(o,[e,t],!0)),s}function intervalsInbetween(e,t,r){return intervalsInRangeDo(e,t,coalesceOverlapping(Array.prototype.slice.call(r)),function(e,t){return t?e:null}).filter(Boolean)}function mapToMatchingIndexes(e,t){var r,n,i=0;return t.map(function(t){for(;(n=e[i])&&n[0]<t[0];)i++;if(n&&n[0]===t[0]){for(r=i;(n=e[r])&&n[1]<t[1];)r++;if(n&&n[1]===t[1])return range(i,r)}return[]})}function create(e,t,r){var n=r||0;return n+t>e.length&&(n-=n+t-e.length),{array:e,from:n,to:n+t}}function toArray$4(e){return e.array.slice(e.from,e.to)}function originalToProjectedIndex(e,t){return t<e.from||t>=e.to?null:t-e.from}function projectedToOriginalIndex(e,t){return t<0||t>e.to-e.from?null:e.from+t}function transformToIncludeIndex(e,t){if(!(t in e.array))return null;var r=0;return t<e.from&&(r=-e.from+t),t>=e.to&&(r=t-e.to+1),0===r?e:create(e.array,e.to-e.from,e.from+r)}function get$2(e,t,r){var n=e[t];return n?n[r]:void 0}function set$2(e,t,r,n){var i=e[t];return i&&(i[r]=n),n}function getRow(e,t){return e[t]}function setRow(e,t,r){return e[t]=r}function getCol(e,t){return e.reduce(function(e,r){return e.push(r[t]),e},[])}function setCol(e,t,r){return e.map(function(e,n){return e[t]?e[t]=r[n]:void 0})}function create$1(e,t,r){for(var n=new Array(e);e>0;)n[--e]=withN(t,r);return n}function mapCreate(e,t,r,n){for(var i=new Array(e),o=0;o<e;o++){i[o]=new Array(t);for(var a=0;a<t;a++)i[o][a]=r.call(n||this,o,a)}return i}function forEach$2(e,t,r){e.forEach(function(e,n){e.forEach(function(e,i){t.call(r||this,e,n,i)})})}function map$2(e,t,r){var n=new Array(e.length);return e.forEach(function(e,i){n[i]=new Array(e.length),e.forEach(function(e,o){n[i][o]=t.call(r||this,e,i,o)})}),n}function toObjects(e){for(var t=e[0],r=new Array(e.length-1),n=1;n<e.length;n++)for(var i=r[n-1]={},o=0;o<t.length;o++)i[t[o]]=e[n][o];return r}function tableFromObjects(e,t){Array.isArray(e)||(e=[e]);var r=[[]],n=r[0],i=e.reduce(function(e,t){return e.concat([Object.keys(t).reduce(function(e,r){var i=n.indexOf(r);return-1===i&&(i=n.length,n.push(r)),e[i]=t[r],e},[])])},[]);return t=1===arguments.length?null:t,i.forEach(function(e){for(var r=0;r<n.length;r++)e[r]||(e[r]=t)}),r.concat(i)}function prewalk(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{i:0},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=n.i++;t(e,o,i),(r(e,o,i)||[]).forEach(function(e){return prewalk(e,t,r,n,i+1)})}function postwalk(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{i:0},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=n.i++;(r(e,o,i)||[]).forEach(function(e){return postwalk(e,t,r,n,i)}),t(e,o,i)}function find(e,t,r){if(t(e))return e;var n=r(e);if(n&&n.length)for(var i=0;i<n.length;i++){var o=find(n[i],t,r);if(o)return o}}function filter$1(e,t,r){var n=[];return t(e)&&n.push(e),n.concat(flatten((r(e)||[]).map(function(e){return filter$1(e,t,r)})))}function map$3(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return[t(e,n)].concat(flatten((r(e)||[]).map(function(e){return map$3(e,t,r,n+1)})))}function mapTree(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=(r(e)||[]).map(function(e){return mapTree(e,t,r,n+1)});return t(e,i,n)}function create$2(e){var t=[{name:"send",args:["msg","callback"]},{name:"listen",args:["messenger","callback"]},{name:"close",args:["messenger","callback"]},{name:"isOnline",args:[]}],r=t.map(function(e){return e.name}).concat(["id","sendHeartbeat","heartbeatInterval","ignoreUnknownMessages","allowConcurrentSends","sendTimeout","services"]);t.forEach(function(t){if(!e[t.name]){var r="message implementation needs function "+t.name+"("+t.args.join(",")+")";throw new Error(r)}});var n=e.sendHeartbeat&&(e.heartbeatInterval||1e3),i=!!e.hasOwnProperty("ignoreUnknownMessages")&&e.ignoreUnknownMessages,o={_outgoing:[],_inflight:[],_id:e.id||newUUID(),_ignoreUnknownMessages:i,_services:{},_messageCounter:0,_messageResponseCallbacks:{},_whenOnlineCallbacks:[],_statusWatcherProc:null,_startHeartbeatProcessProc:null,_listenInProgress:null,_heartbeatInterval:n,_status:OFFLINE,_runWhenOnlineCallbacks:function(){var e=o._whenOnlineCallbacks.slice();o._whenOnlineCallbacks=[],e.forEach(function(e){try{e.call(null,null,o)}catch(e){console.error("error in _runWhenOnlineCallbacks: %s",e)}})},_ensureStatusWatcher:function(){o._statusWatcherProc||(o._statusWatcherProc=setInterval(function(){o.isOnline()&&o._whenOnlineCallbacks.length&&o._runWhenOnlineCallbacks();var e=o._status;o._status=o.isOnline()?ONLINE:OFFLINE,o._status!==ONLINE&&o._statusWatcherProc&&o.reconnect(),o._status!==e&&o.onStatusChange&&o.onStatusChange()},20))},_addMissingData:function(e){if(!e.target)throw new Error("Message needs target!");if(!e.action)throw new Error("Message needs action!");return e.data||(e.data=null),e.messageId||(e.messageId=newUUID()),e.sender=o.id(),e.messageIndex=o._messageCounter++,e},_queueSend:function(e,t){if(t&&"function"!=typeof t)throw new Error("Expecing a when send callback, got: "+t);o._outgoing.push([e,t])},_deliverMessageQueue:function(){function t(t){if(-1!==o._inflight.indexOf(t)){var n=t[0],i=t[1];i&&(o._messageResponseCallbacks[n.messageId]=i),e.send.call(o,n,function(e){remove(o._inflight,t),e&&r(e,t),o._deliverMessageQueue()})}}function r(e,t){var r=t[0],n=t[1];delete o._messageResponseCallbacks[r.messageId],console.error(e),n&&n(e)}if(e.allowConcurrentSends||!o._inflight.length){var n=o._outgoing.shift();n&&(o._inflight.push(n),o.isOnline()?t(n):o.whenOnline(function(){t(n)}),function(t){"number"==typeof e.sendTimeout&&setTimeout(function(){-1!==o._inflight.indexOf(t)&&(remove(o._inflight,t),r(new Error("Timeout sending message"),t),o._deliverMessageQueue())},e.sendTimeout)}(n),e.allowConcurrentSends&&o._outgoing.length&&o._deliverMessageQueue())}},_startHeartbeatProcess:function(){o._startHeartbeatProcessProc||(o._startHeartbeatProcessProc=setTimeout(function(){e.sendHeartbeat.call(o,function(e,t){o._startHeartbeatProcessProc=null,o._startHeartbeatProcess()})},o._heartbeatInterval))},id:function(){return o._id},isOnline:function(){return e.isOnline.call(o)},heartbeatEnabled:function(){return"number"==typeof o._heartbeatInterval},listen:function(t){if(!o._listenInProgress)return o._listenInProgress=!0,o._ensureStatusWatcher(),e.listen.call(o,function(e){o._listenInProgress=null,t&&t(e),o.heartbeatEnabled()&&o._startHeartbeatProcess()})},reconnect:function(){if(o._status!==ONLINE)return o.listen(),o},send:function(e,t){return o._addMissingData(e),o._queueSend(e,t),o._deliverMessageQueue(),e},sendTo:function(e,t,r,n){var i={target:e,action:t,data:r};return o.send(i,n)},onMessage:function(e){if(o.emit("message",e),e.inResponseTo){var t=o._messageResponseCallbacks[e.inResponseTo];t&&!e.expectMoreResponses&&delete o._messageResponseCallbacks[e.inResponseTo],t&&t(null,e)}else{var r=o._services[e.action];if(r)try{r.call(null,e,o)}catch(t){var n=String(t.stack||t);console.error("Error invoking service: "+n),o.answer(e,{error:n})}else if(!o._ignoreUnknownMessages){var i=new Error("messageNotUnderstood: "+e.action);o.answer(e,{error:String(i)})}}},answer:function(e,t,r,n){"function"==typeof r&&(n=r,r=!1);var i={target:e.sender,action:e.action+"Result",inResponseTo:e.messageId,data:t};return r&&(i.expectMoreResponses=!0),o.send(i,n)},close:function(t){return clearInterval(o._statusWatcherProc),o._statusWatcherProc=null,e.close.call(o,function(e){o._status=OFFLINE,t&&t(e)}),o},whenOnline:function(e){return o._whenOnlineCallbacks.push(e),o.isOnline()&&o._runWhenOnlineCallbacks(),o},outgoingMessages:function(){return pluck(o._inflight.concat(o._outgoing),0)},addServices:function(e){return Object.assign(o._services,e),o}};e.services&&o.addServices(e.services),makeEmitter(o);for(var a in e)-1===r.indexOf(a)&&e.hasOwnProperty(a)&&(o[a]=e[a]);return o}function fork(e,t,r){r||(r=t,t=e,e=null);var n=(e=e||{}).args||[],i=create$3(e);return i.run.apply(i,[t].concat(n).concat(r)),i}function create$3(e){(e=e||{}).useMessenger=!0;var t=e.workerId||newUUID(),r=create$2({sendTimeout:5e3,send:function(e,t){r.worker.postMessage(e),t()},listen:function(t){var n=r.worker=isNodejs?NodejsWorker.create(e):BrowserWorker.create(e);n.on("message",function(e){r.onMessage(e)}),n.on("ready",function(){NodejsWorker.debug&&console.log("WORKER READY!!!")}),n.on("close",function(){NodejsWorker.debug&&console.log("WORKER CLOSED...!!!")}),n.once("ready",t)},close:function(e){return r.worker.ready?r.sendTo(t,"close",{},function(t,n){if((t=t||n.data.error)&&console.error("Error in worker messenger close: "+t.stack||t),t)e(t);else{var i=!1;r.worker.once("close",function(){i=!0}),waitFor(1e3,function(){return!!i},e)}}):e(null)},isOnline:function(){return r.worker&&r.worker.ready}});return Object.assign(r,{eval:function(e,n){r.sendTo(t,"remoteEval",{expr:e},function(e,t){n(e,t?t.data.result:null)})},run:function(){var e=Array.prototype.slice.call(arguments),n=e.shift(),i=e.pop();if("function"!=typeof n)throw new Error("run: no function that should run in worker passed");if("function"!=typeof i)throw new Error("run: no callback passed");return r.sendTo(t,"run",{func:String(n),args:e},function(e,t){i(e||t.data.error,t?t.data.result:null)})}}),r.listen(),r}function createLivelyLangObject(){return{chain:chain$$1,noConflict:noConflict,installGlobals:installGlobals,uninstallGlobals:uninstallGlobals,globalInterfaceSpec:globalInterfaceSpec,toString:function(){return"[object lively.lang]"}}}function chain$$1(e){if(!e)return e;if(Array.isArray(e))return createChain(arr,e);if("Date"===e.constructor.name)return createChain(date,e);switch(void 0===e?"undefined":_typeof(e)){case"string":return createChain(string,e);case"object":return createChain(obj,e);case"function":return createChain(fun,e);case"number":return createChain(num,e)}throw new Error("Chain for object "+e+" ("+e.constructor.name+") no supported")}function createChain(e,t){return Object.keys(e).reduce(function(r,n){return r[n]=function(){var r=Array.prototype.slice.call(arguments);return chain$$1(e[n].apply(null,[t].concat(r)))},r},{value:function(){return t}})}function noConflict(){return isNode||(livelyLang._prevLivelyGlobal?delete GLOBAL.lively.lang:delete GLOBAL.lively),livelyLang}function installGlobals(){Object.assign(livelyLang,{worker:worker,messenger:messenger,events:events,tree:tree,grid:grid,arrayProjection:arrayProjection,interval:interval,graph:graph,date:date,properties:properties,obj:obj,arr:arr,fun:fun,num:num,string:string,Closure:Closure,promise:promise,Path:Path,Group:Group}),globalInterfaceSpec.forEach(function(e){if("installMethods"===e.action){(r=Path(e.target)).isIn(GLOBAL)||r.set(GLOBAL,{},!0);var t=Path(e.sources[0]);e.methods.forEach(function(e){installProperty(t.concat([e]),r.concat([e]))}),e.alias&&e.alias.forEach(function(e){installProperty(t.concat([e[1]]),r.concat([e[0]]))})}else{if("installObject"!==e.action)throw new Error("Cannot deal with global setup action: "+e.action);var r=Path(e.target),n=Path(e.source).get(livelyLang);r.set(GLOBAL,n,!0)}})}function installProperty(e,t){if(!e.isIn(livelyLang)){var r=new Error("property not provided by lively.lang: "+e);throw console.error(r.stack||r),r}var n=e.get(livelyLang);if("function"==typeof n&&"prototype"===t.slice(-2,-1).toString()){var i=n;(n=function(){var e=Array.prototype.slice.call(arguments);return e.unshift(this),i.apply(null,e)}).toString=function(){return i.toString()}}t.set(GLOBAL,n,!0)}function uninstallGlobals(){globalInterfaceSpec.forEach(function(e){if("installMethods"===e.action){var t=Path(e.target),r=Path(e.source).get(livelyLang),n=t.get(GLOBAL);if(!n)return;e.methods.filter(function(e){return r===n[e]}).forEach(function(e){delete n[e]}),e.alias&&e.alias.filter(function(e){return r===n[e]}).forEach(function(e){delete n[e[0]]})}else{if("installObject"!==e.action)throw new Error("Cannot deal with global setup action: "+e.action);(t=Path(e.target)).del(GLOBAL)}})}var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},classCallCheck=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),get$1=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},set$1=function e(t,r,n,i){var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var a=Object.getPrototypeOf(t);null!==a&&e(a,r,n,i)}else if("value"in o&&o.writable)o.value=n;else{var s=o.set;void 0!==s&&s.call(i,n)}return n},slicedToArray=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),toConsumableArray=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},parameterRegex=/function[^\(]*\(([^\)]*)\)|\(?([^\)=]*)\)?\s*=>/,Closure=function(){function e(t,r,n,i){classCallCheck(this,e),this.originalFunc=t,this.varMapping=r||{},this.setFuncSource(n||t),this.setFuncProperties(t||i)}return createClass(e,null,[{key:"fromFunction",value:function(e,t){return new this(e,t||{})}},{key:"fromSource",value:function(e,t){return new this(null,t||{},e)}}]),createClass(e,[{key:"setFuncSource",value:function(e){return e="undefined"!=typeof lively&&lively.sourceTransform&&"function"==typeof lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder?lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder(e):String(e),this.source=e}},{key:"getFuncSource",value:function(){return this.source||this.setFuncSource(this.originalFunc)}},{key:"hasFuncSource",value:function(){return this.source&&!0}},{key:"getFunc",value:function(){return this.originalFunc||this.recreateFunc()}},{key:"getFuncProperties",value:function(){return this.funcProperties||(this.funcProperties={})}},{key:"setFuncProperties",value:function(e){var t=this.getFuncProperties();for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])}},{key:"lookup",value:function(e){return this.varMapping[e]}},{key:"parameterNames",value:function(e){if("undefined"!=typeof lively&&lively.ast)return(lively.ast.parseFunction(e).params||[]).map(function(e){return"Identifier"===e.type?e.name:e.left&&"Identifier"===e.left.type?e.left.name:null}).filter(Boolean);var t=parameterRegex.exec(e);return t?(t[1]||t[2]||"").split(",").map(function(e){return e.trim()}):[]}},{key:"firstParameter",value:function(e){return this.parameterNames(e)[0]||null}},{key:"recreateFunc",value:function(){return this.recreateFuncFromSource(this.getFuncSource(),this.originalFunc)}},{key:"recreateFuncFromSource",value:function(e,t){var r=[],n="$super"===this.firstParameter(e);for(var i in this.varMapping)this.varMapping.hasOwnProperty(i)&&("this"!=i?r.push("var "+i+" = this.varMapping."+i+";\n"):!0);var o="";r.length>0&&(o+=r.join("\n")),n&&(o+="(function superWrapperForClosure() { return "),o+="("+e+")",n&&(o+=".apply(this, [$super.bind(this)].concat(Array.from(arguments))) })");try{var a=evalJS.call(this,o)||this.couldNotCreateFunc(o);return this.addFuncProperties(a),this.originalFunc=a,a}catch(e){var s="Cannot create function "+e+" src: "+o;throw console.error(s),new Error(s)}}},{key:"addFuncProperties",value:function(e){var t=this.getFuncProperties();for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);this.addClosureInformation(e)}},{key:"couldNotCreateFunc",value:function(e){var t="Could not recreate closure from source: \n"+e;return console.error(t),function(){throw new Error(t)}}},{key:"asFunction",value:function(){return this.recreateFunc()}},{key:"addClosureInformation",value:function(e){return e.hasLivelyClosure=!0,e.livelyClosure=this,e}},{key:"isLivelyClosure",get:function(){return!0}},{key:"doNotSerialize",get:function(){return["originalFunc"]}}]),e}(),_throttledByName={},_debouncedByName={},_queues={},_queueUntilCallbacks={},_eitherNameRegistry={},fun=Object.freeze({Empty:Empty,K:K,Null:Null,False:False,True:True,notYetImplemented:notYetImplemented,withNull:withNull,all:all,own:own,argumentNames:argumentNames,qualifiedMethodName:qualifiedMethodName,extractBody:extractBody,timeToRun:timeToRun,timeToRunN:timeToRunN$1,delay:delay,throttle:throttle,debounce:debounce,throttleNamed:throttleNamed,debounceNamed:debounceNamed,createQueue:createQueue,workerWithCallbackQueue:workerWithCallbackQueue,composeAsync:composeAsync,compose:compose,waitFor:waitFor,waitForAll:waitForAll,flip:flip,curry:curry,wrap:wrap,binds:binds,getOriginal:getOriginal,wrapperChain:wrapperChain,replaceMethodForOneCall:replaceMethodForOneCall,once:once,either:either,eitherNamed:eitherNamed,evalJS:evalJS,fromString:fromString,asScript:asScript,asScriptOf:asScriptOf,addToObject:addToObject,setLocalVarValue:setLocalVarValue,getVarMapping:getVarMapping,setProperty:setProperty,functionNames:functionNames,localFunctionNames:localFunctionNames,logErrors:logErrors,logCompletion:logCompletion,logCalls:logCalls,traceCalls:traceCalls,webkitStack:webkitStack}),Group=function(){function e(){classCallCheck(this,e)}return createClass(e,[{key:"toArray",value:function(){return this.reduceGroups(function(e,t,r){return e.concat([r])},[])}},{key:"forEach",value:function(e,t){var r=this;return Object.keys(r).forEach(function(n){r[n].forEach(e.bind(t,n))}),r}},{key:"forEachGroup",value:function(e,t){var r=this;return Object.keys(r).forEach(function(n){e.call(t,n,r[n])}),r}},{key:"map",value:function(t,r){var n=new e;return this.forEachGroup(function(e,i){n[e]=i.map(t.bind(r,e))}),n}},{key:"mapGroups",value:function(t,r){var n=new e;return this.forEachGroup(function(e,i){n[e]=t.call(r,e,i)}),n}},{key:"keys",value:function(){return Object.keys(this)}},{key:"reduceGroups",value:function(e,t,r){return this.forEachGroup(function(n,i){t=e.call(r,t,n,i)}),t}},{key:"count",value:function(){return this.reduceGroups(function(e,t,r){return e[t]=r.length,e},{})}}],[{key:"fromArray",value:function(t,r,n){for(var i=new e,o=0,a=t.length;o<a;o++){var s=r.call(n,t[o],o);i[s]||(i[s]=[]),i[s].push(t[o])}return i}},{key:"by",get:function(){return groupBy}}]),e}(),GLOBAL$1="undefined"!=typeof System?System.global:"undefined"!=typeof window?window:global,features$1={from:!!Array.from,filter:!!Array.prototype.filter,find:!!Array.prototype.find,findIndex:!!Array.prototype.findIndex,includes:!!Array.prototype.includes},from=features$1.from?Array.from:function(e){if(!e)return[];if(Array.isArray(e))return e;if(e.toArray)return e.toArray();for(var t=e.length,r=new Array(t);t--;)r[t]=e[t];return r},detect=features$1.find?function(e,t,r){return e.find(t,r)}:function(e,t,r){for(var n,i=0,o=e.length;i<o;i++)if(n=e[i],t.call(r,n,i))return n},findIndex=features$1.findIndex?function(e,t,r){return e.findIndex(t,r)}:function(e,t,r){var n=-1;return e.find(function(e,i){return n=i,t.call(e,r)})?n:-1},isArray$1=Array.isArray,includes$1=features$1.includes?function(e,t){return e.includes(t)}:function(e,t){return-1!==e.indexOf(t)},include$1=includes$1,permutations=function(){function e(t,r){return t.length?flatmap(t,function(n,i){return e(t.slice(0,i).concat(t.slice(i+1)),r.concat([n]))}):[r]}return function(t){return e(t,[])}}();features$1.from||(Array.from=from),features$1.filter||(Array.prototype.filter=function(e,t){return filter(this,e,t)}),features$1.find||(Array.prototype.find=function(e,t){return detect(this,e,t)}),features$1.findIndex||(Array.prototype.findIndex=function(e,t){return findIndex(this,e,t)}),features$1.includes||(Array.prototype.includes=function(e){return includes$1(this,e)});var arr=Object.freeze({range:range,from:from,withN:withN,genN:genN,filter:filter,detect:detect,findIndex:findIndex,findAndGet:findAndGet,filterByKey:filterByKey,grep:grep,mask:mask,reject:reject,rejectByKey:rejectByKey,without:without,withoutAll:withoutAll,uniq:uniq,uniqBy:uniqBy,uniqByKey:uniqByKey,compact:compact,mutableCompact:mutableCompact,forEach:forEach$1,zip:zip,flatten:flatten,flatmap:flatmap,interpose:interpose,delimWith:delimWith,map:map$1,invoke:invoke,pluck:pluck,reduce:reduce,reduceRight:reduceRight,isArray:isArray$1,includes:includes$1,include:include$1,some:some,every:every,equals:equals$2,deepEquals:deepEquals,isSorted:isSorted,sort:sort,sortBy:sortBy,sortByKey:sortByKey,reverse:reverse,reversed:reversed,reMatches:reMatches$1,first:first,last:last,intersect:intersect,union:union,pushAt:pushAt,removeAt:removeAt,remove:remove,pushAll:pushAll$1,pushAllAt:pushAllAt,pushIfNotIncluded:pushIfNotIncluded,replaceAt:replaceAt,clear:clear,isSubset:isSubset,doAndContinue:doAndContinue,nestedDelay:nestedDelay,forEachShowingProgress:forEachShowingProgress,swap:swap,rotate:rotate,groupBy:groupBy,groupByKey:groupByKey,partition:partition,batchify:batchify,toTuples:toTuples,permutations:permutations,combinationsPick:combinationsPick,combinations:combinations,take:take,drop:drop,takeWhile:takeWhile,dropWhile:dropWhile,shuffle:shuffle,max:max,min:min,sum:sum,count:count$1,size:size$1,histogram:histogram,clone:clone$1,toArray:toArray$3,each:each,all:all$1,any:any,collect:collect,findAll:findAll,inject:inject,mapAsyncSeries:mapAsyncSeries,mapAsync:mapAsync}),getOwnPropertyDescriptors="function"==typeof Object.prototype.getOwnPropertyDescriptors?Object.prototype.getOwnPropertyDescriptors:function(e){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&Object.defineProperty(t,r,{configurable:!0,enumerable:!0,writable:!0,value:Object.getOwnPropertyDescriptor(e,r)});return t},keys$1=Object.keys,obj=Object.freeze({isArray:isArray$$1,isElement:isElement,isFunction:isFunction,isBoolean:isBoolean,isString:isString,isNumber:isNumber,isUndefined:isUndefined,isRegExp:isRegExp,isObject:isObject,isPrimitive:isPrimitive,isEmpty:isEmpty,equals:equals$1,keys:keys$1,values:values,select:select,dissoc:dissoc,addScript:addScript,extend:extend,clone:clone$$1,extract:extract,inspect:inspect,merge:merge,deepMerge:deepMerge,inherit:inherit,valuesInPropertyHierarchy:valuesInPropertyHierarchy,mergePropertyInHierarchy:mergePropertyInHierarchy,sortKeysWithBeforeAndAfterConstraints:sortKeysWithBeforeAndAfterConstraints,deepCopy:deepCopy,typeStringOf:typeStringOf,shortPrintStringOf:shortPrintStringOf,isMutableType:isMutableType,safeToString:safeToString,asObject:asObject,newKeyIn:newKeyIn}),features={repeat:!!String.prototype.repeat,includes:!!String.prototype.includes,startsWith:!!String.prototype.startsWith,endsWith:!!String.prototype.endsWith},pathDotRe=/\/\.\//g,pathDoubleDotRe=/\/[^\/]+\/\.\./,pathDoubleSlashRe=/(^|[^:])[\/]+/g,urlStartRe=/^[a-z0-9-_\.]+:\/\//,newUUIDTemplate="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",newUUIDRe=/[xy]/g,newUUIDReplacer=function(e){var t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)},includes$$1=features.includes?function(e,t){return e.includes(t)}:function(e,t){return e.indexOf(t)>-1},include$$1=includes$$1,startsWith=features.startsWith?function(e,t){return e.startsWith(t)}:function(e,t){return 0===e.indexOf(t)},endsWith=features.endsWith?function(e,t){return e.endsWith(t)}:function(e,t){var r=e.length-t.length;return r>=0&&e.lastIndexOf(t)===r},times=features.repeat?function(e,t){return e.repeat(t)}:function(e,t){return t<1?"":new Array(t+1).join(e)},string=Object.freeze({format:format,formatFromArray:formatFromArray,indent:indent,minIndent:minIndent,changeIndent:changeIndent,quote:quote,print:print,printNested:printNested,pad:pad,printTable:printTable,printTree:printTree,toArray:toArray$1,lines:lines,paragraphs:paragraphs,nonEmptyLines:nonEmptyLines,tokens:tokens,tableize:tableize,unescapeCharacterEntities:unescapeCharacterEntities,toQueryParams:toQueryParams,normalizePath:normalizePath$1,joinPath:joinPath,newUUID:newUUID,createDataURI:createDataURI,hashCode:hashCode,md5:md5,reMatches:reMatches$$1,stringMatch:stringMatch,peekRight:peekRight,peekLeft:peekLeft,lineIndexComputer:lineIndexComputer,lineNumberToIndexesComputer:lineNumberToIndexesComputer,findLineWithIndexInLineRanges:findLineWithIndexInLineRanges,regexIndexOf:regexIndexOf,regexLastIndexOf:regexLastIndexOf,lineRanges:lineRanges,diff:diff,empty:empty,includes:includes$$1,include:include$$1,startsWith:startsWith,startsWithVowel:startsWithVowel,endsWith:endsWith,withDecimalPrecision:withDecimalPrecision,capitalize:capitalize,camelCaseString:camelCaseString,camelize:camelize,truncate:truncate,truncateLeft:truncateLeft,regExpEscape:regExpEscape,succ:succ,digitValue:digitValue,times:times,longestCommonSubstring:longestCommonSubstring,applyChange:applyChange,applyChanges:applyChanges,levenshtein:levenshtein}),normalRandom=function(e,t){var r,n=!1;return function(e,t){if(n)return n=!1,r*t+e;var i,o,a;do{a=(i=2*Math.random()-1)*i+(o=2*Math.random()-1)*o}while(a>=1||0==a);var s=Math.sqrt(-2*Math.log(a)/a);return r=o*s,n=!0,e+t*i*s}}(),convertLength=function(){function e(t,r){return"cm"===r?t:"mm"===r?.1*t:"in"===r?2.54*t:"px"===r?t*e(1/96,"in"):"pt"===r?t*e(1/72,"in"):"pc"===r?t*e(12,"pt"):void 0}return function t(r,n,i){return n===i?r:"cm"===i?e(r,n):"cm"===n?r/e(1,i):t(t(r,n,"cm"),"cm",i)}}(),num=Object.freeze({random:random,normalRandom:normalRandom,randomSmallerInteger:randomSmallerInteger,humanReadableByteSize:humanReadableByteSize,average:average,averageInc:averageInc,median:median,between:between,sort:sort$1,parseLength:parseLength,convertLength:convertLength,roundTo:roundTo,detent:detent,toDegrees:toDegrees,toRadians:toRadians,backoff:backoff}),properties=Object.freeze({all:all$2,allOwnPropertiesOrFunctions:allOwnPropertiesOrFunctions,own:own$1,forEachOwn:forEachOwn,nameFor:nameFor,values:values$1,ownValues:ownValues,any:any$1,allProperties:allProperties,hash:hash}),dateFormat=function(){var e=function(){var t=/d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,r=/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,n=/[^-+\dA-Z]/g,i=function(e,t){for(e=String(e),t=t||2;e.length<t;)e="0"+e;return e};return function(o,a,s){var u=e;if(1!=arguments.length||"[object String]"!=Object.prototype.toString.call(o)||/\d/.test(o)||(a=o,o=void 0),o=o?new Date(o):new Date,isNaN(o))throw SyntaxError("invalid date");"UTC:"==(a=String(u.masks[a]||a||u.masks.default)).slice(0,4)&&(a=a.slice(4),s=!0);var c=s?"getUTC":"get",l=o[c+"Date"](),f=o[c+"Day"](),p=o[c+"Month"](),d=o[c+"FullYear"](),h=o[c+"Hours"](),m=o[c+"Minutes"](),v=o[c+"Seconds"](),y=o[c+"Milliseconds"](),g=s?0:o.getTimezoneOffset(),b={d:l,dd:i(l),ddd:u.i18n.dayNames[f],dddd:u.i18n.dayNames[f+7],m:p+1,mm:i(p+1),mmm:u.i18n.monthNames[p],mmmm:u.i18n.monthNames[p+12],yy:String(d).slice(2),yyyy:d,h:h%12||12,hh:i(h%12||12),H:h,HH:i(h),M:m,MM:i(m),s:v,ss:i(v),l:i(y,3),L:i(y>99?Math.round(y/10):y),t:h<12?"a":"p",tt:h<12?"am":"pm",T:h<12?"A":"P",TT:h<12?"AM":"PM",Z:s?"UTC":(String(o).match(r)||[""]).pop().replace(n,""),o:(g>0?"-":"+")+i(100*Math.floor(Math.abs(g)/60)+Math.abs(g)%60,4),S:["th","st","nd","rd"][l%10>3?0:(l%100-l%10!=10)*l%10]};return a.replace(t,function(e){return e in b?b[e]:e.slice(1,e.length-1)})}}();return e.masks={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:ss",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"},e.i18n={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"]},e}(),date=Object.freeze({format:format$1,equals:equals$3,relativeTo:relativeTo});Object.assign(promise,{delay:delay$1,delayReject:delayReject,timeout:timeout,waitFor:waitFor$1,deferred:deferred,convertCallbackFun:convertCallbackFun,convertCallbackFunWithManyArgs:convertCallbackFunWithManyArgs,chain:chain$1,finally:promise_finally,parallel:parallel}),Object.assign(Path.prototype,{get isPathAccessor(){return!0},fromPath:function(e){return"string"==typeof e&&""!==e&&e!==this.splitter?(this._parts=e.split(this.splitter),this._path=e):Array.isArray(e)?(this._parts=[].concat(e),this._path=e.join(this.splitter)):(this._parts=[],this._path=""),this},setSplitter:function(e){return e&&(this.splitter=e),this},parts:function(){return this._parts},size:function(){return this._parts.length},slice:function(e,t){return Path(this.parts().slice(e,t))},normalizePath:function(){return this._path},isRoot:function(e){return 0===this._parts.length},isIn:function(e){if(this.isRoot())return!0;var t=this.get(e,-1);return t&&t.hasOwnProperty(this._parts[this._parts.length-1])},equals:function(e){return e&&e.isPathAccessor&&this.parts().equals(e.parts())},isParentPathOf:function(e){e=e&&e.isPathAccessor?e:Path(e);for(var t=this.parts(),r=e.parts(),n=0;n<t.length;n++)if(t[n]!=r[n])return!1;return!0},relativePathTo:function(e){return e=Path(e),this.isParentPathOf(e)?e.slice(this.size(),e.size()):void 0},del:function(e){if(this.isRoot())return!1;for(var t=e,r=0;r<this._parts.length-1;r++){var n=this._parts[r];if(!t.hasOwnProperty(n))return!1;t=t[n]}return delete t[this._parts[this._parts.length-1]]},withParentAndKeyDo:function(e,t,r){if(this.isRoot())return r(null,null);for(var n=e,i=0;i<this._parts.length-1;i++){var o=this._parts[i];if(!n.hasOwnProperty(o)||"object"!==_typeof(n[o])&&"function"!=typeof n[o]){if(!t)return r(null,o);n=n[o]={}}else n=n[o]}return r(n,this._parts[this._parts.length-1])},set:function(e,t,r){return this.withParentAndKeyDo(e,r,function(e,r){return e?e[r]=t:void 0})},defineProperty:function(e,t,r){return this.withParentAndKeyDo(e,r,function(e,r){return e?Object.defineProperty(e,r,t):void 0})},get:function(e,t){return(t?this._parts.slice(0,t):this._parts).reduce(function(e,t){return e?e[t]:e},e)},concat:function(e,t){return Path(this.parts().concat(Path(e,t).parts()))},toString:function(){return this.normalizePath()},serializeExpr:function(){return"lively.lang.Path("+inspect(this.parts())+")"},watch:function(e){if(e&&!this.isRoot()){var t=e.target,r=this.get(t,-1),n=this.parts().slice(-1)[0],i="propertyWatcher$"+n,o=r&&r.hasOwnProperty(i),a=e.uninstall,s=(e.haltWhenChanged,e.showStack),u=r.__lookupGetter__(n),c=r.__lookupSetter__(n);if(t&&n&&r)if(a){if(!o)return;delete r[n],r[n]=r[i],delete r[i];l="Watcher for "+r+"."+n+" uninstalled";show(l)}else if(o){l="Watcher for "+r+"."+n+" already installed";show(l)}else{if(u||c){l=r+'["'+n+'"] is a getter/setter, watching not support';return console.log(l),void("undefined"==typeof show&&show(l))}r[i]=r[n],r.__defineSetter__(n,function(t){var o=r[i];e.onSet&&e.onSet(t,o);var a=r+"."+n+" changed: "+o+" -> "+t;return s&&(a+="\n"+("undefined"!=typeof lively?lively.printStack():console.trace())),e.verbose&&(console.log(a),"undefined"!=typeof show&&show(a)),r[i]=t}),r.__defineGetter__(n,function(){return e.onGet&&e.onGet(r[i]),r[i]});var l="Watcher for "+r+"."+n+" installed";console.log(l),"undefined"!=typeof show&&show(l)}}},debugFunctionWrapper:function(e){var t=e.target,r=this.get(t,-1),n=this.parts().slice(-1)[0],i=e.uninstall,o=(void 0===e.haltWhenChanged||e.haltWhenChanged,e.showStack),a=r&&n&&r[n],s=a&&a.isDebugFunctionWrapper;if(t&&n&&a&&r){if(i){if(!s)return;r[n]=r[n].debugTargetFunction;c="Uninstalled debugFunctionWrapper for "+r+"."+n;return console.log(c),"undefined"!=typeof show&&show(c),void show(c)}if(s){c="debugFunctionWrapper for "+r+"."+n+" already installed";return console.log(c),void("undefined"!=typeof show&&show(c))}var u=r[n]=a.wrap(function(t){var i=Array.from(arguments);return o&&show(lively.printStack()),e.verbose&&show(n+" called"),i.shift().apply(r,i)});u.isDebugFunctionWrapper=!0,u.debugTargetFunction=a;var c="debugFunctionWrapper for "+r+"."+n+" installed";console.log(c),"undefined"!=typeof show&&show(c)}}});var graph=Object.freeze({clone:clone$2,without:without$1,hull:hull,subgraphReachableBy:subgraphReachableBy,invert:invert,sortByReference:sortByReference,reduce:reduce$1,random:random$1}),GLOBAL$2="undefined"!=typeof System?System.global:"undefined"!=typeof window?window:global,interval=Object.freeze({isInterval:isInterval,sort:sort$2,compare:compare,coalesce:coalesce,coalesceOverlapping:coalesceOverlapping,mergeOverlapping:mergeOverlapping,intervalsInRangeDo:intervalsInRangeDo,intervalsInbetween:intervalsInbetween,mapToMatchingIndexes:mapToMatchingIndexes}),arrayProjection=Object.freeze({create:create,toArray:toArray$4,originalToProjectedIndex:originalToProjectedIndex,projectedToOriginalIndex:projectedToOriginalIndex,transformToIncludeIndex:transformToIncludeIndex}),grid=Object.freeze({get:get$2,set:set$2,getRow:getRow,setRow:setRow,getCol:getCol,setCol:setCol,create:create$1,mapCreate:mapCreate,forEach:forEach$2,map:map$2,toObjects:toObjects,tableFromObjects:tableFromObjects}),detect$1=find,tree=Object.freeze({prewalk:prewalk,postwalk:postwalk,find:find,detect:detect$1,filter:filter$1,map:map$3,mapTree:mapTree}),isNode$1="undefined"!=typeof process&&process.versions&&process.versions.node,makeEmitter=isNode$1?function(e,t){if(e.on&&e.removeListener)return e;var r="undefined"!=typeof System?System._nodeRequire("events"):require("events");return Object.assign(e,r.EventEmitter.prototype),r.EventEmitter.call(e),t&&t.maxListenerLimit&&e.setMaxListeners(t.maxListenerLimit),e}:function(e){return e.on&&e.removeListener?e:(e.listeners={},e.on=function(t,r){r&&(e.listeners[t]||(e.listeners[t]=[]),e.listeners[t].push(r))},e.once=function(t,r){function n(){e.removeListener(t,n),r.apply(this,arguments)}r&&e.on(t,n)},e.removeListener=function(t,r){e.listeners[t]&&(e.listeners[t]=e.listeners[t].filter(function(e){return e!==r}))},e.removeAllListeners=function(t){e.listeners[t]&&(e.listeners[t]=[])},e.emit=function(){var t=Array.prototype.slice.call(arguments),r=t.shift(),n=e.listeners[r];n&&n.length&&n.forEach(function(e){try{e.apply(null,t)}catch(e){console.error("Error in event handler: %s",e.stack||String(e))}})},e)},events=Object.freeze({makeEmitter:makeEmitter}),OFFLINE="offline",ONLINE="online",messenger=Object.freeze({create:create$2}),isNodejs="undefined"!=typeof require&&"undefined"!=typeof process,WorkerSetup={loadDependenciesBrowser:function(e){var t="undefined"!=typeof self?self:this;importScripts.apply(t,e.scriptsToLoad||[])},loadDependenciesNodejs:function(e){(global.lively||(global.lively={})).lang=require(require("path").join(e.libLocation,"index"))},initBrowserGlobals:function(e){remoteWorker.send=function(e){postMessage(e)};var t="undefined"!=typeof self?self:this,r=t.Global=t;r.window=r,r.console=r.console||function(){var e={};return["log","error","warn"].forEach(function(t){e[t]=function(){for(var e=arguments[0],r=1;r<arguments.length;r++)e=e.replace("%s",arguments[r]);remoteWorker.send({type:t,message:["[",t.toUpperCase(),"] ",e].join("")})}}),e}()},initOnMessageHandler:function(e){function t(e){if(e=e.data.data?e.data:e,remoteWorker.messenger)remoteWorker.messenger.onMessage(e);else if("close"==e.action)return remoteWorker.send({type:"closed",workerReady:!1}),void remoteWorker.close()}remoteWorker.on?remoteWorker.on("message",t):remoteWorker.onmessage=t},initWorkerInterface:function initWorkerInterface(options){remoteWorker.callStringifiedFunction=function(stringifiedFunc,args,thenDo){var func;try{func=eval("("+stringifiedFunc+")")}catch(e){return void thenDo(new Error("Cannot create function from string: "+e.stack||e))}var usesCallback=func.length===args.length+1,whenDone=lively.lang.fun.once(function(e,t){remoteWorker.isBusy=!1,thenDo(e,t)});remoteWorker.isBusy=!0,usesCallback&&args.push(whenDone);try{var result=func.apply(remoteWorker,args.concat([whenDone]))}catch(e){return void whenDone(e,null)}usesCallback||whenDone(null,result)},remoteWorker.httpRequest=function(e){if(e.url){var t=new XMLHttpRequest,r=e.method||"GET";t.onreadystatechange=function(){4===t.readyState&&e.done&&e.done(t)},t.open(r,e.url),t.send()}else console.log("Error, httpRequest needs url")},remoteWorker.terminateIfNotBusyIn=function(e){setTimeout(function(){remoteWorker.isBusy?remoteWorker.terminateIfNotBusyIn(e):(remoteWorker.send({type:"closed",workerReady:!1}),remoteWorker.close())},e)}},initWorkerMessenger:function initWorkerMessenger(options){if(!options.useMessenger)return null;if(!lively.lang.messenger)throw new Error("worker.create requires messenger.js to be loaded!");if(!lively.lang.events)throw new Error("worker.create requires events.js to be loaded!");return remoteWorker.messenger=lively.lang.messenger.create({services:{remoteEval:function remoteEval(msg,messenger){var result;try{result=eval(msg.data.expr)}catch(e){result=e.stack||e}messenger.answer(msg,{result:String(result)})},run:function(e,t){var r=e.data.func,n=e.data.args;r?remoteWorker.callStringifiedFunction(r,n,function(r,n){t.answer(e,{error:r?String(r):null,result:n})}):t.answer(e,{error:"no funcString"})},close:function(e,t){t.answer(e,{status:"OK"}),remoteWorker.send({type:"closed",workerReady:!1}),remoteWorker.close()}},isOnline:function(){return!0},send:function(e,t){remoteWorker.send(e),t()},listen:function(e){e()},close:function(e){remoteWorker.send({type:"closed",workerReady:!1}),remoteWorker.close()}})}},BrowserWorker={create:function(e){if(!(e=e||{}).libLocation&&!e.scriptsToLoad){var t=document.querySelector('script[src$="worker.js"]');if(!t)throw new Error('Cannot find library path to start worker. Use worker.create({libLocation: "..."}) to explicitly define the path!');e.libLocation=t.src.replace(/worker.js$/,"")}var r="("+String(function(){self.onmessage=function(e){if("setup"!==e.data.action)throw new Error("expected setup to be first message but got "+JSON.stringify(e.data));var t=e.data.options||{};initBrowserGlobals(t),loadDependenciesBrowser(t),initOnMessageHandler(t),initWorkerInterface(t),initWorkerMessenger(t),postMessage({workerReady:!0})},__FUNCTIONDECLARATIONS__}).replace("__FUNCTIONDECLARATIONS__",[WorkerSetup.initBrowserGlobals,WorkerSetup.loadDependenciesBrowser,WorkerSetup.initOnMessageHandler,WorkerSetup.initWorkerInterface,WorkerSetup.initWorkerMessenger].join("\n"))+")();",n=new Worker(function(e){var t;try{t=new Blob([e],{type:"text/javascript"})}catch(r){window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,(t=new BlobBuilder).append(e),t=t.getBlob()}return("undefined"!=typeof webkitURL?webkitURL:URL).createObjectURL(t)}(r));return function(e,t){makeEmitter(t),e.scriptsToLoad||(e.scriptsToLoad=["base.js","events.js","object.js","collection.js","function.js","string.js","number.js","date.js","messenger.js","worker.js"].map(function(t){return e.libLocation+t}));var r=Object.keys(e).reduce(function(t,r){return"function"!=typeof e[r]&&(t[r]=e[r]),t},{});t.onmessage=function(e){void 0!==e.data.workerReady?(t.ready=!!e.data.workerReady,t.ready?t.emit("ready"):t.emit("close")):t.emit("message",e.data)},t.errors=[],t.onerror=function(e){console.error(e),t.errors.push(e),t.emit("error",e)},t.postMessage({action:"setup",options:r})}(e,n),n}},NodejsWorker={debug:!1,initCodeFileCreated:!1,create:function(e){e=e||{};var t,r=makeEmitter({ready:!1,errors:[],postMessage:function(e){t?r.ready?t.send(e):r.emit("error",new Error("nodejs worker process not ready or already closed")):r.emit("error",new Error("nodejs worker process not yet created"))}});return NodejsWorker.startWorker(e,function(e,n){if(e)return r.ready=!1,void r.emit("error",e);(t=n).on("message",function(e){NodejsWorker.debug&&console.log("[WORKER PARENT] got message:",e),r.emit("message",e)}),t.on("close",function(){console.log("[WORKER PARENT] worker closed"),r.emit("close")}),t.on("error",function(e){console.log("[WORKER PARENT] error ",e),r.errors.push(e),r.emit("error",e)}),r.ready=!0,r.emit("ready")}),r},workerSetupFunction:function(){var e=process;console.log("[WORKER] Starting init"),e.on("message",function(t){if("setup"!==t.action)throw new Error("expected setup to be first message but got "+JSON.stringify(t.data));e.removeAllListeners("message");var r=t.data.options||{};console.log("[WORKER] running setup with options",r),loadDependenciesNodejs(r),initOnMessageHandler(r),initWorkerInterface(r),initWorkerMessenger(r),e.send({workerReady:!0})}),__FUNCTIONDECLARATIONS__},ensureInitCodeFile:function(e,t,r){var n=require("path"),i=require("os"),o=require("fs"),a=n.join(i.tmpDir(),"lively-nodejs-workers/"),s=n.join(a,"nodejs-worker-init.js");NodejsWorker.initCodeFileCreated?o.exists(s,function(n){n?r(null,s):NodejsWorker.createWorkerCodeFile(e,s,t,r)}):NodejsWorker.createWorkerCodeFile(e,s,t,r)},createWorkerCodeFile:function(e,t,r,n){var i=require("path"),o=require("fs");(0,require("child_process").exec)("mkdir -p "+i.dirname(t),function(e,i,a){e?n(new Error(["[WORKER PARENT] Could not create worker temp dir:",i,a].join("\n"))):o.writeFile(t,r,function(e){NodejsWorker.debug&&console.log("worker code file %s created",t),NodejsWorker.initCodeFileCreated=!0,n(e,t)})})},startWorker:function(e,t){var r=require("util"),n=require("child_process").fork,i=String(NodejsWorker.workerSetupFunction).replace("__FUNCTIONDECLARATIONS__",[WorkerSetup.loadDependenciesNodejs,WorkerSetup.initOnMessageHandler,WorkerSetup.initWorkerInterface,WorkerSetup.initWorkerMessenger].join("\n")),o=r.format("(%s)();\n",i);NodejsWorker.ensureInitCodeFile(e,o,function(r,i){if(r)return t(r);var o=n(i,{});NodejsWorker.debug&&console.log("worker forked"),o.on("message",function(e){"pong"===e.action?console.log("[WORKER pong] ",e):"log"===e.action&&console.log("[Message from WORKER] ",e.data)}),o.once("message",function(e){NodejsWorker.debug&&console.log("worker setup done"),t(null,o,e)}),o.on("close",function(){NodejsWorker.debug&&console.log("[WORKER PARENT] worker closed")}),o.send({action:"setup",data:{options:e}}),global.WORKER=o})}},worker=Object.freeze({fork:fork,create:create$3}),GLOBAL="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:void 0,isNode="undefined"!=typeof process&&process.env&&"function"==typeof process.exit,globalInterfaceSpec=[{action:"installMethods",target:"Array",sources:["arr"],methods:["from","genN","range","withN"]},{action:"installMethods",target:"Array.prototype",sources:["arr"],methods:["all","any","batchify","clear","clone","collect","compact","delimWith","detect","doAndContinue","each","equals","filterByKey","findAll","first","flatten","forEachShowingProgress","grep","groupBy","groupByKey","histogram","include","inject","intersect","invoke","last","mapAsync","mapAsyncSeries","mask","max","min","mutableCompact","nestedDelay","partition","pluck","pushAll","pushAllAt","pushAt","pushIfNotIncluded","reMatches","reject","rejectByKey","remove","removeAt","replaceAt","rotate","shuffle","size","sortBy","sortByKey","sum","swap","toArray","toTuples","union","uniq","uniqBy","without","withoutAll","zip"],alias:[["select","filter"]]},{action:"installMethods",target:"Date",sources:["date"],methods:[]},{action:"installMethods",target:"Date.prototype",sources:["date"],methods:["equals","format","relativeTo"]},{action:"installMethods",target:"Function",sources:["fun"],methods:["fromString"]},{action:"installMethods",target:"Function.prototype",sources:["fun"],methods:["addToObject","argumentNames","asScript","asScriptOf","binds","curry","delay","functionNames","localFunctionNames","getOriginal","getVarMapping","logCalls","logCompletion","logErrors","qualifiedMethodName","setProperty","traceCalls","wrap"]},{action:"installMethods",target:"Number",sources:["num"],methods:[]},{action:"installMethods",target:"Number.prototype",sources:["num"],methods:["detent","randomSmallerInteger","roundTo","toDegrees","toRadians"]},{action:"installMethods",target:"Object",sources:["obj"],methods:["addScript","clone","deepCopy","extend","inherit","isArray","isBoolean","isElement","isEmpty","isFunction","isNumber","isObject","isRegExp","isString","isUndefined","merge","mergePropertyInHierarchy","values","valuesInPropertyHierarchy"]},{action:"installMethods",target:"Object.prototype",sources:["obj"],methods:[]},{action:"installMethods",target:"String.prototype",sources:["string"],methods:["camelize","capitalize","digitValue","empty","hashCode","include","pad","regExpEscape","startsWithVowel","succ","times","toArray","toQueryParams","truncate"]},{action:"installObject",target:"Numbers",source:"num",methods:["average","between","convertLength","humanReadableByteSize","median","normalRandom","parseLength","random","sort"]},{action:"installObject",target:"Properties",source:"properties",methods:["all","allOwnPropertiesOrFunctions","allProperties","any","forEachOwn","hash","nameFor","own","ownValues","values"]},{action:"installObject",target:"Strings",source:"string",methods:["camelCaseString","createDataURI","diff","format","formatFromArray","indent","lineIndexComputer","lines","md5","newUUID","nonEmptyLines","pad","paragraphs","peekLeft","peekRight","print","printNested","printTable","printTree","quote","reMatches","stringMatch","tableize","tokens","unescapeCharacterEntities","withDecimalPrecision"]},{action:"installObject",target:"Objects",source:"obj",methods:["asObject","equals","inspect","isMutableType","safeToString","shortPrintStringOf","typeStringOf"]},{action:"installObject",target:"Functions",source:"fun",methods:["all","compose","composeAsync","createQueue","debounce","debounceNamed","either","extractBody","flip","notYetImplemented","once","own","throttle","throttleNamed","timeToRun","timeToRunN","waitFor","workerWithCallbackQueue","wrapperChain"]},{action:"installObject",target:"Grid",source:"grid"},{action:"installObject",target:"Interval",source:"interval"},{action:"installObject",target:"lively.ArrayProjection",source:"arrayProjection"},{action:"installObject",target:"lively.Closure",source:"Closure"},{action:"installObject",target:"lively.Grouping",source:"Group"},{action:"installObject",target:"lively.PropertyPath",source:"Path"},{action:"installObject",target:"lively.Worker",source:"worker"},{action:"installObject",target:"lively.Class",source:"classHelper"}],livelyLang=createLivelyLangObject();exports.worker=worker,exports.messenger=messenger,exports.events=events,exports.tree=tree,exports.grid=grid,exports.arrayProjection=arrayProjection,exports.interval=interval,exports.graph=graph,exports.date=date,exports.properties=properties,exports.obj=obj,exports.arr=arr,exports.fun=fun,exports.num=num,exports.string=string,exports.Closure=Closure,exports.promise=promise,exports.Path=Path,exports.Group=Group,exports.livelyLang=livelyLang,exports.chain=chain$$1,exports.noConflict=noConflict,exports.installGlobals=installGlobals,exports.uninstallGlobals=uninstallGlobals}(this.lively.lang=this.lively.lang||{})}.call(GLOBAL),"undefined"!=typeof module&&module.exports&&(module.exports=GLOBAL.lively.lang)}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(e,t){"use strict";function r(e){if(void 0===e){if("undefined"==typeof System)return void 0!==o?o:o||(o={emitter:t.events.makeEmitter({},{maxListenerLimit:1e4}),notifications:[]});e=System}var r=e.get("@lively-env");r||e.set("@lively-env",e.newModule({options:{}}));var n=r.options;if(!n)throw new Error("@lively-env registered read-only");return n.emitter||Object.assign(n,{emitter:e["__lively.notifications_emitter"]||(e["__lively.notifications_emitter"]=t.events.makeEmitter({},{maxListenerLimit:1e4})),notifications:e["__lively.notifications_notifications"]||(e["__lively.notifications_notifications"]=[])}),{emitter:n.emitter,notifications:n.notifications}}function n(e,t){e.push(t),e.limit&&e.splice(0,e.length-e.limit)}function i(e){var r=e.type+" ".repeat(Math.max(0,32-e.type.length));console.log(r+" "+t.obj.inspect(e,{maxDepth:2}))}var o=void 0;e.subscribe=function(e,t,n){return r(n).emitter.on(e,t),t},e.subscribeOnce=function(e,t,n){return r(n).emitter.once(e,t),t},e.emit=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Date.now(),a=arguments[3],s=Object.assign({type:e,time:o},t),u=r(a),c=u.emitter,l=u.notifications;return c.emit(e,s),c.isLogging&&i(s),c.isRecording&&n(l,s),s},e.unsubscribe=function(e,t,n){return r(n).emitter.removeListener(e,t),t},e.unsubscribeAll=function(e,t){r(t).emitter.removeAllListeners(e)},e.startRecording=function(e){r(e).emitter.isRecording=!0},e.stopRecording=function(e){r(e).emitter.isRecording=!1},e.clearRecord=function(e){var t=r(e).notifications;t.splice(0,t.length)},e.getRecord=function(e){return r(e).notifications},e.startLogging=function(e){r(e).emitter.isLogging=!0},e.stopLogging=function(e){r(e).emitter.isLogging=!1}}(this.lively.notifications=this.lively.notifications||{},lively.lang),"undefined"!=typeof module&&module.exports&&(module.exports=e.lively.classes)}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;if(e.define){var t=e;delete e.define}!function(){var e=void 0;!function(){var e=void 0;(function(t,r){"function"==typeof e&&e.amd?e(["exports"],r):r(t.acorn=t.acorn||{})})(this,function(e){"use strict";function t(e,t){for(var r=65536,n=0;n<t.length;n+=2){if((r+=t[n])>e)return!1;if((r+=t[n+1])>=e)return!0}}function r(e,r){return e<65?36===e:e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&x.test(String.fromCharCode(e)):!1!==r&&t(e,k)))}function n(e,r){return e<48?36===e:e<58||!(e<65)&&(e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&w.test(String.fromCharCode(e)):!1!==r&&(t(e,k)||t(e,E)))))}function i(e,t){return new S(e,{beforeExpr:!0,binop:t})}function o(e,t){return void 0===t&&(t={}),t.keyword=e,C[e]=new S(e,t)}function a(e){return 10===e||13===e||8232===e||8233===e}function s(e){return"[object Array]"===Object.prototype.toString.call(e)}function u(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function c(e,t){for(var r=1,n=0;;){j.lastIndex=n;var i=j.exec(e);if(!(i&&i.index<t))return new P(r,t-n);++r,n=i.index+i[0].length}}function l(e){var t={};for(var r in I)t[r]=e&&u(e,r)?e[r]:I[r];if(t.ecmaVersion>=2015&&(t.ecmaVersion-=2009),null==t.allowReserved&&(t.allowReserved=t.ecmaVersion<5),s(t.onToken)){var n=t.onToken;t.onToken=function(e){return n.push(e)}}return s(t.onComment)&&(t.onComment=f(t,t.onComment)),t}function f(e,t){return function(r,n,i,o,a,s){var u={type:r?"Block":"Line",value:n,start:i,end:o};e.locations&&(u.loc=new T(this,a,s)),e.ranges&&(u.range=[i,o]),t.push(u)}}function p(e){return new RegExp("^("+e.replace(/ /g,"|")+")$")}function d(e,t,r,n){return e.type=t,e.end=r,this.options.locations&&(e.loc.end=n),this.options.ranges&&(e.range[1]=r),e}function h(e,t,r,n){try{return new RegExp(e,t)}catch(e){if(void 0!==r)throw e instanceof SyntaxError&&n.raise(r,"Error parsing regular expression: "+e.message),e}}function m(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}var v={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},y="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",g={5:y,6:y+" const class extends export import super"},b="-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",_="-------------------------------------------------------------------------------------------------------------------------------------------------",x=new RegExp("["+b+"]"),w=new RegExp("["+b+_+"]");b=_=null;var k=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541],E=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239],S=function(e,t){void 0===t&&(t={}),this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=t.binop||null,this.updateContext=null},A={beforeExpr:!0},D={startsExpr:!0},C={},F={num:new S("num",D),regexp:new S("regexp",D),string:new S("string",D),name:new S("name",D),eof:new S("eof"),bracketL:new S("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new S("]"),braceL:new S("{",{beforeExpr:!0,startsExpr:!0}),braceR:new S("}"),parenL:new S("(",{beforeExpr:!0,startsExpr:!0}),parenR:new S(")"),comma:new S(",",A),semi:new S(";",A),colon:new S(":",A),dot:new S("."),question:new S("?",A),arrow:new S("=>",A),template:new S("template"),ellipsis:new S("...",A),backQuote:new S("`",D),dollarBraceL:new S("${",{beforeExpr:!0,startsExpr:!0}),eq:new S("=",{beforeExpr:!0,isAssign:!0}),assign:new S("_=",{beforeExpr:!0,isAssign:!0}),incDec:new S("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new S("prefix",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:i("||",1),logicalAND:i("&&",2),bitwiseOR:i("|",3),bitwiseXOR:i("^",4),bitwiseAND:i("&",5),equality:i("==/!=",6),relational:i("</>",7),bitShift:i("<</>>",8),plusMin:new S("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:i("%",10),star:i("*",10),slash:i("/",10),starstar:new S("**",{beforeExpr:!0}),_break:o("break"),_case:o("case",A),_catch:o("catch"),_continue:o("continue"),_debugger:o("debugger"),_default:o("default",A),_do:o("do",{isLoop:!0,beforeExpr:!0}),_else:o("else",A),_finally:o("finally"),_for:o("for",{isLoop:!0}),_function:o("function",D),_if:o("if"),_return:o("return",A),_switch:o("switch"),_throw:o("throw",A),_try:o("try"),_var:o("var"),_const:o("const"),_while:o("while",{isLoop:!0}),_with:o("with"),_new:o("new",{beforeExpr:!0,startsExpr:!0}),_this:o("this",D),_super:o("super",D),_class:o("class"),_extends:o("extends",A),_export:o("export"),_import:o("import"),_null:o("null",D),_true:o("true",D),_false:o("false",D),_in:o("in",{beforeExpr:!0,binop:7}),_instanceof:o("instanceof",{beforeExpr:!0,binop:7}),_typeof:o("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:o("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:o("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},O=/\r\n?|\n|\u2028|\u2029/,j=new RegExp(O.source,"g"),R=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,B=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,P=function(e,t){this.line=e,this.column=t};P.prototype.offset=function(e){return new P(this.line,this.column+e)};var T=function(e,t,r){this.start=t,this.end=r,null!==e.sourceFile&&(this.source=e.sourceFile)},I={ecmaVersion:7,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1,plugins:{}},L={},N=function(e,t,r){this.options=e=l(e),this.sourceFile=e.sourceFile,this.keywords=p(g[e.ecmaVersion>=6?6:5]);var n="";if(!e.allowReserved){for(var i=e.ecmaVersion;!(n=v[i]);i--);"module"==e.sourceType&&(n+=" await")}this.reservedWords=p(n);var o=(n?n+" ":"")+v.strict;this.reservedWordsStrict=p(o),this.reservedWordsStrictBind=p(o+" "+v.strictBind),this.input=String(t),this.containsEsc=!1,this.loadPlugins(e.plugins),r?(this.pos=r,this.lineStart=this.input.lastIndexOf("\n",r-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(O).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=F.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule="module"===e.sourceType,this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.inFunction=this.inGenerator=this.inAsync=!1,this.yieldPos=this.awaitPos=0,this.labels=[],0===this.pos&&e.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2)};N.prototype.isKeyword=function(e){return this.keywords.test(e)},N.prototype.isReservedWord=function(e){return this.reservedWords.test(e)},N.prototype.extend=function(e,t){this[e]=t(this[e])},N.prototype.loadPlugins=function(e){var t=this;for(var r in e){var n=L[r];if(!n)throw new Error("Plugin '"+r+"' not found");n(t,e[r])}},N.prototype.parse=function(){var e=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(e)};var M=N.prototype,q=/^(?:'((?:[^\']|\.)*)'|"((?:[^\"]|\.)*)"|;)/;M.strictDirective=function(e){for(var t=this;;){B.lastIndex=e,e+=B.exec(t.input)[0].length;var r=q.exec(t.input.slice(e));if(!r)return!1;if("use strict"==(r[1]||r[2]))return!0;e+=r[0].length}},M.eat=function(e){return this.type===e&&(this.next(),!0)},M.isContextual=function(e){return this.type===F.name&&this.value===e},M.eatContextual=function(e){return this.value===e&&this.eat(F.name)},M.expectContextual=function(e){this.eatContextual(e)||this.unexpected()},M.canInsertSemicolon=function(){return this.type===F.eof||this.type===F.braceR||O.test(this.input.slice(this.lastTokEnd,this.start))},M.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},M.semicolon=function(){this.eat(F.semi)||this.insertSemicolon()||this.unexpected()},M.afterTrailingComma=function(e,t){if(this.type==e)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),t||this.next(),!0},M.expect=function(e){this.eat(e)||this.unexpected()},M.unexpected=function(e){this.raise(null!=e?e:this.start,"Unexpected token")};var $=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=-1};M.checkPatternErrors=function(e,t){if(e){e.trailingComma>-1&&this.raiseRecoverable(e.trailingComma,"Comma is not permitted after the rest element");var r=t?e.parenthesizedAssign:e.parenthesizedBind;r>-1&&this.raiseRecoverable(r,"Parenthesized pattern")}},M.checkExpressionErrors=function(e,t){var r=e?e.shorthandAssign:-1;if(!t)return r>=0;r>-1&&this.raise(r,"Shorthand property assignments are valid only in destructuring patterns")},M.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},M.isSimpleAssignTarget=function(e){return"ParenthesizedExpression"===e.type?this.isSimpleAssignTarget(e.expression):"Identifier"===e.type||"MemberExpression"===e.type};var W=N.prototype;W.parseTopLevel=function(e){var t=this,r={};for(e.body||(e.body=[]);this.type!==F.eof;){var n=t.parseStatement(!0,!0,r);e.body.push(n)}return this.next(),this.options.ecmaVersion>=6&&(e.sourceType=this.options.sourceType),this.finishNode(e,"Program")};var U={kind:"loop"},z={kind:"switch"};W.isLet=function(){if(this.type!==F.name||this.options.ecmaVersion<6||"let"!=this.value)return!1;B.lastIndex=this.pos;var e=B.exec(this.input),t=this.pos+e[0].length,i=this.input.charCodeAt(t);if(91===i||123==i)return!0;if(r(i,!0)){for(var o=t+1;n(this.input.charCodeAt(o),!0);++o);var a=this.input.slice(t,o);if(!this.isKeyword(a))return!0}return!1},W.isAsyncFunction=function(){if(this.type!==F.name||this.options.ecmaVersion<8||"async"!=this.value)return!1;B.lastIndex=this.pos;var e=B.exec(this.input),t=this.pos+e[0].length;return!(O.test(this.input.slice(this.pos,t))||"function"!==this.input.slice(t,t+8)||t+8!=this.input.length&&n(this.input.charAt(t+8)))},W.parseStatement=function(e,t,r){var n,i=this.type,o=this.startNode();switch(this.isLet()&&(i=F._var,n="let"),i){case F._break:case F._continue:return this.parseBreakContinueStatement(o,i.keyword);case F._debugger:return this.parseDebuggerStatement(o);case F._do:return this.parseDoStatement(o);case F._for:return this.parseForStatement(o);case F._function:return!e&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(o,!1);case F._class:return e||this.unexpected(),this.parseClass(o,!0);case F._if:return this.parseIfStatement(o);case F._return:return this.parseReturnStatement(o);case F._switch:return this.parseSwitchStatement(o);case F._throw:return this.parseThrowStatement(o);case F._try:return this.parseTryStatement(o);case F._const:case F._var:return n=n||this.value,e||"var"==n||this.unexpected(),this.parseVarStatement(o,n);case F._while:return this.parseWhileStatement(o);case F._with:return this.parseWithStatement(o);case F.braceL:return this.parseBlock();case F.semi:return this.parseEmptyStatement(o);case F._export:case F._import:return this.options.allowImportExportEverywhere||(t||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),i===F._import?this.parseImport(o):this.parseExport(o,r);default:if(this.isAsyncFunction()&&e)return this.next(),this.parseFunctionStatement(o,!0);var a=this.value,s=this.parseExpression();return i===F.name&&"Identifier"===s.type&&this.eat(F.colon)?this.parseLabeledStatement(o,a,s):this.parseExpressionStatement(o,s)}},W.parseBreakContinueStatement=function(e,t){var r=this,n="break"==t;this.next(),this.eat(F.semi)||this.insertSemicolon()?e.label=null:this.type!==F.name?this.unexpected():(e.label=this.parseIdent(),this.semicolon());for(var i=0;i<this.labels.length;++i){var o=r.labels[i];if(null==e.label||o.name===e.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(e.label&&n)break}}return i===this.labels.length&&this.raise(e.start,"Unsyntactic "+t),this.finishNode(e,n?"BreakStatement":"ContinueStatement")},W.parseDebuggerStatement=function(e){return this.next(),this.semicolon(),this.finishNode(e,"DebuggerStatement")},W.parseDoStatement=function(e){return this.next(),this.labels.push(U),e.body=this.parseStatement(!1),this.labels.pop(),this.expect(F._while),e.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(F.semi):this.semicolon(),this.finishNode(e,"DoWhileStatement")},W.parseForStatement=function(e){if(this.next(),this.labels.push(U),this.expect(F.parenL),this.type===F.semi)return this.parseFor(e,null);var t=this.isLet();if(this.type===F._var||this.type===F._const||t){var r=this.startNode(),n=t?"let":this.value;return this.next(),this.parseVar(r,!0,n),this.finishNode(r,"VariableDeclaration"),!(this.type===F._in||this.options.ecmaVersion>=6&&this.isContextual("of"))||1!==r.declarations.length||"var"!==n&&r.declarations[0].init?this.parseFor(e,r):this.parseForIn(e,r)}var i=new $,o=this.parseExpression(!0,i);return this.type===F._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.toAssignable(o),this.checkLVal(o),this.checkPatternErrors(i,!0),this.parseForIn(e,o)):(this.checkExpressionErrors(i,!0),this.parseFor(e,o))},W.parseFunctionStatement=function(e,t){return this.next(),this.parseFunction(e,!0,!1,t)},W.isFunction=function(){return this.type===F._function||this.isAsyncFunction()},W.parseIfStatement=function(e){return this.next(),e.test=this.parseParenExpression(),e.consequent=this.parseStatement(!this.strict&&this.isFunction()),e.alternate=this.eat(F._else)?this.parseStatement(!this.strict&&this.isFunction()):null,this.finishNode(e,"IfStatement")},W.parseReturnStatement=function(e){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(F.semi)||this.insertSemicolon()?e.argument=null:(e.argument=this.parseExpression(),this.semicolon()),this.finishNode(e,"ReturnStatement")},W.parseSwitchStatement=function(e){var t=this;this.next(),e.discriminant=this.parseParenExpression(),e.cases=[],this.expect(F.braceL),this.labels.push(z);for(var r,n=!1;this.type!=F.braceR;)if(t.type===F._case||t.type===F._default){var i=t.type===F._case;r&&t.finishNode(r,"SwitchCase"),e.cases.push(r=t.startNode()),r.consequent=[],t.next(),i?r.test=t.parseExpression():(n&&t.raiseRecoverable(t.lastTokStart,"Multiple default clauses"),n=!0,r.test=null),t.expect(F.colon)}else r||t.unexpected(),r.consequent.push(t.parseStatement(!0));return r&&this.finishNode(r,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(e,"SwitchStatement")},W.parseThrowStatement=function(e){return this.next(),O.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),e.argument=this.parseExpression(),this.semicolon(),this.finishNode(e,"ThrowStatement")};var V=[];W.parseTryStatement=function(e){if(this.next(),e.block=this.parseBlock(),e.handler=null,this.type===F._catch){var t=this.startNode();this.next(),this.expect(F.parenL),t.param=this.parseBindingAtom(),this.checkLVal(t.param,!0),this.expect(F.parenR),t.body=this.parseBlock(),e.handler=this.finishNode(t,"CatchClause")}return e.finalizer=this.eat(F._finally)?this.parseBlock():null,e.handler||e.finalizer||this.raise(e.start,"Missing catch or finally clause"),this.finishNode(e,"TryStatement")},W.parseVarStatement=function(e,t){return this.next(),this.parseVar(e,!1,t),this.semicolon(),this.finishNode(e,"VariableDeclaration")},W.parseWhileStatement=function(e){return this.next(),e.test=this.parseParenExpression(),this.labels.push(U),e.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(e,"WhileStatement")},W.parseWithStatement=function(e){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),e.object=this.parseParenExpression(),e.body=this.parseStatement(!1),this.finishNode(e,"WithStatement")},W.parseEmptyStatement=function(e){return this.next(),this.finishNode(e,"EmptyStatement")},W.parseLabeledStatement=function(e,t,r){for(var n=this,i=0;i<this.labels.length;++i)n.labels[i].name===t&&n.raise(r.start,"Label '"+t+"' is already declared");for(var o=this.type.isLoop?"loop":this.type===F._switch?"switch":null,a=this.labels.length-1;a>=0;a--){var s=n.labels[a];if(s.statementStart!=e.start)break;s.statementStart=n.start,s.kind=o}return this.labels.push({name:t,kind:o,statementStart:this.start}),e.body=this.parseStatement(!0),("ClassDeclaration"==e.body.type||"VariableDeclaration"==e.body.type&&(this.strict||"var"!=e.body.kind)||"FunctionDeclaration"==e.body.type&&(this.strict||e.body.generator))&&this.raiseRecoverable(e.body.start,"Invalid labeled declaration"),this.labels.pop(),e.label=r,this.finishNode(e,"LabeledStatement")},W.parseExpressionStatement=function(e,t){return e.expression=t,this.semicolon(),this.finishNode(e,"ExpressionStatement")},W.parseBlock=function(){var e=this,t=this.startNode();for(t.body=[],this.expect(F.braceL);!this.eat(F.braceR);){var r=e.parseStatement(!0);t.body.push(r)}return this.finishNode(t,"BlockStatement")},W.parseFor=function(e,t){return e.init=t,this.expect(F.semi),e.test=this.type===F.semi?null:this.parseExpression(),this.expect(F.semi),e.update=this.type===F.parenR?null:this.parseExpression(),this.expect(F.parenR),e.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(e,"ForStatement")},W.parseForIn=function(e,t){var r=this.type===F._in?"ForInStatement":"ForOfStatement";return this.next(),e.left=t,e.right=this.parseExpression(),this.expect(F.parenR),e.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(e,r)},W.parseVar=function(e,t,r){var n=this;for(e.declarations=[],e.kind=r;;){var i=n.startNode();if(n.parseVarId(i),n.eat(F.eq)?i.init=n.parseMaybeAssign(t):"const"!==r||n.type===F._in||n.options.ecmaVersion>=6&&n.isContextual("of")?"Identifier"==i.id.type||t&&(n.type===F._in||n.isContextual("of"))?i.init=null:n.raise(n.lastTokEnd,"Complex binding patterns require an initialization value"):n.unexpected(),e.declarations.push(n.finishNode(i,"VariableDeclarator")),!n.eat(F.comma))break}return e},W.parseVarId=function(e){e.id=this.parseBindingAtom(),this.checkLVal(e.id,!0)},W.parseFunction=function(e,t,r,n){this.initFunction(e),this.options.ecmaVersion>=6&&!n&&(e.generator=this.eat(F.star)),this.options.ecmaVersion>=8&&(e.async=!!n),null==t&&(t=this.type==F.name),t&&(e.id=this.parseIdent());var i=this.inGenerator,o=this.inAsync,a=this.yieldPos,s=this.awaitPos,u=this.inFunction;return this.inGenerator=e.generator,this.inAsync=e.async,this.yieldPos=0,this.awaitPos=0,this.inFunction=!0,t||this.type!==F.name||(e.id=this.parseIdent()),this.parseFunctionParams(e),this.parseFunctionBody(e,r),this.inGenerator=i,this.inAsync=o,this.yieldPos=a,this.awaitPos=s,this.inFunction=u,this.finishNode(e,t?"FunctionDeclaration":"FunctionExpression")},W.parseFunctionParams=function(e){this.expect(F.parenL),e.params=this.parseBindingList(F.parenR,!1,this.options.ecmaVersion>=8,!0),this.checkYieldAwaitInDefaultParams()},W.parseClass=function(e,t){var r=this;this.next(),null==t&&(t=this.type===F.name),this.parseClassId(e,t),this.parseClassSuper(e);var n=this.startNode(),i=!1;for(n.body=[],this.expect(F.braceL);!this.eat(F.braceR);)if(!r.eat(F.semi)){var o=r.startNode(),a=r.eat(F.star),s=!1,u=r.type===F.name&&"static"===r.value;r.parsePropertyName(o),o.static=u&&r.type!==F.parenL,o.static&&(a&&r.unexpected(),a=r.eat(F.star),r.parsePropertyName(o)),r.options.ecmaVersion>=8&&!a&&!o.computed&&"Identifier"===o.key.type&&"async"===o.key.name&&r.type!==F.parenL&&!r.canInsertSemicolon()&&(s=!0,r.parsePropertyName(o)),o.kind="method";var c=!1;if(!o.computed){var l=o.key;a||s||"Identifier"!==l.type||r.type===F.parenL||"get"!==l.name&&"set"!==l.name||(c=!0,o.kind=l.name,l=r.parsePropertyName(o)),!o.static&&("Identifier"===l.type&&"constructor"===l.name||"Literal"===l.type&&"constructor"===l.value)&&(i&&r.raise(l.start,"Duplicate constructor in the same class"),c&&r.raise(l.start,"Constructor can't have get/set modifier"),a&&r.raise(l.start,"Constructor can't be a generator"),s&&r.raise(l.start,"Constructor can't be an async method"),o.kind="constructor",i=!0)}if(r.parseClassMethod(n,o,a,s),c){var f="get"===o.kind?0:1;if(o.value.params.length!==f){var p=o.value.start;"get"===o.kind?r.raiseRecoverable(p,"getter should have no params"):r.raiseRecoverable(p,"setter should have exactly one param")}else"set"===o.kind&&"RestElement"===o.value.params[0].type&&r.raiseRecoverable(o.value.params[0].start,"Setter cannot use rest params")}}return e.body=this.finishNode(n,"ClassBody"),this.finishNode(e,t?"ClassDeclaration":"ClassExpression")},W.parseClassMethod=function(e,t,r,n){t.value=this.parseMethod(r,n),e.body.push(this.finishNode(t,"MethodDefinition"))},W.parseClassId=function(e,t){e.id=this.type===F.name?this.parseIdent():t?this.unexpected():null},W.parseClassSuper=function(e){e.superClass=this.eat(F._extends)?this.parseExprSubscripts():null},W.parseExport=function(e,t){var r=this;if(this.next(),this.eat(F.star))return this.expectContextual("from"),e.source=this.type===F.string?this.parseExprAtom():this.unexpected(),this.semicolon(),this.finishNode(e,"ExportAllDeclaration");if(this.eat(F._default)){this.checkExport(t,"default",this.lastTokStart);var n;if(this.type===F._function||(n=this.isAsyncFunction())){var i=this.startNode();this.next(),n&&this.next(),e.declaration=this.parseFunction(i,null,!1,n)}else if(this.type===F._class){var o=this.startNode();e.declaration=this.parseClass(o,null)}else e.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(e,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())e.declaration=this.parseStatement(!0),"VariableDeclaration"===e.declaration.type?this.checkVariableExport(t,e.declaration.declarations):this.checkExport(t,e.declaration.id.name,e.declaration.id.start),e.specifiers=[],e.source=null;else{if(e.declaration=null,e.specifiers=this.parseExportSpecifiers(t),this.eatContextual("from"))e.source=this.type===F.string?this.parseExprAtom():this.unexpected();else{for(var a=0;a<e.specifiers.length;a++)(r.keywords.test(e.specifiers[a].local.name)||r.reservedWords.test(e.specifiers[a].local.name))&&r.unexpected(e.specifiers[a].local.start);e.source=null}this.semicolon()}return this.finishNode(e,"ExportNamedDeclaration")},W.checkExport=function(e,t,r){e&&(Object.prototype.hasOwnProperty.call(e,t)&&this.raiseRecoverable(r,"Duplicate export '"+t+"'"),e[t]=!0)},W.checkPatternExport=function(e,t){var r=this,n=t.type;if("Identifier"==n)this.checkExport(e,t.name,t.start);else if("ObjectPattern"==n)for(var i=0;i<t.properties.length;++i)r.checkPatternExport(e,t.properties[i].value);else if("ArrayPattern"==n)for(var o=0;o<t.elements.length;++o){var a=t.elements[o];a&&r.checkPatternExport(e,a)}else"AssignmentPattern"==n?this.checkPatternExport(e,t.left):"ParenthesizedExpression"==n&&this.checkPatternExport(e,t.expression)},W.checkVariableExport=function(e,t){var r=this;if(e)for(var n=0;n<t.length;n++)r.checkPatternExport(e,t[n].id)},W.shouldParseExportStatement=function(){return"var"===this.type.keyword||"const"===this.type.keyword||"class"===this.type.keyword||"function"===this.type.keyword||this.isLet()||this.isAsyncFunction()},W.parseExportSpecifiers=function(e){var t=this,r=[],n=!0;for(this.expect(F.braceL);!this.eat(F.braceR);){if(n)n=!1;else if(t.expect(F.comma),t.afterTrailingComma(F.braceR))break;var i=t.startNode();i.local=t.parseIdent(!0),i.exported=t.eatContextual("as")?t.parseIdent(!0):i.local,t.checkExport(e,i.exported.name,i.exported.start),r.push(t.finishNode(i,"ExportSpecifier"))}return r},W.parseImport=function(e){return this.next(),this.type===F.string?(e.specifiers=V,e.source=this.parseExprAtom()):(e.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),e.source=this.type===F.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(e,"ImportDeclaration")},W.parseImportSpecifiers=function(){var e=this,t=[],r=!0;if(this.type===F.name){var n=this.startNode();if(n.local=this.parseIdent(),this.checkLVal(n.local,!0),t.push(this.finishNode(n,"ImportDefaultSpecifier")),!this.eat(F.comma))return t}if(this.type===F.star){var i=this.startNode();return this.next(),this.expectContextual("as"),i.local=this.parseIdent(),this.checkLVal(i.local,!0),t.push(this.finishNode(i,"ImportNamespaceSpecifier")),t}for(this.expect(F.braceL);!this.eat(F.braceR);){if(r)r=!1;else if(e.expect(F.comma),e.afterTrailingComma(F.braceR))break;var o=e.startNode();o.imported=e.parseIdent(!0),e.eatContextual("as")?o.local=e.parseIdent():(o.local=o.imported,e.isKeyword(o.local.name)&&e.unexpected(o.local.start),e.reservedWordsStrict.test(o.local.name)&&e.raiseRecoverable(o.local.start,"The keyword '"+o.local.name+"' is reserved")),e.checkLVal(o.local,!0),t.push(e.finishNode(o,"ImportSpecifier"))}return t};var G=N.prototype;G.toAssignable=function(e,t){var r=this;if(this.options.ecmaVersion>=6&&e)switch(e.type){case"Identifier":this.inAsync&&"await"===e.name&&this.raise(e.start,"Can not use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":break;case"ObjectExpression":e.type="ObjectPattern";for(var n=0;n<e.properties.length;n++){var i=e.properties[n];"init"!==i.kind&&r.raise(i.key.start,"Object pattern can't contain getter or setter"),r.toAssignable(i.value,t)}break;case"ArrayExpression":e.type="ArrayPattern",this.toAssignableList(e.elements,t);break;case"AssignmentExpression":if("="!==e.operator){this.raise(e.left.end,"Only '=' operator can be used for specifying default value.");break}e.type="AssignmentPattern",delete e.operator,this.toAssignable(e.left,t);case"AssignmentPattern":break;case"ParenthesizedExpression":e.expression=this.toAssignable(e.expression,t);break;case"MemberExpression":if(!t)break;default:this.raise(e.start,"Assigning to rvalue")}return e},G.toAssignableList=function(e,t){var r=this,n=e.length;if(n){var i=e[n-1];if(i&&"RestElement"==i.type)--n;else if(i&&"SpreadElement"==i.type){i.type="RestElement";var o=i.argument;this.toAssignable(o,t),"Identifier"!==o.type&&"MemberExpression"!==o.type&&"ArrayPattern"!==o.type&&this.unexpected(o.start),--n}t&&i&&"RestElement"===i.type&&"Identifier"!==i.argument.type&&this.unexpected(i.argument.start)}for(var a=0;a<n;a++){var s=e[a];s&&r.toAssignable(s,t)}return e},G.parseSpread=function(e){var t=this.startNode();return this.next(),t.argument=this.parseMaybeAssign(!1,e),this.finishNode(t,"SpreadElement")},G.parseRest=function(e){var t=this.startNode();return this.next(),t.argument=e?this.type===F.name?this.parseIdent():this.unexpected():this.type===F.name||this.type===F.bracketL?this.parseBindingAtom():this.unexpected(),this.finishNode(t,"RestElement")},G.parseBindingAtom=function(){if(this.options.ecmaVersion<6)return this.parseIdent();switch(this.type){case F.name:return this.parseIdent();case F.bracketL:var e=this.startNode();return this.next(),e.elements=this.parseBindingList(F.bracketR,!0,!0),this.finishNode(e,"ArrayPattern");case F.braceL:return this.parseObj(!0);default:this.unexpected()}},G.parseBindingList=function(e,t,r,n){for(var i=this,o=[],a=!0;!this.eat(e);)if(a?a=!1:i.expect(F.comma),t&&i.type===F.comma)o.push(null);else{if(r&&i.afterTrailingComma(e))break;if(i.type===F.ellipsis){var s=i.parseRest(n);i.parseBindingListItem(s),o.push(s),i.type===F.comma&&i.raise(i.start,"Comma is not permitted after the rest element"),i.expect(e);break}var u=i.parseMaybeDefault(i.start,i.startLoc);i.parseBindingListItem(u),o.push(u)}return o},G.parseBindingListItem=function(e){return e},G.parseMaybeDefault=function(e,t,r){if(r=r||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(F.eq))return r;var n=this.startNodeAt(e,t);return n.left=r,n.right=this.parseMaybeAssign(),this.finishNode(n,"AssignmentPattern")},G.checkLVal=function(e,t,r){var n=this;switch(e.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(e.name)&&this.raiseRecoverable(e.start,(t?"Binding ":"Assigning to ")+e.name+" in strict mode"),r&&(u(r,e.name)&&this.raiseRecoverable(e.start,"Argument name clash"),r[e.name]=!0);break;case"MemberExpression":t&&this.raiseRecoverable(e.start,(t?"Binding":"Assigning to")+" member expression");break;case"ObjectPattern":for(var i=0;i<e.properties.length;i++)n.checkLVal(e.properties[i].value,t,r);break;case"ArrayPattern":for(var o=0;o<e.elements.length;o++){var a=e.elements[o];a&&n.checkLVal(a,t,r)}break;case"AssignmentPattern":this.checkLVal(e.left,t,r);break;case"RestElement":this.checkLVal(e.argument,t,r);break;case"ParenthesizedExpression":this.checkLVal(e.expression,t,r);break;default:this.raise(e.start,(t?"Binding":"Assigning to")+" rvalue")}};var H=N.prototype;H.checkPropClash=function(e,t){if(!(this.options.ecmaVersion>=6&&(e.computed||e.method||e.shorthand))){var r,n=e.key;switch(n.type){case"Identifier":r=n.name;break;case"Literal":r=String(n.value);break;default:return}var i=e.kind;if(this.options.ecmaVersion>=6)"__proto__"===r&&"init"===i&&(t.proto&&this.raiseRecoverable(n.start,"Redefinition of __proto__ property"),t.proto=!0);else{var o=t[r="$"+r];if(o){var a="init"!==i;(!this.strict&&!a||!o[i])&&a^o.init||this.raiseRecoverable(n.start,"Redefinition of property")}else o=t[r]={init:!1,get:!1,set:!1};o[i]=!0}}},H.parseExpression=function(e,t){var r=this,n=this.start,i=this.startLoc,o=this.parseMaybeAssign(e,t);if(this.type===F.comma){var a=this.startNodeAt(n,i);for(a.expressions=[o];this.eat(F.comma);)a.expressions.push(r.parseMaybeAssign(e,t));return this.finishNode(a,"SequenceExpression")}return o},H.parseMaybeAssign=function(e,t,r){if(this.inGenerator&&this.isContextual("yield"))return this.parseYield();var n=!1,i=-1;t?(i=t.parenthesizedAssign,t.parenthesizedAssign=-1):(t=new $,n=!0);var o=this.start,a=this.startLoc;this.type!=F.parenL&&this.type!=F.name||(this.potentialArrowAt=this.start);var s=this.parseMaybeConditional(e,t);if(r&&(s=r.call(this,s,o,a)),this.type.isAssign){this.checkPatternErrors(t,!0),n||$.call(t);var u=this.startNodeAt(o,a);return u.operator=this.value,u.left=this.type===F.eq?this.toAssignable(s):s,t.shorthandAssign=-1,this.checkLVal(s),this.next(),u.right=this.parseMaybeAssign(e),this.finishNode(u,"AssignmentExpression")}return n&&this.checkExpressionErrors(t,!0),i>-1&&(t.parenthesizedAssign=i),s},H.parseMaybeConditional=function(e,t){var r=this.start,n=this.startLoc,i=this.parseExprOps(e,t);if(this.checkExpressionErrors(t))return i;if(this.eat(F.question)){var o=this.startNodeAt(r,n);return o.test=i,o.consequent=this.parseMaybeAssign(),this.expect(F.colon),o.alternate=this.parseMaybeAssign(e),this.finishNode(o,"ConditionalExpression")}return i},H.parseExprOps=function(e,t){var r=this.start,n=this.startLoc,i=this.parseMaybeUnary(t,!1);return this.checkExpressionErrors(t)?i:this.parseExprOp(i,r,n,-1,e)},H.parseExprOp=function(e,t,r,n,i){var o=this.type.binop;if(null!=o&&(!i||this.type!==F._in)&&o>n){var a=this.type===F.logicalOR||this.type===F.logicalAND,s=this.value;this.next();var u=this.start,c=this.startLoc,l=this.parseExprOp(this.parseMaybeUnary(null,!1),u,c,o,i),f=this.buildBinary(t,r,e,l,s,a);return this.parseExprOp(f,t,r,n,i)}return e},H.buildBinary=function(e,t,r,n,i,o){var a=this.startNodeAt(e,t);return a.left=r,a.operator=i,a.right=n,this.finishNode(a,o?"LogicalExpression":"BinaryExpression")},H.parseMaybeUnary=function(e,t){var r,n=this,i=this.start,o=this.startLoc;if(this.inAsync&&this.isContextual("await"))r=this.parseAwait(e),t=!0;else if(this.type.prefix){var a=this.startNode(),s=this.type===F.incDec;a.operator=this.value,a.prefix=!0,this.next(),a.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(e,!0),s?this.checkLVal(a.argument):this.strict&&"delete"===a.operator&&"Identifier"===a.argument.type?this.raiseRecoverable(a.start,"Deleting local variable in strict mode"):t=!0,r=this.finishNode(a,s?"UpdateExpression":"UnaryExpression")}else{if(r=this.parseExprSubscripts(e),this.checkExpressionErrors(e))return r;for(;this.type.postfix&&!this.canInsertSemicolon();){var u=n.startNodeAt(i,o);u.operator=n.value,u.prefix=!1,u.argument=r,n.checkLVal(r),n.next(),r=n.finishNode(u,"UpdateExpression")}}return!t&&this.eat(F.starstar)?this.buildBinary(i,o,r,this.parseMaybeUnary(null,!1),"**",!1):r},H.parseExprSubscripts=function(e){var t=this.start,r=this.startLoc,n=this.parseExprAtom(e),i="ArrowFunctionExpression"===n.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd);if(this.checkExpressionErrors(e)||i)return n;var o=this.parseSubscripts(n,t,r);return e&&"MemberExpression"===o.type&&(e.parenthesizedAssign>=o.start&&(e.parenthesizedAssign=-1),e.parenthesizedBind>=o.start&&(e.parenthesizedBind=-1)),o},H.parseSubscripts=function(e,t,r,n){for(var i,o=this,a=this.options.ecmaVersion>=8&&"Identifier"===e.type&&"async"===e.name&&this.lastTokEnd==e.end&&!this.canInsertSemicolon();;)if((i=o.eat(F.bracketL))||o.eat(F.dot)){var s=o.startNodeAt(t,r);s.object=e,s.property=i?o.parseExpression():o.parseIdent(!0),s.computed=!!i,i&&o.expect(F.bracketR),e=o.finishNode(s,"MemberExpression")}else if(!n&&o.eat(F.parenL)){var u=new $,c=o.yieldPos,l=o.awaitPos;o.yieldPos=0,o.awaitPos=0;var f=o.parseExprList(F.parenR,o.options.ecmaVersion>=8,!1,u);if(a&&!o.canInsertSemicolon()&&o.eat(F.arrow))return o.checkPatternErrors(u,!1),o.checkYieldAwaitInDefaultParams(),o.yieldPos=c,o.awaitPos=l,o.parseArrowExpression(o.startNodeAt(t,r),f,!0);o.checkExpressionErrors(u,!0),o.yieldPos=c||o.yieldPos,o.awaitPos=l||o.awaitPos;var p=o.startNodeAt(t,r);p.callee=e,p.arguments=f,e=o.finishNode(p,"CallExpression")}else{if(o.type!==F.backQuote)return e;var d=o.startNodeAt(t,r);d.tag=e,d.quasi=o.parseTemplate(),e=o.finishNode(d,"TaggedTemplateExpression")}},H.parseExprAtom=function(e){var t,r=this.potentialArrowAt==this.start;switch(this.type){case F._super:this.inFunction||this.raise(this.start,"'super' outside of function or class");case F._this:var n=this.type===F._this?"ThisExpression":"Super";return t=this.startNode(),this.next(),this.finishNode(t,n);case F.name:var i=this.start,o=this.startLoc,a=this.parseIdent(this.type!==F.name);if(this.options.ecmaVersion>=8&&"async"===a.name&&!this.canInsertSemicolon()&&this.eat(F._function))return this.parseFunction(this.startNodeAt(i,o),!1,!1,!0);if(r&&!this.canInsertSemicolon()){if(this.eat(F.arrow))return this.parseArrowExpression(this.startNodeAt(i,o),[a],!1);if(this.options.ecmaVersion>=8&&"async"===a.name&&this.type===F.name)return a=this.parseIdent(),!this.canInsertSemicolon()&&this.eat(F.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(i,o),[a],!0)}return a;case F.regexp:var s=this.value;return t=this.parseLiteral(s.value),t.regex={pattern:s.pattern,flags:s.flags},t;case F.num:case F.string:return this.parseLiteral(this.value);case F._null:case F._true:case F._false:return t=this.startNode(),t.value=this.type===F._null?null:this.type===F._true,t.raw=this.type.keyword,this.next(),this.finishNode(t,"Literal");case F.parenL:var u=this.start,c=this.parseParenAndDistinguishExpression(r);return e&&(e.parenthesizedAssign<0&&!this.isSimpleAssignTarget(c)&&(e.parenthesizedAssign=u),e.parenthesizedBind<0&&(e.parenthesizedBind=u)),c;case F.bracketL:return t=this.startNode(),this.next(),t.elements=this.parseExprList(F.bracketR,!0,!0,e),this.finishNode(t,"ArrayExpression");case F.braceL:return this.parseObj(!1,e);case F._function:return t=this.startNode(),this.next(),this.parseFunction(t,!1);case F._class:return this.parseClass(this.startNode(),!1);case F._new:return this.parseNew();case F.backQuote:return this.parseTemplate();default:this.unexpected()}},H.parseLiteral=function(e){var t=this.startNode();return t.value=e,t.raw=this.input.slice(this.start,this.end),this.next(),this.finishNode(t,"Literal")},H.parseParenExpression=function(){this.expect(F.parenL);var e=this.parseExpression();return this.expect(F.parenR),e},H.parseParenAndDistinguishExpression=function(e){var t,r=this,n=this.start,i=this.startLoc,o=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var a,s,u=this.start,c=this.startLoc,l=[],f=!0,p=!1,d=new $,h=this.yieldPos,m=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==F.parenR;){if(f?f=!1:r.expect(F.comma),o&&r.afterTrailingComma(F.parenR,!0)){p=!0;break}if(r.type===F.ellipsis){a=r.start,l.push(r.parseParenItem(r.parseRest())),r.type===F.comma&&r.raise(r.start,"Comma is not permitted after the rest element");break}r.type!==F.parenL||s||(s=r.start),l.push(r.parseMaybeAssign(!1,d,r.parseParenItem))}var v=this.start,y=this.startLoc;if(this.expect(F.parenR),e&&!this.canInsertSemicolon()&&this.eat(F.arrow))return this.checkPatternErrors(d,!1),this.checkYieldAwaitInDefaultParams(),s&&this.unexpected(s),this.yieldPos=h,this.awaitPos=m,this.parseParenArrowList(n,i,l);l.length&&!p||this.unexpected(this.lastTokStart),a&&this.unexpected(a),this.checkExpressionErrors(d,!0),this.yieldPos=h||this.yieldPos,this.awaitPos=m||this.awaitPos,l.length>1?((t=this.startNodeAt(u,c)).expressions=l,this.finishNodeAt(t,"SequenceExpression",v,y)):t=l[0]}else t=this.parseParenExpression();if(this.options.preserveParens){var g=this.startNodeAt(n,i);return g.expression=t,this.finishNode(g,"ParenthesizedExpression")}return t},H.parseParenItem=function(e){return e},H.parseParenArrowList=function(e,t,r){return this.parseArrowExpression(this.startNodeAt(e,t),r)};var J=[];H.parseNew=function(){var e=this.startNode(),t=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(F.dot))return e.meta=t,e.property=this.parseIdent(!0),"target"!==e.property.name&&this.raiseRecoverable(e.property.start,"The only valid meta property for new is new.target"),this.inFunction||this.raiseRecoverable(e.start,"new.target can only be used in functions"),this.finishNode(e,"MetaProperty");var r=this.start,n=this.startLoc;return e.callee=this.parseSubscripts(this.parseExprAtom(),r,n,!0),this.eat(F.parenL)?e.arguments=this.parseExprList(F.parenR,this.options.ecmaVersion>=8,!1):e.arguments=J,this.finishNode(e,"NewExpression")},H.parseTemplateElement=function(){var e=this.startNode();return e.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),e.tail=this.type===F.backQuote,this.finishNode(e,"TemplateElement")},H.parseTemplate=function(){var e=this,t=this.startNode();this.next(),t.expressions=[];var r=this.parseTemplateElement();for(t.quasis=[r];!r.tail;)e.expect(F.dollarBraceL),t.expressions.push(e.parseExpression()),e.expect(F.braceR),t.quasis.push(r=e.parseTemplateElement());return this.next(),this.finishNode(t,"TemplateLiteral")},H.parseObj=function(e,t){var r=this,n=this.startNode(),i=!0,o={};for(n.properties=[],this.next();!this.eat(F.braceR);){if(i)i=!1;else if(r.expect(F.comma),r.afterTrailingComma(F.braceR))break;var a,s,u,c,l=r.startNode();r.options.ecmaVersion>=6&&(l.method=!1,l.shorthand=!1,(e||t)&&(u=r.start,c=r.startLoc),e||(a=r.eat(F.star))),r.parsePropertyName(l),e||!(r.options.ecmaVersion>=8)||a||l.computed||"Identifier"!==l.key.type||"async"!==l.key.name||r.type===F.parenL||r.type===F.colon||r.canInsertSemicolon()?s=!1:(s=!0,r.parsePropertyName(l,t)),r.parsePropertyValue(l,e,a,s,u,c,t),r.checkPropClash(l,o),n.properties.push(r.finishNode(l,"Property"))}return this.finishNode(n,e?"ObjectPattern":"ObjectExpression")},H.parsePropertyValue=function(e,t,r,n,i,o,a){if((r||n)&&this.type===F.colon&&this.unexpected(),this.eat(F.colon))e.value=t?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,a),e.kind="init";else if(this.options.ecmaVersion>=6&&this.type===F.parenL)t&&this.unexpected(),e.kind="init",e.method=!0,e.value=this.parseMethod(r,n);else if(this.options.ecmaVersion>=5&&!e.computed&&"Identifier"===e.key.type&&("get"===e.key.name||"set"===e.key.name)&&this.type!=F.comma&&this.type!=F.braceR){(r||n||t)&&this.unexpected(),e.kind=e.key.name,this.parsePropertyName(e),e.value=this.parseMethod(!1);var s="get"===e.kind?0:1;if(e.value.params.length!==s){var u=e.value.start;"get"===e.kind?this.raiseRecoverable(u,"getter should have no params"):this.raiseRecoverable(u,"setter should have exactly one param")}else"set"===e.kind&&"RestElement"===e.value.params[0].type&&this.raiseRecoverable(e.value.params[0].start,"Setter cannot use rest params")}else this.options.ecmaVersion>=6&&!e.computed&&"Identifier"===e.key.type?((this.keywords.test(e.key.name)||(this.strict?this.reservedWordsStrict:this.reservedWords).test(e.key.name)||this.inGenerator&&"yield"==e.key.name||this.inAsync&&"await"==e.key.name)&&this.raiseRecoverable(e.key.start,"'"+e.key.name+"' can not be used as shorthand property"),e.kind="init",t?e.value=this.parseMaybeDefault(i,o,e.key):this.type===F.eq&&a?(a.shorthandAssign<0&&(a.shorthandAssign=this.start),e.value=this.parseMaybeDefault(i,o,e.key)):e.value=e.key,e.shorthand=!0):this.unexpected()},H.parsePropertyName=function(e){if(this.options.ecmaVersion>=6){if(this.eat(F.bracketL))return e.computed=!0,e.key=this.parseMaybeAssign(),this.expect(F.bracketR),e.key;e.computed=!1}return e.key=this.type===F.num||this.type===F.string?this.parseExprAtom():this.parseIdent(!0)},H.initFunction=function(e){e.id=null,this.options.ecmaVersion>=6&&(e.generator=!1,e.expression=!1),this.options.ecmaVersion>=8&&(e.async=!1)},H.parseMethod=function(e,t){var r=this.startNode(),n=this.inGenerator,i=this.inAsync,o=this.yieldPos,a=this.awaitPos,s=this.inFunction;return this.initFunction(r),this.options.ecmaVersion>=6&&(r.generator=e),this.options.ecmaVersion>=8&&(r.async=!!t),this.inGenerator=r.generator,this.inAsync=r.async,this.yieldPos=0,this.awaitPos=0,this.inFunction=!0,this.expect(F.parenL),r.params=this.parseBindingList(F.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(r,!1),this.inGenerator=n,this.inAsync=i,this.yieldPos=o,this.awaitPos=a,this.inFunction=s,this.finishNode(r,"FunctionExpression")},H.parseArrowExpression=function(e,t,r){var n=this.inGenerator,i=this.inAsync,o=this.yieldPos,a=this.awaitPos,s=this.inFunction;return this.initFunction(e),this.options.ecmaVersion>=8&&(e.async=!!r),this.inGenerator=!1,this.inAsync=e.async,this.yieldPos=0,this.awaitPos=0,this.inFunction=!0,e.params=this.toAssignableList(t,!0),this.parseFunctionBody(e,!0),this.inGenerator=n,this.inAsync=i,this.yieldPos=o,this.awaitPos=a,this.inFunction=s,this.finishNode(e,"ArrowFunctionExpression")},H.parseFunctionBody=function(e,t){var r=t&&this.type!==F.braceL,n=this.strict,i=!1;if(r)e.body=this.parseMaybeAssign(),e.expression=!0;else{var o=this.options.ecmaVersion>=7&&!this.isSimpleParamList(e.params);n&&!o||(i=this.strictDirective(this.end))&&o&&this.raiseRecoverable(e.start,"Illegal 'use strict' directive in function with non-simple parameter list");var a=this.labels;this.labels=[],i&&(this.strict=!0),e.body=this.parseBlock(!0),e.expression=!1,this.labels=a}n||i?(this.strict=!0,e.id&&this.checkLVal(e.id,!0),this.checkParams(e),this.strict=n):!t&&this.isSimpleParamList(e.params)||this.checkParams(e)},H.isSimpleParamList=function(e){for(var t=0;t<e.length;t++)if("Identifier"!==e[t].type)return!1;return!0},H.checkParams=function(e){for(var t=this,r={},n=0;n<e.params.length;n++)t.checkLVal(e.params[n],!0,r)},H.parseExprList=function(e,t,r,n){for(var i=this,o=[],a=!0;!this.eat(e);){if(a)a=!1;else if(i.expect(F.comma),t&&i.afterTrailingComma(e))break;var s;r&&i.type===F.comma?s=null:i.type===F.ellipsis?(s=i.parseSpread(n),n&&i.type===F.comma&&n.trailingComma<0&&(n.trailingComma=i.start)):s=i.parseMaybeAssign(!1,n),o.push(s)}return o},H.parseIdent=function(e){var t=this.startNode();return e&&"never"==this.options.allowReserved&&(e=!1),this.type===F.name?(!e&&(this.strict?this.reservedWordsStrict:this.reservedWords).test(this.value)&&(this.options.ecmaVersion>=6||-1==this.input.slice(this.start,this.end).indexOf("\\"))&&this.raiseRecoverable(this.start,"The keyword '"+this.value+"' is reserved"),this.inGenerator&&"yield"===this.value&&this.raiseRecoverable(this.start,"Can not use 'yield' as identifier inside a generator"),this.inAsync&&"await"===this.value&&this.raiseRecoverable(this.start,"Can not use 'await' as identifier inside an async function"),t.name=this.value):e&&this.type.keyword?t.name=this.type.keyword:this.unexpected(),this.next(),this.finishNode(t,"Identifier")},H.parseYield=function(){this.yieldPos||(this.yieldPos=this.start);var e=this.startNode();return this.next(),this.type==F.semi||this.canInsertSemicolon()||this.type!=F.star&&!this.type.startsExpr?(e.delegate=!1,e.argument=null):(e.delegate=this.eat(F.star),e.argument=this.parseMaybeAssign()),this.finishNode(e,"YieldExpression")},H.parseAwait=function(){this.awaitPos||(this.awaitPos=this.start);var e=this.startNode();return this.next(),e.argument=this.parseMaybeUnary(null,!0),this.finishNode(e,"AwaitExpression")};var K=N.prototype;K.raise=function(e,t){var r=c(this.input,e);t+=" ("+r.line+":"+r.column+")";var n=new SyntaxError(t);throw n.pos=e,n.loc=r,n.raisedAt=this.pos,n},K.raiseRecoverable=K.raise,K.curPosition=function(){if(this.options.locations)return new P(this.curLine,this.pos-this.lineStart)};var Q=function(e,t,r){this.type="",this.start=t,this.end=0,e.options.locations&&(this.loc=new T(e,r)),e.options.directSourceFile&&(this.sourceFile=e.options.directSourceFile),e.options.ranges&&(this.range=[t,0])},Y=N.prototype;Y.startNode=function(){return new Q(this,this.start,this.startLoc)},Y.startNodeAt=function(e,t){return new Q(this,e,t)},Y.finishNode=function(e,t){return d.call(this,e,t,this.lastTokEnd,this.lastTokEndLoc)},Y.finishNodeAt=function(e,t,r,n){return d.call(this,e,t,r,n)};var X=function(e,t,r,n){this.token=e,this.isExpr=!!t,this.preserveSpace=!!r,this.override=n},Z={b_stat:new X("{",!1),b_expr:new X("{",!0),b_tmpl:new X("${",!0),p_stat:new X("(",!1),p_expr:new X("(",!0),q_tmpl:new X("`",!0,!0,function(e){return e.readTmplToken()}),f_expr:new X("function",!0)},ee=N.prototype;ee.initialContext=function(){return[Z.b_stat]},ee.braceIsBlock=function(e){if(e===F.colon){var t=this.curContext();if(t===Z.b_stat||t===Z.b_expr)return!t.isExpr}return e===F._return?O.test(this.input.slice(this.lastTokEnd,this.start)):e===F._else||e===F.semi||e===F.eof||e===F.parenR||(e==F.braceL?this.curContext()===Z.b_stat:!this.exprAllowed)},ee.updateContext=function(e){var t,r=this.type;r.keyword&&e==F.dot?this.exprAllowed=!1:(t=r.updateContext)?t.call(this,e):this.exprAllowed=r.beforeExpr},F.parenR.updateContext=F.braceR.updateContext=function(){if(1!=this.context.length){var e=this.context.pop();e===Z.b_stat&&this.curContext()===Z.f_expr?(this.context.pop(),this.exprAllowed=!1):this.exprAllowed=e===Z.b_tmpl||!e.isExpr}else this.exprAllowed=!0},F.braceL.updateContext=function(e){this.context.push(this.braceIsBlock(e)?Z.b_stat:Z.b_expr),this.exprAllowed=!0},F.dollarBraceL.updateContext=function(){this.context.push(Z.b_tmpl),this.exprAllowed=!0},F.parenL.updateContext=function(e){var t=e===F._if||e===F._for||e===F._with||e===F._while;this.context.push(t?Z.p_stat:Z.p_expr),this.exprAllowed=!0},F.incDec.updateContext=function(){},F._function.updateContext=function(e){e.beforeExpr&&e!==F.semi&&e!==F._else&&(e!==F.colon&&e!==F.braceL||this.curContext()!==Z.b_stat)&&this.context.push(Z.f_expr),this.exprAllowed=!1},F.backQuote.updateContext=function(){this.curContext()===Z.q_tmpl?this.context.pop():this.context.push(Z.q_tmpl),this.exprAllowed=!1};var te=function(e){this.type=e.type,this.value=e.value,this.start=e.start,this.end=e.end,e.options.locations&&(this.loc=new T(e,e.startLoc,e.endLoc)),e.options.ranges&&(this.range=[e.start,e.end])},re=N.prototype,ne="object"==typeof Packages&&"[object JavaPackage]"==Object.prototype.toString.call(Packages);re.next=function(){this.options.onToken&&this.options.onToken(new te(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},re.getToken=function(){return this.next(),new te(this)},"undefined"!=typeof Symbol&&(re[Symbol.iterator]=function(){var e=this;return{next:function(){var t=e.getToken();return{done:t.type===F.eof,value:t}}}}),re.curContext=function(){return this.context[this.context.length-1]},re.nextToken=function(){var e=this.curContext();return e&&e.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(F.eof):e.override?e.override(this):void this.readToken(this.fullCharCodeAtPos())},re.readToken=function(e){return r(e,this.options.ecmaVersion>=6)||92===e?this.readWord():this.getTokenFromCode(e)},re.fullCharCodeAtPos=function(){var e=this.input.charCodeAt(this.pos);return e<=55295||e>=57344?e:(e<<10)+this.input.charCodeAt(this.pos+1)-56613888},re.skipBlockComment=function(){var e=this,t=this.options.onComment&&this.curPosition(),r=this.pos,n=this.input.indexOf("*/",this.pos+=2);if(-1===n&&this.raise(this.pos-2,"Unterminated comment"),this.pos=n+2,this.options.locations){j.lastIndex=r;for(var i;(i=j.exec(this.input))&&i.index<this.pos;)++e.curLine,e.lineStart=i.index+i[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice(r+2,n),r,this.pos,t,this.curPosition())},re.skipLineComment=function(e){for(var t=this,r=this.pos,n=this.options.onComment&&this.curPosition(),i=this.input.charCodeAt(this.pos+=e);this.pos<this.input.length&&10!==i&&13!==i&&8232!==i&&8233!==i;)++t.pos,i=t.input.charCodeAt(t.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(r+e,this.pos),r,this.pos,n,this.curPosition())},re.skipSpace=function(){var e=this;e:for(;this.pos<this.input.length;){var t=e.input.charCodeAt(e.pos);switch(t){case 32:case 160:++e.pos;break;case 13:10===e.input.charCodeAt(e.pos+1)&&++e.pos;case 10:case 8232:case 8233:++e.pos,e.options.locations&&(++e.curLine,e.lineStart=e.pos);break;case 47:switch(e.input.charCodeAt(e.pos+1)){case 42:e.skipBlockComment();break;case 47:e.skipLineComment(2);break;default:break e}break;default:if(!(t>8&&t<14||t>=5760&&R.test(String.fromCharCode(t))))break e;++e.pos}}},re.finishToken=function(e,t){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var r=this.type;this.type=e,this.value=t,this.updateContext(r)},re.readToken_dot=function(){var e=this.input.charCodeAt(this.pos+1);if(e>=48&&e<=57)return this.readNumber(!0);var t=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&46===e&&46===t?(this.pos+=3,this.finishToken(F.ellipsis)):(++this.pos,this.finishToken(F.dot))},re.readToken_slash=function(){var e=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===e?this.finishOp(F.assign,2):this.finishOp(F.slash,1)},re.readToken_mult_modulo_exp=function(e){var t=this.input.charCodeAt(this.pos+1),r=1,n=42===e?F.star:F.modulo;return this.options.ecmaVersion>=7&&42===t&&(++r,n=F.starstar,t=this.input.charCodeAt(this.pos+2)),61===t?this.finishOp(F.assign,r+1):this.finishOp(n,r)},re.readToken_pipe_amp=function(e){var t=this.input.charCodeAt(this.pos+1);return t===e?this.finishOp(124===e?F.logicalOR:F.logicalAND,2):61===t?this.finishOp(F.assign,2):this.finishOp(124===e?F.bitwiseOR:F.bitwiseAND,1)},re.readToken_caret=function(){return 61===this.input.charCodeAt(this.pos+1)?this.finishOp(F.assign,2):this.finishOp(F.bitwiseXOR,1)},re.readToken_plus_min=function(e){var t=this.input.charCodeAt(this.pos+1);return t===e?45==t&&62==this.input.charCodeAt(this.pos+2)&&O.test(this.input.slice(this.lastTokEnd,this.pos))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(F.incDec,2):61===t?this.finishOp(F.assign,2):this.finishOp(F.plusMin,1)},re.readToken_lt_gt=function(e){var t=this.input.charCodeAt(this.pos+1),r=1;return t===e?(r=62===e&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+r)?this.finishOp(F.assign,r+1):this.finishOp(F.bitShift,r)):33==t&&60==e&&45==this.input.charCodeAt(this.pos+2)&&45==this.input.charCodeAt(this.pos+3)?(this.inModule&&this.unexpected(),this.skipLineComment(4),this.skipSpace(),this.nextToken()):(61===t&&(r=2),this.finishOp(F.relational,r))},re.readToken_eq_excl=function(e){var t=this.input.charCodeAt(this.pos+1);return 61===t?this.finishOp(F.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===e&&62===t&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(F.arrow)):this.finishOp(61===e?F.eq:F.prefix,1)},re.getTokenFromCode=function(e){switch(e){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(F.parenL);case 41:return++this.pos,this.finishToken(F.parenR);case 59:return++this.pos,this.finishToken(F.semi);case 44:return++this.pos,this.finishToken(F.comma);case 91:return++this.pos,this.finishToken(F.bracketL);case 93:return++this.pos,this.finishToken(F.bracketR);case 123:return++this.pos,this.finishToken(F.braceL);case 125:return++this.pos,this.finishToken(F.braceR);case 58:return++this.pos,this.finishToken(F.colon);case 63:return++this.pos,this.finishToken(F.question);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(F.backQuote);case 48:var t=this.input.charCodeAt(this.pos+1);if(120===t||88===t)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(111===t||79===t)return this.readRadixNumber(8);if(98===t||66===t)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(e);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(e);case 124:case 38:return this.readToken_pipe_amp(e);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(e);case 60:case 62:return this.readToken_lt_gt(e);case 61:case 33:return this.readToken_eq_excl(e);case 126:return this.finishOp(F.prefix,1)}this.raise(this.pos,"Unexpected character '"+m(e)+"'")},re.finishOp=function(e,t){var r=this.input.slice(this.pos,this.pos+t);return this.pos+=t,this.finishToken(e,r)};var ie=!!h("","u");re.readRegexp=function(){for(var e,t,r=this,n=this.pos;;){r.pos>=r.input.length&&r.raise(n,"Unterminated regular expression");var i=r.input.charAt(r.pos);if(O.test(i)&&r.raise(n,"Unterminated regular expression"),e)e=!1;else{if("["===i)t=!0;else if("]"===i&&t)t=!1;else if("/"===i&&!t)break;e="\\"===i}++r.pos}var o=this.input.slice(n,this.pos);++this.pos;var a=this.readWord1(),s=o,u="";if(a){var c=/^[gim]*$/;this.options.ecmaVersion>=6&&(c=/^[gimuy]*$/),c.test(a)||this.raise(n,"Invalid regular expression flag"),a.indexOf("u")>=0&&(ie?u="u":(s=(s=s.replace(/\\u\{([0-9a-fA-F]+)\}/g,function(e,t,i){return(t=Number("0x"+t))>1114111&&r.raise(n+i+3,"Code point out of bounds"),"x"})).replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x"),u=u.replace("u","")))}var l=null;return ne||(h(s,u,n,this),l=h(o,a)),this.finishToken(F.regexp,{pattern:o,flags:a,value:l})},re.readInt=function(e,t){for(var r=this,n=this.pos,i=0,o=0,a=null==t?1/0:t;o<a;++o){var s,u=r.input.charCodeAt(r.pos);if((s=u>=97?u-97+10:u>=65?u-65+10:u>=48&&u<=57?u-48:1/0)>=e)break;++r.pos,i=i*e+s}return this.pos===n||null!=t&&this.pos-n!==t?null:i},re.readRadixNumber=function(e){this.pos+=2;var t=this.readInt(e);return null==t&&this.raise(this.start+2,"Expected number in radix "+e),r(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(F.num,t)},re.readNumber=function(e){var t=this.pos,n=!1,i=48===this.input.charCodeAt(this.pos);e||null!==this.readInt(10)||this.raise(t,"Invalid number"),i&&this.pos==t+1&&(i=!1);var o=this.input.charCodeAt(this.pos);46!==o||i||(++this.pos,this.readInt(10),n=!0,o=this.input.charCodeAt(this.pos)),69!==o&&101!==o||i||(43!==(o=this.input.charCodeAt(++this.pos))&&45!==o||++this.pos,null===this.readInt(10)&&this.raise(t,"Invalid number"),n=!0),r(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var a,s=this.input.slice(t,this.pos);return n?a=parseFloat(s):i&&1!==s.length?/[89]/.test(s)||this.strict?this.raise(t,"Invalid number"):a=parseInt(s,8):a=parseInt(s,10),this.finishToken(F.num,a)},re.readCodePoint=function(){var e;if(123===this.input.charCodeAt(this.pos)){this.options.ecmaVersion<6&&this.unexpected();var t=++this.pos;e=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,e>1114111&&this.raise(t,"Code point out of bounds")}else e=this.readHexChar(4);return e},re.readString=function(e){for(var t=this,r="",n=++this.pos;;){t.pos>=t.input.length&&t.raise(t.start,"Unterminated string constant");var i=t.input.charCodeAt(t.pos);if(i===e)break;92===i?(r+=t.input.slice(n,t.pos),r+=t.readEscapedChar(!1),n=t.pos):(a(i)&&t.raise(t.start,"Unterminated string constant"),++t.pos)}return r+=this.input.slice(n,this.pos++),this.finishToken(F.string,r)},re.readTmplToken=function(){for(var e=this,t="",r=this.pos;;){e.pos>=e.input.length&&e.raise(e.start,"Unterminated template");var n=e.input.charCodeAt(e.pos);if(96===n||36===n&&123===e.input.charCodeAt(e.pos+1))return e.pos===e.start&&e.type===F.template?36===n?(e.pos+=2,e.finishToken(F.dollarBraceL)):(++e.pos,e.finishToken(F.backQuote)):(t+=e.input.slice(r,e.pos),e.finishToken(F.template,t));if(92===n)t+=e.input.slice(r,e.pos),t+=e.readEscapedChar(!0),r=e.pos;else if(a(n)){switch(t+=e.input.slice(r,e.pos),++e.pos,n){case 13:10===e.input.charCodeAt(e.pos)&&++e.pos;case 10:t+="\n";break;default:t+=String.fromCharCode(n)}e.options.locations&&(++e.curLine,e.lineStart=e.pos),r=e.pos}else++e.pos}},re.readEscapedChar=function(e){var t=this.input.charCodeAt(++this.pos);switch(++this.pos,t){case 110:return"\n";case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return m(this.readCodePoint());case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";default:if(t>=48&&t<=55){var r=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],n=parseInt(r,8);return n>255&&(r=r.slice(0,-1),n=parseInt(r,8)),"0"!==r&&(this.strict||e)&&this.raise(this.pos-2,"Octal literal in strict mode"),this.pos+=r.length-1,String.fromCharCode(n)}return String.fromCharCode(t)}},re.readHexChar=function(e){var t=this.pos,r=this.readInt(16,e);return null===r&&this.raise(t,"Bad character escape sequence"),r},re.readWord1=function(){var e=this;this.containsEsc=!1;for(var t="",i=!0,o=this.pos,a=this.options.ecmaVersion>=6;this.pos<this.input.length;){var s=e.fullCharCodeAtPos();if(n(s,a))e.pos+=s<=65535?1:2;else{if(92!==s)break;e.containsEsc=!0,t+=e.input.slice(o,e.pos);var u=e.pos;117!=e.input.charCodeAt(++e.pos)&&e.raise(e.pos,"Expecting Unicode escape sequence \\uXXXX"),++e.pos;var c=e.readCodePoint();(i?r:n)(c,a)||e.raise(u,"Invalid Unicode escape"),t+=m(c),o=e.pos}i=!1}return t+this.input.slice(o,this.pos)},re.readWord=function(){var e=this.readWord1(),t=F.name;return this.keywords.test(e)&&(this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+e),t=C[e]),this.finishToken(t,e)};e.version="4.0.11",e.parse=function(e,t){return new N(t,e).parse()},e.parseExpressionAt=function(e,t,r){var n=new N(r,e,t);return n.nextToken(),n.parseExpression()},e.tokenizer=function(e,t){return new N(t,e)},e.addLooseExports=function(t,r,n){e.parse_dammit=t,e.LooseParser=r,e.pluginsLoose=n},e.Parser=N,e.plugins=L,e.defaultOptions=I,e.Position=P,e.SourceLocation=T,e.getLineInfo=c,e.Node=Q,e.TokenType=S,e.tokTypes=F,e.keywordTypes=C,e.TokContext=X,e.tokContexts=Z,e.isIdentifierChar=n,e.isIdentifierStart=r,e.Token=te,e.isNewLine=a,e.lineBreak=O,e.lineBreakG=j,Object.defineProperty(e,"__esModule",{value:!0})}),function(t,r){"function"==typeof e&&e.amd?e(["exports"],r):r((t.acorn=t.acorn||{},t.acorn.walk=t.acorn.walk||{}))}(this,function(e){"use strict";function t(e){return"string"==typeof e?function(t){return t==e}:e||function(){return!0}}function r(e,t,r){r(e,t)}function n(e,t,r){}var i=function(e,t){this.node=e,this.state=t},o=Object.create||function(e){function t(){}return t.prototype=e,new t},a={};a.Program=a.BlockStatement=function(e,t,r){for(var n=0;n<e.body.length;++n)r(e.body[n],t,"Statement")},a.Statement=r,a.EmptyStatement=n,a.ExpressionStatement=a.ParenthesizedExpression=function(e,t,r){return r(e.expression,t,"Expression")},a.IfStatement=function(e,t,r){r(e.test,t,"Expression"),r(e.consequent,t,"Statement"),e.alternate&&r(e.alternate,t,"Statement")},a.LabeledStatement=function(e,t,r){return r(e.body,t,"Statement")},a.BreakStatement=a.ContinueStatement=n,a.WithStatement=function(e,t,r){r(e.object,t,"Expression"),r(e.body,t,"Statement")},a.SwitchStatement=function(e,t,r){r(e.discriminant,t,"Expression");for(var n=0;n<e.cases.length;++n){var i=e.cases[n];i.test&&r(i.test,t,"Expression");for(var o=0;o<i.consequent.length;++o)r(i.consequent[o],t,"Statement")}},a.ReturnStatement=a.YieldExpression=a.AwaitExpression=function(e,t,r){e.argument&&r(e.argument,t,"Expression")},a.ThrowStatement=a.SpreadElement=function(e,t,r){return r(e.argument,t,"Expression")},a.TryStatement=function(e,t,r){r(e.block,t,"Statement"),e.handler&&r(e.handler,t),e.finalizer&&r(e.finalizer,t,"Statement")},a.CatchClause=function(e,t,r){r(e.param,t,"Pattern"),r(e.body,t,"ScopeBody")},a.WhileStatement=a.DoWhileStatement=function(e,t,r){r(e.test,t,"Expression"),r(e.body,t,"Statement")},a.ForStatement=function(e,t,r){e.init&&r(e.init,t,"ForInit"),e.test&&r(e.test,t,"Expression"),e.update&&r(e.update,t,"Expression"),r(e.body,t,"Statement")},a.ForInStatement=a.ForOfStatement=function(e,t,r){r(e.left,t,"ForInit"),r(e.right,t,"Expression"),r(e.body,t,"Statement")},a.ForInit=function(e,t,r){"VariableDeclaration"==e.type?r(e,t):r(e,t,"Expression")},a.DebuggerStatement=n,a.FunctionDeclaration=function(e,t,r){return r(e,t,"Function")},a.VariableDeclaration=function(e,t,r){for(var n=0;n<e.declarations.length;++n)r(e.declarations[n],t)},a.VariableDeclarator=function(e,t,r){r(e.id,t,"Pattern"),e.init&&r(e.init,t,"Expression")},a.Function=function(e,t,r){e.id&&r(e.id,t,"Pattern");for(var n=0;n<e.params.length;n++)r(e.params[n],t,"Pattern");r(e.body,t,e.expression?"ScopeExpression":"ScopeBody")},a.ScopeBody=function(e,t,r){return r(e,t,"Statement")},a.ScopeExpression=function(e,t,r){return r(e,t,"Expression")},a.Pattern=function(e,t,r){"Identifier"==e.type?r(e,t,"VariablePattern"):"MemberExpression"==e.type?r(e,t,"MemberPattern"):r(e,t)},a.VariablePattern=n,a.MemberPattern=r,a.RestElement=function(e,t,r){return r(e.argument,t,"Pattern")},a.ArrayPattern=function(e,t,r){for(var n=0;n<e.elements.length;++n){var i=e.elements[n];i&&r(i,t,"Pattern")}},a.ObjectPattern=function(e,t,r){for(var n=0;n<e.properties.length;++n)r(e.properties[n].value,t,"Pattern")},a.Expression=r,a.ThisExpression=a.Super=a.MetaProperty=n,a.ArrayExpression=function(e,t,r){for(var n=0;n<e.elements.length;++n){var i=e.elements[n];i&&r(i,t,"Expression")}},a.ObjectExpression=function(e,t,r){for(var n=0;n<e.properties.length;++n)r(e.properties[n],t)},a.FunctionExpression=a.ArrowFunctionExpression=a.FunctionDeclaration,a.SequenceExpression=a.TemplateLiteral=function(e,t,r){for(var n=0;n<e.expressions.length;++n)r(e.expressions[n],t,"Expression")},a.UnaryExpression=a.UpdateExpression=function(e,t,r){r(e.argument,t,"Expression")},a.BinaryExpression=a.LogicalExpression=function(e,t,r){r(e.left,t,"Expression"),r(e.right,t,"Expression")},a.AssignmentExpression=a.AssignmentPattern=function(e,t,r){r(e.left,t,"Pattern"),r(e.right,t,"Expression")},a.ConditionalExpression=function(e,t,r){r(e.test,t,"Expression"),r(e.consequent,t,"Expression"),r(e.alternate,t,"Expression")},a.NewExpression=a.CallExpression=function(e,t,r){if(r(e.callee,t,"Expression"),e.arguments)for(var n=0;n<e.arguments.length;++n)r(e.arguments[n],t,"Expression")},a.MemberExpression=function(e,t,r){r(e.object,t,"Expression"),e.computed&&r(e.property,t,"Expression")},a.ExportNamedDeclaration=a.ExportDefaultDeclaration=function(e,t,r){e.declaration&&r(e.declaration,t,"ExportNamedDeclaration"==e.type||e.declaration.id?"Statement":"Expression"),e.source&&r(e.source,t,"Expression")},a.ExportAllDeclaration=function(e,t,r){r(e.source,t,"Expression")},a.ImportDeclaration=function(e,t,r){for(var n=0;n<e.specifiers.length;n++)r(e.specifiers[n],t);r(e.source,t,"Expression")},a.ImportSpecifier=a.ImportDefaultSpecifier=a.ImportNamespaceSpecifier=a.Identifier=a.Literal=n,a.TaggedTemplateExpression=function(e,t,r){r(e.tag,t,"Expression"),r(e.quasi,t)},a.ClassDeclaration=a.ClassExpression=function(e,t,r){return r(e,t,"Class")},a.Class=function(e,t,r){e.id&&r(e.id,t,"Pattern"),e.superClass&&r(e.superClass,t,"Expression");for(var n=0;n<e.body.body.length;n++)r(e.body.body[n],t)},a.MethodDefinition=a.Property=function(e,t,r){e.computed&&r(e.key,t,"Expression"),r(e.value,t,"Expression")},e.simple=function(t,r,n,i,o){n||(n=e.base),function e(t,i,o){var a=o||t.type,s=r[a];n[a](t,i,e),s&&s(t,i)}(t,i,o)},e.ancestor=function(t,r,n,i){n||(n=e.base);var o=[];!function e(t,i,a){var s=a||t.type,u=r[s],c=t!=o[o.length-1];c&&o.push(t),n[s](t,i,e),u&&u(t,i||o,o),c&&o.pop()}(t,i)},e.recursive=function(t,r,n,i,o){var a=n?e.make(n,i):i;!function e(t,r,n){a[n||t.type](t,r,e)}(t,r,o)},e.findNodeAt=function(r,n,o,a,s,u){a=t(a),s||(s=e.base);try{!function e(t,r,u){var c=u||t.type;if((null==n||t.start<=n)&&(null==o||t.end>=o)&&s[c](t,r,e),(null==n||t.start==n)&&(null==o||t.end==o)&&a(c,t))throw new i(t,r)}(r,u)}catch(e){if(e instanceof i)return e;throw e}},e.findNodeAround=function(r,n,o,a,s){o=t(o),a||(a=e.base);try{!function e(t,r,s){var u=s||t.type;if(!(t.start>n||t.end<n)&&(a[u](t,r,e),o(u,t)))throw new i(t,r)}(r,s)}catch(e){if(e instanceof i)return e;throw e}},e.findNodeAfter=function(r,n,o,a,s){o=t(o),a||(a=e.base);try{!function e(t,r,s){if(!(t.end<n)){var u=s||t.type;if(t.start>=n&&o(u,t))throw new i(t,r);a[u](t,r,e)}}(r,s)}catch(e){if(e instanceof i)return e;throw e}},e.findNodeBefore=function(r,n,o,a,s){o=t(o),a||(a=e.base);var u;return function e(t,r,s){if(!(t.start>n)){var c=s||t.type;t.end<=n&&(!u||u.node.end<t.end)&&o(c,t)&&(u=new i(t,r)),a[c](t,r,e)}}(r,s),u},e.make=function(t,r){r||(r=e.base);var n=o(r);for(var i in t)n[i]=t[i];return n},e.base=a,Object.defineProperty(e,"__esModule",{value:!0})}),function(t,r){"function"==typeof e&&e.amd?e(["exports","./acorn"],r):r((t.acorn=t.acorn||{},t.acorn.loose=t.acorn.loose||{}),t.acorn)}(this,function(e,t){"use strict";function r(e){return e<14&&e>8||32===e||160===e||t.isNewLine(e)}function n(e){return""==e.name}function i(e,t){var r=new a(e,t);return r.next(),r.parseTopLevel()}var o={},a=function(e,r){if(void 0===r&&(r={}),this.toks=t.tokenizer(e,r),this.options=this.toks.options,this.input=this.toks.input,this.tok=this.last={type:t.tokTypes.eof,start:0,end:0},this.options.locations){var n=this.toks.curPosition();this.tok.loc=new t.SourceLocation(this.toks,n,n)}this.ahead=[],this.context=[],this.curIndent=0,this.curLineStart=0,this.nextLineStart=this.lineEnd(this.curLineStart)+1,this.inAsync=!1,this.options.pluginsLoose=r.pluginsLoose||{},this.loadPlugins(this.options.pluginsLoose)};a.prototype.startNode=function(){return new t.Node(this.toks,this.tok.start,this.options.locations?this.tok.loc.start:null)},a.prototype.storeCurrentPos=function(){return this.options.locations?[this.tok.start,this.tok.loc.start]:this.tok.start},a.prototype.startNodeAt=function(e){return this.options.locations?new t.Node(this.toks,e[0],e[1]):new t.Node(this.toks,e)},a.prototype.finishNode=function(e,t){return e.type=t,e.end=this.last.end,this.options.locations&&(e.loc.end=this.last.loc.end),this.options.ranges&&(e.range[1]=this.last.end),e},a.prototype.dummyNode=function(e){var r=this.startNode();return r.type=e,r.end=r.start,this.options.locations&&(r.loc.end=r.loc.start),this.options.ranges&&(r.range[1]=r.start),this.last={type:t.tokTypes.name,start:r.start,end:r.start,loc:r.loc},r},a.prototype.dummyIdent=function(){var e=this.dummyNode("Identifier");return e.name="",e},a.prototype.dummyString=function(){var e=this.dummyNode("Literal");return e.value=e.raw="",e},a.prototype.eat=function(e){return this.tok.type===e&&(this.next(),!0)},a.prototype.isContextual=function(e){return this.tok.type===t.tokTypes.name&&this.tok.value===e},a.prototype.eatContextual=function(e){return this.tok.value===e&&this.eat(t.tokTypes.name)},a.prototype.canInsertSemicolon=function(){return this.tok.type===t.tokTypes.eof||this.tok.type===t.tokTypes.braceR||t.lineBreak.test(this.input.slice(this.last.end,this.tok.start))},a.prototype.semicolon=function(){return this.eat(t.tokTypes.semi)},a.prototype.expect=function(e){var t=this;if(this.eat(e))return!0;for(var r=1;r<=2;r++)if(t.lookAhead(r).type==e){for(var n=0;n<r;n++)t.next();return!0}},a.prototype.pushCx=function(){this.context.push(this.curIndent)},a.prototype.popCx=function(){this.curIndent=this.context.pop()},a.prototype.lineEnd=function(e){for(;e<this.input.length&&!t.isNewLine(this.input.charCodeAt(e));)++e;return e},a.prototype.indentationAfter=function(e){for(var t=this,r=0;;++e){var n=t.input.charCodeAt(e);if(32===n)++r;else{if(9!==n)return r;r+=t.options.tabSize}}},a.prototype.closes=function(e,r,n,i){return this.tok.type===e||this.tok.type===t.tokTypes.eof||n!=this.curLineStart&&this.curIndent<r&&this.tokenStartsLine()&&(!i||this.nextLineStart>=this.input.length||this.indentationAfter(this.nextLineStart)<r)},a.prototype.tokenStartsLine=function(){for(var e=this,t=this.tok.start-1;t>=this.curLineStart;--t){var r=e.input.charCodeAt(t);if(9!==r&&32!==r)return!1}return!0},a.prototype.extend=function(e,t){this[e]=t(this[e])},a.prototype.loadPlugins=function(e){var t=this;for(var r in e){var n=o[r];if(!n)throw new Error("Plugin '"+r+"' not found");n(t,e[r])}};var s=a.prototype;s.next=function(){var e=this;if(this.last=this.tok,this.ahead.length?this.tok=this.ahead.shift():this.tok=this.readToken(),this.tok.start>=this.nextLineStart){for(;this.tok.start>=this.nextLineStart;)e.curLineStart=e.nextLineStart,e.nextLineStart=e.lineEnd(e.curLineStart)+1;this.curIndent=this.indentationAfter(this.curLineStart)}},s.readToken=function(){for(var e=this;;)try{return e.toks.next(),e.toks.type===t.tokTypes.dot&&"."===e.input.substr(e.toks.end,1)&&e.options.ecmaVersion>=6&&(e.toks.end++,e.toks.type=t.tokTypes.ellipsis),new t.Token(e.toks)}catch(u){if(!(u instanceof SyntaxError))throw u;var n=u.message,i=u.raisedAt,o=!0;if(/unterminated/i.test(n))if(i=e.lineEnd(u.pos+1),/string/.test(n))o={start:u.pos,end:i,type:t.tokTypes.string,value:e.input.slice(u.pos+1,i)};else if(/regular expr/i.test(n)){var a=e.input.slice(u.pos,i);try{a=new RegExp(a)}catch(e){}o={start:u.pos,end:i,type:t.tokTypes.regexp,value:a}}else o=!!/template/.test(n)&&{start:u.pos,end:i,type:t.tokTypes.template,value:e.input.slice(u.pos,i)};else if(/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(n))for(;i<this.input.length&&!r(this.input.charCodeAt(i));)++i;else if(/character escape|expected hexadecimal/i.test(n))for(;i<this.input.length;){var s=e.input.charCodeAt(i++);if(34===s||39===s||t.isNewLine(s))break}else if(/unexpected character/i.test(n))i++,o=!1;else{if(!/regular expression/i.test(n))throw u;o=!0}if(e.resetTo(i),!0===o&&(o={start:i,end:i,type:t.tokTypes.name,value:""}),o)return e.options.locations&&(o.loc=new t.SourceLocation(e.toks,t.getLineInfo(e.input,o.start),t.getLineInfo(e.input,o.end))),o}},s.resetTo=function(e){var r=this;this.toks.pos=e;var n=this.input.charAt(e-1);if(this.toks.exprAllowed=!n||/[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(n)||/[enwfd]/.test(n)&&/\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(e-10,e)),this.options.locations){this.toks.curLine=1,this.toks.lineStart=t.lineBreakG.lastIndex=0;for(var i;(i=t.lineBreakG.exec(this.input))&&i.index<e;)++r.toks.curLine,r.toks.lineStart=i.index+i[0].length}},s.lookAhead=function(e){for(var t=this;e>this.ahead.length;)t.ahead.push(t.readToken());return this.ahead[e-1]};var u=a.prototype;u.parseTopLevel=function(){var e=this,r=this.startNodeAt(this.options.locations?[0,t.getLineInfo(this.input,0)]:0);for(r.body=[];this.tok.type!==t.tokTypes.eof;)r.body.push(e.parseStatement());return this.last=this.tok,this.options.ecmaVersion>=6&&(r.sourceType=this.options.sourceType),this.finishNode(r,"Program")},u.parseStatement=function(){var e,r=this,i=this.tok.type,o=this.startNode();switch(this.toks.isLet()&&(i=t.tokTypes._var,e="let"),i){case t.tokTypes._break:case t.tokTypes._continue:this.next();var a=i===t.tokTypes._break;return this.semicolon()||this.canInsertSemicolon()?o.label=null:(o.label=this.tok.type===t.tokTypes.name?this.parseIdent():null,this.semicolon()),this.finishNode(o,a?"BreakStatement":"ContinueStatement");case t.tokTypes._debugger:return this.next(),this.semicolon(),this.finishNode(o,"DebuggerStatement");case t.tokTypes._do:return this.next(),o.body=this.parseStatement(),o.test=this.eat(t.tokTypes._while)?this.parseParenExpression():this.dummyIdent(),this.semicolon(),this.finishNode(o,"DoWhileStatement");case t.tokTypes._for:if(this.next(),this.pushCx(),this.expect(t.tokTypes.parenL),this.tok.type===t.tokTypes.semi)return this.parseFor(o,null);var s=this.toks.isLet();if(s||this.tok.type===t.tokTypes._var||this.tok.type===t.tokTypes._const){var u=this.parseVar(!0,s?"let":this.tok.value);return 1!==u.declarations.length||this.tok.type!==t.tokTypes._in&&!this.isContextual("of")?this.parseFor(o,u):this.parseForIn(o,u)}var c=this.parseExpression(!0);return this.tok.type===t.tokTypes._in||this.isContextual("of")?this.parseForIn(o,this.toAssignable(c)):this.parseFor(o,c);case t.tokTypes._function:return this.next(),this.parseFunction(o,!0);case t.tokTypes._if:return this.next(),o.test=this.parseParenExpression(),o.consequent=this.parseStatement(),o.alternate=this.eat(t.tokTypes._else)?this.parseStatement():null,this.finishNode(o,"IfStatement");case t.tokTypes._return:return this.next(),this.eat(t.tokTypes.semi)||this.canInsertSemicolon()?o.argument=null:(o.argument=this.parseExpression(),this.semicolon()),this.finishNode(o,"ReturnStatement");case t.tokTypes._switch:var l=this.curIndent,f=this.curLineStart;this.next(),o.discriminant=this.parseParenExpression(),o.cases=[],this.pushCx(),this.expect(t.tokTypes.braceL);for(var p;!this.closes(t.tokTypes.braceR,l,f,!0);)if(r.tok.type===t.tokTypes._case||r.tok.type===t.tokTypes._default){var d=r.tok.type===t.tokTypes._case;p&&r.finishNode(p,"SwitchCase"),o.cases.push(p=r.startNode()),p.consequent=[],r.next(),p.test=d?r.parseExpression():null,r.expect(t.tokTypes.colon)}else p||(o.cases.push(p=r.startNode()),p.consequent=[],p.test=null),p.consequent.push(r.parseStatement());return p&&this.finishNode(p,"SwitchCase"),this.popCx(),this.eat(t.tokTypes.braceR),this.finishNode(o,"SwitchStatement");case t.tokTypes._throw:return this.next(),o.argument=this.parseExpression(),this.semicolon(),this.finishNode(o,"ThrowStatement");case t.tokTypes._try:if(this.next(),o.block=this.parseBlock(),o.handler=null,this.tok.type===t.tokTypes._catch){var h=this.startNode();this.next(),this.expect(t.tokTypes.parenL),h.param=this.toAssignable(this.parseExprAtom(),!0),this.expect(t.tokTypes.parenR),h.body=this.parseBlock(),o.handler=this.finishNode(h,"CatchClause")}return o.finalizer=this.eat(t.tokTypes._finally)?this.parseBlock():null,o.handler||o.finalizer?this.finishNode(o,"TryStatement"):o.block;case t.tokTypes._var:case t.tokTypes._const:return this.parseVar(!1,e||this.tok.value);case t.tokTypes._while:return this.next(),o.test=this.parseParenExpression(),o.body=this.parseStatement(),this.finishNode(o,"WhileStatement");case t.tokTypes._with:return this.next(),o.object=this.parseParenExpression(),o.body=this.parseStatement(),this.finishNode(o,"WithStatement");case t.tokTypes.braceL:return this.parseBlock();case t.tokTypes.semi:return this.next(),this.finishNode(o,"EmptyStatement");case t.tokTypes._class:return this.parseClass(!0);case t.tokTypes._import:return this.parseImport();case t.tokTypes._export:return this.parseExport();default:if(this.toks.isAsyncFunction())return this.next(),this.next(),this.parseFunction(o,!0,!0);var m=this.parseExpression();return n(m)?(this.next(),this.tok.type===t.tokTypes.eof?this.finishNode(o,"EmptyStatement"):this.parseStatement()):i===t.tokTypes.name&&"Identifier"===m.type&&this.eat(t.tokTypes.colon)?(o.body=this.parseStatement(),o.label=m,this.finishNode(o,"LabeledStatement")):(o.expression=m,this.semicolon(),this.finishNode(o,"ExpressionStatement"))}},u.parseBlock=function(){var e=this,r=this.startNode();this.pushCx(),this.expect(t.tokTypes.braceL);var n=this.curIndent,i=this.curLineStart;for(r.body=[];!this.closes(t.tokTypes.braceR,n,i,!0);)r.body.push(e.parseStatement());return this.popCx(),this.eat(t.tokTypes.braceR),this.finishNode(r,"BlockStatement")},u.parseFor=function(e,r){return e.init=r,e.test=e.update=null,this.eat(t.tokTypes.semi)&&this.tok.type!==t.tokTypes.semi&&(e.test=this.parseExpression()),this.eat(t.tokTypes.semi)&&this.tok.type!==t.tokTypes.parenR&&(e.update=this.parseExpression()),this.popCx(),this.expect(t.tokTypes.parenR),e.body=this.parseStatement(),this.finishNode(e,"ForStatement")},u.parseForIn=function(e,r){var n=this.tok.type===t.tokTypes._in?"ForInStatement":"ForOfStatement";return this.next(),e.left=r,e.right=this.parseExpression(),this.popCx(),this.expect(t.tokTypes.parenR),e.body=this.parseStatement(),this.finishNode(e,n)},u.parseVar=function(e,r){var n=this,i=this.startNode();i.kind=r,this.next(),i.declarations=[];do{var o=n.startNode();o.id=n.options.ecmaVersion>=6?n.toAssignable(n.parseExprAtom(),!0):n.parseIdent(),o.init=n.eat(t.tokTypes.eq)?n.parseMaybeAssign(e):null,i.declarations.push(n.finishNode(o,"VariableDeclarator"))}while(this.eat(t.tokTypes.comma));if(!i.declarations.length){var a=this.startNode();a.id=this.dummyIdent(),i.declarations.push(this.finishNode(a,"VariableDeclarator"))}return e||this.semicolon(),this.finishNode(i,"VariableDeclaration")},u.parseClass=function(e){var r=this,i=this.startNode();this.next(),null==e&&(e=this.tok.type===t.tokTypes.name),this.tok.type===t.tokTypes.name?i.id=this.parseIdent():i.id=e?this.dummyIdent():null,i.superClass=this.eat(t.tokTypes._extends)?this.parseExpression():null,i.body=this.startNode(),i.body.body=[],this.pushCx();var o=this.curIndent+1,a=this.curLineStart;for(this.eat(t.tokTypes.braceL),this.curIndent+1<o&&(o=this.curIndent,a=this.curLineStart);!this.closes(t.tokTypes.braceR,o,a);)if(!r.semicolon()){var s,u,c=r.startNode();r.options.ecmaVersion>=6&&(c.static=!1,s=r.eat(t.tokTypes.star)),r.parsePropertyName(c),n(c.key)?(n(r.parseMaybeAssign())&&r.next(),r.eat(t.tokTypes.comma)):("Identifier"!==c.key.type||c.computed||"static"!==c.key.name||r.tok.type==t.tokTypes.parenL||r.tok.type==t.tokTypes.braceL?c.static=!1:(c.static=!0,s=r.eat(t.tokTypes.star),r.parsePropertyName(c)),c.computed||"Identifier"!==c.key.type||"async"!==c.key.name||r.tok.type===t.tokTypes.parenL||r.canInsertSemicolon()?u=!1:(r.parsePropertyName(c),u=!0),r.options.ecmaVersion>=5&&"Identifier"===c.key.type&&!c.computed&&("get"===c.key.name||"set"===c.key.name)&&r.tok.type!==t.tokTypes.parenL&&r.tok.type!==t.tokTypes.braceL?(c.kind=c.key.name,r.parsePropertyName(c),c.value=r.parseMethod(!1)):(c.computed||c.static||s||u||!("Identifier"===c.key.type&&"constructor"===c.key.name||"Literal"===c.key.type&&"constructor"===c.key.value)?c.kind="method":c.kind="constructor",c.value=r.parseMethod(s,u)),i.body.body.push(r.finishNode(c,"MethodDefinition")))}return this.popCx(),this.eat(t.tokTypes.braceR)||(this.last.end=this.tok.start,this.options.locations&&(this.last.loc.end=this.tok.loc.start)),this.semicolon(),this.finishNode(i.body,"ClassBody"),this.finishNode(i,e?"ClassDeclaration":"ClassExpression")},u.parseFunction=function(e,r,n){var i=this.inAsync;return this.initFunction(e),this.options.ecmaVersion>=6&&(e.generator=this.eat(t.tokTypes.star)),this.options.ecmaVersion>=8&&(e.async=!!n),null==r&&(r=this.tok.type===t.tokTypes.name),this.tok.type===t.tokTypes.name?e.id=this.parseIdent():r&&(e.id=this.dummyIdent()),this.inAsync=e.async,e.params=this.parseFunctionParams(),e.body=this.parseBlock(),this.inAsync=i,this.finishNode(e,r?"FunctionDeclaration":"FunctionExpression")},u.parseExport=function(){var e=this.startNode();if(this.next(),this.eat(t.tokTypes.star))return e.source=this.eatContextual("from")?this.parseExprAtom():this.dummyString(),this.finishNode(e,"ExportAllDeclaration");if(this.eat(t.tokTypes._default)){var r;if(this.tok.type===t.tokTypes._function||(r=this.toks.isAsyncFunction())){var n=this.startNode();this.next(),r&&this.next(),e.declaration=this.parseFunction(n,null,r)}else this.tok.type===t.tokTypes._class?e.declaration=this.parseClass(null):(e.declaration=this.parseMaybeAssign(),this.semicolon());return this.finishNode(e,"ExportDefaultDeclaration")}return this.tok.type.keyword||this.toks.isLet()||this.toks.isAsyncFunction()?(e.declaration=this.parseStatement(),e.specifiers=[],e.source=null):(e.declaration=null,e.specifiers=this.parseExportSpecifierList(),e.source=this.eatContextual("from")?this.parseExprAtom():null,this.semicolon()),this.finishNode(e,"ExportNamedDeclaration")},u.parseImport=function(){var e=this.startNode();if(this.next(),this.tok.type===t.tokTypes.string)e.specifiers=[],e.source=this.parseExprAtom(),e.kind="";else{var r;this.tok.type===t.tokTypes.name&&"from"!==this.tok.value&&((r=this.startNode()).local=this.parseIdent(),this.finishNode(r,"ImportDefaultSpecifier"),this.eat(t.tokTypes.comma)),e.specifiers=this.parseImportSpecifierList(),e.source=this.eatContextual("from")&&this.tok.type==t.tokTypes.string?this.parseExprAtom():this.dummyString(),r&&e.specifiers.unshift(r)}return this.semicolon(),this.finishNode(e,"ImportDeclaration")},u.parseImportSpecifierList=function(){var e=this,r=[];if(this.tok.type===t.tokTypes.star){var i=this.startNode();this.next(),i.local=this.eatContextual("as")?this.parseIdent():this.dummyIdent(),r.push(this.finishNode(i,"ImportNamespaceSpecifier"))}else{var o=this.curIndent,a=this.curLineStart,s=this.nextLineStart;for(this.pushCx(),this.eat(t.tokTypes.braceL),this.curLineStart>s&&(s=this.curLineStart);!this.closes(t.tokTypes.braceR,o+(this.curLineStart<=s?1:0),a);){var u=e.startNode();if(e.eat(t.tokTypes.star))u.local=e.eatContextual("as")?e.parseIdent():e.dummyIdent(),e.finishNode(u,"ImportNamespaceSpecifier");else{if(e.isContextual("from"))break;if(u.imported=e.parseIdent(),n(u.imported))break;u.local=e.eatContextual("as")?e.parseIdent():u.imported,e.finishNode(u,"ImportSpecifier")}r.push(u),e.eat(t.tokTypes.comma)}this.eat(t.tokTypes.braceR),this.popCx()}return r},u.parseExportSpecifierList=function(){var e=this,r=[],i=this.curIndent,o=this.curLineStart,a=this.nextLineStart;for(this.pushCx(),this.eat(t.tokTypes.braceL),this.curLineStart>a&&(a=this.curLineStart);!this.closes(t.tokTypes.braceR,i+(this.curLineStart<=a?1:0),o)&&!e.isContextual("from");){var s=e.startNode();if(s.local=e.parseIdent(),n(s.local))break;s.exported=e.eatContextual("as")?e.parseIdent():s.local,e.finishNode(s,"ExportSpecifier"),r.push(s),e.eat(t.tokTypes.comma)}return this.eat(t.tokTypes.braceR),this.popCx(),r};var c=a.prototype;c.checkLVal=function(e){if(!e)return e;switch(e.type){case"Identifier":case"MemberExpression":return e;case"ParenthesizedExpression":return e.expression=this.checkLVal(e.expression),e;default:return this.dummyIdent()}},c.parseExpression=function(e){var r=this,n=this.storeCurrentPos(),i=this.parseMaybeAssign(e);if(this.tok.type===t.tokTypes.comma){var o=this.startNodeAt(n);for(o.expressions=[i];this.eat(t.tokTypes.comma);)o.expressions.push(r.parseMaybeAssign(e));return this.finishNode(o,"SequenceExpression")}return i},c.parseParenExpression=function(){this.pushCx(),this.expect(t.tokTypes.parenL);var e=this.parseExpression();return this.popCx(),this.expect(t.tokTypes.parenR),e},c.parseMaybeAssign=function(e){if(this.toks.isContextual("yield")){var r=this.startNode();return this.next(),this.semicolon()||this.canInsertSemicolon()||this.tok.type!=t.tokTypes.star&&!this.tok.type.startsExpr?(r.delegate=!1,r.argument=null):(r.delegate=this.eat(t.tokTypes.star),r.argument=this.parseMaybeAssign()),this.finishNode(r,"YieldExpression")}var n=this.storeCurrentPos(),i=this.parseMaybeConditional(e);if(this.tok.type.isAssign){var o=this.startNodeAt(n);return o.operator=this.tok.value,o.left=this.tok.type===t.tokTypes.eq?this.toAssignable(i):this.checkLVal(i),this.next(),o.right=this.parseMaybeAssign(e),this.finishNode(o,"AssignmentExpression")}return i},c.parseMaybeConditional=function(e){var r=this.storeCurrentPos(),n=this.parseExprOps(e);if(this.eat(t.tokTypes.question)){var i=this.startNodeAt(r);return i.test=n,i.consequent=this.parseMaybeAssign(),i.alternate=this.expect(t.tokTypes.colon)?this.parseMaybeAssign(e):this.dummyIdent(),this.finishNode(i,"ConditionalExpression")}return n},c.parseExprOps=function(e){var t=this.storeCurrentPos(),r=this.curIndent,n=this.curLineStart;return this.parseExprOp(this.parseMaybeUnary(!1),t,-1,e,r,n)},c.parseExprOp=function(e,r,n,i,o,a){if(this.curLineStart!=a&&this.curIndent<o&&this.tokenStartsLine())return e;var s=this.tok.type.binop;if(null!=s&&(!i||this.tok.type!==t.tokTypes._in)&&s>n){var u=this.startNodeAt(r);if(u.left=e,u.operator=this.tok.value,this.next(),this.curLineStart!=a&&this.curIndent<o&&this.tokenStartsLine())u.right=this.dummyIdent();else{var c=this.storeCurrentPos();u.right=this.parseExprOp(this.parseMaybeUnary(!1),c,s,i,o,a)}return this.finishNode(u,/&&|\|\|/.test(u.operator)?"LogicalExpression":"BinaryExpression"),this.parseExprOp(u,r,n,i,o,a)}return e},c.parseMaybeUnary=function(e){var r,n=this,i=this.storeCurrentPos();if(this.options.ecmaVersion>=8&&this.inAsync&&this.toks.isContextual("await"))r=this.parseAwait(),e=!0;else if(this.tok.type.prefix){var o=this.startNode(),a=this.tok.type===t.tokTypes.incDec;a||(e=!0),o.operator=this.tok.value,o.prefix=!0,this.next(),o.argument=this.parseMaybeUnary(!0),a&&(o.argument=this.checkLVal(o.argument)),r=this.finishNode(o,a?"UpdateExpression":"UnaryExpression")}else if(this.tok.type===t.tokTypes.ellipsis){var s=this.startNode();this.next(),s.argument=this.parseMaybeUnary(e),r=this.finishNode(s,"SpreadElement")}else for(r=this.parseExprSubscripts();this.tok.type.postfix&&!this.canInsertSemicolon();){var u=n.startNodeAt(i);u.operator=n.tok.value,u.prefix=!1,u.argument=n.checkLVal(r),n.next(),r=n.finishNode(u,"UpdateExpression")}if(!e&&this.eat(t.tokTypes.starstar)){var c=this.startNodeAt(i);return c.operator="**",c.left=r,c.right=this.parseMaybeUnary(!1),this.finishNode(c,"BinaryExpression")}return r},c.parseExprSubscripts=function(){var e=this.storeCurrentPos();return this.parseSubscripts(this.parseExprAtom(),e,!1,this.curIndent,this.curLineStart)},c.parseSubscripts=function(e,r,n,i,o){for(var a=this;;){if(a.curLineStart!=o&&a.curIndent<=i&&a.tokenStartsLine()){if(a.tok.type!=t.tokTypes.dot||a.curIndent!=i)return e;--i}var s="Identifier"===e.type&&"async"===e.name&&!a.canInsertSemicolon();if(a.eat(t.tokTypes.dot)){var u=a.startNodeAt(r);u.object=e,a.curLineStart!=o&&a.curIndent<=i&&a.tokenStartsLine()?u.property=a.dummyIdent():u.property=a.parsePropertyAccessor()||a.dummyIdent(),u.computed=!1,e=a.finishNode(u,"MemberExpression")}else if(a.tok.type==t.tokTypes.bracketL){a.pushCx(),a.next();var c=a.startNodeAt(r);c.object=e,c.property=a.parseExpression(),c.computed=!0,a.popCx(),a.expect(t.tokTypes.bracketR),e=a.finishNode(c,"MemberExpression")}else if(n||a.tok.type!=t.tokTypes.parenL){if(a.tok.type!=t.tokTypes.backQuote)return e;var l=a.startNodeAt(r);l.tag=e,l.quasi=a.parseTemplate(),e=a.finishNode(l,"TaggedTemplateExpression")}else{var f=a.parseExprList(t.tokTypes.parenR);if(s&&a.eat(t.tokTypes.arrow))return a.parseArrowExpression(a.startNodeAt(r),f,!0);var p=a.startNodeAt(r);p.callee=e,p.arguments=f,e=a.finishNode(p,"CallExpression")}}},c.parseExprAtom=function(){var e;switch(this.tok.type){case t.tokTypes._this:case t.tokTypes._super:var r=this.tok.type===t.tokTypes._this?"ThisExpression":"Super";return e=this.startNode(),this.next(),this.finishNode(e,r);case t.tokTypes.name:var i=this.storeCurrentPos(),o=this.parseIdent(),a=!1;if("async"===o.name&&!this.canInsertSemicolon()){if(this.eat(t.tokTypes._function))return this.parseFunction(this.startNodeAt(i),!1,!0);this.tok.type===t.tokTypes.name&&(o=this.parseIdent(),a=!0)}return this.eat(t.tokTypes.arrow)?this.parseArrowExpression(this.startNodeAt(i),[o],a):o;case t.tokTypes.regexp:e=this.startNode();var s=this.tok.value;return e.regex={pattern:s.pattern,flags:s.flags},e.value=s.value,e.raw=this.input.slice(this.tok.start,this.tok.end),this.next(),this.finishNode(e,"Literal");case t.tokTypes.num:case t.tokTypes.string:return e=this.startNode(),e.value=this.tok.value,e.raw=this.input.slice(this.tok.start,this.tok.end),this.next(),this.finishNode(e,"Literal");case t.tokTypes._null:case t.tokTypes._true:case t.tokTypes._false:return e=this.startNode(),e.value=this.tok.type===t.tokTypes._null?null:this.tok.type===t.tokTypes._true,e.raw=this.tok.type.keyword,this.next(),this.finishNode(e,"Literal");case t.tokTypes.parenL:var u=this.storeCurrentPos();this.next();var c=this.parseExpression();if(this.expect(t.tokTypes.parenR),this.eat(t.tokTypes.arrow)){var l=c.expressions||[c];return l.length&&n(l[l.length-1])&&l.pop(),this.parseArrowExpression(this.startNodeAt(u),l)}if(this.options.preserveParens){var f=this.startNodeAt(u);f.expression=c,c=this.finishNode(f,"ParenthesizedExpression")}return c;case t.tokTypes.bracketL:return e=this.startNode(),e.elements=this.parseExprList(t.tokTypes.bracketR,!0),this.finishNode(e,"ArrayExpression");case t.tokTypes.braceL:return this.parseObj();case t.tokTypes._class:return this.parseClass(!1);case t.tokTypes._function:return e=this.startNode(),this.next(),this.parseFunction(e,!1);case t.tokTypes._new:return this.parseNew();case t.tokTypes.backQuote:return this.parseTemplate();default:return this.dummyIdent()}},c.parseNew=function(){var e=this.startNode(),r=this.curIndent,n=this.curLineStart,i=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(t.tokTypes.dot))return e.meta=i,e.property=this.parseIdent(!0),this.finishNode(e,"MetaProperty");var o=this.storeCurrentPos();return e.callee=this.parseSubscripts(this.parseExprAtom(),o,!0,r,n),this.tok.type==t.tokTypes.parenL?e.arguments=this.parseExprList(t.tokTypes.parenR):e.arguments=[],this.finishNode(e,"NewExpression")},c.parseTemplateElement=function(){var e=this.startNode();return e.value={raw:this.input.slice(this.tok.start,this.tok.end).replace(/\r\n?/g,"\n"),cooked:this.tok.value},this.next(),e.tail=this.tok.type===t.tokTypes.backQuote,this.finishNode(e,"TemplateElement")},c.parseTemplate=function(){var e=this,r=this.startNode();this.next(),r.expressions=[];var n=this.parseTemplateElement();for(r.quasis=[n];!n.tail;)e.next(),r.expressions.push(e.parseExpression()),e.expect(t.tokTypes.braceR)?n=e.parseTemplateElement():((n=e.startNode()).value={cooked:"",raw:""},n.tail=!0,e.finishNode(n,"TemplateElement")),r.quasis.push(n);return this.expect(t.tokTypes.backQuote),this.finishNode(r,"TemplateLiteral")},c.parseObj=function(){var e=this,r=this.startNode();r.properties=[],this.pushCx();var i=this.curIndent+1,o=this.curLineStart;for(this.eat(t.tokTypes.braceL),this.curIndent+1<i&&(i=this.curIndent,o=this.curLineStart);!this.closes(t.tokTypes.braceR,i,o);){var a,s,u,c=e.startNode();if(e.options.ecmaVersion>=6&&(u=e.storeCurrentPos(),c.method=!1,c.shorthand=!1,a=e.eat(t.tokTypes.star)),e.parsePropertyName(c),c.computed||"Identifier"!==c.key.type||"async"!==c.key.name||e.tok.type===t.tokTypes.parenL||e.tok.type===t.tokTypes.colon||e.canInsertSemicolon()?s=!1:(e.parsePropertyName(c),s=!0),n(c.key))n(e.parseMaybeAssign())&&e.next(),e.eat(t.tokTypes.comma);else{if(e.eat(t.tokTypes.colon))c.kind="init",c.value=e.parseMaybeAssign();else if(e.options.ecmaVersion>=6&&(e.tok.type===t.tokTypes.parenL||e.tok.type===t.tokTypes.braceL))c.kind="init",c.method=!0,c.value=e.parseMethod(a,s);else if(e.options.ecmaVersion>=5&&"Identifier"===c.key.type&&!c.computed&&("get"===c.key.name||"set"===c.key.name)&&e.tok.type!=t.tokTypes.comma&&e.tok.type!=t.tokTypes.braceR)c.kind=c.key.name,e.parsePropertyName(c),c.value=e.parseMethod(!1);else{if(c.kind="init",e.options.ecmaVersion>=6)if(e.eat(t.tokTypes.eq)){var l=e.startNodeAt(u);l.operator="=",l.left=c.key,l.right=e.parseMaybeAssign(),c.value=e.finishNode(l,"AssignmentExpression")}else c.value=c.key;else c.value=e.dummyIdent();c.shorthand=!0}r.properties.push(e.finishNode(c,"Property")),e.eat(t.tokTypes.comma)}}return this.popCx(),this.eat(t.tokTypes.braceR)||(this.last.end=this.tok.start,this.options.locations&&(this.last.loc.end=this.tok.loc.start)),this.finishNode(r,"ObjectExpression")},c.parsePropertyName=function(e){if(this.options.ecmaVersion>=6){if(this.eat(t.tokTypes.bracketL))return e.computed=!0,e.key=this.parseExpression(),void this.expect(t.tokTypes.bracketR);e.computed=!1}var r=this.tok.type===t.tokTypes.num||this.tok.type===t.tokTypes.string?this.parseExprAtom():this.parseIdent();e.key=r||this.dummyIdent()},c.parsePropertyAccessor=function(){if(this.tok.type===t.tokTypes.name||this.tok.type.keyword)return this.parseIdent()},c.parseIdent=function(){var e=this.tok.type===t.tokTypes.name?this.tok.value:this.tok.type.keyword;if(!e)return this.dummyIdent();var r=this.startNode();return this.next(),r.name=e,this.finishNode(r,"Identifier")},c.initFunction=function(e){e.id=null,e.params=[],this.options.ecmaVersion>=6&&(e.generator=!1,e.expression=!1),this.options.ecmaVersion>=8&&(e.async=!1)},c.toAssignable=function(e,t){var r=this;if(!e||"Identifier"==e.type||"MemberExpression"==e.type&&!t);else if("ParenthesizedExpression"==e.type)e.expression=this.toAssignable(e.expression,t);else{if(this.options.ecmaVersion<6)return this.dummyIdent();if("ObjectExpression"==e.type){e.type="ObjectPattern";for(var n=e.properties,i=0;i<n.length;i++)n[i].value=r.toAssignable(n[i].value,t)}else if("ArrayExpression"==e.type)e.type="ArrayPattern",this.toAssignableList(e.elements,t);else if("SpreadElement"==e.type)e.type="RestElement",e.argument=this.toAssignable(e.argument,t);else{if("AssignmentExpression"!=e.type)return this.dummyIdent();e.type="AssignmentPattern",delete e.operator}}return e},c.toAssignableList=function(e,t){for(var r=this,n=0;n<e.length;n++)e[n]=r.toAssignable(e[n],t);return e},c.parseFunctionParams=function(e){return e=this.parseExprList(t.tokTypes.parenR),this.toAssignableList(e,!0)},c.parseMethod=function(e,r){var n=this.startNode(),i=this.inAsync;return this.initFunction(n),this.options.ecmaVersion>=6&&(n.generator=!!e),this.options.ecmaVersion>=8&&(n.async=!!r),this.inAsync=n.async,n.params=this.parseFunctionParams(),n.expression=this.options.ecmaVersion>=6&&this.tok.type!==t.tokTypes.braceL,n.body=n.expression?this.parseMaybeAssign():this.parseBlock(),this.inAsync=i,this.finishNode(n,"FunctionExpression")},c.parseArrowExpression=function(e,r,n){var i=this.inAsync;return this.initFunction(e),this.options.ecmaVersion>=8&&(e.async=!!n),this.inAsync=e.async,e.params=this.toAssignableList(r,!0),e.expression=this.tok.type!==t.tokTypes.braceL,e.body=e.expression?this.parseMaybeAssign():this.parseBlock(),this.inAsync=i,this.finishNode(e,"ArrowFunctionExpression")},c.parseExprList=function(e,r){var i=this;this.pushCx();var o=this.curIndent,a=this.curLineStart,s=[];for(this.next();!this.closes(e,o+1,a);)if(i.eat(t.tokTypes.comma))s.push(r?null:i.dummyIdent());else{var u=i.parseMaybeAssign();if(n(u)){if(i.closes(e,o,a))break;i.next()}else s.push(u);i.eat(t.tokTypes.comma)}return this.popCx(),this.eat(e)||(this.last.end=this.tok.start,this.options.locations&&(this.last.loc.end=this.tok.loc.start)),s},c.parseAwait=function(){var e=this.startNode();return this.next(),e.argument=this.parseMaybeUnary(),this.finishNode(e,"AwaitExpression")},t.defaultOptions.tabSize=4,t.addLooseExports(i,a,o),e.parse_dammit=i,e.LooseParser=a,e.pluginsLoose=o,Object.defineProperty(e,"__esModule",{value:!0})}),function(e){function t(e,t){return e.lineStart>=t}function r(e,t,r){var n=t.input.slice(t.start);return r&&(n=n.replace(s,"$1 $3")),e.test(n)}function n(e,t,r){var n=new e.constructor(e.options,e.input,t);if(r)for(var i in r)n[i]=r[i];var o=e,a=n;return["inFunction","inAsync","inGenerator","inModule"].forEach(function(e){e in o&&(a[e]=o[e])}),n.nextToken(),n}var i={exports:{}},o=/^async[\t ]+(return|throw)/,a=/^\s*[):;]/,s=/([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g;i.exports=function(e,i){i&&"object"==typeof i||(i={}),e.extend("parse",function(t){return function(){return this.inAsync=i.inAsyncFunction,i.awaitAnywhere&&i.inAsyncFunction&&e.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive"),t.apply(this,arguments)}}),e.extend("parseStatement",function(e){return function(t,n){var a=this.start,s=this.startLoc;if("name"===this.type.label&&i.asyncExits&&r(o,this)){this.next();var u=this.parseStatement(t,n);return u.async=!0,u.start=a,u.loc&&(u.loc.start=s),u.range&&(u.range[0]=a),u}return e.apply(this,arguments)}}),e.extend("parseIdent",function(e){return function(t){return"module"===this.options.sourceType&&this.options.ecmaVersion>=8&&i.awaitAnywhere?e.call(this,!0):e.apply(this,arguments)}}),e.extend("parseExprAtom",function(e){var t={};return function(r){var o,a=this.start,s=(this.startLoc,e.apply(this,arguments));if("Identifier"===s.type&&"await"===s.name&&!this.inAsync&&i.awaitAnywhere){var u=this.startNodeAt(s.start,s.loc&&s.loc.start);a=this.start;var c={raise:function(){try{return pp.raise.apply(this,arguments)}catch(e){throw t}}};try{if((o=n(this,a-4,c).parseExprSubscripts()).end<=a)return o=n(this,a,c).parseExprSubscripts(),u.argument=o,u=this.finishNodeAt(u,"AwaitExpression",o.end,o.loc&&o.loc.end),this.pos=o.end,this.end=o.end,this.endLoc=o.endLoc,this.next(),u}catch(e){if(e===t)return s;throw e}}return s}});var s={undefined:!0,get:!0,set:!0,static:!0,async:!0,constructor:!0};e.extend("parsePropertyName",function(e){return function(r){var n=r.key&&r.key.name,i=e.apply(this,arguments);return"get"===this.value&&(r.__maybeStaticAsyncGetter=!0),s[this.value]?i:("Identifier"!==i.type||"async"!==i.name&&"async"!==n||t(this,i.end)||this.input.slice(i.end).match(a)?delete r.__maybeStaticAsyncGetter:"set"===r.kind||"set"===i.name?this.raise(i.start,"'set <member>(value)' cannot be be async"):(this.__isAsyncProp=!0,"Identifier"===(i=e.apply(this,arguments)).type&&"set"===i.name&&this.raise(i.start,"'set <member>(value)' cannot be be async")),i)}}),e.extend("parseClassMethod",function(e){return function(t,r,n){var i=e.apply(this,arguments);return r.__maybeStaticAsyncGetter&&(delete r.__maybeStaticAsyncGetter,"get"!==r.key.name&&(r.kind="get")),i}}),e.extend("parseFunctionBody",function(e){return function(t,r){var n=this.inAsync;this.__isAsyncProp&&(t.async=!0,this.inAsync=!0,delete this.__isAsyncProp);var i=e.apply(this,arguments);return this.inAsync=n,i}})},e.plugins.asyncawait=i.exports}(this.acorn),function(e){var t={exports:{}};t.exports=function(e){function t(e,t){var n=this.startNode(),i=!0,o={};for(n.properties=[],this.next();!this.eat(r.braceR);){if(i)i=!1;else if(this.expect(r.comma),this.afterTrailingComma(r.braceR))break;var a,s,u,c,l=this.startNode();if(this.options.ecmaVersion>=6){if(this.type===r.ellipsis){(l=this.parseSpread()).type=e?"RestElement":"SpreadElement",n.properties.push(l);continue}l.method=!1,l.shorthand=!1,(e||t)&&(u=this.start,c=this.startLoc),e||(a=this.eat(r.star))}this.parsePropertyName(l),e||!(this.options.ecmaVersion>=8)||a||l.computed||"Identifier"!==l.key.type||"async"!==l.key.name||this.type===r.parenL||this.type===r.colon||this.canInsertSemicolon()?s=!1:(s=!0,this.parsePropertyName(l,t)),this.parsePropertyValue(l,e,a,s,u,c,t),this.checkPropClash(l,o),n.properties.push(this.finishNode(l,"Property"))}return this.finishNode(n,e?"ObjectPattern":"ObjectExpression")}var r=e.tokTypes,n=e.Parser.prototype;return e.plugins.objectSpread=function(e){n.parseObj=t},e},t.exports(e)}(this.acorn),this.acorn}(),function(t){(function(r){function n(e,t){if({}.hasOwnProperty.call(n.cache,e))return n.cache[e];var r=n.resolve(e);if(!r)throw new Error("Failed to resolve module "+e);var i={id:e,require:n,filename:e,exports:{},loaded:!1,parent:t,children:[]};t&&t.children.push(i);var o=e.slice(0,e.lastIndexOf("/")+1);return n.cache[e]=i.exports,r.call(i.exports,i,i.exports,o,e),i.loaded=!0,n.cache[e]=i.exports}n.modules={},n.cache={},n.resolve=function(e){return{}.hasOwnProperty.call(n.modules,e)?n.modules[e]:void 0},n.define=function(e,t){n.modules[e]=t};var i=function(){var e="/";return{title:"browser",version:"v7.7.4",browser:!0,env:{},argv:[],nextTick:r.setImmediate||function(e){setTimeout(e,0)},cwd:function(){return e},chdir:function(t){e=t}}}();n.define("/tools/entry-point.js",function(e,i,o,a){!function(){"use strict";r.escodegen=n("/escodegen.js",e),t.escodegen.browser=!0}()}),n.define("/escodegen.js",function(e,t,i,o){!function(){"use strict";function i(e){return B.Expression.hasOwnProperty(e.type)}function o(e){return B.Statement.hasOwnProperty(e.type)}function a(){return{indent:null,base:null,parse:null,comment:!1,format:{indent:{style:"    ",base:0,adjustMultilineComment:!1},newline:"\n",space:" ",json:!1,renumber:!1,hexadecimal:!1,quotes:"single",escapeless:!1,compact:!1,parentheses:!0,semicolons:!0,safeConcatenation:!1,preserveBlankLines:!1},moz:{comprehensionExpressionStartsWithAssignment:!1,starlessGenerator:!1},sourceMap:null,sourceMapRoot:null,sourceMapWithCode:!1,directive:!1,raw:!0,verbatim:null,sourceCode:null}}function s(e,t){var r="";for(t|=0;t>0;t>>>=1,e+=e)1&t&&(r+=e);return r}function u(e){return/[\r\n]/g.test(e)}function c(e){var t=e.length;return t&&z.code.isLineTerminator(e.charCodeAt(t-1))}function l(e,t){var r;for(r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}function f(e,t){function r(e){return"object"==typeof e&&e instanceof Object&&!(e instanceof RegExp)}var n,i;for(n in t)t.hasOwnProperty(n)&&(r(i=t[n])?r(e[n])?f(e[n],i):e[n]=f({},i):e[n]=i);return e}function p(e){var t,r,n,i,o;if(e!==e)throw new Error("Numeric literal whose value is NaN");if(e<0||0===e&&1/e<0)throw new Error("Numeric literal whose value is negative");if(e===1/0)return J?"null":K?"1e400":"1e+400";if(t=""+e,!K||t.length<3)return t;for(r=t.indexOf("."),J||48!==t.charCodeAt(0)||1!==r||(r=0,t=t.slice(1)),n=t,t=t.replace("e+","e"),i=0,(o=n.indexOf("e"))>0&&(i=+n.slice(o+1),n=n.slice(0,o)),r>=0&&(i-=n.length-r-1,n=+(n.slice(0,r)+n.slice(r+1))+""),o=0;48===n.charCodeAt(n.length+o-1);)--o;return 0!==o&&(i-=o,n=n.slice(0,o)),0!==i&&(n+="e"+i),(n.length<t.length||Q&&e>1e12&&Math.floor(e)===e&&(n="0x"+e.toString(16)).length<t.length)&&+n===e&&(t=n),t}function d(e,t){return 8232==(-2&e)?(t?"u":"\\u")+(8232===e?"2028":"2029"):10===e||13===e?(t?"":"\\")+(10===e?"n":"r"):String.fromCharCode(e)}function h(e){var t,r,n,i,o,a,s,u;if(r=e.toString(),e.source){if(!(t=r.match(/\/([^\/]*)$/)))return r;for(n=t[1],r="",s=!1,u=!1,i=0,o=e.source.length;i<o;++i)a=e.source.charCodeAt(i),u?(r+=d(a,u),u=!1):(s?93===a&&(s=!1):47===a?r+="\\":91===a&&(s=!0),r+=d(a,u),u=92===a);return"/"+r+"/"+n}return r}function m(e,t){var r;return 8===e?"\\b":12===e?"\\f":9===e?"\\t":(r=e.toString(16).toUpperCase(),J||e>255?"\\u"+"0000".slice(r.length)+r:0!==e||z.code.isDecimalDigit(t)?11===e?"\\x0B":"\\x"+"00".slice(r.length)+r:"\\0")}function v(e){if(92===e)return"\\\\";if(10===e)return"\\n";if(13===e)return"\\r";if(8232===e)return"\\u2028";if(8233===e)return"\\u2029";throw new Error("Incorrectly classified character")}function y(e){var t,r,n,i;for(i="double"===Y?'"':"'",t=0,r=e.length;t<r;++t){if(39===(n=e.charCodeAt(t))){i='"';break}if(34===n){i="'";break}92===n&&++t}return i+e+i}function g(e){var t,r,n,i,o,a="",s=0,u=0;for(t=0,r=e.length;t<r;++t){if(39===(n=e.charCodeAt(t)))++s;else if(34===n)++u;else if(47===n&&J)a+="\\";else{if(z.code.isLineTerminator(n)||92===n){a+=v(n);continue}if(!z.code.isIdentifierPartES5(n)&&(J&&n<32||!J&&!X&&(n<32||n>126))){a+=m(n,e.charCodeAt(t+1));continue}}a+=String.fromCharCode(n)}if(i=!("double"===Y||"auto"===Y&&u<s),o=i?"'":'"',!(i?s:u))return o+a+o;for(e=a,a=o,t=0,r=e.length;t<r;++t)(39===(n=e.charCodeAt(t))&&i||34===n&&!i)&&(a+="\\"),a+=String.fromCharCode(n);return a+o}function b(e){var t,r,n,i="";for(t=0,r=e.length;t<r;++t)n=e[t],i+=V(n)?b(n):n;return i}function _(e,t){if(!se)return V(e)?b(e):e;if(null==t){if(e instanceof W)return e;t={}}return null==t.loc?new W(null,null,se,e,t.name||null):new W(t.loc.start.line,t.loc.start.column,!0===se?t.loc.source||null:se,e,t.name||null)}function x(){return ee||" "}function w(e,t){var r,n,i,o;return 0===(r=_(e).toString()).length?[t]:0===(n=_(t).toString()).length?[e]:(i=r.charCodeAt(r.length-1),o=n.charCodeAt(0),(43===i||45===i)&&i===o||z.code.isIdentifierPartES5(i)&&z.code.isIdentifierPartES5(o)||47===i&&105===o?[e,x(),t]:z.code.isWhiteSpace(i)||z.code.isLineTerminator(i)||z.code.isWhiteSpace(o)||z.code.isLineTerminator(o)?[e,t]:[e,ee,t])}function k(e){return[G,e]}function E(e){var t;t=G,e(G+=H),G=t}function S(e){var t;for(t=e.length-1;t>=0&&!z.code.isLineTerminator(e.charCodeAt(t));--t);return e.length-1-t}function A(e,t){var r,n,i,o,a,s,u,c;for(r=e.split(/\r\n|[\r\n]/),s=Number.MAX_VALUE,n=1,i=r.length;n<i;++n){for(o=r[n],a=0;a<o.length&&z.code.isWhiteSpace(o.charCodeAt(a));)++a;s>a&&(s=a)}for(void 0!==t?(u=G,"*"===r[1][s]&&(t+=" "),G=t):(1&s&&--s,u=G),n=1,i=r.length;n<i;++n)c=_(k(r[n].slice(s))),r[n]=se?c.join(""):c;return G=u,r.join("\n")}function D(e,t){if("Line"===e.type){if(c(e.value))return"//"+e.value;var r="//"+e.value;return ce||(r+="\n"),r}return oe.format.indent.adjustMultilineComment&&/[\n\r]/.test(e.value)?A("/*"+e.value+"*/",t):"/*"+e.value+"*/"}function C(e,t){var r,n,i,o,a,u,l,f,p,d,h,m;if(e.leadingComments&&e.leadingComments.length>0){if(o=t,ce){for(t=[],f=(i=e.leadingComments[0]).extendedRange,p=i.range,(m=((h=ue.substring(f[0],p[0])).match(/\n/g)||[]).length)>0?(t.push(s("\n",m)),t.push(k(D(i)))):(t.push(h),t.push(D(i))),d=p,r=1,n=e.leadingComments.length;r<n;r++)p=(i=e.leadingComments[r]).range,m=(ue.substring(d[1],p[0]).match(/\n/g)||[]).length,t.push(s("\n",m)),t.push(k(D(i))),d=p;m=(ue.substring(p[1],f[1]).match(/\n/g)||[]).length,t.push(s("\n",m))}else for(i=e.leadingComments[0],t=[],ne&&e.type===M.Program&&0===e.body.length&&t.push("\n"),t.push(D(i)),c(_(t).toString())||t.push("\n"),r=1,n=e.leadingComments.length;r<n;++r)c(_(l=[D(i=e.leadingComments[r])]).toString())||l.push("\n"),t.push(k(l));t.push(k(o))}if(e.trailingComments)if(ce)f=(i=e.trailingComments[0]).extendedRange,p=i.range,(m=((h=ue.substring(f[0],p[0])).match(/\n/g)||[]).length)>0?(t.push(s("\n",m)),t.push(k(D(i)))):(t.push(h),t.push(D(i)));else for(a=!c(_(t).toString()),u=s(" ",S(_([G,t,H]).toString())),r=0,n=e.trailingComments.length;r<n;++r)i=e.trailingComments[r],a?(t=0===r?[t,H]:[t,u]).push(D(i,u)):t=[t,k(D(i))],r===n-1||c(_(t).toString())||(t=[t,"\n"]);return t}function F(e,t,r){var n,i=0;for(n=e;n<t;n++)"\n"===ue[n]&&i++;for(n=1;n<i;n++)r.push(Z)}function O(e,t,r){return t<r?["(",e,")"]:e}function j(e){var t,r,n;for(t=1,r=(n=e.split(/\r\n|\n/)).length;t<r;t++)n[t]=Z+G+n[t];return n}function R(e,t){var r,n;return r=e[oe.verbatim],n="string"==typeof r?O(j(r),q.Sequence,t):O(n=j(r.content),null!=r.precedence?r.precedence:q.Sequence,t),_(n,e)}function B(){}function P(e){return _(e.name,e)}function T(e,t){return e.async?"async"+(t?x():ee):""}function I(e){return e.generator&&!oe.moz.starlessGenerator?"*"+ee:""}function L(e){var t=e.value;return t.async?T(t,!e.computed):I(t)?"*":""}function N(e){var t;if(t=new B,o(e))return t.generateStatement(e,de);if(i(e))return t.generateExpression(e,q.Sequence,pe);throw new Error("Unknown node type: "+e.type)}var M,q,$,W,U,z,V,G,H,J,K,Q,Y,X,Z,ee,te,re,ne,ie,oe,ae,se,ue,ce,le,fe;U=n("/node_modules/estraverse/estraverse.js",e),z=n("/node_modules/esutils/lib/utils.js",e),M=U.Syntax,$={"||":(q={Sequence:0,Yield:1,Await:1,Assignment:1,Conditional:2,ArrowFunction:2,LogicalOR:3,LogicalAND:4,BitwiseOR:5,BitwiseXOR:6,BitwiseAND:7,Equality:8,Relational:9,BitwiseSHIFT:10,Additive:11,Multiplicative:12,Unary:13,Postfix:14,Call:15,New:16,TaggedTemplate:17,Member:18,Primary:19}).LogicalOR,"&&":q.LogicalAND,"|":q.BitwiseOR,"^":q.BitwiseXOR,"&":q.BitwiseAND,"==":q.Equality,"!=":q.Equality,"===":q.Equality,"!==":q.Equality,is:q.Equality,isnt:q.Equality,"<":q.Relational,">":q.Relational,"<=":q.Relational,">=":q.Relational,in:q.Relational,instanceof:q.Relational,"<<":q.BitwiseSHIFT,">>":q.BitwiseSHIFT,">>>":q.BitwiseSHIFT,"+":q.Additive,"-":q.Additive,"*":q.Multiplicative,"%":q.Multiplicative,"/":q.Multiplicative};var pe=7,de=1;(V=Array.isArray)||(V=function(e){return"[object Array]"===Object.prototype.toString.call(e)}),B.prototype.maybeBlock=function(e,t){var r,n,i=this;return n=!oe.comment||!e.leadingComments,e.type===M.BlockStatement&&n?[ee,this.generateStatement(e,t)]:e.type===M.EmptyStatement&&n?";":(E(function(){r=[Z,k(i.generateStatement(e,t))]}),r)},B.prototype.maybeBlockSuffix=function(e,t){var r=c(_(t).toString());return e.type!==M.BlockStatement||oe.comment&&e.leadingComments||r?r?[t,G]:[t,Z,G]:[t,ee]},B.prototype.generatePattern=function(e,t,r){return e.type===M.Identifier?P(e):this.generateExpression(e,t,r)},B.prototype.generateFunctionParams=function(e){var t,r,n,i;if(i=!1,e.type!==M.ArrowFunctionExpression||e.rest||e.defaults&&0!==e.defaults.length||1!==e.params.length||e.params[0].type!==M.Identifier){for((n=e.type===M.ArrowFunctionExpression?[T(e,!1)]:[]).push("("),e.defaults&&(i=!0),t=0,r=e.params.length;t<r;++t)i&&e.defaults[t]?n.push(this.generateAssignment(e.params[t],e.defaults[t],"=",q.Assignment,pe)):n.push(this.generatePattern(e.params[t],q.Assignment,pe)),t+1<r&&n.push(","+ee);e.rest&&(e.params.length&&n.push(","+ee),n.push("..."),n.push(P(e.rest))),n.push(")")}else n=[T(e,!0),P(e.params[0])];return n},B.prototype.generateFunctionBody=function(e){var t,r;return t=this.generateFunctionParams(e),e.type===M.ArrowFunctionExpression&&(t.push(ee),t.push("=>")),e.expression?(t.push(ee),"{"===(r=this.generateExpression(e.body,q.Assignment,pe)).toString().charAt(0)&&(r=["(",r,")"]),t.push(r)):t.push(this.maybeBlock(e.body,9)),t},B.prototype.generateIterationForStatement=function(e,t,r){var n=["for"+ee+"("],i=this;return E(function(){t.left.type===M.VariableDeclaration?E(function(){n.push(t.left.kind+x()),n.push(i.generateStatement(t.left.declarations[0],0))}):n.push(i.generateExpression(t.left,q.Call,pe)),n=w(n,e),n=[w(n,i.generateExpression(t.right,q.Sequence,pe)),")"]}),n.push(this.maybeBlock(t.body,r)),n},B.prototype.generatePropertyKey=function(e,t,r){var n=[];return t&&n.push("["),"AssignmentPattern"===r.type?n.push(this.AssignmentPattern(r,q.Sequence,pe)):n.push(this.generateExpression(e,q.Sequence,pe)),t&&n.push("]"),n},B.prototype.generateAssignment=function(e,t,r,n,i){return q.Assignment<n&&(i|=1),O([this.generateExpression(e,q.Call,i),ee+r+ee,this.generateExpression(t,q.Assignment,i)],q.Assignment,n)},B.prototype.semicolon=function(e){return!re&&32&e?"":";"},B.Statement={BlockStatement:function(e,t){var r,n,i=["{",Z],o=this;return E(function(){0===e.body.length&&ce&&(r=e.range)[1]-r[0]>2&&("\n"===(n=ue.substring(r[0]+1,r[1]-1))[0]&&(i=["{"]),i.push(n));var a,s,u,l;for(l=de,8&t&&(l|=16),a=0,s=e.body.length;a<s;++a)ce&&(0===a&&(e.body[0].leadingComments&&(r=e.body[0].leadingComments[0].extendedRange,"\n"===(n=ue.substring(r[0],r[1]))[0]&&(i=["{"])),e.body[0].leadingComments||F(e.range[0],e.body[0].range[0],i)),a>0&&(e.body[a-1].trailingComments||e.body[a].leadingComments||F(e.body[a-1].range[1],e.body[a].range[0],i))),a===s-1&&(l|=32),u=e.body[a].leadingComments&&ce?o.generateStatement(e.body[a],l):k(o.generateStatement(e.body[a],l)),i.push(u),c(_(u).toString())||(ce&&a<s-1?e.body[a+1].leadingComments||i.push(Z):i.push(Z)),ce&&a===s-1&&(e.body[a].trailingComments||F(e.body[a].range[1],e.range[1],i))}),i.push(k("}")),i},BreakStatement:function(e,t){return e.label?"break "+e.label.name+this.semicolon(t):"break"+this.semicolon(t)},ContinueStatement:function(e,t){return e.label?"continue "+e.label.name+this.semicolon(t):"continue"+this.semicolon(t)},ClassBody:function(e,t){var r=["{",Z],n=this;return E(function(t){var i,o;for(i=0,o=e.body.length;i<o;++i)r.push(t),r.push(n.generateExpression(e.body[i],q.Sequence,pe)),i+1<o&&r.push(Z)}),c(_(r).toString())||r.push(Z),r.push(G),r.push("}"),r},ClassDeclaration:function(e,t){var r;return r=["class"],e.id&&(r=w(r,this.generateExpression(e.id,q.Sequence,pe))),e.superClass&&(r=w(r,w("extends",this.generateExpression(e.superClass,q.Assignment,pe)))),r.push(ee),r.push(this.generateStatement(e.body,33)),r},DirectiveStatement:function(e,t){return oe.raw&&e.raw?e.raw+this.semicolon(t):y(e.directive)+this.semicolon(t)},DoWhileStatement:function(e,t){var r=w("do",this.maybeBlock(e.body,de));return r=this.maybeBlockSuffix(e.body,r),w(r,["while"+ee+"(",this.generateExpression(e.test,q.Sequence,pe),")"+this.semicolon(t)])},CatchClause:function(e,t){var r,n=this;return E(function(){var t;r=["catch"+ee+"(",n.generateExpression(e.param,q.Sequence,pe),")"],e.guard&&(t=n.generateExpression(e.guard,q.Sequence,pe),r.splice(2,0," if ",t))}),r.push(this.maybeBlock(e.body,de)),r},DebuggerStatement:function(e,t){return"debugger"+this.semicolon(t)},EmptyStatement:function(e,t){return";"},ExportDefaultDeclaration:function(e,t){var r,n=["export"];return r=32&t?33:de,n=w(n,"default"),n=o(e.declaration)?w(n,this.generateStatement(e.declaration,r)):w(n,this.generateExpression(e.declaration,q.Assignment,pe)+this.semicolon(t))},ExportNamedDeclaration:function(e,t){var r,n=["export"],i=this;return r=32&t?33:de,e.declaration?w(n,this.generateStatement(e.declaration,r)):(e.specifiers&&(0===e.specifiers.length?n=w(n,"{"+ee+"}"):e.specifiers[0].type===M.ExportBatchSpecifier?n=w(n,this.generateExpression(e.specifiers[0],q.Sequence,pe)):(n=w(n,"{"),E(function(t){var r,o;for(n.push(Z),r=0,o=e.specifiers.length;r<o;++r)n.push(t),n.push(i.generateExpression(e.specifiers[r],q.Sequence,pe)),r+1<o&&n.push(","+Z)}),c(_(n).toString())||n.push(Z),n.push(G+"}")),e.source?n=w(n,["from"+ee,this.generateExpression(e.source,q.Sequence,pe),this.semicolon(t)]):n.push(this.semicolon(t))),n)},ExportAllDeclaration:function(e,t){return["export"+ee,"*"+ee,"from"+ee,this.generateExpression(e.source,q.Sequence,pe),this.semicolon(t)]},ExpressionStatement:function(e,t){var r,n;return r=[this.generateExpression(e.expression,q.Sequence,pe)],123===(n=_(r).toString()).charCodeAt(0)||function(e){var t;return"class"===e.slice(0,5)&&(123===(t=e.charCodeAt(5))||z.code.isWhiteSpace(t)||z.code.isLineTerminator(t))}(n)||function(e){var t;return"function"===e.slice(0,8)&&(40===(t=e.charCodeAt(8))||z.code.isWhiteSpace(t)||42===t||z.code.isLineTerminator(t))}(n)||function(e){var t,r,n;if("async"!==e.slice(0,5))return!1;if(!z.code.isWhiteSpace(e.charCodeAt(5)))return!1;for(r=6,n=e.length;r<n&&z.code.isWhiteSpace(e.charCodeAt(r));++r);return r!==n&&"function"===e.slice(r,r+8)&&(40===(t=e.charCodeAt(r+8))||z.code.isWhiteSpace(t)||42===t||z.code.isLineTerminator(t))}(n)||ie&&16&t&&e.expression.type===M.Literal&&"string"==typeof e.expression.value?r=["(",r,")"+this.semicolon(t)]:r.push(this.semicolon(t)),r},ImportDeclaration:function(e,t){var r,n,i=this;return 0===e.specifiers.length?["import",ee,this.generateExpression(e.source,q.Sequence,pe),this.semicolon(t)]:(r=["import"],n=0,e.specifiers[n].type===M.ImportDefaultSpecifier&&(r=w(r,[this.generateExpression(e.specifiers[n],q.Sequence,pe)]),++n),e.specifiers[n]&&(0!==n&&r.push(","),e.specifiers[n].type===M.ImportNamespaceSpecifier?r=w(r,[ee,this.generateExpression(e.specifiers[n],q.Sequence,pe)]):(r.push(ee+"{"),e.specifiers.length-n==1?(r.push(ee),r.push(this.generateExpression(e.specifiers[n],q.Sequence,pe)),r.push(ee+"}"+ee)):(E(function(t){var o,a;for(r.push(Z),o=n,a=e.specifiers.length;o<a;++o)r.push(t),r.push(i.generateExpression(e.specifiers[o],q.Sequence,pe)),o+1<a&&r.push(","+Z)}),c(_(r).toString())||r.push(Z),r.push(G+"}"+ee)))),r=w(r,["from"+ee,this.generateExpression(e.source,q.Sequence,pe),this.semicolon(t)]))},VariableDeclarator:function(e,t){var r=1&t?pe:6;return e.init?[this.generateExpression(e.id,q.Assignment,r),ee,"=",ee,this.generateExpression(e.init,q.Assignment,r)]:this.generatePattern(e.id,q.Assignment,r)},VariableDeclaration:function(e,t){function r(){for(a=e.declarations[0],oe.comment&&a.leadingComments?(n.push("\n"),n.push(k(u.generateStatement(a,s)))):(n.push(x()),n.push(u.generateStatement(a,s))),i=1,o=e.declarations.length;i<o;++i)a=e.declarations[i],oe.comment&&a.leadingComments?(n.push(","+Z),n.push(k(u.generateStatement(a,s)))):(n.push(","+ee),n.push(u.generateStatement(a,s)))}var n,i,o,a,s,u=this;return n=[e.kind],s=1&t?de:0,e.declarations.length>1?E(r):r(),n.push(this.semicolon(t)),n},ThrowStatement:function(e,t){return[w("throw",this.generateExpression(e.argument,q.Sequence,pe)),this.semicolon(t)]},TryStatement:function(e,t){var r,n,i,o;if(r=["try",this.maybeBlock(e.block,de)],r=this.maybeBlockSuffix(e.block,r),e.handlers)for(n=0,i=e.handlers.length;n<i;++n)r=w(r,this.generateStatement(e.handlers[n],de)),(e.finalizer||n+1!==i)&&(r=this.maybeBlockSuffix(e.handlers[n].body,r));else{for(n=0,i=(o=e.guardedHandlers||[]).length;n<i;++n)r=w(r,this.generateStatement(o[n],de)),(e.finalizer||n+1!==i)&&(r=this.maybeBlockSuffix(o[n].body,r));if(e.handler)if(V(e.handler))for(n=0,i=e.handler.length;n<i;++n)r=w(r,this.generateStatement(e.handler[n],de)),(e.finalizer||n+1!==i)&&(r=this.maybeBlockSuffix(e.handler[n].body,r));else r=w(r,this.generateStatement(e.handler,de)),e.finalizer&&(r=this.maybeBlockSuffix(e.handler.body,r))}return e.finalizer&&(r=w(r,["finally",this.maybeBlock(e.finalizer,de)])),r},SwitchStatement:function(e,t){var r,n,i,o,a,s=this;if(E(function(){r=["switch"+ee+"(",s.generateExpression(e.discriminant,q.Sequence,pe),")"+ee+"{"+Z]}),e.cases)for(a=de,i=0,o=e.cases.length;i<o;++i)i===o-1&&(a|=32),n=k(this.generateStatement(e.cases[i],a)),r.push(n),c(_(n).toString())||r.push(Z);return r.push(k("}")),r},SwitchCase:function(e,t){var r,n,i,o,a,s=this;return E(function(){for(r=e.test?[w("case",s.generateExpression(e.test,q.Sequence,pe)),":"]:["default:"],i=0,(o=e.consequent.length)&&e.consequent[0].type===M.BlockStatement&&(n=s.maybeBlock(e.consequent[0],de),r.push(n),i=1),i===o||c(_(r).toString())||r.push(Z),a=de;i<o;++i)i===o-1&&32&t&&(a|=32),n=k(s.generateStatement(e.consequent[i],a)),r.push(n),i+1===o||c(_(n).toString())||r.push(Z)}),r},IfStatement:function(e,t){var r,n,i,o=this;return E(function(){r=["if"+ee+"(",o.generateExpression(e.test,q.Sequence,pe),")"]}),i=32&t,n=de,i&&(n|=32),e.alternate?(r.push(this.maybeBlock(e.consequent,de)),r=this.maybeBlockSuffix(e.consequent,r),r=e.alternate.type===M.IfStatement?w(r,["else ",this.generateStatement(e.alternate,n)]):w(r,w("else",this.maybeBlock(e.alternate,n)))):r.push(this.maybeBlock(e.consequent,n)),r},ForStatement:function(e,t){var r,n=this;return E(function(){r=["for"+ee+"("],e.init?e.init.type===M.VariableDeclaration?r.push(n.generateStatement(e.init,0)):(r.push(n.generateExpression(e.init,q.Sequence,6)),r.push(";")):r.push(";"),e.test?(r.push(ee),r.push(n.generateExpression(e.test,q.Sequence,pe)),r.push(";")):r.push(";"),e.update?(r.push(ee),r.push(n.generateExpression(e.update,q.Sequence,pe)),r.push(")")):r.push(")")}),r.push(this.maybeBlock(e.body,32&t?33:de)),r},ForInStatement:function(e,t){return this.generateIterationForStatement("in",e,32&t?33:de)},ForOfStatement:function(e,t){return this.generateIterationForStatement("of",e,32&t?33:de)},LabeledStatement:function(e,t){return[e.label.name+":",this.maybeBlock(e.body,32&t?33:de)]},Program:function(e,t){var r,n,i,o,a;for(o=e.body.length,r=[ne&&o>0?"\n":""],a=17,i=0;i<o;++i)ne||i!==o-1||(a|=32),ce&&(0===i&&(e.body[0].leadingComments||F(e.range[0],e.body[i].range[0],r)),i>0&&(e.body[i-1].trailingComments||e.body[i].leadingComments||F(e.body[i-1].range[1],e.body[i].range[0],r))),n=k(this.generateStatement(e.body[i],a)),r.push(n),i+1<o&&!c(_(n).toString())&&(ce?e.body[i+1].leadingComments||r.push(Z):r.push(Z)),ce&&i===o-1&&(e.body[i].trailingComments||F(e.body[i].range[1],e.range[1],r));return r},FunctionDeclaration:function(e,t){return[T(e,!0),"function",I(e)||x(),e.id?P(e.id):"",this.generateFunctionBody(e)]},ReturnStatement:function(e,t){return e.argument?[w("return",this.generateExpression(e.argument,q.Sequence,pe)),this.semicolon(t)]:["return"+this.semicolon(t)]},WhileStatement:function(e,t){var r,n=this;return E(function(){r=["while"+ee+"(",n.generateExpression(e.test,q.Sequence,pe),")"]}),r.push(this.maybeBlock(e.body,32&t?33:de)),r},WithStatement:function(e,t){var r,n=this;return E(function(){r=["with"+ee+"(",n.generateExpression(e.object,q.Sequence,pe),")"]}),r.push(this.maybeBlock(e.body,32&t?33:de)),r}},l(B.prototype,B.Statement),B.Expression={SequenceExpression:function(e,t,r){var n,i,o;for(q.Sequence<t&&(r|=1),n=[],i=0,o=e.expressions.length;i<o;++i)n.push(this.generateExpression(e.expressions[i],q.Assignment,r)),i+1<o&&n.push(","+ee);return O(n,q.Sequence,t)},AssignmentExpression:function(e,t,r){return this.generateAssignment(e.left,e.right,e.operator,t,r)},ArrowFunctionExpression:function(e,t,r){return O(this.generateFunctionBody(e),q.ArrowFunction,t)},ConditionalExpression:function(e,t,r){return q.Conditional<t&&(r|=1),O([this.generateExpression(e.test,q.LogicalOR,r),ee+"?"+ee,this.generateExpression(e.consequent,q.Assignment,r),ee+":"+ee,this.generateExpression(e.alternate,q.Assignment,r)],q.Conditional,t)},LogicalExpression:function(e,t,r){return this.BinaryExpression(e,t,r)},BinaryExpression:function(e,t,r){var n,i,o,a;return(i=$[e.operator])<t&&(r|=1),o=this.generateExpression(e.left,i,r),a=o.toString(),n=47===a.charCodeAt(a.length-1)&&z.code.isIdentifierPartES5(e.operator.charCodeAt(0))?[o,x(),e.operator]:w(o,e.operator),o=this.generateExpression(e.right,i+1,r),"/"===e.operator&&"/"===o.toString().charAt(0)||"<"===e.operator.slice(-1)&&"!--"===o.toString().slice(0,3)?(n.push(x()),n.push(o)):n=w(n,o),"in"!==e.operator||1&r?O(n,i,t):["(",n,")"]},CallExpression:function(e,t,r){var n,i,o;for((n=[this.generateExpression(e.callee,q.Call,3)]).push("("),i=0,o=e.arguments.length;i<o;++i)n.push(this.generateExpression(e.arguments[i],q.Assignment,pe)),i+1<o&&n.push(","+ee);return n.push(")"),2&r?O(n,q.Call,t):["(",n,")"]},NewExpression:function(e,t,r){var n,i,o,a,s;if(i=e.arguments.length,s=4&r&&!te&&0===i?5:1,n=w("new",this.generateExpression(e.callee,q.New,s)),!(4&r)||te||i>0){for(n.push("("),o=0,a=i;o<a;++o)n.push(this.generateExpression(e.arguments[o],q.Assignment,pe)),o+1<a&&n.push(","+ee);n.push(")")}return O(n,q.New,t)},MemberExpression:function(e,t,r){var n,i;return n=[this.generateExpression(e.object,q.Call,2&r?3:1)],e.computed?(n.push("["),n.push(this.generateExpression(e.property,q.Sequence,2&r?pe:5)),n.push("]")):(e.object.type===M.Literal&&"number"==typeof e.object.value&&(i=_(n).toString()).indexOf(".")<0&&!/[eExX]/.test(i)&&z.code.isDecimalDigit(i.charCodeAt(i.length-1))&&!(i.length>=2&&48===i.charCodeAt(0))&&n.push("."),n.push("."),n.push(P(e.property))),O(n,q.Member,t)},MetaProperty:function(e,t,r){var n,i,o;return i="string"==typeof e.meta.type&&e.meta.type===M.Identifier?e.meta.name:e.meta,o="string"==typeof e.property.type&&e.property.type===M.Identifier?e.property.name:e.property,n=[i,".",o],O(n,q.Member,t)},UnaryExpression:function(e,t,r){var n,i,o,a,s;return i=this.generateExpression(e.argument,q.Unary,pe),""===ee?n=w(e.operator,i):(n=[e.operator],e.operator.length>2?n=w(n,i):(s=(a=_(n).toString()).charCodeAt(a.length-1),o=i.toString().charCodeAt(0),(43===s||45===s)&&s===o||z.code.isIdentifierPartES5(s)&&z.code.isIdentifierPartES5(o)?(n.push(x()),n.push(i)):n.push(i))),O(n,q.Unary,t)},YieldExpression:function(e,t,r){var n;return n=e.delegate?"yield*":"yield",e.argument&&(n=w(n,this.generateExpression(e.argument,q.Yield,pe))),O(n,q.Yield,t)},AwaitExpression:function(e,t,r){return O(w(e.all?"await*":"await",this.generateExpression(e.argument,q.Await,pe)),q.Await,t)},UpdateExpression:function(e,t,r){return e.prefix?O([e.operator,this.generateExpression(e.argument,q.Unary,pe)],q.Unary,t):O([this.generateExpression(e.argument,q.Postfix,pe),e.operator],q.Postfix,t)},FunctionExpression:function(e,t,r){var n=[T(e,!0),"function"];return e.id?(n.push(I(e)||x()),n.push(P(e.id))):n.push(I(e)||ee),n.push(this.generateFunctionBody(e)),n},ArrayPattern:function(e,t,r){return this.ArrayExpression(e,t,r,!0)},ArrayExpression:function(e,t,r,n){var i,o,a=this;return e.elements.length?(o=!n&&e.elements.length>1,i=["[",o?Z:""],E(function(t){var r,n;for(r=0,n=e.elements.length;r<n;++r)e.elements[r]?(i.push(o?t:""),i.push(a.generateExpression(e.elements[r],q.Assignment,pe))):(o&&i.push(t),r+1===n&&i.push(",")),r+1<n&&i.push(","+(o?Z:ee))}),o&&!c(_(i).toString())&&i.push(Z),i.push(o?G:""),i.push("]"),i):"[]"},RestElement:function(e,t,r){return"..."+this.generatePattern(e.argument)},ClassExpression:function(e,t,r){var n;return n=["class"],e.id&&(n=w(n,this.generateExpression(e.id,q.Sequence,pe))),e.superClass&&(n=w(n,w("extends",this.generateExpression(e.superClass,q.Assignment,pe)))),n.push(ee),n.push(this.generateStatement(e.body,33)),n},MethodDefinition:function(e,t,r){var n,i;return n=e.static?["static"+ee]:[],i="get"===e.kind||"set"===e.kind?[w(e.kind,this.generatePropertyKey(e.key,e.computed,e.value)),this.generateFunctionBody(e.value)]:[L(e),this.generatePropertyKey(e.key,e.computed,e.value),this.generateFunctionBody(e.value)],w(n,i)},Property:function(e,t,r){return"get"===e.kind||"set"===e.kind?[e.kind,x(),this.generatePropertyKey(e.key,e.computed,e.value),this.generateFunctionBody(e.value)]:e.shorthand?this.generatePropertyKey(e.key,e.computed,e.value):e.method?[L(e),this.generatePropertyKey(e.key,e.computed,e.value),this.generateFunctionBody(e.value)]:[this.generatePropertyKey(e.key,e.computed,e.value),":"+ee,this.generateExpression(e.value,q.Assignment,pe)]},ObjectExpression:function(e,t,r){var n,i,o,a=this;return e.properties.length?(n=e.properties.length>1,E(function(){o=a.generateExpression(e.properties[0],q.Sequence,pe)}),n||u(_(o).toString())?(E(function(t){var r,s;if(i=["{",Z,t,o],n)for(i.push(","+Z),r=1,s=e.properties.length;r<s;++r)i.push(t),i.push(a.generateExpression(e.properties[r],q.Sequence,pe)),r+1<s&&i.push(","+Z)}),c(_(i).toString())||i.push(Z),i.push(G),i.push("}"),i):["{",ee,o,ee,"}"]):"{}"},AssignmentPattern:function(e,t,r){return this.generateAssignment(e.left,e.right,"=",t,r)},ObjectPattern:function(e,t,r){var n,i,o,a,s,u=this;if(!e.properties.length)return"{}";if(a=!1,1===e.properties.length)"RestElement"!==(s=e.properties[0]).type&&s.value.type!==M.Identifier&&(a=!0);else for(i=0,o=e.properties.length;i<o;++i)if("RestElement"!==(s=e.properties[i]).type&&!s.shorthand){a=!0;break}return n=["{",a?Z:""],E(function(t){var r,i;for(r=0,i=e.properties.length;r<i;++r)n.push(a?t:""),n.push(u.generateExpression(e.properties[r],q.Sequence,pe)),r+1<i&&n.push(","+(a?Z:ee))}),a&&!c(_(n).toString())&&n.push(Z),n.push(a?G:""),n.push("}"),n},ThisExpression:function(e,t,r){return"this"},Super:function(e,t,r){return"super"},Identifier:function(e,t,r){return P(e)},ImportDefaultSpecifier:function(e,t,r){return P(e.id||e.local)},ImportNamespaceSpecifier:function(e,t,r){var n=["*"],i=e.id||e.local;return i&&n.push(ee+"as"+x()+P(i)),n},ImportSpecifier:function(e,t,r){var n=e.imported,i=[n.name],o=e.local;return o&&o.name!==n.name&&i.push(x()+"as"+x()+P(o)),i},ExportSpecifier:function(e,t,r){var n=e.local,i=[n.name],o=e.exported;return o&&o.name!==n.name&&i.push(x()+"as"+x()+P(o)),i},Literal:function(e,t,r){var n;if(e.hasOwnProperty("raw")&&ae&&oe.raw)try{if((n=ae(e.raw).body[0].expression).type===M.Literal&&n.value===e.value)return e.raw}catch(e){}return null===e.value?"null":"string"==typeof e.value?g(e.value):"number"==typeof e.value?p(e.value):"boolean"==typeof e.value?e.value?"true":"false":e.regex?"/"+e.regex.pattern+"/"+e.regex.flags:h(e.value)},GeneratorExpression:function(e,t,r){return this.ComprehensionExpression(e,t,r)},ComprehensionExpression:function(e,t,r){var n,i,o,a,s=this;return n=e.type===M.GeneratorExpression?["("]:["["],oe.moz.comprehensionExpressionStartsWithAssignment&&(a=this.generateExpression(e.body,q.Assignment,pe),n.push(a)),e.blocks&&E(function(){for(i=0,o=e.blocks.length;i<o;++i)a=s.generateExpression(e.blocks[i],q.Sequence,pe),i>0||oe.moz.comprehensionExpressionStartsWithAssignment?n=w(n,a):n.push(a)}),e.filter&&(n=w(n,"if"+ee),a=this.generateExpression(e.filter,q.Sequence,pe),n=w(n,["(",a,")"])),oe.moz.comprehensionExpressionStartsWithAssignment||(a=this.generateExpression(e.body,q.Assignment,pe),n=w(n,a)),n.push(e.type===M.GeneratorExpression?")":"]"),n},ComprehensionBlock:function(e,t,r){var n;return n=e.left.type===M.VariableDeclaration?[e.left.kind,x(),this.generateStatement(e.left.declarations[0],0)]:this.generateExpression(e.left,q.Call,pe),n=w(n,e.of?"of":"in"),n=w(n,this.generateExpression(e.right,q.Sequence,pe)),["for"+ee+"(",n,")"]},SpreadElement:function(e,t,r){return["...",this.generateExpression(e.argument,q.Assignment,pe)]},TaggedTemplateExpression:function(e,t,r){var n=3;return 2&r||(n=1),O([this.generateExpression(e.tag,q.Call,n),this.generateExpression(e.quasi,q.Primary,4)],q.TaggedTemplate,t)},TemplateElement:function(e,t,r){return e.value.raw},TemplateLiteral:function(e,t,r){var n,i,o;for(n=["`"],i=0,o=e.quasis.length;i<o;++i)n.push(this.generateExpression(e.quasis[i],q.Primary,pe)),i+1<o&&(n.push("${"+ee),n.push(this.generateExpression(e.expressions[i],q.Sequence,pe)),n.push(ee+"}"));return n.push("`"),n},ModuleSpecifier:function(e,t,r){return this.Literal(e,t,r)}},l(B.prototype,B.Expression),B.prototype.generateExpression=function(e,t,r){var n,i;return i=e.type||M.Property,oe.verbatim&&e.hasOwnProperty(oe.verbatim)?R(e,t):(n=this[i](e,t,r),oe.comment&&(n=C(e,n)),_(n,e))},B.prototype.generateStatement=function(e,t){var r,n;return r=this[e.type](e,t),oe.comment&&(r=C(e,r)),n=_(r).toString(),e.type!==M.Program||ne||""!==Z||"\n"!==n.charAt(n.length-1)||(r=se?_(r).replaceRight(/\s+$/,""):n.replace(/\s+$/,"")),_(r,e)},le={indent:{style:"",base:0},renumber:!0,hexadecimal:!0,quotes:"auto",escapeless:!0,compact:!0,parentheses:!1,semicolons:!1},fe=a().format,t.version=n("/package.json",e).version,t.generate=function(i,o){var u,c,l=a();return null!=o?("string"==typeof o.indent&&(l.format.indent.style=o.indent),"number"==typeof o.base&&(l.format.indent.base=o.base),o=f(l,o),H=o.format.indent.style,G="string"==typeof o.base?o.base:s(H,o.format.indent.base)):(H=(o=l).format.indent.style,G=s(H,o.format.indent.base)),J=o.format.json,K=o.format.renumber,Q=!J&&o.format.hexadecimal,Y=J?"double":o.format.quotes,X=o.format.escapeless,Z=o.format.newline,ee=o.format.space,o.format.compact&&(Z=ee=H=G=""),te=o.format.parentheses,re=o.format.semicolons,ne=o.format.safeConcatenation,ie=o.directive,ae=J?null:o.parse,se=o.sourceMap,ue=o.sourceCode,ce=o.format.preserveBlankLines&&null!==ue,oe=o,se&&(W=t.browser?r.sourceMap.SourceNode:n("/node_modules/source-map/lib/source-map.js",e).SourceNode),u=N(i),se?(c=u.toStringWithSourceMap({file:o.file,sourceRoot:o.sourceMapRoot}),o.sourceContent&&c.map.setSourceContent(o.sourceMap,o.sourceContent),o.sourceMapWithCode?c:c.map.toString()):(c={code:u.toString(),map:null},o.sourceMapWithCode?c:c.code)},t.attachComments=U.attachComments,t.Precedence=f({},q),t.browser=!1,t.FORMAT_MINIFY=le,t.FORMAT_DEFAULTS=fe}()}),n.define("/package.json",function(e,t,r,n){e.exports={name:"escodegen",description:"ECMAScript code generator",homepage:"http://github.com/estools/escodegen",main:"escodegen.js",bin:{esgenerate:"./bin/esgenerate.js",escodegen:"./bin/escodegen.js"},files:["LICENSE.BSD","LICENSE.source-map","README.md","bin","escodegen.js","package.json"],version:"1.8.1",engines:{node:">=0.12.0"},maintainers:[{name:"Yusuke Suzuki",email:"utatane.tea@gmail.com",web:"http://github.com/Constellation"}],repository:{type:"git",url:"http://github.com/estools/escodegen.git"},dependencies:{estraverse:"^1.9.1",esutils:"^2.0.2",esprima:"^2.7.1",optionator:"^0.8.1"},optionalDependencies:{"source-map":"~0.2.0"},devDependencies:{acorn:"^2.7.0",bluebird:"^2.3.11","bower-registry-client":"^0.2.1",chai:"^1.10.0","commonjs-everywhere":"^0.9.7",gulp:"^3.8.10","gulp-eslint":"^0.2.0","gulp-mocha":"^2.0.0",semver:"^5.1.0"},license:"BSD-2-Clause",scripts:{test:"gulp travis","unit-test":"gulp test",lint:"gulp lint",release:"node tools/release.js","build-min":"./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",build:"./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"}}}),n.define("/node_modules/source-map/lib/source-map.js",function(e,t,r,i){t.SourceMapGenerator=n("/node_modules/source-map/lib/source-map/source-map-generator.js",e).SourceMapGenerator,t.SourceMapConsumer=n("/node_modules/source-map/lib/source-map/source-map-consumer.js",e).SourceMapConsumer,t.SourceNode=n("/node_modules/source-map/lib/source-map/source-node.js",e).SourceNode}),n.define("/node_modules/source-map/lib/source-map/source-node.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e,t,r,n,i){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==i?null:i,this[s]=!0,null!=n&&this.add(n)}var i=e("/node_modules/source-map/lib/source-map/source-map-generator.js",r).SourceMapGenerator,o=e("/node_modules/source-map/lib/source-map/util.js",r),a=/(\r?\n)/,s="$$$isSourceNode$$$";n.fromStringWithSourceMap=function(e,t,r){function i(e,t){if(null===e||void 0===e.source)s.add(t);else{var i=r?o.join(r,e.source):e.source;s.add(new n(e.originalLine,e.originalColumn,i,t,e.name))}}var s=new n,u=e.split(a),c=function(){return u.shift()+(u.shift()||"")},l=1,f=0,p=null;return t.eachMapping(function(e){if(null!==p){if(!(l<e.generatedLine)){t=(r=u[0]).substr(0,e.generatedColumn-f);return u[0]=r.substr(e.generatedColumn-f),f=e.generatedColumn,i(p,t),void(p=e)}var t="";i(p,c()),l++,f=0}for(;l<e.generatedLine;)s.add(c()),l++;if(f<e.generatedColumn){var r=u[0];s.add(r.substr(0,e.generatedColumn)),u[0]=r.substr(e.generatedColumn),f=e.generatedColumn}p=e},this),u.length>0&&(p&&i(p,c()),s.add(u.join(""))),t.sources.forEach(function(e){var n=t.sourceContentFor(e);null!=n&&(null!=r&&(e=o.join(r,e)),s.setSourceContent(e,n))}),s},n.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[s]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},n.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[s]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},n.prototype.walk=function(e){for(var t,r=0,n=this.children.length;r<n;r++)(t=this.children[r])[s]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},n.prototype.join=function(e){var t,r,n=this.children.length;if(n>0){for(t=[],r=0;r<n-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},n.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[s]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},n.prototype.setSourceContent=function(e,t){this.sourceContents[o.toSetString(e)]=t},n.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][s]&&this.children[t].walkSourceContents(e);for(var n=Object.keys(this.sourceContents),t=0,r=n.length;t<r;t++)e(o.fromSetString(n[t]),this.sourceContents[n[t]])},n.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},n.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new i(e),n=!1,o=null,a=null,s=null,u=null;return this.walk(function(e,i){t.code+=e,null!==i.source&&null!==i.line&&null!==i.column?(o===i.source&&a===i.line&&s===i.column&&u===i.name||r.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name}),o=i.source,a=i.line,s=i.column,u=i.name,n=!0):n&&(r.addMapping({generated:{line:t.line,column:t.column}}),o=null,n=!1);for(var c=0,l=e.length;c<l;c++)10===e.charCodeAt(c)?(t.line++,t.column=0,c+1===l?(o=null,n=!1):n&&r.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}},t.SourceNode=n})}),n.define("/node_modules/source-map/lib/source-map/util.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e){var t=e.match(s);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function i(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function o(e){var t=e,r=n(e);if(r){if(!r.path)return e;t=r.path}for(var o,a="/"===t.charAt(0),s=t.split(/\/+/),u=0,c=s.length-1;c>=0;c--)"."===(o=s[c])?s.splice(c,1):".."===o?u++:u>0&&(""===o?(s.splice(c+1,u),u=0):(s.splice(c,2),u--));return""===(t=s.join("/"))&&(t=a?"/":"."),r?(r.path=t,i(r)):t}function a(e,t){var r=e||"",n=t||"";return(r>n)-(r<n)}t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var s=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,u=/^data:.+\,.+$/;t.urlParse=n,t.urlGenerate=i,t.normalize=o,t.join=function(e,t){""===e&&(e="."),""===t&&(t=".");var r=n(t),a=n(e);if(a&&(e=a.path||"/"),r&&!r.scheme)return a&&(r.scheme=a.scheme),i(r);if(r||t.match(u))return t;if(a&&!a.host&&!a.path)return a.host=t,i(a);var s="/"===t.charAt(0)?t:o(e.replace(/\/+$/,"")+"/"+t);return a?(a.path=s,i(a)):s},t.relative=function(e,t){""===e&&(e=".");var r=n(e=e.replace(/\/$/,""));return"/"==t.charAt(0)&&r&&"/"==r.path?t.slice(1):0===t.indexOf(e+"/")?t.substr(e.length+1):t},t.toSetString=function(e){return"$"+e},t.fromSetString=function(e){return e.substr(1)},t.compareByOriginalPositions=function(e,t,r){var n;return(n=a(e.source,t.source))?n:(n=e.originalLine-t.originalLine)?n:(n=e.originalColumn-t.originalColumn)||r?n:(n=a(e.name,t.name))?n:(n=e.generatedLine-t.generatedLine)||e.generatedColumn-t.generatedColumn},t.compareByGeneratedPositions=function(e,t,r){var n;return(n=e.generatedLine-t.generatedLine)?n:(n=e.generatedColumn-t.generatedColumn)||r?n:(n=a(e.source,t.source))?n:(n=e.originalLine-t.originalLine)?n:(n=e.originalColumn-t.originalColumn)||a(e.name,t.name)}})}),n.define("/node_modules/amdefine/amdefine.js",function(e,t,r,o){"use strict";e.exports=function(e,t){function r(e){var t,r;for(t=0;e[t];t+=1)if("."===(r=e[t]))e.splice(t,1),t-=1;else if(".."===r){if(1===t&&(".."===e[2]||".."===e[0]))break;t>0&&(e.splice(t-1,2),t-=2)}}function a(e,t){var n;return e&&"."===e.charAt(0)&&t&&(r(n=(n=(n=t.split("/")).slice(0,n.length-1)).concat(e.split("/"))),e=n.join("/")),e}function s(e){return function(t){return a(t,e)}}function u(e){function t(t){h[e]=t}return t.fromText=function(e,t){throw new Error("amdefine does not implement load.fromText")},t}function c(r,n,i){var a,s,u,c;if(r)s=h[r]={},a=f(t,s,u={id:r,uri:o,exports:s},r);else{if(m)throw new Error("amdefine with no module ID cannot be called more than once per file.");m=!0,s=e.exports,a=f(t,s,u=e,e.id)}n&&(n=n.map(function(e){return a(e)})),void 0!==(c="function"==typeof i?i.apply(u.exports,n):i)&&(u.exports=c,r&&(h[r]=u.exports))}function l(e,t,r){Array.isArray(e)?(r=t,t=e,e=void 0):"string"!=typeof e&&(r=e,e=t=void 0),t&&!Array.isArray(t)&&(r=t,t=void 0),t||(t=["require","exports","module"]),e?d[e]=[e,t,r]:c(e,t,r)}var f,p,d={},h={},m=!1,v=n("path",e);return f=function(e,t,r,n){function o(o,a){if("string"==typeof o)return p(e,t,r,o,n);o=o.map(function(i){return p(e,t,r,i,n)}),a&&i.nextTick(function(){a.apply(null,o)})}return o.toUrl=function(e){return 0===e.indexOf(".")?a(e,v.dirname(r.filename)):e},o},t=t||function(){return e.require.apply(e,arguments)},p=function(e,t,r,n,i){var o,l,m=n.indexOf("!"),v=n;if(-1===m){if("require"===(n=a(n,i)))return f(e,t,r,i);if("exports"===n)return t;if("module"===n)return r;if(h.hasOwnProperty(n))return h[n];if(d[n])return c.apply(null,d[n]),h[n];if(e)return e(v);throw new Error("No module with ID: "+n)}return o=n.substring(0,m),n=n.substring(m+1,n.length),l=p(e,t,r,o,i),n=l.normalize?l.normalize(n,s(i)):a(n,i),h[n]?h[n]:(l.load(n,f(e,t,r,i),u(n),{}),h[n])},l.require=function(e){return h[e]?h[e]:d[e]?(c.apply(null,d[e]),h[e]):void 0},l.amd={},l}}),n.define("/node_modules/source-map/lib/source-map/source-map-generator.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e){e||(e={}),this._file=o.getArg(e,"file",null),this._sourceRoot=o.getArg(e,"sourceRoot",null),this._skipValidation=o.getArg(e,"skipValidation",!1),this._sources=new a,this._names=new a,this._mappings=new s,this._sourcesContents=null}var i=e("/node_modules/source-map/lib/source-map/base64-vlq.js",r),o=e("/node_modules/source-map/lib/source-map/util.js",r),a=e("/node_modules/source-map/lib/source-map/array-set.js",r).ArraySet,s=e("/node_modules/source-map/lib/source-map/mapping-list.js",r).MappingList;n.prototype._version=3,n.fromSourceMap=function(e){var t=e.sourceRoot,r=new n({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var n={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(n.source=e.source,null!=t&&(n.source=o.relative(t,n.source)),n.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(n.name=e.name)),r.addMapping(n)}),e.sources.forEach(function(t){var n=e.sourceContentFor(t);null!=n&&r.setSourceContent(t,n)}),r},n.prototype.addMapping=function(e){var t=o.getArg(e,"generated"),r=o.getArg(e,"original",null),n=o.getArg(e,"source",null),i=o.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,n,i),null==n||this._sources.has(n)||this._sources.add(n),null==i||this._names.has(i)||this._names.add(i),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:n,name:i})},n.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=o.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents={}),this._sourcesContents[o.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[o.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},n.prototype.applySourceMap=function(e,t,r){var n=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');n=e.file}var i=this._sourceRoot;null!=i&&(n=o.relative(i,n));var s=new a,u=new a;this._mappings.unsortedForEach(function(t){if(t.source===n&&null!=t.originalLine){var a=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=a.source&&(t.source=a.source,null!=r&&(t.source=o.join(r,t.source)),null!=i&&(t.source=o.relative(i,t.source)),t.originalLine=a.line,t.originalColumn=a.column,null!=a.name&&(t.name=a.name))}var c=t.source;null==c||s.has(c)||s.add(c);var l=t.name;null==l||u.has(l)||u.add(l)},this),this._sources=s,this._names=u,e.sources.forEach(function(t){var n=e.sourceContentFor(t);null!=n&&(null!=r&&(t=o.join(r,t)),null!=i&&(t=o.relative(i,t)),this.setSourceContent(t,n))},this)},n.prototype._validateMapping=function(e,t,r,n){if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||n)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:n}))},n.prototype._serializeMappings=function(){for(var e,t=0,r=1,n=0,a=0,s=0,u=0,c="",l=this._mappings.toArray(),f=0,p=l.length;f<p;f++){if((e=l[f]).generatedLine!==r)for(t=0;e.generatedLine!==r;)c+=";",r++;else if(f>0){if(!o.compareByGeneratedPositions(e,l[f-1]))continue;c+=","}c+=i.encode(e.generatedColumn-t),t=e.generatedColumn,null!=e.source&&(c+=i.encode(this._sources.indexOf(e.source)-u),u=this._sources.indexOf(e.source),c+=i.encode(e.originalLine-1-a),a=e.originalLine-1,c+=i.encode(e.originalColumn-n),n=e.originalColumn,null!=e.name&&(c+=i.encode(this._names.indexOf(e.name)-s),s=this._names.indexOf(e.name)))}return c},n.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=o.relative(t,e));var r=o.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},n.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},n.prototype.toString=function(){return JSON.stringify(this)},t.SourceMapGenerator=n})}),n.define("/node_modules/source-map/lib/source-map/mapping-list.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e,t){var r=e.generatedLine,n=t.generatedLine,i=e.generatedColumn,a=t.generatedColumn;return n>r||n==r&&a>=i||o.compareByGeneratedPositions(e,t)<=0}function i(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}var o=e("/node_modules/source-map/lib/source-map/util.js",r);i.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},i.prototype.add=function(e){n(this._last,e)?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},i.prototype.toArray=function(){return this._sorted||(this._array.sort(o.compareByGeneratedPositions),this._sorted=!0),this._array},t.MappingList=i})}),n.define("/node_modules/source-map/lib/source-map/array-set.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(){this._array=[],this._set={}}var i=e("/node_modules/source-map/lib/source-map/util.js",r);n.fromArray=function(e,t){for(var r=new n,i=0,o=e.length;i<o;i++)r.add(e[i],t);return r},n.prototype.add=function(e,t){var r=this.has(e),n=this._array.length;r&&!t||this._array.push(e),r||(this._set[i.toSetString(e)]=n)},n.prototype.has=function(e){return Object.prototype.hasOwnProperty.call(this._set,i.toSetString(e))},n.prototype.indexOf=function(e){if(this.has(e))return this._set[i.toSetString(e)];throw new Error('"'+e+'" is not in the set.')},n.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},n.prototype.toArray=function(){return this._array.slice()},t.ArraySet=n})}),n.define("/node_modules/source-map/lib/source-map/base64-vlq.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e){return e<0?1+(-e<<1):0+(e<<1)}function i(e){var t=e>>1;return 1==(1&e)?-t:t}var o=e("/node_modules/source-map/lib/source-map/base64.js",r);t.encode=function(e){var t,r="",i=n(e);do{t=31&i,(i>>>=5)>0&&(t|=32),r+=o.encode(t)}while(i>0);return r},t.decode=function(e,t){var r,n,a=0,s=e.length,u=0,c=0;do{if(a>=s)throw new Error("Expected more digits in base 64 VLQ value.");r=!!(32&(n=o.decode(e.charAt(a++)))),u+=(n&=31)<<c,c+=5}while(r);t.value=i(u),t.rest=e.slice(a)}})}),n.define("/node_modules/source-map/lib/source-map/base64.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){var n={},i={};"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").forEach(function(e,t){n[e]=t,i[t]=e}),t.encode=function(e){if(e in i)return i[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){if(e in n)return n[e];throw new TypeError("Not a valid base 64 digit: "+e)}})}),n.define("/node_modules/source-map/lib/source-map/source-map-consumer.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(t){var n=t;return"string"==typeof t&&(n=JSON.parse(t.replace(/^\)\]\}'/,""))),null!=n.sections?new(e("/node_modules/source-map/lib/source-map/indexed-source-map-consumer.js",r).IndexedSourceMapConsumer)(n):new(e("/node_modules/source-map/lib/source-map/basic-source-map-consumer.js",r).BasicSourceMapConsumer)(n)}var i=e("/node_modules/source-map/lib/source-map/util.js",r);n.fromSourceMap=function(t){return e("/node_modules/source-map/lib/source-map/basic-source-map-consumer.js",r).BasicSourceMapConsumer.fromSourceMap(t)},n.prototype._version=3,n.prototype.__generatedMappings=null,Object.defineProperty(n.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,this.sourceRoot)),this.__generatedMappings}}),n.prototype.__originalMappings=null,Object.defineProperty(n.prototype,"_originalMappings",{get:function(){return this.__originalMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,this.sourceRoot)),this.__originalMappings}}),n.prototype._nextCharIsMappingSeparator=function(e){var t=e.charAt(0);return";"===t||","===t},n.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},n.GENERATED_ORDER=1,n.ORIGINAL_ORDER=2,n.prototype.eachMapping=function(e,t,r){var o,a=t||null;switch(r||n.GENERATED_ORDER){case n.GENERATED_ORDER:o=this._generatedMappings;break;case n.ORIGINAL_ORDER:o=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var s=this.sourceRoot;o.map(function(e){var t=e.source;return null!=t&&null!=s&&(t=i.join(s,t)),{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:e.name}}).forEach(e,a)},n.prototype.allGeneratedPositionsFor=function(e){var t={source:i.getArg(e,"source"),originalLine:i.getArg(e,"line"),originalColumn:1/0};null!=this.sourceRoot&&(t.source=i.relative(this.sourceRoot,t.source));var r=[],n=this._findMapping(t,this._originalMappings,"originalLine","originalColumn",i.compareByOriginalPositions);if(n>=0)for(var o=this._originalMappings[n];o&&o.originalLine===t.originalLine;)r.push({line:i.getArg(o,"generatedLine",null),column:i.getArg(o,"generatedColumn",null),lastColumn:i.getArg(o,"lastGeneratedColumn",null)}),o=this._originalMappings[--n];return r.reverse()},t.SourceMapConsumer=n})}),n.define("/node_modules/source-map/lib/source-map/basic-source-map-consumer.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=i.getArg(t,"version"),n=i.getArg(t,"sources"),o=i.getArg(t,"names",[]),s=i.getArg(t,"sourceRoot",null),u=i.getArg(t,"sourcesContent",null),c=i.getArg(t,"mappings"),l=i.getArg(t,"file",null);if(r!=this._version)throw new Error("Unsupported version: "+r);n=n.map(i.normalize),this._names=a.fromArray(o,!0),this._sources=a.fromArray(n,!0),this.sourceRoot=s,this.sourcesContent=u,this._mappings=c,this.file=l}var i=e("/node_modules/source-map/lib/source-map/util.js",r),o=e("/node_modules/source-map/lib/source-map/binary-search.js",r),a=e("/node_modules/source-map/lib/source-map/array-set.js",r).ArraySet,s=e("/node_modules/source-map/lib/source-map/base64-vlq.js",r),u=e("/node_modules/source-map/lib/source-map/source-map-consumer.js",r).SourceMapConsumer;(n.prototype=Object.create(u.prototype)).consumer=u,n.fromSourceMap=function(e){var t=Object.create(n.prototype);return t._names=a.fromArray(e._names.toArray(),!0),t._sources=a.fromArray(e._sources.toArray(),!0),t.sourceRoot=e._sourceRoot,t.sourcesContent=e._generateSourcesContent(t._sources.toArray(),t.sourceRoot),t.file=e._file,t.__generatedMappings=e._mappings.toArray().slice(),t.__originalMappings=e._mappings.toArray().slice().sort(i.compareByOriginalPositions),t},n.prototype._version=3,Object.defineProperty(n.prototype,"sources",{get:function(){return this._sources.toArray().map(function(e){return null!=this.sourceRoot?i.join(this.sourceRoot,e):e},this)}}),n.prototype._parseMappings=function(e,t){for(var r,n=1,o=0,a=0,u=0,c=0,l=0,f=e,p={};f.length>0;)if(";"===f.charAt(0))n++,f=f.slice(1),o=0;else if(","===f.charAt(0))f=f.slice(1);else{if(r={},r.generatedLine=n,s.decode(f,p),r.generatedColumn=o+p.value,o=r.generatedColumn,(f=p.rest).length>0&&!this._nextCharIsMappingSeparator(f)){if(s.decode(f,p),r.source=this._sources.at(c+p.value),c+=p.value,0===(f=p.rest).length||this._nextCharIsMappingSeparator(f))throw new Error("Found a source, but no line and column");if(s.decode(f,p),r.originalLine=a+p.value,a=r.originalLine,r.originalLine+=1,0===(f=p.rest).length||this._nextCharIsMappingSeparator(f))throw new Error("Found a source and line, but no column");s.decode(f,p),r.originalColumn=u+p.value,u=r.originalColumn,(f=p.rest).length>0&&!this._nextCharIsMappingSeparator(f)&&(s.decode(f,p),r.name=this._names.at(l+p.value),l+=p.value,f=p.rest)}this.__generatedMappings.push(r),"number"==typeof r.originalLine&&this.__originalMappings.push(r)}this.__generatedMappings.sort(i.compareByGeneratedPositions),this.__originalMappings.sort(i.compareByOriginalPositions)},n.prototype._findMapping=function(e,t,r,n,i){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[n]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[n]);return o.search(e,t,i)},n.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},n.prototype.originalPositionFor=function(e){var t={generatedLine:i.getArg(e,"line"),generatedColumn:i.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",i.compareByGeneratedPositions);if(r>=0){var n=this._generatedMappings[r];if(n.generatedLine===t.generatedLine){var o=i.getArg(n,"source",null);return null!=o&&null!=this.sourceRoot&&(o=i.join(this.sourceRoot,o)),{source:o,line:i.getArg(n,"originalLine",null),column:i.getArg(n,"originalColumn",null),name:i.getArg(n,"name",null)}}}return{source:null,line:null,column:null,name:null}},n.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(e=i.relative(this.sourceRoot,e)),this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];var r;if(null!=this.sourceRoot&&(r=i.urlParse(this.sourceRoot))){var n=e.replace(/^file:\/\//,"");if("file"==r.scheme&&this._sources.has(n))return this.sourcesContent[this._sources.indexOf(n)];if((!r.path||"/"==r.path)&&this._sources.has("/"+e))return this.sourcesContent[this._sources.indexOf("/"+e)]}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},n.prototype.generatedPositionFor=function(e){var t={source:i.getArg(e,"source"),originalLine:i.getArg(e,"line"),originalColumn:i.getArg(e,"column")};null!=this.sourceRoot&&(t.source=i.relative(this.sourceRoot,t.source));var r=this._findMapping(t,this._originalMappings,"originalLine","originalColumn",i.compareByOriginalPositions);if(r>=0){var n=this._originalMappings[r];return{line:i.getArg(n,"generatedLine",null),column:i.getArg(n,"generatedColumn",null),lastColumn:i.getArg(n,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},t.BasicSourceMapConsumer=n})}),n.define("/node_modules/source-map/lib/source-map/binary-search.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e,t,r,i,o){var a=Math.floor((t-e)/2)+e,s=o(r,i[a],!0);return 0===s?a:s>0?t-a>1?n(a,t,r,i,o):a:a-e>1?n(e,a,r,i,o):e<0?-1:e}t.search=function(e,t,r){return 0===t.length?-1:n(-1,t.length,e,t,r)}})}),n.define("/node_modules/source-map/lib/source-map/indexed-source-map-consumer.js",function(e,t,r,i){if("function"!=typeof o)var o=n("/node_modules/amdefine/amdefine.js",e)(e,n);o(function(e,t,r){function n(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=i.getArg(t,"version"),n=i.getArg(t,"sections");if(r!=this._version)throw new Error("Unsupported version: "+r);var o={line:-1,column:0};this._sections=n.map(function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var t=i.getArg(e,"offset"),r=i.getArg(t,"line"),n=i.getArg(t,"column");if(r<o.line||r===o.line&&n<o.column)throw new Error("Section offsets must be ordered and non-overlapping.");return o=t,{generatedOffset:{generatedLine:r+1,generatedColumn:n+1},consumer:new a(i.getArg(e,"map"))}})}var i=e("/node_modules/source-map/lib/source-map/util.js",r),o=e("/node_modules/source-map/lib/source-map/binary-search.js",r),a=e("/node_modules/source-map/lib/source-map/source-map-consumer.js",r).SourceMapConsumer;e("/node_modules/source-map/lib/source-map/basic-source-map-consumer.js",r).BasicSourceMapConsumer;(n.prototype=Object.create(a.prototype)).constructor=a,n.prototype._version=3,Object.defineProperty(n.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),n.prototype.originalPositionFor=function(e){var t={generatedLine:i.getArg(e,"line"),generatedColumn:i.getArg(e,"column")},r=o.search(t,this._sections,function(e,t){var r=e.generatedLine-t.generatedOffset.generatedLine;return r||e.generatedColumn-t.generatedOffset.generatedColumn}),n=this._sections[r];return n?n.consumer.originalPositionFor({line:t.generatedLine-(n.generatedOffset.generatedLine-1),column:t.generatedColumn-(n.generatedOffset.generatedLine===t.generatedLine?n.generatedOffset.generatedColumn-1:0)}):{source:null,line:null,column:null,name:null}},n.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var n=this._sections[r].consumer.sourceContentFor(e,!0);if(n)return n}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},n.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer.sources.indexOf(i.getArg(e,"source"))){var n=r.consumer.generatedPositionFor(e);if(n)return{line:n.line+(r.generatedOffset.generatedLine-1),column:n.column+(r.generatedOffset.generatedLine===n.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},n.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var n=this._sections[r],o=n.consumer._generatedMappings,a=0;a<o.length;a++){var s=o[r],u=s.source,c=n.consumer.sourceRoot;null!=u&&null!=c&&(u=i.join(c,u));var l={source:u,generatedLine:s.generatedLine+(n.generatedOffset.generatedLine-1),generatedColumn:s.column+(n.generatedOffset.generatedLine===s.generatedLine)?n.generatedOffset.generatedColumn-1:0,originalLine:s.originalLine,originalColumn:s.originalColumn,name:s.name};this.__generatedMappings.push(l),"number"==typeof l.originalLine&&this.__originalMappings.push(l)}this.__generatedMappings.sort(i.compareByGeneratedPositions),this.__originalMappings.sort(i.compareByOriginalPositions)},t.IndexedSourceMapConsumer=n})}),n.define("/node_modules/esutils/lib/utils.js",function(e,t,r,i){!function(){"use strict";t.ast=n("/node_modules/esutils/lib/ast.js",e),t.code=n("/node_modules/esutils/lib/code.js",e),t.keyword=n("/node_modules/esutils/lib/keyword.js",e)}()}),n.define("/node_modules/esutils/lib/keyword.js",function(e,t,r,i){!function(){"use strict";function t(e){switch(e){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return!0;default:return!1}}function r(e,t){return!(!t&&"yield"===e)&&i(e,t)}function i(e,r){if(r&&t(e))return!0;switch(e.length){case 2:return"if"===e||"in"===e||"do"===e;case 3:return"var"===e||"for"===e||"new"===e||"try"===e;case 4:return"this"===e||"else"===e||"case"===e||"void"===e||"with"===e||"enum"===e;case 5:return"while"===e||"break"===e||"catch"===e||"throw"===e||"const"===e||"yield"===e||"class"===e||"super"===e;case 6:return"return"===e||"typeof"===e||"delete"===e||"switch"===e||"export"===e||"import"===e;case 7:return"default"===e||"finally"===e||"extends"===e;case 8:return"function"===e||"continue"===e||"debugger"===e;case 10:return"instanceof"===e;default:return!1}}function o(e,t){return"null"===e||"true"===e||"false"===e||r(e,t)}function a(e,t){return"null"===e||"true"===e||"false"===e||i(e,t)}function s(e){var t,r,n;if(0===e.length)return!1;if(n=e.charCodeAt(0),!l.isIdentifierStartES5(n))return!1;for(t=1,r=e.length;t<r;++t)if(n=e.charCodeAt(t),!l.isIdentifierPartES5(n))return!1;return!0}function u(e,t){return 1024*(e-55296)+(t-56320)+65536}function c(e){var t,r,n,i,o;if(0===e.length)return!1;for(o=l.isIdentifierStartES6,t=0,r=e.length;t<r;++t){if(55296<=(n=e.charCodeAt(t))&&n<=56319){if(++t>=r)return!1;if(!(56320<=(i=e.charCodeAt(t))&&i<=57343))return!1;n=u(n,i)}if(!o(n))return!1;o=l.isIdentifierPartES6}return!0}var l=n("/node_modules/esutils/lib/code.js",e);e.exports={isKeywordES5:r,isKeywordES6:i,isReservedWordES5:o,isReservedWordES6:a,isRestrictedWord:function(e){return"eval"===e||"arguments"===e},isIdentifierNameES5:s,isIdentifierNameES6:c,isIdentifierES5:function(e,t){return s(e)&&!o(e,t)},isIdentifierES6:function(e,t){return c(e)&&!a(e,t)}}}()}),n.define("/node_modules/esutils/lib/code.js",function(e,t,r,n){!function(){"use strict";function t(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(Math.floor((e-65536)/1024)+55296)+String.fromCharCode((e-65536)%1024+56320)}var r,n,i,o,a,s;for(n={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},r={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},i=[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],o=new Array(128),s=0;s<128;++s)o[s]=s>=97&&s<=122||s>=65&&s<=90||36===s||95===s;for(a=new Array(128),s=0;s<128;++s)a[s]=s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||36===s||95===s;e.exports={isDecimalDigit:function(e){return 48<=e&&e<=57},isHexDigit:function(e){return 48<=e&&e<=57||97<=e&&e<=102||65<=e&&e<=70},isOctalDigit:function(e){return e>=48&&e<=55},isWhiteSpace:function(e){return 32===e||9===e||11===e||12===e||160===e||e>=5760&&i.indexOf(e)>=0},isLineTerminator:function(e){return 10===e||13===e||8232===e||8233===e},isIdentifierStartES5:function(e){return e<128?o[e]:n.NonAsciiIdentifierStart.test(t(e))},isIdentifierPartES5:function(e){return e<128?a[e]:n.NonAsciiIdentifierPart.test(t(e))},isIdentifierStartES6:function(e){return e<128?o[e]:r.NonAsciiIdentifierStart.test(t(e))},isIdentifierPartES6:function(e){return e<128?a[e]:r.NonAsciiIdentifierPart.test(t(e))}}}()}),n.define("/node_modules/esutils/lib/ast.js",function(e,t,r,n){!function(){"use strict";function t(e){if(null==e)return!1;switch(e.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return!0}return!1}function r(e){switch(e.type){case"IfStatement":return null!=e.alternate?e.alternate:e.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return e.body}return null}e.exports={isExpression:function(e){if(null==e)return!1;switch(e.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return!0}return!1},isStatement:t,isIterationStatement:function(e){if(null==e)return!1;switch(e.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return!0}return!1},isSourceElement:function(e){return t(e)||null!=e&&"FunctionDeclaration"===e.type},isProblematicIfStatement:function(e){var t;if("IfStatement"!==e.type)return!1;if(null==e.alternate)return!1;t=e.consequent;do{if("IfStatement"===t.type&&null==t.alternate)return!0;t=r(t)}while(t);return!1},trailingStatement:r}}()}),n.define("/node_modules/estraverse/estraverse.js",function(t,r,n,i){!function(t,n){"use strict";"function"==typeof e&&e.amd?e(["exports"],n):n(void 0!==r?r:t.estraverse={})}(this,function e(t){"use strict";function r(){}function n(e){var t,r,i={};for(t in e)e.hasOwnProperty(t)&&(r=e[t],i[t]="object"==typeof r&&null!==r?n(r):r);return i}function i(e,t){var r,n,i,o;for(n=e.length,i=0;n;)t(e[o=i+(r=n>>>1)])?n=r:(i=o+1,n-=r+1);return i}function o(e,t){var r,n,i,o=g(t);for(n=0,i=o.length;n<i;n+=1)e[r=o[n]]=t[r];return e}function a(e,t){this.parent=e,this.key=t}function s(e,t,r,n){this.node=e,this.path=t,this.wrap=r,this.ref=n}function u(){}function c(e){return null!=e&&("object"==typeof e&&"string"==typeof e.type)}function l(e,t){return(e===d.ObjectExpression||e===d.ObjectPattern)&&"properties"===t}function f(e,t){return(new u).traverse(e,t)}function p(e,t){var r;return r=i(t,function(t){return t.range[0]>e.range[0]}),e.extendedRange=[e.range[0],e.range[1]],r!==t.length&&(e.extendedRange[1]=t[r].range[0]),(r-=1)>=0&&(e.extendedRange[0]=t[r].range[1]),e}var d,h,m,v,y,g,b,_,x;return(h=Array.isArray)||(h=function(e){return"[object Array]"===Object.prototype.toString.call(e)}),r(),r(),y=Object.create||function(){function e(){}return function(t){return e.prototype=t,new e}}(),g=Object.keys||function(e){var t,r=[];for(t in e)r.push(t);return r},d={AssignmentExpression:"AssignmentExpression",ArrayExpression:"ArrayExpression",ArrayPattern:"ArrayPattern",ArrowFunctionExpression:"ArrowFunctionExpression",AwaitExpression:"AwaitExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ClassBody:"ClassBody",ClassDeclaration:"ClassDeclaration",ClassExpression:"ClassExpression",ComprehensionBlock:"ComprehensionBlock",ComprehensionExpression:"ComprehensionExpression",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DebuggerStatement:"DebuggerStatement",DirectiveStatement:"DirectiveStatement",DoWhileStatement:"DoWhileStatement",EmptyStatement:"EmptyStatement",ExportBatchSpecifier:"ExportBatchSpecifier",ExportDeclaration:"ExportDeclaration",ExportSpecifier:"ExportSpecifier",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",ForOfStatement:"ForOfStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",GeneratorExpression:"GeneratorExpression",Identifier:"Identifier",IfStatement:"IfStatement",ImportDeclaration:"ImportDeclaration",ImportDefaultSpecifier:"ImportDefaultSpecifier",ImportNamespaceSpecifier:"ImportNamespaceSpecifier",ImportSpecifier:"ImportSpecifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",MethodDefinition:"MethodDefinition",ModuleSpecifier:"ModuleSpecifier",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",ObjectPattern:"ObjectPattern",Program:"Program",Property:"Property",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SpreadElement:"SpreadElement",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",TaggedTemplateExpression:"TaggedTemplateExpression",TemplateElement:"TemplateElement",TemplateLiteral:"TemplateLiteral",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement",YieldExpression:"YieldExpression"},v={AssignmentExpression:["left","right"],ArrayExpression:["elements"],ArrayPattern:["elements"],ArrowFunctionExpression:["params","defaults","rest","body"],AwaitExpression:["argument"],BlockStatement:["body"],BinaryExpression:["left","right"],BreakStatement:["label"],CallExpression:["callee","arguments"],CatchClause:["param","body"],ClassBody:["body"],ClassDeclaration:["id","body","superClass"],ClassExpression:["id","body","superClass"],ComprehensionBlock:["left","right"],ComprehensionExpression:["blocks","filter","body"],ConditionalExpression:["test","consequent","alternate"],ContinueStatement:["label"],DebuggerStatement:[],DirectiveStatement:[],DoWhileStatement:["body","test"],EmptyStatement:[],ExportBatchSpecifier:[],ExportDeclaration:["declaration","specifiers","source"],ExportSpecifier:["id","name"],ExpressionStatement:["expression"],ForStatement:["init","test","update","body"],ForInStatement:["left","right","body"],ForOfStatement:["left","right","body"],FunctionDeclaration:["id","params","defaults","rest","body"],FunctionExpression:["id","params","defaults","rest","body"],GeneratorExpression:["blocks","filter","body"],Identifier:[],IfStatement:["test","consequent","alternate"],ImportDeclaration:["specifiers","source"],ImportDefaultSpecifier:["id"],ImportNamespaceSpecifier:["id"],ImportSpecifier:["id","name"],Literal:[],LabeledStatement:["label","body"],LogicalExpression:["left","right"],MemberExpression:["object","property"],MethodDefinition:["key","value"],ModuleSpecifier:[],NewExpression:["callee","arguments"],ObjectExpression:["properties"],ObjectPattern:["properties"],Program:["body"],Property:["key","value"],ReturnStatement:["argument"],SequenceExpression:["expressions"],SpreadElement:["argument"],SwitchStatement:["discriminant","cases"],SwitchCase:["test","consequent"],TaggedTemplateExpression:["tag","quasi"],TemplateElement:[],TemplateLiteral:["quasis","expressions"],ThisExpression:[],ThrowStatement:["argument"],TryStatement:["block","handlers","handler","guardedHandlers","finalizer"],UnaryExpression:["argument"],UpdateExpression:["argument"],VariableDeclaration:["declarations"],VariableDeclarator:["id","init"],WhileStatement:["test","body"],WithStatement:["object","body"],YieldExpression:["argument"]},b={},_={},x={},m={Break:b,Skip:_,Remove:x},a.prototype.replace=function(e){this.parent[this.key]=e},a.prototype.remove=function(){return h(this.parent)?(this.parent.splice(this.key,1),!0):(this.replace(null),!1)},u.prototype.path=function(){function e(e,t){if(h(t))for(n=0,i=t.length;n<i;++n)e.push(t[n]);else e.push(t)}var t,r,n,i,o;if(!this.__current.path)return null;for(o=[],t=2,r=this.__leavelist.length;t<r;++t)e(o,this.__leavelist[t].path);return e(o,this.__current.path),o},u.prototype.type=function(){return this.current().type||this.__current.wrap},u.prototype.parents=function(){var e,t,r;for(r=[],e=1,t=this.__leavelist.length;e<t;++e)r.push(this.__leavelist[e].node);return r},u.prototype.current=function(){return this.__current.node},u.prototype.__execute=function(e,t){var r,n;return n=void 0,r=this.__current,this.__current=t,this.__state=null,e&&(n=e.call(this,t.node,this.__leavelist[this.__leavelist.length-1].node)),this.__current=r,n},u.prototype.notify=function(e){this.__state=e},u.prototype.skip=function(){this.notify(_)},u.prototype.break=function(){this.notify(b)},u.prototype.remove=function(){this.notify(x)},u.prototype.__initialize=function(e,t){this.visitor=t,this.root=e,this.__worklist=[],this.__leavelist=[],this.__current=null,this.__state=null,this.__fallback="iteration"===t.fallback,this.__keys=v,t.keys&&(this.__keys=o(y(this.__keys),t.keys))},u.prototype.traverse=function(e,t){var r,n,i,o,a,u,f,p,d,m,v,y;for(this.__initialize(e,t),y={},r=this.__worklist,n=this.__leavelist,r.push(new s(e,null,null,null)),n.push(new s(null,null,null,null));r.length;)if((i=r.pop())!==y){if(i.node){if(u=this.__execute(t.enter,i),this.__state===b||u===b)return;if(r.push(y),n.push(i),this.__state===_||u===_)continue;if(o=i.node,a=i.wrap||o.type,!(m=this.__keys[a])){if(!this.__fallback)throw new Error("Unknown node type "+a+".");m=g(o)}for(p=m.length;(p-=1)>=0;)if(f=m[p],v=o[f])if(h(v)){for(d=v.length;(d-=1)>=0;)if(v[d]){if(l(a,m[p]))i=new s(v[d],[f,d],"Property",null);else{if(!c(v[d]))continue;i=new s(v[d],[f,d],null,null)}r.push(i)}}else c(v)&&r.push(new s(v,f,null,null))}}else if(i=n.pop(),u=this.__execute(t.leave,i),this.__state===b||u===b)return},u.prototype.replace=function(e,t){function r(e){var t,r,i,o;if(e.ref.remove())for(r=e.ref.key,o=e.ref.parent,t=n.length;t--;)if((i=n[t]).ref&&i.ref.parent===o){if(i.ref.key<r)break;--i.ref.key}}var n,i,o,u,f,p,d,m,v,y,w,k,E;for(this.__initialize(e,t),w={},n=this.__worklist,i=this.__leavelist,p=new s(e,null,null,new a(k={root:e},"root")),n.push(p),i.push(p);n.length;)if((p=n.pop())!==w){if(void 0!==(f=this.__execute(t.enter,p))&&f!==b&&f!==_&&f!==x&&(p.ref.replace(f),p.node=f),this.__state!==x&&f!==x||(r(p),p.node=null),this.__state===b||f===b)return k.root;if((o=p.node)&&(n.push(w),i.push(p),this.__state!==_&&f!==_)){if(u=p.wrap||o.type,!(v=this.__keys[u])){if(!this.__fallback)throw new Error("Unknown node type "+u+".");v=g(o)}for(d=v.length;(d-=1)>=0;)if(E=v[d],y=o[E])if(h(y)){for(m=y.length;(m-=1)>=0;)if(y[m]){if(l(u,v[d]))p=new s(y[m],[E,m],"Property",new a(y,m));else{if(!c(y[m]))continue;p=new s(y[m],[E,m],null,new a(y,m))}n.push(p)}}else c(y)&&n.push(new s(y,E,null,new a(o,E)))}}else if(p=i.pop(),void 0!==(f=this.__execute(t.leave,p))&&f!==b&&f!==_&&f!==x&&p.ref.replace(f),this.__state!==x&&f!==x||r(p),this.__state===b||f===b)return k.root;return k.root},t.version="1.8.1-dev",t.Syntax=d,t.traverse=f,t.replace=function(e,t){return(new u).replace(e,t)},t.attachComments=function(e,t,r){var i,o,a,s,u=[];if(!e.range)throw new Error("attachComments needs range information");if(!r.length){if(t.length){for(a=0,o=t.length;a<o;a+=1)(i=n(t[a])).extendedRange=[0,e.range[0]],u.push(i);e.leadingComments=u}return e}for(a=0,o=t.length;a<o;a+=1)u.push(p(n(t[a]),r));return s=0,f(e,{enter:function(e){for(var t;s<u.length&&!((t=u[s]).extendedRange[1]>e.range[0]);)t.extendedRange[1]===e.range[0]?(e.leadingComments||(e.leadingComments=[]),e.leadingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?m.Break:u[s].extendedRange[0]>e.range[1]?m.Skip:void 0}}),s=0,f(e,{leave:function(e){for(var t;s<u.length&&(t=u[s],!(e.range[1]<t.extendedRange[0]));)e.range[1]===t.extendedRange[0]?(e.trailingComments||(e.trailingComments=[]),e.trailingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?m.Break:u[s].extendedRange[0]>e.range[1]?m.Skip:void 0}}),e},t.VisitorKeys=v,t.VisitorOption=m,t.Controller=u,t.cloneEnvironment=function(){return e({})},t})}),n("/tools/entry-point.js")}).call(t,t)}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this)}(),function(){this.lively=this.lively||{},function(e,t,r,n){"use strict";function i(){}function o(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={style:"  ",base:0,adjustMultilineComment:!1,optsIndent:r&&r.format&&r.format.indent||{}},i=r&&r.format||{},o=ue({indent:n,quotes:"double"},t.obj.dissoc(i,["indent"]));return r=ue({format:o,comment:!1},t.obj.dissoc(r,["format"])),ge.generate(e,r)}function a(e,r,n,i){var o=(i=i||{}).traversal||"preorder",a=t.obj.clone(i.visitors?i.visitors:be.make(be.visitors.withMemberExpression)),s="preorder"===o?function(e,t,i,o,a){return r(i,n,o,t),e(i,o+1,a)}:function(e,t,i,o,a){var s=e(i,o+1,a);return r(i,n,o,t),s};return Object.keys(a).forEach(function(e){var t=a[e];a[e]=function(r,n,i){return s(t,e,r,n,i)}}),be.recursive(e,0,null,a),e}function s(e,r,n,i){var o=[];return i=i||be.make(be.visitors.withMemberExpression),Object.keys(be.base).forEach(function(e){var r=i[e];i[e]=function(e,n,i){return t.arr.pushIfNotIncluded(o,e),r(e,n,i)}}),i.Property=function(e,r,n){t.arr.pushIfNotIncluded(o,e),n(e.key,r,"Expression"),n(e.value,r,"Expression")},i.LabeledStatement=function(e,t,r){e.label&&r(e.label,t,"Expression"),r(e.body,t,"Statement")},be.findNodeAround(e,r,n,i),o}function u(e){return De(e,{index:0},function(e,t,r){e(),t.astIndex=r.index++}),e}function c(e){if(Array.isArray(e.body))for(var t=e.body.length-1;t>=0;t--){var r=e.body[t];"BlockStatement"===r.type&&r[ke]&&e.body.splice.apply(e.body,[t,1].concat(r.body))}return e}function l(e,t){return"string"==typeof e&&(t=e,e=d(e)),t&&xe.run(e,function(e,r,n){return!e.source&&(e.source=t.slice(e.start,e.end))}),e}function f(e,t){return t="string"==typeof t?this.parse(t):t,s(t,e)}function p(e,t){(t=t||{}).ecmaVersion=t.ecmaVersion||8,t.sourceType=t.sourceType||"module",t.plugins=t.plugins||{},t.plugins.asyncawait=t.plugins.hasOwnProperty("asyncawait")?t.plugins.asyncawait:{inAsyncFunction:!0},t.plugins.objectSpread=!t.plugins.hasOwnProperty("objectSpread")||t.plugins.objectSpread;var r,n,i;"LabeledStatement"===t.type&&(n="$={"+e+"}");try{r=d(n||e,t),n?r=null:t.addSource&&l(r,e)}catch(e){i=e}if(i&&void 0!==i.raisedAt){n&&(i.pos-=3,i.raisedAt-=3,i.loc.column-=3);var o="";o+=e.slice(i.raisedAt-20,i.raisedAt),o+="<-error->",o+=e.slice(i.raisedAt,i.raisedAt+20),t.verbose&&show("parse error: "+o),i.parseErrorSource=o}else i&&t.verbose&&show(""+i+i.stack);return r||(r=_e.parse_dammit(e,t),t.addSource&&l(r,e),r.isFuzzy=!0,r.parseError=i),r}function d(e,r){function n(e){return o.forEach(function(r){var n=t.arr.detect(f(r.start,a).reverse(),function(e){return"BlockStatement"===e.type||"Program"===e.type});n||(n=a),n.comments||(n.comments=[]),n.comments.push(r),e.nodesWithComments.push(n)}),e}function i(r){return r.nodesWithComments.forEach(function(n){t.arr.clone(n.comments).reduce(function(i,o){if(o.isBlock)return i.lastComment=null,i;if(!i.lastComment)return i.lastComment=o,i;var a=i.lastComment;if(t.arr.detect(n.body,function(e){return e.start>=a.end&&e.end<=o.start}))return i.lastComment=o,i;var s=e.slice(a.end,o.start);return/[\n\r][\n\r]+/.test(s)?(i.lastComment=o,i):(a.text+="\n"+o.text,a.end=o.end,t.arr.remove(n.comments,o),t.arr.remove(r.comments,o),i)},{lastComment:null})}),r}if(r=r||{},r.ecmaVersion=r.ecmaVersion||8,r.sourceType=r.sourceType||"module",r.hasOwnProperty("allowImportExportEverywhere")||(r.allowImportExportEverywhere=!0),r.plugins=r.plugins||{},r.plugins.asyncawait=r.plugins.hasOwnProperty("asyncawait")?r.plugins.asyncawait:{inAsyncFunction:!0},r.plugins.objectSpread=!r.plugins.hasOwnProperty("objectSpread")||r.plugins.objectSpread,r.withComments){delete r.withComments;var o=[];r.onComment=function(e,t,r,n,i,a){o.push({isBlock:e,text:t,node:null,start:r,end:n,line:i,column:a})}}try{var a=acorn.parse(e,r)}catch(t){if("undefined"!=typeof SyntaxError&&t instanceof SyntaxError&&t.loc){var s=e.split("\n"),c=t.message,p=t.loc,d=p.line,h=p.column,m=t.pos,v=s[d-1],y="Syntax error at line "+d+" column "+h+" (index "+m+') "'+c+'"\nsource: '+v.slice(0,h)+"<--SyntaxError--\x3e"+v.slice(h),g=new SyntaxError(y);throw g.loc={line:d,column:h},g.pos=m,g}throw t}return r.addSource&&l(a,e),r.addAstIndex&&!a.hasOwnProperty("astIndex")&&u(a),a&&o&&function(e){e=i(n(e)),a.allComments=e.comments}({ast:a,comments:o,nodesWithComments:[]}),a}function h(e){return Re.test(e)&&-1===e.indexOf("-")}function m(e){return"this"===e?{type:"ThisExpression"}:{name:String(e),type:"Identifier"}}function v(e){return{type:"Literal",value:e}}function y(e){return{type:"ExpressionStatement",expression:e}}function g(e){return{type:"ReturnStatement",argument:e}}function b(e){for(var t=arguments.length,r=Array(t>2?t-2:0),n=2;n<t;n++)r[n-2]=arguments[n];var i=e.arrow,o=e.id,a=e.expression,s=e.generator,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return u=u.map(function(e){return"string"==typeof e?m(e):e}),{type:(i?"Arrow":"")+"FunctionExpression",id:o?"string"==typeof o?m(o):o:void 0,params:u,body:{body:r,type:"BlockStatement"},expression:a||!1,generator:s||!1}}function _(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return"string"==typeof e&&(e=m(e)),{type:"CallExpression",callee:e,arguments:r}}function x(e,t,r){return"string"==typeof e&&(e={name:e,type:"Identifier"}),{type:"VariableDeclaration",kind:r||"var",declarations:[{type:"VariableDeclarator",id:e,init:t}]}}function w(e,t,r){return"string"==typeof e&&(e=m(e)),"string"==typeof t?(r||h(t)||(r=!0),t=r?v(t):m(t)):"number"==typeof t?(t=v(t),r=!0):"Literal"===t.type&&(r=!0),{type:"MemberExpression",computed:!!r,object:e,property:t}}function k(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return r.reduce(function(e,t){return w(e,t)},"object"===(void 0===e?"undefined":oe(e))?e:m(e))}function E(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return{body:Array.isArray(t[0])?t[0]:t,type:"BlockStatement"}}function S(){return Object.assign(E.apply(void 0,arguments),{sourceType:"module",type:"Program"})}function A(e,t,r){for(var n=arguments.length,i=Array(n>3?n-3:0),o=3;o<n;o++)i[o-3]=arguments[o];return Array.isArray(r)||(i.unshift(r),r=null),{block:E(i),finalizer:r?E(r):null,handler:{body:E(t),param:m(e),type:"CatchClause"},type:"TryStatement"}}function D(e,t){return{type:"Property",key:e,computed:"Identifier"!==e.type,shorthand:!1,value:t}}function C(e){var t=new ye,r=t.newScope(e,null);return t.accept(e,r,[]),r}function F(e,r){return t.tree.filter(C(e),function(e){var t=e.node,n=t.start,i=t.end;return"FunctionDeclaration"===t.type&&(n=t.params.length?t.params[0].start:t.body.start,i=t.body.end),n<=r&&r<=i},function(e){return e.subScopes})}function O(e,t){return(t&&e.node.id&&e.node.id.name?[e.node.id]:[]).concat(Pe.declIds(e.params)).concat(e.funcDecls.map(function(e){return e.id})).concat(Pe.varDeclIds(e)).concat(e.catches).concat(e.classDecls.map(function(e){return e.id})).concat(e.importSpecifiers)}function j(e){var t=Pe.declIds(e.params).concat(e.catches),r=(e.node.id&&e.node.id.name?[e.node]:[]).concat(e.funcDecls).concat(e.classDecls);return t.map(function(e){return[e,e]}).concat(r.map(function(e){return[e,e.id]})).concat(Pe.varDecls(e)).concat(e.importSpecifiers.map(function(t){return[M(e.node,t),t]}))}function R(e,r){return t.arr.pluck(O(e,!0),"name").concat(r?B("Program"===e.node.type?e.node:e.node.body):[])}function B(e){return e&&e.comments?t.arr.flatten(e.comments.filter(function(e){return e.text.trim().match(/^global/)}).map(function(e){return t.arr.invoke(e.text.replace(/^\s*global\s*/,"").split(","),"trim")})):[]}function P(e){return we.run(e)}function T(e,t){if(0==t.length)return[null,null];var r=de(t),n=r[0],i=r.slice(1),o=n.decls||j(n);return n.decls=o,o.find(function(t){var r=pe(t,2);r[0];return r[1].name==e})||T(e,i)}function I(e){function t(e,n){var i=[e].concat(n);e.refs.forEach(function(e){var t=T(e.name,i),n=pe(t,2),o=n[0],a=n[1];r.set(e,{decl:o,declId:a,ref:e})}),e.subScopes.forEach(function(e){return t(e,i)})}if(e.referencesResolvedSafely)return e;var r=e.resolvedRefMap||(e.resolvedRefMap=new Map);return t(e,[]),e.referencesResolvedSafely=!0,e}function L(e,r){function n(e){var t=R(e,o);return e.subScopes.map(n).reduce(function(e,t){return e.concat(t)},e.refs).filter(function(e){return-1===t.indexOf(e.name)})}(r=r||{}).withComments=!0,"string"==typeof e&&(e=d(e,r));var i=C(e),o=!!r.jslintGlobalComment,a=R(i,o),s=i.refs.concat(t.arr.flatten(i.subScopes.map(n))),u=t.arr.withoutAll(s.map(function(e){return e.name}),a);return{scope:i,varDecls:i.varDecls,funcDecls:i.funcDecls,classDecls:i.classDecls,declaredNames:a,undeclaredNames:u,refs:s,thisRefs:i.thisRefs}}function N(e,t){return t="string"==typeof t?d(t):t,acorn.walk.findNodesIncluding(t,e)}function M(e,r,n){var o=N(r.start,e).reverse().find(function(e){return t.arr.include(Ie,e.type)});if(n&&n.asPath){var a=new i,s=void 0;a.accept=t.fun.wrap(a.accept,function(e,t,r,n){if(t===o)throw s=n,new Error("stop search");return e(t,r,n)});try{a.accept(e,{},[])}catch(e){}return s}return o}function q(e){return e.source||o(e)}function $(e,r){var n=t.string.peekLeft(e,r,/\s+$/),i="number"==typeof n?e.slice(n,r):"";return"\n"===i[0]&&(i=i.slice(1)),i}function W(e,r){for(var n=0;n<e.length;n++){var i=e[n];if("del"===i.type)r=r.slice(0,i.pos)+r.slice(i.pos+i.length);else{if("add"!==i.type)throw new Error("Unexpected change "+t.obj.inspect(i));r=r.slice(0,i.pos)+i.string+r.slice(i.pos)}}return r}function U(e,t){if(e.start===t.start&&e.end===t.end)return 0;if(e.end<=t.start)return-1;if(e.start>=t.end)return 1;if(e.start<=t.start&&e.end>=t.end)return 1;if(t.start<=e.start&&t.end>=e.end)return-1;throw new Error("Comparing nodes")}function z(e,r,n){var i="object"===(void 0===n?"undefined":oe(n))?n:{changes:[],source:n},o=!1,a=i.changes.reduce(function(e,r){if(e.end<r.pos)return e;var n=r.pos<e.start;if(o=o||r.pos>=e.start&&r.pos<=e.end,"add"===r.type)return{start:n?e.start+r.string.length:e.start,end:e.end+r.string.length};if("del"===r.type)return{start:n?e.start-r.length:e.start,end:e.end-r.length};throw new Error("Cannot deal with change "+t.obj.inspect(r))},{start:e.start,end:e.end}),s=i.source,u=r(e,s.slice(a.start,a.end),o),c=Array.isArray(u)?u.map(q).join("\n"+$(s,a.start)):c=q(u),l=[{type:"del",pos:a.start,length:a.end-a.start},{type:"add",pos:a.start,string:c}];return{changes:i.changes.concat(l),source:W(l,s)}}function V(e,t){for(var r=e.sort(function(e,t){return U(e.target,t.target)}),n="object"===(void 0===t?"undefined":oe(t))?t:{changes:[],source:t},i=0;i<r.length;i++){var o=r[i];n=z(o.target,o.replacementFunc,n)}return n}function G(e,r){var n=d(e,r=r||{}),i=t.arr.last(n.body);return"ExpressionStatement"===i.type?(n.body.splice(n.body.length-1,1,g(i.expression)),r.asAST?n:o(n)):r.asAST?n:e}function H(e,r){function n(e){return t.arr.detect(e.node.body,function(t){return t.start>e.comment.end})}function a(e){return{type:"unknown",comment:e.comment.text}}function s(e){var r=t.Path(e.path.slice(0,-1)).get(_);return r&&"FunctionDeclaration"===r.type}function u(e){var r=t.Path(e.path.slice(0,-1)).get(_);return{name:r.id?r.id.name:"<error: no name for function>",args:t.arr.pluck(r.params,"name")}}function c(e){return t.arr.equals(e.path.slice(-2),["value","body"])}function l(e){return t.arr.equals(e.path.slice(-2),["right","body"])}function f(e){for(var r=t.Path(e.path.slice(0,-2)).get(_),n=r.key?r.key.name:"<error: no name for method>",i=e.path.slice(),o="<error: no object found for method>";i.length&&"init"!==t.arr.last(i);)i.pop();if(i.length&&(o=t.Path(i.slice(0,-1).concat(["id","name"])).get(_)),t.string.startsWith(o,"<error")){for(i=e.path.slice();i.length&&"right"!==t.arr.last(i);)i.pop();if(i.length){var a=t.Path(i.slice(0,-1).concat(["left"])).get(_);o=x.slice(a.start,a.end)}}if(t.string.startsWith(o,"<error")){i=e.path.slice();var s=t.Path(i.slice(0,-6)).get(_),u=s&&"CallExpression"===s.type&&s.arguments[0];u&&(o=x.slice(u.start,u.end))}return{name:n,args:t.arr.pluck(r.value.params,"name"),objectName:o}}function p(e){var r=t.Path(e.path.slice(0,-1)).get(_);if("FunctionExpression"!==r.type&&"FunctionDeclaration"!==r.type)return{};var n=M(_,r);if("ExpressionStatement"!==n.type||"AssignmentExpression"!==n.expression.type)return{};var i=x.slice(n.expression.left.object.start,n.expression.left.object.end);return{name:x.slice(n.expression.left.property.start,n.expression.left.property.end),objectName:i,args:t.arr.pluck(r.params,"name")}}function h(e){var r=e.path.slice(-5);return t.arr.removeAt(r,1),t.arr.equals(r,["properties","value","callee","body"])}function m(e){var r,n,i;i=e.path.slice(0,-3);var o=t.Path(i).get(_);o&&"Property"===o.type&&(n=t.arr.pluck(o.value.callee.params,"name"),r=o.key?o.key.name:"<error: no name for method>"),r||(i=e.path.slice(0,-2),(o=t.Path(i).get(_))&&"Property"===o.type&&(n=t.arr.pluck(o.value.params,"name"),r=o.key?o.key.name:"<error: no name for method>")),r||(r="<error: no name for method>",n=[],i=e.path);for(var a=t.arr.clone(i),s="<error: no object found for method>";a.length&&"init"!==t.arr.last(a);)a.pop();if(a.length&&(s=t.Path(a.slice(0,-1).concat(["id","name"])).get(_)),t.string.startsWith(s,"<error")){for(a=t.arr.clone(i);a.length&&"right"!==t.arr.last(a);)a.pop();if(a.length){var u=t.Path(a.slice(0,-1).concat(["left"])).get(_);s=x.slice(u.start,u.end)}}if(t.string.startsWith(s,"<error")){var a=t.arr.clone(i),c=t.Path(a.slice(0,-4)).get(_),l=c&&"CallExpression"===c.type&&c.arguments[0];l&&(s=x.slice(l.start,l.end))}return{name:r,args:n,objectName:s}}function v(e){return y(e)&&("ObjectExpression"===e.declarations[0].init.type||b(e.declarations[0].init))}function y(e){return e&&"VariableDeclaration"===e.type&&1===e.declarations.length}function g(e){return{name:e.declarations[0].id.name}}function b(e){return"AssignmentExpression"===e.type&&("ObjectExpression"===e.right.type||"AssignmentExpression"===e.right.type&&b(e.right))}var _="string"==typeof e?d(e,{withComments:!0}):e,x=r||("string"==typeof e?e:o(e)),w=t.arr.sortBy(function(e){var r=[],n=new i;return n.accept=t.fun.wrap(n.accept,function(e,n,i,o){return n.comments&&t.arr.pushAll(r,n.comments.map(function(e){return{path:o,comment:e,node:n}})),e(n,i,o)}),n.accept(e,r,[]),r}(_),function(e){return e.comment.start});return w.map(function(e,r){if(c(e))return t.obj.merge([e,e.comment,{type:"method",comment:e.comment.text},f(e)]);if(h(e))return t.obj.merge([e,e.comment,{type:"method",comment:e.comment.text},m(e)]);if(s(e))return t.obj.merge([e,e.comment,{type:"function",comment:e.comment.text},u(e)]);if(l(e))return t.obj.merge([e,e.comment,{type:"method",comment:e.comment.text},p(e)]);var i=n(e);if(!i)return t.obj.merge([e,e.comment,{followingNode:i},a(e)]);var o=w[r+1];return o&&o.comment.start<=i.start?t.obj.merge([e,e.comment,{followingNode:i},a(e)]):v(i)?t.obj.merge([e,e.comment,{followingNode:i},{type:"object",comment:e.comment.text},g(i)]):y(i)?t.obj.merge([e,e.comment,{followingNode:i},{type:"var",comment:e.comment.text},g(i)]):t.obj.merge([e,e.comment,{followingNode:i},a(e)])})}function J(e,r){r=r||t.obj.merge({hideOneLiners:!1},r),"string"==typeof e&&(e=d(e,{addSource:!0}));var n="Program"===e.type?e.body:e.body.body,i=[],o=(r.hideOneLiners&&e.source,!0),a=!1,s=void 0;try{for(var u,c=n[Symbol.iterator]();!(o=(u=c.next()).done);o=!0){var l=u.value,f=ee(l=te(l),r)||Y(l)||X(l)||K(l)||Z(l);if(f){if(r.hideOneLiners)if(e.loc)f=f.filter(function(e){return!e.node.loc||e.node.loc.start.line!==e.node.loc.end.line});else if(e.source){var p=[],h=!0,m=!1,v=void 0;try{for(var y,g=f[Symbol.iterator]();!(h=(y=g.next()).done);h=!0){var b=y.value;(b.parent&&p.includes(b.parent)||(b.node.source||"").includes("\n"))&&p.push(b)}}catch(e){m=!0,v=e}finally{try{!h&&g.return&&g.return()}finally{if(m)throw v}}f=p}i.push.apply(i,he(f))}}}catch(e){a=!0,s=e}finally{try{!o&&c.return&&c.return()}finally{if(a)throw s}}return i}function K(e){var t;if("ClassDeclaration"!==e.type)return null;var r={type:"class-decl",name:e.id.name,node:e,children:[]};return(t=r.children).push.apply(t,he(e.body.body.map(function(e,t){return Q(e,r,t)}).filter(Boolean))),[r].concat(he(r.children))}function Q(e,t,r){if("MethodDefinition"!==e.type)return null;var n;return"constructor"===e.kind?n="class-constructor":"method"===e.kind?n=e.static?"class-class-method":"class-instance-method":"get"===e.kind?n=e.static?"class-class-getter":"class-instance-getter":"set"===e.kind&&(n=e.static?"class-class-setter":"class-instance-setter"),n?{type:n,parent:t,node:e,name:e.key.name}:null}function Y(e){if("VariableDeclaration"!==e.type)return null;var t=[],r=!0,n=!1,i=void 0;try{for(var o,a=function(){var e=o.value,r=e.id,n=e.node,i={name:r.name,node:n,type:"var-decl"};if(t.push(i),!i.node.init)return"continue";for(var a=i.node.init;"AssignmentExpression"===a.type;)a=a.right;if("ObjectExpression"===a.type)return i.type="object-decl",i.children=re(a).map(function(e){return ue({},e,{type:"object-"+e.type,parent:i})}),t.push.apply(t,he(i.children)),"continue";(u=Z(a,i))&&(i.children=u.map(function(e){return ue({},e,{parent:i})}),t.push.apply(t,he(i.children)))},s=ie(e)[Symbol.iterator]();!(r=(o=s.next()).done);r=!0){var u;a()}}catch(e){n=!0,i=e}finally{try{!r&&s.return&&s.return()}finally{if(n)throw i}}return t}function X(e){return"FunctionStatement"!==e.type&&"FunctionDeclaration"!==e.type?null:[{name:e.id.name,node:e,type:"function-decl"}]}function Z(e,t){if("ExpressionStatement"===e.type&&(e=e.expression),"CallExpression"!==e.type)return null;var r=e.arguments.find(function(e){return"ObjectExpression"===e.type});return r?re(r,t):null}function ee(e,r){if(!ne(e))return null;var n,i=t.Path("expression.arguments.0").get(e);n=i&&"FunctionExpression"===i.type&&t.string.lines(i.source||"").length>5?J(i,r):J(t.Path("expression.callee").get(e),r);var o={node:e,name:t.Path("expression.callee.id.name").get(e)};return n.forEach(function(e){return e.parent||(e.parent=o)}),n}function te(e){return"ExportNamedDeclaration"!==e.type&&"ExportDefaultDeclaration"!==e.type||!e.declaration?e:e.declaration}function re(e,t){return e.properties.map(function(e){return{name:e.key.name||e.key.value,type:"FunctionExpression"===e.value.type?"method":"property",node:e,parent:t}})}function ne(e){return"CallExpression"===t.Path("expression.type").get(e)&&"FunctionExpression"===t.Path("expression.callee.type").get(e)}function ie(e){return e.declarations.map(function(e){return!e.source&&e.init&&(e.source=e.id.name+" = "+e.init.source),{node:e,id:e.id}})}i.prototype.accept=function(e,t,r){if(!e)throw new Error("Undefined AST node in Visitor.accept:\n  "+r.join(".")+"\n  "+e);if(!e.type)throw new Error("Strangee AST node without type in Visitor.accept:\n  "+r.join(".")+"\n  "+JSON.stringify(e));switch(e.type){case"Node":return this.visitNode(e,t,r);case"SourceLocation":return this.visitSourceLocation(e,t,r);case"Position":return this.visitPosition(e,t,r);case"Program":return this.visitProgram(e,t,r);case"Function":return this.visitFunction(e,t,r);case"Statement":return this.visitStatement(e,t,r);case"SwitchCase":return this.visitSwitchCase(e,t,r);case"CatchClause":return this.visitCatchClause(e,t,r);case"VariableDeclarator":return this.visitVariableDeclarator(e,t,r);case"Expression":return this.visitExpression(e,t,r);case"Property":return this.visitProperty(e,t,r);case"Pattern":return this.visitPattern(e,t,r);case"Super":return this.visitSuper(e,t,r);case"SpreadElement":return this.visitSpreadElement(e,t,r);case"TemplateElement":return this.visitTemplateElement(e,t,r);case"Class":return this.visitClass(e,t,r);case"ClassBody":return this.visitClassBody(e,t,r);case"MethodDefinition":return this.visitMethodDefinition(e,t,r);case"ModuleDeclaration":return this.visitModuleDeclaration(e,t,r);case"ModuleSpecifier":return this.visitModuleSpecifier(e,t,r);case"Identifier":return this.visitIdentifier(e,t,r);case"Literal":return this.visitLiteral(e,t,r);case"ExpressionStatement":return this.visitExpressionStatement(e,t,r);case"BlockStatement":return this.visitBlockStatement(e,t,r);case"EmptyStatement":return this.visitEmptyStatement(e,t,r);case"DebuggerStatement":return this.visitDebuggerStatement(e,t,r);case"WithStatement":return this.visitWithStatement(e,t,r);case"ReturnStatement":return this.visitReturnStatement(e,t,r);case"LabeledStatement":return this.visitLabeledStatement(e,t,r);case"BreakStatement":return this.visitBreakStatement(e,t,r);case"ContinueStatement":return this.visitContinueStatement(e,t,r);case"IfStatement":return this.visitIfStatement(e,t,r);case"SwitchStatement":return this.visitSwitchStatement(e,t,r);case"ThrowStatement":return this.visitThrowStatement(e,t,r);case"TryStatement":return this.visitTryStatement(e,t,r);case"WhileStatement":return this.visitWhileStatement(e,t,r);case"DoWhileStatement":return this.visitDoWhileStatement(e,t,r);case"ForStatement":return this.visitForStatement(e,t,r);case"ForInStatement":return this.visitForInStatement(e,t,r);case"Declaration":return this.visitDeclaration(e,t,r);case"ThisExpression":return this.visitThisExpression(e,t,r);case"ArrayExpression":return this.visitArrayExpression(e,t,r);case"ObjectExpression":return this.visitObjectExpression(e,t,r);case"FunctionExpression":return this.visitFunctionExpression(e,t,r);case"UnaryExpression":return this.visitUnaryExpression(e,t,r);case"UpdateExpression":return this.visitUpdateExpression(e,t,r);case"BinaryExpression":return this.visitBinaryExpression(e,t,r);case"AssignmentExpression":return this.visitAssignmentExpression(e,t,r);case"LogicalExpression":return this.visitLogicalExpression(e,t,r);case"MemberExpression":return this.visitMemberExpression(e,t,r);case"ConditionalExpression":return this.visitConditionalExpression(e,t,r);case"CallExpression":return this.visitCallExpression(e,t,r);case"NewExpression":return this.visitNewExpression(e,t,r);case"SequenceExpression":return this.visitSequenceExpression(e,t,r);case"ArrowFunctionExpression":return this.visitArrowFunctionExpression(e,t,r);case"YieldExpression":return this.visitYieldExpression(e,t,r);case"TemplateLiteral":return this.visitTemplateLiteral(e,t,r);case"TaggedTemplateExpression":return this.visitTaggedTemplateExpression(e,t,r);case"AssignmentProperty":return this.visitAssignmentProperty(e,t,r);case"ObjectPattern":return this.visitObjectPattern(e,t,r);case"ArrayPattern":return this.visitArrayPattern(e,t,r);case"RestElement":return this.visitRestElement(e,t,r);case"AssignmentPattern":return this.visitAssignmentPattern(e,t,r);case"ClassExpression":return this.visitClassExpression(e,t,r);case"MetaProperty":return this.visitMetaProperty(e,t,r);case"ImportDeclaration":return this.visitImportDeclaration(e,t,r);case"ImportSpecifier":return this.visitImportSpecifier(e,t,r);case"ImportDefaultSpecifier":return this.visitImportDefaultSpecifier(e,t,r);case"ImportNamespaceSpecifier":return this.visitImportNamespaceSpecifier(e,t,r);case"ExportNamedDeclaration":return this.visitExportNamedDeclaration(e,t,r);case"ExportSpecifier":return this.visitExportSpecifier(e,t,r);case"ExportDefaultDeclaration":return this.visitExportDefaultDeclaration(e,t,r);case"ExportAllDeclaration":return this.visitExportAllDeclaration(e,t,r);case"AwaitExpression":return this.visitAwaitExpression(e,t,r);case"RegExpLiteral":return this.visitRegExpLiteral(e,t,r);case"FunctionDeclaration":return this.visitFunctionDeclaration(e,t,r);case"VariableDeclaration":return this.visitVariableDeclaration(e,t,r);case"ForOfStatement":return this.visitForOfStatement(e,t,r);case"ClassDeclaration":return this.visitClassDeclaration(e,t,r)}throw new Error("No visit function in AST visitor Visitor for:\n  "+r.join(".")+"\n  "+JSON.stringify(e))},i.prototype.visitNode=function(e,t,r){return e},i.prototype.visitSourceLocation=function(e,t,r){var n=this;return e.start=n.accept(e.start,t,r.concat(["start"])),e.end=n.accept(e.end,t,r.concat(["end"])),e},i.prototype.visitPosition=function(e,t,r){return e},i.prototype.visitProgram=function(e,t,r){for(var n=this,i=[],o=0;o<e.body.length;o++){var a=e.body[o],s=a?n.accept(a,t,r.concat(["body",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.body=i,e},i.prototype.visitFunction=function(e,t,r){var n=this;e.id&&(e.id=n.accept(e.id,t,r.concat(["id"])));for(var i=[],o=0;o<e.params.length;o++){var a=e.params[o],s=a?n.accept(a,t,r.concat(["params",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.params=i,e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitStatement=function(e,t,r){return e},i.prototype.visitSwitchCase=function(e,t,r){var n=this;e.test&&(e.test=n.accept(e.test,t,r.concat(["test"])));for(var i=[],o=0;o<e.consequent.length;o++){var a=e.consequent[o],s=a?n.accept(a,t,r.concat(["consequent",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.consequent=i,e},i.prototype.visitCatchClause=function(e,t,r){var n=this;return e.param=n.accept(e.param,t,r.concat(["param"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitVariableDeclarator=function(e,t,r){var n=this;return e.id=n.accept(e.id,t,r.concat(["id"])),e.init&&(e.init=n.accept(e.init,t,r.concat(["init"]))),e},i.prototype.visitExpression=function(e,t,r){return e},i.prototype.visitProperty=function(e,t,r){var n=this;return e.key=n.accept(e.key,t,r.concat(["key"])),e.value=n.accept(e.value,t,r.concat(["value"])),e},i.prototype.visitPattern=function(e,t,r){return e},i.prototype.visitSuper=function(e,t,r){return e},i.prototype.visitSpreadElement=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitTemplateElement=function(e,t,r){return e},i.prototype.visitClass=function(e,t,r){var n=this;return e.id&&(e.id=n.accept(e.id,t,r.concat(["id"]))),e.superClass&&(e.superClass=n.accept(e.superClass,t,r.concat(["superClass"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitClassBody=function(e,t,r){for(var n=this,i=[],o=0;o<e.body.length;o++){var a=e.body[o],s=a?n.accept(a,t,r.concat(["body",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.body=i,e},i.prototype.visitMethodDefinition=function(e,t,r){var n=this;return e.key=n.accept(e.key,t,r.concat(["key"])),e.value=n.accept(e.value,t,r.concat(["value"])),e},i.prototype.visitModuleDeclaration=function(e,t,r){return e},i.prototype.visitModuleSpecifier=function(e,t,r){var n=this;return e.local=n.accept(e.local,t,r.concat(["local"])),e},i.prototype.visitIdentifier=function(e,t,r){return e},i.prototype.visitLiteral=function(e,t,r){return e},i.prototype.visitExpressionStatement=function(e,t,r){var n=this;return e.expression=n.accept(e.expression,t,r.concat(["expression"])),e},i.prototype.visitBlockStatement=function(e,t,r){for(var n=this,i=[],o=0;o<e.body.length;o++){var a=e.body[o],s=a?n.accept(a,t,r.concat(["body",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.body=i,e},i.prototype.visitEmptyStatement=function(e,t,r){return e},i.prototype.visitDebuggerStatement=function(e,t,r){return e},i.prototype.visitWithStatement=function(e,t,r){var n=this;return e.object=n.accept(e.object,t,r.concat(["object"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitReturnStatement=function(e,t,r){var n=this;return e.argument&&(e.argument=n.accept(e.argument,t,r.concat(["argument"]))),e},i.prototype.visitLabeledStatement=function(e,t,r){var n=this;return e.label=n.accept(e.label,t,r.concat(["label"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitBreakStatement=function(e,t,r){var n=this;return e.label&&(e.label=n.accept(e.label,t,r.concat(["label"]))),e},i.prototype.visitContinueStatement=function(e,t,r){var n=this;return e.label&&(e.label=n.accept(e.label,t,r.concat(["label"]))),e},i.prototype.visitIfStatement=function(e,t,r){var n=this;return e.test=n.accept(e.test,t,r.concat(["test"])),e.consequent=n.accept(e.consequent,t,r.concat(["consequent"])),e.alternate&&(e.alternate=n.accept(e.alternate,t,r.concat(["alternate"]))),e},i.prototype.visitSwitchStatement=function(e,t,r){var n=this;e.discriminant=n.accept(e.discriminant,t,r.concat(["discriminant"]));for(var i=[],o=0;o<e.cases.length;o++){var a=e.cases[o],s=a?n.accept(a,t,r.concat(["cases",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.cases=i,e},i.prototype.visitThrowStatement=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitTryStatement=function(e,t,r){var n=this;return e.block=n.accept(e.block,t,r.concat(["block"])),e.handler&&(e.handler=n.accept(e.handler,t,r.concat(["handler"]))),e.finalizer&&(e.finalizer=n.accept(e.finalizer,t,r.concat(["finalizer"]))),e},i.prototype.visitWhileStatement=function(e,t,r){var n=this;return e.test=n.accept(e.test,t,r.concat(["test"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitDoWhileStatement=function(e,t,r){var n=this;return e.body=n.accept(e.body,t,r.concat(["body"])),e.test=n.accept(e.test,t,r.concat(["test"])),e},i.prototype.visitForStatement=function(e,t,r){var n=this;return e.init&&(e.init=n.accept(e.init,t,r.concat(["init"]))),e.test&&(e.test=n.accept(e.test,t,r.concat(["test"]))),e.update&&(e.update=n.accept(e.update,t,r.concat(["update"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitForInStatement=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitDeclaration=function(e,t,r){return e},i.prototype.visitThisExpression=function(e,t,r){return e},i.prototype.visitArrayExpression=function(e,t,r){var n=this;if(e.elements){for(var i=[],o=0;o<e.elements.length;o++){var a=e.elements[o],s=a?n.accept(a,t,r.concat(["elements",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}e.elements=i}return e},i.prototype.visitObjectExpression=function(e,t,r){for(var n=this,i=[],o=0;o<e.properties.length;o++){var a=e.properties[o],s=a?n.accept(a,t,r.concat(["properties",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.properties=i,e},i.prototype.visitFunctionExpression=function(e,t,r){var n=this;e.id&&(e.id=n.accept(e.id,t,r.concat(["id"])));for(var i=[],o=0;o<e.params.length;o++){var a=e.params[o],s=a?n.accept(a,t,r.concat(["params",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.params=i,e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitUnaryExpression=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitUpdateExpression=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitBinaryExpression=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e},i.prototype.visitAssignmentExpression=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e},i.prototype.visitLogicalExpression=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e},i.prototype.visitMemberExpression=function(e,t,r){var n=this;return e.object=n.accept(e.object,t,r.concat(["object"])),e.property=n.accept(e.property,t,r.concat(["property"])),e},i.prototype.visitConditionalExpression=function(e,t,r){var n=this;return e.test=n.accept(e.test,t,r.concat(["test"])),e.alternate=n.accept(e.alternate,t,r.concat(["alternate"])),e.consequent=n.accept(e.consequent,t,r.concat(["consequent"])),e},i.prototype.visitCallExpression=function(e,t,r){var n=this;e.callee=n.accept(e.callee,t,r.concat(["callee"]));for(var i=[],o=0;o<e.arguments.length;o++){var a=e.arguments[o],s=a?n.accept(a,t,r.concat(["arguments",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.arguments=i,e},i.prototype.visitNewExpression=function(e,t,r){var n=this;e.callee=n.accept(e.callee,t,r.concat(["callee"]));for(var i=[],o=0;o<e.arguments.length;o++){var a=e.arguments[o],s=a?n.accept(a,t,r.concat(["arguments",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.arguments=i,e},i.prototype.visitSequenceExpression=function(e,t,r){for(var n=this,i=[],o=0;o<e.expressions.length;o++){var a=e.expressions[o],s=a?n.accept(a,t,r.concat(["expressions",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.expressions=i,e},i.prototype.visitArrowFunctionExpression=function(e,t,r){var n=this;e.body=n.accept(e.body,t,r.concat(["body"])),e.id&&(e.id=n.accept(e.id,t,r.concat(["id"])));for(var i=[],o=0;o<e.params.length;o++){var a=e.params[o],s=a?n.accept(a,t,r.concat(["params",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.params=i,e},i.prototype.visitYieldExpression=function(e,t,r){var n=this;return e.argument&&(e.argument=n.accept(e.argument,t,r.concat(["argument"]))),e},i.prototype.visitTemplateLiteral=function(e,t,r){for(var n=this,i=[],o=0;o<e.quasis.length;o++){s=(a=e.quasis[o])?n.accept(a,t,r.concat(["quasis",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}e.quasis=i;for(var i=[],o=0;o<e.expressions.length;o++){var a=e.expressions[o],s=a?n.accept(a,t,r.concat(["expressions",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.expressions=i,e},i.prototype.visitTaggedTemplateExpression=function(e,t,r){var n=this;return e.tag=n.accept(e.tag,t,r.concat(["tag"])),e.quasi=n.accept(e.quasi,t,r.concat(["quasi"])),e},i.prototype.visitAssignmentProperty=function(e,t,r){var n=this;return e.value=n.accept(e.value,t,r.concat(["value"])),e.key=n.accept(e.key,t,r.concat(["key"])),e},i.prototype.visitObjectPattern=function(e,t,r){for(var n=this,i=[],o=0;o<e.properties.length;o++){var a=e.properties[o],s=a?n.accept(a,t,r.concat(["properties",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.properties=i,e},i.prototype.visitArrayPattern=function(e,t,r){var n=this;if(e.elements){for(var i=[],o=0;o<e.elements.length;o++){var a=e.elements[o],s=a?n.accept(a,t,r.concat(["elements",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}e.elements=i}return e},i.prototype.visitRestElement=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitAssignmentPattern=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e},i.prototype.visitClassExpression=function(e,t,r){var n=this;return e.id&&(e.id=n.accept(e.id,t,r.concat(["id"]))),e.superClass&&(e.superClass=n.accept(e.superClass,t,r.concat(["superClass"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitMetaProperty=function(e,t,r){var n=this;return e.meta=n.accept(e.meta,t,r.concat(["meta"])),e.property=n.accept(e.property,t,r.concat(["property"])),e},i.prototype.visitImportDeclaration=function(e,t,r){for(var n=this,i=[],o=0;o<e.specifiers.length;o++){var a=e.specifiers[o],s=a?n.accept(a,t,r.concat(["specifiers",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.specifiers=i,e.source=n.accept(e.source,t,r.concat(["source"])),e},i.prototype.visitImportSpecifier=function(e,t,r){var n=this;return e.imported=n.accept(e.imported,t,r.concat(["imported"])),e.local=n.accept(e.local,t,r.concat(["local"])),e},i.prototype.visitImportDefaultSpecifier=function(e,t,r){var n=this;return e.local=n.accept(e.local,t,r.concat(["local"])),e},i.prototype.visitImportNamespaceSpecifier=function(e,t,r){var n=this;return e.local=n.accept(e.local,t,r.concat(["local"])),e},i.prototype.visitExportNamedDeclaration=function(e,t,r){var n=this;e.declaration&&(e.declaration=n.accept(e.declaration,t,r.concat(["declaration"])));for(var i=[],o=0;o<e.specifiers.length;o++){var a=e.specifiers[o],s=a?n.accept(a,t,r.concat(["specifiers",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.specifiers=i,e.source&&(e.source=n.accept(e.source,t,r.concat(["source"]))),e},i.prototype.visitExportSpecifier=function(e,t,r){var n=this;return e.exported=n.accept(e.exported,t,r.concat(["exported"])),e.local=n.accept(e.local,t,r.concat(["local"])),e},i.prototype.visitExportDefaultDeclaration=function(e,t,r){var n=this;return e.declaration=n.accept(e.declaration,t,r.concat(["declaration"])),e},i.prototype.visitExportAllDeclaration=function(e,t,r){var n=this;return e.source=n.accept(e.source,t,r.concat(["source"])),e},i.prototype.visitAwaitExpression=function(e,t,r){var n=this;return e.argument=n.accept(e.argument,t,r.concat(["argument"])),e},i.prototype.visitRegExpLiteral=function(e,t,r){return e},i.prototype.visitFunctionDeclaration=function(e,t,r){var n=this;e.id=n.accept(e.id,t,r.concat(["id"]));for(var i=[],o=0;o<e.params.length;o++){var a=e.params[o],s=a?n.accept(a,t,r.concat(["params",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.params=i,e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitVariableDeclaration=function(e,t,r){for(var n=this,i=[],o=0;o<e.declarations.length;o++){var a=e.declarations[o],s=a?n.accept(a,t,r.concat(["declarations",o])):a;Array.isArray(s)?i.push.apply(i,s):i.push(s)}return e.declarations=i,e},i.prototype.visitForOfStatement=function(e,t,r){var n=this;return e.left=n.accept(e.left,t,r.concat(["left"])),e.right=n.accept(e.right,t,r.concat(["right"])),e.body=n.accept(e.body,t,r.concat(["body"])),e},i.prototype.visitClassDeclaration=function(e,t,r){var n=this;return e.id=n.accept(e.id,t,r.concat(["id"])),e.superClass&&(e.superClass=n.accept(e.superClass,t,r.concat(["superClass"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e};var oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ae=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},se=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),ue=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},ce=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},le=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},fe=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},pe=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),de=function(e){return Array.isArray(e)?e:Array.from(e)},he=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},me=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){var i=n.map(function(e){return"string"==typeof e?"."+e:"["+e+"]"}).join(""),o=[],a=ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,{index:r.index,tree:o},n);return r.tree.push({node:e,path:i,index:r.index++,children:o}),a}}]),t}(),ve=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"recordNotEqual",value:function(e,t,r,n){r.comparisons.errors.push({node1:e,node2:t,path:r.completePath,msg:n})}},{key:"compareType",value:function(e,t,r){return this.compareField("type",e,t,r)}},{key:"compareField",value:function(e,t,r,n){if(r=lively.lang.Path(n.completePath.join(".")).get(r),t&&r&&t[e]===r[e])return!0;if(t&&"*"===t[e]||r&&"*"===r[e])return!0;var i,o=n.completePath.join(".")+"."+e;return i=t?r?o+" is not equal: "+t[e]+" vs. "+r[e]:"node2 not defined but node1 ("+o+") is: "+t[e]:"node1 on "+o+" not defined",this.recordNotEqual(t,r,n,i),!1}},{key:"accept",value:function(e,t,r,n){var i=lively.lang.Path(n.join(".")).get(t);if("*"!==e&&"*"!==i){var o={completePath:n,comparisons:r.comparisons};this.compareType(e,t,o)&&this["visit"+e.type](e,t,o,n)}}},{key:"visitFunction",value:function(e,r,n,i){return e.generator&&this.compareField("generator",e,r,n),e.expression&&this.compareField("expression",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitFunction",this).call(this,e,r,n,i)}},{key:"visitSwitchStatement",value:function(e,r,n,i){return e.lexical&&this.compareField("lexical",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitSwitchStatement",this).call(this,e,r,n,i)}},{key:"visitForInStatement",value:function(e,r,n,i){return e.each&&this.compareField("each",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitForInStatement",this).call(this,e,r,n,i)}},{key:"visitFunctionDeclaration",value:function(e,r,n,i){return e.generator&&this.compareField("generator",e,r,n),e.expression&&this.compareField("expression",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitFunctionDeclaration",this).call(this,e,r,n,i)}},{key:"visitVariableDeclaration",value:function(e,r,n,i){return this.compareField("kind",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitVariableDeclaration",this).call(this,e,r,n,i)}},{key:"visitUnaryExpression",value:function(e,r,n,i){return this.compareField("operator",e,r,n),e.prefix&&this.compareField("prefix",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitUnaryExpression",this).call(this,e,r,n,i)}},{key:"visitBinaryExpression",value:function(e,r,n,i){return this.compareField("operator",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitBinaryExpression",this).call(this,e,r,n,i)}},{key:"visitAssignmentExpression",value:function(e,r,n,i){return this.compareField("operator",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitAssignmentExpression",this).call(this,e,r,n,i)}},{key:"visitUpdateExpression",value:function(e,r,n,i){return this.compareField("operator",e,r,n),e.prefix&&this.compareField("prefix",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitUpdateExpression",this).call(this,e,r,n,i)}},{key:"visitLogicalExpression",value:function(e,r,n,i){return this.compareField("operator",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitLogicalExpression",this).call(this,e,r,n,i)}},{key:"visitMemberExpression",value:function(e,r,n,i){return e.computed&&this.compareField("computed",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitMemberExpression",this).call(this,e,r,n,i)}},{key:"visitComprehensionBlock",value:function(e,r,n,i){return e.each&&this.compareField("each",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitComprehensionBlock",this).call(this,e,r,n,i)}},{key:"visitIdentifier",value:function(e,r,n,i){return this.compareField("name",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitIdentifier",this).call(this,e,r,n,i)}},{key:"visitLiteral",value:function(e,r,n,i){return this.compareField("value",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitLiteral",this).call(this,e,r,n,i)}},{key:"visitClassDeclaration",value:function(e,r,n,i){return this.compareField("id",e,r,n),e.superClass&&this.compareField("superClass",e,r,n),this.compareField("body",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitClassDeclaration",this).call(this,e,r,n,i)}},{key:"visitClassBody",value:function(e,r,n,i){return this.compareField("body",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitClassBody",this).call(this,e,r,n,i)}},{key:"visitMethodDefinition",value:function(e,r,n,i){return this.compareField("static",e,r,n),this.compareField("computed",e,r,n),this.compareField("kind",e,r,n),this.compareField("key",e,r,n),this.compareField("value",e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitMethodDefinition",this).call(this,e,r,n,i)}}]),t}(),ye=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"newScope",value:function(e,t){var r={node:e,varDecls:[],varDeclPaths:[],funcDecls:[],funcDeclPaths:[],classDecls:[],classDeclPaths:[],classExprs:[],classExprPaths:[],methodDecls:[],methodDeclPaths:[],importSpecifiers:[],importSpecifierPaths:[],exportDecls:[],exportDeclPaths:[],refs:[],thisRefs:[],params:[],catches:[],subScopes:[],resolvedRefMap:new Map};return t&&t.subScopes.push(r),r}},{key:"visitVariableDeclaration",value:function(e,r,n){return r.varDecls.push(e),r.varDeclPaths.push(n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitVariableDeclaration",this).call(this,e,r,n)}},{key:"visitVariableDeclarator",value:function(e,t,r){var n=this;return e.init&&(e.init=n.accept(e.init,t,r.concat(["init"]))),e}},{key:"visitFunction",value:function(e,t,r){var n=this,i=this.newScope(e,t);return e.params.forEach(function(e,t){"AssignmentPattern"===e.type&&n.accept(e.right,i,r.concat("params",t,"right"))}),i.params=Array.prototype.slice.call(e.params),i}},{key:"visitFunctionDeclaration",value:function(e,t,r){var n=this.visitFunction(e,t,r);t.funcDecls.push(e),t.funcDeclPaths.push(r);var i=this;return e.defaults&&(e.defaults=e.defaults.reduce(function(e,t,o){var a=i.accept(t,n,r.concat(["defaults",o]));return Array.isArray(a)?e.push.apply(e,a):e.push(a),e},[])),e.rest&&(e.rest=i.accept(e.rest,n,r.concat(["rest"]))),e.body=i.accept(e.body,n,r.concat(["body"])),e.loc&&(e.loc=i.accept(e.loc,n,r.concat(["loc"]))),e}},{key:"visitFunctionExpression",value:function(e,t,r){var n=this.visitFunction(e,t,r),i=this;return e.defaults&&(e.defaults=e.defaults.reduce(function(e,t,o){var a=i.accept(t,n,r.concat(["defaults",o]));return Array.isArray(a)?e.push.apply(e,a):e.push(a),e},[])),e.rest&&(e.rest=i.accept(e.rest,n,r.concat(["rest"]))),e.body=i.accept(e.body,n,r.concat(["body"])),e.loc&&(e.loc=i.accept(e.loc,n,r.concat(["loc"]))),e}},{key:"visitArrowFunctionExpression",value:function(e,t,r){var n=this.visitFunction(e,t,r),i=this;return e.defaults&&(e.defaults=e.defaults.reduce(function(e,t,o){var a=i.accept(t,n,r.concat(["defaults",o]));return Array.isArray(a)?e.push.apply(e,a):e.push(a),e},[])),e.rest&&(e.rest=i.accept(e.rest,n,r.concat(["rest"]))),e.body=i.accept(e.body,n,r.concat(["body"])),e.loc&&(e.loc=i.accept(e.loc,n,r.concat(["loc"]))),e.generator,e.expression,e}},{key:"visitIdentifier",value:function(e,r,n){return r.refs.push(e),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitIdentifier",this).call(this,e,r,n)}},{key:"visitMemberExpression",value:function(e,t,r){var n=this;return e.object=n.accept(e.object,t,r.concat(["object"])),e.computed&&(e.property=n.accept(e.property,t,r.concat(["property"]))),e}},{key:"visitProperty",value:function(e,t,r){var n=this;return e.computed&&(e.key=n.accept(e.key,t,r.concat(["key"]))),e.value=n.accept(e.value,t,r.concat(["value"])),e}},{key:"visitThisExpression",value:function(e,r,n){return r.thisRefs.push(e),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitThisExpression",this).call(this,e,r,n)}},{key:"visitTryStatement",value:function(e,t,r){var n=this;return e.block=n.accept(e.block,t,r.concat(["block"])),e.handler&&(e.handler=n.accept(e.handler,t,r.concat(["handler"])),t.catches.push(e.handler.param)),e.finalizer&&(e.finalizer=n.accept(e.finalizer,t,r.concat(["finalizer"]))),e}},{key:"visitLabeledStatement",value:function(e,t,r){var n=this;return e.body=n.accept(e.body,t,r.concat(["body"])),e}},{key:"visitClassDeclaration",value:function(e,t,r){t.classDecls.push(e),t.classDeclPaths.push(r);var n=this;return e.superClass&&(e.superClass=n.accept(e.superClass,t,r.concat(["superClass"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e}},{key:"visitClassExpression",value:function(e,t,r){e.id&&(t.classExprs.push(e),t.classExprPaths.push(r));var n=this;return e.superClass&&(e.superClass=n.accept(e.superClass,t,r.concat(["superClass"]))),e.body=n.accept(e.body,t,r.concat(["body"])),e}},{key:"visitMethodDefinition",value:function(e,t,r){var n=this;return e.value=n.accept(e.value,t,r.concat(["value"])),e}},{key:"visitMetaProperty",value:function(e,t,r){return e}},{key:"visitBreakStatement",value:function(e,t,r){return e}},{key:"visitContinueStatement",value:function(e,t,r){return e}},{key:"visitImportSpecifier",value:function(e,t,r){t.importSpecifiers.push(e.local),t.importSpecifierPaths.push(r);var n=this;return e.local=n.accept(e.local,t,r.concat(["local"])),e}},{key:"visitImportDefaultSpecifier",value:function(e,t,r){t.importSpecifiers.push(e.local),t.importSpecifierPaths.push(r);return e}},{key:"visitImportNamespaceSpecifier",value:function(e,t,r){t.importSpecifiers.push(e.local),t.importSpecifierPaths.push(r);return e}},{key:"visitExportSpecifier",value:function(e,t,r){var n=this;return e.local=n.accept(e.local,t,r.concat(["local"])),e}},{key:"visitExportNamedDeclaration",value:function(e,r,n){return r.exportDecls.push(e),r.exportDeclPaths.push(n),e.source||ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitExportNamedDeclaration",this).call(this,e,r,n),e}},{key:"visitExportDefaultDeclaration",value:function(e,r,n){return r.exportDecls.push(e),r.exportDeclPaths.push(n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitExportDefaultDeclaration",this).call(this,e,r,n)}},{key:"visitExportAllDeclaration",value:function(e,r,n){return r.exportDecls.push(e),r.exportDeclPaths.push(n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitExportAllDeclaration",this).call(this,e,r,n)}}]),t}(),ge=r.escodegen||r,be=acorn.walk,_e=acorn.loose;be.base.AwaitExpression||(be.base.AwaitExpression=function(e,t,r){e.argument&&r(e.argument,t,"Expression")}),be.forEachNode=a,be.matchNodes=function(e,t,r,n){return a(e,function(e,r,n,i){t[e.type]&&t[e.type](e,r,n,i)},r,n)},be.findNodesIncluding=s,be.withParentInfo=function(e,r,n){function i(e){var r={id:t.string.newUUID(),parentScope:e,containingScopes:[]};return e&&e.containingScopes.push(r),r}n=n||{};var o,s=be.make({Function:function(e,t,r){t&&t.scope&&(t.scope=i(t.scope)),r(e.body,t,"ScopeBody")},VariableDeclarator:function(e,t,r){e.init&&r(e.init,t,"Expression")},VariableDeclaration:function(e,t,r){for(var n=0;n<e.declarations.length;++n){var i=e.declarations[n];i&&r(i,t,"VariableDeclarator")}},ObjectExpression:function(e,t,r){for(var n=0;n<e.properties.length;++n){var i=e.properties[n];r(i.key,t,"Expression"),r(i.value,t,"Expression")}},MemberExpression:function(e,t,r){r(e.object,t,"Expression"),r(e.property,t,"Expression")}},be.base),u=[];a(e,function(e){t.arr.withoutAll(Object.keys(e),["end","start","type","source","raw"]).forEach(function(t){if(!e.__lookupGetter__(t)){var r=e[t];e.__defineGetter__(t,function(){return o=t,r}),u.push([e,t,e[t]])}})},null,{visitors:s});var c=[];return Object.keys(s).forEach(function(e){var t=s[e];s[e]=function(i,a,s){return e===i.type||n.visitAllNodes?(c.push(r.call(null,i,{scope:a.scope,depth:a.depth,parent:a.parent,type:e,propertyInParent:o})),t(i,{scope:a.scope,parent:i,depth:a.depth+1},s)):t(i,a,s)}}),be.recursive(e,{scope:i(),parent:null,propertyInParent:"",depth:0},null,s),u.forEach(function(e){delete e[0][e[1]],e[0][e[1]]=e[2]}),c},be.copy=function(e,r){function n(e){return null===e?null:i[e.type](e,n)}var i=t.obj.extend({Program:function(e,t){return{start:e.start,end:e.end,type:"Program",body:e.body.map(t),source:e.source,astIndex:e.astIndex}},FunctionDeclaration:function(e,t){return{start:e.start,end:e.end,type:"FunctionDeclaration",id:t(e.id),params:e.params.map(t),body:t(e.body),source:e.source,astIndex:e.astIndex}},BlockStatement:function(e,t){return{start:e.start,end:e.end,type:"BlockStatement",body:e.body.map(t),source:e.source,astIndex:e.astIndex}},ExpressionStatement:function(e,t){return{start:e.start,end:e.end,type:"ExpressionStatement",expression:t(e.expression),source:e.source,astIndex:e.astIndex}},CallExpression:function(e,t){return{start:e.start,end:e.end,type:"CallExpression",callee:t(e.callee),arguments:e.arguments.map(t),source:e.source,astIndex:e.astIndex}},MemberExpression:function(e,t){return{start:e.start,end:e.end,type:"MemberExpression",object:t(e.object),property:t(e.property),computed:e.computed,source:e.source,astIndex:e.astIndex}},NewExpression:function(e,t){return{start:e.start,end:e.end,type:"NewExpression",callee:t(e.callee),arguments:e.arguments.map(t),source:e.source,astIndex:e.astIndex}},VariableDeclaration:function(e,t){return{start:e.start,end:e.end,type:"VariableDeclaration",declarations:e.declarations.map(t),kind:e.kind,source:e.source,astIndex:e.astIndex}},VariableDeclarator:function(e,t){return{start:e.start,end:e.end,type:"VariableDeclarator",id:t(e.id),init:t(e.init),source:e.source,astIndex:e.astIndex}},FunctionExpression:function(e,t){return{start:e.start,end:e.end,type:"FunctionExpression",id:t(e.id),params:e.params.map(t),body:t(e.body),source:e.source,astIndex:e.astIndex}},IfStatement:function(e,t){return{start:e.start,end:e.end,type:"IfStatement",test:t(e.test),consequent:t(e.consequent),alternate:t(e.alternate),source:e.source,astIndex:e.astIndex}},ConditionalExpression:function(e,t){return{start:e.start,end:e.end,type:"ConditionalExpression",test:t(e.test),consequent:t(e.consequent),alternate:t(e.alternate),source:e.source,astIndex:e.astIndex}},SwitchStatement:function(e,t){return{start:e.start,end:e.end,type:"SwitchStatement",discriminant:t(e.discriminant),cases:e.cases.map(t),source:e.source,astIndex:e.astIndex}},SwitchCase:function(e,t){return{start:e.start,end:e.end,type:"SwitchCase",test:t(e.test),consequent:e.consequent.map(t),source:e.source,astIndex:e.astIndex}},BreakStatement:function(e,t){return{start:e.start,end:e.end,type:"BreakStatement",label:e.label,source:e.source,astIndex:e.astIndex}},ContinueStatement:function(e,t){return{start:e.start,end:e.end,type:"ContinueStatement",label:e.label,source:e.source,astIndex:e.astIndex}},TryStatement:function(e,t){return{start:e.start,end:e.end,type:"TryStatement",block:t(e.block),handler:t(e.handler),finalizer:t(e.finalizer),guardedHandlers:e.guardedHandlers.map(t),source:e.source,astIndex:e.astIndex}},CatchClause:function(e,t){return{start:e.start,end:e.end,type:"CatchClause",param:t(e.param),guard:t(e.guard),body:t(e.body),source:e.source,astIndex:e.astIndex}},ThrowStatement:function(e,t){return{start:e.start,end:e.end,type:"ThrowStatement",argument:t(e.argument),source:e.source,astIndex:e.astIndex}},ForStatement:function(e,t){return{start:e.start,end:e.end,type:"ForStatement",init:t(e.init),test:t(e.test),update:t(e.update),body:t(e.body),source:e.source,astIndex:e.astIndex}},ForInStatement:function(e,t){return{start:e.start,end:e.end,type:"ForInStatement",left:t(e.left),right:t(e.right),body:t(e.body),source:e.source,astIndex:e.astIndex}},WhileStatement:function(e,t){return{start:e.start,end:e.end,type:"WhileStatement",test:t(e.test),body:t(e.body),source:e.source,astIndex:e.astIndex}},DoWhileStatement:function(e,t){return{start:e.start,end:e.end,type:"DoWhileStatement",test:t(e.test),body:t(e.body),source:e.source,astIndex:e.astIndex}},WithStatement:function(e,t){return{start:e.start,end:e.end,type:"WithStatement",object:t(e.object),body:t(e.body),source:e.source,astIndex:e.astIndex}},UnaryExpression:function(e,t){return{start:e.start,end:e.end,type:"UnaryExpression",argument:t(e.argument),operator:e.operator,prefix:e.prefix,source:e.source,astIndex:e.astIndex}},BinaryExpression:function(e,t){return{start:e.start,end:e.end,type:"BinaryExpression",left:t(e.left),operator:e.operator,right:t(e.right),source:e.source,astIndex:e.astIndex}},LogicalExpression:function(e,t){return{start:e.start,end:e.end,type:"LogicalExpression",left:t(e.left),operator:e.operator,right:t(e.right),source:e.source,astIndex:e.astIndex}},AssignmentExpression:function(e,t){return{start:e.start,end:e.end,type:"AssignmentExpression",left:t(e.left),operator:e.operator,right:t(e.right),source:e.source,astIndex:e.astIndex}},UpdateExpression:function(e,t){return{start:e.start,end:e.end,type:"UpdateExpression",argument:t(e.argument),operator:e.operator,prefix:e.prefix,source:e.source,astIndex:e.astIndex}},ReturnStatement:function(e,t){return{start:e.start,end:e.end,type:"ReturnStatement",argument:t(e.argument),source:e.source,astIndex:e.astIndex}},Identifier:function(e,t){return{start:e.start,end:e.end,type:"Identifier",name:e.name,source:e.source,astIndex:e.astIndex}},Literal:function(e,t){return{start:e.start,end:e.end,type:"Literal",value:e.value,raw:e.raw,source:e.source,astIndex:e.astIndex}},ObjectExpression:function(e,t){return{start:e.start,end:e.end,type:"ObjectExpression",properties:e.properties.map(function(e){return{key:t(e.key),value:t(e.value),kind:e.kind}}),source:e.source,astIndex:e.astIndex}},ArrayExpression:function(e,t){return{start:e.start,end:e.end,type:"ArrayExpression",elements:e.elements.map(t),source:e.source,astIndex:e.astIndex}},SequenceExpression:function(e,t){return{start:e.start,end:e.end,type:"SequenceExpression",expressions:e.expressions.map(t),source:e.source,astIndex:e.astIndex}},EmptyStatement:function(e,t){return{start:e.start,end:e.end,type:"EmptyStatement",source:e.source,astIndex:e.astIndex}},ThisExpression:function(e,t){return{start:e.start,end:e.end,type:"ThisExpression",source:e.source,astIndex:e.astIndex}},DebuggerStatement:function(e,t){return{start:e.start,end:e.end,type:"DebuggerStatement",source:e.source,astIndex:e.astIndex}},LabeledStatement:function(e,t){return{start:e.start,end:e.end,type:"LabeledStatement",label:e.label,body:t(e.body),source:e.source,astIndex:e.astIndex}}},r||{});return n(e)},be.findSiblings=function(e,r,n){if(!r)return[];var i=s(e,r.start),o=i.indexOf(r),a=i.slice(0,o),u=t.arr.detect(a.reverse(),function(e){return Array.isArray(e.body)}).body;if(!n)return t.arr.without(u,r);var c=u.indexOf(r);return"before"===n?u.slice(0,c):u.slice(c+1)},be.findNodeByAstIndex=function(e,t,r){r=null==r||!!r,!e.astIndex&&r&&u(e);var n=null;return De(e,null,function(e,r,i){n||r.astIndex<t||(r.astIndex!==t?e():n=r)}),n},be.findStatementOfNode=function(e,r,n){n||(n=r,r=e,e=null),e||(e={}),r.astIndex||u(r);var i,o=!1,a=["EmptyStatement","BlockStatement","ExpressionStatement","IfStatement","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","SwitchStatement","ReturnStatement","ThrowStatement","TryStatement","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","DebuggerStatement","FunctionDeclaration","VariableDeclaration","ClassDeclaration"];return De(r,{},function(s,u,c,l){if(!(o||u.astIndex<n.astIndex)){if(u===n||u.astIndex===n.astIndex)if(o=!0,e.asPath)i=l;else{var f=t.Path(l);do{i=f.get(r),f=f.slice(0,f.size()-1)}while(-1==a.indexOf(i.type)&&f.size()>0)}!o&&s()}}),i},be.addAstIndex=u,be.visitors={stopAtFunctions:be.make({Function:function(){}},be.base),withMemberExpression:be.make({MemberExpression:function(e,t,r){r(e.object,t,"Expression"),r(e.property,t,"Expression")}},be.base)};var xe=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){return this.doFunc(e,r,n),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n)}}],[{key:"run",value:function(e,t,r){var n=new this;return n.doFunc=t,n.accept(e,r,[]),r}}]),t}(),we=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){switch(e.type){case"ArrowFunctionExpression":case"FunctionExpression":return e;case"FunctionDeclaration":return r.unshift({node:e,path:n}),e;default:return ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n)}}}],[{key:"run",value:function(e){var t=[];return(new this).accept(e,t,[]),t}}]),t}(),ke=Symbol("canBeInlined"),Ee=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){return this.replacer(ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n))}},{key:"visitBlockStatement",value:function(e,r,n){return c(ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitBlockStatement",this).call(this,e,r,n))}},{key:"visitProgram",value:function(e,r,n){return c(ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"visitProgram",this).call(this,e,r,n))}}],[{key:"run",value:function(e,t){var r=new this;return r.replacer=t,r.accept(e,null,[])}}]),t}(),Se=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){return this.replacer(ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n),n)}}],[{key:"run",value:function(e,t){var r=new this;return r.replacer=t,r.accept(e,null,[])}}]),t}();acorn.walk.addSource=l;var Ae={withMozillaAstDo:function(e,t,r){var n=new i,o=n.accept;return n.accept=function(e,i,a){return t=r(function(){o.call(n,e,i,a)},e,i,a),e},n.accept(e,t,[]),t},printAst:function(e,r){var n,i,a=(r=r||{}).printSource||!1,s=r.printPositions||!1,u=r.printIndex||!1,c=[];return"string"==typeof e?(n=e,i=d(e)):(i=e,n=r.source||i.source),a&&!i.source&&(n||(i=d(n=o(i))),l(i,n)),(new me).accept(i,{index:0,tree:c},[]),t.string.printTree(c[0],function(e){var r=e.path+":"+e.node.type,i=[];if(u&&i.push(e.index),s&&i.push(e.node.start+"-"+e.node.end),a){var o=e.node.source||n.slice(e.node.start,e.node.end),c=t.string.print(o.truncate(60).replace(/\n/g,"").replace(/\s+/g," "));i.push(c)}return i.length&&(r+="("+i.join(",")+")"),r},function(e){return e.children},"  ")},compareAst:function(e,t){if(!e||!t)throw new Error("node"+(e?"1":"2")+" not defined");var r={completePath:[],comparisons:{errors:[]}};return(new ve).accept(e,t,r,[]),r.comparisons.errors.length?r.comparisons.errors.pluck("msg"):null},pathToNode:function(e,t,r){r=r||{},e.astIndex||u(e);var n=new i,o=null;return(n.accept=function(e,r,n,i){if(!o){var a=r.concat(i);if(e.astIndex===t){var s=a.map(function(e){return"string"==typeof e?"."+e:"["+e+"]"}).join("");o={pathString:s,path:a,node:e}}return this["visit"+e.type](e,a,n,i)}}).call(n,e,[],{},[]),o},rematchAstWithSource:function(e,r,n,o){var a=d(r,(n=!!n)?{locations:!0}:void 0),s=new i;o&&(a=t.Path(o).get(a)),s.accept=function(t,r,i){var o=(i=i||[]).reduce(function(e,t){return e[t]},e);return o.start=t.start,o.end=t.end,n&&(o.loc=t.loc),this["visit"+t.type](t,r,i)},s.accept(a)}},De=Ae.withMozillaAstDo,Ce=Ae.printAst,Fe=Ae.compareAst,Oe=Ae.pathToNode,je=Ae.rematchAstWithSource,Re=/[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/,Be=Object.freeze({isIdentifier:h,id:m,literal:v,objectLiteral:function(e){for(var t=[],r=0;r<e.length;r+=2){var n=e[r];"string"==typeof n&&(n=m(n)),t.push(D(n,e[r+1]))}return{properties:t,type:"ObjectExpression"}},prop:D,exprStmt:y,returnStmt:g,empty:function(){return{type:"EmptyStatement"}},binaryExpr:function(e,t,r){return{left:e,right:r,operator:t,type:"BinaryExpression"}},funcExpr:b,funcCall:_,varDecl:x,member:w,memberChain:k,assign:function(e,t){return{type:"AssignmentExpression",operator:"=",right:t?"string"==typeof t?m(t):t:m("undefined"),left:"string"==typeof e?m(e):e}},block:E,program:S,tryStmt:A,ifStmt:function(e){return{consequent:arguments.length>1&&void 0!==arguments[1]?arguments[1]:E(),alternate:arguments.length>2&&void 0!==arguments[2]?arguments[2]:E(),test:e,type:"IfStatement"}},forIn:function(e,t,r){return{type:"ForInStatement",left:"string"==typeof e?x(e):e,right:"string"==typeof t?m(t):t,body:r}},conditional:function(e){return{consequent:arguments.length>1&&void 0!==arguments[1]?arguments[1]:m("undefined"),alternate:arguments.length>2&&void 0!==arguments[2]?arguments[2]:m("undefined"),test:e,type:"ConditionalExpression"}},logical:function(e,t,r){return{operator:e,left:t,right:r,type:"LogicalExpression"}}}),Pe={declIds:function(e){for(var t=[],r=0;r<e.length;r++){var n=e[r];if(n)if("Identifier"===n.type)t.push(n);else if("RestElement"===n.type)t.push(n.argument);else if("AssignmentPattern"===n.type)t.push.apply(t,he(Pe.declIds([n.left])));else if("ObjectPattern"===n.type)for(var i=0;i<n.properties.length;i++){var o=n.properties[i];t.push.apply(t,he(Pe.declIds([o.value||o])))}else"ArrayPattern"===n.type&&t.push.apply(t,he(Pe.declIds(n.elements)))}return t},varDecls:function(e){return t.arr.flatmap(e.varDecls,function(e){return t.arr.flatmap(e.declarations,function(e){return Pe.declIds([e.id]).map(function(t){return[e,t]})})})},varDeclIds:function(e){return Pe.declIds(e.varDecls.reduce(function(e,t){return e.push.apply(e,t.declarations),e},[]).map(function(e){return e.id}))},objPropertiesAsList:function(e,r,n){return t.arr.flatmap(e.properties,function(e){var i=e.key.name,o=[],a={key:r.concat([i]),value:e.value};switch(e.value.type){case"ArrayExpression":case"ArrayPattern":n||o.push(a),o=o.concat(t.arr.flatmap(e.value.elements,function(e,t){return Pe.objPropertiesAsList(e,r.concat([i,t]),n)}));break;case"ObjectExpression":case"ObjectPattern":n||o.push(a),o=o.concat(Pe.objPropertiesAsList(e.value,r.concat([i]),n));break;case"AssignmentPattern":n||o.push(a),o=o.concat(Pe.objPropertiesAsList(e.left,r.concat([i]),n));break;default:o.push(a)}return o})},isDeclaration:function(e){return"FunctionDeclaration"===e.type||"VariableDeclaration"===e.type||"ClassDeclaration"===e.type}},Te=["true","false","null","undefined","arguments","Object","Function","Array","Number","parseFloat","parseInt","Infinity","NaN","Boolean","String","Symbol","Date","Promise","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","JSON","Math","console","ArrayBuffer","Uint8Array","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","Uint8ClampedArray","DataView","Map","Set","WeakMap","WeakSet","Proxy","Reflect","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape","eval","isFinite","isNaN","Intl","navigator","window","document","Blob","setTimeout","clearTimeout","setInterval","clearInterval","requestAnimationFrame","cancelAnimationFrame","btoa","atob","sessionStorage","localStorage","$world","lively"],Ie=["EmptyStatement","BlockStatement","ExpressionStatement","IfStatement","BreakStatement","ContinueStatement","WithStatement","ReturnStatement","ThrowStatement","TryStatement","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement","DebuggerStatement","FunctionDeclaration","VariableDeclaration","ClassDeclaration","ImportDeclaration","ImportDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],Le=Object.freeze({helpers:Pe,knownGlobals:Te,scopes:C,nodesAtIndex:function(e,t){return De(e,[],function(e,r,n){return r.start<=t&&t<=r.end&&(n.push(r),e()),n})},scopesAtIndex:F,scopeAtIndex:function(e,r){return t.arr.last(F(e,r))},scopesAtPos:function(e,t){return N(e,t).filter(function(e){return"Program"===e.type||"FunctionDeclaration"===e.type||"FunctionExpression"===e.type})},nodesInScopeOf:function(e){return De(e,{root:e,result:[]},function(e,t,r){return r.result.push(t),t===r.root||"Program"!==t.type&&"FunctionDeclaration"!==t.type&&"FunctionExpression"!==t.type?(e(),r):r}).result},declarationsOfScope:O,_declaredVarNames:R,_findJsLintGlobalDeclarations:B,topLevelDeclsAndRefs:L,topLevelFuncDecls:P,findGlobalVarRefs:function(e,t){var r=L(e,t),n=r.declaredNames.concat(Te);return r.refs.filter(function(e){return-1===n.indexOf(e.name)})},findNodesIncludingLines:function(e,r,n,i){if(!r&&!e)throw new Error("Need at least ast or code");return r=r||o(e),e=e&&e.loc?e:d(r,{locations:!0}),De(e,[],function(e,r,i){return n.every(function(e){return t.num.between(e,r.loc.start.line,r.loc.end.line)})&&(t.arr.pushIfNotIncluded(i,r),e()),i})},findReferencesAndDeclsInScope:function(e,r){function n(e){return e.params.concat(t.arr.pluck(e.funcDecls,"id")).concat(t.arr.pluck(e.classDecls,"id")).concat(Pe.varDeclIds(e))}return"this"===r?e.thisRefs:t.arr.flatten(t.tree.map(e,function(e){return e.refs.concat(n(e)).filter(function(e){return e.name===r})},function(e){return e.subScopes.filter(function(e){return n(e).every(function(e){return e.name!==r})})}))},findDeclarationClosestToIndex:function(e,r,n){var i=null;return t.arr.detect(F(e,n).reverse(),function(e){var n=O(e,!0),o=t.arr.pluck(n,"name").indexOf(r);return-1!==o&&(i=n[o],!0)}),i},nodesAt:N,statementOf:M,resolveReferences:I,refWithDeclAt:function(e,t){var r=!0,n=!1,i=void 0;try{for(var o,a=t.resolvedRefMap.values()[Symbol.iterator]();!(r=(o=a.next()).done);r=!0){var s=o.value,u=s.ref,c=u.start,l=u.end;if(c<=e&&e<=l)return s}}catch(e){n=!0,i=e}finally{try{!r&&a.return&&a.return()}finally{if(n)throw i}}},imports:function(e){for(var t=[],r=e.node.body||[],n=0;n<r.length;n++){var i=r[n];if("ImportDeclaration"===i.type)if(0!==i.specifiers.length){var o=i.source?i.source.value:"unknown module";t.push.apply(t,he(i.specifiers.map(function(e){var t;return t="ImportNamespaceSpecifier"===e.type?"*":"ImportDefaultSpecifier"===e.type?"default":"ImportSpecifier"===e.type?e.imported.name:null,{local:e.local?e.local.name:null,imported:t,fromModule:o,node:i}})))}else t.push({local:null,imported:null,fromModule:i.source.value,node:i})}return t},exports:function(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&I(e);var r=e.exportDecls.reduce(function(t,r){var n=M(e.node,r);if(!n)return t;var i=n.source?n.source.value:null;if("ExportAllDeclaration"===n.type)return t.concat([{local:null,exported:"*",imported:"*",fromModule:i,node:r,type:"all"}]);if("ExportDefaultDeclaration"===n.type){if(Pe.isDeclaration(n.declaration))return t.concat({local:n.declaration.id.name,exported:"default",type:"FunctionDeclaration"===n.declaration.type?"function":"ClassDeclaration"===n.declaration.type?"class":null,fromModule:null,node:r,decl:n.declaration,declId:n.declaration.id});if("Identifier"===n.declaration.type){var o=e.resolvedRefMap.get(n.declaration)||{},a=o.decl,s=o.declId;return t.concat([{local:n.declaration.name,exported:"default",fromModule:null,node:r,type:"id",decl:a,declId:s}])}return t.concat([{local:null,exported:"default",fromModule:null,node:r,type:"expr",decl:n.declaration,declId:n.declaration}])}return n.specifiers&&n.specifiers.length?t.concat(n.specifiers.map(function(t){var n,o;if(i)n=r,o=t.exported;else if(t.local){var a=e.resolvedRefMap.get(t.local);n=a?a.decl:null,o=a?a.declId:null}return{local:!i&&t.local?t.local.name:null,exported:t.exported?t.exported.name:null,imported:i&&t.local?t.local.name:null,fromModule:i||null,type:"id",node:r,decl:n,declId:o}})):n.declaration&&n.declaration.declarations?t.concat(n.declaration.declarations.map(function(e){return{local:e.id.name,exported:e.id.name,type:n.declaration.kind,fromModule:null,node:r,decl:e,declId:e.id}})):n.declaration?t.concat({local:n.declaration.id.name,exported:n.declaration.id.name,type:"FunctionDeclaration"===n.declaration.type?"function":"ClassDeclaration"===n.declaration.type?"class":null,fromModule:null,node:r,decl:n.declaration,declId:n.declaration.id}):t},[]);return t.arr.uniqBy(r,function(e,t){return e.local==t.local&&e.exported==t.exported&&e.fromModule==t.fromModule})}}),Ne=function(e){function t(){return ae(this,t),fe(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return le(t,i),se(t,[{key:"accept",value:function(e,r,n){return"ObjectExpression"===e.type&&(e=this.transformSpreadElement(e)),ce(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n)}},{key:"transformSpreadElement",value:function(e){var t=[],r=[t];return e.properties.forEach(function(e){"SpreadElement"!==e.type?t.push(e):(r.push(e),t=[],r.push(t))}),1===r.length?e:(t.length||r.pop(),_.apply(void 0,[w("Object","assign")].concat(he(r.map(function(e){return"SpreadElement"===e.type?e.argument:{properties:e,type:"ObjectExpression"}})))))}}]),t}(),Me=/^\s*(\{|function\s*\()/,qe=Object.freeze({replaceNode:z,replaceNodes:V,replace:function(e,t,r,n){var i="object"===(void 0===e?"undefined":oe(e))?e:null;return z(t,r,"string"==typeof e?e:i.source||q(i))},_compareNodesForReplacement:U,oneDeclaratorPerVarDecl:function(e){var r="object"===(void 0===e?"undefined":oe(e))?e:d(e),n="string"==typeof e?e:r.source||q(r);return V(function e(r){return t.arr.flatten(r.varDecls.concat(r.subScopes.map(e)))}(C(r)).map(function(e){return{target:e,replacementFunc:function(e,t,r){return r&&(e=d(t).body[0]),e.declarations.map(function(e){return{type:"VariableDeclaration",kind:"var",declarations:[e]}})}}}),n)},oneDeclaratorForVarsInDestructoring:function(e){var r="object"===(void 0===e?"undefined":oe(e))?e:d(e),n="string"==typeof e?e:r.source||q(r);return V(function e(r){return t.arr.flatten(r.varDecls.concat(r.subScopes.map(e)))}(C(r)).map(function(e){return{target:e,replacementFunc:function(e,r,n){return n&&(e=d(r).body[0]),t.arr.flatmap(e.declarations,function(e){var r={type:"Identifier",name:"__temp"},n={type:"VariableDeclaration",kind:"var",declarations:[{type:"VariableDeclarator",id:r,init:e.init}]},i=Pe.objPropertiesAsList(e.id,[],!1).map(function(e){return e.key}).map(function(e){return x(t.arr.last(e),k.apply(void 0,[r.name].concat(he(e))),"var")});return[n].concat(i)})}}}),n)},returnLastStatement:G,wrapInFunction:function(e,t){var r=G(e,t=t||{});return t.asAST?S(b.apply(void 0,[{id:t.id||void 0},[]].concat(he(r.body)))):"function"+(t.id?" "+t.id:"")+"() {\n"+r+"\n}"},wrapInStartEndCall:function(e,r){"string"==typeof e&&(e=d(e)),r=r||{};var n="Program"===e.type,i=r.startFuncNode||m("__start_execution"),o=r.endFuncNode||m("__end_execution"),a=P(e),s=e.body,u=[];a.forEach(function(r){var n=r.node,i=r.path;t.Path(i).set(e,y(n.id)),u.push(n)}),s.unshift(y(_(i)));var c=t.arr.last(s);return"ExpressionStatement"===c.type?(s.pop(),s.push(y(_(o,m("null"),c.expression)))):"VariableDeclaration"===c.type&&"Identifier"===t.arr.last(c.declarations).id.type?s.push(y(_(o,m("null"),t.arr.last(c.declarations).id))):s.push(y(_(o,m("null"),m("undefined")))),u.push(A.apply(void 0,["err",[y(_(o,m("err"),m("undefined")))]].concat(he(s)))),n?S.apply(void 0,u):E.apply(void 0,u)},transformSingleExpression:function(e){if(!Me.test(e)||e.split("\n").length>30)return e;try{var t=p(e);1===t.body.length&&("FunctionDeclaration"===t.body[0].type||"BlockStatement"===t.body[0].type&&"LabeledStatement"===t.body[0].body[0].type)&&(e="("+e.replace(/;\s*$/,"")+")")}catch(e){"undefined"!=typeof $world?$world.logError(e):console.error("Eval preprocess error: %s",e.stack||e)}return e},objectSpreadTransform:function(e){return(new Ne).accept(e,{},[])}}),$e=Object.freeze({getCommentPrecedingNode:function(e,r){var n=M(e,r,{asPath:!0}).slice(0,-2),i=t.Path(n).get(e);return i.comments&&i.comments.length?t.chain(H(e)).reversed().detect(function(e){return e.followingNode===r}).value():null},extractComments:H}),We=Object.freeze({findDecls:J}),Ue=/^(?!(?:do|if|in|for|let|new|try|var|case|default|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/,ze=d("").constructor;Object.defineProperty(ze.prototype,"__serialize__",{configurable:!0,value:function(){return{__expr__:"("+JSON.stringify(this)+")"}}}),e.escodegen=ge,e.acorn=acorn,e.query=Le,e.transform=qe,e.comments=$e,e.categorizer=We,e.stringify=o,e.nodes=Be,e.isValidIdentifier=function(e){return Ue.test(e)},e.BaseVisitor=i,e.withMozillaAstDo=De,e.printAst=Ce,e.compareAst=Fe,e.pathToNode=Oe,e.rematchAstWithSource=je,e.ReplaceManyVisitor=Ee,e.ReplaceVisitor=Se,e.parse=d,e.parseFunction=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=d("("+e+")",t);return xe.run(r,function(r,n,i){r._positionFixed||(r._positionFixed=!0,(r.start||0===r.start)&&(r.start+=-1,r.end+=-1),t.addSource&&!r.source&&(r.source=e.slice(r.start,r.end)))}),r.body[0].expression},e.fuzzyParse=p}(this.lively.ast=this.lively.ast||{},lively.lang,e.escodegen,acorn)}.call(e),"undefined"!=typeof module&&module.exports&&(module.exports=e.lively.ast),t&&(e.define=t)}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;void 0===lively.lang&&(e.livey.lang={})}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(e,t,r){"use strict";function n(e){return e.hasOwnProperty(T)}function i(e){if(n(e)){var t=s(e),r=t.properties,i=t.propertySettings;e[I]={properties:r,propertySettings:i},r&&"object"===(void 0===r?"undefined":S(r))?o(e,i,r):console.warn("Class "+e.name+" indicates it has managed properties but its properties accessor ("+T+") does not return a valid property descriptor map")}}function o(e,t,r){a(e);var n=t.valueStoreProperty,i=t.defaultGetter,o=t.defaultSetter,s=e.prototype;Object.keys(r).forEach(function(e){var t=r[e];if(!(s.hasOwnProperty(e)&&s.__lookupGetter__(e))){var a=t.get||"function"==typeof i&&function(){return i.call(this,e)}||function(){return this[n][e]};s.__defineGetter__(e,a)}if(!(s.hasOwnProperty(e)&&s.__lookupSetter__(e))&&(t.hasOwnProperty("set")||!t.readOnly)){var u=t.set||"function"==typeof o&&function(t){o.call(this,e,t)}||function(t){this[n][e]=t};s.__defineSetter__(e,u)}})}function a(e){Object.defineProperty(e.prototype,"propertiesAndPropertySettings",{enumerable:!1,configurable:!0,writable:!0,value:function(){var e=this.constructor;return e[I]||s(e)}}),Object.defineProperty(e.prototype,"initializeProperties",{enumerable:!1,configurable:!0,writable:!0,value:function(e){var t=this.propertiesAndPropertySettings(),r=t.properties;return u(this,t.propertySettings,r,e),this}})}function s(e){for(var r=F({},L),n={},i=t.obj.valuesInPropertyHierarchy(e,"propertySettings"),o=t.obj.valuesInPropertyHierarchy(e,"properties"),a=0;a<i.length;a++){var s=i[a];s&&"object"===(void 0===s?"undefined":S(s))&&Object.assign(r,s)}for(a=0;a<o.length;a++){var u=o[a];if("object"===(void 0===u?"undefined":S(u)))for(var c in u)n.hasOwnProperty(c)?Object.assign(n[c],u[c]):n[c]=u[c];else console.error("[initializeProperties] "+e+" encountered property declaration that is not a JS object: "+u)}return{properties:n,propertySettings:r}}function u(e,r,n,i){var o=r.valueStoreProperty,a=t.obj.sortKeysWithBeforeAndAfterConstraints(n),s=[],u={};e.hasOwnProperty(o)||(e[o]={});for(m=0;m<a.length;m++){var c=a[m],l=n[c],f=l.derived,p=!!l.foldable,d=l.hasOwnProperty("defaultValue")?l.defaultValue:void 0;Array.isArray(d)&&(d=d.slice()),f||p||(e[o][c]=d);var h=void 0;l.hasOwnProperty("initialize")?(h=u[c]={initialize:d},s.push(c)):f&&void 0!==d?(h=u[c]={derived:d},s.push(c)):p&&void 0!==d&&(h=u[c]={folded:d},s.push(c)),i&&c in i&&(l.readOnly?console.warn("Trying to initialize read-only property "+c+" in "+e+", skipping setting value"):(h||(h=u[c]={},s.push(c)),h.value=i[c]))}for(var m=0;m<s.length;m++){var v=s[m],y=u[v],g=y.hasOwnProperty("value");if(y.hasOwnProperty("initialize")){var b=g?y.value:y.initialize;n[v].initialize.call(e,b),g&&(e[v]=y.value)}else y.hasOwnProperty("derived")?e[v]=g?y.value:y.derived:y.hasOwnProperty("folded")?e[v]=g?y.value:y.folded:g&&(e[v]=y.value)}}function c(e,t){var r=t?"function"==typeof t?t:t.value?t.value:Object:Object,n=e&&e[q];return n&&n===r||(d(r),e[q]=r,H(e.prototype,r.prototype),r!==Object&&H(e,r)),r}function l(e,t,r){if(r=Object.assign(r,G),r.value.displayName=r.key,r.needsDeclaringClass){var n=r.value.originalFunction||r.value;r.value=Object.assign(function(){return n.call.apply(n,[this,t].concat(Array.prototype.slice.call(arguments)))},{originalFunction:n,toString:function(){return n.toString()},displayName:r.key})}Object.defineProperty(e,r.key,r)}function f(e,t){t=Object.assign(t,V),Object.defineProperty(e,t.key,t)}function p(e,t,r){r&&r.forEach(function(t){t.value?l(e,e,t):f(e,t)}),t&&t.forEach(function(t){t.value?l(e.prototype,e,t):f(e.prototype,t)}),e.prototype[N]?Object.getOwnPropertySymbols(e.prototype).includes(N)&&e.prototype[N].isDefaultInitializer&&e[q].prototype[N]&&delete e.prototype[N]:(Object.defineProperty(e.prototype,N,{enumerable:!1,configurable:!0,writable:!0,value:function(){}}),e.prototype[N].isDefaultInitializer=!0,e.prototype[N].displayName="lively-initialize");for(var n=t.map(function(e){return e.key}).concat(["constructor","arguments","caller"]),i=Object.getOwnPropertyNames(e.prototype),o=0;o<i.length;o++){var a=i[o];n.includes(a)||delete e.prototype[a]}for(var s=r.map(function(e){return e.key}).concat(["length","name","prototype","arguments","caller"]),u=Object.getOwnPropertyNames(e),c=0;c<u.length;c++){var p=u[c];s.includes(p)||delete e[p]}}function d(e){e===Object||e.prototype[N]||(Object.defineProperty(e.prototype,N,{enumerable:!1,configurable:!0,writable:!0,value:function(){e.apply(this,arguments)}}),e.prototype[N].displayName="lively-initialize-stub")}function h(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},a=arguments[5],s=arguments[6],u=e.name,l=u&&o.hasOwnProperty(u)&&o[u],f=l&&l[q];l&&"function"==typeof l&&f||(l=e);c(l,t);if(p(l,r,n),l[W]=s,a){var d=a.package(),h=l[$],m=Date.now();l[$]={package:d?{name:d.name,version:d.version}:{},pathInPackage:d?a.pathInPackage():a.id,lastChange:h&&h.lastChange&&m<=h.lastChange?h.lastChange+1:m,lastSuperclassChange:0},t&&t.referencedAs&&(l.hasOwnProperty(U)&&a.unsubscribeFromToplevelDefinitionChanges(l[U]),l[U]=a.subscribeToToplevelDefinitionChanges(function(e,o){if(e===t.referencedAs){var a=o&&o[$],s=l[$];if(a){if(a.lastChange===s.lastSuperclassChange)return;s.lastSuperclassChange=a.lastChange}c(l,o),p(l,r,n),i(l)}}))}return l.toString=function(){var e=String(this.prototype[N]).match(z),t=this.name,r=this[q];return"class "+t+" "+(r?"extends "+r.name:"")+" {\n  constructor"+(e?e[0]:"()")+" { /*...*/ }\n}"},i(l),l}function m(e){return"ArrowFunctionExpression"===e.type||"FunctionExpression"===e.type||"FunctionDeclaration"===e.type}function v(e){return e.replace(ue,"_").replace(ce,"_")}function y(e){return ne({id:e?Y(e):null},["__first_arg__"],ae(oe(Y("__first_arg__"),"&&",Q("__first_arg__",Z(Q("Symbol","for"),ee("lively-instance-restorer")),!0)),se(),se(X(Z(Q(Q("this",Z(Q("Symbol","for"),ee("lively-instance-initialize")),!0),"apply"),Y("this"),Y("arguments"))))))}function g(e,t,n,i){console.assert("Super"===e.type);var o=t.currentMethod;o||console.warn("[lively.classes] Trying to transform es6 class but got super call outside a method! "+r.stringify(e)+" in "+n.join("."));var a=n.slice(-2),s=B(a,2),u=s[0],c=s[1];return"callee"===u&&"object"===c||"callee"===c?e:o&&"static"===o[fe]?Z(Q("Object","getPrototypeOf"),Y(pe)):Z(Q("Object","getPrototypeOf"),Q(Y(pe),"prototype"))}function b(e,t,r,n){return console.assert("CallExpression"===e.type),console.assert("Super"===e.callee.object.type),Z.apply(void 0,[Q(Z(Q(n.functionNode,"_get"),g(e.callee.object,t,r.concat(["callee","object"]),n),ee(e.callee.property.value||e.callee.property.name),Y("this")),"call"),Y("this")].concat(P(e.arguments)))}function _(e,t,r,n){return console.assert("CallExpression"===e.type),console.assert("Super"===e.callee.type),Z.apply(void 0,[Q(Z(Q(n.functionNode,"_get"),g(e.callee,t,r.concat(["callee"]),n),Z(Q("Symbol","for"),ee("lively-instance-initialize")),Y("this")),"call"),Y("this")].concat(P(e.arguments)))}function x(e,t,r,n){return console.assert("MemberExpression"===e.type),console.assert("Super"===e.object.type),Z(Q(n.functionNode,"_get"),g(e.object,t,r.concat(["object"]),n),ee(e.property.value||e.property.name),Y("this"))}function w(e,t,r,n){return console.assert("AssignmentExpression"===e.type),console.assert("Super"===e.left.object.type),Z(Q(n.functionNode,"_set"),g(e.left.object,t,r.concat(["left","object"]),n),ee(e.left.property.value||e.left.property.name),e.right,Y("this"))}function k(e,t,n,i){console.assert("ClassDeclaration"===e.type||"ClassExpression"===e.type);var o=e.body.body,a=e.superClass,s=e.id,u=e.type,c=e.start,l=e.end,f=Y("undefined"),p=Y("undefined"),d=s?s.name:"anonymous_class",h=i.evalId,m=i.sourceAccessorName,g=e["x-lively-object-meta"]||{start:c,end:l};if(o.length){var b=o.reduce(function(e,t){var r,n=t.key,i=t.kind,o=t.value,a=t.static;if("Literal"!==n.type&&"Identifier"!==n.type&&console.warn("Unexpected key in classToFunctionTransform! "+JSON.stringify(n)),"method"===i){var s=Y(d+"_"+v(n.name||n.value)+"_"),u=["key",ee(n.name||n.value),"value",F({},o,C({id:s},fe,a?"static":"proto"))];r=te(u)}else if("get"===i||"set"===i)r=te(["key",ee(n.name||n.value),i,Object.assign({},o,C({id:Y(i)},fe,a?"static":"proto"))]);else if("constructor"===i){var c=["key",Z(Q("Symbol","for"),ee("lively-instance-initialize")),"value",F({},o,C({id:Y(d+"_initialize_")},fe,"proto"))];r=te(c)}else console.warn("[lively.classes] classToFunctionTransform encountered unknown class property with kind "+i+", ignoring it, "+JSON.stringify(t));return(a?e.clazz:e.inst).push(r),e},{inst:[],clazz:[]}),_=b.inst,x=b.clazz;_.length&&(f={type:"ArrayExpression",elements:_}),x.length&&(p={type:"ArrayExpression",elements:x})}var w,k,E=i.scope;if(a&&i.currentModuleAccessor)if(i.classHolder===a.object)k=a,w=a.property.name;else{var S=E&&E.resolvedRefMap&&E.resolvedRefMap.get(a);S&&S.decl&&E.decls&&E.decls.find(function(e){return B(e,1)[0]===S.decl})&&(k=a,w=a.name)}var A=k?te(["referencedAs",ee(w),"value",k]):a||Y("undefined"),D=s&&"ClassDeclaration"===u,O=["start",ee(g.start),"end",ee(g.end)];void 0!==h&&O.push("evalId",ee(h)),m&&O.push("moduleSource",r.nodes.id(m));var j=te(O),R=Z(ne({},["superclass"],re(de,t.classHolder),re(pe,D?{type:"ConditionalExpression",test:oe(Z(Q(de,"hasOwnProperty"),ee(s.name)),"&&",oe({argument:Q(de,s),operator:"typeof",prefix:!0,type:"UnaryExpression"},"===",ee("function"))),consequent:Q(de,s),alternate:K(Q(de,s),y(s.name))}:y(s?s.name:null)),ie(Z(i.functionNode,Y(pe),Y("superclass"),f,p,Y(de),i.currentModuleAccessor||Y("undefined"),j))),A);if("ClassExpression"===u)return R;var P=R;return i.declarationWrapper&&t.classHolder===i.classHolder&&(P=Z(i.declarationWrapper,ee(s.name),ee("class"),P,i.classHolder,j)),P=re(s,P,"var"),P[le]=!0,P}function E(e,t,r,n){return e.declaration&&e.declaration[le]?[e.declaration,{declaration:e.declaration.declarations[0].id,type:"ExportDefaultDeclaration"}]:e}var S="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},A=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},D=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),C=function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e},F=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},O=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},j=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},R=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},B=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),P=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},T="properties",I=Symbol.for("lively.classes-properties-and-settings"),L={defaultSetter:null,defaultGetter:null,valueStoreProperty:"_state"},N=Symbol.for("lively-instance-initialize"),M=Symbol.for("lively-instance-restorer"),q=Symbol.for("lively-instance-superclass"),$=Symbol.for("lively-module-meta"),W=Symbol.for("lively-object-meta"),U=Symbol.for("lively-klass-changes-subscriber"),z=/\([^\\)]*\)/,V={enumerable:!1,configurable:!0},G={enumerable:!1,configurable:!0,writable:!0},H="function"==typeof Object.setPrototypeOf?function(e,t){return Object.setPrototypeOf(e,t)}:function(e,t){return e.__proto__=t};h._get=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;return void 0===a?void 0:a.call(n)},h._set=function e(t,r,n,i){var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var a=Object.getPrototypeOf(t);null!==a&&e(a,r,n,i)}else if("value"in o&&o.writable)o.value=n;else{var s=o.set;void 0!==s&&s.call(i,n)}return n};var J=Object.freeze({initializeSymbol:N,instanceRestorerSymbol:M,superclassSymbol:q,moduleMetaSymbol:$,objMetaSymbol:W,moduleSubscribeToToplevelChangesSym:U,setPrototypeOf:H,adoptObject:function(e,t){t!==e.constructor&&(e.constructor=t,H(e,t.prototype))},setSuperclass:c,initializeClass:h}),K=r.nodes.assign,Q=r.nodes.member,Y=r.nodes.id,X=r.nodes.exprStmt,Z=r.nodes.funcCall,ee=r.nodes.literal,te=r.nodes.objectLiteral,re=r.nodes.varDecl,ne=r.nodes.funcExpr,ie=r.nodes.returnStmt,oe=r.nodes.binaryExpr,ae=r.nodes.ifStmt,se=r.nodes.block,ue=/^[^_a-z]/i,ce=/[^_a-z0-9]/gi,le=Symbol(),fe=Symbol(),pe="__lively_class__",de="__lively_classholder__",he=function(e){function t(){return A(this,t),R(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return j(t,e),D(t,[{key:"accept",value:function(e,r,n){return m(e)&&(r=F({},r,{classHolder:te([]),currentMethod:e[fe]?e:r.currentMethod})),"ClassExpression"!==e.type&&"ClassDeclaration"!==e.type||(e=k(e,r,0,r.options)),"Super"===e.type&&(e=g(e,r,n,r.options)),"MemberExpression"===e.type&&e.object&&"Super"===e.object.type&&(e=x(e,r,n,r.options)),"AssignmentExpression"===e.type&&"MemberExpression"===e.left.type&&"Super"===e.left.object.type&&(e=w(e,r,n,r.options)),"CallExpression"===e.type&&"Super"===e.callee.type&&(e=_(e,r,n,r.options)),"CallExpression"===e.type&&e.callee.object&&"Super"===e.callee.object.type&&(e=b(e,r,n,r.options)),"ExportDefaultDeclaration"===(e=O(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"accept",this).call(this,e,r,n)).type?E(e,0,0,r.options):e}}],[{key:"run",value:function(e,t){var r=new this,n=t.classHolder||te([]);return r.accept(e,{options:t,classHolder:n},[])}}]),t}(r.BaseVisitor);e.runtime=J,e.classToFunctionTransform=function(e,t){var n="string"==typeof e?r.parse(e):e;return t.scope=r.query.resolveReferences(r.query.scopes(n)),he.run(n,t)}}(this.lively.classes=this.lively.classes||{},lively.lang,lively.ast),"undefined"!=typeof module&&module.exports&&(module.exports=e.lively.classes)}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;void 0===lively.lang&&(e.livey.lang={})}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(e,t,r,n){"use strict";function i(e,t){var r=z(e),i=r.refs.filter(function(e){return l(e,r,t)}),o=[],a=n.ReplaceVisitor.run(e,function(e,r){if("Property"===e.type&&i.includes(e.key)&&e.shorthand)return T(N(e.key.name),e.value);if("ExportNamedDeclaration"===e.type){var n=e.declaration,a=e.specifiers;return n&&(n.id?o.push(n.id):n.declarations&&o.push.apply(o,B(n.declarations.map(function(e){return e.id})))),a&&a.forEach(function(e){var t=e.local;return o.push(t)}),e}return"AssignmentExpression"===e.type&&i.includes(e.left)&&t.declarationWrapper?R({},e,{right:j(t.declarationWrapper,null,M(e.left.name),M("assignment"),e.right,t.captureObj,t)}):e});return n.ReplaceVisitor.run(a,function(e,r,n){return i.includes(e)&&!o.includes(e)?P(t.captureObj,e):e})}function o(e,t){var r=z(e);return n.ReplaceManyVisitor.run(e,function(e){if(!r.varDecls.includes(e)||e.declarations.every(function(e){return!c(e,t)}))return e;for(var n=[],i=0;i<e.declarations.length;i++){var o=e.declarations[i];if(c(o,t)){var s=o.init||{operator:"||",type:"LogicalExpression",left:{computed:!1,object:t.captureObj,property:o.id,type:"MemberExpression"},right:{name:"undefined",type:"Identifier"}},u=t.declarationWrapper&&o.id.name?j(t.declarationWrapper,o,M(o.id.name),M(e.kind),s,t.captureObj,t):s;if(o.id.type.includes("Pattern")){var l=a(r.declaredNames,"destructured_1"),f={type:"Identifier",name:l},p={parent:f,declaredNames:r.declaredNames},d=_(o.id,p).map(function(r){return r[G]&&r[G].capture?E(t.captureObj,r.declarations[0].id,t.declarationWrapper?j(t.declarationWrapper,null,M(r.declarations[0].id.name),M(e.kind),r.declarations[0].init,t.captureObj,t):r.declarations[0].init,!1):r});r.declaredNames.push(l),n.push.apply(n,B([I(f,u,e.kind)].concat(d)))}else n.push(E(t.captureObj,o.id,u,!1))}else n.push({type:"VariableDeclaration",kind:e.kind||"var",declarations:[o]})}return n})}function a(e,t){for(var r=t,n=1;e.indexOf(r)>-1;){if(n>1e3)throw new Error("Endless loop searching for unique variable "+r);r=r.replace(/_[0-9]+$|$/,"_"+ ++n)}return r}function s(e,r){for(var n=z(e),i=[],o=0;o<n.scope.varDecls.length;o++){var a=n.scope.varDecls[o],s=t.Path(n.scope.varDeclPaths[o]).slice(0,-1).get(e);"ForStatement"!==s.type&&"ForInStatement"!==s.type&&"ForOfStatement"!==s.type&&"ExportNamedDeclaration"!==s.type||i.push.apply(i,B(a.declarations))}return n.scope.catches.map(function(e){return e.name}).concat(i.map(function(e){return e.id.name}))}function u(e,r){for(var n=z(e),i=[],o=0;o<n.scope.varDecls.length;o++){var a=n.scope.varDecls[o],s=t.Path(n.scope.varDeclPaths[o]).slice(0,-1).get(e);"ForStatement"!==s.type&&"ForInStatement"!==s.type&&"ForOfStatement"!==s.type||i.push.apply(i,B(a.declarations))}return n.scope.catches.map(function(e){return e.name}).concat(V.declIds(i.map(function(e){return e.id})).map(function(e){return e.name}))}function c(e,t){return-1===t.excludeDecls.indexOf(e.id.name)&&(!t.includeDecls||t.includeDecls.indexOf(e.id.name)>-1)}function l(e,t,r){if(t.scope.importSpecifiers.includes(e))return!1;for(var n=0;n<t.scope.exportDecls.length;n++){var i=t.scope.exportDecls[n];if(i.declarations&&i.declarations.includes(e))return!1;if(i.declaration===e)return!1}return!r.excludeRefs.includes(e.name)&&!(r.includeRefs&&!r.includeRefs.includes(e.name))}function f(e,t){if(t.classToFunction)return r.classToFunctionTransform(e,t.classToFunction);var n=z(e);if(!n.classDecls.length)return e;for(var i=e.body.length-1;i>=0;i--){var o=e.body[i];n.classDecls.includes(o)&&e.body.splice(i+1,0,E(t.captureObj,o.id,o.id,!1))}return e}function p(e,t){for(var r=e.body,n=e.body=[],i=0;i<r.length;i++){var o=r[i];if("ExportNamedDeclaration"!==o.type||!o.declaration||"VariableDeclaration"!==o.declaration.type||o.declaration.declarations.length<=1)n.push(o);else for(var a=o.declaration.declarations,s=0;s<a.length;s++)n.push({type:"ExportNamedDeclaration",specifiers:[],declaration:I(a[s].id,a[s].init,o.declaration.kind)})}return e}function d(e,t){for(var r=[],n=0;n<e.body.length;n++){var i=e.body[n];r.push(i),"ExportNamedDeclaration"!==i.type&&"ExportDefaultDeclaration"!==i.type||!i.declaration||(i.declaration.declarations?r.push.apply(r,B(i.declaration.declarations.map(function(e){var r=e.id;return t.declarationWrapper&&(e.init.callee&&e.init.callee.name===t.declarationWrapper.name||(r=j(t.declarationWrapper,e,M(e.id.name),M("assignment"),e.id,t.captureObj,t))),E(t.captureObj,e.id,r,!1)}))):"FunctionDeclaration"===i.declaration.type||"ClassDeclaration"===i.declaration.type&&r.push(E(t.captureObj,i.declaration.id,i.declaration.id,!1)))}return e.body=r,e}function h(e,t){return e.body=e.body.reduce(function(e,r){return e.concat("ImportDeclaration"===r.type&&r.specifiers.length?[r].concat(r.specifiers.map(function(e){return E(t.captureObj,e.local,e.local,!1)})):[r])},[]),e}function m(e,r){for(var n=z(e),i=[],o=0;o<e.body.length;o++){var a=e.body[o];"ExportDefaultDeclaration"===a.type&&a.declaration&&-1===a.declaration.type.indexOf("Declaration")?i=i.concat([k(e,{type:"VariableDeclarator",id:a.declaration,init:P(r.captureObj,a.declaration)}),a]):"ExportNamedDeclaration"!==a.type||!a.specifiers.length||a.source?i.push(a):i=i.concat(a.specifiers.map(function(i){return t.arr.include(n.declaredNames,i.local.name)?null:k(e,{type:"VariableDeclarator",id:i.local,init:P(r.captureObj,i.local)})}).filter(Boolean)).concat(a)}return e.body=i,e}function v(e,t){for(var r=[],n=0;n<e.body.length;n++){var i=e.body[n];"ExportDefaultDeclaration"===i.type&&"FunctionDeclaration"===i.declaration.type&&i.declaration.id&&i.declaration.async&&(r.push(i.declaration),i.declaration={type:"Identifier",name:i.declaration.id.name}),r.push(i)}return e.body=r,e}function y(e,t){return e.body=e.body.reduce(function(r,n){var i;if("ExportNamedDeclaration"===n.type)if(n.source){a=s=n.source;i=n.specifiers.map(function(e){return{type:"ExpressionStatement",expression:S({type:"Literal",value:e.exported.name},{type:"Literal",value:e.local.name},s,t.moduleExportFunc,t.moduleImportFunc)}})}else if(n.declaration){var o=n.declaration.declarations;i=o?o.map(function(e){return t.excludeDecls.push(e.id),I(e.id,E(t.captureObj,e.id,t.declarationWrapper?j(t.declarationWrapper,null,M(e.id.name),M(n.declaration.kind),e,t.captureObj,t):e.init,!1),n.declaration.kind)}).concat(o.map(function(e){return O(t.moduleExportFunc,e.id.name,e.id)})):[n.declaration].concat(O(t.moduleExportFunc,n.declaration.id.name,n.declaration.id))}else i=n.specifiers.map(function(e){return O(t.moduleExportFunc,e.exported.name,c({id:e.local},t)?P(t.captureObj,e.local):e.local)});else if("ExportDefaultDeclaration"===n.type)i=n.declaration&&n.declaration.id?[n.declaration].concat(O(t.moduleExportFunc,"default",n.declaration.id)):[O(t.moduleExportFunc,"default",n.declaration)];else if("ExportAllDeclaration"===n.type){var a={name:t.es6ExportFuncId+"__iterator__",type:"Identifier"},s=n.source;i=[{type:"ForInStatement",body:{type:"ExpressionStatement",expression:S(a,a,s,t.moduleExportFunc,t.moduleImportFunc)},left:{type:"VariableDeclaration",kind:"var",declarations:[{type:"VariableDeclarator",id:a,init:null}]},right:D(null,s,t.moduleImportFunc)}],t.excludeRefs.push(a.name),t.excludeDecls.push(a.name)}else i="ImportDeclaration"===n.type?n.specifiers.length?n.specifiers.map(function(r){var i=r.local,o="ImportSpecifier"===r.type&&r.imported.name||"ImportDefaultSpecifier"===r.type&&"default"||null;return A(e,i,o||null,n.source,t.moduleImportFunc)}):C(null,n.source,t.moduleImportFunc):[n];return r.concat(i)},[]),e}function g(e,r){var n=z(e).scope,i=n.funcDecls;if(!i.length)return e;for(var o=[],a=i.length;a--;){var s=i[a];if(c(s,r)){var u=n.funcDeclPaths[a].slice(0,-1),l=t.Path(u).get(n.node),f={type:"Identifier",name:s.id.name},p=r.declarationWrapper?j(r.declarationWrapper,s,M(f.name),M("function"),f,r.captureObj,r):f,d=R({},s);if(Array.isArray(l))l.splice(l.indexOf(s),1,q(s.id));else if("ExportNamedDeclaration"===l.type){var h=n.node.body.indexOf(l);h>-1&&n.node.body.splice(h,1,{type:"ExportNamedDeclaration",specifiers:[{type:"ExportSpecifier",exported:s.id,local:s.id}]})}else"ExportDefaultDeclaration"===l.type&&(l.declaration=s.id);o.unshift(E(r.captureObj,f,p,!1)),o.unshift(d)}}return e.body=o.concat(e.body),e}function b(e,r){var n=z(e);return t.chain(n.scope.varDecls).pluck("declarations").flatten().value().concat(n.scope.funcDecls).reduce(function(e,t){return e[t.id.name]||(e[t.id.name]=[]),e[t.id.name].push({type:t.type,start:t.start,end:t.end}),e},{})}function _(e,t){return"ArrayPattern"===e.type?x(e,t):"ObjectPattern"===e.type?w(e,t):[]}function x(e,t){for(var r=t.declaredNames,n=G,i=[],o=0;o<e.elements.length;o++){var s=e.elements[o];if("Identifier"===s.type)(u=I(s,P(t.parent,N(o),!0)))[n]={capture:!0},i.push(u);else if("RestElement"===s.type)(u=I(s.argument,{type:"CallExpression",arguments:[{type:"Literal",value:o}],callee:P(t.parent,N("slice"),!1)}))[n]={capture:!0},i.push(u);else if("AssignmentPattern"==s.type){var u=I(s.left,$(W(P(t.parent,N(o),!0),"===",N("undefined")),s.right,P(t.parent,N(o),!0)));u[n]={capture:!0},i.push(u)}else{var c=N(a(r,t.parent.name+"$"+o)),l=I(c,P(t.parent,o));r.push(c.name),i.push(l),i.push.apply(i,B(_(s,{parent:c,declaredNames:r})))}}return i}function w(e,t){for(var r=t.declaredNames,n=G,i=[],o=0;o<e.properties.length;o++){var s=e.properties[o];if("Identifier"==s.value.type)(u=I(s.value,P(t.parent,s.key)))[n]={capture:!0},i.push(u);else if("AssignmentPattern"==s.value.type){var u=I(s.value.left,$(W(P(t.parent,s.key),"===",N("undefined")),s.value.right,P(t.parent,s.key)));u[n]={capture:!0},i.push(u)}else{var c=N(a(r,t.parent.name+"$"+s.key.name)),l=I(c,P(t.parent,s.key));l[n]={capture:!1},r.push(c.name),i.push.apply(i,B([l].concat(_(s.value,{parent:c,declaredNames:r}))))}}return i}function k(e,t,r){var n=z(e),i=t.id.name;return n.declaredNames.indexOf(i)>-1?q(L(t.id,t.init)):{declarations:[t],kind:r||"var",type:"VariableDeclaration"}}function E(e,t,r,n){return q(L(P(e,t,n),r||N("undefined")))}function S(e,t,r,n,i){return F(n,e,D(t,r,i))}function A(e,t,r,n,i){return I(t,D(r,n,i))}function D(e,t,r){return"string"==typeof e&&(e=M(e)),{arguments:[t].concat(e||[]),callee:r,type:"CallExpression"}}function C(e,t,r){return q(D(e,t,r))}function F(e,r,n){return"string"==typeof r&&(r=M(r)),n=t.obj.deepCopy(n),U(e,r,n)}function O(e,t,r){return q(F(e,t,r))}function j(e,t,r,i,o,a,s){if(t){var u=[],c=!1;if(t["x-lively-object-meta"]){var l=t["x-lively-object-meta"],f=l.start,p=l.end,d=l.evalId,h=l.sourceAccessorName;c=!0,u.push("start",n.nodes.literal(f),"end",n.nodes.literal(p))}if(void 0===d&&s.hasOwnProperty("evalId")&&(d=s.evalId,c=!0),void 0===h&&s.hasOwnProperty("sourceAccessorName")&&(h=s.sourceAccessorName,c=!0),void 0!==d&&u.push("evalId",n.nodes.literal(d)),h&&u.push("moduleSource",n.nodes.id(h)),c)return U(e,r,i,o,a,n.nodes.objectLiteral(u))}return U(e,r,i,o,a)}var R=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},B=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},P=n.nodes.member,T=n.nodes.prop,I=n.nodes.varDecl,L=n.nodes.assign,N=n.nodes.id,M=n.nodes.literal,q=n.nodes.exprStmt,$=n.nodes.conditional,W=n.nodes.binaryExpr,U=n.nodes.funcCall,z=n.query.topLevelDeclsAndRefs,V=n.query.helpers,G=Symbol("lively.ast-destructuring-transform"),H=Object.freeze({rewriteToCaptureTopLevelVariables:function(e,r,n){r||(r={type:"Identifier",name:"__rec"});var a=e;if((n=R({ignoreUndeclaredExcept:null,includeRefs:null,excludeRefs:n&&n.exclude||[],includeDecls:null,excludeDecls:n&&n.exclude||[],recordDefRanges:!1,es6ExportFuncId:null,es6ImportFuncId:null,captureObj:r,moduleExportFunc:{name:n&&n.es6ExportFuncId||"_moduleExport",type:"Identifier"},moduleImportFunc:{name:n&&n.es6ImportFuncId||"_moduleImport",type:"Identifier"},declarationWrapper:void 0,classToFunction:n&&n.hasOwnProperty("classToFunction")?n.classToFunction:{classHolder:r,functionNode:{type:"Identifier",name:"_createOrExtendClass"},declarationWrapper:n&&n.declarationWrapper,evalId:n&&n.evalId,sourceAccessorName:n&&n.sourceAccessorName}},n)).ignoreUndeclaredExcept){var c=z(e);n.excludeRefs=t.arr.withoutAll(c.undeclaredNames,n.ignoreUndeclaredExcept).concat(n.excludeRefs),n.excludeDecls=t.arr.withoutAll(c.undeclaredNames,n.ignoreUndeclaredExcept).concat(n.excludeDecls)}n.excludeRefs=n.excludeRefs.concat(n.captureObj.name),n.excludeDecls=n.excludeDecls.concat(n.captureObj.name);n.recordDefRanges&&b(a);return n.excludeRefs=n.excludeRefs.concat(u(e)),n.excludeDecls=n.excludeDecls.concat(s(e)),a=v(a),n.es6ExportFuncId&&(n.excludeRefs.push(n.es6ExportFuncId),n.excludeRefs.push(n.es6ImportFuncId),a=y(a,n)),a=i(a,n),a=o(a,n),a=f(a,n),a=p(a),a=d(a,n),a=h(a,n),a=m(a,n),a=g(a,n)},rewriteToRegisterModuleToCaptureSetters:function(e,r,i){i=R({captureObj:r||{type:"Identifier",name:"__rec"},exclude:[],declarationWrapper:void 0},i);var o=t.Path("body.0.expression").get(e);if("System"!==o.callee.object.name)throw new Error("rewriteToRegisterModuleToCaptureSetters: input doesn't seem to be a System.register call: "+n.stringify(e).slice(0,300)+"...");if("register"!==o.callee.property.name)throw new Error("rewriteToRegisterModuleToCaptureSetters: input doesn't seem to be a System.register call: "+n.stringify(e).slice(0,300)+"...");var a=t.Path("arguments.1.body.body").get(o),s=t.arr.last(a);if("ReturnStatement"!==s.type)throw new Error("rewriteToRegisterModuleToCaptureSetters: input doesn't seem to be a System.register call, at return statement: "+n.stringify(e).slice(0,300)+"...");var u=s.argument.properties.find(function(e){return"setters"===e.key.name});if(!u)throw new Error("rewriteToRegisterModuleToCaptureSetters: input doesn't seem to be a System.register call, at finding setters: "+n.stringify(e).slice(0,300)+"...");var c=s.argument.properties.find(function(e){return"execute"===e.key.name});if(!c)throw new Error("rewriteToRegisterModuleToCaptureSetters: input doesn't seem to be a System.register call, at finding execute: "+n.stringify(e).slice(0,300)+"...");u.value.elements.forEach(function(e){return e.body.body=e.body.body.map(function(e){if("ExpressionStatement"!==e.type||"AssignmentExpression"!==e.expression.type||"Identifier"!==e.expression.left.type||t.arr.include(i.exclude,e.expression.left.name))return e;var r=e.expression.left,n=i.declarationWrapper?j(i.declarationWrapper,null,M(r.name),M("var"),e.expression,i.captureObj,i):e.expression;return q(L(P(i.captureObj,r),n))})});var l=c.value.body.body.find(function(e){return"ExpressionStatement"===e.type&&"AssignmentExpression"==e.expression.type&&e.expression.left.name===i.captureObj.name});if(l||(l=c.value.body.body.find(function(e){return"VariableDeclaration"===e.type&&e.declarations[0].id&&e.declarations[0].id.name===i.captureObj.name})),l&&(t.arr.remove(c.value.body.body,l),t.arr.pushAt(a,l,a.length-1)),i.sourceAccessorName){var f=c.value.body.body.find(function(e){return"ExpressionStatement"===e.type&&"AssignmentExpression"==e.expression.type&&e.expression.left.name===i.sourceAccessorName});f||(f=c.value.body.body.find(function(e){return"VariableDeclaration"===e.type&&e.declarations[0].id&&e.declarations[0].id.name===i.sourceAccessorName})),f&&(t.arr.remove(c.value.body.body,f),t.arr.pushAt(a,f,a.length-1))}return e}});e.capturing=H,e.stringifyFunctionWithoutToplevelRecorder=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"__lvVarRecorder";"function"==typeof e&&(e=String(e));var r="string"==typeof e?n.parseFunction(e):e,i=n.ReplaceVisitor.run(r,function(e){return"MemberExpression"===e.type&&"Identifier"===e.object.type&&e.object.name===t?e.property:e});return n.stringify(i)}}(this.lively.sourceTransform=this.lively.sourceTransform||{},lively.lang,lively.classes,lively.ast),"undefined"!=typeof module&&module.exports&&(module.exports=e.lively.sourceTransform)}(),function(){var GLOBAL="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(exports,lively_lang,lively_ast,lively_sourceTransform,lively_classes,lively_notifications){"use strict";function getGlobal(){return"undefined"!=typeof System?System.global:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof Global?Global:"undefined"!=typeof self?self:function(){return this}()}function signatureOf(e,t){var r=String(t).match(/function\s*[a-zA-Z0-9_$]*\s*\(([^\)]*)\)/);return e+"("+(r&&r[1]||"")+")"}function pluck(e,t){return e.map(function(e){return e[t]})}function printSymbol(e){if(Symbol.keyFor(e))return'Symbol.for("'+Symbol.keyFor(e)+'")';if(knownSymbols.get(e))return knownSymbols.get(e);String(e).match(symMatcher);return String(e)}function safeToString(e){if(!e)return String(e);if(Array.isArray(e))return"["+e.map(safeToString).join(",")+"]";if("symbol"===(void 0===e?"undefined":_typeof(e)))return printSymbol(e);try{return String(e)}catch(e){throw new Error("Cannot print object: "+e.stack)}}function printEvalResult(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=e.value,n=e.isError,i=e.isPromise,o=e.promisedValue,a=e.promiseStatus;if(n||r instanceof Error){var s=r,u=String(s),c=s.stack||"";return c&&s.message!==s.stack&&(0===(c=String(c)).indexOf(u)&&(c=c.slice(u.length)),u+="\n"+c),u}if(i){var l=lively_lang.string.print(a),f="pending"===a?void 0:printEvalResult({value:o},t);return"Promise({status: "+l+", "+(void 0===r?"":"value: "+f)+"})"}return r instanceof Promise?'Promise({status: "unknown"})':t.inspect?printInspectEvalValue(r,t.inspectDepth||2):String(r)}function getObjectForCompletion(e,t){var r="";return Promise.resolve().then(function(){var n=t.lastIndexOf(".");return n>=0?(r=t.slice(n+1),t=t.slice(0,n)):(r=t,t='(typeof window === "undefined" ? global : window)'),e(t)}).then(function(e){return{evalResult:e,startLetters:r,code:t}})}function propertyExtract(e,t,r){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t).map(printSymbol)).filter(function(t){return-1===e.indexOf(t)}).map(r).filter(function(e){return!!e}).sort(function(e,t){return e.name<t.name?-1:e.name>t.name?1:0})}function getMethodsOf(e,t){return propertyExtract(e,t,function(e){return t.__lookupGetter__&&t.__lookupGetter__(e)||"function"!=typeof t[e]?null:{name:e,completion:signatureOf(e,t[e])}})}function getAttributesOf(e,t){return propertyExtract(e,t,function(e){return t.__lookupGetter__&&!t.__lookupGetter__(e)&&"function"==typeof t[e]?null:{name:e,completion:e}})}function getProtoChain(e){for(var t=[];e;)t.push(e),e=e.__proto__;return t}function getDescriptorOf(e,t){function r(e,t){return e.length>t&&(e=e.slice(0,t)+"..."),e.replace(/\n/g,"").replace(/\s+/g," ")}if(e===t){if("function"!=typeof e)return r(safeToString(e),50);var n=e.toString(),i=r(n.slice(n.indexOf("{")+1,n.lastIndexOf("}")),50);return signatureOf(e.displayName||e.name||"function",e)+" {"+i+"}"}var o=t.hasOwnProperty("constructor")&&t.constructor;return o?"string"==typeof o.type&&o.type.length?r(o.type,50):"string"==typeof o.name&&o.name.length?r(o.name,50):"anonymous class":"prototype"}function descriptorsOfObjAndProtoProperties(e){var t=[];return getProtoChain(e).map(function(r){var n=getDescriptorOf(e,r),i=getMethodsOf(t,r).concat(getAttributesOf(t,r));return t=t.concat(pluck(i,"name")),[n,pluck(i,"completion")]})}function getCompletions(e,t,r){var n=getObjectForCompletion(e,t).then(function(e){var t=e.evalResult,r={completions:descriptorsOfObjAndProtoProperties(t&&t.isEvalResult?t.value:t),startLetters:e.startLetters,code:e.code};return t&&t.isPromise&&("fulfilled"===t.promiseStatus?r.promiseResolvedCompletions=descriptorsOfObjAndProtoProperties(t.promisedValue):"rejected"===t.promiseStatus&&(r.promiseRejectedCompletions=descriptorsOfObjAndProtoProperties(t.promisedValue))),r});return"function"==typeof r&&n.then(function(e){return r(null,e)}).catch(function(e){return r(e)}),n}function processInlineCodeTransformOptions(parsed,options){if(!parsed.comments)return options;var livelyComment=parsed.comments.find(function(e){return e.text.startsWith("lively.vm ")});if(!livelyComment)return options;try{var inlineOptions=eval("inlineOptions = {"+livelyComment.text.slice("lively.vm ".length)+"};");return Object.assign(options,inlineOptions)}catch(e){return options}}function evalCodeTransform(e,t){e=lively_ast.transform.transformSingleExpression(e);var r=lively_ast.parse(e,{withComments:!0});t=processInlineCodeTransformOptions(r,t);var n=lively_ast.query.topLevelDeclsAndRefs(r),i=n.classDecls,o=n.funcDecls,a=n.varDecls,s={};if(t.hasOwnProperty("evalId")&&(s.evalId=t.evalId),t.sourceAccessorName&&(s.sourceAccessorName=t.sourceAccessorName),[].concat(toConsumableArray(i),toConsumableArray(o)).forEach(function(e){return e["x-lively-object-meta"]=_extends({},s,{start:e.start,end:e.end})}),a.forEach(function(e){return e.declarations.forEach(function(e){return e["x-lively-object-meta"]=_extends({},s,{start:e.start,end:e.end})})}),r=lively_ast.transform.objectSpreadTransform(r),!t.topLevelVarRecorder&&t.topLevelVarRecorderName){var u=getGlobal();"GLOBAL"===t.topLevelVarRecorderName?t.topLevelVarRecorder=getGlobal():t.topLevelVarRecorder=lively_lang.Path(t.topLevelVarRecorderName).get(u)}if(t.topLevelVarRecorder){var c=(t.dontTransform||[]).concat(["arguments"]),l=t.recordGlobals?null:lively_lang.arr.withoutAll(Object.keys(t.topLevelVarRecorder),c),f=id(t.varRecorderName||"__lvVarRecorder"),p=void 0;if(t.declarationWrapperName||"function"==typeof t.declarationCallback){var d=t.declarationWrapperName||defaultDeclarationWrapperName;t.declarationWrapper=member(id(t.varRecorderName||"__lvVarRecorder"),literal(d),!0),t.declarationCallback&&(t.topLevelVarRecorder[d]=t.declarationCallback)}(!t.hasOwnProperty("transformES6Classes")||t.transformES6Classes)&&(defaultClassToFunctionConverterName in t.topLevelVarRecorder||(t.topLevelVarRecorder[defaultClassToFunctionConverterName]=lively_classes.runtime.initializeClass),p={currentModuleAccessor:t.currentModuleAccessor,classHolder:f,functionNode:member(f,defaultClassToFunctionConverterName),declarationWrapper:t.declarationWrapper,evalId:t.evalId,sourceAccessorName:t.sourceAccessorName}),r=lively_sourceTransform.capturing.rewriteToCaptureTopLevelVariables(r,f,{es6ImportFuncId:t.es6ImportFuncId,es6ExportFuncId:t.es6ExportFuncId,ignoreUndeclaredExcept:l,exclude:c,declarationWrapper:t.declarationWrapper||void 0,classToFunction:p,evalId:t.evalId,sourceAccessorName:t.sourceAccessorName,keepTopLevelVarDecls:t.keepTopLevelVarDecls})}t.wrapInStartEndCall&&(r=lively_ast.transform.wrapInStartEndCall(r,{startFuncNode:t.startFuncNode,endFuncNode:t.endFuncNode}));var h=lively_ast.stringify(r);return t.sourceURL&&(h+="\n//# sourceURL="+t.sourceURL.replace(/\s/g,"_")),h}function evalCodeTransformOfSystemRegisterSetters(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t.topLevelVarRecorder)return e;if("function"==typeof t.declarationCallback||t.declarationWrapperName){var r=t.declarationWrapperName||defaultDeclarationWrapperName;t.declarationWrapper=member(id(t.varRecorderName),literal(r),!0),t.declarationCallback&&(t.topLevelVarRecorder[r]=t.declarationCallback)}var n=lively_ast.parse(e),i=(t.dontTransform||[]).concat(["arguments"]),o=(t.recordGlobals||lively_lang.arr.withoutAll(Object.keys(t.topLevelVarRecorder),i),lively_sourceTransform.capturing.rewriteToRegisterModuleToCaptureSetters(n,id(t.varRecorderName||"__lvVarRecorder"),_extends({exclude:i},t)));return lively_ast.stringify(o)}function _normalizeEvalOptions(e){if(e||(e={}),(e=_extends({targetModule:null,sourceURL:e.targetModule,runtime:null,context:getGlobal(),varRecorderName:defaultTopLevelVarRecorderName,dontTransform:[],recordGlobals:null,returnPromise:!0,promiseTimeout:200,waitForPromise:!0,wrapInStartEndCall:!1,onStartEval:null,onEndEval:null},e)).targetModule){var t=e.runtime&&e.runtime.modules&&e.runtime.modules[e.targetModule];t&&(e=Object.assign(e,t))}return e.wrapInStartEndCall&&(e.startFuncNode={type:"MemberExpression",object:{type:"Identifier",name:e.varRecorderName},property:{type:"Literal",value:startEvalFunctionName},computed:!0},e.endFuncNode={type:"MemberExpression",object:{type:"Identifier",name:e.varRecorderName},property:{type:"Literal",value:endEvalFunctionName},computed:!0}),e}function _eval(__lvEvalStatement,__lvVarRecorder,__lvOriginalCode){return eval(__lvEvalStatement)}function runEval$1(e,t,r){"function"==typeof t&&2===arguments.length&&(r=t,t=null);var n,i,o=new EvalResult,a=!1,s=!1;t=_normalizeEvalOptions(t);var u=lively_lang.promise.deferred(),c=t.topLevelVarRecorder||getGlobal(),l=e;t.wrapInStartEndCall&&(c[startEvalFunctionName]&&console.warn(o.addWarning("startEvalFunctionName "+startEvalFunctionName+" already exists in recorder!")),c[endEvalFunctionName]&&console.warn(o.addWarning("endEvalFunctionName "+endEvalFunctionName+" already exists in recorder!")),c[startEvalFunctionName]=function(){a?console.warn(o.addWarning("onEvalStartCalled multiple times!")):(a=!0,"function"==typeof t.onStartEval&&t.onStartEval())},c[endEvalFunctionName]=function(e,n){s?console.warn(o.addWarning("onEvalEndCalled multiple times!")):(s=!0,finishEval(e,n,o,t,c,u,r))});try{e=evalCodeTransform(e,t),t.header&&(e=t.header+e),t.footer&&(e+=t.footer),t.transpiler&&(e=t.transpiler(e,t.transpilerOptions))}catch(e){console.warn(o.addWarning("lively.vm evalCodeTransform not working: "+e))}try{"undefined"!=typeof $world&&$world.get("log")&&($world.get("log").textString=e),i=_eval.call(t.context,e,t.topLevelVarRecorder,t.originalSource||l)}catch(e){n=e}return t.wrapInStartEndCall?n&&!s&&c[endEvalFunctionName](n,void 0):finishEval(n,n||i,o,t,c,u,r),t.sync?o:u.promise}function finishEval(e,t,r,n,i,o,a){n.wrapInStartEndCall&&(delete i[startEvalFunctionName],delete i[endEvalFunctionName]),e?(r.isError=!0,r.value=e):r.value=t,r.value instanceof Promise&&(r.isPromise=!0),n.sync?(r.processSync(n),"function"==typeof n.onEndEval&&n.onEndEval(e,t)):r.process(n).then(function(){return"function"==typeof a&&a(null,r),"function"==typeof n.onEndEval&&n.onEndEval(e,t),r},function(e){return"function"==typeof a&&a(e,void 0),"function"==typeof n.onEndEval&&n.onEndEval(e,void 0),r}).then(o.resolve,o.reject)}function syncEval$1(e,t){return t=Object.assign(t||{},{sync:!0}),runEval$1(e,t)}function tryToWaitForPromise(e,t){console.assert(e.isPromise,"no promise in tryToWaitForPromise???");var r={},n=new Promise(function(e){return setTimeout(e,t,r)});return Promise.race([n,e.value]).then(function(t){return Object.assign(e,t!==r?{promiseStatus:"fulfilled",promisedValue:t}:{promiseStatus:"pending"})}).catch(function(t){return Object.assign(e,{promiseStatus:"rejected",promisedValue:t})})}function ensureImportsAreImported(e,t,r){var n=lively_ast.parse(t).body.filter(function(e){return"ImportDeclaration"===e.type});return Promise.all(n.map(function(t){return e.normalize(t.source.value,r).then(function(t){return e.get(t)||e.import(t)})})).catch(function(e){throw console.error("Error ensuring imports: "+e.message),e})}function hasUnimportedImports(e,t,r){var n=lively.ast.parse(t).body.filter(function(e){return"ImportDeclaration"===e.type});return lively_lang.arr.uniq(n.map(function(e){return e.source.value})).filter(Boolean).filter(function(t){return!e.get(e.decanonicalize(t,r))}).length>0}function babelTranspilerForAsyncAwaitCode(e,t,r,n){return function(e,n){n=Object.assign({sourceMap:void 0,inputSourceMap:void 0,filename:r,code:!0,ast:!1},n);var i="(async function(__rec) {\n"+e+"\n}).call(this);",o=t.transform(i,n).code;return o=o.replace(/\}\)\.call\(undefined\);$/,"}).call(this)")}}function babelPluginTranspilerForAsyncAwaitCode(e,t,r,n){return function(n,i){var o=e.babelOptions||{},a=[];a.push(t.presetES2015),o.stage3&&a.push({plugins:t.pluginsStage3}),o.stage2&&a.push({plugins:t.pluginsStage2}),o.stage1&&a.push({plugins:t.pluginsStage1}),i=Object.assign({sourceMap:void 0,inputSourceMap:void 0,filename:r,babelrc:!1,presets:a,moduleIds:!1,code:!0,ast:!1},i);var s="(async function(__rec) {\n"+n+"\n}).call(this);",u=t.babel.transform(s,i).code;return u=u.replace(/\}\)\.call\(undefined\);$/,"}).call(this)")}}function getEs6Transpiler(e,t,r){if(t.transpiler)return t.transpiler;if(!t.es6Transpile)return null;if("babel"===e.transpiler){var n=e.global[e.transpiler]||e.get(e.decanonicalize(e.transpiler));return n?babelTranspilerForAsyncAwaitCode(e,n,t.targetModule,r):e.import(e.transpiler).then(function(n){return babelTranspilerForAsyncAwaitCode(e,n,t.targetModule,r)})}if("plugin-babel"===e.transpiler){var i=e.decanonicalize("plugin-babel").split("/").slice(0,-1).concat("systemjs-babel-browser.js").join("/"),o=e.get(i);return o?babelPluginTranspilerForAsyncAwaitCode(e,o,t.targetModule,r):e.import(i).then(function(n){return babelPluginTranspilerForAsyncAwaitCode(e,n,t.targetModule,r)})}if("lively.transpiler"===e.transpiler){var a=new(0,e.get(e.decanonicalize("lively.transpiler")).default)(e,t.targetModule,r);return function(e,t){return a.transpileDoit(e,t)}}throw new Error("Sorry, currently only babel is supported as es6 transpiler for runEval!")}function runEval$2(e,t,r){r=_extends({targetModule:null,parentModule:null,es6Transpile:!0,transpiler:null,transpilerOptions:null,format:"esm"},r);var n=t;e.debug&&console.log("[lively.module] runEval: "+t.slice(0,100).replace(/\n/gm," ")+"...");var i=r,o=i.format,a=i.targetModule,s=i.parentModule;if(a=e.decanonicalize(a||"*scratch*",s),r.targetModule=a,o){var u=e.getConfig().meta[a];u||(u={}),u[a]||(u[a]={}),u[a].format||(u[a].format=o,e.config(u))}var c=e.get("@lively-env").moduleEnv(a),l=c.recorder,f=c.recorderName,p=c.dontTransform,d=getEs6Transpiler(e,r,c),h="var _moduleExport = "+f+"._moduleExport,\n    _moduleImport = "+f+"._moduleImport;\n";if(!(r=_extends({waitForPromise:!0,sync:!1,evalId:r.evalId||c.nextEvalId(),sourceAccessorName:!r.hasOwnProperty("embedOriginalCode")||r.embedOriginalCode?"__lvOriginalCode":void 0,originalSource:n},r,{header:h,recordGlobals:!0,dontTransform:p,varRecorderName:f,topLevelVarRecorder:l,sourceURL:r.sourceURL||r.targetModule,context:r.context||l,wrapInStartEndCall:!0,es6ExportFuncId:"_moduleExport",es6ImportFuncId:"_moduleImport",transpiler:d,declarationWrapperName:c.varDefinitionCallbackName,currentModuleAccessor:funcCall(member$1(funcCall(member$1(member$1("__lvVarRecorder","System"),"get"),literal$1("@lively-env")),"moduleEnv"),literal$1(r.targetModule))})).sync&&!r.importsEnsured&&hasUnimportedImports(e,t,a))return ensureImportsAreImported(e,t,a).then(function(){return runEval$2(e,n,_extends({},r,{importsEnsured:!0}))});if(!c.record()){if(!r.sync&&!r._moduleImported)return e.import(a).catch(function(e){return null}).then(function(){return runEval$2(e,n,_extends({},r,{_moduleImported:!0}))});c.ensureRecord()}if(r.es6Transpile&&r.transpiler instanceof Promise){if(!r.sync&&!r._transpilerLoaded)return r.transpiler.catch(function(e){return console.error(e)}).then(function(t){return runEval$2(e,n,_extends({},r,{transpiler:t,_transpilerLoaded:!0}))});console.warn("[lively.vm] sync eval requested but transpiler is not yet loaded, will continue without transpilation!"),r.transpiler=null}e.debug&&console.log("[lively.module] runEval in module "+a+" started"),lively_notifications.emit("lively.vm/doitrequest",{code:n,waitForPromise:r.waitForPromise,targetModule:r.targetModule},Date.now(),e),e.get("@lively-env").evaluationStart(a);var m=runEval$1(t,r);return r.sync?evalEnd(e,n,r,m):Promise.resolve(m).then(function(t){return evalEnd(e,n,r,t)})}function evalEnd(e,t,r,n){return e.get("@lively-env").evaluationEnd(r.targetModule),e.debug&&console.log("[lively.module] runEval in module "+r.targetModule+" done"),lively_notifications.emit("lively.vm/doitresult",{code:t,result:n,waitForPromise:r.waitForPromise,targetModule:r.targetModule},Date.now(),e),n}function runEval$$1(e,t){var r=t=_extends({format:"esm",System:null,targetModule:null},t),n=r.format,i=r.System,o=r.targetModule;return i||"undefined"==typeof System||(i=System),!i&&o?Promise.reject(new Error("options to runEval have targetModule but cannot find system loader!")):o&&["esm","es6","register"].includes(n)?runEval$2(i,e,t):runEval$1(e,t)}function syncEval$$1(e,t){return syncEval$1(e,t)}var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},asyncToGenerator=function(e){return function(){var t=e.apply(this,arguments);return new Promise(function(e,r){function n(i,o){try{var a=t[i](o),s=a.value}catch(e){return void r(e)}if(!a.done)return Promise.resolve(s).then(function(e){n("next",e)},function(e){n("throw",e)});e(s)}return n("next")})}},classCallCheck=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),defineProperty=function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e},_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},get$1=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},inherits=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},possibleConstructorReturn=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},set=function e(t,r,n,i){var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var a=Object.getPrototypeOf(t);null!==a&&e(a,r,n,i)}else if("value"in o&&o.writable)o.value=n;else{var s=o.set;void 0!==s&&s.call(i,n)}return n},slicedToArray=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),toConsumableArray=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},knownSymbols=Object.getOwnPropertyNames(Symbol).filter(function(e){return"symbol"===_typeof(Symbol[e])}).reduce(function(e,t){return e.set(Symbol[t],"Symbol."+t)},new Map),symMatcher=/^Symbol\((.*)\)$/,printInspectEvalValue=function(){function e(e,t){if("object"===(void 0===t?"undefined":_typeof(t))&&(t=t.maxDepth||2),!e)return String(e);if("string"==typeof e){var n=e.includes("\n")?"`":'"';return n+e+n}if(e instanceof Error)return e.stack||safeToString(e);if(!lively_lang.obj.isObject(e))return safeToString(e);try{var i=lively_lang.obj.inspect(e,{customPrinter:r,maxDepth:t,printFunctionSource:!0})}catch(e){}return"{}"===i?safeToString(e):i}function t(t,r){if(!("string"!=typeof t&&!Array.isArray(t)&&n&&"function"==typeof t[n]))return r;for(var o,a="function"==typeof t.entries,s=a?t.entries():t[n](),u=[],c=a?"{":"[",l=a?"}":"]",f=t.constructor&&t.constructor.name||"Iterable",p=0;p<i&&!(o=s.next()).done;p++)u.push(o.value);return f+"("+c+u.map(function(t){return a?String(t[0])+": "+String(t[1]):e(t,2)}).join(", ")+l+")"}function r(e,r,n){if(!e)return r;if("symbol"===(void 0===e?"undefined":_typeof(e)))return printSymbol(e);if("string"==typeof e)return lively_lang.string.print(lively_lang.string.truncate(e,o));if(e.isMorph)return safeToString(e);if(e instanceof Promise)return"Promise()";if("undefined"!=typeof Node&&e instanceof Node)return safeToString(e);if("undefined"!=typeof ImageData&&e instanceof ImageData)return safeToString(e);var a=e.length||e.byteLength;if(void 0!==a&&a>i&&e.slice)return"["+("string"==typeof e||e.byteLength?safeToString(e.slice(0,i)):e.slice(0,i).map(n))+",...]";var s=t(e,r);return s!==r?s:r}var n="undefined"!=typeof Symbol&&Symbol.iterator,i=10,o=100;return e}(),completions=Object.freeze({getObjectForCompletion:getObjectForCompletion,getCompletions:getCompletions}),id=lively_ast.nodes.id,literal=lively_ast.nodes.literal,member=lively_ast.nodes.member,defaultDeclarationWrapperName="lively.capturing-declaration-wrapper",defaultClassToFunctionConverterName="initializeES6ClassForLively",defaultTopLevelVarRecorderName="__lvVarRecorder",startEvalFunctionName="lively.vm-on-eval-start",endEvalFunctionName="lively.vm-on-eval-end",EvalResult=function(){function e(){classCallCheck(this,e),this.isEvalResult=!0,this.value=void 0,this.warnings=[],this.isError=!1,this.isPromise=!1,this.promisedValue=void 0,this.promiseStatus="unknown"}return createClass(e,[{key:"addWarning",value:function(e){return this.warnings.push(e),e}},{key:"printed",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.value=printEvalResult(this,e)}},{key:"processSync",value:function(e){return(e.inspect||e.asString)&&(this.value=this.print(this.value,e)),this}},{key:"process",value:function(e){var t=this;return t.isPromise&&e.waitForPromise?tryToWaitForPromise(t,e.promiseTimeout).then(function(){return(e.inspect||e.asString)&&t.printed(e),t}):((e.inspect||e.asString)&&t.printed(e),Promise.resolve(t))}}]),e}(),funcCall=lively_ast.nodes.funcCall,member$1=lively_ast.nodes.member,literal$1=lively_ast.nodes.literal,EvalStrategy=function(){function e(){classCallCheck(this,e)}return createClass(e,[{key:"runEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",Promise.reject("runEval(source, options) not yet implemented for "+this.constructor.name));case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"keysOfObject",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",Promise.reject("keysOfObject(prefix, options) not yet implemented for "+this.constructor.name));case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),e}(),SimpleEvalStrategy=function(_EvalStrategy){function SimpleEvalStrategy(){return classCallCheck(this,SimpleEvalStrategy),possibleConstructorReturn(this,(SimpleEvalStrategy.__proto__||Object.getPrototypeOf(SimpleEvalStrategy)).apply(this,arguments))}return inherits(SimpleEvalStrategy,_EvalStrategy),createClass(SimpleEvalStrategy,[{key:"runEval",value:function(){function runEval(e,t){return _ref3.apply(this,arguments)}var _ref3=asyncToGenerator(regeneratorRuntime.mark(function _callee3(source,options){return regeneratorRuntime.wrap(function _callee3$(_context3){for(;;)switch(_context3.prev=_context3.next){case 0:return _context3.abrupt("return",Promise.resolve().then(function(){try{return Promise.resolve({value:eval(source)})}catch(e){return{isError:!0,value:e}}}));case 1:case"end":return _context3.stop()}},_callee3,this)}));return runEval}()},{key:"keysOfObject",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,lively.vm.completions.getCompletions(function(e){return i.runEval(e,r)},t);case 2:return n=e.sent,e.abrupt("return",{completions:n.completions,prefix:n.startLetters});case 4:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),SimpleEvalStrategy}(EvalStrategy),LivelyVmEvalStrategy=function(e){function t(){return classCallCheck(this,t),possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return inherits(t,EvalStrategy),createClass(t,[{key:"normalizeOptions",value:function(e){if(!e.targetModule)throw new Error("runEval called but options.targetModule not specified!");return Object.assign({sourceURL:e.targetModule+"_doit_"+Date.now()},e)}},{key:"runEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=this.normalizeOptions(r),(n=r.System||lively.modules.System).config({meta:defineProperty({},r.targetModule,{format:"esm"})}),e.abrupt("return",lively.vm.runEval(t,r));case 4:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"keysOfObject",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,lively.vm.completions.getCompletions(function(e){return lively.vm.runEval(e,r)},t);case 2:return n=e.sent,e.abrupt("return",{completions:n.completions,prefix:n.startLetters});case 4:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),t}(),RemoteEvalStrategy=function(e){function t(){return classCallCheck(this,t),possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return inherits(t,LivelyVmEvalStrategy),createClass(t,[{key:"sourceForRemote",value:function(e,t,r){return r=lively_lang.obj.dissoc(r,["systemInterface","System","context"]),"\n(function() {\n  var arg = "+JSON.stringify(t)+",\n      options = "+JSON.stringify(r)+';\n  if (typeof lively === "undefined" || !lively.vm) {\n    return Promise.resolve({\n      isEvalResult: true,\n      isError: true,\n      value: \'lively.vm not available!\'\n    });\n  }\n  var hasSystem = typeof System !== "undefined"\n  options.context = hasSystem\n    ? System.global\n    : typeof window !== "undefined"\n        ? window\n        : typeof global !== "undefined"\n            ? global\n            : typeof self !== "undefined" ? self : this;\n  function evalFunction(source, options) {\n    if (hasSystem) {\n      var conf = {meta: {}}; conf.meta[options.targetModule] = {format: "esm"};\n      System.config(conf);\n    } else {\n      options = Object.assign({topLevelVarRecorderName: "GLOBAL"}, options);\n      delete options.targetModule;\n    }\n    return lively.vm.runEval(source, options);\n  }\n  function keysOfObjectFunction(prefix, options) {\n    return lively.vm.completions.getCompletions(code => evalFunction(code, options), prefix)\n      .then(result => ({isEvalResult: true, completions: result.completions, prefix: result.startLetters}));\n  }\n  return '+("eval"===e?"evalFunction":"keysOfObjectFunction")+"(arg, options)\n    .catch(err => ({isEvalResult: true, isError: true, value: String(err.stack || err)}));\n})();\n"}},{key:"runEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.remoteEval(this.sourceForRemote("eval",t,r),r));case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"keysOfObject",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.remoteEval(this.sourceForRemote("keysOfObject",t,r),r));case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"remoteEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.prev=0,e.next=3,this.basicRemoteEval(t,r);case 3:return n=e.sent,e.abrupt("return","string"==typeof n?JSON.parse(n):n);case 7:return e.prev=7,e.t0=e.catch(0),e.abrupt("return",{isError:!0,value:"Remote eval failed: "+(n||e.t0)});case 10:case"end":return e.stop()}},e,this,[[0,7]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"basicRemoteEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error("Not yet implemented");case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),t}(),HttpEvalStrategy=function(e){function t(e){classCallCheck(this,t);var r=possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return r.url=e||r.constructor.defaultURL,r}return inherits(t,RemoteEvalStrategy),createClass(t,null,[{key:"defaultURL",get:function(){return"http://localhost:3000/lively"}}]),createClass(t,[{key:"normalizeOptions",value:function(e){return e=get$1(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"normalizeOptions",this).call(this,e),Object.assign({serverEvalURL:this.url},e,{context:null})}},{key:"basicRemoteEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=this.normalizeOptions(r),n="basicRemoteEval_"+(System.get("@system-env").node?"node":"web"),e.next=4,this[n]({method:"POST",body:t},r.serverEvalURL);case 4:return e.abrupt("return",e.sent);case 5:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"basicRemoteEval_web",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=r.match(/[^:]+:\/\/[^\/]+/)||[r],i=slicedToArray(n,1),o=i[0],(a=document.location.origin!==o)&&(t.headers=_extends({},t.headers,{pragma:"no-cache","cache-control":"no-cache","x-lively-proxy-request":r}),r=document.location.origin),e.prev=2,e.next=5,window.fetch(r,t);case 5:s=e.sent,e.next=11;break;case 8:throw e.prev=8,e.t0=e.catch(2),new Error("Cannot reach server at "+r+": "+e.t0.message);case 11:if(s.ok){e.next=13;break}throw new Error("Server at "+r+": "+s.statusText);case 13:return e.abrupt("return",s.text());case 14:case"end":return e.stop()}},e,this,[[2,8]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"basicRemoteEval_node",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=System._nodeRequire("url").parse,i=System._nodeRequire(r.startsWith("https:")?"https":"http"),o=Object.assign({method:t.method||"GET"},n(r)),e.abrupt("return",new Promise(function(e,r){var n=i.request(o,function(t){t.setEncoding("utf8");var n="";t.on("data",function(e){return n+=e}),t.on("end",function(){return e(n)}),t.on("error",function(e){return r(e)})});n.on("error",function(e){return r(e)}),n.end(t.body)}));case 2:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),t}(),L2LEvalStrategy=function(e){function t(e,r){classCallCheck(this,t);var n=possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.l2lClient=e,n.targetId=r,n}return inherits(t,RemoteEvalStrategy),createClass(t,[{key:"basicRemoteEval",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=this.l2lClient,i=this.targetId,e.next=4,new Promise(function(e,r){return n.sendTo(i,"remote-eval",{source:t},e)});case 4:return o=e.sent,(a=o.data)&&a.value&&a.value.isEvalResult&&(a=a.value),e.abrupt("return",a);case 8:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()}]),t}(),evalStrategies=Object.freeze({RemoteEvalStrategy:RemoteEvalStrategy,EvalStrategy:EvalStrategy,SimpleEvalStrategy:SimpleEvalStrategy,LivelyVmEvalStrategy:LivelyVmEvalStrategy,HttpEvalStrategy:HttpEvalStrategy,L2LEvalStrategy:L2LEvalStrategy});exports.completions=completions,exports.runEval=runEval$$1,exports.syncEval=syncEval$$1,exports.evalStrategies=evalStrategies,exports.defaultTopLevelVarRecorderName=defaultTopLevelVarRecorderName,exports.defaultClassToFunctionConverterName=defaultClassToFunctionConverterName,exports.evalCodeTransform=evalCodeTransform,exports.evalCodeTransformOfSystemRegisterSetters=evalCodeTransformOfSystemRegisterSetters}(this.lively.vm=this.lively.vm||{},lively.lang,lively.ast,lively.sourceTransform,lively.classes,lively.notifications),"undefined"!=typeof module&&module.exports&&(module.exports=GLOBAL.lively.vm)}(),function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(e,t){"use strict";function r(e,t){return Array.isArray(e)?e.reduce(function(e,t){return r(t,e)},t):"string"==typeof e?t.filter(function(t){return t.path()!==e&&t.name()!==e}):e instanceof RegExp?t.filter(function(t){return!e.test(t.path())&&!e.test(t.name())}):"function"==typeof e?t.filter(function(t){return!e(t)}):t}function n(e){var t=(e=e).split("?"),r=S(t,2),n=(r[0],r[1]),i={};if(!n)return i;var o=n.split("&");if(o)for(var a=0;a<o.length;a++){var s=o[a].split("="),u=s[0],c=!0;if(s.length>1)if("undefined"===(c=decodeURIComponent(s.slice(1).join("="))))c=void 0;else if(c.match(/^(true|false|null|[0-9"[{].*)$/))try{c=JSON.parse(c)}catch(e){"["===c[0]&&(c=c.slice(1,-1).split(","))}i[u]=c}return i}function i(e){var t=e,r=t;do{r=(t=r).replace(C,"")}while(r!=t);return r=r.replace(F,"$1/"),r=r.replace(D,"/")}function o(e,t){e.startsWith("/")&&(e=e.slice(1)),t.startsWith("/")&&(t=t.slice(1));for(var r=e.split("/"),n=t.split("/"),i=0;i<n.length&&(r[i]&&r[i]==n[i]);i++);return"../".repeat(Math.max(0,n.length-i-1))+r.splice(i,r.length).join("/")}function a(e,t){var r=e.match(A),n=t.match(A),a=void 0,s=void 0,u=void 0,c=void 0,l=!0;if((r&&!n||!r&&n)&&(l=!1),r&&n&&(a=r[1],s=r[2],u=n[1],c=n[2],a!==u?l=!1:s!==c?l=!1:(e=r[3],t=n[3])),!l)throw new Error("[relativePathBetween] incompatible paths: "+e+" vs. "+t);if(e=i(e),t=i(t),e==t)return"";var f=o(t,e);if(!f)throw new Error("pathname differs in relativePathFrom "+e+" vs "+t);return f}function s(e,t){throw new Error(t+" for "+e.constructor.name+" not yet implemented")}function u(e){var t=e.match(/\/([a-z]+?):multistatus/i);return t?t[1]:"d"}function c(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=e.tagName.replace(/[^:]+:/,""),n=I[r],i=e.textContent;switch(n){case"lastModified":case"created":i=new Date(i);break;case"size":i=Number(i)}return t[n]=i,t}function l(e){var t=(new DOMParser).parseFromString(e,"text/xml"),r=u(e),n=new T("/"+r+":multistatus/"+r+":response").findAll(t.documentElement),i=new T(r+":href"),o=new T(r+":propstat/"+r+":prop");return n.map(function(e){var t=o.findFirst(e),r=Array.from(t.childNodes).reduce(function(e,t){return c(t,e)},{}),n=i.findFirst(e);return r.url=n.textContent||n.text,r})}function f(){return document.location.origin}function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"GET",r=arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=e.url,o=e.useCors,a=e.useProxy,s=e.headers,o=void 0===o||o,u={method:t};return(a=void 0===a||a)&&(Object.assign(n,{pragma:"no-cache","cache-control":"no-cache","x-lively-proxy-request":i}),i=f()),o&&(u.mode="cors"),r&&(u.body=r),u.redirect="follow",u.headers=x({},n,s),fetch(i,u)}function d(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return new Promise(function(t,n){return e.apply(null,r.concat(function(e,r){return e?n(e):t(r)}))})}}function h(e,t){return!t||("string"==typeof t?!e.url.includes(t):"function"==typeof t?!t(e):!(t instanceof RegExp)||!t.test(e.url))}function m(e,t){if(!e)throw new Error("lively.resource resource constructor: expects url but got "+e);if(e.isResource)return e;e=String(e);for(var r=0;r<Z.length;r++)if(Z[r].matches(e))return new Z[r].resourceClass(e,t);throw new Error("Cannot find resource type for url "+e)}function v(e){var t=e.name;Z=Z.filter(function(e){return e.name!==t}).concat(e)}var y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},g=function(e){return function(){var t=e.apply(this,arguments);return new Promise(function(e,r){function n(i,o){try{var a=t[i](o),s=a.value}catch(e){return void r(e)}if(!a.done)return Promise.resolve(s).then(function(e){n("next",e)},function(e){n("throw",e)});e(s)}return n("next")})}},b=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},_=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),x=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},w=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},k=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},E=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},S=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),A=/^([^:\/]+):\/\/([^\/]*)(.*)/,D=/\/\.\//g,C=/\/[^\/]+\/\.\./,F=/(^|[^:])[\/]+/g,O=/\/+$/,j=/^\/+/,R=/^[a-z0-9-_\.]+:/,B=/^\/\/[^\/]+/,P=function(){function e(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(b(this,e),!t)throw new Error("Cannot create resource without url");this.url=String(t),this.binary=!1,this.lastModified=void 0,this.created=void 0,this.etag=void 0,this.size=void 0,this.type=void 0,this.contentType=void 0,this.user=void 0,this.group=void 0,this.mode=void 0,this._isDirectory=void 0,this._isLink=void 0,this.linkCount=void 0}return _(e,null,[{key:"fromProps",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this(e.url).assignProperties(e)}}]),_(e,[{key:"equals",value:function(e){if(!e||this.constructor!==e.constructor)return!1;var t=this.url,r=e.url;return"/"===t[t.length-1]&&(t=t.slice(0,-1)),"/"===r[r.length-1]&&(r=r.slice(0,-1)),t===r}},{key:"toString",value:function(){return this.constructor.name+'("'+this.url+'")'}},{key:"newResource",value:function(e){return m(e)}},{key:"path",value:function(){var e=this.url.replace(R,"").replace(B,"");return""===e?"/":e}},{key:"pathWithoutQuery",value:function(){return this.path().split("?")[0]}},{key:"name",value:function(){var e=this.path(),t=e.lastIndexOf("?");t>-1&&(e=e.slice(0,t)),e.endsWith("/")&&(e=e.slice(0,-1));var r=e.split("/"),n=r[r.length-1];return decodeURIComponent(n)}},{key:"ext",value:function(){var e=this.url;if(e.endsWith("/"))return"";var t=e.match(/\.([^\/\.]+$)/)||["",""],r=S(t,2),n=(r[0],r[1]);return n.toLowerCase()}},{key:"nameWithoutExt",value:function(){var e=this.name(),t=e.lastIndexOf(".");return t>0&&(e=e.slice(0,t)),e}},{key:"scheme",value:function(){return this.url.split(":")[0]}},{key:"host",value:function(){var e=this.url.indexOf("://");if(-1===e)return null;var t=this.url.slice(e+3),r=t.indexOf("/");return t.slice(0,r>-1?r:t.length)}},{key:"schemeAndHost",value:function(){return this.isRoot()?this.asFile().url:this.url.slice(0,this.url.length-this.path().length)}},{key:"parent",value:function(){return this.isRoot()?null:this.newResource(this.url.replace(O,"").split("/").slice(0,-1).join("/")+"/")}},{key:"parents",value:function(){for(var e=[],t=this.parent();t;)e.unshift(t),t=t.parent();return e}},{key:"isParentOf",value:function(e){var t=this;return e.schemeAndHost()===this.schemeAndHost()&&e.parents().some(function(e){return e.equals(t)})}},{key:"query",value:function(){return n(this.url)}},{key:"withQuery",value:function(e){var t=x({},this.query(),e),r=this.url.split("?"),n=S(r,1)[0],i=Object.keys(t).map(function(e){return e+"="+encodeURIComponent(String(t[e]))}).join("&");return this.newResource(n+"?"+i)}},{key:"commonDirectory",value:function(e){if(e.schemeAndHost()!==this.schemeAndHost())return null;if(this.isDirectory()&&this.equals(e))return this;if(this.isRoot())return this.asDirectory();if(e.isRoot())return e.asDirectory();for(var t=e.parents(),r=this.parents(),n=this.root(),i=0;i<r.length;i++){var o=r[i],a=t[i];if(!a||!o.equals(a))return n;n=o}return n}},{key:"withRelativePartsResolved",value:function(){var e=this.path(),t=i(e);return t===e?this:(t.startsWith("/")&&(t=t.slice(1)),this.newResource(this.root().url+t))}},{key:"relativePathFrom",value:function(e){return a(e.url,this.url)}},{key:"withPath",value:function(e){return(this.isRoot()?this:this.root()).join(e)}},{key:"join",value:function(e){return this.newResource(this.url.replace(O,"")+"/"+e.replace(j,""))}},{key:"isRoot",value:function(){return"/"===this.path()}},{key:"isFile",value:function(){return!this.isRoot()&&!this.url.match(O)}},{key:"isDirectory",value:function(){return!this.isFile()}},{key:"asDirectory",value:function(){return this.url.endsWith("/")?this:this.newResource(this.url.replace(O,"")+"/")}},{key:"root",value:function(){if(this.isRoot())return this;var e=this.url.slice(0,-this.path().length);return this.newResource(e+"/")}},{key:"asFile",value:function(){return this.url.endsWith("/")?this.newResource(this.url.replace(O,"")):this}},{key:"assignProperties",value:function(e){for(var t in e)if("url"!==t){var r=t;"isLink"!==t&&"isDirectory"!==t||(r="_"+t),this[r]=e[t]}return this}},{key:"ensureExistance",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.exists();case 2:if(!e.sent){e.next=4;break}return e.abrupt("return",this);case 4:return e.next=6,this.parent().ensureExistance();case 6:if(!this.isFile()){e.next=11;break}return e.next=9,this.write(t||"");case 9:e.next=13;break;case 11:return e.next=13,this.mkdir();case 13:return e.abrupt("return",this);case 14:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"copyTo",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,n,i,o=this,a=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isFile()){e.next=13;break}if(r=t.isFile()?t:t.join(this.name()),!a){e.next=5;break}return e.next=5,r.parent().ensureExistance();case 5:return e.t0=r,e.next=8,this.read();case 8:return e.t1=e.sent,e.next=11,e.t0.write.call(e.t0,e.t1);case 11:e.next=25;break;case 13:if(t.isDirectory()){e.next=15;break}throw new Error("Cannot copy a directory to a file!");case 15:return e.next=17,this.dirList("infinity");case 17:return n=e.sent,i=n.map(function(e){return t.join(e.relativePathFrom(o))}),e.next=21,t.ensureExistance();case 21:return e.next=23,n.reduceRight(function(e,t,r){return function(){return Promise.resolve(t.isDirectory()&&i[r].ensureExistance()).then(e)}},function(){return Promise.resolve()})();case 23:return e.next=25,n.reduceRight(function(e,t,r){return function(){return Promise.resolve(t.isFile()&&t.copyTo(i[r],!1)).then(e)}},function(){return Promise.resolve()})();case 25:return e.abrupt("return",this);case 26:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"rename",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.copyTo(t);case 2:return this.remove(),e.abrupt("return",t);case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"beBinary",value:function(e){return this.setBinary(!0)}},{key:"setBinary",value:function(e){return this.binary=e,this}},{key:"read",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"read");case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"write",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"write");case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"mkdir",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"mkdir");case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"exists",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"exists");case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"remove",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"remove");case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"dirList",value:function(){var e=g(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"dirList");case 1:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"readProperties",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:s(this,"readProperties");case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"writeJson",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.write(t?JSON.stringify(e,null,2):JSON.stringify(e))}},{key:"readJson",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=JSON,e.next=3,this.read();case 3:return e.t1=e.sent,e.abrupt("return",e.t0.parse.call(e.t0,e.t1));case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"__serialize__",value:function(){return{__expr__:'var r = null; try { r = resource("'+this.url+'");} catch (err) {}; r',bindings:{"lively.resources":["resource"]}}}},{key:"isResource",get:function(){return!0}},{key:"canDealWithJSON",get:function(){return!1}}]),e}(),T=function(){function e(t){b(this,e),this.expression=t,this.contextNode=null,this.xpe=new XPathEvaluator}return _(e,[{key:"establishContext",value:function(e){if(!this.nsResolver){var t=e.ownerDocument?e.ownerDocument.documentElement:e.documentElement;t!==this.contextNode&&(this.contextNode=t,this.nsResolver=this.xpe.createNSResolver(t))}}},{key:"manualNSLookup",value:function(){return this.nsResolver=function(e){return Namespace[e.toUpperCase()]||null},this}},{key:"findAll",value:function(e,t){this.establishContext(e);for(var r=this.xpe.evaluate(this.expression,e,this.nsResolver,XPathResult.ANY_TYPE,null),n=[],i=null;i=r.iterateNext();)n.push(i);return n.length>0||void 0===t?n:t}},{key:"findFirst",value:function(e){return this.establishContext(e),this.xpe.evaluate(this.expression,e,this.nsResolver,XPathResult.ANY_TYPE,null).iterateNext()}}]),e}(),I={getlastmodified:"lastModified",creationDate:"created",getetag:"etag",getcontentlength:"size",resourcetype:"type",getcontenttype:"contentType"},L=["3ds","3g2","3gp","7z","a","aac","adp","ai","aif","aiff","alz","ape","apk","ar","arj","asf","au","avi","bak","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","csv","cur","dat","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","fli","flv","fpx","fst","fvt","g3","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","o","oga","ogg","ogv","otf","pages","pbm","pcx","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","rgb","rip","rlc","rmf","rmvb","rtf","rz","s3m","s7z","scpt","sgi","shar","sil","sketch","slk","smv","so","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"],N="undefined"!=typeof System?System.get("@system-env").node:"undefined"!=typeof global&&"undefined"!=typeof process,M={name:"http-webdav-resource",matches:function(e){return e.startsWith("http:")||e.startsWith("https:")},resourceClass:function(e){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};b(this,t);var n=E(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,r));return n.useProxy=!!r.hasOwnProperty("useProxy")&&r.useProxy,n.useCors=!!r.hasOwnProperty("useCors")&&r.useCors,n.headers=r.headers||{},n.binary=!!n.isFile()&&L.includes(n.ext()),n.errorOnHTTPStatusCodes=!r.hasOwnProperty("errorOnHTTPStatusCodes")||r.errorOnHTTPStatusCodes,n}return k(t,P),_(t,[{key:"join",value:function(e){return Object.assign(w(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"join",this).call(this,e),{headers:this.headers,useCors:this.useCors,useProxy:this.useProxy})}},{key:"makeProxied",value:function(){return this.useProxy?this:new this.constructor(this.url,{headers:this.headers,useCors:this.useCors,useProxy:!0})}},{key:"noErrorOnHTTPStatusCodes",value:function(){return this.errorOnHTTPStatusCodes=!1,this}},{key:"read",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,p(this);case 2:if((t=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=5;break}throw new Error("Cannot read "+this.url+": "+t.statusText+" "+t.status);case 5:if(this.binary){e.next=7;break}return e.abrupt("return",t.text());case 7:if("blob"!==this.binary){e.next=9;break}return e.abrupt("return",t.blob());case 9:if("function"!=typeof t.arrayBuffer){e.next=11;break}return e.abrupt("return",t.arrayBuffer());case 11:if("function"!=typeof t.buffer){e.next=13;break}return e.abrupt("return",t.buffer());case 13:throw new Error("Don't now how to read binary resource "+this+"'");case 14:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"write",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(this.isFile()){e.next=2;break}throw new Error("Cannot write a non-file: "+this.url);case 2:return e.next=4,p(this,"PUT",t);case 4:if((r=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=7;break}throw new Error("Cannot write "+this.url+": "+r.statusText+" "+r.status);case 7:return e.abrupt("return",this);case 8:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"mkdir",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isFile()){e.next=2;break}throw new Error("Cannot mkdir on a file: "+this.url);case 2:return e.next=4,p(this,"MKCOL");case 4:if((t=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=7;break}throw new Error("Cannot create directory "+this.url+": "+t.statusText+" "+t.status);case 7:return e.abrupt("return",this);case 8:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"exists",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isRoot()){e.next=4;break}e.t0=!0,e.next=7;break;case 4:return e.next=6,p(this,"HEAD");case 6:e.t0=!!e.sent.ok;case 7:return e.abrupt("return",e.t0);case 8:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"remove",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,p(this,"DELETE");case 2:return e.abrupt("return",this);case 3:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"_propfind",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t,r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,p(this,"PROPFIND",null,{"Content-Type":"text/xml"});case 2:if((t=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=5;break}throw new Error("Error in dirList for "+this.url+": "+t.statusText);case 5:return e.next=7,t.text();case 7:return r=e.sent,n=this.root(),e.abrupt("return",l(r).map(function(e){return n.join(e.url).assignProperties(e)}));case 10:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"dirList",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t,n,i,o,a,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if("number"==typeof s||"infinity"===s){e.next=2;break}throw new Error("dirList  invalid depth argument: "+s);case 2:if(t=u.exclude,s<=0&&(s=1),1!==s){e.next=13;break}return e.next=7,this._propfind();case 7:return n=e.sent,i=n.shift(),t&&(n=r(t,n)),e.abrupt("return",n);case 13:return e.next=15,this.dirList(1,u);case 15:return o=e.sent,a=o.filter(function(e){return e.isDirectory()}),e.abrupt("return",Promise.all(a.map(function(e){return e.dirList("number"==typeof s?s-1:s,u)})).then(function(e){return e.reduce(function(e,t){return e.concat(t)},o)}));case 18:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"readProperties",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._propfind();case 2:return r=e.sent[0],e.abrupt("return",this.assignProperties(r));case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"post",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t,r,n,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return"string"!=typeof i&&(i=JSON.stringify(i)),e.next=3,p(this,"POST",i,{});case 3:return t=e.sent,r=void 0,n=void 0,e.prev=6,e.next=9,t.text();case 9:r=e.sent,e.next=14;break;case 12:e.prev=12,e.t0=e.catch(6);case 14:if(r&&"application/json"===t.headers.get("content-type"))try{n=JSON.parse(r)}catch(e){}if(t.ok||!this.errorOnHTTPStatusCodes){e.next=19;break}throw new Error("Error in POST "+this.url+": "+(r||t.statusText));case 19:return e.abrupt("return",n||r);case 20:case"end":return e.stop()}},e,this,[[6,12]])}));return function(){return e.apply(this,arguments)}}()},{key:"copyTo",value:function(){var e=g(regeneratorRuntime.mark(function e(r){var n,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isFile()){e.next=7;break}if(n=r.isFile()?r:r.join(this.name()),!N){e.next=7;break}if(!n.isHTTPResource){e.next=5;break}return e.abrupt("return",this._copyTo_file_nodejs_http(n,i));case 5:if(!n.isNodeJSFileResource){e.next=7;break}return e.abrupt("return",this._copyTo_file_nodejs_fs(n,i));case 7:return e.abrupt("return",w(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"copyTo",this).call(this,r,i));case 8:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_copyFrom_file_nodejs_fs",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,n,i,o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!o){e.next=3;break}return e.next=3,this.parent().ensureExistance();case 3:return r=void 0,(n=t._createReadStream()).on("error",function(e){return r=e}),e.next=8,p(this,"PUT",n);case 8:if(i=e.sent,!r){e.next=11;break}throw r;case 11:if(i.ok||!this.errorOnHTTPStatusCodes){e.next=13;break}throw new Error("copyTo: Cannot GET: "+i.statusText+" "+i.status);case 13:return e.abrupt("return",this);case 14:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_copyTo_file_nodejs_fs",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,n,i=this,o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!o){e.next=3;break}return e.next=3,t.parent().ensureExistance();case 3:return e.next=5,p(this,"GET");case 5:if((r=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=8;break}throw new Error("copyTo: Cannot GET: "+r.statusText+" "+r.status);case 8:return n=void 0,e.abrupt("return",new Promise(function(e,o){return r.body.pipe(t._createWriteStream()).on("error",function(e){return n=e}).on("finish",function(){return n?o(n):e(i)})}));case 10:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_copyTo_file_nodejs_http",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,n,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!i){e.next=3;break}return e.next=3,t.parent().ensureExistance();case 3:return e.next=5,p(this,"GET");case 5:if((r=e.sent).ok||!this.errorOnHTTPStatusCodes){e.next=8;break}throw new Error("copyTo: Cannot GET: "+r.statusText+" "+r.status);case 8:return e.next=10,p(t,"PUT",r.body);case 10:if(n=e.sent,r.ok||!this.errorOnHTTPStatusCodes){e.next=13;break}throw new Error("copyTo: Cannot PUT: "+n.statusText+" "+n.status);case 13:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"isHTTPResource",get:function(){return!0}}]),t}()},q=d(t.readFile),$=d(t.writeFile),W=function(e){return new Promise(function(r,n){return t.exists(e,function(e){return r(!!e)})})},U=d(t.readdir),z=d(t.mkdir),V=d(t.rmdir),G=d(t.unlink),H=d(t.lstat),J=d(t.rename),K={name:"nodejs-file-resource",matches:function(e){return e.startsWith("file:")},resourceClass:function(e){function n(){return b(this,n),E(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return k(n,P),_(n,[{key:"path",value:function(){return this.url.replace("file://","")}},{key:"stat",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",H(this.path()));case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"read",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=q(this.path()),e.abrupt("return",this.binary?t:t.then(String));case 2:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"write",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isDirectory()){e.next=2;break}throw new Error("Cannot write into a directory: "+this.path());case 2:return e.next=4,$(this.path(),t);case 4:return e.abrupt("return",this);case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"mkdir",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isFile()){e.next=2;break}throw new Error("Cannot mkdir on a file: "+this.path());case 2:return e.next=4,z(this.path());case 4:return e.abrupt("return",this);case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"exists",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",!!this.isRoot()||W(this.path()));case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"dirList",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t,n,i,o,a,s,u,c,l,f,p,d,h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if("number"==typeof h||"infinity"===h){e.next=2;break}throw new Error("dirList  invalid depth argument: "+h);case 2:if(t=m.exclude,h<=0&&(h=1),1!==h){e.next=42;break}return n=[],i=!0,o=!1,a=void 0,e.prev=9,e.next=12,U(this.path());case 12:e.t0=Symbol.iterator,s=e.sent[e.t0]();case 14:if(i=(u=s.next()).done){e.next=26;break}return c=u.value,l=this.join(c),e.next=19,l.stat();case 19:f=e.sent,(l=f.isDirectory()?l.asDirectory():l)._assignPropsFromStat(f),n.push(l);case 23:i=!0,e.next=14;break;case 26:e.next=32;break;case 28:e.prev=28,e.t1=e.catch(9),o=!0,a=e.t1;case 32:e.prev=32,e.prev=33,!i&&s.return&&s.return();case 35:if(e.prev=35,!o){e.next=38;break}throw a;case 38:return e.finish(35);case 39:return e.finish(32);case 40:return t&&(n=r(t,n)),e.abrupt("return",n);case 42:return e.next=44,this.dirList(1,m);case 44:return p=e.sent,d=p.filter(function(e){return e.isDirectory()}),e.abrupt("return",Promise.all(d.map(function(e){return e.dirList("number"==typeof h?h-1:h,m)})).then(function(e){return e.reduce(function(e,t){return e.concat(t)},p)}));case 47:case"end":return e.stop()}},e,this,[[9,28,32,40],[33,,35,39]])}));return function(){return e.apply(this,arguments)}}()},{key:"isEmptyDirectory",value:function(){var e=g(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.dirList();case 2:return e.t0=e.sent.length,e.abrupt("return",0===e.t0);case 4:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"rename",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,k;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t instanceof this.constructor){e.next=2;break}return e.abrupt("return",w(n.prototype.__proto__||Object.getPrototypeOf(n.prototype),"rename",this).call(this,t));case 2:if(!this.isFile()){e.next=7;break}t=t.asFile(),J(this.path(),t.path()),e.next=93;break;case 7:return t=t.asDirectory(),e.next=10,t.ensureExistance();case 10:return r=[],i=[],o=!0,a=!1,s=void 0,e.prev=14,e.next=17,this.dirList("infinity");case 17:e.t0=Symbol.iterator,u=e.sent[e.t0]();case 19:if(o=(c=u.next()).done){e.next=25;break}(l=c.value).isDirectory()?i.push(l):r.push(l);case 22:o=!0,e.next=19;break;case 25:e.next=31;break;case 27:e.prev=27,e.t1=e.catch(14),a=!0,s=e.t1;case 31:e.prev=31,e.prev=32,!o&&u.return&&u.return();case 34:if(e.prev=34,!a){e.next=37;break}throw s;case 37:return e.finish(34);case 38:return e.finish(31);case 39:f=!0,p=!1,d=void 0,e.prev=42,h=i[Symbol.iterator]();case 44:if(f=(m=h.next()).done){e.next=51;break}return v=m.value,e.next=48,t.join(v.relativePathFrom(this)).ensureExistance();case 48:f=!0,e.next=44;break;case 51:e.next=57;break;case 53:e.prev=53,e.t2=e.catch(42),p=!0,d=e.t2;case 57:e.prev=57,e.prev=58,!f&&h.return&&h.return();case 60:if(e.prev=60,!p){e.next=63;break}throw d;case 63:return e.finish(60);case 64:return e.finish(57);case 65:y=!0,g=!1,b=void 0,e.prev=68,_=r[Symbol.iterator]();case 70:if(y=(x=_.next()).done){e.next=77;break}return k=x.value,e.next=74,k.rename(t.join(k.relativePathFrom(this)));case 74:y=!0,e.next=70;break;case 77:e.next=83;break;case 79:e.prev=79,e.t3=e.catch(68),g=!0,b=e.t3;case 83:e.prev=83,e.prev=84,!y&&_.return&&_.return();case 86:if(e.prev=86,!g){e.next=89;break}throw b;case 89:return e.finish(86);case 90:return e.finish(83);case 91:return e.next=93,this.remove();case 93:return e.abrupt("return",t);case 94:case"end":return e.stop()}},e,this,[[14,27,31,39],[32,,34,38],[42,53,57,65],[58,,60,64],[68,79,83,91],[84,,86,90]])}));return function(t){return e.apply(this,arguments)}}()},{key:"remove",value:function(){var e=g(regeneratorRuntime.mark(function e(){var t,r,n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.exists();case 2:if(e.sent){e.next=5;break}e.next=41;break;case 5:if(!this.isDirectory()){e.next=39;break}return t=!0,r=!1,n=void 0,e.prev=9,e.next=12,this.dirList();case 12:e.t0=Symbol.iterator,i=e.sent[e.t0]();case 14:if(t=(o=i.next()).done){e.next=21;break}return a=o.value,e.next=18,a.remove();case 18:t=!0,e.next=14;break;case 21:e.next=27;break;case 23:e.prev=23,e.t1=e.catch(9),r=!0,n=e.t1;case 27:e.prev=27,e.prev=28,!t&&i.return&&i.return();case 30:if(e.prev=30,!r){e.next=33;break}throw n;case 33:return e.finish(30);case 34:return e.finish(27);case 35:return e.next=37,V(this.path());case 37:e.next=41;break;case 39:return e.next=41,G(this.path());case 41:return e.abrupt("return",this);case 42:case"end":return e.stop()}},e,this,[[9,23,27,35],[28,,30,34]])}));return function(){return e.apply(this,arguments)}}()},{key:"readProperties",value:function(){var e=g(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=this,e.next=3,this.stat();case 3:return e.t1=e.sent,e.abrupt("return",e.t0._assignPropsFromStat.call(e.t0,e.t1));case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"copyTo",value:function(){var e=g(regeneratorRuntime.mark(function e(t){var r,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isFile()){e.next=4;break}if(!(r=t.isFile()?t:t.join(this.name())).isHTTPResource){e.next=4;break}return e.abrupt("return",r._copyFrom_file_nodejs_fs(this,i=!0));case 4:return e.abrupt("return",w(n.prototype.__proto__||Object.getPrototypeOf(n.prototype),"copyTo",this).call(this,t,i));case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_assignPropsFromStat",value:function(e){return this.assignProperties({lastModified:e.mtime,created:e.ctime,size:e.size,type:e.isDirectory()?"directory":"file",isLink:e.isSymbolicLink()})}},{key:"_createWriteStream",value:function(){return t.createWriteStream(this.path())}},{key:"_createReadStream",value:function(){return t.createReadStream(this.path())}},{key:"isNodeJSFileResource",get:function(){return!0}}]),n}()},Q=/\//g,Y=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(b(this,e),!t||"string"!=typeof t)throw new Error("LocalResourceInMemoryBackend needs name!");this.name=t,this._filespec=r}return _(e,null,[{key:"removeHost",value:function(e){delete this.hosts[e]}},{key:"ensure",value:function(e){var t=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.named(r.host);return Promise.resolve().then(function(){return e?ee("local://"+n.name,e):null}).then(function(){return t})}},{key:"named",value:function(e){return e||(e="default"),this.hosts[e]||(this.hosts[e]=new this(e))}},{key:"hosts",get:function(){return this._hosts||(this._hosts={})}}]),_(e,[{key:"get",value:function(e){return this._filespec[e]}},{key:"set",value:function(e,t){this._filespec[e]=t}},{key:"write",value:function(e,t){var r=this._filespec[e];r||(r=this._filespec[e]={created:new Date}),r.content=t,r.isDirectory=!1,r.lastModified=new Date}},{key:"read",value:function(e){var t=this._filespec[e];return t&&t.content?t.content:""}},{key:"mkdir",value:function(e){var t=this._filespec[e];t&&t.isDirectory||(t||(t=this._filespec[e]={created:new Date}),t.content&&delete t.content,t.isDirectory=!0,t.lastModified=new Date)}},{key:"partialFilespec",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"/",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0,r={},n=this.filespec,i=Object.keys(n),o=0;o<i.length;o++){var a=i[o];if(a.startsWith(e)&&e!==a){var s=a.slice(e.length);(s.includes("/")?s.match(Q).length+1:1)>t||(r[a]=n[a])}}return r}},{key:"filespec",get:function(){return this._filespec},set:function(e){this._filespec=e}}]),e}(),X={name:"local-resource",matches:function(e){return e.startsWith("local:")},resourceClass:function(e){function t(){return b(this,t),E(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return k(t,P),_(t,[{key:"read",value:function(){return Promise.resolve(this.localBackend.read(this.path()))}},{key:"write",value:function(e){if(this.isDirectory())throw new Error("Cannot write into a directory! ("+this.url+")");var t=this.localBackend.get(this.path());if(t&&t.isDirectory)throw new Error(this.url+" already exists and is a directory (cannot write into it!)");return this.localBackend.write(this.path(),e),Promise.resolve(this)}},{key:"mkdir",value:function(){if(!this.isDirectory())throw new Error("Cannot mkdir a file! ("+this.url+")");var e=this.localBackend.get(this.path());if(e&&e.isDirectory)return Promise.resolve(this);if(e&&!e.isDirectory)throw new Error(this.url+" already exists and is a file (cannot mkdir it!)");return this.localBackend.mkdir(this.path()),Promise.resolve(this)}},{key:"exists",value:function(){return Promise.resolve(this.isRoot()||this.path()in this.localBackend.filespec)}},{key:"remove",value:function(){var e=this,t=this.path();return Object.keys(this.localBackend.filespec).forEach(function(r){return r.startsWith(t)&&delete e.localBackend.filespec[r]}),Promise.resolve(this)}},{key:"readProperties",value:function(){throw new Error("not yet implemented")}},{key:"dirList",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isDirectory())return this.asDirectory().dirList(t,r);var n=r.exclude,i=this.path(),o=[],a=Object.keys(this.localBackend.filespec);"infinity"===t&&(t=1/0);for(var s=0;s<a.length;s++){var u=a[s];if(u.startsWith(i)&&i!==u){var c=u.slice(i.length);if(!((c.includes("/")?c.match(Q).length+1:1)>t&&"continue"===function(){var r=e.join(c.split("/").slice(0,t).join("/")+"/");return o.some(function(e){return e.equals(r)})||o.push(r),"continue"}())){var l=this.join(c);n&&!h(l,n)||o.push(l)}}}return Promise.resolve(o)}},{key:"localBackend",get:function(){return Y.named(this.host())}}]),t}()},Z=Z||[];v(X),v(M),v(K);var ee=function(){var e=g(regeneratorRuntime.mark(function e(t,r,n){var i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return i=m(t,n).asDirectory(),e.next=3,i.ensureExistance();case 3:e.t0=regeneratorRuntime.keys(r);case 4:if((e.t1=e.t0()).done){e.next=18;break}if(o=e.t1.value,r.hasOwnProperty(o)){e.next=8;break}return e.abrupt("continue",4);case 8:if(a=i.join(o),"object"!==y(r[o])){e.next=14;break}return e.next=12,ee(a,r[o],n);case 12:e.next=16;break;case 14:return e.next=16,a.write(r[o]);case 16:e.next=4;break;case 18:return e.abrupt("return",i);case 19:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}(),te=function(){var e=g(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"infinity",_=arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.dirList(b,_);case 2:r=e.sent,n={},i=!0,o=!1,a=void 0,e.prev=7,s=r[Symbol.iterator]();case 9:if(i=(u=s.next()).done){e.next=44;break}if(!(c=u.value).isDirectory()){e.next=15;break}e.t0={},e.next=18;break;case 15:return e.next=17,c.read();case 17:e.t0=e.sent;case 18:for(l=e.t0,f=c.asFile().relativePathFrom(t).split("/"),p=n,d=!0,h=!1,m=void 0,e.prev=24,v=f.slice(0,-1)[Symbol.iterator]();!(d=(y=v.next()).done);d=!0)g=y.value,p[g]||(p[g]={}),p=p[g];e.next=32;break;case 28:e.prev=28,e.t1=e.catch(24),h=!0,m=e.t1;case 32:e.prev=32,e.prev=33,!d&&v.return&&v.return();case 35:if(e.prev=35,!h){e.next=38;break}throw m;case 38:return e.finish(35);case 39:return e.finish(32);case 40:p[f[f.length-1]]=l;case 41:i=!0,e.next=9;break;case 44:e.next=50;break;case 46:e.prev=46,e.t2=e.catch(7),o=!0,a=e.t2;case 50:e.prev=50,e.prev=51,!i&&s.return&&s.return();case 53:if(e.prev=53,!o){e.next=56;break}throw a;case 56:return e.finish(53);case 57:return e.finish(50);case 58:return e.abrupt("return",n);case 59:case"end":return e.stop()}},e,this,[[7,46,50,58],[24,28,32,40],[33,,35,39],[51,,53,57]])}));return function(t){return e.apply(this,arguments)}}(),re=function(){var e=g(regeneratorRuntime.mark(function e(){var t,r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!("fetch"in System.global&&"Headers"in System.global)){e.next=2;break}return e.abrupt("return",Promise.resolve());case 2:if(t=System.decanonicalize("lively.resources"),!System.get("@system-env").node){e.next=16;break}e.prev=4,r=System._nodeRequire("fetch-ponyfill"),e.next=14;break;case 8:return e.prev=8,e.t0=e.catch(4),e.next=12,System.normalize("fetch-ponyfill",t);case 12:n=e.sent.replace("file://",""),r=System._nodeRequire(n);case 14:e.next=19;break;case 16:return e.next=18,System.import("fetch-ponyfill",t);case 18:r=e.sent;case 19:Object.assign(System.global,r());case 20:case"end":return e.stop()}},e,this,[[4,8]])}));return function(){return e.apply(this,arguments)}}();e.resource=m,e.createFiles=ee,e.createFileSpec=te,e.loadViaScript=function(e,t){var r=document.head,n=r.namespaceURI;return new Promise(function(t,i){var o=document.createElementNS(n,"script");o.setAttribute("type","text/ecmascript"),r.appendChild(o),o.setAttributeNS(null,"id",e),"http://www.w3.org/2000/svg"===o.namespaceURI?o.setAttributeNS("http://www.w3.org/1999/xlink","href",e):o.setAttribute("src",e),o.onload=t,o.onerror=i,o.setAttributeNS(null,"async",!0)})},e.ensureFetch=re,e.registerExtension=v,e.unregisterExtension=function(e){var t="string"==typeof e?e:e.name;Z=Z.filter(function(e){return e.name!==t})},e.Resource=P,e.parseQuery=n}(this.lively.resources=this.lively.resources||{},"undefined"!=typeof module&&"function"==typeof module.require?module.require("fs"):{readFile:function(){throw new Error("fs module not available")}}),"undefined"!=typeof module&&module.exports&&(module.exports=e.lively.resources)}(),function(){var e=function(){var e={},t={exports:e};return function(r){if("object"==typeof e&&void 0!==t)t.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).PouchDB=r()}}(function(){return function e(t,r,n){function i(a,s){if(!r[a]){if(!t[a]){var u="function"==typeof require&&require;if(!s&&u)return u(a,!0);if(o)return o(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var l=r[a]={exports:{}};t[a][0].call(l.exports,function(e){var r=t[a][1][e];return i(r||e)},l,l.exports,e,t,r,n)}return r[a].exports}for(var o="function"==typeof require&&require,a=0;a<n.length;a++)i(n[a]);return i}({1:[function(e,t,r){"use strict";t.exports=function(e){return function(){var t=arguments.length;if(t){for(var r=[],n=-1;++n<t;)r[n]=arguments[n];return e.call(this,r)}return e.call(this,[])}}},{}],2:[function(e,t,r){(function(n){function i(){var e;try{e=r.storage.debug}catch(e){}return!e&&void 0!==n&&"env"in n&&(e=n.env.DEBUG),e}(r=t.exports=e(3)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},r.formatArgs=function(e){var t=this.useColors;if(e[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+e[0]+(t?"%c ":" ")+"+"+r.humanize(this.diff),t){var n="color: "+this.color;e.splice(1,0,n,"color: inherit");var i=0,o=0;e[0].replace(/%[a-zA-Z%]/g,function(e){"%%"!==e&&(i++,"%c"===e&&(o=i))}),e.splice(o,0,n)}},r.save=function(e){try{null==e?r.storage.removeItem("debug"):r.storage.debug=e}catch(e){}},r.load=i,r.useColors=function(){return!("undefined"==typeof window||!window||void 0===window.process||"renderer"!==window.process.type)||"undefined"!=typeof document&&document&&"WebkitAppearance"in document.documentElement.style||"undefined"!=typeof window&&window&&window.console&&(console.firebug||console.exception&&console.table)||"undefined"!=typeof navigator&&navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},r.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(e){}}(),r.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],r.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},r.enable(i())}).call(this,e(9))},{3:3,9:9}],3:[function(e,t,r){function n(e){var t,n=0;for(t in e)n=(n<<5)-n+e.charCodeAt(t),n|=0;return r.colors[Math.abs(n)%r.colors.length]}function i(e){function t(){if(t.enabled){var e=t,n=+new Date,i=n-(o||n);e.diff=i,e.prev=o,e.curr=n,o=n;for(var a=new Array(arguments.length),s=0;s<a.length;s++)a[s]=arguments[s];a[0]=r.coerce(a[0]),"string"!=typeof a[0]&&a.unshift("%O");var u=0;a[0]=a[0].replace(/%([a-zA-Z%])/g,function(t,n){if("%%"===t)return t;u++;var i=r.formatters[n];if("function"==typeof i){var o=a[u];t=i.call(e,o),a.splice(u,1),u--}return t}),r.formatArgs.call(e,a),(t.log||r.log||console.log.bind(console)).apply(e,a)}}return t.namespace=e,t.enabled=r.enabled(e),t.useColors=r.useColors(),t.color=n(e),"function"==typeof r.init&&r.init(t),t}(r=t.exports=i.debug=i.default=i).coerce=function(e){return e instanceof Error?e.stack||e.message:e},r.disable=function(){r.enable("")},r.enable=function(e){r.save(e),r.names=[],r.skips=[];for(var t=("string"==typeof e?e:"").split(/[\s,]+/),n=t.length,i=0;i<n;i++)t[i]&&("-"===(e=t[i].replace(/\*/g,".*?"))[0]?r.skips.push(new RegExp("^"+e.substr(1)+"$")):r.names.push(new RegExp("^"+e+"$")))},r.enabled=function(e){var t,n;for(t=0,n=r.skips.length;t<n;t++)if(r.skips[t].test(e))return!1;for(t=0,n=r.names.length;t<n;t++)if(r.names[t].test(e))return!0;return!1},r.humanize=e(8),r.names=[],r.skips=[],r.formatters={};var o},{8:8}],4:[function(e,t,r){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(e){return"function"==typeof e}function o(e){return"number"==typeof e}function a(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!o(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,r,n,o,u,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||a(this._events.error)&&!this._events.error.length)){if((t=arguments[1])instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}if(r=this._events[e],s(r))return!1;if(i(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:o=Array.prototype.slice.call(arguments,1),r.apply(this,o)}else if(a(r))for(o=Array.prototype.slice.call(arguments,1),n=(c=r.slice()).length,u=0;u<n;u++)c[u].apply(this,o);return!0},n.prototype.addListener=function(e,t){var r;if(!i(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,i(t.listener)?t.listener:t),this._events[e]?a(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,a(this._events[e])&&!this._events[e].warned&&(r=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners)&&r>0&&this._events[e].length>r&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace()),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function r(){this.removeListener(e,r),n||(n=!0,t.apply(this,arguments))}if(!i(t))throw TypeError("listener must be a function");var n=!1;return r.listener=t,this.on(e,r),this},n.prototype.removeListener=function(e,t){var r,n,o,s;if(!i(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(r=this._events[e],o=r.length,n=-1,r===t||i(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(a(r)){for(s=o;s-- >0;)if(r[s]===t||r[s].listener&&r[s].listener===t){n=s;break}if(n<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(n,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[e],i(r))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){return this._events&&this._events[e]?i(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(i(t))return 1;if(t)return t.length}return 0},n.listenerCount=function(e,t){return e.listenerCount(t)}},{}],5:[function(e,t,r){(function(e){"use strict";function r(){c=!0;for(var e,t,r=l.length;r;){for(t=l,l=[],e=-1;++e<r;)t[e]();r=l.length}c=!1}var n,i=e.MutationObserver||e.WebKitMutationObserver;if(i){var o=0,a=new i(r),s=e.document.createTextNode("");a.observe(s,{characterData:!0}),n=function(){s.data=o=++o%2}}else if(e.setImmediate||void 0===e.MessageChannel)n="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){r(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(r,0)};else{var u=new e.MessageChannel;u.port1.onmessage=r,n=function(){u.port2.postMessage(0)}}var c,l=[];t.exports=function(e){1!==l.push(e)||c||n()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],6:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},{}],7:[function(e,t,r){"use strict";function n(){}function i(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=h,this.queue=[],this.outcome=void 0,e!==n&&u(this,e)}function o(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function a(e,t,r){l(function(){var n;try{n=t(r)}catch(t){return f.reject(e,t)}n===e?f.reject(e,new TypeError("Cannot resolve promise with itself")):f.resolve(e,n)})}function s(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function u(e,t){function r(t){i||(i=!0,f.reject(e,t))}function n(t){i||(i=!0,f.resolve(e,t))}var i=!1,o=c(function(){t(n,r)});"error"===o.status&&r(o.value)}function c(e,t){var r={};try{r.value=e(t),r.status="success"}catch(e){r.status="error",r.value=e}return r}var l=e(5),f={},p=["REJECTED"],d=["FULFILLED"],h=["PENDING"];t.exports=i,i.prototype.catch=function(e){return this.then(null,e)},i.prototype.then=function(e,t){if("function"!=typeof e&&this.state===d||"function"!=typeof t&&this.state===p)return this;var r=new this.constructor(n);return this.state!==h?a(r,this.state===d?e:t,this.outcome):this.queue.push(new o(r,e,t)),r},o.prototype.callFulfilled=function(e){f.resolve(this.promise,e)},o.prototype.otherCallFulfilled=function(e){a(this.promise,this.onFulfilled,e)},o.prototype.callRejected=function(e){f.reject(this.promise,e)},o.prototype.otherCallRejected=function(e){a(this.promise,this.onRejected,e)},f.resolve=function(e,t){var r=c(s,t);if("error"===r.status)return f.reject(e,r.value);var n=r.value;if(n)u(e,n);else{e.state=d,e.outcome=t;for(var i=-1,o=e.queue.length;++i<o;)e.queue[i].callFulfilled(t)}return e},f.reject=function(e,t){e.state=p,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},i.resolve=function(e){return e instanceof this?e:f.resolve(new this(n),e)},i.reject=function(e){var t=new this(n);return f.reject(t,e)},i.all=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,i=!1;if(!r)return this.resolve([]);for(var o=new Array(r),a=0,s=-1,u=new this(n);++s<r;)!function(e,n){t.resolve(e).then(function(e){o[n]=e,++a!==r||i||(i=!0,f.resolve(u,o))},function(e){i||(i=!0,f.reject(u,e))})}(e[s],s);return u},i.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,i=!1;if(!r)return this.resolve([]);for(var o=-1,a=new this(n);++o<r;)!function(e){t.resolve(e).then(function(e){i||(i=!0,f.resolve(a,e))},function(e){i||(i=!0,f.reject(a,e))})}(e[o]);return a}},{5:5}],8:[function(e,t,r){function n(e){if(!((e=String(e)).length>1e4)){var t=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(t){var r=parseFloat(t[1]);switch((t[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return r*f;case"days":case"day":case"d":return r*l;case"hours":case"hour":case"hrs":case"hr":case"h":return r*c;case"minutes":case"minute":case"mins":case"min":case"m":return r*u;case"seconds":case"second":case"secs":case"sec":case"s":return r*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}}}function i(e){return e>=l?Math.round(e/l)+"d":e>=c?Math.round(e/c)+"h":e>=u?Math.round(e/u)+"m":e>=s?Math.round(e/s)+"s":e+"ms"}function o(e){return a(e,l,"day")||a(e,c,"hour")||a(e,u,"minute")||a(e,s,"second")||e+" ms"}function a(e,t,r){if(!(e<t))return e<1.5*t?Math.floor(e/t)+" "+r:Math.ceil(e/t)+" "+r+"s"}var s=1e3,u=60*s,c=60*u,l=24*c,f=365.25*l;t.exports=function(e,t){t=t||{};var r=typeof e;if("string"===r&&e.length>0)return n(e);if("number"===r&&!1===isNaN(e))return t.long?o(e):i(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},{}],9:[function(e,t,r){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(e){if(f===setTimeout)return setTimeout(e,0);if((f===n||!f)&&setTimeout)return f=setTimeout,setTimeout(e,0);try{return f(e,0)}catch(t){try{return f.call(null,e,0)}catch(t){return f.call(this,e,0)}}}function a(e){if(p===clearTimeout)return clearTimeout(e);if((p===i||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(e);try{return p(e)}catch(t){try{return p.call(null,e)}catch(t){return p.call(this,e)}}}function s(){v&&h&&(v=!1,h.length?m=h.concat(m):y=-1,m.length&&u())}function u(){if(!v){var e=o(s);v=!0;for(var t=m.length;t;){for(h=m,m=[];++y<t;)h&&h[y].run();y=-1,t=m.length}h=null,v=!1,a(e)}}function c(e,t){this.fun=e,this.array=t}function l(){}var f,p,d=t.exports={};!function(){try{f="function"==typeof setTimeout?setTimeout:n}catch(e){f=n}try{p="function"==typeof clearTimeout?clearTimeout:i}catch(e){p=i}}();var h,m=[],v=!1,y=-1;d.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];m.push(new c(e,t)),1!==m.length||v||o(u)},c.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(e){return[]},d.binding=function(e){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(e){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},{}],10:[function(e,t,r){!function(e){if("object"==typeof r)t.exports=e();else{var n;try{n=window}catch(e){n=self}n.SparkMD5=e()}}(function(e){"use strict";function t(e,t){var r=e[0],n=e[1],i=e[2],o=e[3];n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[0]-680876936|0)<<7|r>>>25)+n|0)&n|~r&i)+t[1]-389564586|0)<<12|o>>>20)+r|0)&r|~o&n)+t[2]+606105819|0)<<17|i>>>15)+o|0)&o|~i&r)+t[3]-1044525330|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[4]-176418897|0)<<7|r>>>25)+n|0)&n|~r&i)+t[5]+1200080426|0)<<12|o>>>20)+r|0)&r|~o&n)+t[6]-1473231341|0)<<17|i>>>15)+o|0)&o|~i&r)+t[7]-45705983|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[8]+1770035416|0)<<7|r>>>25)+n|0)&n|~r&i)+t[9]-1958414417|0)<<12|o>>>20)+r|0)&r|~o&n)+t[10]-42063|0)<<17|i>>>15)+o|0)&o|~i&r)+t[11]-1990404162|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[12]+1804603682|0)<<7|r>>>25)+n|0)&n|~r&i)+t[13]-40341101|0)<<12|o>>>20)+r|0)&r|~o&n)+t[14]-1502002290|0)<<17|i>>>15)+o|0)&o|~i&r)+t[15]+1236535329|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[1]-165796510|0)<<5|r>>>27)+n|0)&i|n&~i)+t[6]-1069501632|0)<<9|o>>>23)+r|0)&n|r&~n)+t[11]+643717713|0)<<14|i>>>18)+o|0)&r|o&~r)+t[0]-373897302|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[5]-701558691|0)<<5|r>>>27)+n|0)&i|n&~i)+t[10]+38016083|0)<<9|o>>>23)+r|0)&n|r&~n)+t[15]-660478335|0)<<14|i>>>18)+o|0)&r|o&~r)+t[4]-405537848|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[9]+568446438|0)<<5|r>>>27)+n|0)&i|n&~i)+t[14]-1019803690|0)<<9|o>>>23)+r|0)&n|r&~n)+t[3]-187363961|0)<<14|i>>>18)+o|0)&r|o&~r)+t[8]+1163531501|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[13]-1444681467|0)<<5|r>>>27)+n|0)&i|n&~i)+t[2]-51403784|0)<<9|o>>>23)+r|0)&n|r&~n)+t[7]+1735328473|0)<<14|i>>>18)+o|0)&r|o&~r)+t[12]-1926607734|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[5]-378558|0)<<4|r>>>28)+n|0)^n^i)+t[8]-2022574463|0)<<11|o>>>21)+r|0)^r^n)+t[11]+1839030562|0)<<16|i>>>16)+o|0)^o^r)+t[14]-35309556|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[1]-1530992060|0)<<4|r>>>28)+n|0)^n^i)+t[4]+1272893353|0)<<11|o>>>21)+r|0)^r^n)+t[7]-155497632|0)<<16|i>>>16)+o|0)^o^r)+t[10]-1094730640|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[13]+681279174|0)<<4|r>>>28)+n|0)^n^i)+t[0]-358537222|0)<<11|o>>>21)+r|0)^r^n)+t[3]-722521979|0)<<16|i>>>16)+o|0)^o^r)+t[6]+76029189|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[9]-640364487|0)<<4|r>>>28)+n|0)^n^i)+t[12]-421815835|0)<<11|o>>>21)+r|0)^r^n)+t[15]+530742520|0)<<16|i>>>16)+o|0)^o^r)+t[2]-995338651|0)<<23|n>>>9)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[0]-198630844|0)<<6|r>>>26)+n|0)|~i))+t[7]+1126891415|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[14]-1416354905|0)<<15|i>>>17)+o|0)|~r))+t[5]-57434055|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[12]+1700485571|0)<<6|r>>>26)+n|0)|~i))+t[3]-1894986606|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[10]-1051523|0)<<15|i>>>17)+o|0)|~r))+t[1]-2054922799|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[8]+1873313359|0)<<6|r>>>26)+n|0)|~i))+t[15]-30611744|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[6]-1560198380|0)<<15|i>>>17)+o|0)|~r))+t[13]+1309151649|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[4]-145523070|0)<<6|r>>>26)+n|0)|~i))+t[11]-1120210379|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[2]+718787259|0)<<15|i>>>17)+o|0)|~r))+t[9]-343485551|0)<<21|n>>>11)+i|0,e[0]=r+e[0]|0,e[1]=n+e[1]|0,e[2]=i+e[2]|0,e[3]=o+e[3]|0}function r(e){var t,r=[];for(t=0;t<64;t+=4)r[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return r}function n(e){var t,r=[];for(t=0;t<64;t+=4)r[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return r}function i(e){var n,i,o,a,s,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(l,r(e.substring(n-64,n)));for(i=(e=e.substring(n-64)).length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<i;n+=1)o[n>>2]|=e.charCodeAt(n)<<(n%4<<3);if(o[n>>2]|=128<<(n%4<<3),n>55)for(t(l,o),n=0;n<16;n+=1)o[n]=0;return a=8*c,a=a.toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(a[2],16),u=parseInt(a[1],16)||0,o[14]=s,o[15]=u,t(l,o),l}function o(e){var r,i,o,a,s,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(l,n(e.subarray(r-64,r)));for(i=(e=r-64<c?e.subarray(r-64):new Uint8Array(0)).length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<i;r+=1)o[r>>2]|=e[r]<<(r%4<<3);if(o[r>>2]|=128<<(r%4<<3),r>55)for(t(l,o),r=0;r<16;r+=1)o[r]=0;return a=8*c,a=a.toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(a[2],16),u=parseInt(a[1],16)||0,o[14]=s,o[15]=u,t(l,o),l}function a(e){var t,r="";for(t=0;t<4;t+=1)r+=h[e>>8*t+4&15]+h[e>>8*t&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function u(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e,t){var r,n=e.length,i=new ArrayBuffer(n),o=new Uint8Array(i);for(r=0;r<n;r+=1)o[r]=e.charCodeAt(r);return t?o:i}function l(e){return String.fromCharCode.apply(null,new Uint8Array(e))}function f(e,t,r){var n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e)),n.set(new Uint8Array(t),e.byteLength),r?n:n.buffer}function p(e){var t,r=[],n=e.length;for(t=0;t<n-1;t+=2)r.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,r)}function d(){this.reset()}var h=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];return"5d41402abc4b2a76b9719d911017c592"!==s(i("hello"))&&function(e,t){var r=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(r>>16)<<16|65535&r},"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function t(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(r,n){var i,o,a,s,u=this.byteLength,c=t(r,u),l=u;return n!==e&&(l=t(n,u)),c>l?new ArrayBuffer(0):(i=l-c,o=new ArrayBuffer(i),a=new Uint8Array(o),s=new Uint8Array(this,c,i),a.set(s),o)}}(),d.prototype.append=function(e){return this.appendBinary(u(e)),this},d.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var n,i=this._buff.length;for(n=64;n<=i;n+=64)t(this._hash,r(this._buff.substring(n-64,n)));return this._buff=this._buff.substring(n-64),this},d.prototype.end=function(e){var t,r,n=this._buff,i=n.length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<i;t+=1)o[t>>2]|=n.charCodeAt(t)<<(t%4<<3);return this._finish(o,i),r=s(this._hash),e&&(r=p(r)),this.reset(),r},d.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},d.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash}},d.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},d.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},d.prototype._finish=function(e,r){var n,i,o,a=r;if(e[a>>2]|=128<<(a%4<<3),a>55)for(t(this._hash,e),a=0;a<16;a+=1)e[a]=0;n=(n=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(n[2],16),o=parseInt(n[1],16)||0,e[14]=i,e[15]=o,t(this._hash,e)},d.hash=function(e,t){return d.hashBinary(u(e),t)},d.hashBinary=function(e,t){var r=s(i(e));return t?p(r):r},d.ArrayBuffer=function(){this.reset()},d.ArrayBuffer.prototype.append=function(e){var r,i=f(this._buff.buffer,e,!0),o=i.length;for(this._length+=e.byteLength,r=64;r<=o;r+=64)t(this._hash,n(i.subarray(r-64,r)));return this._buff=r-64<o?new Uint8Array(i.buffer.slice(r-64)):new Uint8Array(0),this},d.ArrayBuffer.prototype.end=function(e){var t,r,n=this._buff,i=n.length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<i;t+=1)o[t>>2]|=n[t]<<(t%4<<3);return this._finish(o,i),r=s(this._hash),e&&(r=p(r)),this.reset(),r},d.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},d.ArrayBuffer.prototype.getState=function(){var e=d.prototype.getState.call(this);return e.buff=l(e.buff),e},d.ArrayBuffer.prototype.setState=function(e){return e.buff=c(e.buff,!0),d.prototype.setState.call(this,e)},d.ArrayBuffer.prototype.destroy=d.prototype.destroy,d.ArrayBuffer.prototype._finish=d.prototype._finish,d.ArrayBuffer.hash=function(e,t){var r=s(o(new Uint8Array(e)));return t?p(r):r},d})},{}],11:[function(e,t,r){for(var n=[],i=0;i<256;++i)n[i]=(i+256).toString(16).substr(1);t.exports=function(e,t){var r=t||0,i=n;return i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]}},{}],12:[function(e,t,r){(function(e){var r,n=e.crypto||e.msCrypto;if(n&&n.getRandomValues){var i=new Uint8Array(16);r=function(){return n.getRandomValues(i),i}}if(!r){var o=new Array(16);r=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),o[t]=e>>>((3&t)<<3)&255;return o}}t.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],13:[function(e,t,r){var n=e(12),i=e(11);t.exports=function(e,t,r){var o=t&&r||0;"string"==typeof e&&(t="binary"==e?new Array(16):null,e=null);var a=(e=e||{}).random||(e.rng||n)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t)for(var s=0;s<16;++s)t[o+s]=a[s];return t||i(a)}},{11:11,12:12}],14:[function(e,t,r){"use strict";function n(e,t,r){var n=r[r.length-1];e===n.element&&(r.pop(),n=r[r.length-1]);var i=n.element,o=n.index;Array.isArray(i)?i.push(e):o===t.length-2?i[t.pop()]=e:t.push(e)}r.stringify=function(e){var t=[];t.push({obj:e});for(var r,n,i,o,a,s,u,c,l,f,p,d="";r=t.pop();)if(n=r.obj,i=r.prefix||"",o=r.val||"",d+=i,o)d+=o;else if("object"!=typeof n)d+=void 0===n?null:JSON.stringify(n);else if(null===n)d+="null";else if(Array.isArray(n)){for(t.push({val:"]"}),a=n.length-1;a>=0;a--)s=0===a?"":",",t.push({obj:n[a],prefix:s});t.push({val:"["})}else{u=[];for(c in n)n.hasOwnProperty(c)&&u.push(c);for(t.push({val:"}"}),a=u.length-1;a>=0;a--)f=n[l=u[a]],p=a>0?",":"",p+=JSON.stringify(l)+":",t.push({obj:f,prefix:p});t.push({val:"{"})}return d},r.parse=function(e){for(var t,r,i,o,a,s,u,c,l,f=[],p=[],d=0;;)if("}"!==(t=e[d++])&&"]"!==t&&void 0!==t)switch(t){case" ":case"\t":case"\n":case":":case",":break;case"n":d+=3,n(null,f,p);break;case"t":d+=3,n(!0,f,p);break;case"f":d+=4,n(!1,f,p);break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":for(r="",d--;;){if(i=e[d++],!/[\d\.\-e\+]/.test(i)){d--;break}r+=i}n(parseFloat(r),f,p);break;case'"':for(o="",a=void 0,s=0;;){if('"'===(u=e[d++])&&("\\"!==a||s%2!=1))break;o+=u,"\\"===(a=u)?s++:s=0}n(JSON.parse('"'+o+'"'),f,p);break;case"[":c={element:[],index:f.length},f.push(c.element),p.push(c);break;case"{":l={element:{},index:f.length},f.push(l.element),p.push(l);break;default:throw new Error("unexpectedly reached end of input: "+t)}else{if(1===f.length)return f.pop();n(f.pop(),f,p)}}},{}],15:[function(e,t,r){(function(r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e){return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer||"undefined"!=typeof Blob&&e instanceof Blob}function o(e){if("function"==typeof e.slice)return e.slice(0);var t=new ArrayBuffer(e.byteLength),r=new Uint8Array(t),n=new Uint8Array(e);return r.set(n),t}function a(e){if(e instanceof ArrayBuffer)return o(e);var t=e.size,r=e.type;return"function"==typeof e.slice?e.slice(0,t,r):e.webkitSlice(0,t,r)}function s(e){var t=Object.getPrototypeOf(e);if(null===t)return!0;var r=t.constructor;return"function"==typeof r&&r instanceof r&&oi.call(r)==ai}function u(e){var t,r,n;if(!e||"object"!=typeof e)return e;if(Array.isArray(e)){for(t=[],r=0,n=e.length;r<n;r++)t[r]=u(e[r]);return t}if(e instanceof Date)return e.toISOString();if(i(e))return a(e);if(!s(e))return e;t={};for(r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var o=u(e[r]);void 0!==o&&(t[r]=o)}return t}function c(e){var t=!1;return Qn(function(r){if(t)throw new Error("once called more than once");t=!0,e.apply(this,r)})}function l(e){return Qn(function(t){var r=this,n="function"==typeof(t=u(t))[t.length-1]&&t.pop(),i=new ii(function(n,i){var o;try{var a=c(function(e,t){e?i(e):n(t)});t.push(a),(o=e.apply(r,t))&&"function"==typeof o.then&&n(o)}catch(e){i(e)}});return n&&i.then(function(e){n(null,e)},n),i})}function f(e,t,r){if(e.constructor.listeners("debug").length){for(var n=["api",e.name,t],i=0;i<r.length-1;i++)n.push(r[i]);e.constructor.emit("debug",n);var o=r[r.length-1];r[r.length-1]=function(r,n){var i=["api",e.name,t];i=i.concat(r?["error",r]:["success",n]),e.constructor.emit("debug",i),o(r,n)}}}function p(e,t){return l(Qn(function(r){if(this._closed)return ii.reject(new Error("database is closed"));if(this._destroyed)return ii.reject(new Error("database is destroyed"));var n=this;return f(n,e,r),this.taskqueue.isReady?t.apply(this,r):new ii(function(t,i){n.taskqueue.addTask(function(o){o?i(o):t(n[e].apply(n,r))})})}))}function d(e){return"$"+e}function h(e){return e.substring(1)}function m(){this._store={}}function v(e){if(this._store=new m,e&&Array.isArray(e))for(var t=0,r=e.length;t<r;t++)this.add(e[t])}function y(e,t){for(var r={},n=0,i=t.length;n<i;n++){var o=t[n];o in e&&(r[o]=e[o])}return r}function g(e){return e}function b(e){return[{ok:e}]}function _(e,t,r){function n(){var e=[];p.forEach(function(t){t.docs.forEach(function(r){e.push({id:t.id,docs:[r]})})}),r(null,{results:e})}function i(){++f===l&&n()}function o(e,t,r){p[e]={id:t,docs:r},i()}function a(){if(!(h>=d.length)){var e=Math.min(h+li,d.length),t=d.slice(h,e);s(t,h),h+=t.length}}function s(r,n){r.forEach(function(r,i){var s=n+i,u=c.get(r),l=y(u[0],["atts_since","attachments"]);l.open_revs=u.map(function(e){return e.rev}),l.open_revs=l.open_revs.filter(g);var f=g;0===l.open_revs.length&&(delete l.open_revs,f=b),["revs","attachments","binary","ajax","latest"].forEach(function(e){e in t&&(l[e]=t[e])}),e.get(r,l,function(e,t){var n;n=e?[{error:e}]:f(t),o(s,r,n),a()})})}var u=t.docs,c=new ui;u.forEach(function(e){c.has(e.id)?c.get(e.id).push(e):c.set(e.id,[e])});var l=c.size,f=0,p=new Array(l),d=[];c.forEach(function(e,t){d.push(t)});var h=0;a()}function x(){return"undefined"!=typeof chrome&&void 0!==chrome.storage&&void 0!==chrome.storage.local}function w(){return ci}function k(e){x()?chrome.storage.onChanged.addListener(function(t){null!=t.db_name&&e.emit(t.dbName.newValue)}):w()&&("undefined"!=typeof addEventListener?addEventListener("storage",function(t){e.emit(t.key)}):window.attachEvent("storage",function(t){e.emit(t.key)}))}function E(){Yn.EventEmitter.call(this),this._listeners={},k(this)}function S(e){if("undefined"!==console&&e in console){var t=Array.prototype.slice.call(arguments,1);console[e].apply(console,t)}}function A(e,t){return e=parseInt(e,10)||0,(t=parseInt(t,10))!==t||t<=e?t=(e||1)<<1:t+=1,t>6e5&&(e=3e5,t=6e5),~~((t-e)*Math.random()+e)}function D(e){var t=0;return e||(t=2e3),A(e,t)}function C(e,t){S("info","The above "+e+" is totally normal. "+t)}function F(e,t,r){Error.call(this,r),this.status=e,this.name=t,this.message=r,this.error=!0}function O(e,t){function r(t){for(var r in e)"function"!=typeof e[r]&&(this[r]=e[r]);void 0!==t&&(this.reason=t)}return r.prototype=F.prototype,new r(t)}function j(e){if("object"!=typeof e){var t=e;(e=bi).data=t}return"error"in e&&"conflict"===e.error&&(e.name="conflict",e.status=409),"name"in e||(e.name=e.error||"unknown"),"status"in e||(e.status=500),"message"in e||(e.message=e.message||e.reason),e}function R(e,t,r){try{return!e(t,r)}catch(e){var n="Filter function threw: "+e.toString();return O(ki,n)}}function B(e){var t={},r=e.filter&&"function"==typeof e.filter;return t.query=e.query_params,function(n){n.doc||(n.doc={});var i=r&&R(e.filter,n.doc,t);if("object"==typeof i)return i;if(i)return!1;if(e.include_docs){if(!e.attachments)for(var o in n.doc._attachments)n.doc._attachments.hasOwnProperty(o)&&(n.doc._attachments[o].stub=!0)}else delete n.doc;return!0}}function P(e){for(var t=[],r=0,n=e.length;r<n;r++)t=t.concat(e[r]);return t}function T(e){var t;if(e?"string"!=typeof e?t=O(vi):/^_/.test(e)&&!/^_(design|local)/.test(e)&&(t=O(gi)):t=O(yi),t)throw t}function I(e){return"boolean"==typeof e._remote?e._remote:"function"==typeof e.type&&(S("warn","db.type() is deprecated and will be removed in a future version of PouchDB"),"http"===e.type())}function L(e,t){return"listenerCount"in e?e.listenerCount(t):Yn.EventEmitter.listenerCount(e,t)}function N(e){if(!e)return null;var t=e.split("/");return 2===t.length?t:1===t.length?[e,e]:null}function M(e){var t=N(e);return t?t.join("/"):null}function q(e){for(var t=Ri.exec(e),r={},n=14;n--;){var i=Fi[n],o=t[n]||"",a=-1!==["user","password"].indexOf(i);r[i]=a?decodeURIComponent(o):o}return r[Oi]={},r[Fi[12]].replace(ji,function(e,t,n){t&&(r[Oi][t]=n)}),r}function $(e,t){var r=[],n=[];for(var i in t)t.hasOwnProperty(i)&&(r.push(i),n.push(t[i]));return r.push(e),Function.apply(null,r).apply(null,n)}function W(e,t,r){return new ii(function(n,i){e.get(t,function(o,a){if(o){if(404!==o.status)return i(o);a={}}var s=a._rev,u=r(a);if(!u)return n({updated:!1,rev:s});u._id=t,u._rev=s,n(U(e,u,r))})})}function U(e,t,r){return e.put(t).then(function(e){return{updated:!0,rev:e.rev}},function(n){if(409!==n.status)throw n;return W(e,t._id,r)})}function z(){return ei().replace(/-/g,"").toLowerCase()}function V(e){for(var t,r,n,i,o=e.rev_tree.slice();i=o.pop();){var a=i.ids,s=a[2],u=i.pos;if(s.length)for(var c=0,l=s.length;c<l;c++)o.push({pos:u+1,ids:s[c]});else{var f=!!a[1].deleted,p=a[0];t&&!(n!==f?n:r!==u?r<u:t<p)||(t=p,r=u,n=f)}}return r+"-"+t}function G(e,t){for(var r,n=e.slice();r=n.pop();)for(var i=r.pos,o=r.ids,a=o[2],s=t(0===a.length,i,o[0],r.ctx,o[1]),u=0,c=a.length;u<c;u++)n.push({pos:i+1,ids:a[u],ctx:s})}function H(e,t){return e.pos-t.pos}function J(e){var t=[];G(e,function(e,r,n,i,o){e&&t.push({rev:r+"-"+n,pos:r,opts:o})}),t.sort(H).reverse();for(var r=0,n=t.length;r<n;r++)delete t[r].pos;return t}function K(e){for(var t=V(e),r=J(e.rev_tree),n=[],i=0,o=r.length;i<o;i++){var a=r[i];a.rev===t||a.opts.deleted||n.push(a.rev)}return n}function Q(e){var t=[];return G(e.rev_tree,function(e,r,n,i,o){"available"!==o.status||e||(t.push(r+"-"+n),o.status="missing")}),t}function Y(e){for(var t,r=[],n=e.slice();t=n.pop();){var i=t.pos,o=t.ids,a=o[0],s=o[1],u=o[2],c=0===u.length,l=t.history?t.history.slice():[];l.push({id:a,opts:s}),c&&r.push({pos:i+1-l.length,ids:l});for(var f=0,p=u.length;f<p;f++)n.push({pos:i+1,ids:u[f],history:l})}return r.reverse()}function X(e,t){return e.pos-t.pos}function Z(e,t,r){for(var n,i=0,o=e.length;i<o;)r(e[n=i+o>>>1],t)<0?i=n+1:o=n;return i}function ee(e,t,r){var n=Z(e,t,r);e.splice(n,0,t)}function te(e,t){for(var r,n,i=t,o=e.length;i<o;i++){var a=e[i],s=[a.id,a.opts,[]];n?(n[2].push(s),n=s):r=n=s}return r}function re(e,t){return e[0]<t[0]?-1:1}function ne(e,t){for(var r=[{tree1:e,tree2:t}],n=!1;r.length>0;){var i=r.pop(),o=i.tree1,a=i.tree2;(o[1].status||a[1].status)&&(o[1].status="available"===o[1].status||"available"===a[1].status?"available":"missing");for(var s=0;s<a[2].length;s++)if(o[2][0]){for(var u=!1,c=0;c<o[2].length;c++)o[2][c][0]===a[2][s][0]&&(r.push({tree1:o[2][c],tree2:a[2][s]}),u=!0);u||(n="new_branch",ee(o[2],a[2][s],re))}else n="new_leaf",o[2][0]=a[2][s]}return{conflicts:n,tree:e}}function ie(e,t,r){var n,i=[],o=!1,a=!1;if(!e.length)return{tree:[t],conflicts:"new_leaf"};for(var s=0,u=e.length;s<u;s++){var c=e[s];if(c.pos===t.pos&&c.ids[0]===t.ids[0])n=ne(c.ids,t.ids),i.push({pos:c.pos,ids:n.tree}),o=o||n.conflicts,a=!0;else if(!0!==r){var l=c.pos<t.pos?c:t,f=c.pos<t.pos?t:c,p=f.pos-l.pos,d=[],h=[];for(h.push({ids:l.ids,diff:p,parent:null,parentIdx:null});h.length>0;){var m=h.pop();if(0!==m.diff)for(var v=m.ids[2],y=0,g=v.length;y<g;y++)h.push({ids:v[y],diff:m.diff-1,parent:m.ids,parentIdx:y});else m.ids[0]===f.ids[0]&&d.push(m)}var b=d[0];b?(n=ne(b.ids,f.ids),b.parent[2][b.parentIdx]=n.tree,i.push({pos:l.pos,ids:l.ids}),o=o||n.conflicts,a=!0):i.push(c)}else i.push(c)}return a||i.push(t),i.sort(X),{tree:i,conflicts:o||"internal_node"}}function oe(e,t){for(var r,n,i=Y(e),o=0,a=i.length;o<a;o++){var s,u=i[o],c=u.ids;if(c.length>t){r||(r={});var l=c.length-t;s={pos:u.pos+l,ids:te(c,l)};for(var f=0;f<l;f++){var p=u.pos+f+"-"+c[f].id;r[p]=!0}}else s={pos:u.pos,ids:te(c,0)};n=n?ie(n,s,!0).tree:[s]}return r&&G(n,function(e,t,n){delete r[t+"-"+n]}),{tree:n,revs:r?Object.keys(r):[]}}function ae(e,t,r){var n=ie(e,t),i=oe(n.tree,r);return{tree:i.tree,stemmedRevs:i.revs,conflicts:n.conflicts}}function se(e,t){for(var r,n=e.slice(),i=t.split("-"),o=parseInt(i[0],10),a=i[1];r=n.pop();){if(r.pos===o&&r.ids[0]===a)return!0;for(var s=r.ids[2],u=0,c=s.length;u<c;u++)n.push({pos:r.pos+1,ids:s[u]})}return!1}function ue(e){return e.ids}function ce(e,t){t||(t=V(e));for(var r,n=t.substring(t.indexOf("-")+1),i=e.rev_tree.map(ue);r=i.pop();){if(r[0]===n)return!!r[1].deleted;i=i.concat(r[2])}}function le(e){return/^_local/.test(e)}function fe(e,t){for(var r,n=t.rev_tree.slice();r=n.pop();){var i=r.pos,o=r.ids,a=o[0],s=o[1],u=o[2],c=0===u.length,l=r.history?r.history.slice():[];if(l.push({id:a,pos:i,opts:s}),c)for(var f=0,p=l.length;f<p;f++){var d=l[f];if(d.pos+"-"+d.id===e)return i+"-"+a}for(var h=0,m=u.length;h<m;h++)n.push({pos:i+1,ids:u[h],history:l})}throw new Error("Unable to resolve latest revision for id "+t.id+", rev "+e)}function pe(e,t){try{e.emit("change",t)}catch(e){S("error",'Error in .on("change", function):',e)}}function de(e,t,r){function n(){i.cancel()}Yn.EventEmitter.call(this);var i=this;this.db=e;var o=(t=t?u(t):{}).complete=c(function(t,r){t?L(i,"error")>0&&i.emit("error",t):i.emit("complete",r),i.removeAllListeners(),e.removeListener("destroyed",n)});r&&(i.on("complete",function(e){r(null,e)}),i.on("error",r)),e.once("destroyed",n),t.onChange=function(e){i.isCancelled||pe(i,e)};var a=new ii(function(e,r){t.complete=function(t,n){t?r(t):e(n)}});i.once("cancel",function(){e.removeListener("destroyed",n),t.complete(null,{status:"cancelled"})}),this.then=a.then.bind(a),this.catch=a.catch.bind(a),this.then(function(e){o(null,e)},o),e.taskqueue.isReady?i.validateChanges(t):e.taskqueue.addTask(function(e){e?t.complete(e):i.isCancelled?i.emit("cancel"):i.validateChanges(t)})}function he(e,t,r){var n=[{rev:e._rev}];"all_docs"===r.style&&(n=J(t.rev_tree).map(function(e){return{rev:e.rev}}));var i={id:t.id,changes:n,doc:e};return ce(t,e._rev)&&(i.deleted=!0),r.conflicts&&(i.doc._conflicts=K(t),i.doc._conflicts.length||delete i.doc._conflicts),i}function me(e,t){return e<t?-1:e>t?1:0}function ve(e,t){return function(r,n){r||n[0]&&n[0].error?((r=r||n[0]).docId=t,e(r)):e(null,n.length?n[0]:n)}}function ye(e){for(var t=0;t<e.length;t++){var r=e[t];if(r._deleted)delete r._attachments;else if(r._attachments)for(var n=Object.keys(r._attachments),i=0;i<n.length;i++){var o=n[i];r._attachments[o]=y(r._attachments[o],["data","digest","content_type","length","revpos","stub"])}}}function ge(e,t){var r=me(e._id,t._id);return 0!==r?r:me(e._revisions?e._revisions.start:0,t._revisions?t._revisions.start:0)}function be(e){var t={},r=[];return G(e,function(e,n,i,o){var a=n+"-"+i;return e&&(t[a]=0),void 0!==o&&r.push({from:o,to:a}),a}),r.reverse(),r.forEach(function(e){void 0===t[e.from]?t[e.from]=1+t[e.to]:t[e.from]=Math.min(t[e.from],1+t[e.to])}),t}function _e(e,t,r){var n="limit"in t?t.keys.slice(t.skip,t.limit+t.skip):t.skip>0?t.keys.slice(t.skip):t.keys;if(t.descending&&n.reverse(),!n.length)return e._allDocs({limit:0},r);var i={offset:t.skip};return ii.all(n.map(function(r){var n=pi({key:r,deleted:"ok"},t);return["limit","skip","keys"].forEach(function(e){delete n[e]}),new ii(function(t,o){e._allDocs(n,function(e,n){if(e)return o(e);i.total_rows=n.total_rows,t(n.rows[0]||{key:r,error:"not_found"})})})})).then(function(e){return i.rows=e,i})}function xe(e){var t=e._compactionQueue[0],r=t.opts,n=t.callback;e.get("_local/compaction").catch(function(){return!1}).then(function(t){t&&t.last_seq&&(r.last_seq=t.last_seq),e._compact(r,function(t,r){t?n(t):n(null,r),Zn(function(){e._compactionQueue.shift(),e._compactionQueue.length&&xe(e)})})})}function we(e){return"_"===e.charAt(0)&&e+" is not a valid attachment name, attachment names cannot start with '_'"}function ke(){Yn.EventEmitter.call(this)}function Ee(){this.isReady=!1,this.failed=!1,this.queue=[]}function Se(e,t){var r=e.match(/([a-z-]*):\/\/(.*)/);if(r)return{name:/https?/.test(r[1])?r[1]+"://"+r[2]:r[2],adapter:r[1]};var n=De.adapters,i=De.preferredAdapters,o=De.prefix,a=t.adapter;if(!a)for(var s=0;s<i.length&&("idb"===(a=i[s])&&"websql"in n&&w()&&localStorage["_pouch__websqldb_"+o+e]);++s)S("log",'PouchDB is downgrading "'+e+'" to WebSQL to avoid data loss, because it was already opened with WebSQL.');var u=n[a];return{name:!(u&&"use_prefix"in u)||u.use_prefix?o+e:e,adapter:a}}function Ae(e){function t(t){e.removeListener("closed",r),t||e.constructor.emit("destroyed",e.name)}function r(){e.removeListener("destroyed",t),e.constructor.emit("unref",e)}e.once("destroyed",t),e.once("closed",r),e.constructor.emit("ref",e)}function De(e,t){if(!(this instanceof De))return new De(e,t);var r=this;if(t=t||{},e&&"object"==typeof e&&(e=(t=e).name,delete t.name),this.__opts=t=u(t),r.auto_compaction=t.auto_compaction,r.prefix=De.prefix,"string"!=typeof e)throw new Error("Missing/invalid DB name");var n=Se((t.prefix||"")+e,t);if(t.name=n.name,t.adapter=t.adapter||n.adapter,r.name=e,r._adapter=t.adapter,De.emit("debug",["adapter","Picked adapter: ",t.adapter]),!De.adapters[t.adapter]||!De.adapters[t.adapter].valid())throw new Error("Invalid Adapter: "+t.adapter);ke.call(r),r.taskqueue=new Ee,r.adapter=t.adapter,De.adapters[t.adapter].call(r,t,function(e){if(e)return r.taskqueue.fail(e);Ae(r),r.emit("created",r),De.emit("created",r.name),r.taskqueue.ready(r)})}function Ce(e,t){for(var r=e,n=0,i=t.length;n<i&&(r=r[t[n]]);n++);return r}function Fe(e,t){return e<t?-1:e>t?1:0}function Oe(e){for(var t=[],r="",n=0,i=e.length;n<i;n++){var o=e[n];"."===o?n>0&&"\\"===e[n-1]?r=r.substring(0,r.length-1)+".":(t.push(r),r=""):r+=o}return t.push(r),t}function je(e){return Ti.indexOf(e)>-1}function Re(e){return Object.keys(e)[0]}function Be(e){return e[Re(e)]}function Pe(e){var t={};return e.forEach(function(e){Object.keys(e).forEach(function(r){var n=e[r];if("object"!=typeof n&&(n={$eq:n}),je(r))n instanceof Array?t[r]=n.map(function(e){return Pe([e])}):t[r]=Pe([n]);else{var i=t[r]=t[r]||{};Object.keys(n).forEach(function(e){var t=n[e];return"$gt"===e||"$gte"===e?Te(e,t,i):"$lt"===e||"$lte"===e?Ie(e,t,i):"$ne"===e?Le(t,i):"$eq"===e?Ne(t,i):void(i[e]=t)})}})}),t}function Te(e,t,r){void 0===r.$eq&&(void 0!==r.$gte?"$gte"===e?t>r.$gte&&(r.$gte=t):t>=r.$gte&&(delete r.$gte,r.$gt=t):void 0!==r.$gt?"$gte"===e?t>r.$gt&&(delete r.$gt,r.$gte=t):t>r.$gt&&(r.$gt=t):r[e]=t)}function Ie(e,t,r){void 0===r.$eq&&(void 0!==r.$lte?"$lte"===e?t<r.$lte&&(r.$lte=t):t<=r.$lte&&(delete r.$lte,r.$lt=t):void 0!==r.$lt?"$lte"===e?t<r.$lt&&(delete r.$lt,r.$lte=t):t<r.$lt&&(r.$lt=t):r[e]=t)}function Le(e,t){"$ne"in t?t.$ne.push(e):t.$ne=[e]}function Ne(e,t){delete t.$gt,delete t.$gte,delete t.$lt,delete t.$lte,delete t.$ne,t.$eq=e}function Me(e){var t=u(e),r=!1;"$and"in t&&(t=Pe(t.$and),r=!0),["$or","$nor"].forEach(function(e){e in t&&t[e].forEach(function(e){for(var t=Object.keys(e),r=0;r<t.length;r++){var n=t[r],i=e[n];"object"==typeof i&&null!==i||(e[n]={$eq:i})}})}),"$not"in t&&(t.$not=Pe([t.$not]));for(var n=Object.keys(t),i=0;i<n.length;i++){var o=n[i],a=t[o];"object"!=typeof a||null===a?a={$eq:a}:"$ne"in a&&!r&&(a.$ne=[a.$ne]),t[o]=a}return t}function qe(e,t,r){for(var n="",i=r-e.length;n.length<i;)n+=t;return n}function $e(e,t,r){return qe(e,t,r)+e}function We(e,t){if(e===t)return 0;e=Ue(e),t=Ue(t);var r=Xe(e),n=Xe(t);if(r-n!=0)return r-n;switch(typeof e){case"number":return e-t;case"boolean":return e<t?-1:1;case"string":return Qe(e,t)}return Array.isArray(e)?Ke(e,t):Ye(e,t)}function Ue(e){switch(typeof e){case"undefined":return null;case"number":return e===1/0||e===-1/0||isNaN(e)?null:e;case"object":var t=e;if(Array.isArray(e)){var r=e.length;e=new Array(r);for(var n=0;n<r;n++)e[n]=Ue(t[n])}else{if(e instanceof Date)return e.toJSON();if(null!==e){e={};for(var i in t)if(t.hasOwnProperty(i)){var o=t[i];void 0!==o&&(e[i]=Ue(o))}}}}return e}function ze(e){if(null!==e)switch(typeof e){case"boolean":return e?1:0;case"number":return Ze(e);case"string":return e.replace(/\u0002/g,"").replace(/\u0001/g,"").replace(/\u0000/g,"");case"object":var t=Array.isArray(e),r=t?e:Object.keys(e),n=-1,i=r.length,o="";if(t)for(;++n<i;)o+=Ve(r[n]);else for(;++n<i;){var a=r[n];o+=Ve(a)+Ve(e[a])}return o}return""}function Ve(e){return e=Ue(e),Xe(e)+Ni+ze(e)+"\0"}function Ge(e,t){var r,n=t;if("1"===e[t])r=0,t++;else{var i="0"===e[t];t++;var o="",a=e.substring(t,t+Li),s=parseInt(a,10)+Ii;for(i&&(s=-s),t+=Li;;){var u=e[t];if("\0"===u)break;o+=u,t++}r=1===(o=o.split(".")).length?parseInt(o,10):parseFloat(o[0]+"."+o[1]),i&&(r-=10),0!==s&&(r=parseFloat(r+"e"+s))}return{num:r,length:t-n}}function He(e,t){var r=e.pop();if(t.length){var n=t[t.length-1];r===n.element&&(t.pop(),n=t[t.length-1]);var i=n.element,o=n.index;Array.isArray(i)?i.push(r):o===e.length-2?i[e.pop()]=r:e.push(r)}}function Je(e){for(var t=[],r=[],n=0;;){var i=e[n++];if("\0"!==i)switch(i){case"1":t.push(null);break;case"2":t.push("1"===e[n]),n++;break;case"3":var o=Ge(e,n);t.push(o.num),n+=o.length;break;case"4":for(var a="";;){var s=e[n];if("\0"===s)break;a+=s,n++}a=a.replace(/\u0001\u0001/g,"\0").replace(/\u0001\u0002/g,"").replace(/\u0002\u0002/g,""),t.push(a);break;case"5":var u={element:[],index:t.length};t.push(u.element),r.push(u);break;case"6":var c={element:{},index:t.length};t.push(c.element),r.push(c);break;default:throw new Error("bad collationIndex or unexpectedly reached end of input: "+i)}else{if(1===t.length)return t.pop();He(t,r)}}}function Ke(e,t){for(var r=Math.min(e.length,t.length),n=0;n<r;n++){var i=We(e[n],t[n]);if(0!==i)return i}return e.length===t.length?0:e.length>t.length?1:-1}function Qe(e,t){return e===t?0:e>t?1:-1}function Ye(e,t){for(var r=Object.keys(e),n=Object.keys(t),i=Math.min(r.length,n.length),o=0;o<i;o++){var a=We(r[o],n[o]);if(0!==a)return a;if(0!==(a=We(e[r[o]],t[n[o]])))return a}return r.length===n.length?0:r.length>n.length?1:-1}function Xe(e){var t=["boolean","number","string","object"].indexOf(typeof e);return~t?null===e?1:Array.isArray(e)?5:t<3?t+2:t+3:Array.isArray(e)?5:void 0}function Ze(e){if(0===e)return"1";var t=e.toExponential().split(/e\+?/),r=parseInt(t[1],10),n=e<0,i=n?"0":"2",o=$e(((n?-r:r)-Ii).toString(),"0",Li);i+=Ni+o;var a=Math.abs(parseFloat(t[0]));n&&(a=10-a);var s=a.toFixed(20);return s=s.replace(/\.?0+$/,""),i+=Ni+s}function et(e){function t(t){return e.map(function(e){var r=Oe(Re(e));return Ce(t,r)})}return function(e,r){var n=We(t(e.doc),t(r.doc));return 0!==n?n:Fe(e.doc._id,r.doc._id)}}function tt(e,t,r){if(e=e.filter(function(e){return rt(e.doc,t.selector,r)}),t.sort){var n=et(t.sort);e=e.sort(n),"string"!=typeof t.sort[0]&&"desc"===Be(t.sort[0])&&(e=e.reverse())}if("limit"in t||"skip"in t){var i=t.skip||0,o=("limit"in t?t.limit:e.length)+i;e=e.slice(i,o)}return e}function rt(e,t,r){return r.every(function(r){var n=t[r],i=Oe(r),o=Ce(e,i);return je(r)?it(r,n,e):nt(n,e,i,o)})}function nt(e,t,r,n){return!e||Object.keys(e).every(function(i){var o=e[i];return ot(i,t,o,r,n)})}function it(e,t,r){return"$or"===e?t.some(function(e){return rt(r,e,Object.keys(e))}):"$not"===e?!rt(r,t,Object.keys(t)):!t.find(function(e){return rt(r,e,Object.keys(e))})}function ot(e,t,r,n,i){if(!Mi[e])throw new Error('unknown operator "'+e+'" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, $nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');return Mi[e](t,r,n,i)}function at(e){return void 0!==e&&null!==e}function st(e){return void 0!==e}function ut(e,t){var r=t[0],n=t[1];if(0===r)throw new Error("Bad divisor, cannot divide by zero");if(parseInt(r,10)!==r)throw new Error("Divisor is not an integer");if(parseInt(n,10)!==n)throw new Error("Modulus is not an integer");return parseInt(e,10)===e&&e%r===n}function ct(e,t){return t.some(function(t){return e instanceof Array?e.indexOf(t)>-1:e===t})}function lt(e,t){return t.every(function(t){return e.indexOf(t)>-1})}function ft(e,t){return e.length===t}function pt(e,t){return new RegExp(t).test(e)}function dt(e,t){switch(t){case"null":return null===e;case"boolean":return"boolean"==typeof e;case"number":return"number"==typeof e;case"string":return"string"==typeof e;case"array":return e instanceof Array;case"object":return"[object Object]"==={}.toString.call(e)}throw new Error(t+" not supported as a type.Please use one of object, string, array, number, boolean or null.")}function ht(e,t){if("object"!=typeof t)throw new Error("Selector error: expected a JSON object");var r=tt([{doc:e}],{selector:t=Me(t)},Object.keys(t));return r&&1===r.length}function mt(e){return $('"use strict";\nreturn '+e+";",{})}function vt(e){return $(["return function(doc) {",'  "use strict";',"  var emitted = false;","  var emit = function (a, b) {","    emitted = true;","  };","  var view = "+e+";","  view(doc);","  if (emitted) {","    return true;","  }","};"].join("\n"),{})}function yt(e,t){if(e.selector&&e.filter&&"_selector"!==e.filter){var r="string"==typeof e.filter?e.filter:"function";return t(new Error('selector invalid for filter "'+r+'"'))}t()}function gt(e){e.view&&!e.filter&&(e.filter="_view"),e.selector&&!e.filter&&(e.filter="_selector"),e.filter&&"string"==typeof e.filter&&("_view"===e.filter?e.view=M(e.view):e.filter=M(e.filter))}function bt(e,t){return t.filter&&"string"==typeof t.filter&&!t.doc_ids&&!I(e.db)}function _t(e,t){var r=t.complete;if("_view"===t.filter){if(!t.view||"string"!=typeof t.view){var n=O(ki,"`view` filter parameter not found or invalid.");return r(n)}var i=N(t.view);e.db.get("_design/"+i[0],function(n,o){if(e.isCancelled)return r(null,{status:"cancelled"});if(n)return r(j(n));var a=o&&o.views&&o.views[i[1]]&&o.views[i[1]].map;if(!a)return r(O(hi,o.views?"missing json key: "+i[1]:"missing json key: views"));t.filter=vt(a),e.doChanges(t)})}else if(t.selector)t.filter=function(e){return ht(e,t.selector)},e.doChanges(t);else{var o=N(t.filter);e.db.get("_design/"+o[0],function(n,i){if(e.isCancelled)return r(null,{status:"cancelled"});if(n)return r(j(n));var a=i&&i.filters&&i.filters[o[1]];if(!a)return r(O(hi,i&&i.filters?"missing json key: "+o[1]:"missing json key: filters"));t.filter=mt(a),e.doChanges(t)})}}function xt(e){return e.reduce(function(e,t){return e[t]=!0,e},{})}function wt(e){if(!/^\d+-./.test(e))return O(Di);var t=e.indexOf("-"),r=e.substring(0,t),n=e.substring(t+1);return{prefix:parseInt(r,10),id:n}}function kt(e,t){for(var r=e.start-e.ids.length+1,n=e.ids,i=[n[0],t,[]],o=1,a=n.length;o<a;o++)i=[n[o],{status:"missing"},[i]];return[{pos:r,ids:i}]}function Et(e,t){var r,n,i,o={status:"available"};if(e._deleted&&(o.deleted=!0),t)if(e._id||(e._id=Bi()),n=z(),e._rev){if((i=wt(e._rev)).error)return i;e._rev_tree=[{pos:i.prefix,ids:[i.id,{status:"missing"},[[n,o,[]]]]}],r=i.prefix+1}else e._rev_tree=[{pos:1,ids:[n,o,[]]}],r=1;else if(e._revisions&&(e._rev_tree=kt(e._revisions,o),r=e._revisions.start,n=e._revisions.ids[0]),!e._rev_tree){if((i=wt(e._rev)).error)return i;r=i.prefix,n=i.id,e._rev_tree=[{pos:r,ids:[n,o,[]]}]}T(e._id),e._rev=r+"-"+n;var a={metadata:{},data:{}};for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var u="_"===s[0];if(u&&!$i[s]){var c=O(wi,s);throw c.message=wi.message+": "+s,c}u&&!Wi[s]?a.metadata[s.slice(1)]=e[s]:a.data[s]=e[s]}return a}function St(e,t){e=e||[],t=t||{};try{return new Blob(e,t)}catch(i){if("TypeError"!==i.name)throw i;for(var r=new("undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder),n=0;n<e.length;n+=1)r.append(e[n]);return r.getBlob(t.type)}}function At(e){for(var t=e.length,r=new ArrayBuffer(t),n=new Uint8Array(r),i=0;i<t;i++)n[i]=e.charCodeAt(i);return r}function Dt(e,t){return St([At(e)],{type:t})}function Ct(e,t){return Dt(Ui(e),t)}function Ft(e){for(var t="",r=new Uint8Array(e),n=r.byteLength,i=0;i<n;i++)t+=String.fromCharCode(r[i]);return t}function Ot(e,t){if("undefined"==typeof FileReader)return t(Ft((new FileReaderSync).readAsArrayBuffer(e)));var r=new FileReader,n="function"==typeof r.readAsBinaryString;r.onloadend=function(e){var r=e.target.result||"";if(n)return t(r);t(Ft(r))},n?r.readAsBinaryString(e):r.readAsArrayBuffer(e)}function jt(e,t){Ot(e,function(e){t(e)})}function Rt(e,t){jt(e,function(e){t(zi(e))})}function Bt(e,t){if("undefined"==typeof FileReader)return t((new FileReaderSync).readAsArrayBuffer(e));var r=new FileReader;r.onloadend=function(e){var r=e.target.result||new ArrayBuffer(0);t(r)},r.readAsArrayBuffer(e)}function Pt(e){return zi(e)}function Tt(e,t,r){return e.webkitSlice?e.webkitSlice(t,r):e.slice(t,r)}function It(e,t,r,n,i){(r>0||n<t.size)&&(t=Tt(t,r,n)),Bt(t,function(t){e.append(t),i()})}function Lt(e,t,r,n,i){(r>0||n<t.length)&&(t=t.substring(r,n)),e.appendBinary(t),i()}function Nt(e,t){function r(){Vi(i)}function n(){var e=Pt(l.end(!0));t(e),l.destroy()}function i(){var t=c*s,i=t+s;++c<u?f(l,e,t,i,r):f(l,e,t,i,n)}var o="string"==typeof e,a=o?e.length:e.size,s=Math.min(Gi,a),u=Math.ceil(a/s),c=0,l=o?new ri:new ri.ArrayBuffer,f=o?Lt:It;i()}function Mt(e){return ri.hash(e)}function qt(e){try{return Ui(e)}catch(e){return{error:O(_i,"Attachment is not a valid base64 string")}}}function $t(e,t,r){var n=qt(e.data);if(n.error)return r(n.error);e.length=n.length,e.data="blob"===t?Dt(n,e.content_type):"base64"===t?zi(n):n,Nt(n,function(t){e.digest="md5-"+t,r()})}function Wt(e,t,r){Nt(e.data,function(n){e.digest="md5-"+n,e.length=e.data.size||e.data.length||0,"binary"===t?jt(e.data,function(t){e.data=t,r()}):"base64"===t?Rt(e.data,function(t){e.data=t,r()}):r()})}function Ut(e,t,r){if(e.stub)return r();"string"==typeof e.data?$t(e,t,r):Wt(e,t,r)}function zt(e,t,r){function n(){o++,e.length===o&&(i?r(i):r())}if(!e.length)return r();var i,o=0;e.forEach(function(e){var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[],o=0;if(!r.length)return n();for(var a in e.data._attachments)e.data._attachments.hasOwnProperty(a)&&Ut(e.data._attachments[a],t,function(e){i=e,++o===r.length&&n()})})}function Vt(e,t,r,n,i,o,a,s){if(se(t.rev_tree,r.metadata.rev))return n[i]=r,o();var u=t.winningRev||V(t),c="deleted"in t?t.deleted:ce(t,u),l="deleted"in r.metadata?r.metadata.deleted:ce(r.metadata),f=/^1-/.test(r.metadata.rev);if(c&&!l&&s&&f){var p=r.data;p._rev=u,p._id=r.metadata.id,r=Et(p,s)}var d=ae(t.rev_tree,r.metadata.rev_tree[0],e);if(s&&(c&&l&&"new_leaf"!==d.conflicts||!c&&"new_leaf"!==d.conflicts||c&&!l&&"new_branch"===d.conflicts)){var h=O(mi);return n[i]=h,o()}var m=r.metadata.rev;r.metadata.rev_tree=d.tree,r.stemmedRevs=d.stemmedRevs||[],t.rev_map&&(r.metadata.rev_map=t.rev_map);var v=V(r.metadata),y=ce(r.metadata,v),g=c===y?0:c<y?-1:1;a(r,v,y,m===v?y:ce(r.metadata,m),!0,g,i,o)}function Gt(e){return"missing"===e.metadata.rev_tree[0].ids[1].status}function Ht(e,t,r,n,i,o,a,s,u){function c(e,t,r){var n=V(e.metadata),i=ce(e.metadata,n);if("was_delete"in s&&i)return o[t]=O(hi,"deleted"),r();if(f&&Gt(e)){var u=O(mi);return o[t]=u,r()}a(e,n,i,i,!1,i?0:1,t,r)}function l(){++d===h&&u&&u()}e=e||1e3;var f=s.new_edits,p=new ui,d=0,h=t.length;t.forEach(function(e,t){if(e._id&&le(e._id)){var n=e._deleted?"_removeLocal":"_putLocal";r[n](e,{ctx:i},function(e,r){o[t]=e||r,l()})}else{var a=e.metadata.id;p.has(a)?(h--,p.get(a).push([e,t])):p.set(a,[[e,t]])}}),p.forEach(function(t,r){function i(){++u<t.length?s():l()}function s(){var s=t[u],l=s[0],p=s[1];if(n.has(r))Vt(e,n.get(r),l,o,p,i,a,f);else{var d=ae([],l.metadata.rev_tree[0],e);l.metadata.rev_tree=d.tree,l.stemmedRevs=d.stemmedRevs||[],c(l,p,i)}}var u=0;s()})}function Jt(e){try{return JSON.parse(e)}catch(t){return ni.parse(e)}}function Kt(e){try{return JSON.stringify(e)}catch(t){return ni.stringify(e)}}function Qt(e){return function(t){var r="unknown_error";t.target&&t.target.error&&(r=t.target.error.name||t.target.error.message),e(O(Si,r,t.type))}}function Yt(e,t,r){return{data:Kt(e),winningRev:t,deletedOrLocal:r?"1":"0",seq:e.seq,id:e.id}}function Xt(e){if(!e)return null;var t=Jt(e.data);return t.winningRev=e.winningRev,t.deleted="1"===e.deletedOrLocal,t.seq=e.seq,t}function Zt(e){if(!e)return e;var t=e._doc_id_rev.lastIndexOf(":");return e._id=e._doc_id_rev.substring(0,t-1),e._rev=e._doc_id_rev.substring(t+1),delete e._doc_id_rev,e}function er(e,t,r,n){r?n(e?"string"!=typeof e?e:Ct(e,t):St([""],{type:t})):e?"string"!=typeof e?Ot(e,function(e){n(zi(e))}):n(e):n("")}function tr(e,t,r,n){function i(){++s===a.length&&n&&n()}function o(e,t){var n=e._attachments[t],o=n.digest;r.objectStore(Qi).get(o).onsuccess=function(e){n.body=e.target.result.body,i()}}var a=Object.keys(e._attachments||{});if(!a.length)return n&&n();var s=0;a.forEach(function(r){t.attachments&&t.include_docs?o(e,r):(e._attachments[r].stub=!0,i())})}function rr(e,t){return ii.all(e.map(function(e){if(e.doc&&e.doc._attachments){var r=Object.keys(e.doc._attachments);return ii.all(r.map(function(r){var n=e.doc._attachments[r];if("body"in n){var i=n.body,o=n.content_type;return new ii(function(a){er(i,o,t,function(t){e.doc._attachments[r]=pi(y(n,["digest","content_type"]),{data:t}),a()})})}}))}}))}function nr(e,t,r){function n(){--c||i()}function i(){o.length&&o.forEach(function(e){u.index("digestSeq").count(IDBKeyRange.bound(e+"::",e+"::",!1,!1)).onsuccess=function(t){t.target.result||s.delete(e)}})}var o=[],a=r.objectStore(Ki),s=r.objectStore(Qi),u=r.objectStore(Yi),c=e.length;e.forEach(function(e){var r=a.index("_doc_id_rev"),i=t+"::"+e;r.getKey(i).onsuccess=function(e){var t=e.target.result;if("number"!=typeof t)return n();a.delete(t),u.index("seq").openCursor(IDBKeyRange.only(t)).onsuccess=function(e){var t=e.target.result;if(t){var r=t.value.digestSeq.split("::")[0];o.push(r),u.delete(t.primaryKey),t.continue()}else n()}}})}function ir(e,t,r){try{return{txn:e.transaction(t,r)}}catch(e){return{error:e}}}function or(e,t,r,n,i,o){function a(){var e=ir(i,[Ji,Ki,Qi,Zi,Yi,Xi],"readwrite");if(e.error)return o(e.error);(b=e.txn).onabort=Qt(o),b.ontimeout=Qt(o),b.oncomplete=f,_=b.objectStore(Ji),x=b.objectStore(Ki),w=b.objectStore(Qi),k=b.objectStore(Yi),(E=b.objectStore(Xi)).get(Xi).onsuccess=function(e){A=e.target.result,c()},d(function(e){if(e)return I=!0,o(e);l()})}function s(){R=!0,c()}function u(){Ht(e.revs_limit,D,n,T,b,P,h,r,s)}function c(){A&&R&&(A.docCount+=B,E.put(A))}function l(){function e(){++t===D.length&&u()}if(D.length)for(var t=0,r=0,n=D.length;r<n;r++){var i=D[r];i._id&&le(i._id)?e():_.get(i.metadata.id).onsuccess=function(t){var r=Xt(t.target.result);r&&T.set(r.id,r),e()}}}function f(){I||(to.notify(n._meta.name),o(null,P))}function p(e,t){w.get(e).onsuccess=function(r){if(r.target.result)t();else{var n=O(Ci,"unknown stub attachment with digest "+e);n.status=412,t(n)}}}function d(e){function t(){++i===r.length&&e(n)}var r=[];if(D.forEach(function(e){e.data&&e.data._attachments&&Object.keys(e.data._attachments).forEach(function(t){var n=e.data._attachments[t];n.stub&&r.push(n.digest)})}),!r.length)return e();var n,i=0;r.forEach(function(e){p(e,function(e){e&&!n&&(n=e),t()})})}function h(e,t,r,n,i,o,a,s){e.metadata.winningRev=t,e.metadata.deleted=r;var u=e.data;if(u._id=e.metadata.id,u._rev=e.metadata.rev,n&&(u._deleted=!0),u._attachments&&Object.keys(u._attachments).length)return v(e,t,r,i,a,s);B+=o,c(),m(e,t,r,i,a,s)}function m(e,t,r,i,o,a){function s(o){var a=e.stemmedRevs||[];i&&n.auto_compaction&&(a=a.concat(Q(e.metadata))),a&&a.length&&nr(a,e.metadata.id,b),l.seq=o.target.result;var s=Yt(l,t,r);_.put(s).onsuccess=u}function u(){P[o]={ok:!0,id:l.id,rev:l.rev},T.set(e.metadata.id,e.metadata),y(e,l.seq,a)}var c=e.data,l=e.metadata;c._doc_id_rev=l.id+"::"+l.rev,delete c._id,delete c._rev;var f=x.put(c);f.onsuccess=s,f.onerror=function(e){e.preventDefault(),e.stopPropagation(),x.index("_doc_id_rev").getKey(c._doc_id_rev).onsuccess=function(e){x.put(c,e.target.result).onsuccess=s}}}function v(e,t,r,n,i,o){function a(){c===l.length&&m(e,t,r,n,i,o)}function s(){c++,a()}var u=e.data,c=0,l=Object.keys(u._attachments);l.forEach(function(r){var n=e.data._attachments[r];if(n.stub)c++,a();else{var i=n.data;delete n.data,n.revpos=parseInt(t,10),g(n.digest,i,s)}})}function y(e,t,r){function n(){++i===o.length&&r()}var i=0,o=Object.keys(e.data._attachments||{});if(!o.length)return r();for(var a=0;a<o.length;a++)!function(r){var i=e.data._attachments[r].digest,o=k.put({seq:t,digestSeq:i+"::"+t});o.onsuccess=n,o.onerror=function(e){e.preventDefault(),e.stopPropagation(),n()}}(o[a])}function g(e,t,r){w.count(e).onsuccess=function(n){if(n.target.result)return r();var i={digest:e,body:t};w.put(i).onsuccess=r}}for(var b,_,x,w,k,E,S,A,D=t.docs,C=0,F=D.length;C<F;C++){var j=D[C];j._id&&le(j._id)||(j=D[C]=Et(j,r.new_edits)).error&&!S&&(S=j)}if(S)return o(S);var R=!1,B=0,P=new Array(D.length),T=new ui,I=!1,L=n._meta.blobSupport?"blob":"base64";zt(D,L,function(e){if(e)return o(e);a()})}function ar(e,t,r,n,i){function o(e){c=e.target.result,u&&i(u,c,l)}function a(e){u=e.target.result,c&&i(u,c,l)}function s(e){var t=e.target.result;if(!t)return i();i([t.key],[t.value],t)}var u,c,l;"function"==typeof e.getAll&&"function"==typeof e.getAllKeys&&n>1&&!r?(l={continue:function(){if(!u.length)return i();var r,s=u[u.length-1];if(t&&t.upper)try{r=IDBKeyRange.bound(s,t.upper,!0,t.upperOpen)}catch(e){if("DataError"===e.name&&0===e.code)return i()}else r=IDBKeyRange.lowerBound(s,!0);t=r,u=null,c=null,e.getAll(t,n).onsuccess=o,e.getAllKeys(t,n).onsuccess=a}},e.getAll(t,n).onsuccess=o,e.getAllKeys(t,n).onsuccess=a):r?e.openCursor(t,"prev").onsuccess=s:e.openCursor(t).onsuccess=s}function sr(e,t,r){if("function"!=typeof e.getAll){var n=[];e.openCursor(t).onsuccess=function(e){var t=e.target.result;t?(n.push(t.value),t.continue()):r({target:{result:n}})}}else e.getAll(t).onsuccess=r}function ur(e,t,r,n,i){try{if(e&&t)return i?IDBKeyRange.bound(t,e,!r,!1):IDBKeyRange.bound(e,t,!1,!r);if(e)return i?IDBKeyRange.upperBound(e):IDBKeyRange.lowerBound(e);if(t)return i?IDBKeyRange.lowerBound(t,!r):IDBKeyRange.upperBound(t,!r);if(n)return IDBKeyRange.only(n)}catch(e){return{error:e}}return null}function cr(e,t,r){function n(t,r,n){var i=t.id+"::"+n;x.get(i).onsuccess=function(n){if(r.doc=Zt(n.target.result),e.conflicts){var i=K(t);i.length&&(r.doc._conflicts=i)}tr(r.doc,e,v)}}function i(t,r){var i={id:r.id,key:r.id,value:{rev:t}},o=r.deleted;"ok"===e.deleted?(w.push(i),o?(i.value.deleted=!0,i.doc=null):e.include_docs&&n(r,i,t)):!o&&l--<=0&&(w.push(i),e.include_docs&&n(r,i,t))}function o(e){for(var t=0,r=e.length;t<r&&w.length!==f;t++){var n=Xt(e[t]);i(n.winningRev,n)}}function a(){r(null,{total_rows:y,offset:e.skip,rows:w})}var s="startkey"in e&&e.startkey,u="endkey"in e&&e.endkey,c="key"in e&&e.key,l=e.skip||0,f="number"==typeof e.limit?e.limit:-1,p=ur(s,u,!1!==e.inclusive_end,c,e.descending),d=p&&p.error;if(d&&("DataError"!==d.name||0!==d.code))return r(O(Si,d.name,d.message));var h=[Ji,Ki,Xi];e.attachments&&h.push(Qi);var m=ir(t,h,"readonly");if(m.error)return r(m.error);var v=m.txn;v.oncomplete=function(){e.attachments?rr(w,e.binary).then(a):a()},v.onabort=Qt(r);var y,g=v.objectStore(Ji),b=v.objectStore(Ki),_=v.objectStore(Xi),x=b.index("_doc_id_rev"),w=[];return _.get(Xi).onsuccess=function(e){y=e.target.result.docCount},d||0===f?void 0:-1===f?sr(g,p,function(t){var r=t.target.result;e.descending&&(r=r.reverse()),o(r)}):void ar(g,p,e.descending,f+l,function(e,t,r){r&&(o(t),w.length<f&&r.continue())})}function lr(e){return new ii(function(t){var r=St([""]);e.objectStore(eo).put(r,"key").onsuccess=function(){var e=navigator.userAgent.match(/Chrome\/(\d+)/),r=navigator.userAgent.match(/Edge\//);t(r||!e||parseInt(e[1],10)>=43)},e.onabort=function(e){e.preventDefault(),e.stopPropagation(),t(!1)}}).catch(function(){return!1})}function fr(e,t){e.objectStore(Ji).index("deletedOrLocal").count(IDBKeyRange.only("0")).onsuccess=function(e){t(e.target.result)}}function pr(e,t,r,n){try{e(t,r)}catch(t){n.emit("error",t)}}function dr(){!ro&&no.length&&(ro=!0,no.shift()())}function hr(e,t,r){no.push(function(){e(function(e,n){pr(t,e,n,r),ro=!1,Zn(function(){dr(r)})})}),dr()}function mr(e,t,r,n){function i(e,t,r,n){if(r.seq!==t)return n();if(r.winningRev===e._rev)return n(r,e);var i=e._id+"::"+r.winningRev;v.get(i).onsuccess=function(e){n(r,Zt(e.target.result))}}function o(e,t,r){if(c&&!c.has(e._id))return r();var n=_.get(e._id);if(n)return i(e,t,n,r);m.get(e._id).onsuccess=function(o){n=Xt(o.target.result),_.set(e._id,n),i(e,t,n,r)}}function a(){e.complete(null,{results:y,last_seq:l})}if((e=u(e)).continuous){var s=r+":"+Bi();return to.addListener(r,s,t,e),to.notify(r),{cancel:function(){to.removeListener(r,s)}}}var c=e.doc_ids&&new si(e.doc_ids);e.since=e.since||0;var l=e.since,f="limit"in e?e.limit:-1;0===f&&(f=1);var p;p="return_docs"in e?e.return_docs:!("returnDocs"in e)||e.returnDocs;var d,h,m,v,y=[],g=0,b=B(e),_=new ui,x=[Ji,Ki];e.attachments&&x.push(Qi);var w=ir(n,x,"readonly");if(w.error)return e.complete(w.error);(d=w.txn).onabort=Qt(e.complete),d.oncomplete=function(){!e.continuous&&e.attachments?rr(y).then(a):a()},h=d.objectStore(Ki),m=d.objectStore(Ji),v=h.index("_doc_id_rev"),ar(h,e.since&&!e.descending?IDBKeyRange.lowerBound(e.since,!0):null,e.descending,f,function(t,r,n){function i(t,r){var n=e.processChange(r,t,e);l=n.seq=t.seq;var i=b(n);if("object"==typeof i)return e.complete(i);i&&(g++,p&&y.push(n),e.attachments&&e.include_docs?tr(r,e,d,function(){rr([n],e.binary).then(function(){e.onChange(n)})}):e.onChange(n))}function a(){for(var e=0,t=s.length;e<t&&g!==f;e++){var r=s[e];r&&i(u[e],r)}g!==f&&n.continue()}if(n&&t.length){var s=new Array(t.length),u=new Array(t.length),c=0;r.forEach(function(e,r){o(Zt(e),t[r],function(e,n){u[r]=e,s[r]=n,++c===t.length&&a()})})}})}function vr(e,t){var r=this;hr(function(t){yr(r,e,t)},t,r.constructor)}function yr(e,t,r){function n(e){var t=e.createObjectStore(Ji,{keyPath:"id"});e.createObjectStore(Ki,{autoIncrement:!0}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0}),e.createObjectStore(Qi,{keyPath:"digest"}),e.createObjectStore(Xi,{keyPath:"id",autoIncrement:!1}),e.createObjectStore(eo),t.createIndex("deletedOrLocal","deletedOrLocal",{unique:!1}),e.createObjectStore(Zi,{keyPath:"_id"});var r=e.createObjectStore(Yi,{autoIncrement:!0});r.createIndex("seq","seq"),r.createIndex("digestSeq","digestSeq",{unique:!0})}function i(e,t){var r=e.objectStore(Ji);r.createIndex("deletedOrLocal","deletedOrLocal",{unique:!1}),r.openCursor().onsuccess=function(e){var n=e.target.result;if(n){var i=n.value,o=ce(i);i.deletedOrLocal=o?"1":"0",r.put(i),n.continue()}else t()}}function o(e){e.createObjectStore(Zi,{keyPath:"_id"}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0})}function a(e,t){var r=e.objectStore(Zi),n=e.objectStore(Ji),i=e.objectStore(Ki);n.openCursor().onsuccess=function(e){var o=e.target.result;if(o){var a=o.value,s=a.id,u=le(s),c=V(a);if(u){var l=s+"::"+c,f=s+"::",p=s+"::~",d=i.index("_doc_id_rev"),h=IDBKeyRange.bound(f,p,!1,!1),m=d.openCursor(h);m.onsuccess=function(e){if(m=e.target.result){var t=m.value;t._doc_id_rev===l&&r.put(t),i.delete(m.primaryKey),m.continue()}else n.delete(o.primaryKey),o.continue()}}else o.continue()}else t&&t()}}function s(e){var t=e.createObjectStore(Yi,{autoIncrement:!0});t.createIndex("seq","seq"),t.createIndex("digestSeq","digestSeq",{unique:!0})}function u(e,t){var r=e.objectStore(Ki),n=e.objectStore(Qi),i=e.objectStore(Yi);n.count().onsuccess=function(e){if(!e.target.result)return t();r.openCursor().onsuccess=function(e){var r=e.target.result;if(!r)return t();for(var n=r.value,o=r.primaryKey,a=Object.keys(n._attachments||{}),s={},u=0;u<a.length;u++)s[n._attachments[a[u]].digest]=!0;var c=Object.keys(s);for(u=0;u<c.length;u++){var l=c[u];i.put({seq:o,digestSeq:l+"::"+o})}r.continue()}}}function c(e){function t(e){return e.data?Xt(e):(e.deleted="1"===e.deletedOrLocal,e)}var r=e.objectStore(Ki),n=e.objectStore(Ji);n.openCursor().onsuccess=function(e){function i(){var e=Yt(a,a.winningRev,a.deleted);n.put(e).onsuccess=function(){o.continue()}}var o=e.target.result;if(o){var a=t(o.value);if(a.winningRev=a.winningRev||V(a),a.seq)return i();!function(){var e=a.id+"::",t=a.id+"::",n=0;r.index("_doc_id_rev").openCursor(IDBKeyRange.bound(e,t)).onsuccess=function(e){var t=e.target.result;if(!t)return a.seq=n,i();var r=t.primaryKey;r>n&&(n=r),t.continue()}}()}}}var f=t.name,p=null;e._meta=null,e._remote=!1,e.type=function(){return"idb"},e._id=l(function(t){t(null,e._meta.instanceId)}),e._bulkDocs=function(r,n,i){or(t,r,n,e,p,i)},e._get=function(e,t,r){function n(){r(a,{doc:i,metadata:o,ctx:s})}var i,o,a,s=t.ctx;if(!s){var u=ir(p,[Ji,Ki,Qi],"readonly");if(u.error)return r(u.error);s=u.txn}s.objectStore(Ji).get(e).onsuccess=function(e){if(!(o=Xt(e.target.result)))return a=O(hi,"missing"),n();var r;if(t.rev)r=t.latest?fe(t.rev,o):t.rev;else if(r=o.winningRev,ce(o))return a=O(hi,"deleted"),n();var u=s.objectStore(Ki),c=o.id+"::"+r;u.index("_doc_id_rev").get(c).onsuccess=function(e){if((i=e.target.result)&&(i=Zt(i)),!i)return a=O(hi,"missing"),n();n()}}},e._getAttachment=function(e,t,r,n,i){var o;if(n.ctx)o=n.ctx;else{var a=ir(p,[Ji,Ki,Qi],"readonly");if(a.error)return i(a.error);o=a.txn}var s=r.digest,u=r.content_type;o.objectStore(Qi).get(s).onsuccess=function(e){er(e.target.result.body,u,n.binary,function(e){i(null,e)})}},e._info=function(t){var r,n,i=ir(p,[Xi,Ki],"readonly");if(i.error)return t(i.error);var o=i.txn;o.objectStore(Xi).get(Xi).onsuccess=function(e){n=e.target.result.docCount},o.objectStore(Ki).openCursor(null,"prev").onsuccess=function(e){var t=e.target.result;r=t?t.key:0},o.oncomplete=function(){t(null,{doc_count:n,update_seq:r,idb_attachment_format:e._meta.blobSupport?"binary":"base64"})}},e._allDocs=function(e,t){cr(e,p,t)},e._changes=function(t){return mr(t,e,f,p)},e._close=function(e){p.close(),io.delete(f),e()},e._getRevisionTree=function(e,t){var r=ir(p,[Ji],"readonly");if(r.error)return t(r.error);r.txn.objectStore(Ji).get(e).onsuccess=function(e){var r=Xt(e.target.result);r?t(null,r.rev_tree):t(O(hi))}},e._doCompaction=function(e,t,r){var n=ir(p,[Ji,Ki,Qi,Yi],"readwrite");if(n.error)return r(n.error);var i=n.txn;i.objectStore(Ji).get(e).onsuccess=function(r){var n=Xt(r.target.result);G(n.rev_tree,function(e,r,n,i,o){var a=r+"-"+n;-1!==t.indexOf(a)&&(o.status="missing")}),nr(t,e,i);var o=n.winningRev,a=n.deleted;i.objectStore(Ji).put(Yt(n,o,a))},i.onabort=Qt(r),i.oncomplete=function(){r()}},e._getLocal=function(e,t){var r=ir(p,[Zi],"readonly");if(r.error)return t(r.error);var n=r.txn.objectStore(Zi).get(e);n.onerror=Qt(t),n.onsuccess=function(e){var r=e.target.result;r?(delete r._doc_id_rev,t(null,r)):t(O(hi))}},e._putLocal=function(e,t,r){"function"==typeof t&&(r=t,t={}),delete e._revisions;var n=e._rev,i=e._id;e._rev=n?"0-"+(parseInt(n.split("-")[1],10)+1):"0-1";var o,a=t.ctx;if(!a){var s=ir(p,[Zi],"readwrite");if(s.error)return r(s.error);(a=s.txn).onerror=Qt(r),a.oncomplete=function(){o&&r(null,o)}}var u,c=a.objectStore(Zi);n?(u=c.get(i)).onsuccess=function(i){var a=i.target.result;a&&a._rev===n?c.put(e).onsuccess=function(){o={ok:!0,id:e._id,rev:e._rev},t.ctx&&r(null,o)}:r(O(mi))}:((u=c.add(e)).onerror=function(e){r(O(mi)),e.preventDefault(),e.stopPropagation()},u.onsuccess=function(){o={ok:!0,id:e._id,rev:e._rev},t.ctx&&r(null,o)})},e._removeLocal=function(e,t,r){"function"==typeof t&&(r=t,t={});var n=t.ctx;if(!n){var i=ir(p,[Zi],"readwrite");if(i.error)return r(i.error);(n=i.txn).oncomplete=function(){o&&r(null,o)}}var o,a=e._id,s=n.objectStore(Zi),u=s.get(a);u.onerror=Qt(r),u.onsuccess=function(n){var i=n.target.result;i&&i._rev===e._rev?(s.delete(a),o={ok:!0,id:a,rev:"0-0"},t.ctx&&r(null,o)):r(O(hi))}},e._destroy=function(e,t){to.removeAllListeners(f);var r=oo.get(f);r&&r.result&&(r.result.close(),io.delete(f));var n=indexedDB.deleteDatabase(f);n.onsuccess=function(){oo.delete(f),w()&&f in localStorage&&delete localStorage[f],t(null,{ok:!0})},n.onerror=Qt(t)};var d=io.get(f);if(d)return p=d.idb,e._meta=d.global,Zn(function(){r(null,e)});var h;h=t.storage?gr(f,t.storage):indexedDB.open(f,Hi),oo.set(f,h),h.onupgradeneeded=function(e){function t(){var e=f[p-1];p++,e&&e(l,t)}var r=e.target.result;if(e.oldVersion<1)return n(r);var l=e.currentTarget.transaction;e.oldVersion<3&&o(r),e.oldVersion<4&&s(r);var f=[i,a,u,c],p=e.oldVersion;t()},h.onsuccess=function(t){function n(){void 0!==s&&l&&(e._meta={name:f,instanceId:u,blobSupport:s},io.set(f,{idb:p,global:e._meta}),r(null,e))}function i(){if(void 0!==a&&void 0!==o){var e=f+"_id";e in o?u=o[e]:o[e]=u=Bi(),o.docCount=a,c.objectStore(Xi).put(o)}}(p=t.target.result).onversionchange=function(){p.close(),io.delete(f)},p.onabort=function(e){S("error","Database has a global failure",e.target.error),p.close(),io.delete(f)};var o,a,s,u,c=p.transaction([Xi,eo,Ji],"readwrite"),l=!1;c.objectStore(Xi).get(Xi).onsuccess=function(e){o=e.target.result||{id:Xi},i()},fr(c,function(e){a=e,i()}),qi||(qi=lr(c)),qi.then(function(e){s=e,n()}),c.oncomplete=function(){l=!0,n()}},h.onerror=function(){var e="Failed to open indexedDB, are you in private browsing mode?";S("error",e),r(O(Si,e))}}function gr(e,t){try{return indexedDB.open(e,{version:Hi,storage:t})}catch(t){return indexedDB.open(e,Hi)}}function br(e){return decodeURIComponent(escape(e))}function _r(e){return e<65?e-48:e-55}function xr(e,t,r){for(var n="";t<r;)n+=String.fromCharCode(_r(e.charCodeAt(t++))<<4|_r(e.charCodeAt(t++)));return n}function wr(e,t,r){for(var n="";t<r;)n+=String.fromCharCode(_r(e.charCodeAt(t+2))<<12|_r(e.charCodeAt(t+3))<<8|_r(e.charCodeAt(t))<<4|_r(e.charCodeAt(t+1))),t+=4;return n}function kr(e,t){return"UTF-8"===t?br(xr(e,0,e.length)):wr(e,0,e.length)}function Er(e){return"'"+e+"'"}function Sr(e){return e.replace(/\u0002/g,"").replace(/\u0001/g,"").replace(/\u0000/g,"")}function Ar(e){return e.replace(/\u0001\u0001/g,"\0").replace(/\u0001\u0002/g,"").replace(/\u0002\u0002/g,"")}function Dr(e){return delete e._id,delete e._rev,JSON.stringify(e)}function Cr(e,t,r){return e=JSON.parse(e),e._id=t,e._rev=r,e}function Fr(e){for(var t="(";e--;)t+="?",e&&(t+=",");return t+")"}function Or(e,t,r,n,i){return"SELECT "+e+" FROM "+("string"==typeof t?t:t.join(" JOIN "))+(r?" ON "+r:"")+(n?" WHERE "+("string"==typeof n?n:n.join(" AND ")):"")+(i?" ORDER BY "+i:"")}function jr(e,t,r){function n(){++o===e.length&&i()}function i(){if(a.length){var e="SELECT DISTINCT digest AS digest FROM "+po+" WHERE seq IN "+Fr(a.length);r.executeSql(e,a,function(e,t){for(var r=[],n=0;n<t.rows.length;n++)r.push(t.rows.item(n).digest);if(r.length){var i="DELETE FROM "+po+" WHERE seq IN ("+a.map(function(){return"?"}).join(",")+")";e.executeSql(i,a,function(e){var t="SELECT digest FROM "+po+" WHERE digest IN ("+r.map(function(){return"?"}).join(",")+")";e.executeSql(t,r,function(e,t){for(var n=new si,i=0;i<t.rows.length;i++)n.add(t.rows.item(i).digest);r.forEach(function(t){n.has(t)||(e.executeSql("DELETE FROM "+po+" WHERE digest=?",[t]),e.executeSql("DELETE FROM "+co+" WHERE digest=?",[t]))})})})}})}}if(e.length){var o=0,a=[];e.forEach(function(e){var i="SELECT seq FROM "+uo+" WHERE doc_id=? AND rev=?";r.executeSql(i,[t,e],function(e,t){if(!t.rows.length)return n();var r=t.rows.item(0).seq;a.push(r),e.executeSql("DELETE FROM "+uo+" WHERE seq=?",[r],n)})})}}function Rr(e){return function(t){S("error","WebSQL threw an error",t);var r=t&&t.constructor.toString().match(/function ([^(]+)/),n=r&&r[1]||t.type,i=t.target||t.message;e(O(Ai,i,n))}}function Br(e){return"size"in e?1e6*e.size:"undefined"!=typeof navigator&&/Android/.test(navigator.userAgent)?5e6:1}function Pr(e,t,r,n,i,o,a){function s(){if(g)return a(g);o.notify(n._name),a(null,b)}function u(e,t){var r="SELECT count(*) as cnt FROM "+co+" WHERE digest=?";y.executeSql(r,[e],function(r,n){if(0===n.rows.item(0).cnt){var i=O(Ci,"unknown stub attachment with digest "+e);t(i)}else t()})}function c(e){function t(){++i===r.length&&e(n)}var r=[];if(m.forEach(function(e){e.data&&e.data._attachments&&Object.keys(e.data._attachments).forEach(function(t){var n=e.data._attachments[t];n.stub&&r.push(n.digest)})}),!r.length)return e();var n,i=0;r.forEach(function(e){u(e,function(e){e&&!n&&(n=e),t()})})}function l(e,t,r,i,o,a,s,u){function c(){function t(e,t){function n(){return++i===o.length&&t(),!1}var i=0,o=Object.keys(r._attachments||{});if(!o.length)return t();for(var a=0;a<o.length;a++)!function(t){var i="INSERT INTO "+po+" (digest, seq) VALUES (?,?)",o=[r._attachments[t].digest,e];y.executeSql(i,o,n,n)}(o[a])}var r=e.data,n=i?1:0,o=r._id,a=r._rev,s=Dr(r),u="INSERT INTO "+uo+" (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);",c=[o,a,s,n];y.executeSql(u,c,function(e,r){var n=r.insertId;t(n,function(){p(e,n)})},function(){var e=Or("seq",uo,null,"doc_id=? AND rev=?");return y.executeSql(e,[o,a],function(e,r){var i=r.rows.item(0).seq,u="UPDATE "+uo+" SET json=?, deleted=? WHERE doc_id=? AND rev=?;",c=[s,n,o,a];e.executeSql(u,c,function(e){t(i,function(){p(e,i)})})}),!1})}function l(e){h||(e?u(h=e):m===v.length&&c())}function f(e){m++,l(e)}function p(r,i){var a=e.metadata.id,c=e.stemmedRevs||[];o&&n.auto_compaction&&(c=Q(e.metadata).concat(c)),c.length&&jr(c,a,r),e.metadata.seq=i;var l=e.metadata.rev;delete e.metadata.rev;var f=o?"UPDATE "+so+" SET json=?, max_seq=?, winningseq=(SELECT seq FROM "+uo+" WHERE doc_id="+so+".id AND rev=?) WHERE id=?":"INSERT INTO "+so+" (id, winningseq, max_seq, json) VALUES (?,?,?,?);",p=Kt(e.metadata),d=o?[p,i,t,a]:[a,i,i,p];r.executeSql(f,d,function(){b[s]={ok:!0,id:e.metadata.id,rev:l},_.set(a,e.metadata),u()})}var h=null,m=0;e.data._id=e.metadata.id,e.data._rev=e.metadata.rev;var v=Object.keys(e.data._attachments||{});i&&(e.data._deleted=!0),v.forEach(function(r){var n=e.data._attachments[r];if(n.stub)m++,l();else{var i=n.data;delete n.data,n.revpos=parseInt(t,10),d(n.digest,i,f)}}),v.length||c()}function f(){Ht(e.revs_limit,m,n,_,y,b,l,r)}function p(e){function t(){++r===m.length&&e()}if(!m.length)return e();var r=0;m.forEach(function(e){if(e._id&&le(e._id))return t();var r=e.metadata.id;y.executeSql("SELECT json FROM "+so+" WHERE id = ?",[r],function(e,n){if(n.rows.length){var i=Jt(n.rows.item(0).json);_.set(r,i)}t()})})}function d(e,t,r){var n="SELECT digest FROM "+co+" WHERE digest=?";y.executeSql(n,[e],function(i,o){if(o.rows.length)return r();n="INSERT INTO "+co+" (digest, body, escaped) VALUES (?,?,1)",i.executeSql(n,[e,Sr(t)],function(){r()},function(){return r(),!1})})}var h=r.new_edits,m=t.docs.map(function(e){return e._id&&le(e._id)?e:Et(e,h)}),v=m.filter(function(e){return e.error});if(v.length)return a(v[0]);var y,g,b=new Array(m.length),_=new ui;zt(m,"binary",function(e){if(e)return a(e);i.transaction(function(e){y=e,c(function(e){e?g=e:p(f)})},Rr(a),s)})}function Tr(e){return e.websql(e.name,e.version,e.description,e.size)}function Ir(e){try{return{db:Tr(e)}}catch(e){return{error:e}}}function Lr(e){var t=ho.get(e.name);return t||(t=Ir(e),ho.set(e.name,t)),t}function Nr(e,t,r,n,i){function o(){++u===s.length&&i&&i()}function a(e,i){var a=e._attachments[i],s={binary:t.binary,ctx:n};r._getAttachment(e._id,i,a,s,function(t,r){e._attachments[i]=pi(y(a,["digest","content_type"]),{data:r}),o()})}var s=Object.keys(e._attachments||{});if(!s.length)return i&&i();var u=0;s.forEach(function(r){t.attachments&&t.include_docs?a(e,r):(e._attachments[r].stub=!0,o())})}function Mr(e,t){function r(){w()&&(window.localStorage["_pouch__websqldb_"+b._name]=!0),t(null,b)}function n(e,t){e.executeSql(bo),e.executeSql("ALTER TABLE "+uo+" ADD COLUMN deleted TINYINT(1) DEFAULT 0",[],function(){e.executeSql(yo),e.executeSql("ALTER TABLE "+so+" ADD COLUMN local TINYINT(1) DEFAULT 0",[],function(){e.executeSql("CREATE INDEX IF NOT EXISTS 'doc-store-local-idx' ON "+so+" (local, id)");var r="SELECT "+so+".winningseq AS seq, "+so+".json AS metadata FROM "+uo+" JOIN "+so+" ON "+uo+".seq = "+so+".winningseq";e.executeSql(r,[],function(e,r){for(var n=[],i=[],o=0;o<r.rows.length;o++){var a=r.rows.item(o),s=a.seq,u=JSON.parse(a.metadata);ce(u)&&n.push(s),le(u.id)&&i.push(u.id)}e.executeSql("UPDATE "+so+"SET local = 1 WHERE id IN "+Fr(i.length),i,function(){e.executeSql("UPDATE "+uo+" SET deleted = 1 WHERE seq IN "+Fr(n.length),n,t)})})})})}function i(e,t){var r="CREATE TABLE IF NOT EXISTS "+lo+" (id UNIQUE, rev, json)";e.executeSql(r,[],function(){var r="SELECT "+so+".id AS id, "+uo+".json AS data FROM "+uo+" JOIN "+so+" ON "+uo+".seq = "+so+".winningseq WHERE local = 1";e.executeSql(r,[],function(e,r){function n(){if(!i.length)return t(e);var r=i.shift(),o=JSON.parse(r.data)._rev;e.executeSql("INSERT INTO "+lo+" (id, rev, json) VALUES (?,?,?)",[r.id,o,r.data],function(e){e.executeSql("DELETE FROM "+so+" WHERE id=?",[r.id],function(e){e.executeSql("DELETE FROM "+uo+" WHERE seq=?",[r.seq],function(){n()})})})}for(var i=[],o=0;o<r.rows.length;o++)i.push(r.rows.item(o));n()})})}function o(e,t){function r(r){function n(){if(!r.length)return t(e);var i=kr(r.shift().hex,g),o=i.lastIndexOf("::"),a=i.substring(0,o),s=i.substring(o+2),u="UPDATE "+uo+" SET doc_id=?, rev=? WHERE doc_id_rev=?";e.executeSql(u,[a,s,i],function(){n()})}n()}var n="ALTER TABLE "+uo+" ADD COLUMN doc_id";e.executeSql(n,[],function(e){var t="ALTER TABLE "+uo+" ADD COLUMN rev";e.executeSql(t,[],function(e){e.executeSql(go,[],function(e){var t="SELECT hex(doc_id_rev) as hex FROM "+uo;e.executeSql(t,[],function(e,t){for(var n=[],i=0;i<t.rows.length;i++)n.push(t.rows.item(i));r(n)})})})})}function a(e,t){function r(e){var r="SELECT COUNT(*) AS cnt FROM "+co;e.executeSql(r,[],function(e,r){function n(){var r=Or(ko+", "+so+".id AS id",[so,uo],wo,null,so+".id ");r+=" LIMIT "+o+" OFFSET "+i,i+=o,e.executeSql(r,[],function(e,r){if(!r.rows.length)return t(e);for(var i={},o=0;o<r.rows.length;o++)for(var a=r.rows.item(o),s=Cr(a.data,a.id,a.rev),u=Object.keys(s._attachments||{}),c=0;c<u.length;c++)!function(e,t){var r=i[e]=i[e]||[];-1===r.indexOf(t)&&r.push(t)}(s._attachments[u[c]].digest,a.seq);var l=[];if(Object.keys(i).forEach(function(e){i[e].forEach(function(t){l.push([e,t])})}),!l.length)return n();var f=0;l.forEach(function(t){var r="INSERT INTO "+po+" (digest, seq) VALUES (?,?)";e.executeSql(r,t,function(){++f===l.length&&n()})})})}if(!r.rows.item(0).cnt)return t(e);var i=0,o=10;n()})}var n="CREATE TABLE IF NOT EXISTS "+po+" (digest, seq INTEGER)";e.executeSql(n,[],function(e){e.executeSql(xo,[],function(e){e.executeSql(_o,[],r)})})}function s(e,t){var r="ALTER TABLE "+co+" ADD COLUMN escaped TINYINT(1) DEFAULT 0";e.executeSql(r,[],t)}function c(e,t){var r="ALTER TABLE "+so+" ADD COLUMN max_seq INTEGER";e.executeSql(r,[],function(e){var r="UPDATE "+so+" SET max_seq=(SELECT MAX(seq) FROM "+uo+" WHERE doc_id=id)";e.executeSql(r,[],function(e){var r="CREATE UNIQUE INDEX IF NOT EXISTS 'doc-max-seq-idx' ON "+so+" (max_seq)";e.executeSql(r,[],t)})})}function f(e,t){e.executeSql('SELECT HEX("a") AS hex',[],function(e,r){var n=r.rows.item(0).hex;g=2===n.length?"UTF-8":"UTF-16",t()})}function p(){for(;k.length>0;)k.pop()(null,_)}function d(e,t){if(0===t){var r="CREATE TABLE IF NOT EXISTS "+fo+" (dbid, db_version INTEGER)",u="CREATE TABLE IF NOT EXISTS "+co+" (digest UNIQUE, escaped TINYINT(1), body BLOB)",l="CREATE TABLE IF NOT EXISTS "+po+" (digest, seq INTEGER)",f="CREATE TABLE IF NOT EXISTS "+so+" (id unique, json, winningseq, max_seq INTEGER UNIQUE)",d="CREATE TABLE IF NOT EXISTS "+uo+" (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, json, deleted TINYINT(1), doc_id, rev)",h="CREATE TABLE IF NOT EXISTS "+lo+" (id UNIQUE, rev, json)";e.executeSql(u),e.executeSql(h),e.executeSql(l,[],function(){e.executeSql(_o),e.executeSql(xo)}),e.executeSql(f,[],function(){e.executeSql(bo),e.executeSql(d,[],function(){e.executeSql(yo),e.executeSql(go),e.executeSql(r,[],function(){var t="INSERT INTO "+fo+" (db_version, dbid) VALUES (?,?)";_=Bi();var r=[ao,_];e.executeSql(t,r,function(){p()})})})})}else{var m=[n,i,o,a,s,c,function(){t<ao&&e.executeSql("UPDATE "+fo+" SET db_version = "+ao);var r="SELECT dbid FROM "+fo;e.executeSql(r,[],function(e,t){_=t.rows.item(0).dbid,p()})}],v=t,y=function(e){m[v-1](e,y),v++};y(e)}}function h(e){var t="SELECT sql FROM sqlite_master WHERE tbl_name = "+fo;e.executeSql(t,[],function(e,t){t.rows.length?/db_version/.test(t.rows.item(0).sql)?e.executeSql("SELECT db_version FROM "+fo,[],function(e,t){d(e,t.rows.item(0).db_version)}):e.executeSql("ALTER TABLE "+fo+" ADD COLUMN db_version INTEGER",[],function(){d(e,1)}):d(e,0)})}function m(e,t){var r="SELECT MAX(seq) AS seq FROM "+uo;e.executeSql(r,[],function(e,r){var n=r.rows.item(0).seq||0;t(n)})}function v(e,t){var r=Or("COUNT("+so+".id) AS 'num'",[so,uo],wo,uo+".deleted=0");e.executeSql(r,[],function(e,r){t(r.rows.item(0).num)})}function y(e,t,r,n,i){var o=Or(ko,[so,uo],wo,so+".id=?"),a=[t];e.executeSql(o,a,function(e,t){if(!t.rows.length){var o=O(hi,"missing");return i(o)}var a=Jt(t.rows.item(0).metadata);n(fe(r,a))})}var g,b=this,_=null,x=Br(e),k=[];b._name=e.name;var E=Lr(pi({},e,{version:vo,description:e.name,size:x}));if(E.error)return Rr(t)(E.error);var S=E.db;"function"!=typeof S.readTransaction&&(S.readTransaction=S.transaction),S.transaction(function(e){f(e,function(){h(e)})},Rr(t),r),b._remote=!1,b.type=function(){return"websql"},b._id=l(function(e){e(null,_)}),b._info=function(e){var t,r;S.readTransaction(function(e){m(e,function(e){t=e}),v(e,function(e){r=e})},Rr(e),function(){e(null,{doc_count:r,update_seq:t,websql_encoding:g})})},b._bulkDocs=function(t,r,n){Pr(e,t,r,b,S,mo,n)},b._get=function(e,t,r){function n(e){r(e,{doc:i,metadata:o,ctx:a})}var i,o,a=t.ctx;if(!a)return S.readTransaction(function(n){b._get(e,pi({ctx:n},t),r)});var s,u;if(t.rev){if(t.latest)return void y(a,e,t.rev,function(n){t.latest=!1,t.rev=n,b._get(e,t,r)},n);s=Or(ko,[so,uo],so+".id="+uo+".doc_id",[uo+".doc_id=?",uo+".rev=?"]),u=[e,t.rev]}else s=Or(ko,[so,uo],wo,so+".id=?"),u=[e];a.executeSql(s,u,function(e,r){if(!r.rows.length)return n(O(hi,"missing"));var a=r.rows.item(0);if(o=Jt(a.metadata),a.deleted&&!t.rev)return n(O(hi,"deleted"));i=Cr(a.data,o.id,a.rev),n()})},b._allDocs=function(e,t){var r,n=[],i="startkey"in e&&e.startkey,o="endkey"in e&&e.endkey,a="key"in e&&e.key,s="descending"in e&&e.descending,u="limit"in e?e.limit:-1,c="skip"in e?e.skip:0,l=!1!==e.inclusive_end,f=[],p=[];if(!1!==a)p.push(so+".id = ?"),f.push(a);else if(!1!==i||!1!==o){if(!1!==i&&(p.push(so+".id "+(s?"<=":">=")+" ?"),f.push(i)),!1!==o){var d=s?">":"<";l&&(d+="="),p.push(so+".id "+d+" ?"),f.push(o)}!1!==a&&(p.push(so+".id = ?"),f.push(a))}"ok"!==e.deleted&&p.push(uo+".deleted = 0"),S.readTransaction(function(t){if(v(t,function(e){r=e}),0!==u){var i=Or(ko,[so,uo],wo,p,so+".id "+(s?"DESC":"ASC"));i+=" LIMIT "+u+" OFFSET "+c,t.executeSql(i,f,function(t,r){for(var i=0,o=r.rows.length;i<o;i++){var a=r.rows.item(i),s=Jt(a.metadata),u=s.id,c=Cr(a.data,u,a.rev),l=c._rev,f={id:u,key:u,value:{rev:l}};if(e.include_docs){if(f.doc=c,f.doc._rev=l,e.conflicts){var p=K(s);p.length&&(f.doc._conflicts=p)}Nr(f.doc,e,b,t)}if(a.deleted){if("ok"!==e.deleted)continue;f.value.deleted=!0,f.doc=null}n.push(f)}})}},Rr(t),function(){t(null,{total_rows:r,offset:e.skip,rows:n})})},b._changes=function(e){if((e=u(e)).continuous){var t=b._name+":"+Bi();return mo.addListener(b._name,t,b,e),mo.notify(b._name),{cancel:function(){mo.removeListener(b._name,t)}}}var r=e.descending;e.since=e.since&&!r?e.since:0;var n="limit"in e?e.limit:-1;0===n&&(n=1);var i;i="return_docs"in e?e.return_docs:!("returnDocs"in e)||e.returnDocs;var o=[],a=0;!function(){var t=so+".json AS metadata, "+so+".max_seq AS maxSeq, "+uo+".json AS winningDoc, "+uo+".rev AS winningRev ",s=so+" JOIN "+uo,u=so+".id="+uo+".doc_id AND "+so+".winningseq="+uo+".seq",c=["maxSeq > ?"],l=[e.since];e.doc_ids&&(c.push(so+".id IN "+Fr(e.doc_ids.length)),l=l.concat(e.doc_ids));var f=Or(t,s,u,c,"maxSeq "+(r?"DESC":"ASC")),p=B(e);e.view||e.filter||(f+=" LIMIT "+n);var d=e.since||0;S.readTransaction(function(t){t.executeSql(f,l,function(t,r){function s(t){return function(){e.onChange(t)}}for(var u=0,c=r.rows.length;u<c;u++){var l=r.rows.item(u),f=Jt(l.metadata);d=l.maxSeq;var h=Cr(l.winningDoc,f.id,l.winningRev),m=e.processChange(h,f,e);m.seq=l.maxSeq;var v=p(m);if("object"==typeof v)return e.complete(v);if(v&&(a++,i&&o.push(m),e.attachments&&e.include_docs?Nr(h,e,b,t,s(m)):s(m)()),a===n)break}})},Rr(e.complete),function(){e.continuous||e.complete(null,{results:o,last_seq:d})})}()},b._close=function(e){e()},b._getAttachment=function(e,t,r,n,i){var o,a=n.ctx,s=r.digest,u=r.content_type,c="SELECT escaped, CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM "+co+" WHERE digest=?";a.executeSql(c,[s],function(e,t){var r=t.rows.item(0),a=r.escaped?Ar(r.body):kr(r.body,g);o=n.binary?Dt(a,u):zi(a),i(null,o)})},b._getRevisionTree=function(e,t){S.readTransaction(function(r){var n="SELECT json AS metadata FROM "+so+" WHERE id = ?";r.executeSql(n,[e],function(e,r){if(r.rows.length){var n=Jt(r.rows.item(0).metadata);t(null,n.rev_tree)}else t(O(hi))})})},b._doCompaction=function(e,t,r){if(!t.length)return r();S.transaction(function(r){var n="SELECT json AS metadata FROM "+so+" WHERE id = ?";r.executeSql(n,[e],function(r,n){var i=Jt(n.rows.item(0).metadata);G(i.rev_tree,function(e,r,n,i,o){var a=r+"-"+n;-1!==t.indexOf(a)&&(o.status="missing")});var o="UPDATE "+so+" SET json = ? WHERE id = ?";r.executeSql(o,[Kt(i),e])}),jr(t,e,r)},Rr(r),function(){r()})},b._getLocal=function(e,t){S.readTransaction(function(r){var n="SELECT json, rev FROM "+lo+" WHERE id=?";r.executeSql(n,[e],function(r,n){if(n.rows.length){var i=n.rows.item(0),o=Cr(i.json,e,i.rev);t(null,o)}else t(O(hi))})})},b._putLocal=function(e,t,r){function n(e){var n,c;o?(n="UPDATE "+lo+" SET rev=?, json=? WHERE id=? AND rev=?",c=[i,u,a,o]):(n="INSERT INTO "+lo+" (id, rev, json) VALUES (?,?,?)",c=[a,i,u]),e.executeSql(n,c,function(e,n){n.rowsAffected?(s={ok:!0,id:a,rev:i},t.ctx&&r(null,s)):r(O(mi))},function(){return r(O(mi)),!1})}"function"==typeof t&&(r=t,t={}),delete e._revisions;var i,o=e._rev,a=e._id;i=e._rev=o?"0-"+(parseInt(o.split("-")[1],10)+1):"0-1";var s,u=Dr(e);t.ctx?n(t.ctx):S.transaction(n,Rr(r),function(){s&&r(null,s)})},b._removeLocal=function(e,t,r){function n(n){var o="DELETE FROM "+lo+" WHERE id=? AND rev=?",a=[e._id,e._rev];n.executeSql(o,a,function(n,o){if(!o.rowsAffected)return r(O(hi));i={ok:!0,id:e._id,rev:"0-0"},t.ctx&&r(null,i)})}"function"==typeof t&&(r=t,t={});var i;t.ctx?n(t.ctx):S.transaction(n,Rr(r),function(){i&&r(null,i)})},b._destroy=function(e,t){mo.removeAllListeners(b._name),S.transaction(function(e){[so,uo,co,fo,lo,po].forEach(function(t){e.executeSql("DROP TABLE IF EXISTS "+t,[])})},Rr(t),function(){w()&&(delete window.localStorage["_pouch__websqldb_"+b._name],delete window.localStorage[b._name]),t(null,{ok:!0})})}}function qr(){try{return openDatabase("_pouch_validate_websql",1,"",1),!0}catch(e){return!1}}function $r(){if("undefined"==typeof indexedDB||null===indexedDB||!/iP(hone|od|ad)/.test(navigator.userAgent))return!0;var e=w(),t="_pouch__websqldb_valid_"+navigator.userAgent;if(e&&localStorage[t])return"1"===localStorage[t];var r=qr();return e&&(localStorage[t]=r?"1":"0"),r}function Wr(e,t,r,n){return openDatabase(e,t,r,n)}function Ur(e,t){var r=pi({websql:Wr},e);Mr.call(this,r,t)}function zr(){for(var e={},t=new ii(function(t,r){e.resolve=t,e.reject=r}),r=new Array(arguments.length),n=0;n<r.length;n++)r[n]=arguments[n];return e.promise=t,ii.resolve().then(function(){return fetch.apply(null,r)}).then(function(t){e.resolve(t)}).catch(function(t){e.reject(t)}),e}function Vr(e,t){var r,n,i,o=new Headers,a={method:e.method,credentials:"include",headers:o};return e.json&&(o.set("Accept","application/json"),o.set("Content-Type",e.headers["Content-Type"]||"application/json")),e.body&&e.processData&&"string"!=typeof e.body?a.body=JSON.stringify(e.body):a.body="body"in e?e.body:null,Object.keys(e.headers).forEach(function(t){e.headers.hasOwnProperty(t)&&o.set(t,e.headers[t])}),r=zr(e.url,a),e.timeout>0&&(n=setTimeout(function(){r.reject(new Error("Load timeout for resource: "+e.url))},e.timeout)),r.promise.then(function(t){return i={statusCode:t.status},e.timeout>0&&clearTimeout(n),i.statusCode>=200&&i.statusCode<300?e.binary?t.blob():t.text():t.json()}).then(function(e){i.statusCode>=200&&i.statusCode<300?t(null,i,e):(e.status=i.statusCode,t(e))}).catch(function(e){e||(e=new Error("canceled")),t(e)}),{abort:r.reject}}function Gr(e,t){var r,n,i=!1,o=function(){i=!0,r.abort(),s()},a={abort:function(){r.abort(),s()}},s=function(){clearTimeout(n),a.abort=function(){},r&&(r.onprogress=void 0,r.upload&&(r.upload.onprogress=void 0),r.onreadystatechange=void 0,r=void 0)};r=e.xhr?new e.xhr:new XMLHttpRequest;try{r.open(e.method,e.url)}catch(e){return t(new Error(e.name||"Url is invalid"))}r.withCredentials=!("withCredentials"in e)||e.withCredentials,"GET"===e.method?delete e.headers["Content-Type"]:e.json&&(e.headers.Accept="application/json",e.headers["Content-Type"]=e.headers["Content-Type"]||"application/json",e.body&&e.processData&&"string"!=typeof e.body&&(e.body=JSON.stringify(e.body))),e.binary&&(r.responseType="arraybuffer"),"body"in e||(e.body=null);for(var u in e.headers)e.headers.hasOwnProperty(u)&&r.setRequestHeader(u,e.headers[u]);return e.timeout>0&&(n=setTimeout(o,e.timeout),r.onprogress=function(){clearTimeout(n),4!==r.readyState&&(n=setTimeout(o,e.timeout))},void 0!==r.upload&&(r.upload.onprogress=r.onprogress)),r.onreadystatechange=function(){if(4===r.readyState){var n={statusCode:r.status};if(r.status>=200&&r.status<300){var o;o=e.binary?St([r.response||""],{type:r.getResponseHeader("Content-Type")}):r.responseText,t(null,n,o)}else{var a={};if(i)(a=new Error("ETIMEDOUT")).code="ETIMEDOUT";else if("string"==typeof r.response)try{a=JSON.parse(r.response)}catch(e){}a.status=r.status,t(a)}s()}},e.body&&e.body instanceof Blob?Bt(e.body,function(e){r.send(e)}):r.send(e.body),a}function Hr(e,t){return Eo||e.xhr?Gr(e,t):Vr(e,t)}function Jr(){return""}function Kr(e,t){function r(t,r,n){if(!e.binary&&e.json&&"string"==typeof t)try{t=JSON.parse(t)}catch(e){return n(e)}Array.isArray(t)&&(t=t.map(function(e){return e.error||e.missing?j(e):e})),e.binary&&So(t,r),n(null,t,r)}return e=u(e),(e=pi({method:"GET",headers:{},json:!0,processData:!0,timeout:1e4,cache:!1},e)).json&&(e.binary||(e.headers.Accept="application/json"),e.headers["Content-Type"]=e.headers["Content-Type"]||"application/json"),e.binary&&(e.encoding=null,e.json=!1),e.processData||(e.json=!1),Hr(e,function(n,i,o){if(n)return t(j(n));var a,s=i.headers&&i.headers["content-type"],u=o||Jr();if(!e.binary&&(e.json||!e.processData)&&"object"!=typeof u&&(/json/.test(s)||/^[\s]*\{/.test(u)&&/\}[\s]*$/.test(u)))try{u=JSON.parse(u.toString())}catch(e){}i.statusCode>=200&&i.statusCode<300?r(u,i,t):((a=j(u)).status=i.statusCode,t(a))})}function Qr(e,t){var r=navigator&&navigator.userAgent?navigator.userAgent.toLowerCase():"",n=-1!==r.indexOf("safari")&&-1===r.indexOf("chrome"),i=-1!==r.indexOf("msie"),o=-1!==r.indexOf("edge"),a=n||(i||o)&&"GET"===e.method,s=!("cache"in e)||e.cache;if(!/^blob:/.test(e.url)&&(a||!s)){var u=-1!==e.url.indexOf("?");e.url+=(u?"&":"?")+"_nonce="+Date.now()}return Kr(e,t)}function Yr(e,t){return new ii(function(r,n){function i(){l++,e[f++]().then(a,s)}function o(){++p===d?c?n(c):r():u()}function a(){l--,o()}function s(e){l--,c=c||e,o()}function u(){for(;l<t&&f<d;)i()}var c,l=0,f=0,p=0,d=e.length;u()})}function Xr(e){var t=e.doc&&e.doc._attachments;t&&Object.keys(t).forEach(function(e){var r=t[e];r.data=Ct(r.data,r.content_type)})}function Zr(e){return/^_design/.test(e)?"_design/"+encodeURIComponent(e.slice(8)):/^_local/.test(e)?"_local/"+encodeURIComponent(e.slice(7)):encodeURIComponent(e)}function en(e){return e._attachments&&Object.keys(e._attachments)?ii.all(Object.keys(e._attachments).map(function(t){var r=e._attachments[t];if(r.data&&"string"!=typeof r.data)return new ii(function(e){Rt(r.data,e)}).then(function(e){r.data=e})})):ii.resolve()}function tn(e){if(!e.prefix)return!1;var t=q(e.prefix).protocol;return"http"===t||"https"===t}function rn(e,t){if(tn(t)){var r=t.name.substr(t.prefix.length);e=t.prefix+encodeURIComponent(r)}var n=q(e);(n.user||n.password)&&(n.auth={username:n.user,password:n.password});var i=n.path.replace(/(^\/|\/$)/g,"").split("/");return n.db=i.pop(),-1===n.db.indexOf("%")&&(n.db=encodeURIComponent(n.db)),n.path=i.join("/"),n}function nn(e,t){return on(e,e.db+"/"+t)}function on(e,t){var r=e.path?"/":"";return e.protocol+"://"+e.host+(e.port?":"+e.port:"")+"/"+e.path+r+t}function an(e){return"?"+Object.keys(e).map(function(t){return t+"="+encodeURIComponent(e[t])}).join("&")}function sn(e,t){function r(e,t,r){var n=e.ajax||{},i=pi(u(f),n,t),o=u(f.headers||{});return i.headers=pi(o,n.headers,t.headers||{}),s.constructor.listeners("debug").length&&s.constructor.emit("debug",["http",i.method,i.url]),s._ajax(i,r)}function n(e,t){return new ii(function(n,i){r(e,t,function(e,t){if(e)return i(e);n(t)})})}function i(e,t){return p(e,Qn(function(e){o().then(function(){return t.apply(this,e)}).catch(function(t){e.pop()(t)})}))}function o(){return e.skipSetup||e.skip_setup?ii.resolve():v||((v=n({},{method:"GET",url:l}).catch(function(e){return e&&e.status&&404===e.status?(C(404,"PouchDB is just detecting if the remote exists."),n({},{method:"PUT",url:l})):ii.reject(e)}).catch(function(e){return!(!e||!e.status||412!==e.status)||ii.reject(e)})).catch(function(){v=null}),v)}function a(e){return e.split("/").map(encodeURIComponent).join("/")}var s=this,c=rn(e.name,e),l=nn(c,""),f=(e=u(e)).ajax||{};if(e.auth||c.auth){var d=e.auth||c.auth,h=d.username+":"+d.password,m=zi(unescape(encodeURIComponent(h)));f.headers=f.headers||{},f.headers.Authorization="Basic "+m}s._ajax=Qr;var v;Zn(function(){t(null,s)}),s._remote=!0,s.type=function(){return"http"},s.id=i("id",function(e){r({},{method:"GET",url:on(c,"")},function(t,r){var n=r&&r.uuid?r.uuid+c.db:nn(c,"");e(null,n)})}),s.request=i("request",function(e,t){e.url=nn(c,e.url),r({},e,t)}),s.compact=i("compact",function(e,t){"function"==typeof e&&(t=e,e={}),r(e=u(e),{url:nn(c,"_compact"),method:"POST"},function(){function r(){s.info(function(n,i){i&&!i.compact_running?t(null,{ok:!0}):setTimeout(r,e.interval||200)})}r()})}),s.bulkGet=p("bulkGet",function(e,t){function n(t){var n={};e.revs&&(n.revs=!0),e.attachments&&(n.attachments=!0),e.latest&&(n.latest=!0),r(e,{url:nn(c,"_bulk_get"+an(n)),method:"POST",body:{docs:e.docs}},t)}function i(){for(var r=Do,n=Math.ceil(e.docs.length/r),i=0,a=new Array(n),s=0;s<n;s++){var u=y(e,["revs","attachments","latest"]);u.ajax=f,u.docs=e.docs.slice(s*r,Math.min(e.docs.length,(s+1)*r)),_(o,u,function(e){return function(r,o){a[e]=o.results,++i===n&&t(null,{results:P(a)})}}(s))}}var o=this,a=on(c,""),s=Oo[a];"boolean"!=typeof s?n(function(e,r){e?(Oo[a]=!1,C(e.status,"PouchDB is just detecting if the remote supports the _bulk_get API."),i()):(Oo[a]=!0,t(null,r))}):s?n(t):i()}),s._info=function(e){o().then(function(){r({},{method:"GET",url:nn(c,"")},function(t,r){if(t)return e(t);r.host=nn(c,""),e(null,r)})}).catch(e)},s.get=i("get",function(e,t,r){function i(e){function r(r){var o=i[r],s=Zr(e._id)+"/"+a(r)+"?rev="+e._rev;return n(t,{method:"GET",url:nn(c,s),binary:!0}).then(function(e){return t.binary?e:new ii(function(t){Rt(e,t)})}).then(function(e){delete o.stub,delete o.length,o.data=e})}var i=e._attachments,o=i&&Object.keys(i);if(i&&o.length)return Yr(o.map(function(e){return function(){return r(e)}}),5)}function o(e){return Array.isArray(e)?ii.all(e.map(function(e){if(e.ok)return i(e.ok)})):i(e)}"function"==typeof t&&(r=t,t={});var s={};(t=u(t)).revs&&(s.revs=!0),t.revs_info&&(s.revs_info=!0),t.latest&&(s.latest=!0),t.open_revs&&("all"!==t.open_revs&&(t.open_revs=JSON.stringify(t.open_revs)),s.open_revs=t.open_revs),t.rev&&(s.rev=t.rev),t.conflicts&&(s.conflicts=t.conflicts),e=Zr(e);var l={method:"GET",url:nn(c,e+an(s))};n(t,l).then(function(e){return ii.resolve().then(function(){if(t.attachments)return o(e)}).then(function(){r(null,e)})}).catch(function(t){t.docId=e,r(t)})}),s.remove=i("remove",function(e,t,n,i){var o;"string"==typeof t?(o={_id:e,_rev:t},"function"==typeof n&&(i=n,n={})):(o=e,"function"==typeof t?(i=t,n={}):(i=n,n=t));var a=o._rev||n.rev;r(n,{method:"DELETE",url:nn(c,Zr(o._id))+"?rev="+a},i)}),s.getAttachment=i("getAttachment",function(e,t,n,i){"function"==typeof n&&(i=n,n={});var o=n.rev?"?rev="+n.rev:"";r(n,{method:"GET",url:nn(c,Zr(e))+"/"+a(t)+o,binary:!0},i)}),s.removeAttachment=i("removeAttachment",function(e,t,n,i){r({},{method:"DELETE",url:nn(c,Zr(e)+"/"+a(t))+"?rev="+n},i)}),s.putAttachment=i("putAttachment",function(e,t,n,i,o,s){"function"==typeof o&&(s=o,o=i,i=n,n=null);var u=Zr(e)+"/"+a(t),l=nn(c,u);if(n&&(l+="?rev="+n),"string"==typeof i){var p;try{p=Ui(i)}catch(e){return s(O(_i,"Attachment is not a valid base64 string"))}i=p?Dt(p,o):""}r({},{headers:{"Content-Type":o},method:"PUT",url:l,processData:!1,body:i,timeout:f.timeout||6e4},s)}),s._bulkDocs=function(e,t,n){e.new_edits=t.new_edits,o().then(function(){return ii.all(e.docs.map(en))}).then(function(){r(t,{method:"POST",url:nn(c,"_bulk_docs"),timeout:t.timeout,body:e},function(e,t){if(e)return n(e);t.forEach(function(e){e.ok=!0}),n(null,t)})}).catch(n)},s._put=function(e,t,n){o().then(function(){return en(e)}).then(function(){r(t,{method:"PUT",url:nn(c,Zr(e._id)),body:e},function(t,r){if(t)return t.docId=e&&e._id,n(t);n(null,r)})}).catch(n)},s.allDocs=i("allDocs",function(e,t){"function"==typeof e&&(t=e,e={});var r,i={},o="GET";(e=u(e)).conflicts&&(i.conflicts=!0),e.descending&&(i.descending=!0),e.include_docs&&(i.include_docs=!0),e.attachments&&(i.attachments=!0),e.key&&(i.key=JSON.stringify(e.key)),e.start_key&&(e.startkey=e.start_key),e.startkey&&(i.startkey=JSON.stringify(e.startkey)),e.end_key&&(e.endkey=e.end_key),e.endkey&&(i.endkey=JSON.stringify(e.endkey)),void 0!==e.inclusive_end&&(i.inclusive_end=!!e.inclusive_end),void 0!==e.limit&&(i.limit=e.limit),void 0!==e.skip&&(i.skip=e.skip);var a=an(i);void 0!==e.keys&&(o="POST",r={keys:e.keys}),n(e,{method:o,url:nn(c,"_all_docs"+a),body:r}).then(function(r){e.include_docs&&e.attachments&&e.binary&&r.rows.forEach(Xr),t(null,r)}).catch(t)}),s._changes=function(e){var t="batch_size"in e?e.batch_size:Ao;!(e=u(e)).continuous||"heartbeat"in e||(e.heartbeat=Fo);var n="timeout"in e?e.timeout:"timeout"in f?f.timeout:3e4;"timeout"in e&&e.timeout&&n-e.timeout<Co&&(n=e.timeout+Co),"heartbeat"in e&&e.heartbeat&&n-e.heartbeat<Co&&(n=e.heartbeat+Co);var i={};"timeout"in e&&e.timeout&&(i.timeout=e.timeout);var a,s=void 0!==e.limit&&e.limit;a="return_docs"in e?e.return_docs:!("returnDocs"in e)||e.returnDocs;var l=s;if(e.style&&(i.style=e.style),(e.include_docs||e.filter&&"function"==typeof e.filter)&&(i.include_docs=!0),e.attachments&&(i.attachments=!0),e.continuous&&(i.feed="longpoll"),e.conflicts&&(i.conflicts=!0),e.descending&&(i.descending=!0),"heartbeat"in e&&e.heartbeat&&(i.heartbeat=e.heartbeat),e.filter&&"string"==typeof e.filter&&(i.filter=e.filter),e.view&&"string"==typeof e.view&&(i.filter="_view",i.view=e.view),e.query_params&&"object"==typeof e.query_params)for(var p in e.query_params)e.query_params.hasOwnProperty(p)&&(i[p]=e.query_params[p]);var d,h="GET";e.doc_ids?(i.filter="_doc_ids",h="POST",d={doc_ids:e.doc_ids}):e.selector&&(i.filter="_selector",h="POST",d={selector:e.selector});var m,v,y=function(a,u){if(!e.aborted){i.since=a,"object"==typeof i.since&&(i.since=JSON.stringify(i.since)),e.descending?s&&(i.limit=l):i.limit=!s||l>t?t:l;var f={method:h,url:nn(c,"_changes"+an(i)),timeout:n,body:d};v=a,e.aborted||o().then(function(){m=r(e,f,u)}).catch(u)}},g={results:[]},b=function(r,n){if(!e.aborted){var i=0;if(n&&n.results)i=n.results.length,g.last_seq=n.last_seq,{}.query=e.query_params,n.results=n.results.filter(function(t){l--;var r=B(e)(t);return r&&(e.include_docs&&e.attachments&&e.binary&&Xr(t),a&&g.results.push(t),e.onChange(t)),r});else if(r)return e.aborted=!0,void e.complete(r);n&&n.last_seq&&(v=n.last_seq);var o=s&&l<=0||n&&i<t||e.descending;(!e.continuous||s&&l<=0)&&o?e.complete(null,g):Zn(function(){y(v,b)})}};return y(e.since||0,b),{cancel:function(){e.aborted=!0,m&&m.abort()}}},s.revsDiff=i("revsDiff",function(e,t,n){"function"==typeof t&&(n=t,t={}),r(t,{method:"POST",url:nn(c,"_revs_diff"),body:e},n)}),s._close=function(e){e()},s._destroy=function(e,t){r(e,{url:nn(c,""),method:"DELETE"},function(e,r){if(e&&e.status&&404!==e.status)return t(e);t(null,r)})}}function un(e){this.status=400,this.name="query_parse_error",this.message=e,this.error=!0;try{Error.captureStackTrace(this,un)}catch(e){}}function cn(e){this.status=404,this.name="not_found",this.message=e,this.error=!0;try{Error.captureStackTrace(this,cn)}catch(e){}}function ln(e){this.status=500,this.name="invalid_value",this.message=e,this.error=!0;try{Error.captureStackTrace(this,ln)}catch(e){}}function fn(e,t){return t&&e.then(function(e){Zn(function(){t(null,e)})},function(e){Zn(function(){t(e)})}),e}function pn(e){return Qn(function(t){var r=t.pop(),n=e.apply(this,t);return"function"==typeof r&&fn(n,r),n})}function dn(e,t){return e.then(function(e){return t().then(function(){return e})},function(e){return t().then(function(){throw e})})}function hn(e,t){return function(){var r=arguments,n=this;return e.add(function(){return t.apply(n,r)})}}function mn(e){var t=new si(e),r=new Array(t.size),n=-1;return t.forEach(function(e){r[++n]=e}),r}function vn(e){var t=new Array(e.size),r=-1;return e.forEach(function(e,n){t[++r]=n}),t}function yn(e){return new ln("builtin "+e+" function requires map values to be numbers or number arrays")}function gn(e){for(var t=0,r=0,n=e.length;r<n;r++){var i=e[r];if("number"!=typeof i){if(!Array.isArray(i))throw yn("_sum");t="number"==typeof t?[t]:t;for(var o=0,a=i.length;o<a;o++){var s=i[o];if("number"!=typeof s)throw yn("_sum");void 0===t[o]?t.push(s):t[o]+=s}}else"number"==typeof t?t+=i:t[0]+=i}return t}function bn(e,t){return $("return ("+e.replace(/;\s*$/,"")+");",{emit:t,sum:gn,log:jo,isArray:Ro,toJSON:Bo})}function _n(){this.promise=new ii(function(e){e()})}function xn(e){if(!e)return"undefined";switch(typeof e){case"function":case"string":return e.toString();default:return JSON.stringify(e)}}function wn(e,t){return xn(e)+xn(t)+"undefined"}function kn(e,t,r,n,i,o){var a,s=wn(r,n);if(!i&&(a=e._cachedViews=e._cachedViews||{})[s])return a[s];var u=e.info().then(function(u){var c=u.db_name+"-mrview-"+(i?"temp":Mt(s));return W(e,"_local/"+o,function(e){e.views=e.views||{};var r=t;-1===r.indexOf("/")&&(r=t+"/"+t);var n=e.views[r]=e.views[r]||{};if(!n[c])return n[c]=!0,e}).then(function(){return e.registerDependentDatabase(c).then(function(t){var i=t.db;i.auto_compaction=!0;var o={name:c,db:i,sourceDB:e,adapter:e.adapter,mapFun:r,reduceFun:n};return o.db.get("_local/lastSeq").catch(function(e){if(404!==e.status)throw e}).then(function(e){return o.seq=e?e.seq:0,a&&o.db.once("destroyed",function(){delete a[s]}),o})})})});return a&&(a[s]=u),u}function En(e){return-1===e.indexOf("/")?[e,e]:e.split("/")}function Sn(e){return 1===e.length&&/^1-/.test(e[0].rev)}function An(e,t){try{e.emit("error",t)}catch(e){S("error","The user's map/reduce function threw an uncaught error.\nYou can debug this error by doing:\nmyDatabase.on('error', function (err) { debugger; });\nPlease double-check your map/reduce function."),S("error",t)}}function Dn(e){if(/^_sum/.test(e))return Lo._sum;if(/^_count/.test(e))return Lo._count;if(/^_stats/.test(e))return Lo._stats;if(/^_/.test(e))throw new Error(e+" is not a supported reduce function.")}function Cn(e){return/^1-/.test(e)}function Fn(e,t,r){return!e._attachments||!e._attachments[r]||e._attachments[r].digest!==t._attachments[r].digest}function On(e,t){var r=Object.keys(t._attachments);return ii.all(r.map(function(r){return e.getAttachment(t._id,r,{rev:t._rev})}))}function jn(e,t,r){var n=I(t)&&!I(e),i=Object.keys(r._attachments);return n?e.get(r._id).then(function(n){return ii.all(i.map(function(i){return Fn(n,r,i)?t.getAttachment(r._id,i):e.getAttachment(n._id,i)}))}).catch(function(e){if(404!==e.status)throw e;return On(t,r)}):On(t,r)}function Rn(e){var t=[];return Object.keys(e).forEach(function(r){e[r].missing.forEach(function(e){t.push({id:r,rev:e})})}),{docs:t,revs:!0,latest:!0}}function Bn(e,t,r,n){function i(e){return e._attachments&&Object.keys(e._attachments).length>0}function o(e){return e._conflicts&&e._conflicts.length>0}function a(t){return e.allDocs({keys:t,include_docs:!0,conflicts:!0}).then(function(e){if(n.cancelled)throw new Error("cancelled");e.rows.forEach(function(e){e.deleted||!e.doc||!Cn(e.value.rev)||i(e.doc)||o(e.doc)||(e.doc._conflicts&&delete e.doc._conflicts,s.push(e.doc),delete r[e.id])})})}r=u(r);var s=[],c=!0;return ii.resolve().then(function(){var e=Object.keys(r).filter(function(e){var t=r[e].missing;return 1===t.length&&Cn(t[0])});if(e.length>0)return a(e)}).then(function(){var i=Rn(r);if(i.docs.length)return e.bulkGet(i).then(function(r){if(n.cancelled)throw new Error("cancelled");return ii.all(r.results.map(function(r){return ii.all(r.docs.map(function(r){var n=r.ok;return r.error&&(c=!1),n&&n._attachments?jn(t,e,n).then(function(e){var t=Object.keys(n._attachments);return e.forEach(function(e,r){var i=n._attachments[t[r]];delete i.stub,delete i.length,i.data=e}),n}):n}))})).then(function(e){s=s.concat(P(e).filter(Boolean))})})}).then(function(){return{ok:c,docs:s}})}function Pn(e,t,r,n,i){return e.get(t).catch(function(r){if(404===r.status)return"http"!==e.adapter&&"https"!==e.adapter||C(404,"PouchDB is just checking if a remote checkpoint exists."),{session_id:n,_id:t,history:[],replicator:$o,version:qo};throw r}).then(function(o){if(!i.cancelled&&o.last_seq!==r)return o.history=(o.history||[]).filter(function(e){return e.session_id!==n}),o.history.unshift({last_seq:r,session_id:n}),o.history=o.history.slice(0,Wo),o.version=qo,o.replicator=$o,o.session_id=n,o.last_seq=r,e.put(o).catch(function(o){if(409===o.status)return Pn(e,t,r,n,i);throw o})})}function Tn(e,t,r,n,i){this.src=e,this.target=t,this.id=r,this.returnValue=n,this.opts=i}function In(e,t){return e.session_id===t.session_id?{last_seq:e.last_seq,history:e.history}:Ln(e.history,t.history)}function Ln(e,t){var r=e[0],n=e.slice(1),i=t[0],o=t.slice(1);return r&&0!==t.length?Nn(r.session_id,t)?{last_seq:r.last_seq,history:e}:Nn(i.session_id,n)?{last_seq:i.last_seq,history:o}:Ln(n,o):{last_seq:Uo,history:[]}}function Nn(e,t){var r=t[0],n=t.slice(1);return!(!e||0===t.length)&&(e===r.session_id||Nn(e,n))}function Mn(e){return"number"==typeof e.status&&4===Math.floor(e.status/100)}function qn(e,t,r,n){if(!1===e.retry)return t.emit("error",r),void t.removeAllListeners();if("function"!=typeof e.back_off_function&&(e.back_off_function=D),t.emit("requestError",r),"active"===t.state||"pending"===t.state){t.emit("paused",r),t.state="stopped";var i=function(){e.current_back_off=Vo},o=function(){t.removeListener("active",i)};t.once("paused",o),t.once("active",i)}e.current_back_off=e.current_back_off||Vo,e.current_back_off=e.back_off_function(e.current_back_off),setTimeout(n,e.current_back_off)}function $n(e){return Object.keys(e).sort(We).reduce(function(t,r){return t[r]=e[r],t},{})}function Wn(e,t,r){var n=r.doc_ids?r.doc_ids.sort(We):"",i=r.filter?r.filter.toString():"",o="",a="",s="";return r.selector&&(s=JSON.stringify(r.selector)),r.filter&&r.query_params&&(o=JSON.stringify($n(r.query_params))),r.filter&&"_view"===r.filter&&(a=r.view.toString()),ii.all([e.id(),t.id()]).then(function(e){var t=e[0]+e[1]+i+a+o+n+s;return new ii(function(e){Nt(t,e)})}).then(function(e){return"_local/"+(e=e.replace(/\//g,".").replace(/\+/g,"_"))})}function Un(e,t,r,n,i){function o(){return k?ii.resolve():Wn(e,t,r).then(function(i){w=i;var o={};o=!1===r.checkpoint?{writeSourceCheckpoint:!1,writeTargetCheckpoint:!1}:"source"===r.checkpoint?{writeSourceCheckpoint:!0,writeTargetCheckpoint:!1}:"target"===r.checkpoint?{writeSourceCheckpoint:!1,writeTargetCheckpoint:!0}:{writeSourceCheckpoint:!0,writeTargetCheckpoint:!0},k=new Tn(e,t,w,n,o)})}function a(){if(N=[],0!==x.docs.length){var e=x.docs,o={timeout:r.timeout};return t.bulkDocs({docs:e,new_edits:!1},o).then(function(t){if(n.cancelled)throw h(),new Error("cancelled");var r=Object.create(null);t.forEach(function(e){e.error&&(r[e.id]=e)});var o=Object.keys(r).length;i.doc_write_failures+=o,i.docs_written+=e.length-o,e.forEach(function(e){var t=r[e._id];if(t){if(i.errors.push(t),"unauthorized"!==t.name&&"forbidden"!==t.name)throw t;n.emit("denied",u(t))}else N.push(e)})},function(t){throw i.doc_write_failures+=e.length,t})}}function s(){if(x.error)throw new Error("There was a problem getting docs.");i.last_seq=F=x.seq;var e=u(i);return N.length&&(e.docs=N,n.emit("change",e)),A=!0,k.writeCheckpoint(x.seq,M).then(function(){if(A=!1,n.cancelled)throw h(),new Error("cancelled");x=void 0,g()}).catch(function(e){throw _(e),e})}function c(){var e={};return x.changes.forEach(function(t){"_user/"!==t.id&&(e[t.id]=t.changes.map(function(e){return e.rev}))}),t.revsDiff(e).then(function(e){if(n.cancelled)throw h(),new Error("cancelled");x.diffs=e})}function l(){return Bn(e,t,x.diffs,n).then(function(e){x.error=!e.ok,e.docs.forEach(function(e){delete x.diffs[e._id],i.docs_read++,x.docs.push(e)})})}function f(){n.cancelled||x||(0!==E.length?(x=E.shift(),c().then(l).then(a).then(s).then(f).catch(function(e){d("batch processing terminated with error",e)})):p(!0))}function p(e){0!==S.changes.length?(e||D||S.changes.length>=R)&&(E.push(S),S={seq:0,changes:[],docs:[]},"pending"!==n.state&&"stopped"!==n.state||(n.state="active",n.emit("active")),f()):0!==E.length||x||((j&&q.live||D)&&(n.state="pending",n.emit("paused")),D&&h())}function d(e,t){C||(t.message||(t.message=e),i.ok=!1,i.status="aborting",E=[],S={seq:0,changes:[],docs:[]},h(t))}function h(o){C||n.cancelled&&(i.status="cancelled",A)||(i.status=i.status||"complete",i.end_time=new Date,i.last_seq=F,C=!0,o?((o=O(o)).result=i,"unauthorized"===o.name||"forbidden"===o.name?(n.emit("error",o),n.removeAllListeners()):qn(r,n,o,function(){Un(e,t,r,n)})):(n.emit("complete",i),n.removeAllListeners()))}function m(e){if(n.cancelled)return h();B(r)(e)&&(S.seq=e.seq,S.changes.push(e),p(0===E.length&&q.live))}function v(e){if(T=!1,n.cancelled)return h();if(e.results.length>0)q.since=e.last_seq,g(),p(!0);else{var t=function(){j?(q.live=!0,g()):D=!0,p(!0)};x||0!==e.results.length?t():(A=!0,k.writeCheckpoint(e.last_seq,M).then(function(){A=!1,i.last_seq=F=e.last_seq,t()}).catch(_))}}function y(e){if(T=!1,n.cancelled)return h();d("changes rejected",e)}function g(){function t(){o.cancel()}function i(){n.removeListener("cancel",t)}if(!T&&!D&&E.length<P){T=!0,n._changes&&(n.removeListener("cancel",n._abortChanges),n._changes.cancel()),n.once("cancel",t);var o=e.changes(q).on("change",m);o.then(i,i),o.then(v).catch(y),r.retry&&(n._changes=o,n._abortChanges=t)}}function b(){o().then(function(){if(!n.cancelled)return k.getCheckpoint().then(function(e){q={since:F=e,limit:R,batch_size:R,style:"all_docs",doc_ids:I,selector:L,return_docs:!0},r.filter&&("string"!=typeof r.filter?q.include_docs=!0:q.filter=r.filter),"heartbeat"in r&&(q.heartbeat=r.heartbeat),"timeout"in r&&(q.timeout=r.timeout),r.query_params&&(q.query_params=r.query_params),r.view&&(q.view=r.view),g()});h()}).catch(function(e){d("getCheckpoint rejected with ",e)})}function _(e){A=!1,d("writeCheckpoint completed with error",e)}var x,w,k,E=[],S={seq:0,changes:[],docs:[]},A=!1,D=!1,C=!1,F=0,j=r.continuous||r.live||!1,R=r.batch_size||100,P=r.batches_limit||10,T=!1,I=r.doc_ids,L=r.selector,N=[],M=Bi();i=i||{ok:!0,start_time:new Date,docs_read:0,docs_written:0,doc_write_failures:0,errors:[]};var q={};n.ready(e,t),n.cancelled?h():(n._addedListeners||(n.once("cancel",h),"function"==typeof r.complete&&(n.once("error",r.complete),n.once("complete",function(e){r.complete(null,e)})),n._addedListeners=!0),void 0===r.since?b():o().then(function(){return A=!0,k.writeCheckpoint(r.since,M)}).then(function(){A=!1,n.cancelled?h():(F=r.since,b())}).catch(_))}function zn(){Yn.EventEmitter.call(this),this.cancelled=!1,this.state="pending";var e=this,t=new ii(function(t,r){e.once("complete",t),e.once("error",r)});e.then=function(e,r){return t.then(e,r)},e.catch=function(e){return t.catch(e)},e.catch(function(){})}function Vn(e,t){var r=t.PouchConstructor;return"string"==typeof e?new r(e,t):e}function Gn(e,t,r,n){if("function"==typeof r&&(n=r,r={}),void 0===r&&(r={}),r.doc_ids&&!Array.isArray(r.doc_ids))throw O(ki,"`doc_ids` filter parameter is not a list.");r.complete=n,(r=u(r)).continuous=r.continuous||r.live,r.retry="retry"in r&&r.retry,r.PouchConstructor=r.PouchConstructor||this;var i=new zn(r);return Un(Vn(e,r),Vn(t,r),r,i),i}function Hn(e,t,r,n){return"function"==typeof r&&(n=r,r={}),void 0===r&&(r={}),r=u(r),r.PouchConstructor=r.PouchConstructor||this,e=Vn(e,r),t=Vn(t,r),new Jn(e,t,r,n)}function Jn(e,t,r,n){function i(e){h.emit("change",{direction:"pull",change:e})}function o(e){h.emit("change",{direction:"push",change:e})}function a(e){h.emit("denied",{direction:"push",doc:e})}function s(e){h.emit("denied",{direction:"pull",doc:e})}function u(){h.pushPaused=!0,h.pullPaused&&h.emit("paused")}function c(){h.pullPaused=!0,h.pushPaused&&h.emit("paused")}function l(){h.pushPaused=!1,h.pullPaused&&h.emit("active",{direction:"push"})}function f(){h.pullPaused=!1,h.pushPaused&&h.emit("active",{direction:"pull"})}function p(e){return function(t,r){var n="change"===t&&(r===i||r===o),p="denied"===t&&(r===s||r===a),d="paused"===t&&(r===c||r===u),m="active"===t&&(r===f||r===l);(n||p||d||m)&&(t in y||(y[t]={}),y[t][e]=!0,2===Object.keys(y[t]).length&&h.removeAllListeners(t))}}function d(e,t,r){-1==e.listeners(t).indexOf(r)&&e.on(t,r)}var h=this;this.canceled=!1;var m=r.push?pi({},r,r.push):r,v=r.pull?pi({},r,r.pull):r;this.push=Gn(e,t,m),this.pull=Gn(t,e,v),this.pushPaused=!0,this.pullPaused=!0;var y={};r.live&&(this.push.on("complete",h.pull.cancel.bind(h.pull)),this.pull.on("complete",h.push.cancel.bind(h.push))),this.on("newListener",function(e){"change"===e?(d(h.pull,"change",i),d(h.push,"change",o)):"denied"===e?(d(h.pull,"denied",s),d(h.push,"denied",a)):"active"===e?(d(h.pull,"active",f),d(h.push,"active",l)):"paused"===e&&(d(h.pull,"paused",c),d(h.push,"paused",u))}),this.on("removeListener",function(e){"change"===e?(h.pull.removeListener("change",i),h.push.removeListener("change",o)):"denied"===e?(h.pull.removeListener("denied",s),h.push.removeListener("denied",a)):"active"===e?(h.pull.removeListener("active",f),h.push.removeListener("active",l)):"paused"===e&&(h.pull.removeListener("paused",c),h.push.removeListener("paused",u))}),this.pull.on("removeListener",p("pull")),this.push.on("removeListener",p("push"));var g=ii.all([this.push,this.pull]).then(function(e){var t={push:e[0],pull:e[1]};return h.emit("complete",t),n&&n(null,t),h.removeAllListeners(),t},function(e){if(h.cancel(),n?n(e):h.emit("error",e),h.removeAllListeners(),n)throw e});this.then=function(e,t){return g.then(e,t)},this.catch=function(e){return g.catch(e)}}var Kn=n(e(7)),Qn=n(e(1)),Yn=e(4),Xn=n(e(6)),Zn=n(e(5)),ei=n(e(13)),ti=n(e(2)),ri=n(e(10)),ni=n(e(14)),ii="function"==typeof Promise?Promise:Kn,oi=Function.prototype.toString,ai=oi.call(Object);m.prototype.get=function(e){var t=d(e);return this._store[t]},m.prototype.set=function(e,t){var r=d(e);return this._store[r]=t,!0},m.prototype.has=function(e){return d(e)in this._store},m.prototype.delete=function(e){var t=d(e),r=t in this._store;return delete this._store[t],r},m.prototype.forEach=function(e){for(var t=Object.keys(this._store),r=0,n=t.length;r<n;r++){var i=t[r];e(this._store[i],i=h(i))}},Object.defineProperty(m.prototype,"size",{get:function(){return Object.keys(this._store).length}}),v.prototype.add=function(e){return this._store.set(e,!0)},v.prototype.has=function(e){return this._store.has(e)},v.prototype.forEach=function(e){this._store.forEach(function(t,r){e(r)})},Object.defineProperty(v.prototype,"size",{get:function(){return this._store.size}});var si,ui;!function(){if("undefined"==typeof Symbol||"undefined"==typeof Map||"undefined"==typeof Set)return!1;var e=Object.getOwnPropertyDescriptor(Map,Symbol.species);return e&&"get"in e&&Map[Symbol.species]===Map}()?(si=v,ui=m):(si=Set,ui=Map);var ci,li=6;if(x())ci=!1;else try{localStorage.setItem("_pouch_check_localstorage",1),ci=!!localStorage.getItem("_pouch_check_localstorage")}catch(e){ci=!1}Xn(E,Yn.EventEmitter),E.prototype.addListener=function(e,t,r,n){function i(){if(o._listeners[t])if(a)a="waiting";else{a=!0;var e=y(n,["style","include_docs","attachments","conflicts","filter","doc_ids","view","since","query_params","binary"]);r.changes(e).on("change",function(e){e.seq>n.since&&!n.cancelled&&(n.since=e.seq,n.onChange(e))}).on("complete",function(){"waiting"===a&&Zn(i),a=!1}).on("error",function(){a=!1})}}if(!this._listeners[t]){var o=this,a=!1;this._listeners[t]=i,this.on(e,i)}},E.prototype.removeListener=function(e,t){t in this._listeners&&(Yn.EventEmitter.prototype.removeListener.call(this,e,this._listeners[t]),delete this._listeners[t])},E.prototype.notifyLocalWindows=function(e){x()?chrome.storage.local.set({dbName:e}):w()&&(localStorage[e]="a"===localStorage[e]?"b":"a")},E.prototype.notify=function(e){this.emit(e),this.notifyLocalWindows(e)};var fi,pi=fi="function"==typeof Object.assign?Object.assign:function(e){for(var t=Object(e),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t};Xn(F,Error),F.prototype.toString=function(){return JSON.stringify({status:this.status,name:this.name,message:this.message,reason:this.reason})};new F(401,"unauthorized","Name or password is incorrect.");var di=new F(400,"bad_request","Missing JSON list of 'docs'"),hi=new F(404,"not_found","missing"),mi=new F(409,"conflict","Document update conflict"),vi=new F(400,"bad_request","_id field must contain a string"),yi=new F(412,"missing_id","_id is required for puts"),gi=new F(400,"bad_request","Only reserved document ids may start with underscore."),bi=(new F(412,"precondition_failed","Database not open"),new F(500,"unknown_error","Database encountered an unknown error")),_i=new F(500,"badarg","Some query argument is invalid"),xi=(new F(400,"invalid_request","Request was invalid"),new F(400,"query_parse_error","Some query parameter is invalid")),wi=new F(500,"doc_validation","Bad special document member"),ki=new F(400,"bad_request","Something wrong with the request"),Ei=new F(400,"bad_request","Document must be a JSON object"),Si=(new F(404,"not_found","Database not found"),new F(500,"indexed_db_went_bad","unknown")),Ai=new F(500,"web_sql_went_bad","unknown"),Di=(new F(500,"levelDB_went_went_bad","unknown"),new F(403,"forbidden","Forbidden by design doc validate_doc_update function"),new F(400,"bad_request","Invalid rev format")),Ci=(new F(412,"file_exists","The database could not be created, the file already exists."),new F(412,"missing_stub","A pre-existing attachment stub wasn't found"));new F(413,"invalid_url","Provided URL is invalid");var Fi=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],Oi="queryKey",ji=/(?:^|&)([^&=]*)=?([^&]*)/g,Ri=/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,Bi=ei;Xn(de,Yn.EventEmitter),de.prototype.cancel=function(){this.isCancelled=!0,this.db.taskqueue.isReady&&this.emit("cancel")},de.prototype.validateChanges=function(e){var t=e.complete,r=this;De._changesFilterPlugin?De._changesFilterPlugin.validate(e,function(n){if(n)return t(n);r.doChanges(e)}):r.doChanges(e)},de.prototype.doChanges=function(e){var t=this,r=e.complete;if("live"in(e=u(e))&&!("continuous"in e)&&(e.continuous=e.live),e.processChange=he,"latest"===e.since&&(e.since="now"),e.since||(e.since=0),"now"!==e.since){if(De._changesFilterPlugin){if(De._changesFilterPlugin.normalize(e),De._changesFilterPlugin.shouldFilter(this,e))return De._changesFilterPlugin.filter(this,e)}else["doc_ids","filter","selector","view"].forEach(function(t){t in e&&S("warn",'The "'+t+'" option was passed in to changes/replicate, but pouchdb-changes-filter plugin is not installed, so it was ignored. Please install the plugin to enable filtering.')});"descending"in e||(e.descending=!1),e.limit=0===e.limit?1:e.limit,e.complete=r;var n=this.db._changes(e);if(n&&"function"==typeof n.cancel){var i=t.cancel;t.cancel=Qn(function(e){n.cancel(),i.apply(this,e)})}}else this.db.info().then(function(n){t.isCancelled?r(null,{status:"cancelled"}):(e.since=n.update_seq,t.doChanges(e))},r)},Xn(ke,Yn.EventEmitter),ke.prototype.post=p("post",function(e,t,r){if("function"==typeof t&&(r=t,t={}),"object"!=typeof e||Array.isArray(e))return r(O(Ei));this.bulkDocs({docs:[e]},t,ve(r,e._id))}),ke.prototype.put=p("put",function(e,t,r){function n(r){"function"==typeof i._put&&!1!==t.new_edits?i._put(e,t,r):i.bulkDocs({docs:[e]},t,ve(r,e._id))}if("function"==typeof t&&(r=t,t={}),"object"!=typeof e||Array.isArray(e))return r(O(Ei));if(T(e._id),le(e._id)&&"function"==typeof this._putLocal)return e._deleted?this._removeLocal(e,r):this._putLocal(e,r);var i=this;t.force&&e._rev?(!function(){var r=e._rev.split("-"),n=r[1],i=parseInt(r[0],10)+1,o=z();e._revisions={start:i,ids:[o,n]},e._rev=i+"-"+o,t.new_edits=!1}(),n(function(t){var n=t?null:{ok:!0,id:e._id,rev:e._rev};r(t,n)})):n(r)}),ke.prototype.putAttachment=p("putAttachment",function(e,t,r,n,i){function o(e){var r="_rev"in e?parseInt(e._rev,10):0;return e._attachments=e._attachments||{},e._attachments[t]={content_type:i,data:n,revpos:++r},a.put(e)}var a=this;return"function"==typeof i&&(i=n,n=r,r=null),void 0===i&&(i=n,n=r,r=null),i||S("warn","Attachment",t,"on document",e,"is missing content_type"),a.get(e).then(function(e){if(e._rev!==r)throw O(mi);return o(e)},function(t){if(t.reason===hi.message)return o({_id:e});throw t})}),ke.prototype.removeAttachment=p("removeAttachment",function(e,t,r,n){var i=this;i.get(e,function(e,o){if(e)n(e);else if(o._rev===r){if(!o._attachments)return n();delete o._attachments[t],0===Object.keys(o._attachments).length&&delete o._attachments,i.put(o,n)}else n(O(mi))})}),ke.prototype.remove=p("remove",function(e,t,r,n){var i;"string"==typeof t?(i={_id:e,_rev:t},"function"==typeof r&&(n=r,r={})):(i=e,"function"==typeof t?(n=t,r={}):(n=r,r=t)),(r=r||{}).was_delete=!0;var o={_id:i._id,_rev:i._rev||r.rev};if(o._deleted=!0,le(o._id)&&"function"==typeof this._removeLocal)return this._removeLocal(i,n);this.bulkDocs({docs:[o]},r,ve(n,o._id))}),ke.prototype.revsDiff=p("revsDiff",function(e,t,r){function n(e,t){s.has(e)||s.set(e,{missing:[]}),s.get(e).missing.push(t)}function i(t,r){var i=e[t].slice(0);G(r,function(e,r,o,a,s){var u=r+"-"+o,c=i.indexOf(u);-1!==c&&(i.splice(c,1),"available"!==s.status&&n(t,u))}),i.forEach(function(e){n(t,e)})}"function"==typeof t&&(r=t,t={});var o=Object.keys(e);if(!o.length)return r(null,{});var a=0,s=new ui;o.map(function(t){this._getRevisionTree(t,function(n,u){if(n&&404===n.status&&"missing"===n.message)s.set(t,{missing:e[t]});else{if(n)return r(n);i(t,u)}if(++a===o.length){var c={};return s.forEach(function(e,t){c[t]=e}),r(null,c)}})},this)}),ke.prototype.bulkGet=p("bulkGet",function(e,t){_(this,e,t)}),ke.prototype.compactDocument=p("compactDocument",function(e,t,r){var n=this;this._getRevisionTree(e,function(i,o){if(i)return r(i);var a=be(o),s=[],u=[];Object.keys(a).forEach(function(e){a[e]>t&&s.push(e)}),G(o,function(e,t,r,n,i){var o=t+"-"+r;"available"===i.status&&-1!==s.indexOf(o)&&u.push(o)}),n._doCompaction(e,u,r)})}),ke.prototype.compact=p("compact",function(e,t){"function"==typeof e&&(t=e,e={});var r=this;e=e||{},r._compactionQueue=r._compactionQueue||[],r._compactionQueue.push({opts:e,callback:t}),1===r._compactionQueue.length&&xe(r)}),ke.prototype._compact=function(e,t){var r=this,n={return_docs:!1,last_seq:e.last_seq||0},i=[];r.changes(n).on("change",function(e){i.push(r.compactDocument(e.id,0))}).on("complete",function(e){var n=e.last_seq;ii.all(i).then(function(){return W(r,"_local/compaction",function(e){return(!e.last_seq||e.last_seq<n)&&(e.last_seq=n,e)})}).then(function(){t(null,{ok:!0})}).catch(t)}).on("error",t)},ke.prototype.get=p("get",function(e,t,r){function n(){var n=[],a=i.length;if(!a)return r(null,n);i.forEach(function(i){o.get(e,{rev:i,revs:t.revs,latest:t.latest,attachments:t.attachments},function(e,t){if(e)n.push({missing:i});else{for(var o,s=0,u=n.length;s<u;s++)if(n[s].ok&&n[s].ok._rev===t._rev){o=!0;break}o||n.push({ok:t})}--a||r(null,n)})})}if("function"==typeof t&&(r=t,t={}),"string"!=typeof e)return r(O(vi));if(le(e)&&"function"==typeof this._getLocal)return this._getLocal(e,r);var i=[],o=this;if(!t.open_revs)return this._get(e,t,function(n,i){if(n)return n.docId=e,r(n);var a=i.doc,s=i.metadata,u=i.ctx;if(t.conflicts){var c=K(s);c.length&&(a._conflicts=c)}if(ce(s,a._rev)&&(a._deleted=!0),t.revs||t.revs_info){for(var l=a._rev.split("-"),f=parseInt(l[0],10),p=l[1],d=Y(s.rev_tree),h=null,m=0;m<d.length;m++){var v=d[m],y=v.ids.map(function(e){return e.id}).indexOf(p);(y===f-1||!h&&-1!==y)&&(h=v)}var g=h.ids.map(function(e){return e.id}).indexOf(a._rev.split("-")[1])+1,b=h.ids.length-g;if(h.ids.splice(g,b),h.ids.reverse(),t.revs&&(a._revisions={start:h.pos+h.ids.length-1,ids:h.ids.map(function(e){return e.id})}),t.revs_info){var _=h.pos+h.ids.length;a._revs_info=h.ids.map(function(e){return _--,{rev:_+"-"+e.id,status:e.opts.status}})}}if(t.attachments&&a._attachments){var x=a._attachments,w=Object.keys(x).length;if(0===w)return r(null,a);Object.keys(x).forEach(function(e){this._getAttachment(a._id,e,x[e],{rev:a._rev,binary:t.binary,ctx:u},function(t,n){var i=a._attachments[e];i.data=n,delete i.stub,delete i.length,--w||r(null,a)})},o)}else{if(a._attachments)for(var k in a._attachments)a._attachments.hasOwnProperty(k)&&(a._attachments[k].stub=!0);r(null,a)}});if("all"===t.open_revs)this._getRevisionTree(e,function(e,t){if(e)return r(e);i=J(t).map(function(e){return e.rev}),n()});else{if(!Array.isArray(t.open_revs))return r(O(bi,"function_clause"));i=t.open_revs;for(var a=0;a<i.length;a++){var s=i[a];if("string"!=typeof s||!/^\d+-/.test(s))return r(O(Di))}n()}}),ke.prototype.getAttachment=p("getAttachment",function(e,t,r,n){var i=this;r instanceof Function&&(n=r,r={}),this._get(e,r,function(o,a){return o?n(o):a.doc._attachments&&a.doc._attachments[t]?(r.ctx=a.ctx,r.binary=!0,void i._getAttachment(e,t,a.doc._attachments[t],r,n)):n(O(hi))})}),ke.prototype.allDocs=p("allDocs",function(e,t){if("function"==typeof e&&(t=e,e={}),e.skip=void 0!==e.skip?e.skip:0,e.start_key&&(e.startkey=e.start_key),e.end_key&&(e.endkey=e.end_key),"keys"in e){if(!Array.isArray(e.keys))return t(new TypeError("options.keys must be an array"));var r=["startkey","endkey","key"].filter(function(t){return t in e})[0];if(r)return void t(O(xi,"Query parameter `"+r+"` is not compatible with multi-get"));if(!I(this))return _e(this,e,t)}return this._allDocs(e,t)}),ke.prototype.changes=function(e,t){return"function"==typeof e&&(t=e,e={}),new de(this,e,t)},ke.prototype.close=p("close",function(e){return this._closed=!0,this.emit("closed"),this._close(e)}),ke.prototype.info=p("info",function(e){var t=this;this._info(function(r,n){if(r)return e(r);n.db_name=n.db_name||t.name,n.auto_compaction=!(!t.auto_compaction||I(t)),n.adapter=t.adapter,e(null,n)})}),ke.prototype.id=p("id",function(e){return this._id(e)}),ke.prototype.type=function(){return"function"==typeof this._type?this._type():this.adapter},ke.prototype.bulkDocs=p("bulkDocs",function(e,t,r){if("function"==typeof t&&(r=t,t={}),t=t||{},Array.isArray(e)&&(e={docs:e}),!e||!e.docs||!Array.isArray(e.docs))return r(O(di));for(var n=0;n<e.docs.length;++n)if("object"!=typeof e.docs[n]||Array.isArray(e.docs[n]))return r(O(Ei));var i;if(e.docs.forEach(function(e){e._attachments&&Object.keys(e._attachments).forEach(function(t){i=i||we(t),e._attachments[t].content_type||S("warn","Attachment",t,"on document",e._id,"is missing content_type")})}),i)return r(O(ki,i));"new_edits"in t||(t.new_edits=!("new_edits"in e)||e.new_edits);var o=this;t.new_edits||I(o)||e.docs.sort(ge),ye(e.docs);var a=e.docs.map(function(e){return e._id});return this._bulkDocs(e,t,function(e,n){if(e)return r(e);if(t.new_edits||(n=n.filter(function(e){return e.error})),!I(o))for(var i=0,s=n.length;i<s;i++)n[i].id=n[i].id||a[i];r(null,n)})}),ke.prototype.registerDependentDatabase=p("registerDependentDatabase",function(e,t){var r=new this.constructor(e,this.__opts);W(this,"_local/_pouch_dependentDbs",function(t){return t.dependentDbs=t.dependentDbs||{},!t.dependentDbs[e]&&(t.dependentDbs[e]=!0,t)}).then(function(){t(null,{db:r})}).catch(t)}),ke.prototype.destroy=p("destroy",function(e,t){function r(){n._destroy(e,function(e,r){if(e)return t(e);n._destroyed=!0,n.emit("destroyed"),t(null,r||{ok:!0})})}"function"==typeof e&&(t=e,e={});var n=this,i=!("use_prefix"in n)||n.use_prefix;if(I(n))return r();n.get("_local/_pouch_dependentDbs",function(e,o){if(e)return 404!==e.status?t(e):r();var a=o.dependentDbs,s=n.constructor,u=Object.keys(a).map(function(e){var t=i?e.replace(new RegExp("^"+s.prefix),""):e;return new s(t,n.__opts).destroy()});ii.all(u).then(r,t)})}),Ee.prototype.execute=function(){var e;if(this.failed)for(;e=this.queue.shift();)e(this.failed);else for(;e=this.queue.shift();)e()},Ee.prototype.fail=function(e){this.failed=e,this.execute()},Ee.prototype.ready=function(e){this.isReady=!0,this.db=e,this.execute()},Ee.prototype.addTask=function(e){this.queue.push(e),this.failed&&this.execute()},Xn(De,ke),De.adapters={},De.preferredAdapters=[],De.prefix="_pouch_";var Pi=new Yn.EventEmitter;!function(e){Object.keys(Yn.EventEmitter.prototype).forEach(function(t){"function"==typeof Yn.EventEmitter.prototype[t]&&(e[t]=Pi[t].bind(Pi))});var t=e._destructionListeners=new ui;e.on("ref",function(e){t.has(e.name)||t.set(e.name,[]),t.get(e.name).push(e)}),e.on("unref",function(e){if(t.has(e.name)){var r=t.get(e.name),n=r.indexOf(e);n<0||(r.splice(n,1),r.length>1?t.set(e.name,r):t.delete(e.name))}}),e.on("destroyed",function(e){if(t.has(e)){var r=t.get(e);t.delete(e),r.forEach(function(e){e.emit("destroyed",!0)})}})}(De),De.adapter=function(e,t,r){t.valid()&&(De.adapters[e]=t,r&&De.preferredAdapters.push(e))},De.plugin=function(e){if("function"==typeof e)e(De);else{if("object"!=typeof e||0===Object.keys(e).length)throw new Error('Invalid plugin: got "'+e+'", expected an object or a function');Object.keys(e).forEach(function(t){De.prototype[t]=e[t]})}return this.__defaults&&(De.__defaults=pi({},this.__defaults)),De},De.defaults=function(e){function t(e,r){if(!(this instanceof t))return new t(e,r);r=r||{},e&&"object"==typeof e&&(e=(r=e).name,delete r.name),r=pi({},t.__defaults,r),De.call(this,e,r)}return Xn(t,De),t.preferredAdapters=De.preferredAdapters.slice(),Object.keys(De).forEach(function(e){e in t||(t[e]=De[e])}),t.__defaults=pi({},this.__defaults,e),t};var Ti=["$or","$nor","$not"],Ii=-324,Li=3,Ni="",Mi={$elemMatch:function(e,t,r,n){return!!Array.isArray(n)&&(0!==n.length&&("object"==typeof n[0]?n.some(function(e){return rt(e,t,Object.keys(t))}):n.some(function(n){return nt(t,e,r,n)})))},$allMatch:function(e,t,r,n){return!!Array.isArray(n)&&(0!==n.length&&("object"==typeof n[0]?n.every(function(e){return rt(e,t,Object.keys(t))}):n.every(function(n){return nt(t,e,r,n)})))},$eq:function(e,t,r,n){return st(n)&&0===We(n,t)},$gte:function(e,t,r,n){return st(n)&&We(n,t)>=0},$gt:function(e,t,r,n){return st(n)&&We(n,t)>0},$lte:function(e,t,r,n){return st(n)&&We(n,t)<=0},$lt:function(e,t,r,n){return st(n)&&We(n,t)<0},$exists:function(e,t,r,n){return t?st(n):!st(n)},$mod:function(e,t,r,n){return at(n)&&ut(n,t)},$ne:function(e,t,r,n){return t.every(function(e){return 0!==We(n,e)})},$in:function(e,t,r,n){return at(n)&&ct(n,t)},$nin:function(e,t,r,n){return at(n)&&!ct(n,t)},$size:function(e,t,r,n){return at(n)&&ft(n,t)},$all:function(e,t,r,n){return Array.isArray(n)&&lt(n,t)},$regex:function(e,t,r,n){return at(n)&&pt(n,t)},$type:function(e,t,r,n){return dt(n,t)}};De.plugin(function(e){e.debug=ti;var t={};e.on("debug",function(e){var r=e[0],n=e.slice(1);t[r]||(t[r]=ti("pouchdb:"+r)),t[r].apply(null,n)})}),De.plugin(function(e){e._changesFilterPlugin={validate:yt,normalize:gt,shouldFilter:bt,filter:_t}}),De.version="6.3.2";var qi,$i=xt(["_id","_rev","_attachments","_deleted","_revisions","_revs_info","_conflicts","_deleted_conflicts","_local_seq","_rev_tree","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats","_removed"]),Wi=xt(["_attachments","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats"]),Ui=function(e){return atob(e)},zi=function(e){return btoa(e)},Vi=r.setImmediate||r.setTimeout,Gi=32768,Hi=5,Ji="document-store",Ki="by-sequence",Qi="attach-store",Yi="attach-seq-store",Xi="meta-store",Zi="local-store",eo="detect-blob-support",to=new E,ro=!1,no=[],io=new ui,oo=new ui;vr.valid=function(){return!("undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform))&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange};var ao=7,so=Er("document-store"),uo=Er("by-sequence"),co=Er("attach-store"),lo=Er("local-store"),fo=Er("metadata-store"),po=Er("attach-seq-store"),ho=new ui,mo=new E,vo=1,yo="CREATE INDEX IF NOT EXISTS 'by-seq-deleted-idx' ON "+uo+" (seq, deleted)",go="CREATE UNIQUE INDEX IF NOT EXISTS 'by-seq-doc-id-rev' ON "+uo+" (doc_id, rev)",bo="CREATE INDEX IF NOT EXISTS 'doc-winningseq-idx' ON "+so+" (winningseq)",_o="CREATE INDEX IF NOT EXISTS 'attach-seq-seq-idx' ON "+po+" (seq)",xo="CREATE UNIQUE INDEX IF NOT EXISTS 'attach-seq-digest-idx' ON "+po+" (digest, seq)",wo=uo+".seq = "+so+".winningseq",ko=uo+".seq AS seq, "+uo+".deleted AS deleted, "+uo+".json AS data, "+uo+".rev AS rev, "+so+".json AS metadata";Ur.valid=function(){return"function"==typeof openDatabase&&$r()},Ur.use_prefix=!0;var Eo=function(){try{return new XMLHttpRequest,!0}catch(e){return!1}}(),So=function(){},Ao=25,Do=50,Co=5e3,Fo=1e4,Oo={};sn.valid=function(){return!0};Xn(un,Error),Xn(cn,Error),Xn(ln,Error);var jo=S.bind(null,"log"),Ro=Array.isArray,Bo=JSON.parse;_n.prototype.add=function(e){return this.promise=this.promise.catch(function(){}).then(function(){return e()}),this.promise},_n.prototype.finish=function(){return this.promise};var Po={},To=new _n,Io=50,Lo={_sum:function(e,t){return gn(t)},_count:function(e,t){return t.length},_stats:function(e,t){return{sum:gn(t),min:Math.min.apply(null,t),max:Math.max.apply(null,t),count:t.length,sumsqr:function(e){for(var t=0,r=0,n=e.length;r<n;r++){var i=e[r];t+=i*i}return t}(t)}}},No=function(e,t,r,n){function i(e,t,r){try{t(r)}catch(t){An(e,t)}}function o(e,t,r,n,i){try{return{output:t(r,n,i)}}catch(t){return An(e,t),{error:t}}}function a(e,t){var r=We(e.key,t.key);return 0!==r?r:We(e.value,t.value)}function s(e,t,r){return r=r||0,"number"==typeof t?e.slice(r,t+r):r>0?e.slice(r):e}function u(e){var t=e.value;return t&&"object"==typeof t&&t._id||e.id}function c(e){e.rows.forEach(function(e){var t=e.doc&&e.doc._attachments;t&&Object.keys(t).forEach(function(e){var r=t[e];t[e].data=Ct(r.data,r.content_type)})})}function l(e){return function(t){return e.include_docs&&e.attachments&&e.binary&&c(t),t}}function f(e,t,r,n){var i=t[e];void 0!==i&&(n&&(i=encodeURIComponent(JSON.stringify(i))),r.push(e+"="+i))}function p(e){if(void 0!==e){var t=Number(e);return isNaN(t)||t!==parseInt(e,10)?e:t}}function d(e){return e.group_level=p(e.group_level),e.limit=p(e.limit),e.skip=p(e.skip),e}function h(e){if(e){if("number"!=typeof e)return new un('Invalid value for integer: "'+e+'"');if(e<0)return new un('Invalid value for positive integer: "'+e+'"')}}function m(e,t){var r=e.descending?"endkey":"startkey",n=e.descending?"startkey":"endkey";if(void 0!==e[r]&&void 0!==e[n]&&We(e[r],e[n])>0)throw new un("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");if(t.reduce&&!1!==e.reduce){if(e.include_docs)throw new un("{include_docs:true} is invalid for reduce");if(e.keys&&e.keys.length>1&&!e.group&&!e.group_level)throw new un("Multi-key fetches for reduce views must use {group: true}")}["group_level","limit","skip"].forEach(function(t){var r=h(e[t]);if(r)throw r})}function v(e,t,r){var n,i=[],o="GET";if(f("reduce",r,i),f("include_docs",r,i),f("attachments",r,i),f("limit",r,i),f("descending",r,i),f("group",r,i),f("group_level",r,i),f("skip",r,i),f("stale",r,i),f("conflicts",r,i),f("startkey",r,i,!0),f("start_key",r,i,!0),f("endkey",r,i,!0),f("end_key",r,i,!0),f("inclusive_end",r,i),f("key",r,i,!0),i=i.join("&"),i=""===i?"":"?"+i,void 0!==r.keys){var a="keys="+encodeURIComponent(JSON.stringify(r.keys));a.length+i.length+1<=2e3?i+=("?"===i[0]?"&":"?")+a:(o="POST","string"==typeof t?n={keys:r.keys}:t.keys=r.keys)}if("string"==typeof t){var s=En(t);return e.request({method:o,url:"_design/"+s[0]+"/_view/"+s[1]+i,body:n}).then(function(e){return e.rows.forEach(function(e){if(e.value&&e.value.error&&"builtin_reduce_error"===e.value.error)throw new Error(e.reason)}),e}).then(l(r))}return n=n||{},Object.keys(t).forEach(function(e){Array.isArray(t[e])?n[e]=t[e]:n[e]=t[e].toString()}),e.request({method:"POST",url:"_temp_view"+i,body:n}).then(l(r))}function y(e,t,r){return new ii(function(n,i){e._query(t,r,function(e,t){if(e)return i(e);n(t)})})}function g(e){return new ii(function(t,r){e._viewCleanup(function(e,n){if(e)return r(e);t(n)})})}function b(e){return function(t){if(404===t.status)return e;throw t}}function _(e,t,r){function n(e){return e.keys.length?t.db.allDocs({keys:e.keys,include_docs:!0}):ii.resolve({rows:[]})}function i(e,t){for(var r=[],n=new si,i=0,o=t.rows.length;i<o;i++){var a=t.rows[i].doc;if(a&&(r.push(a),n.add(a._id),a._deleted=!u.has(a._id),!a._deleted)){var s=u.get(a._id);"value"in s&&(a.value=s.value)}}var c=vn(u);return c.forEach(function(e){if(!n.has(e)){var t={_id:e},i=u.get(e);"value"in i&&(t.value=i.value),r.push(t)}}),e.keys=mn(c.concat(e.keys)),r.push(e),r}var o="_local/doc_"+e,a={_id:o,keys:[]},s=r.get(e),u=s[0];return(Sn(s[1])?ii.resolve(a):t.db.get(o).catch(b(a))).then(function(e){return n(e).then(function(t){return i(e,t)})})}function x(e,t,r){return e.db.get("_local/lastSeq").catch(b({_id:"_local/lastSeq",seq:0})).then(function(n){var i=vn(t);return ii.all(i.map(function(r){return _(r,e,t)})).then(function(t){var i=P(t);return n.seq=r,i.push(n),e.db.bulkDocs({docs:i})})})}function w(e){var t="string"==typeof e?e:e.name,r=Po[t];return r||(r=Po[t]=new _n),r}function k(e){return hn(w(e),function(){return E(e)})()}function E(e){function r(t,r){return function(){return x(e,t,r)}}function n(){return e.sourceDB.changes({conflicts:!0,include_docs:!0,style:"all_docs",since:p,limit:Io}).then(o)}function o(e){var t=e.results;if(t.length){var i=s(t);if(d.add(r(i,p)),!(t.length<Io))return n()}}function s(t){for(var r=new ui,n=0,o=t.length;n<o;n++){var s=t[n];if("_"!==s.doc._id[0]){c=[],(l=s.doc)._deleted||i(e.sourceDB,f,l),c.sort(a);var d=u(c);r.set(s.doc._id,[d,s.changes])}p=s.seq}return r}function u(e){for(var t,r=new ui,n=0,i=e.length;n<i;n++){var o=e[n],a=[o.key,o.id];n>0&&0===We(o.key,t)&&a.push(n),r.set(Ve(a),o),t=o.key}return r}var c,l,f=t(e.mapFun,function(e,t){var r={id:l._id,key:Ue(e)};void 0!==t&&null!==t&&(r.value=Ue(t)),c.push(r)}),p=e.seq||0,d=new _n;return n().then(function(){return d.finish()}).then(function(){e.seq=p})}function S(e,t,n){0===n.group_level&&delete n.group_level;var i=n.group||n.group_level,a=r(e.reduceFun),u=[],c=isNaN(n.group_level)?Number.POSITIVE_INFINITY:n.group_level;t.forEach(function(e){var t=u[u.length-1],r=i?e.key:null;if(i&&Array.isArray(r)&&(r=r.slice(0,c)),t&&0===We(t.groupKey,r))return t.keys.push([e.key,e.id]),void t.values.push(e.value);u.push({keys:[[e.key,e.id]],values:[e.value],groupKey:r})}),t=[];for(var l=0,f=u.length;l<f;l++){var p=u[l],d=o(e.sourceDB,a,p.keys,p.values,!1);if(d.error&&d.error instanceof ln)throw d.error;t.push({value:d.error?null:d.output,key:p.groupKey})}return{rows:s(t,n.limit,n.skip)}}function A(e,t){return hn(w(e),function(){return D(e,t)})()}function D(e,t){function r(t){return t.include_docs=!0,e.db.allDocs(t).then(function(e){return i=e.total_rows,e.rows.map(function(e){if("value"in e.doc&&"object"==typeof e.doc.value&&null!==e.doc.value){var t=Object.keys(e.doc.value).sort(),r=["id","key","value"];if(!(t<r||t>r))return e.doc.value}var n=Je(e.doc._id);return{key:n[0],id:n[1],value:"value"in e.doc?e.doc.value:null}})})}function n(r){var n;if(n=o?S(e,r,t):{total_rows:i,offset:a,rows:r},t.include_docs){var s=mn(r.map(u));return e.sourceDB.allDocs({keys:s,include_docs:!0,conflicts:t.conflicts,attachments:t.attachments,binary:t.binary}).then(function(e){var t=new ui;return e.rows.forEach(function(e){t.set(e.id,e.doc)}),r.forEach(function(e){var r=u(e),n=t.get(r);n&&(e.doc=n)}),n})}return n}var i,o=e.reduceFun&&!1!==t.reduce,a=t.skip||0;if(void 0===t.keys||t.keys.length||(t.limit=0,delete t.keys),void 0!==t.keys){var s=t.keys.map(function(e){return r({startkey:Ve([e]),endkey:Ve([e,{}])})});return ii.all(s).then(P).then(n)}var c,l,f={descending:t.descending};if("start_key"in t&&(c=t.start_key),"startkey"in t&&(c=t.startkey),"end_key"in t&&(l=t.end_key),"endkey"in t&&(l=t.endkey),void 0!==c&&(f.startkey=Ve(t.descending?[c,{}]:[c])),void 0!==l){var p=!1!==t.inclusive_end;t.descending&&(p=!p),f.endkey=Ve(p?[l,{}]:[l])}if(void 0!==t.key){var d=Ve([t.key]),h=Ve([t.key,{}]);f.descending?(f.endkey=d,f.startkey=h):(f.startkey=d,f.endkey=h)}return o||("number"==typeof t.limit&&(f.limit=t.limit),f.skip=a),r(f).then(n)}function C(e){return e.request({method:"POST",url:"_view_cleanup"})}function F(t){return t.get("_local/"+e).then(function(e){var r=new ui;Object.keys(e.views).forEach(function(e){var t=En(e),n="_design/"+t[0],i=t[1],o=r.get(n);o||(o=new si,r.set(n,o)),o.add(i)});var n={keys:vn(r),include_docs:!0};return t.allDocs(n).then(function(n){var i={};n.rows.forEach(function(t){var n=t.key.substring(8);r.get(t.key).forEach(function(r){var o=n+"/"+r;e.views[o]||(o=r);var a=Object.keys(e.views[o]),s=t.doc&&t.doc.views&&t.doc.views[r];a.forEach(function(e){i[e]=i[e]||s})})});var o=Object.keys(i).filter(function(e){return!i[e]}).map(function(e){return hn(w(e),function(){return new t.constructor(e,t.__opts).destroy()})()});return ii.all(o).then(function(){return{ok:!0}})})},b({ok:!0}))}function O(t,r,i){if("function"==typeof t._query)return y(t,r,i);if(I(t))return v(t,r,i);if("string"!=typeof r)return m(i,r),To.add(function(){return kn(t,"temp_view/temp_view",r.map,r.reduce,!0,e).then(function(e){return dn(k(e).then(function(){return A(e,i)}),function(){return e.db.destroy()})})}),To.finish();var o=r,a=En(o),s=a[0],u=a[1];return t.get("_design/"+s).then(function(r){var a=r.views&&r.views[u];if(!a)throw new cn("ddoc "+r._id+" has no view named "+u);return n(r,u),m(i,a),kn(t,o,a.map,a.reduce,!1,e).then(function(e){return"ok"===i.stale||"update_after"===i.stale?("update_after"===i.stale&&Zn(function(){k(e)}),A(e,i)):k(e).then(function(){return A(e,i)})})})}return{query:function(e,t,r){var n=this;"function"==typeof t&&(r=t,t={}),t=t?d(t):{},"function"==typeof e&&(e={map:e});var i=ii.resolve().then(function(){return O(n,e,t)});return fn(i,r),i},viewCleanup:pn(function(){var e=this;return"function"==typeof e._viewCleanup?g(e):I(e)?C(e):F(e)})}}("mrviews",function(e,t){if("function"==typeof e&&2===e.length){var r=e;return function(e){return r(e,t)}}return bn(e.toString(),t)},function(e){var t=e.toString(),r=Dn(t);return r||bn(t)},function(e,t){var r=e.views&&e.views[t];if("string"!=typeof r.map)throw new cn("ddoc "+e._id+" has no string view named "+t+", instead found object of type: "+typeof r.map)}),Mo={query:function(e,t,r){return No.query.call(this,e,t,r)},viewCleanup:function(e){return No.viewCleanup.call(this,e)}},qo=1,$o="pouchdb",Wo=5,Uo=0;Tn.prototype.writeCheckpoint=function(e,t){var r=this;return this.updateTarget(e,t).then(function(){return r.updateSource(e,t)})},Tn.prototype.updateTarget=function(e,t){return this.opts.writeTargetCheckpoint?Pn(this.target,this.id,e,t,this.returnValue):ii.resolve(!0)},Tn.prototype.updateSource=function(e,t){if(this.opts.writeSourceCheckpoint){var r=this;return this.readOnlySource?ii.resolve(!0):Pn(this.src,this.id,e,t,this.returnValue).catch(function(e){if(Mn(e))return r.readOnlySource=!0,!0;throw e})}return ii.resolve(!0)};var zo={undefined:function(e,t){return 0===We(e.last_seq,t.last_seq)?t.last_seq:0},1:function(e,t){return In(t,e).last_seq}};Tn.prototype.getCheckpoint=function(){var e=this;return e.target.get(e.id).then(function(t){return e.readOnlySource?ii.resolve(t.last_seq):e.src.get(e.id).then(function(e){if(t.version!==e.version)return Uo;var r;return(r=t.version?t.version.toString():"undefined")in zo?zo[r](t,e):Uo},function(r){if(404===r.status&&t.last_seq)return e.src.put({_id:e.id,last_seq:Uo}).then(function(){return Uo},function(r){return Mn(r)?(e.readOnlySource=!0,t.last_seq):Uo});throw r})}).catch(function(e){if(404!==e.status)throw e;return Uo})};var Vo=0;Xn(zn,Yn.EventEmitter),zn.prototype.cancel=function(){this.cancelled=!0,this.state="cancelled",this.emit("cancel")},zn.prototype.ready=function(e,t){function r(){n.cancel()}var n=this;n._readyCalled||(n._readyCalled=!0,e.once("destroyed",r),t.once("destroyed",r),n.once("complete",function(){e.removeListener("destroyed",r),t.removeListener("destroyed",r)}))},Xn(Jn,Yn.EventEmitter),Jn.prototype.cancel=function(){this.canceled||(this.canceled=!0,this.push.cancel(),this.pull.cancel())},De.plugin(function(e){e.adapter("idb",vr,!0)}).plugin(function(e){e.adapter("websql",Ur,!0)}).plugin(function(e){e.adapter("http",sn,!1),e.adapter("https",sn,!1)}).plugin(Mo).plugin(function(e){e.replicate=Gn,e.sync=Hn,Object.defineProperty(e.prototype,"replicate",{get:function(){var e=this;return{from:function(t,r,n){return e.constructor.replicate(t,e,r,n)},to:function(t,r,n){return e.constructor.replicate(e,t,r,n)}}}}),e.prototype.sync=function(e,t,r){return this.constructor.sync(this,e,t,r)}}),t.exports=De}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{1:1,10:10,13:13,14:14,2:2,4:4,5:5,6:6,7:7}]},{},[15])(15)}),t.exports}(),t=function(){var e={},t={exports:e};return function(r){if("object"==typeof e&&void 0!==t)t.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).pouchdbAdapterMemory=r()}}(function(){return function e(t,r,n){function i(a,s){if(!r[a]){if(!t[a]){var u="function"==typeof require&&require;if(!s&&u)return u(a,!0);if(o)return o(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var l=r[a]={exports:{}};t[a][0].call(l.exports,function(e){var r=t[a][1][e];return i(r||e)},l,l.exports,e,t,r,n)}return r[a].exports}for(var o="function"==typeof require&&require,a=0;a<n.length;a++)i(n[a]);return i}({1:[function(e,t,r){"use strict";t.exports=function(e){return function(){var t=arguments.length;if(t){for(var r=[],n=-1;++n<t;)r[n]=arguments[n];return e.call(this,r)}return e.call(this,[])}}},{}],2:[function(e,t,r){"use strict";function n(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function i(e){return a[e>>18&63]+a[e>>12&63]+a[e>>6&63]+a[63&e]}function o(e,t,r){for(var n,o=[],a=t;a<r;a+=3)n=(e[a]<<16)+(e[a+1]<<8)+e[a+2],o.push(i(n));return o.join("")}r.byteLength=function(e){return 3*e.length/4-n(e)},r.toByteArray=function(e){var t,r,i,o,a,c=e.length;o=n(e),a=new u(3*c/4-o),r=o>0?c-4:c;var l=0;for(t=0;t<r;t+=4)i=s[e.charCodeAt(t)]<<18|s[e.charCodeAt(t+1)]<<12|s[e.charCodeAt(t+2)]<<6|s[e.charCodeAt(t+3)],a[l++]=i>>16&255,a[l++]=i>>8&255,a[l++]=255&i;return 2===o?(i=s[e.charCodeAt(t)]<<2|s[e.charCodeAt(t+1)]>>4,a[l++]=255&i):1===o&&(i=s[e.charCodeAt(t)]<<10|s[e.charCodeAt(t+1)]<<4|s[e.charCodeAt(t+2)]>>2,a[l++]=i>>8&255,a[l++]=255&i),a},r.fromByteArray=function(e){for(var t,r=e.length,n=r%3,i="",s=[],u=0,c=r-n;u<c;u+=16383)s.push(o(e,u,u+16383>c?c:u+16383));return 1===n?(t=e[r-1],i+=a[t>>2],i+=a[t<<4&63],i+="=="):2===n&&(t=(e[r-2]<<8)+e[r-1],i+=a[t>>10],i+=a[t>>4&63],i+=a[t<<2&63],i+="="),s.push(i),s.join("")};for(var a=[],s=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",l=0,f=c.length;l<f;++l)a[l]=c[l],s[c.charCodeAt(l)]=l;s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63},{}],3:[function(e,t,r){},{}],4:[function(e,t,r){(function(r){function n(e,t,n){t>>>=0;var i=e.byteLength-t;if(i<0)throw new RangeError("'offset' is out of bounds");if(void 0===n)n=i;else if((n>>>=0)>i)throw new RangeError("'length' is out of bounds");return a?r.from(e.slice(t,t+n)):new r(new Uint8Array(e.slice(t,t+n)))}function i(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!r.isEncoding(t))throw new TypeError('"encoding" must be a valid string encoding');return a?r.from(e,t):new r(e,t)}var o=e("is-array-buffer-x"),a="function"==typeof r.alloc&&"function"==typeof r.allocUnsafe&&"function"==typeof r.from;t.exports=function(e,t,s){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return o(e)?n(e,t,s):"string"==typeof e?i(e,t):a?r.from(e):new r(e)}}).call(this,e("buffer").Buffer)},{buffer:5,"is-array-buffer-x":25}],5:[function(e,t,r){"use strict";function n(e){if(e>J)throw new RangeError("Invalid typed array length");var t=new Uint8Array(e);return t.__proto__=i.prototype,t}function i(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return u(e)}return o(e,t,r)}function o(e,t,r){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return e instanceof ArrayBuffer?f(e,t,r):"string"==typeof e?c(e,t):p(e)}function a(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function s(e,t,r){return a(e),e<=0?n(e):void 0!==t?"string"==typeof r?n(e).fill(t,r):n(e).fill(t):n(e)}function u(e){return a(e),n(e<0?0:0|d(e))}function c(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!i.isEncoding(t))throw new TypeError('"encoding" must be a valid string encoding');var r=0|h(e,t),o=n(r),a=o.write(e,t);return a!==r&&(o=o.slice(0,a)),o}function l(e){for(var t=e.length<0?0:0|d(e.length),r=n(t),i=0;i<t;i+=1)r[i]=255&e[i];return r}function f(e,t,r){if(t<0||e.byteLength<t)throw new RangeError("'offset' is out of bounds");if(e.byteLength<t+(r||0))throw new RangeError("'length' is out of bounds");var n;return n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),n.__proto__=i.prototype,n}function p(e){if(i.isBuffer(e)){var t=0|d(e.length),r=n(t);return 0===r.length?r:(e.copy(r,0,0,t),r)}if(e){if(z(e)||"length"in e)return"number"!=typeof e.length||V(e.length)?n(0):l(e);if("Buffer"===e.type&&Array.isArray(e.data))return l(e.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function d(e){if(e>=J)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+J.toString(16)+" bytes");return 0|e}function h(e,t){if(i.isBuffer(e))return e.length;if(z(e)||e instanceof ArrayBuffer)return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return M(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return W(e).length;default:if(n)return M(e).length;t=(""+t).toLowerCase(),n=!0}}function m(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if(r>>>=0,t>>>=0,r<=t)return"";for(e||(e="utf8");;)switch(e){case"hex":return O(this,t,r);case"utf8":case"utf-8":return A(this,t,r);case"ascii":return C(this,t,r);case"latin1":case"binary":return F(this,t,r);case"base64":return S(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return j(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function v(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function y(e,t,r,n,o){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,V(r)&&(r=o?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(o)return-1;r=e.length-1}else if(r<0){if(!o)return-1;r=0}if("string"==typeof t&&(t=i.from(t,n)),i.isBuffer(t))return 0===t.length?-1:g(e,t,r,n,o);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):g(e,[t],r,n,o);throw new TypeError("val must be string, number or Buffer")}function g(e,t,r,n,i){function o(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,s=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,u/=2,r/=2}var c;if(i){var l=-1;for(c=r;c<s;c++)if(o(e,c)===o(t,-1===l?0:c-l)){if(-1===l&&(l=c),c-l+1===u)return l*a}else-1!==l&&(c-=c-l),l=-1}else for(r+u>s&&(r=s-u),c=r;c>=0;c--){for(var f=!0,p=0;p<u;p++)if(o(e,c+p)!==o(t,p)){f=!1;break}if(f)return c}return-1}function b(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(t.substr(2*a,2),16);if(V(s))return a;e[r+a]=s}return a}function _(e,t,r,n){return U(M(t,e.length-r),e,r,n)}function x(e,t,r,n){return U(q(t),e,r,n)}function w(e,t,r,n){return x(e,t,r,n)}function k(e,t,r,n){return U(W(t),e,r,n)}function E(e,t,r,n){return U($(t,e.length-r),e,r,n)}function S(e,t,r){return 0===t&&r===e.length?G.fromByteArray(e):G.fromByteArray(e.slice(t,r))}function A(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o=e[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s<=r){var u,c,l,f;switch(s){case 1:o<128&&(a=o);break;case 2:128==(192&(u=e[i+1]))&&(f=(31&o)<<6|63&u)>127&&(a=f);break;case 3:u=e[i+1],c=e[i+2],128==(192&u)&&128==(192&c)&&(f=(15&o)<<12|(63&u)<<6|63&c)>2047&&(f<55296||f>57343)&&(a=f);break;case 4:u=e[i+1],c=e[i+2],l=e[i+3],128==(192&u)&&128==(192&c)&&128==(192&l)&&(f=(15&o)<<18|(63&u)<<12|(63&c)<<6|63&l)>65535&&f<1114112&&(a=f)}}null===a?(a=65533,s=1):a>65535&&(a-=65536,n.push(a>>>10&1023|55296),a=56320|1023&a),n.push(a),i+=s}return D(n)}function D(e){var t=e.length;if(t<=K)return String.fromCharCode.apply(String,e);for(var r="",n=0;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=K));return r}function C(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function F(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function O(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=t;o<r;++o)i+=N(e[o]);return i}function j(e,t,r){for(var n=e.slice(t,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function R(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function B(e,t,r,n,o,a){if(!i.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>o||t<a)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function P(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function T(e,t,r,n,i){return t=+t,r>>>=0,i||P(e,t,r,4,3.4028234663852886e38,-3.4028234663852886e38),H.write(e,t,r,n,23,4),r+4}function I(e,t,r,n,i){return t=+t,r>>>=0,i||P(e,t,r,8,1.7976931348623157e308,-1.7976931348623157e308),H.write(e,t,r,n,52,8),r+8}function L(e){if((e=e.trim().replace(Q,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}function N(e){return e<16?"0"+e.toString(16):e.toString(16)}function M(e,t){t=t||1/0;for(var r,n=e.length,i=null,o=[],a=0;a<n;++a){if((r=e.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function q(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function $(e,t){for(var r,n,i,o=[],a=0;a<e.length&&!((t-=2)<0);++a)n=(r=e.charCodeAt(a))>>8,i=r%256,o.push(i),o.push(n);return o}function W(e){return G.toByteArray(L(e))}function U(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function z(e){return"function"==typeof ArrayBuffer.isView&&ArrayBuffer.isView(e)}function V(e){return e!==e}var G=e("base64-js"),H=e("ieee754");r.Buffer=i,r.SlowBuffer=function(e){return+e!=e&&(e=0),i.alloc(+e)},r.INSPECT_MAX_BYTES=50;var J=2147483647;r.kMaxLength=J,i.TYPED_ARRAY_SUPPORT=function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()}catch(e){return!1}}(),i.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),"undefined"!=typeof Symbol&&Symbol.species&&i[Symbol.species]===i&&Object.defineProperty(i,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),i.poolSize=8192,i.from=function(e,t,r){return o(e,t,r)},i.prototype.__proto__=Uint8Array.prototype,i.__proto__=Uint8Array,i.alloc=function(e,t,r){return s(e,t,r)},i.allocUnsafe=function(e){return u(e)},i.allocUnsafeSlow=function(e){return u(e)},i.isBuffer=function(e){return null!=e&&!0===e._isBuffer},i.compare=function(e,t){if(!i.isBuffer(e)||!i.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,o=0,a=Math.min(r,n);o<a;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0},i.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},i.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return i.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=i.allocUnsafe(t),o=0;for(r=0;r<e.length;++r){var a=e[r];if(!i.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(n,o),o+=a.length}return n},i.byteLength=h,i.prototype._isBuffer=!0,i.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)v(this,t,t+1);return this},i.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},i.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},i.prototype.toString=function(){var e=this.length;return 0===e?"":0===arguments.length?A(this,0,e):m.apply(this,arguments)},i.prototype.equals=function(e){if(!i.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===i.compare(this,e)},i.prototype.inspect=function(){var e="",t=r.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},i.prototype.compare=function(e,t,r,n,o){if(!i.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),t<0||r>e.length||n<0||o>this.length)throw new RangeError("out of range index");if(n>=o&&t>=r)return 0;if(n>=o)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,o>>>=0,this===e)return 0;for(var a=o-n,s=r-t,u=Math.min(a,s),c=this.slice(n,o),l=e.slice(t,r),f=0;f<u;++f)if(c[f]!==l[f]){a=c[f],s=l[f];break}return a<s?-1:s<a?1:0},i.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},i.prototype.indexOf=function(e,t,r){return y(this,e,t,r,!0)},i.prototype.lastIndexOf=function(e,t,r){return y(this,e,t,r,!1)},i.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return b(this,e,t,r);case"utf8":case"utf-8":return _(this,e,t,r);case"ascii":return x(this,e,t,r);case"latin1":case"binary":return w(this,e,t,r);case"base64":return k(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},i.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var K=4096;i.prototype.slice=function(e,t){var r=this.length;e=~~e,t=void 0===t?r:~~t,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),t<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);var n=this.subarray(e,t);return n.__proto__=i.prototype,n},i.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||R(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},i.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||R(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},i.prototype.readUInt8=function(e,t){return e>>>=0,t||R(e,1,this.length),this[e]},i.prototype.readUInt16LE=function(e,t){return e>>>=0,t||R(e,2,this.length),this[e]|this[e+1]<<8},i.prototype.readUInt16BE=function(e,t){return e>>>=0,t||R(e,2,this.length),this[e]<<8|this[e+1]},i.prototype.readUInt32LE=function(e,t){return e>>>=0,t||R(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},i.prototype.readUInt32BE=function(e,t){return e>>>=0,t||R(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},i.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||R(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n},i.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||R(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o},i.prototype.readInt8=function(e,t){return e>>>=0,t||R(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},i.prototype.readInt16LE=function(e,t){e>>>=0,t||R(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},i.prototype.readInt16BE=function(e,t){e>>>=0,t||R(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},i.prototype.readInt32LE=function(e,t){return e>>>=0,t||R(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},i.prototype.readInt32BE=function(e,t){return e>>>=0,t||R(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},i.prototype.readFloatLE=function(e,t){return e>>>=0,t||R(e,4,this.length),H.read(this,e,!0,23,4)},i.prototype.readFloatBE=function(e,t){return e>>>=0,t||R(e,4,this.length),H.read(this,e,!1,23,4)},i.prototype.readDoubleLE=function(e,t){return e>>>=0,t||R(e,8,this.length),H.read(this,e,!0,52,8)},i.prototype.readDoubleBE=function(e,t){return e>>>=0,t||R(e,8,this.length),H.read(this,e,!1,52,8)},i.prototype.writeUIntLE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||B(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},i.prototype.writeUIntBE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||B(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},i.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,1,255,0),this[t]=255&e,t+1},i.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},i.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},i.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},i.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},i.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var i=Math.pow(2,8*r-1);B(this,e,t,r,i-1,-i)}var o=0,a=1,s=0;for(this[t]=255&e;++o<r&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},i.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var i=Math.pow(2,8*r-1);B(this,e,t,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},i.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},i.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},i.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},i.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},i.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},i.prototype.writeFloatLE=function(e,t,r){return T(this,e,t,!0,r)},i.prototype.writeFloatBE=function(e,t,r){return T(this,e,t,!1,r)},i.prototype.writeDoubleLE=function(e,t,r){return I(this,e,t,!0,r)},i.prototype.writeDoubleBE=function(e,t,r){return I(this,e,t,!1,r)},i.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},i.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var o=e.charCodeAt(0);o<256&&(e=o)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!i.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0);var a;if("number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var s=i.isBuffer(e)?e:new i(e,n),u=s.length;for(a=0;a<r-t;++a)this[a+t]=s[a%u]}return this};var Q=/[^+/0-9A-Za-z-_]/g},{"base64-js":2,ieee754:22}],6:[function(e,t,r){(function(e){function t(e){return Object.prototype.toString.call(e)}r.isArray=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===t(e)},r.isBoolean=function(e){return"boolean"==typeof e},r.isNull=function(e){return null===e},r.isNullOrUndefined=function(e){return null==e},r.isNumber=function(e){return"number"==typeof e},r.isString=function(e){return"string"==typeof e},r.isSymbol=function(e){return"symbol"==typeof e},r.isUndefined=function(e){return void 0===e},r.isRegExp=function(e){return"[object RegExp]"===t(e)},r.isObject=function(e){return"object"==typeof e&&null!==e},r.isDate=function(e){return"[object Date]"===t(e)},r.isError=function(e){return"[object Error]"===t(e)||e instanceof Error},r.isFunction=function(e){return"function"==typeof e},r.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},r.isBuffer=e.isBuffer}).call(this,{isBuffer:e("../../is-buffer/index.js")})},{"../../is-buffer/index.js":26}],7:[function(e,t,r){function n(e){o.call(this,e),this._options=e,this._iterator=null,this._operations=[]}var i=e("util"),o=e("abstract-leveldown").AbstractIterator;i.inherits(n,o),n.prototype.setDb=function(e){var t=this._iterator=e.iterator(this._options);this._operations.forEach(function(e){t[e.method].apply(t,e.args)})},n.prototype._operation=function(e,t){if(this._iterator)return this._iterator[e].apply(this._iterator,t);this._operations.push({method:e,args:t})},"next end".split(" ").forEach(function(e){n.prototype["_"+e]=function(){this._operation(e,arguments)}}),t.exports=n},{"abstract-leveldown":12,util:114}],8:[function(e,t,r){(function(r,n){function i(e){a.call(this,"string"==typeof e?e:""),this._db=void 0,this._operations=[],this._iterators=[]}var o=e("util"),a=e("abstract-leveldown").AbstractLevelDOWN,s=e("./deferred-iterator");o.inherits(i,a),i.prototype.setDb=function(e){this._db=e,this._operations.forEach(function(t){e[t.method].apply(e,t.args)}),this._iterators.forEach(function(t){t.setDb(e)})},i.prototype._open=function(e,t){return n.nextTick(t)},i.prototype._operation=function(e,t){if(this._db)return this._db[e].apply(this._db,t);this._operations.push({method:e,args:t})},"put get del batch approximateSize".split(" ").forEach(function(e){i.prototype["_"+e]=function(){this._operation(e,arguments)}}),i.prototype._isBuffer=function(e){return r.isBuffer(e)},i.prototype._iterator=function(e){if(this._db)return this._db.iterator.apply(this._db,arguments);var t=new s(e);return this._iterators.push(t),t},t.exports=i,t.exports.DeferredIterator=s}).call(this,{isBuffer:e("../is-buffer/index.js")},e("_process"))},{"../is-buffer/index.js":26,"./deferred-iterator":7,_process:70,"abstract-leveldown":12,util:114}],9:[function(e,t,r){(function(e){function r(e){this._db=e,this._operations=[],this._written=!1}r.prototype._checkWritten=function(){if(this._written)throw new Error("write() already called on this batch")},r.prototype.put=function(e,t){this._checkWritten();var r=this._db._checkKey(e,"key",this._db._isBuffer);if(r)throw r;return this._db._isBuffer(e)||(e=String(e)),this._db._isBuffer(t)||(t=String(t)),"function"==typeof this._put?this._put(e,t):this._operations.push({type:"put",key:e,value:t}),this},r.prototype.del=function(e){this._checkWritten();var t=this._db._checkKey(e,"key",this._db._isBuffer);if(t)throw t;return this._db._isBuffer(e)||(e=String(e)),"function"==typeof this._del?this._del(e):this._operations.push({type:"del",key:e}),this},r.prototype.clear=function(){return this._checkWritten(),this._operations=[],"function"==typeof this._clear&&this._clear(),this},r.prototype.write=function(t,r){if(this._checkWritten(),"function"==typeof t&&(r=t),"function"!=typeof r)throw new Error("write() requires a callback argument");return"object"!=typeof t&&(t={}),this._written=!0,"function"==typeof this._write?this._write(r):"function"==typeof this._db._batch?this._db._batch(this._operations,t,r):void e.nextTick(r)},t.exports=r}).call(this,e("_process"))},{_process:70}],10:[function(e,t,r){(function(e){function r(e){this.db=e,this._ended=!1,this._nexting=!1}r.prototype.next=function(t){var r=this;if("function"!=typeof t)throw new Error("next() requires a callback argument");return r._ended?t(new Error("cannot call next() after end()")):r._nexting?t(new Error("cannot call next() before previous next() has completed")):(r._nexting=!0,"function"==typeof r._next?r._next(function(){r._nexting=!1,t.apply(null,arguments)}):void e.nextTick(function(){r._nexting=!1,t()}))},r.prototype.end=function(t){if("function"!=typeof t)throw new Error("end() requires a callback argument");return this._ended?t(new Error("end() already called on iterator")):(this._ended=!0,"function"==typeof this._end?this._end(t):void e.nextTick(t))},t.exports=r}).call(this,e("_process"))},{_process:70}],11:[function(e,t,r){(function(r,n){function i(e){if(!arguments.length||void 0===e)throw new Error("constructor requires at least a location argument");if("string"!=typeof e)throw new Error("constructor requires a location string argument");this.location=e,this.status="new"}var o=e("xtend"),a=e("./abstract-iterator"),s=e("./abstract-chained-batch");i.prototype.open=function(e,t){var r=this,i=this.status;if("function"==typeof e&&(t=e),"function"!=typeof t)throw new Error("open() requires a callback argument");"object"!=typeof e&&(e={}),e.createIfMissing=0!=e.createIfMissing,e.errorIfExists=!!e.errorIfExists,"function"==typeof this._open?(this.status="opening",this._open(e,function(e){if(e)return r.status=i,t(e);r.status="open",t()})):(this.status="open",n.nextTick(t))},i.prototype.close=function(e){var t=this,r=this.status;if("function"!=typeof e)throw new Error("close() requires a callback argument");"function"==typeof this._close?(this.status="closing",this._close(function(n){if(n)return t.status=r,e(n);t.status="closed",e()})):(this.status="closed",n.nextTick(e))},i.prototype.get=function(e,t,r){var i;if("function"==typeof t&&(r=t),"function"!=typeof r)throw new Error("get() requires a callback argument");return(i=this._checkKey(e,"key",this._isBuffer))?r(i):(this._isBuffer(e)||(e=String(e)),"object"!=typeof t&&(t={}),t.asBuffer=0!=t.asBuffer,"function"==typeof this._get?this._get(e,t,r):void n.nextTick(function(){r(new Error("NotFound"))}))},i.prototype.put=function(e,t,r,i){var o;if("function"==typeof r&&(i=r),"function"!=typeof i)throw new Error("put() requires a callback argument");return(o=this._checkKey(e,"key",this._isBuffer))?i(o):(this._isBuffer(e)||(e=String(e)),null==t||this._isBuffer(t)||n.browser||(t=String(t)),"object"!=typeof r&&(r={}),"function"==typeof this._put?this._put(e,t,r,i):void n.nextTick(i))},i.prototype.del=function(e,t,r){var i;if("function"==typeof t&&(r=t),"function"!=typeof r)throw new Error("del() requires a callback argument");return(i=this._checkKey(e,"key",this._isBuffer))?r(i):(this._isBuffer(e)||(e=String(e)),"object"!=typeof t&&(t={}),"function"==typeof this._del?this._del(e,t,r):void n.nextTick(r))},i.prototype.batch=function(e,t,r){if(!arguments.length)return this._chainedBatch();if("function"==typeof t&&(r=t),"function"==typeof e&&(r=e),"function"!=typeof r)throw new Error("batch(array) requires a callback argument");if(!Array.isArray(e))return r(new Error("batch(array) requires an array argument"));t&&"object"==typeof t||(t={});for(var i,o,a=0,s=e.length;a<s;a++)if("object"==typeof(i=e[a])){if(o=this._checkKey(i.type,"type",this._isBuffer))return r(o);if(o=this._checkKey(i.key,"key",this._isBuffer))return r(o)}if("function"==typeof this._batch)return this._batch(e,t,r);n.nextTick(r)},i.prototype.approximateSize=function(e,t,r){if(null==e||null==t||"function"==typeof e||"function"==typeof t)throw new Error("approximateSize() requires valid `start`, `end` and `callback` arguments");if("function"!=typeof r)throw new Error("approximateSize() requires a callback argument");if(this._isBuffer(e)||(e=String(e)),this._isBuffer(t)||(t=String(t)),"function"==typeof this._approximateSize)return this._approximateSize(e,t,r);n.nextTick(function(){r(null,0)})},i.prototype._setupIteratorOptions=function(e){var t=this;return e=o(e),["start","end","gt","gte","lt","lte"].forEach(function(r){e[r]&&t._isBuffer(e[r])&&0===e[r].length&&delete e[r]}),e.reverse=!!e.reverse,e.keys=0!=e.keys,e.values=0!=e.values,e.limit="limit"in e?e.limit:-1,e.keyAsBuffer=0!=e.keyAsBuffer,e.valueAsBuffer=0!=e.valueAsBuffer,e},i.prototype.iterator=function(e){return"object"!=typeof e&&(e={}),e=this._setupIteratorOptions(e),"function"==typeof this._iterator?this._iterator(e):new a(this)},i.prototype._chainedBatch=function(){return new s(this)},i.prototype._isBuffer=function(e){return r.isBuffer(e)},i.prototype._checkKey=function(e,t){if(null===e||void 0===e)return new Error(t+" cannot be `null` or `undefined`");if(this._isBuffer(e)){if(0===e.length)return new Error(t+" cannot be an empty Buffer")}else if(""===String(e))return new Error(t+" cannot be an empty String")},t.exports=i}).call(this,{isBuffer:e("../../../is-buffer/index.js")},e("_process"))},{"../../../is-buffer/index.js":26,"./abstract-chained-batch":9,"./abstract-iterator":10,_process:70,xtend:120}],12:[function(e,t,r){r.AbstractLevelDOWN=e("./abstract-leveldown"),r.AbstractIterator=e("./abstract-iterator"),r.AbstractChainedBatch=e("./abstract-chained-batch"),r.isLevelDOWN=e("./is-leveldown")},{"./abstract-chained-batch":9,"./abstract-iterator":10,"./abstract-leveldown":11,"./is-leveldown":13}],13:[function(e,t,r){var n=e("./abstract-leveldown");t.exports=function(e){return!(!e||"object"!=typeof e)&&Object.keys(n.prototype).filter(function(e){return"_"!=e[0]&&"approximateSize"!=e}).every(function(t){return"function"==typeof e[t]})}},{"./abstract-leveldown":11}],14:[function(e,t,r){"use strict";function n(e){if(this._capacity=a(e),this._length=0,this._front=0,s(e)){for(var t=e.length,r=0;r<t;++r)this[r]=e[r];this._length=t}}function i(e,t,r,n,i){for(var o=0;o<i;++o)r[o+n]=e[o+t],e[o+t]=void 0}function o(e){return e>>>=0,e-=1,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}function a(e){if("number"!=typeof e){if(!s(e))return 16;e=e.length}return o(Math.min(Math.max(16,e),1073741824))}n.prototype.toArray=function(){for(var e=this._length,t=new Array(e),r=this._front,n=this._capacity,i=0;i<e;++i)t[i]=this[r+i&n-1];return t},n.prototype.push=function(e){var t=arguments.length,r=this._length;if(t>1){var n=this._capacity;if(r+t>n){for(o=0;o<t;++o)this._checkCapacity(r+1),this[i=this._front+r&this._capacity-1]=arguments[o],r++,this._length=r;return r}for(var i=this._front,o=0;o<t;++o)this[i+r&n-1]=arguments[o],i++;return this._length=r+t,r+t}return 0===t?r:(this._checkCapacity(r+1),this[o=this._front+r&this._capacity-1]=e,this._length=r+1,r+1)},n.prototype.pop=function(){var e=this._length;if(0!==e){var t=this._front+e-1&this._capacity-1,r=this[t];return this[t]=void 0,this._length=e-1,r}},n.prototype.shift=function(){var e=this._length;if(0!==e){var t=this._front,r=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length=e-1,r}},n.prototype.unshift=function(e){var t=this._length,r=arguments.length;if(r>1){if(t+r>(a=this._capacity)){for(i=r-1;i>=0;i--){this._checkCapacity(t+1);a=this._capacity;this[o=(this._front-1&a-1^a)-a]=arguments[i],t++,this._length=t,this._front=o}return t}for(var n=this._front,i=r-1;i>=0;i--){var o=(n-1&a-1^a)-a;this[o]=arguments[i],n=o}return this._front=n,this._length=t+r,t+r}if(0===r)return t;this._checkCapacity(t+1);var a=this._capacity;return this[i=(this._front-1&a-1^a)-a]=e,this._length=t+1,this._front=i,t+1},n.prototype.peekBack=function(){var e=this._length;if(0!==e)return this[this._front+e-1&this._capacity-1]},n.prototype.peekFront=function(){if(0!==this._length)return this[this._front]},n.prototype.get=function(e){var t=e;if(t===(0|t)){var r=this._length;if(t<0&&(t+=r),!(t<0||t>=r))return this[this._front+t&this._capacity-1]}},n.prototype.isEmpty=function(){return 0===this._length},n.prototype.clear=function(){for(var e=this._length,t=this._front,r=this._capacity,n=0;n<e;++n)this[t+n&r-1]=void 0;this._length=0,this._front=0},n.prototype.toString=function(){return this.toArray().toString()},n.prototype.valueOf=n.prototype.toString,n.prototype.removeFront=n.prototype.shift,n.prototype.removeBack=n.prototype.pop,n.prototype.insertFront=n.prototype.unshift,n.prototype.insertBack=n.prototype.push,n.prototype.enqueue=n.prototype.push,n.prototype.dequeue=n.prototype.shift,n.prototype.toJSON=n.prototype.toArray,Object.defineProperty(n.prototype,"length",{get:function(){return this._length},set:function(){throw new RangeError("")}}),n.prototype._checkCapacity=function(e){this._capacity<e&&this._resizeTo(a(1.5*this._capacity+16))},n.prototype._resizeTo=function(e){var t=this._capacity;this._capacity=e;var r=this._front,n=this._length;r+n>t&&i(this,0,this,t,r+n&t-1)};var s=Array.isArray;t.exports=n},{}],15:[function(e,t,r){function n(e,t,r){a(this,{type:e,name:e,cause:"string"!=typeof t?t:r,message:t&&"string"!=typeof t?t.message:t},"ewr")}function i(e,t){Error.call(this),Error.captureStackTrace&&Error.captureStackTrace(this,arguments.callee),n.call(this,"CustomError",e,t)}function o(e,t,r){var o=function(r,i){n.call(this,t,r,i),"FilesystemError"==t&&(this.code=this.cause.code,this.path=this.cause.path,this.errno=this.cause.errno,this.message=(e.errno[this.cause.errno]?e.errno[this.cause.errno].description:this.cause.message)+(this.cause.path?" ["+this.cause.path+"]":"")),Error.call(this),Error.captureStackTrace&&Error.captureStackTrace(this,arguments.callee)};return o.prototype=r?new r:new i,o}var a=e("prr");i.prototype=new Error,t.exports=function(e){var t=function(t,r){return o(e,t,r)};return{CustomError:i,FilesystemError:t("FilesystemError"),createError:t}}},{prr:17}],16:[function(e,t,r){var n=t.exports.all=[{errno:-2,code:"ENOENT",description:"no such file or directory"},{errno:-1,code:"UNKNOWN",description:"unknown error"},{errno:0,code:"OK",description:"success"},{errno:1,code:"EOF",description:"end of file"},{errno:2,code:"EADDRINFO",description:"getaddrinfo error"},{errno:3,code:"EACCES",description:"permission denied"},{errno:4,code:"EAGAIN",description:"resource temporarily unavailable"},{errno:5,code:"EADDRINUSE",description:"address already in use"},{errno:6,code:"EADDRNOTAVAIL",description:"address not available"},{errno:7,code:"EAFNOSUPPORT",description:"address family not supported"},{errno:8,code:"EALREADY",description:"connection already in progress"},{errno:9,code:"EBADF",description:"bad file descriptor"},{errno:10,code:"EBUSY",description:"resource busy or locked"},{errno:11,code:"ECONNABORTED",description:"software caused connection abort"},{errno:12,code:"ECONNREFUSED",description:"connection refused"},{errno:13,code:"ECONNRESET",description:"connection reset by peer"},{errno:14,code:"EDESTADDRREQ",description:"destination address required"},{errno:15,code:"EFAULT",description:"bad address in system call argument"},{errno:16,code:"EHOSTUNREACH",description:"host is unreachable"},{errno:17,code:"EINTR",description:"interrupted system call"},{errno:18,code:"EINVAL",description:"invalid argument"},{errno:19,code:"EISCONN",description:"socket is already connected"},{errno:20,code:"EMFILE",description:"too many open files"},{errno:21,code:"EMSGSIZE",description:"message too long"},{errno:22,code:"ENETDOWN",description:"network is down"},{errno:23,code:"ENETUNREACH",description:"network is unreachable"},{errno:24,code:"ENFILE",description:"file table overflow"},{errno:25,code:"ENOBUFS",description:"no buffer space available"},{errno:26,code:"ENOMEM",description:"not enough memory"},{errno:27,code:"ENOTDIR",description:"not a directory"},{errno:28,code:"EISDIR",description:"illegal operation on a directory"},{errno:29,code:"ENONET",description:"machine is not on the network"},{errno:31,code:"ENOTCONN",description:"socket is not connected"},{errno:32,code:"ENOTSOCK",description:"socket operation on non-socket"},{errno:33,code:"ENOTSUP",description:"operation not supported on socket"},{errno:34,code:"ENOENT",description:"no such file or directory"},{errno:35,code:"ENOSYS",description:"function not implemented"},{errno:36,code:"EPIPE",description:"broken pipe"},{errno:37,code:"EPROTO",description:"protocol error"},{errno:38,code:"EPROTONOSUPPORT",description:"protocol not supported"},{errno:39,code:"EPROTOTYPE",description:"protocol wrong type for socket"},{errno:40,code:"ETIMEDOUT",description:"connection timed out"},{errno:41,code:"ECHARSET",description:"invalid Unicode character"},{errno:42,code:"EAIFAMNOSUPPORT",description:"address family for hostname not supported"},{errno:44,code:"EAISERVICE",description:"servname not supported for ai_socktype"},{errno:45,code:"EAISOCKTYPE",description:"ai_socktype not supported"},{errno:46,code:"ESHUTDOWN",description:"cannot send after transport endpoint shutdown"},{errno:47,code:"EEXIST",description:"file already exists"},{errno:48,code:"ESRCH",description:"no such process"},{errno:49,code:"ENAMETOOLONG",description:"name too long"},{errno:50,code:"EPERM",description:"operation not permitted"},{errno:51,code:"ELOOP",description:"too many symbolic links encountered"},{errno:52,code:"EXDEV",description:"cross-device link not permitted"},{errno:53,code:"ENOTEMPTY",description:"directory not empty"},{errno:54,code:"ENOSPC",description:"no space left on device"},{errno:55,code:"EIO",description:"i/o error"},{errno:56,code:"EROFS",description:"read-only file system"},{errno:57,code:"ENODEV",description:"no such device"},{errno:58,code:"ESPIPE",description:"invalid seek"},{errno:59,code:"ECANCELED",description:"operation canceled"}];t.exports.errno={},t.exports.code={},n.forEach(function(e){t.exports.errno[e.errno]=e,t.exports.code[e.code]=e}),t.exports.custom=e("./custom")(t.exports),t.exports.create=t.exports.custom.createError},{"./custom":15}],17:[function(e,t,r){!function(e,r,n){void 0!==t&&t.exports?t.exports=n():r.prr=n()}(0,this,function(){var e="function"==typeof Object.defineProperty?function(e,t,r){return Object.defineProperty(e,t,r),e}:function(e,t,r){return e[t]=r.value,e},t=function(e,t){var r="object"==typeof t,n=!r&&"string"==typeof t,i=function(e){return r?!!t[e]:!!n&&t.indexOf(e[0])>-1};return{enumerable:i("enumerable"),configurable:i("configurable"),writable:i("writable"),value:e}};return function(r,n,i,o){var a;if(o=t(i,o),"object"==typeof n){for(a in n)Object.hasOwnProperty.call(n,a)&&(o.value=n[a],e(r,a,o));return r}return e(r,n,o)}})},{}],18:[function(e,t,r){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(e){return"function"==typeof e}function o(e){return"number"==typeof e}function a(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!o(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,r,n,o,u,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||a(this._events.error)&&!this._events.error.length)){if((t=arguments[1])instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}if(r=this._events[e],s(r))return!1;if(i(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:o=Array.prototype.slice.call(arguments,1),r.apply(this,o)}else if(a(r))for(o=Array.prototype.slice.call(arguments,1),n=(c=r.slice()).length,u=0;u<n;u++)c[u].apply(this,o);return!0},n.prototype.addListener=function(e,t){var r;if(!i(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,i(t.listener)?t.listener:t),this._events[e]?a(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,a(this._events[e])&&!this._events[e].warned&&(r=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners)&&r>0&&this._events[e].length>r&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace()),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function r(){this.removeListener(e,r),n||(n=!0,t.apply(this,arguments))}if(!i(t))throw TypeError("listener must be a function");var n=!1;return r.listener=t,this.on(e,r),this},n.prototype.removeListener=function(e,t){var r,n,o,s;if(!i(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(r=this._events[e],o=r.length,n=-1,r===t||i(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(a(r)){for(s=o;s-- >0;)if(r[s]===t||r[s].listener&&r[s].listener===t){n=s;break}if(n<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(n,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[e],i(r))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){return this._events&&this._events[e]?i(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(i(t))return 1;if(t)return t.length}return 0},n.listenerCount=function(e,t){return e.listenerCount(t)}},{}],19:[function(e,t,r){"use strict";function n(e,t,r,n,i,o){this._color=e,this.key=t,this.value=r,this.left=n,this.right=i,this._count=o}function i(e){return new n(e._color,e.key,e.value,e.left,e.right,e._count)}function o(e,t){return new n(e,t.key,t.value,t.left,t.right,t._count)}function a(e){e._count=1+(e.left?e.left._count:0)+(e.right?e.right._count:0)}function s(e,t){this._compare=e,this.root=t}function u(e,t){if(t.left&&(r=u(e,t.left)))return r;var r=e(t.key,t.value);return r||(t.right?u(e,t.right):void 0)}function c(e,t,r,n){if(t(e,n.key)<=0){if(n.left&&(i=c(e,t,r,n.left)))return i;var i=r(n.key,n.value);if(i)return i}if(n.right)return c(e,t,r,n.right)}function l(e,t,r,n,i){var o,a=r(e,i.key),s=r(t,i.key);if(a<=0){if(i.left&&(o=l(e,t,r,n,i.left)))return o;if(s>0&&(o=n(i.key,i.value)))return o}if(s>0&&i.right)return l(e,t,r,n,i.right)}function f(e,t){this.tree=e,this._stack=t}function p(e,t){e.key=t.key,e.value=t.value,e.left=t.left,e.right=t.right,e._color=t._color,e._count=t._count}function d(e){for(var t,r,n,s,u=e.length-1;u>=0;--u){if(t=e[u],0===u)return void(t._color=v);if((r=e[u-1]).left===t){if((n=r.right).right&&n.right._color===m)return n=r.right=i(n),s=n.right=i(n.right),r.right=n.left,n.left=r,n.right=s,n._color=r._color,t._color=v,r._color=v,s._color=v,a(r),a(n),u>1&&((c=e[u-2]).left===r?c.left=n:c.right=n),void(e[u-1]=n);if(n.left&&n.left._color===m)return n=r.right=i(n),s=n.left=i(n.left),r.right=s.left,n.left=s.right,s.left=r,s.right=n,s._color=r._color,r._color=v,n._color=v,t._color=v,a(r),a(n),a(s),u>1&&((c=e[u-2]).left===r?c.left=s:c.right=s),void(e[u-1]=s);if(n._color===v){if(r._color===m)return r._color=v,void(r.right=o(m,n));r.right=o(m,n);continue}n=i(n),r.right=n.left,n.left=r,n._color=r._color,r._color=m,a(r),a(n),u>1&&((c=e[u-2]).left===r?c.left=n:c.right=n),e[u-1]=n,e[u]=r,u+1<e.length?e[u+1]=t:e.push(t),u+=2}else{if((n=r.left).left&&n.left._color===m)return n=r.left=i(n),s=n.left=i(n.left),r.left=n.right,n.right=r,n.left=s,n._color=r._color,t._color=v,r._color=v,s._color=v,a(r),a(n),u>1&&((c=e[u-2]).right===r?c.right=n:c.left=n),void(e[u-1]=n);if(n.right&&n.right._color===m)return n=r.left=i(n),s=n.right=i(n.right),r.left=s.right,n.right=s.left,s.right=r,s.left=n,s._color=r._color,r._color=v,n._color=v,t._color=v,a(r),a(n),a(s),u>1&&((c=e[u-2]).right===r?c.right=s:c.left=s),void(e[u-1]=s);if(n._color===v){if(r._color===m)return r._color=v,void(r.left=o(m,n));r.left=o(m,n);continue}if(n=i(n),r.left=n.right,n.right=r,n._color=r._color,r._color=m,a(r),a(n),u>1){var c=e[u-2];c.right===r?c.right=n:c.left=n}e[u-1]=n,e[u]=r,u+1<e.length?e[u+1]=t:e.push(t),u+=2}}}function h(e,t){return e<t?-1:e>t?1:0}t.exports=function(e){return new s(e||h,null)};var m=0,v=1,y=s.prototype;Object.defineProperty(y,"keys",{get:function(){var e=[];return this.forEach(function(t,r){e.push(t)}),e}}),Object.defineProperty(y,"values",{get:function(){var e=[];return this.forEach(function(t,r){e.push(r)}),e}}),Object.defineProperty(y,"length",{get:function(){return this.root?this.root._count:0}}),y.insert=function(e,t){for(var r=this._compare,i=this.root,u=[],c=[];i;){var l=r(e,i.key);u.push(i),c.push(l),i=l<=0?i.left:i.right}u.push(new n(m,e,t,null,null,1));for(f=u.length-2;f>=0;--f){i=u[f];c[f]<=0?u[f]=new n(i._color,i.key,i.value,u[f+1],i.right,i._count+1):u[f]=new n(i._color,i.key,i.value,i.left,u[f+1],i._count+1)}for(var f=u.length-1;f>1;--f){var p=u[f-1],i=u[f];if(p._color===v||i._color===v)break;var d=u[f-2];if(d.left===p)if(p.left===i){if(!(h=d.right)||h._color!==m){d._color=m,d.left=p.right,p._color=v,p.right=d,u[f-2]=p,u[f-1]=i,a(d),a(p),f>=3&&((y=u[f-3]).left===d?y.left=p:y.right=p);break}p._color=v,d.right=o(v,h),d._color=m,f-=1}else{if(!(h=d.right)||h._color!==m){p.right=i.left,d._color=m,d.left=i.right,i._color=v,i.left=p,i.right=d,u[f-2]=i,u[f-1]=p,a(d),a(p),a(i),f>=3&&((y=u[f-3]).left===d?y.left=i:y.right=i);break}p._color=v,d.right=o(v,h),d._color=m,f-=1}else if(p.right===i){if(!(h=d.left)||h._color!==m){d._color=m,d.right=p.left,p._color=v,p.left=d,u[f-2]=p,u[f-1]=i,a(d),a(p),f>=3&&((y=u[f-3]).right===d?y.right=p:y.left=p);break}p._color=v,d.left=o(v,h),d._color=m,f-=1}else{var h=d.left;if(!h||h._color!==m){if(p.left=i.right,d._color=m,d.right=i.left,i._color=v,i.right=p,i.left=d,u[f-2]=i,u[f-1]=p,a(d),a(p),a(i),f>=3){var y=u[f-3];y.right===d?y.right=i:y.left=i}break}p._color=v,d.left=o(v,h),d._color=m,f-=1}}return u[0]._color=v,new s(r,u[0])},y.forEach=function(e,t,r){if(this.root)switch(arguments.length){case 1:return u(e,this.root);case 2:return c(t,this._compare,e,this.root);case 3:if(this._compare(t,r)>=0)return;return l(t,r,this._compare,e,this.root)}},Object.defineProperty(y,"begin",{get:function(){for(var e=[],t=this.root;t;)e.push(t),t=t.left;return new f(this,e)}}),Object.defineProperty(y,"end",{get:function(){for(var e=[],t=this.root;t;)e.push(t),t=t.right;return new f(this,e)}}),y.at=function(e){if(e<0)return new f(this,[]);for(var t=this.root,r=[];;){if(r.push(t),t.left){if(e<t.left._count){t=t.left;continue}e-=t.left._count}if(!e)return new f(this,r);if(e-=1,!t.right)break;if(e>=t.right._count)break;t=t.right}return new f(this,[])},y.ge=function(e){for(var t=this._compare,r=this.root,n=[],i=0;r;){var o=t(e,r.key);n.push(r),o<=0&&(i=n.length),r=o<=0?r.left:r.right}return n.length=i,new f(this,n)},y.gt=function(e){for(var t=this._compare,r=this.root,n=[],i=0;r;){var o=t(e,r.key);n.push(r),o<0&&(i=n.length),r=o<0?r.left:r.right}return n.length=i,new f(this,n)},y.lt=function(e){for(var t=this._compare,r=this.root,n=[],i=0;r;){var o=t(e,r.key);n.push(r),o>0&&(i=n.length),r=o<=0?r.left:r.right}return n.length=i,new f(this,n)},y.le=function(e){for(var t=this._compare,r=this.root,n=[],i=0;r;){var o=t(e,r.key);n.push(r),o>=0&&(i=n.length),r=o<0?r.left:r.right}return n.length=i,new f(this,n)},y.find=function(e){for(var t=this._compare,r=this.root,n=[];r;){var i=t(e,r.key);if(n.push(r),0===i)return new f(this,n);r=i<=0?r.left:r.right}return new f(this,[])},y.remove=function(e){var t=this.find(e);return t?t.remove():this},y.get=function(e){for(var t=this._compare,r=this.root;r;){var n=t(e,r.key);if(0===n)return r.value;r=n<=0?r.left:r.right}};var g=f.prototype;Object.defineProperty(g,"valid",{get:function(){return this._stack.length>0}}),Object.defineProperty(g,"node",{get:function(){return this._stack.length>0?this._stack[this._stack.length-1]:null},enumerable:!0}),g.clone=function(){return new f(this.tree,this._stack.slice())},g.remove=function(){var e=this._stack;if(0===e.length)return this.tree;var t=new Array(e.length),r=e[e.length-1];t[t.length-1]=new n(r._color,r.key,r.value,r.left,r.right,r._count);for(u=e.length-2;u>=0;--u)(r=e[u]).left===e[u+1]?t[u]=new n(r._color,r.key,r.value,t[u+1],r.right,r._count):t[u]=new n(r._color,r.key,r.value,r.left,t[u+1],r._count);if((r=t[t.length-1]).left&&r.right){var i=t.length;for(r=r.left;r.right;)t.push(r),r=r.right;var o=t[i-1];t.push(new n(r._color,o.key,o.value,r.left,r.right,r._count)),t[i-1].key=r.key,t[i-1].value=r.value;for(u=t.length-2;u>=i;--u)r=t[u],t[u]=new n(r._color,r.key,r.value,r.left,t[u+1],r._count);t[i-1].left=t[i]}if((r=t[t.length-1])._color===m){var a=t[t.length-2];a.left===r?a.left=null:a.right===r&&(a.right=null),t.pop();for(u=0;u<t.length;++u)t[u]._count--;return new s(this.tree._compare,t[0])}if(r.left||r.right){r.left?p(r,r.left):r.right&&p(r,r.right),r._color=v;for(u=0;u<t.length-1;++u)t[u]._count--;return new s(this.tree._compare,t[0])}if(1===t.length)return new s(this.tree._compare,null);for(var u=0;u<t.length;++u)t[u]._count--;var c=t[t.length-2];return d(t),c.left===r?c.left=null:c.right=null,new s(this.tree._compare,t[0])},Object.defineProperty(g,"key",{get:function(){if(this._stack.length>0)return this._stack[this._stack.length-1].key},enumerable:!0}),Object.defineProperty(g,"value",{get:function(){if(this._stack.length>0)return this._stack[this._stack.length-1].value},enumerable:!0}),Object.defineProperty(g,"index",{get:function(){var e=0,t=this._stack;if(0===t.length){var r=this.tree.root;return r?r._count:0}t[t.length-1].left&&(e=t[t.length-1].left._count);for(var n=t.length-2;n>=0;--n)t[n+1]===t[n].right&&(++e,t[n].left&&(e+=t[n].left._count));return e},enumerable:!0}),g.next=function(){var e=this._stack;if(0!==e.length){var t=e[e.length-1];if(t.right)for(t=t.right;t;)e.push(t),t=t.left;else for(e.pop();e.length>0&&e[e.length-1].right===t;)t=e[e.length-1],e.pop()}},Object.defineProperty(g,"hasNext",{get:function(){var e=this._stack;if(0===e.length)return!1;if(e[e.length-1].right)return!0;for(var t=e.length-1;t>0;--t)if(e[t-1].left===e[t])return!0;return!1}}),g.update=function(e){var t=this._stack;if(0===t.length)throw new Error("Can't update empty node!");var r=new Array(t.length),i=t[t.length-1];r[r.length-1]=new n(i._color,i.key,e,i.left,i.right,i._count);for(var o=t.length-2;o>=0;--o)(i=t[o]).left===t[o+1]?r[o]=new n(i._color,i.key,i.value,r[o+1],i.right,i._count):r[o]=new n(i._color,i.key,i.value,i.left,r[o+1],i._count);return new s(this.tree._compare,r[0])},g.prev=function(){var e=this._stack;if(0!==e.length){var t=e[e.length-1];if(t.left)for(t=t.left;t;)e.push(t),t=t.right;else for(e.pop();e.length>0&&e[e.length-1].left===t;)t=e[e.length-1],e.pop()}},Object.defineProperty(g,"hasPrev",{get:function(){var e=this._stack;if(0===e.length)return!1;if(e[e.length-1].left)return!0;for(var t=e.length-1;t>0;--t)if(e[t-1].right===e[t])return!0;return!1}})},{}],20:[function(e,t,r){"use strict";t.exports="function"==typeof Symbol&&"symbol"==typeof Symbol("")},{}],21:[function(e,t,r){"use strict";t.exports=e("has-symbol-support-x")&&"symbol"==typeof Symbol.toStringTag},{"has-symbol-support-x":20}],22:[function(e,t,r){r.read=function(e,t,r,n,i){var o,a,s=8*i-n-1,u=(1<<s)-1,c=u>>1,l=-7,f=r?i-1:0,p=r?-1:1,d=e[t+f];for(f+=p,o=d&(1<<-l)-1,d>>=-l,l+=s;l>0;o=256*o+e[t+f],f+=p,l-=8);for(a=o&(1<<-l)-1,o>>=-l,l+=n;l>0;a=256*a+e[t+f],f+=p,l-=8);if(0===o)o=1-c;else{if(o===u)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),o-=c}return(d?-1:1)*a*Math.pow(2,o-n)},r.write=function(e,t,r,n,i,o){var a,s,u,c=8*o-i-1,l=(1<<c)-1,f=l>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,h=n?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=l):(a=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-a))<1&&(a--,u*=2),(t+=a+f>=1?p/u:p*Math.pow(2,1-f))*u>=2&&(a++,u/=2),a+f>=l?(s=0,a=l):a+f>=1?(s=(t*u-1)*Math.pow(2,i),a+=f):(s=t*Math.pow(2,f-1)*Math.pow(2,i),a=0));i>=8;e[r+d]=255&s,d+=h,s/=256,i-=8);for(a=a<<i|s,c+=i;c>0;e[r+d]=255&a,d+=h,a/=256,c-=8);e[r+d-h]|=128*m}},{}],23:[function(e,t,r){(function(e){"use strict";function r(){c=!0;for(var e,t,r=l.length;r;){for(t=l,l=[],e=-1;++e<r;)t[e]();r=l.length}c=!1}var n,i=e.MutationObserver||e.WebKitMutationObserver;if(i){var o=0,a=new i(r),s=e.document.createTextNode("");a.observe(s,{characterData:!0}),n=function(){s.data=o=++o%2}}else if(e.setImmediate||void 0===e.MessageChannel)n="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){r(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(r,0)};else{var u=new e.MessageChannel;u.port1.onmessage=r,n=function(){u.port2.postMessage(0)}}var c,l=[];t.exports=function(e){1!==l.push(e)||c||n()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],24:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},{}],25:[function(e,t,r){"use strict";var n,i,o,a=e("is-object-like-x"),s="function"==typeof ArrayBuffer;if(s){if(e("has-to-string-tag-x"))try{o=Object.getOwnPropertyDescriptor(ArrayBuffer.prototype,"byteLength").get,o="number"==typeof o.call(new ArrayBuffer(4))&&o}catch(e){}!1===Boolean(o)&&(n=e("to-string-tag-x"),i="[object ArrayBuffer]")}t.exports=function(e){if(!1===s||!1===a(e))return!1;if(!1===Boolean(o))return n(e)===i;try{return"number"==typeof o.call(e)}catch(e){}return!1}},{"has-to-string-tag-x":21,"is-object-like-x":28,"to-string-tag-x":110}],26:[function(e,t,r){function n(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function i(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&n(e.slice(0,0))}t.exports=function(e){return null!=e&&(n(e)||i(e)||!!e._isBuffer)}},{}],27:[function(e,t,r){"use strict";var n=Function.prototype.toString,i=e("to-string-tag-x"),o=e("has-to-string-tag-x"),a=e("is-primitive"),s=/^\s*class /,u=function(e){try{var t=n.call(e).replace(/\/\/.*\n/g,"").replace(/\/\*[.\s\S]*\*\//g,"").replace(/\n/gm," ").replace(/ {2}/g," ");return s.test(t)}catch(e){}return!1},c=function(e){try{return!u(e)&&(n.call(e),!0)}catch(e){}return!1};t.exports=function(e){if(a(e))return!1;if(o)return c(e);if(u(e))return!1;var t=i(e);return"[object Function]"===t||"[object GeneratorFunction]"===t||"[object AsyncFunction]"===t}},{"has-to-string-tag-x":21,"is-primitive":29,"to-string-tag-x":110}],28:[function(e,t,r){"use strict";var n=e("is-function-x"),i=e("is-primitive");t.exports=function(e){return!1===i(e)&&!1===n(e)}},{"is-function-x":27,"is-primitive":29}],29:[function(e,t,r){"use strict";t.exports=function(e){return null==e||"function"!=typeof e&&"object"!=typeof e}},{}],30:[function(e,t,r){var n={}.toString;t.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},{}],31:[function(e,t,r){function n(e){this.opts=e||{},this.encodings=i}var i=e("./lib/encodings");t.exports=n,n.prototype._encoding=function(e){return"string"==typeof e&&(e=i[e]),e||(e=i.id),e},n.prototype._keyEncoding=function(e,t){return this._encoding(t&&t.keyEncoding||e&&e.keyEncoding||this.opts.keyEncoding)},n.prototype._valueEncoding=function(e,t){return this._encoding(t&&(t.valueEncoding||t.encoding)||e&&(e.valueEncoding||e.encoding)||this.opts.valueEncoding||this.opts.encoding)},n.prototype.encodeKey=function(e,t,r){return this._keyEncoding(t,r).encode(e)},n.prototype.encodeValue=function(e,t,r){return this._valueEncoding(t,r).encode(e)},n.prototype.decodeKey=function(e,t){return this._keyEncoding(t).decode(e)},n.prototype.decodeValue=function(e,t){return this._valueEncoding(t).decode(e)},n.prototype.encodeBatch=function(e,t){var r=this;return e.map(function(e){var n={type:e.type,key:r.encodeKey(e.key,t,e)};return r.keyAsBuffer(t,e)&&(n.keyEncoding="binary"),e.prefix&&(n.prefix=e.prefix),"value"in e&&(n.value=r.encodeValue(e.value,t,e),r.valueAsBuffer(t,e)&&(n.valueEncoding="binary")),n})};var o=["lt","gt","lte","gte","start","end"];n.prototype.encodeLtgt=function(e){var t=this,r={};return Object.keys(e).forEach(function(n){r[n]=o.indexOf(n)>-1?t.encodeKey(e[n],e):e[n]}),r},n.prototype.createStreamDecoder=function(e){var t=this;return e.keys&&e.values?function(r,n){return{key:t.decodeKey(r,e),value:t.decodeValue(n,e)}}:e.keys?function(r){return t.decodeKey(r,e)}:e.values?function(r,n){return t.decodeValue(n,e)}:function(){}},n.prototype.keyAsBuffer=function(e){return this._keyEncoding(e).buffer},n.prototype.valueAsBuffer=function(e){return this._valueEncoding(e).buffer}},{"./lib/encodings":32}],32:[function(e,t,r){(function(e){function t(t){return void 0===t||null===t||e.isBuffer(t)}r.utf8=r["utf-8"]={encode:function(e){return t(e)?e:String(e)},decode:function(e){return"string"==typeof e?e:String(e)},buffer:!1,type:"utf8"},r.json={encode:JSON.stringify,decode:JSON.parse,buffer:!1,type:"json"},r.binary={encode:function(r){return t(r)?r:new e(r)},decode:function(e){return e},buffer:!0,type:"binary"},r.none={encode:function(e){return e},decode:function(e){return e},buffer:!1,type:"id"},r.id=r.none,["hex","ascii","base64","ucs2","ucs-2","utf16le","utf-16le"].forEach(function(n){r[n]={encode:function(r){return t(r)?r:new e(r,n)},decode:function(e){return e.toString(n)},buffer:!0,type:n}})}).call(this,e("buffer").Buffer)},{buffer:5}],33:[function(e,t,r){var n=e("errno").create,i=n("LevelUPError"),o=n("NotFoundError",i);o.prototype.notFound=!0,o.prototype.status=404,t.exports={LevelUPError:i,InitializationError:n("InitializationError",i),OpenError:n("OpenError",i),ReadError:n("ReadError",i),WriteError:n("WriteError",i),NotFoundError:o,EncodingError:n("EncodingError",i)}},{errno:16}],34:[function(e,t,r){function n(e,t){if(!(this instanceof n))return new n(e,t);o.call(this,a(t,{objectMode:!0})),this._iterator=e,this._destroyed=!1,this._decoder=null,t&&t.decoder&&(this._decoder=t.decoder),this.on("end",this._cleanup.bind(this))}var i=e("inherits"),o=e("readable-stream").Readable,a=e("xtend"),s=e("level-errors").EncodingError;t.exports=n,i(n,o),n.prototype._read=function(){var e=this;this._destroyed||this._iterator.next(function(t,r,n){if(!e._destroyed){if(t)return e.emit("error",t);if(void 0===r&&void 0===n)e.push(null);else{if(!e._decoder)return e.push({key:r,value:n});try{var n=e._decoder(r,n)}catch(t){return e.emit("error",new s(t)),void e.push(null)}e.push(n)}}})},n.prototype.destroy=n.prototype._cleanup=function(){var e=this;this._destroyed||(this._destroyed=!0,this._iterator.end(function(t){if(t)return e.emit("error",t);e.emit("close")}))}},{inherits:24,"level-errors":33,"readable-stream":78,xtend:120}],35:[function(e,t,r){function n(e,t){this._levelup=e,this._codec=t,this.batch=e.db.batch(),this.ops=[],this.length=0}var i=e("./util"),o=e("level-errors").WriteError,a=i.getOptions,s=i.dispatchError;n.prototype.put=function(e,t,r){r=a(r);var n=this._codec.encodeKey(e,r),i=this._codec.encodeValue(t,r);try{this.batch.put(n,i)}catch(e){throw new o(e)}return this.ops.push({type:"put",key:n,value:i}),this.length++,this},n.prototype.del=function(e,t){t=a(t);var r=this._codec.encodeKey(e,t);try{this.batch.del(r)}catch(e){throw new o(e)}return this.ops.push({type:"del",key:r}),this.length++,this},n.prototype.clear=function(){try{this.batch.clear()}catch(e){throw new o(e)}return this.ops=[],this.length=0,this},n.prototype.write=function(e){var t=this._levelup,r=this.ops;try{this.batch.write(function(n){if(n)return s(t,new o(n),e);t.emit("batch",r),e&&e()})}catch(e){throw new o(e)}},t.exports=n},{"./util":37,"level-errors":33}],36:[function(e,t,r){(function(r){function n(e,t){return"function"==typeof e?e:t}function i(e,t,n){if(!(this instanceof i))return new i(e,t,n);var o;if(c.call(this),this.setMaxListeners(1/0),"function"==typeof e?((t="object"==typeof t?t:{}).db=e,e=null):"object"==typeof e&&"function"==typeof e.db&&(t=e,e=null),"function"==typeof t&&(n=t,t={}),(!t||"function"!=typeof t.db)&&"string"!=typeof e){if(o=new w("Must provide a location for the database"),n)return r.nextTick(function(){n(o)});throw o}t=D(t),this.options=p(C,t),this._codec=new A(this.options),this._status="new",d(this,"location",e,"e"),this.open(n)}function o(e,t,r){if(!e._isOpening()&&!e.isOpen())return O(e,new g("Database is not open"),r),!0}function a(e,t,r){O(e,new y(t),r)}function s(e,t,r){O(e,new g(t),r)}function u(e){return function(t,r){F()[e](t,r||function(){})}}var c=e("events").EventEmitter,l=e("util").inherits,f=e("util").deprecate,p=e("xtend"),d=e("prr"),h=e("deferred-leveldown"),m=e("level-iterator-stream"),v=e("level-errors"),y=v.WriteError,g=v.ReadError,b=v.NotFoundError,_=v.OpenError,x=v.EncodingError,w=v.InitializationError,k=v.LevelUPError,E=e("./util"),S=e("./batch"),A=e("level-codec"),D=E.getOptions,C=E.defaultOptions,F=e("./leveldown"),O=E.dispatchError;E.isDefined;l(i,c),i.prototype.open=function(e){var t,n,i=this;if(this.isOpen())return e&&r.nextTick(function(){e(null,i)}),this;if(this._isOpening())return e&&this.once("open",function(){e(null,i)});if(this.emit("opening"),this._status="opening",this.db=new h(this.location),"function"!=typeof this.options.db&&"function"!=typeof F)throw new k("missing db factory, you need to set options.db");t=this.options.db||F(),(n=t(this.location)).open(this.options,function(t){if(t)return O(i,new _(t),e);i.db.setDb(n),i.db=n,i._status="open",e&&e(null,i),i.emit("open"),i.emit("ready")})},i.prototype.close=function(e){var t=this;if(this.isOpen())this._status="closing",this.db.close(function(){t._status="closed",t.emit("closed"),e&&e.apply(null,arguments)}),this.emit("closing"),this.db=new h(this.location);else{if("closed"==this._status&&e)return r.nextTick(e);"closing"==this._status&&e?this.once("closed",e):this._isOpening()&&this.once("open",function(){t.close(e)})}},i.prototype.isOpen=function(){return"open"==this._status},i.prototype._isOpening=function(){return"opening"==this._status},i.prototype.isClosed=function(){return/^clos/.test(this._status)},i.prototype.get=function(e,t,r){var i,a=this;if(r=n(t,r),!o(this,0,r)){if(null===e||void 0===e||"function"!=typeof r)return s(this,"get() requires key and callback arguments",r);t=E.getOptions(t),i=this._codec.encodeKey(e,t),t.asBuffer=this._codec.valueAsBuffer(t),this.db.get(i,t,function(n,i){if(n)return n=/notfound/i.test(n)||n.notFound?new b("Key not found in database ["+e+"]",n):new g(n),O(a,n,r);if(r){try{i=a._codec.decodeValue(i,t)}catch(e){return r(new x(e))}r(null,i)}})}},i.prototype.put=function(e,t,r,i){var s,u,c=this;if(i=n(r,i),null===e||void 0===e)return a(this,"put() requires a key argument",i);o(this,0,i)||(r=D(r),s=this._codec.encodeKey(e,r),u=this._codec.encodeValue(t,r),this.db.put(s,u,r,function(r){if(r)return O(c,new y(r),i);c.emit("put",e,t),i&&i()}))},i.prototype.del=function(e,t,r){var i,s=this;if(r=n(t,r),null===e||void 0===e)return a(this,"del() requires a key argument",r);o(this,0,r)||(t=D(t),i=this._codec.encodeKey(e,t),this.db.del(i,t,function(t){if(t)return O(s,new y(t),r);s.emit("del",e),r&&r()}))},i.prototype.batch=function(e,t,r){var i,s=this;return arguments.length?(r=n(t,r),Array.isArray(e)?void(o(this,0,r)||(t=D(t),i=(i=s._codec.encodeBatch(e,t)).map(function(e){return e.type||void 0===e.key||void 0===e.value||(e.type="put"),e}),this.db.batch(i,t,function(t){if(t)return O(s,new y(t),r);s.emit("batch",e),r&&r()}))):a(this,"batch() requires an array argument",r)):new S(this,this._codec)},i.prototype.approximateSize=f(function(e,t,r,i){var o,a,u=this;if(i=n(r,i),r=D(r),null===e||void 0===e||null===t||void 0===t||"function"!=typeof i)return s(this,"approximateSize() requires start, end and callback arguments",i);o=this._codec.encodeKey(e,r),a=this._codec.encodeKey(t,r),this.db.approximateSize(o,a,function(e,t){if(e)return O(u,new _(e),i);i&&i(null,t)})},"db.approximateSize() is deprecated. Use db.db.approximateSize() instead"),i.prototype.readStream=i.prototype.createReadStream=function(e){return e=p({keys:!0,values:!0},this.options,e),e.keyEncoding=e.keyEncoding,e.valueEncoding=e.valueEncoding,e=this._codec.encodeLtgt(e),e.keyAsBuffer=this._codec.keyAsBuffer(e),e.valueAsBuffer=this._codec.valueAsBuffer(e),"number"!=typeof e.limit&&(e.limit=-1),new m(this.db.iterator(e),p(e,{decoder:this._codec.createStreamDecoder(e)}))},i.prototype.keyStream=i.prototype.createKeyStream=function(e){return this.createReadStream(p(e,{keys:!0,values:!1}))},i.prototype.valueStream=i.prototype.createValueStream=function(e){return this.createReadStream(p(e,{keys:!1,values:!0}))},i.prototype.toString=function(){return"LevelUP"},t.exports=i,t.exports.errors=e("level-errors"),t.exports.destroy=f(u("destroy"),"levelup.destroy() is deprecated. Use leveldown.destroy() instead"),t.exports.repair=f(u("repair"),"levelup.repair() is deprecated. Use leveldown.repair() instead")}).call(this,e("_process"))},{"./batch":35,"./leveldown":3,"./util":37,_process:70,"deferred-leveldown":8,events:18,"level-codec":38,"level-errors":33,"level-iterator-stream":34,prr:71,util:114,xtend:120}],37:[function(e,t,r){e("xtend");var n={createIfMissing:!0,errorIfExists:!1,keyEncoding:"utf8",valueEncoding:"utf8",compression:!0};t.exports={defaultOptions:n,getOptions:function(e){return"string"==typeof e&&(e={valueEncoding:e}),"object"!=typeof e&&(e={}),e},dispatchError:function(e,t,r){"function"==typeof r?r(t):e.emit("error",t)},isDefined:function(e){return void 0!==e}}},{xtend:120}],38:[function(e,t,r){arguments[4][31][0].apply(r,arguments)},{"./lib/encodings":39,dup:31}],39:[function(e,t,r){(function(e){function t(e){return e}function n(t){return void 0===t||null===t||e.isBuffer(t)}r.utf8=r["utf-8"]={encode:function(e){return n(e)?e:String(e)},decode:t,buffer:!1,type:"utf8"},r.json={encode:JSON.stringify,decode:JSON.parse,buffer:!1,type:"json"},r.binary={encode:function(t){return n(t)?t:new e(t)},decode:t,buffer:!0,type:"binary"},r.id={encode:function(e){return e},decode:function(e){return e},buffer:!1,type:"id"},["hex","ascii","base64","ucs2","ucs-2","utf16le","utf-16le"].forEach(function(t){r[t]={encode:function(r){return n(r)?r:new e(r,t)},decode:function(e){return e.toString(t)},buffer:!0,type:t}})}).call(this,e("buffer").Buffer)},{buffer:5}],40:[function(e,t,r){"use strict";function n(){}function i(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=h,this.queue=[],this.outcome=void 0,e!==n&&u(this,e)}function o(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function a(e,t,r){l(function(){var n;try{n=t(r)}catch(t){return f.reject(e,t)}n===e?f.reject(e,new TypeError("Cannot resolve promise with itself")):f.resolve(e,n)})}function s(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function u(e,t){function r(t){i||(i=!0,f.reject(e,t))}function n(t){i||(i=!0,f.resolve(e,t))}var i=!1,o=c(function(){t(n,r)});"error"===o.status&&r(o.value)}function c(e,t){var r={};try{r.value=e(t),r.status="success"}catch(e){r.status="error",r.value=e}return r}var l=e("immediate"),f={},p=["REJECTED"],d=["FULFILLED"],h=["PENDING"];t.exports=i,i.prototype.catch=function(e){return this.then(null,e)},i.prototype.then=function(e,t){if("function"!=typeof e&&this.state===d||"function"!=typeof t&&this.state===p)return this;var r=new this.constructor(n);return this.state!==h?a(r,this.state===d?e:t,this.outcome):this.queue.push(new o(r,e,t)),r},o.prototype.callFulfilled=function(e){f.resolve(this.promise,e)},o.prototype.otherCallFulfilled=function(e){a(this.promise,this.onFulfilled,e)},o.prototype.callRejected=function(e){f.reject(this.promise,e)},o.prototype.otherCallRejected=function(e){a(this.promise,this.onRejected,e)},f.resolve=function(e,t){var r=c(s,t);if("error"===r.status)return f.reject(e,r.value);var n=r.value;if(n)u(e,n);else{e.state=d,e.outcome=t;for(var i=-1,o=e.queue.length;++i<o;)e.queue[i].callFulfilled(t)}return e},f.reject=function(e,t){e.state=p,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},i.resolve=function(e){return e instanceof this?e:f.resolve(new this(n),e)},i.reject=function(e){var t=new this(n);return f.reject(t,e)},i.all=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,i=!1;if(!r)return this.resolve([]);for(var o=new Array(r),a=0,s=-1,u=new this(n);++s<r;)!function(e,n){t.resolve(e).then(function(e){o[n]=e,++a!==r||i||(i=!0,f.resolve(u,o))},function(e){i||(i=!0,f.reject(u,e))})}(e[s],s);return u},i.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,i=!1;if(!r)return this.resolve([]);for(var o=-1,a=new this(n);++o<r;)!function(e){t.resolve(e).then(function(e){i||(i=!0,f.resolve(a,e))},function(e){i||(i=!0,f.reject(a,e))})}(e[o]);return a}},{immediate:23}],41:[function(e,t,r){t.exports=function(e){return null===e}},{}],42:[function(e,t,r){(function(e){function t(e,t){return Object.hasOwnProperty.call(e,t)}function n(e){return void 0!==e&&""!==e}function t(e,t){return Object.hasOwnProperty.call(e,t)}function i(e,t){return Object.hasOwnProperty.call(e,t)&&t}function o(e){return e}r.compare=function(t,r){if(e.isBuffer(t)){for(var n=Math.min(t.length,r.length),i=0;i<n;i++){var o=t[i]-r[i];if(o)return o}return t.length-r.length}return t<r?-1:t>r?1:0};var a=r.lowerBoundKey=function(e){return i(e,"gt")||i(e,"gte")||i(e,"min")||(e.reverse?i(e,"end"):i(e,"start"))||void 0},s=r.lowerBound=function(e,t){var r=a(e);return r?e[r]:t},u=r.lowerBoundInclusive=function(e){return!t(e,"gt")},c=r.upperBoundInclusive=function(e){return!t(e,"lt")},l=r.lowerBoundExclusive=function(e){return!u(e)},f=r.upperBoundExclusive=function(e){return!c(e)},p=r.upperBoundKey=function(e){return i(e,"lt")||i(e,"lte")||i(e,"max")||(e.reverse?i(e,"start"):i(e,"end"))||void 0},d=r.upperBound=function(e,t){var r=p(e);return r?e[r]:t};r.start=function(e,t){return e.reverse?d(e,t):s(e,t)},r.end=function(e,t){return e.reverse?s(e,t):d(e,t)},r.startInclusive=function(e){return e.reverse?c(e):u(e)},r.endInclusive=function(e){return e.reverse?u(e):c(e)},r.toLtgt=function(e,n,i,a,s){n=n||{},i=i||o;var u=arguments.length>3,c=r.lowerBoundKey(e),l=r.upperBoundKey(e);return c?"gt"===c?n.gt=i(e.gt,!1):n.gte=i(e[c],!1):u&&(n.gte=i(a,!1)),l?"lt"===l?n.lt=i(e.lt,!0):n.lte=i(e[l],!0):u&&(n.lte=i(s,!0)),null!=e.reverse&&(n.reverse=!!e.reverse),t(n,"max")&&delete n.max,t(n,"min")&&delete n.min,t(n,"start")&&delete n.start,t(n,"end")&&delete n.end,n},r.contains=function(e,t,i){i=i||r.compare;var o=s(e);if(n(o)&&((u=i(t,o))<0||0===u&&l(e)))return!1;var a=d(e);if(n(a)){var u=i(t,a);if(u>0||0===u&&f(e))return!1}return!0},r.filter=function(e,t){return function(n){return r.contains(e,n,t)}}}).call(this,{isBuffer:e("../is-buffer/index.js")})},{"../is-buffer/index.js":26}],43:[function(e,t,r){t.exports=e("immediate")},{immediate:50}],44:[function(e,t,r){(function(r){function n(e){return p.compare(e,this._end)>0}function i(e){return p.compare(e,this._end)>=0}function o(e){return p.compare(e,this._end)<0}function a(e){return p.compare(e,this._end)<=0}function s(e,t){f.call(this,e),this._limit=t.limit,-1===this._limit&&(this._limit=1/0);var r=e._store[e._location];this.keyAsBuffer=!1!==t.keyAsBuffer,this.valueAsBuffer=!1!==t.valueAsBuffer,this._reverse=t.reverse,this._options=t,this._done=0,this._reverse?(this._incr="prev",this._start=p.upperBound(t),this._end=p.lowerBound(t),void 0===this._start?this._tree=r.end:p.upperBoundInclusive(t)?this._tree=r.le(this._start):this._tree=r.lt(this._start),this._end&&(p.lowerBoundInclusive(t)?this._test=i:this._test=n)):(this._incr="next",this._start=p.lowerBound(t),this._end=p.upperBound(t),void 0===this._start?this._tree=r.begin:p.lowerBoundInclusive(t)?this._tree=r.ge(this._start):this._tree=r.gt(this._start),this._end&&(p.upperBoundInclusive(t)?this._test=a:this._test=o))}function u(e){if(!(this instanceof u))return new u(e);l.call(this,"string"==typeof e?e:""),this._location=this.location?"$"+this.location:"_tree",this._store=this.location?h:this,this._store[this._location]=this._store[this._location]||d(p.compare)}var c=e("inherits"),l=e("abstract-leveldown").AbstractLevelDOWN,f=e("abstract-leveldown").AbstractIterator,p=e("ltgt"),d=e("functional-red-black-tree"),h={},m=e("./immediate");c(s,f),s.prototype._next=function(e){var t,n;return this._done++>=this._limit?m(e):this._tree.valid?(t=this._tree.key,n=this._tree.value,this._test(t)?(this.keyAsBuffer&&(t=new r(t)),this.valueAsBuffer&&(n=new r(n)),this._tree[this._incr](),void m(function(){e(null,t,n)})):m(e)):m(e)},s.prototype._test=function(){return!0},u.clearGlobalStore=function(e){e?Object.keys(h).forEach(function(e){delete h[e]}):h={}},c(u,l),u.prototype._open=function(e,t){var r=this;m(function(){t(null,r)})},u.prototype._put=function(e,t,r,n){void 0!==t&&null!==t||(t="");var i=this._store[this._location].find(e);i.valid?this._store[this._location]=i.update(t):this._store[this._location]=this._store[this._location].insert(e,t),m(n)},u.prototype._get=function(e,t,n){var i=this._store[this._location].get(e);if(void 0===i)return m(function(){n(new Error("NotFound"))});!1===t.asBuffer||this._isBuffer(i)||(i=new r(String(i))),m(function(){n(null,i)})},u.prototype._del=function(e,t,r){this._store[this._location]=this._store[this._location].remove(e),m(r)},u.prototype._batch=function(e,t,r){for(var n,i,o,a=-1,s=e.length,u=this._store[this._location];++a<s;)e[a]&&(n=this._isBuffer(e[a].key)?e[a].key:String(e[a].key),o=u.find(n),"put"===e[a].type?(i=this._isBuffer(e[a].value)?e[a].value:String(e[a].value),u=o.valid?o.update(i):u.insert(n,i)):u=o.remove());this._store[this._location]=u,m(r)},u.prototype._iterator=function(e){return new s(this,e)},u.prototype._isBuffer=function(e){return r.isBuffer(e)},u.destroy=function(e,t){var r="$"+e;r in h&&delete h[r],m(t)},t.exports=u}).call(this,e("buffer").Buffer)},{"./immediate":43,"abstract-leveldown":48,buffer:5,"functional-red-black-tree":19,inherits:24,ltgt:56}],45:[function(e,t,r){arguments[4][9][0].apply(r,arguments)},{_process:70,dup:9}],46:[function(e,t,r){arguments[4][10][0].apply(r,arguments)},{_process:70,dup:10}],47:[function(e,t,r){arguments[4][11][0].apply(r,arguments)},{"../../../is-buffer/index.js":26,"./abstract-chained-batch":45,"./abstract-iterator":46,_process:70,dup:11,xtend:120}],48:[function(e,t,r){arguments[4][12][0].apply(r,arguments)},{"./abstract-chained-batch":45,"./abstract-iterator":46,"./abstract-leveldown":47,"./is-leveldown":49,dup:12}],49:[function(e,t,r){arguments[4][13][0].apply(r,arguments)},{"./abstract-leveldown":47,dup:13}],50:[function(e,t,r){"use strict";function n(){a&&s&&(a=!1,s.length?f=s.concat(f):l=-1,f.length&&i())}function i(){if(!a){p=!1,a=!0;for(var e=f.length,t=setTimeout(n);e;){for(s=f,f=[];s&&++l<e;)s[l].run();l=-1,e=f.length}s=null,l=-1,a=!1,clearTimeout(t)}}function o(e,t){this.fun=e,this.array=t}for(var a,s,u,c=[e("./nextTick"),e("./mutation.js"),e("./messageChannel"),e("./stateChange"),e("./timeout")],l=-1,f=[],p=!1,d=-1,h=c.length;++d<h;)if(c[d]&&c[d].test&&c[d].test()){u=c[d].install(i);break}o.prototype.run=function(){var e=this.fun,t=this.array;switch(t.length){case 0:return e();case 1:return e(t[0]);case 2:return e(t[0],t[1]);case 3:return e(t[0],t[1],t[2]);default:return e.apply(null,t)}},t.exports=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];f.push(new o(e,t)),p||a||(p=!0,u())}},{"./messageChannel":51,"./mutation.js":52,"./nextTick":53,"./stateChange":54,"./timeout":55}],51:[function(e,t,r){(function(e){"use strict";r.test=function(){return!e.setImmediate&&void 0!==e.MessageChannel},r.install=function(t){var r=new e.MessageChannel;return r.port1.onmessage=t,function(){r.port2.postMessage(0)}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],52:[function(e,t,r){(function(e){"use strict";var t=e.MutationObserver||e.WebKitMutationObserver;r.test=function(){return t},r.install=function(r){var n=0,i=new t(r),o=e.document.createTextNode("");return i.observe(o,{characterData:!0}),function(){o.data=n=++n%2}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],53:[function(e,t,r){(function(e){"use strict";r.test=function(){return void 0!==e&&!e.browser},r.install=function(t){return function(){e.nextTick(t)}}}).call(this,e("_process"))},{_process:70}],54:[function(e,t,r){(function(e){"use strict";r.test=function(){return"document"in e&&"onreadystatechange"in e.document.createElement("script")},r.install=function(t){return function(){var r=e.document.createElement("script");return r.onreadystatechange=function(){t(),r.onreadystatechange=null,r.parentNode.removeChild(r),r=null},e.document.documentElement.appendChild(r),t}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],55:[function(e,t,r){"use strict";r.test=function(){return!0},r.install=function(e){return function(){setTimeout(e,0)}}},{}],56:[function(e,t,r){(function(e){function t(e,t){return Object.hasOwnProperty.call(e,t)}function n(e){return void 0!==e&&""!==e}function t(e,t){return Object.hasOwnProperty.call(e,t)}function i(e,t){return Object.hasOwnProperty.call(e,t)&&t}function o(e){return e}r.compare=function(t,r){if(e.isBuffer(t)){for(var n=Math.min(t.length,r.length),i=0;i<n;i++){var o=t[i]-r[i];if(o)return o}return t.length-r.length}return t<r?-1:t>r?1:0};var a=r.lowerBoundKey=function(e){return i(e,"gt")||i(e,"gte")||i(e,"min")||(e.reverse?i(e,"end"):i(e,"start"))||void 0},s=r.lowerBound=function(e){var t=a(e);return t&&e[t]},u=r.lowerBoundInclusive=function(e){return!t(e,"gt")},c=r.upperBoundInclusive=function(e){return!t(e,"lt")},l=r.lowerBoundExclusive=function(e){return!u(e)},f=r.upperBoundExclusive=function(e){return!c(e)},p=r.upperBoundKey=function(e){return i(e,"lt")||i(e,"lte")||i(e,"max")||(e.reverse?i(e,"start"):i(e,"end"))||void 0},d=r.upperBound=function(e){var t=p(e);return t&&e[t]};r.toLtgt=function(e,n,i,a,s){n=n||{},i=i||o;var u=arguments.length>3,c=r.lowerBoundKey(e),l=r.upperBoundKey(e);return c?"gt"===c?n.gt=i(e.gt,!1):n.gte=i(e[c],!1):u&&(n.gte=i(a,!1)),l?"lt"===l?n.lt=i(e.lt,!0):n.lte=i(e[l],!0):u&&(n.lte=i(s,!0)),null!=e.reverse&&(n.reverse=!!e.reverse),t(n,"max")&&delete n.max,t(n,"min")&&delete n.min,t(n,"start")&&delete n.start,t(n,"end")&&delete n.end,n},r.contains=function(e,t,i){i=i||r.compare;var o=s(e);if(n(o)&&((u=i(t,o))<0||0===u&&l(e)))return!1;var a=d(e);if(n(a)){var u=i(t,a);if(u>0||0===u&&f(e))return!1}return!0},r.filter=function(e,t){return function(n){return r.contains(e,n,t)}}}).call(this,{isBuffer:e("../../../is-buffer/index.js")})},{"../../../is-buffer/index.js":26}],57:[function(e,t,r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e,t){var r=new Uint8Array(e);return A.blob([r],{type:t})}function o(e,t){A.readAsBinaryString(e,t)}function a(e){return A.blob([""],{type:e})}function s(e,t){var r=t.prefix()[0],n=e._cache,i=n.get(r);return i||(i=new d.Map,n.set(r,i)),i}function u(){this._batch=[],this._cache=new d.Map}function c(e){return"winningRev"in e?e.winningRev:k.winningRev(e)}function l(e,t){return"deleted"in e?e.deleted:w.isDeleted(e,t)}function f(e,t,r){var n=e.content_type;return new h(function(o,a){t.binaryStore.get(e.digest,function(t,s){var u;if(t){if("NotFoundError"!==t.name)return a(t);u=r.binary?A.binaryStringToBlobOrBuffer("",n):""}else u=r.binary?i(s,n):s.toString("base64");delete e.stub,delete e.length,e.data=u,o()})})}function p(e,t,r){var n=[];return e.forEach(function(e){e.doc&&e.doc._attachments&&Object.keys(e.doc._attachments).forEach(function(t){var r=e.doc._attachments[t];"data"in r||n.push(r)})}),h.all(n.map(function(e){return f(e,t,r)}))}var d=e("pouchdb-collections"),h=n(e("pouchdb-promise")),m=n(e("levelup")),v=n(e("sublevel-pouchdb")),y=e("through2"),g=n(e("argsarray")),b=n(e("double-ended-queue")),_=n(e("buffer-from")),x=e("pouchdb-utils"),w=e("pouchdb-adapter-utils"),k=e("pouchdb-merge"),E=e("pouchdb-json"),S=e("pouchdb-md5"),A=e("pouchdb-binary-utils"),D=e("pouchdb-errors");u.prototype.get=function(e,t,r){var n=s(this,e),i=n.get(t);return i?x.nextTick(function(){r(null,i)}):null===i?x.nextTick(function(){r({name:"NotFoundError"})}):void e.get(t,function(e,i){if(e)return"NotFoundError"===e.name&&n.set(t,null),r(e);n.set(t,i),r(null,i)})},u.prototype.batch=function(e){for(var t=0,r=e.length;t<r;t++){var n=e[t],i=s(this,n.prefix);"put"===n.type?i.set(n.key,n.value):i.set(n.key,null)}this._batch=this._batch.concat(e)},u.prototype.execute=function(e,t){for(var r=new d.Set,n=[],i=this._batch.length-1;i>=0;i--){var o=this._batch[i],a=o.prefix.prefix()[0]+""+o.key;r.has(a)||(r.add(a),n.push(o))}e.batch(n,t)};var C="document-store",F="by-sequence",O="attach-store",j="attach-binary-store",R="local-store",B="meta-store",P=new d.Map,T="_local_last_update_seq",I="_local_doc_count",L="_local_uuid",N="md5-",M={encode:E.safeJsonStringify,decode:E.safeJsonParse,buffer:!1,type:"cheap-json"},q=new x.changesHandler;t.exports=function(e,t){function r(){Y.docStore=K.sublevel(C,{valueEncoding:M}),Y.bySeqStore=K.sublevel(F,{valueEncoding:"json"}),Y.attachmentStore=K.sublevel(O,{valueEncoding:"json"}),Y.binaryStore=K.sublevel(j,{valueEncoding:"binary"}),Y.localStore=K.sublevel(R,{valueEncoding:"json"}),Y.metaStore=K.sublevel(B,{valueEncoding:"json"}),"object"==typeof e.migrate?e.migrate.doMigrationTwo(K,Y,n):n()}function n(){Y.metaStore.get(T,function(e,r){void 0===K._updateSeq&&(K._updateSeq=r||0),Y.metaStore.get(I,function(e,r){K._docCount=e?0:r,Y.metaStore.get(L,function(e,r){J=e?x.uuid():r,Y.metaStore.put(L,J,function(){x.nextTick(function(){t(null,Q)})})})})})}function s(e){return K.isClosed()?e(new Error("database is closed")):e(null,K._docCount)}function f(e,t){try{e.apply(null,t)}catch(e){t[t.length-1](e)}}function E(){var e=K._queue.peekFront();"read"===e.type?$(e):W(e)}function $(e){for(var t=[e],r=1,n=K._queue.get(r);void 0!==n&&"read"===n.type;)t.push(n),r++,n=K._queue.get(r);var i=0;t.forEach(function(e){var r=e.args,n=r[r.length-1];r[r.length-1]=g(function(e){n.apply(null,e),++i===t.length&&x.nextTick(function(){t.forEach(function(){K._queue.shift()}),K._queue.length&&E()})}),f(e.fun,r)})}function W(e){var t=e.args,r=t[t.length-1];t[t.length-1]=g(function(e){r.apply(null,e),x.nextTick(function(){K._queue.shift(),K._queue.length&&E()})}),f(e.fun,t)}function U(e){return g(function(t){K._queue.push({fun:e,args:t,type:"write"}),1===K._queue.length&&x.nextTick(E)})}function z(e){return g(function(t){K._queue.push({fun:e,args:t,type:"read"}),1===K._queue.length&&x.nextTick(E)})}function V(e){return("0000000000000000"+e).slice(-16)}function G(e){return parseInt(e,10)}function H(e,t){te.destroy(e,t)}var J,K,Q=this,Y={},X=(e=x.clone(e)).revs_limit,Z=e.name;void 0===e.createIfMissing&&(e.createIfMissing=!0);var ee,te=e.db,re=x.functionName(te);P.has(re)?ee=P.get(re):(ee=new d.Map,P.set(re,ee)),ee.has(Z)?(K=ee.get(Z),r()):ee.set(Z,v(m(Z,e,function(n){if(n)return ee.delete(Z),t(n);(K=ee.get(Z))._docCount=-1,K._queue=new b,"object"==typeof e.migrate?e.migrate.doMigrationOne(Z,K,r):r()}))),Q._remote=!1,Q.type=function(){return"leveldb"},Q._id=function(e){e(null,J)},Q._info=function(e){var t={doc_count:K._docCount,update_seq:K._updateSeq,backend_adapter:x.functionName(te)};return x.nextTick(function(){e(null,t)})},Q._get=z(function(e,t,r){t=x.clone(t),Y.docStore.get(e,function(e,n){if(e||!n)return r(D.createError(D.MISSING_DOC,"missing"));var i;if(t.rev)i=t.latest?k.latest(t.rev,n):t.rev;else if(i=c(n),l(n,i))return r(D.createError(D.MISSING_DOC,"deleted"));var o=n.rev_map[i];Y.bySeqStore.get(V(o),function(e,t){if(!t)return r(D.createError(D.MISSING_DOC));if("_id"in t&&t._id!==n.id)return r(new Error("wrong doc returned"));if(t._id=n.id,"_rev"in t){if(t._rev!==i)return r(new Error("wrong doc returned"))}else t._rev=i;return r(null,{doc:t,metadata:n})})})}),Q._getAttachment=function(e,t,r,n,o){var s=r.digest,u=r.content_type;Y.binaryStore.get(s,function(e,t){if(e)return"NotFoundError"!==e.name?o(e):o(null,n.binary?a(u):"");n.binary?o(null,i(t,u)):o(null,t.toString("base64"))})},Q._bulkDocs=U(function(e,t,r){function n(e,t){E.get(Y.attachmentStore,e,function(r){if(r){var n=D.createError(D.MISSING_STUB,"unknown stub attachment with digest "+e);t(n)}else t()})}function i(e){function t(){if(++n===O.length)return e(r)}var r,n=0;O.forEach(function(e){if(e._id&&w.isLocalId(e._id))return t();E.get(Y.docStore,e._id,function(n,i){n?"NotFoundError"!==n.name&&(r=n):g.set(e._id,i),t()})})}function a(e,t){var r=h.resolve();e.forEach(function(e,t){r=r.then(function(){return new h(function(r,n){Q._doCompactionNoLock(t,e,{ctx:E},function(e){if(e)return n(e);r()})})})}),r.then(function(){t()},t)}function s(e){var t=new d.Map;g.forEach(function(e,r){t.set(r,k.compactTree(e))}),a(t,e)}function c(){a(b,function(e){if(e&&m(e),Q.auto_compaction)return s(m);m()})}function l(e,t,n,i,a,s,u,c){function l(e){_++,v||(e?c(v=e):_===x.length&&m())}function d(e,t,r,n){return function(i){p(e,N+i,t,r,n)}}function h(e,t,r){return function(n){S.binaryMd5(n,d(e,t,n,r))}}function m(){var t=e.metadata.rev_map[e.metadata.rev];if(t)return c();t=++F,e.metadata.rev_map[e.metadata.rev]=e.metadata.seq=t;var r=[{key:V(t),value:e.data,prefix:Y.bySeqStore,type:"put"},{key:e.metadata.id,value:e.metadata,prefix:Y.docStore,type:"put"}];E.batch(r),y[u]={ok:!0,id:e.metadata.id,rev:e.metadata.rev},g.set(e.metadata.id,e.metadata),c()}C+=s;var v=null,_=0;e.metadata.winningRev=t,e.metadata.deleted=n,e.data._id=e.metadata.id,e.data._rev=e.metadata.rev,i&&(e.data._deleted=!0),e.stemmedRevs.length&&b.set(e.metadata.id,e.stemmedRevs);for(var x=e.data._attachments?Object.keys(e.data._attachments):[],w=0;w<x.length;w++){var k=x[w],O=e.data._attachments[k];if(O.stub)f(e.data._id,e.data._rev,O.digest,l);else{var j;if("string"==typeof O.data){try{j=A.atob(O.data)}catch(e){return void r(D.createError(D.BAD_ARG,"Attachment is not a valid base64 string"))}h(e,k,l)(j)}else o(O.data,h(e,k,l))}}x.length||m()}function f(e,t,r,n){function i(){return new h(function(e,t){E.get(Y.attachmentStore,r,function(r,n){if(r&&"NotFoundError"!==r.name)return t(r);e(n)})})}function o(n){var i=[e,t].join("@"),o={};return n?n.refs&&(o.refs=n.refs,o.refs[i]=!0):(o.refs={},o.refs[i]=!0),new h(function(e){E.batch([{type:"put",prefix:Y.attachmentStore,key:r,value:o}]),e(!n)})}var a=B[r]||h.resolve();B[r]=a.then(function(){return i().then(o).then(function(e){n(null,e)},n)})}function p(e,t,r,n,i){var o=e.data._attachments[r];delete o.data,o.digest=t,o.length=n.length;var a=e.metadata.id,s=e.metadata.rev;o.revpos=parseInt(s,10),f(a,s,t,function(e,r){return e?i(e):0===n.length?i(e):r?(E.batch([{type:"put",prefix:Y.binaryStore,key:t,value:_(n,"binary")}]),void i()):i(e)})}function m(e){if(e)return x.nextTick(function(){r(e)});E.batch([{prefix:Y.metaStore,type:"put",key:T,value:F},{prefix:Y.metaStore,type:"put",key:I,value:K._docCount+C}]),E.execute(K,function(e){if(e)return r(e);K._docCount+=C,K._updateSeq=F,q.notify(Z),x.nextTick(function(){r(null,y)})})}var v=t.new_edits,y=new Array(e.docs.length),g=new d.Map,b=new d.Map,E=new u,C=0,F=K._updateSeq,O=e.docs,j=O.map(function(e){if(e._id&&w.isLocalId(e._id))return e;var t=w.parseDoc(e,v);return t.metadata&&!t.metadata.rev_map&&(t.metadata.rev_map={}),t}),R=j.filter(function(e){return e.error});if(R.length)return r(R[0]);var B={};if(!j.length)return r(null,[]);!function(e){var t=[];if(O.forEach(function(e){e&&e._attachments&&Object.keys(e._attachments).forEach(function(r){var n=e._attachments[r];n.stub&&t.push(n.digest)})}),!t.length)return e();var r,i=0;t.forEach(function(o){n(o,function(n){n&&!r&&(r=n),++i===t.length&&e(r)})})}(function(e){if(e)return r(e);i(function(e){if(e)return r(e);w.processDocs(X,j,Q,g,E,y,l,t,c)})})}),Q._allDocs=z(function(e,t){e=x.clone(e),s(function(r,n){if(r)return t(r);var i={},o=e.skip||0;if(e.startkey&&(i.gte=e.startkey),e.endkey&&(i.lte=e.endkey),e.key&&(i.gte=i.lte=e.key),e.descending){i.reverse=!0;var a=i.lte;i.lte=i.gte,i.gte=a}var s;if("number"==typeof e.limit&&(s=e.limit),0===s||"start"in i&&"end"in i&&i.start>i.end)return t(null,{total_rows:n,offset:e.skip,rows:[]});var u=[],f=Y.docStore.readStream(i),d=y.obj(function(t,r,n){function i(t){var r={id:a.id,key:a.id,value:{rev:p}};if(e.include_docs){if(r.doc=t,r.doc._rev=r.value.rev,e.conflicts){var i=k.collectConflicts(a);i.length&&(r.doc._conflicts=i)}for(var o in r.doc._attachments)r.doc._attachments.hasOwnProperty(o)&&(r.doc._attachments[o].stub=!0)}if(!1===e.inclusive_end&&a.id===e.endkey)return n();if(d){if("ok"!==e.deleted)return n();r.value.deleted=!0,r.doc=null}u.push(r),n()}var a=t.value,p=c(a),d=l(a,p);if(d){if("ok"!==e.deleted)return void n()}else{if(o-- >0)return void n();if("number"==typeof s&&s--<=0)return f.unpipe(),f.destroy(),void n()}if(e.include_docs){var h=a.rev_map[p];Y.bySeqStore.get(V(h),function(e,t){i(t)})}else i()},function(r){h.resolve().then(function(){if(e.include_docs&&e.attachments)return p(u,Y,e)}).then(function(){t(null,{total_rows:n,offset:e.skip,rows:u})},t),r()}).on("unpipe",function(){d.end()});f.on("error",t),f.pipe(d)})}),Q._changes=function(e){function t(){e.done=!0,l&&e.limit&&e.limit<o.length&&(o.length=e.limit),v.unpipe(g),v.destroy(),e.continuous||e.cancelled||(e.include_docs&&e.attachments?p(o,Y,e).then(function(){e.complete(null,{results:o,last_seq:a})}):e.complete(null,{results:o,last_seq:a}))}if((e=x.clone(e)).continuous){var r=Z+":"+x.uuid();return q.addListener(Z,r,Q,e),q.notify(Z),{cancel:function(){q.removeListener(Z,r)}}}var n,i=e.descending,o=[],a=e.since||0,s=0,u={reverse:i};"limit"in e&&e.limit>0&&(n=e.limit),u.reverse||(u.start=V(e.since||0));var l,f=e.doc_ids&&new d.Set(e.doc_ids),h=x.filterChange(e),m=new d.Map;l="return_docs"in e?e.return_docs:!("returnDocs"in e)||e.returnDocs;var v=Y.bySeqStore.readStream(u),g=y.obj(function(r,u,d){function v(t){function r(r){var n=e.processChange(r,t,e);n.seq=t.seq;var i=h(n);if("object"==typeof i)return e.complete(i);i&&(s++,e.attachments&&e.include_docs?p([n],Y,e).then(function(){e.onChange(n)}):e.onChange(n),l&&o.push(n)),d()}var n=c(t);if(t.seq!==y)return d();if(a=y,n===g._rev)return r(g);var i=t.rev_map[n];Y.bySeqStore.get(V(i),function(e,t){r(t)})}if(n&&s>=n)return t(),d();if(e.cancelled||e.done)return d();var y=G(r.key),g=r.value;if(y===e.since&&!i)return d();if(f&&!f.has(g._id))return d();var b;if(b=m.get(g._id))return v(b);Y.docStore.get(g._id,function(t,r){if(e.cancelled||e.done||K.isClosed()||w.isLocalId(r.id))return d();m.set(g._id,r),v(r)})},function(t){if(e.cancelled)return t();l&&e.limit&&e.limit<o.length&&(o.length=e.limit),t()}).on("unpipe",function(){g.end(),t()});return v.pipe(g),{cancel:function(){e.cancelled=!0,t()}}},Q._close=function(e){if(K.isClosed())return e(D.createError(D.NOT_OPEN));K.close(function(t){t?e(t):(ee.delete(Z),e())})},Q._getRevisionTree=function(e,t){Y.docStore.get(e,function(e,r){e?t(D.createError(D.MISSING_DOC)):t(null,r.rev_tree)})},Q._doCompaction=U(function(e,t,r,n){Q._doCompactionNoLock(e,t,r,n)}),Q._doCompactionNoLock=function(e,t,r,n){if("function"==typeof r&&(n=r,r={}),!t.length)return n();var i=r.ctx||new u;i.get(Y.docStore,e,function(o,a){function s(e){if(e&&(p=e),++m===t.length){if(p)return n(p);c()}}function u(e){return e?n(e):(i.batch(f),r.ctx?n():void i.execute(K,n))}function c(){function r(e){e&&(o=e),++a===n.length&&u(o)}var n=Object.keys(h);if(!n.length)return u();var o,a=0,s=new d.Map;t.forEach(function(t){s.set(e+"@"+t,!0)}),n.forEach(function(e){i.get(Y.attachmentStore,e,function(t,n){if(t)return"NotFoundError"===t.name?r():r(t);var i=Object.keys(n.refs||{}).filter(function(e){return!s.has(e)}),o={};i.forEach(function(e){o[e]=!0}),i.length?f.push({key:e,type:"put",value:{refs:o},prefix:Y.attachmentStore}):f=f.concat([{key:e,type:"del",prefix:Y.attachmentStore},{key:e,type:"del",prefix:Y.binaryStore}]),r()})})}if(o)return n(o);var l=t.map(function(e){var t=a.rev_map[e];return delete a.rev_map[e],t});k.traverseRevTree(a.rev_tree,function(e,r,n,i,o){var a=r+"-"+n;-1!==t.indexOf(a)&&(o.status="missing")});var f=[];f.push({key:a.id,value:a,type:"put",prefix:Y.docStore});var p,h={},m=0;l.forEach(function(e){f.push({key:V(e),type:"del",prefix:Y.bySeqStore}),i.get(Y.bySeqStore,V(e),function(e,t){if(e)return"NotFoundError"===e.name?s():s(e);Object.keys(t._attachments||{}).forEach(function(e){var r=t._attachments[e].digest;h[r]=!0}),s()})})})},Q._getLocal=function(e,t){Y.localStore.get(e,function(e,r){e?t(D.createError(D.MISSING_DOC)):t(null,r)})},Q._putLocal=function(e,t,r){"function"==typeof t&&(r=t,t={}),t.ctx?Q._putLocalNoLock(e,t,r):Q._putLocalWithLock(e,t,r)},Q._putLocalWithLock=U(function(e,t,r){Q._putLocalNoLock(e,t,r)}),Q._putLocalNoLock=function(e,t,r){delete e._revisions;var n=e._rev,i=e._id,o=t.ctx||new u;o.get(Y.localStore,i,function(a,s){if(a&&n)return r(D.createError(D.REV_CONFLICT));if(s&&s._rev!==n)return r(D.createError(D.REV_CONFLICT));e._rev=n?"0-"+(parseInt(n.split("-")[1],10)+1):"0-1";var u=[{type:"put",prefix:Y.localStore,key:i,value:e}];o.batch(u);var c={ok:!0,id:e._id,rev:e._rev};if(t.ctx)return r(null,c);o.execute(K,function(e){if(e)return r(e);r(null,c)})})},Q._removeLocal=function(e,t,r){"function"==typeof t&&(r=t,t={}),t.ctx?Q._removeLocalNoLock(e,t,r):Q._removeLocalWithLock(e,t,r)},Q._removeLocalWithLock=U(function(e,t,r){Q._removeLocalNoLock(e,t,r)}),Q._removeLocalNoLock=function(e,t,r){var n=t.ctx||new u;n.get(Y.localStore,e._id,function(i,o){if(i)return r("NotFoundError"!==i.name?i:D.createError(D.MISSING_DOC));if(o._rev!==e._rev)return r(D.createError(D.REV_CONFLICT));n.batch([{prefix:Y.localStore,type:"del",key:e._id}]);var a={ok:!0,id:e._id,rev:"0-0"};if(t.ctx)return r(null,a);n.execute(K,function(e){if(e)return r(e);r(null,a)})})},Q._destroy=function(e,t){var r,n=x.functionName(te);if(!P.has(n))return H(Z,t);(r=P.get(n)).has(Z)?(q.removeAllListeners(Z),r.get(Z).close(function(){r.delete(Z),H(Z,t)})):H(Z,t)}}},{argsarray:1,"buffer-from":4,"double-ended-queue":14,levelup:36,"pouchdb-adapter-utils":60,"pouchdb-binary-utils":61,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-json":64,"pouchdb-md5":65,"pouchdb-merge":66,"pouchdb-promise":58,"pouchdb-utils":67,"sublevel-pouchdb":97,through2:109}],58:[function(e,t,r){"use strict";var n=function(e){return e&&"object"==typeof e&&"default"in e?e.default:e}(e("lie")),i="function"==typeof Promise?Promise:n;t.exports=i},{lie:40}],59:[function(e,t,r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e,t){var r=o.assign({db:s},e);a.call(this,r,t)}var o=e("pouchdb-utils"),a=n(e("pouchdb-adapter-leveldb-core")),s=n(e("memdown"));i.valid=function(){return!0},i.use_prefix=!1;t.exports=function(e){e.adapter("memory",i,!0)}},{memdown:44,"pouchdb-adapter-leveldb-core":57,"pouchdb-utils":67}],60:[function(e,t,r){"use strict";function n(e){return e.reduce(function(e,t){return e[t]=!0,e},{})}function i(e){if(!/^\d+-./.test(e))return h.createError(h.INVALID_REV);var t=e.indexOf("-"),r=e.substring(0,t),n=e.substring(t+1);return{prefix:parseInt(r,10),id:n}}function o(e,t){for(var r=e.start-e.ids.length+1,n=e.ids,i=[n[0],t,[]],o=1,a=n.length;o<a;o++)i=[n[o],{status:"missing"},[i]];return[{pos:r,ids:i}]}function a(e,t){var r,n,a,s={status:"available"};if(e._deleted&&(s.deleted=!0),t)if(e._id||(e._id=d.uuid()),n=d.rev(),e._rev){if((a=i(e._rev)).error)return a;e._rev_tree=[{pos:a.prefix,ids:[a.id,{status:"missing"},[[n,s,[]]]]}],r=a.prefix+1}else e._rev_tree=[{pos:1,ids:[n,s,[]]}],r=1;else if(e._revisions&&(e._rev_tree=o(e._revisions,s),r=e._revisions.start,n=e._revisions.ids[0]),!e._rev_tree){if((a=i(e._rev)).error)return a;r=a.prefix,n=a.id,e._rev_tree=[{pos:r,ids:[n,s,[]]}]}d.invalidIdError(e._id),e._rev=r+"-"+n;var u={metadata:{},data:{}};for(var c in e)if(Object.prototype.hasOwnProperty.call(e,c)){var l="_"===c[0];if(l&&!b[c]){var f=h.createError(h.DOC_VALIDATION,c);throw f.message=h.DOC_VALIDATION.message+": "+c,f}l&&!_[c]?u.metadata[c.slice(1)]=e[c]:u.data[c]=e[c]}return u}function s(e){try{return v.atob(e)}catch(e){return{error:h.createError(h.BAD_ARG,"Attachment is not a valid base64 string")}}}function u(e,t,r){var n=s(e.data);if(n.error)return r(n.error);e.length=n.length,e.data="blob"===t?v.binaryStringToBlobOrBuffer(n,e.content_type):"base64"===t?v.btoa(n):n,y.binaryMd5(n,function(t){e.digest="md5-"+t,r()})}function c(e,t,r){y.binaryMd5(e.data,function(n){e.digest="md5-"+n,e.length=e.data.size||e.data.length||0,"binary"===t?v.blobOrBufferToBinaryString(e.data,function(t){e.data=t,r()}):"base64"===t?v.blobOrBufferToBase64(e.data,function(t){e.data=t,r()}):r()})}function l(e,t,r){if(e.stub)return r();"string"==typeof e.data?u(e,t,r):c(e,t,r)}function f(e,t,r,n,i,o,s,u){if(m.revExists(t.rev_tree,r.metadata.rev))return n[i]=r,o();var c=t.winningRev||m.winningRev(t),l="deleted"in t?t.deleted:m.isDeleted(t,c),f="deleted"in r.metadata?r.metadata.deleted:m.isDeleted(r.metadata),p=/^1-/.test(r.metadata.rev);if(l&&!f&&u&&p){var d=r.data;d._rev=c,d._id=r.metadata.id,r=a(d,u)}var v=m.merge(t.rev_tree,r.metadata.rev_tree[0],e);if(u&&(l&&f&&"new_leaf"!==v.conflicts||!l&&"new_leaf"!==v.conflicts||l&&!f&&"new_branch"===v.conflicts)){var y=h.createError(h.REV_CONFLICT);return n[i]=y,o()}var g=r.metadata.rev;r.metadata.rev_tree=v.tree,r.stemmedRevs=v.stemmedRevs||[],t.rev_map&&(r.metadata.rev_map=t.rev_map);var b=m.winningRev(r.metadata),_=m.isDeleted(r.metadata,b),x=l===_?0:l<_?-1:1;s(r,b,_,g===b?_:m.isDeleted(r.metadata,g),!0,x,i,o)}function p(e){return"missing"===e.metadata.rev_tree[0].ids[1].status}Object.defineProperty(r,"__esModule",{value:!0});var d=e("pouchdb-utils"),h=e("pouchdb-errors"),m=e("pouchdb-merge"),v=e("pouchdb-binary-utils"),y=e("pouchdb-md5"),g=e("pouchdb-collections"),b=n(["_id","_rev","_attachments","_deleted","_revisions","_revs_info","_conflicts","_deleted_conflicts","_local_seq","_rev_tree","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats","_removed"]),_=n(["_attachments","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats"]);r.invalidIdError=d.invalidIdError,r.isDeleted=m.isDeleted,r.isLocalId=m.isLocalId,r.normalizeDdocFunctionName=d.normalizeDdocFunctionName,r.parseDdocFunctionName=d.parseDdocFunctionName,r.parseDoc=a,r.preprocessAttachments=function(e,t,r){function n(){o++,e.length===o&&(i?r(i):r())}if(!e.length)return r();var i,o=0;e.forEach(function(e){var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[],o=0;if(!r.length)return n();for(var a in e.data._attachments)e.data._attachments.hasOwnProperty(a)&&l(e.data._attachments[a],t,function(e){i=e,++o===r.length&&n()})})},r.processDocs=function(e,t,r,n,i,o,a,s,u){function c(e,t,r){var n=m.winningRev(e.metadata),i=m.isDeleted(e.metadata,n);if("was_delete"in s&&i)return o[t]=h.createError(h.MISSING_DOC,"deleted"),r();if(d&&p(e)){var u=h.createError(h.REV_CONFLICT);return o[t]=u,r()}a(e,n,i,i,!1,i?0:1,t,r)}function l(){++y===b&&u&&u()}e=e||1e3;var d=s.new_edits,v=new g.Map,y=0,b=t.length;t.forEach(function(e,t){if(e._id&&m.isLocalId(e._id)){var n=e._deleted?"_removeLocal":"_putLocal";r[n](e,{ctx:i},function(e,r){o[t]=e||r,l()})}else{var a=e.metadata.id;v.has(a)?(b--,v.get(a).push([e,t])):v.set(a,[[e,t]])}}),v.forEach(function(t,r){function i(){++u<t.length?s():l()}function s(){var s=t[u],l=s[0],p=s[1];if(n.has(r))f(e,n.get(r),l,o,p,i,a,d);else{var h=m.merge([],l.metadata.rev_tree[0],e);l.metadata.rev_tree=h.tree,l.stemmedRevs=h.stemmedRevs||[],c(l,p,i)}}var u=0;s()})},r.updateDoc=f},{"pouchdb-binary-utils":61,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-md5":65,"pouchdb-merge":66,"pouchdb-utils":67}],61:[function(e,t,r){"use strict";function n(e,t){e=e||[],t=t||{};try{return new Blob(e,t)}catch(i){if("TypeError"!==i.name)throw i;for(var r=new("undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder),n=0;n<e.length;n+=1)r.append(e[n]);return r.getBlob(t.type)}}function i(e){for(var t=e.length,r=new ArrayBuffer(t),n=new Uint8Array(r),i=0;i<t;i++)n[i]=e.charCodeAt(i);return r}function o(e,t){return n([i(e)],{type:t})}function a(e){for(var t="",r=new Uint8Array(e),n=r.byteLength,i=0;i<n;i++)t+=String.fromCharCode(r[i]);return t}function s(e,t){if("undefined"==typeof FileReader)return t(a((new FileReaderSync).readAsArrayBuffer(e)));var r=new FileReader,n="function"==typeof r.readAsBinaryString;r.onloadend=function(e){var r=e.target.result||"";if(n)return t(r);t(a(r))},n?r.readAsBinaryString(e):r.readAsArrayBuffer(e)}function u(e,t){s(e,function(e){t(e)})}Object.defineProperty(r,"__esModule",{value:!0});var c=function(e){return atob(e)},l=function(e){return btoa(e)};r.atob=c,r.btoa=l,r.base64StringToBlobOrBuffer=function(e,t){return o(c(e),t)},r.binaryStringToArrayBuffer=i,r.binaryStringToBlobOrBuffer=o,r.blob=n,r.blobOrBufferToBase64=function(e,t){u(e,function(e){t(l(e))})},r.blobOrBufferToBinaryString=u,r.readAsArrayBuffer=function(e,t){if("undefined"==typeof FileReader)return t((new FileReaderSync).readAsArrayBuffer(e));var r=new FileReader;r.onloadend=function(e){var r=e.target.result||new ArrayBuffer(0);t(r)},r.readAsArrayBuffer(e)},r.readAsBinaryString=s,r.typedBuffer=function(){}},{}],62:[function(e,t,r){"use strict";function n(e){return"$"+e}function i(e){return e.substring(1)}function o(){this._store={}}function a(e){if(this._store=new o,e&&Array.isArray(e))for(var t=0,r=e.length;t<r;t++)this.add(e[t])}Object.defineProperty(r,"__esModule",{value:!0}),o.prototype.get=function(e){var t=n(e);return this._store[t]},o.prototype.set=function(e,t){var r=n(e);return this._store[r]=t,!0},o.prototype.has=function(e){return n(e)in this._store},o.prototype.delete=function(e){var t=n(e),r=t in this._store;return delete this._store[t],r},o.prototype.forEach=function(e){for(var t=Object.keys(this._store),r=0,n=t.length;r<n;r++){var o=t[r];e(this._store[o],o=i(o))}},Object.defineProperty(o.prototype,"size",{get:function(){return Object.keys(this._store).length}}),a.prototype.add=function(e){return this._store.set(e,!0)},a.prototype.has=function(e){return this._store.has(e)},a.prototype.forEach=function(e){this._store.forEach(function(t,r){e(r)})},Object.defineProperty(a.prototype,"size",{get:function(){return this._store.size}}),!function(){if("undefined"==typeof Symbol||"undefined"==typeof Map||"undefined"==typeof Set)return!1;var e=Object.getOwnPropertyDescriptor(Map,Symbol.species);return e&&"get"in e&&Map[Symbol.species]===Map}()?(r.Set=a,r.Map=o):(r.Set=Set,r.Map=Map)},{}],63:[function(e,t,r){"use strict";function n(e,t,r){Error.call(this,r),this.status=e,this.name=t,this.message=r,this.error=!0}Object.defineProperty(r,"__esModule",{value:!0}),function(e){return e&&"object"==typeof e&&"default"in e?e.default:e}(e("inherits"))(n,Error),n.prototype.toString=function(){return JSON.stringify({status:this.status,name:this.name,message:this.message,reason:this.reason})};var i=new n(401,"unauthorized","Name or password is incorrect."),o=new n(400,"bad_request","Missing JSON list of 'docs'"),a=new n(404,"not_found","missing"),s=new n(409,"conflict","Document update conflict"),u=new n(400,"bad_request","_id field must contain a string"),c=new n(412,"missing_id","_id is required for puts"),l=new n(400,"bad_request","Only reserved document ids may start with underscore."),f=new n(412,"precondition_failed","Database not open"),p=new n(500,"unknown_error","Database encountered an unknown error"),d=new n(500,"badarg","Some query argument is invalid"),h=new n(400,"invalid_request","Request was invalid"),m=new n(400,"query_parse_error","Some query parameter is invalid"),v=new n(500,"doc_validation","Bad special document member"),y=new n(400,"bad_request","Something wrong with the request"),g=new n(400,"bad_request","Document must be a JSON object"),b=new n(404,"not_found","Database not found"),_=new n(500,"indexed_db_went_bad","unknown"),x=new n(500,"web_sql_went_bad","unknown"),w=new n(500,"levelDB_went_went_bad","unknown"),k=new n(403,"forbidden","Forbidden by design doc validate_doc_update function"),E=new n(400,"bad_request","Invalid rev format"),S=new n(412,"file_exists","The database could not be created, the file already exists."),A=new n(412,"missing_stub","A pre-existing attachment stub wasn't found"),D=new n(413,"invalid_url","Provided URL is invalid");r.UNAUTHORIZED=i,r.MISSING_BULK_DOCS=o,r.MISSING_DOC=a,r.REV_CONFLICT=s,r.INVALID_ID=u,r.MISSING_ID=c,r.RESERVED_ID=l,r.NOT_OPEN=f,r.UNKNOWN_ERROR=p,r.BAD_ARG=d,r.INVALID_REQUEST=h,r.QUERY_PARSE_ERROR=m,r.DOC_VALIDATION=v,r.BAD_REQUEST=y,r.NOT_AN_OBJECT=g,r.DB_MISSING=b,r.WSQ_ERROR=x,r.LDB_ERROR=w,r.FORBIDDEN=k,r.INVALID_REV=E,r.FILE_EXISTS=S,r.MISSING_STUB=A,r.IDB_ERROR=_,r.INVALID_URL=D,r.createError=function(e,t){function r(t){for(var r in e)"function"!=typeof e[r]&&(this[r]=e[r]);void 0!==t&&(this.reason=t)}return r.prototype=n.prototype,new r(t)},r.generateErrorFromResponse=function(e){if("object"!=typeof e){var t=e;(e=p).data=t}return"error"in e&&"conflict"===e.error&&(e.name="conflict",e.status=409),"name"in e||(e.name=e.error||"unknown"),"status"in e||(e.status=500),"message"in e||(e.message=e.message||e.reason),e}},{inherits:24}],64:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=function(e){return e&&"object"==typeof e&&"default"in e?e.default:e}(e("vuvuzela"));r.safeJsonParse=function(e){try{return JSON.parse(e)}catch(t){return n.parse(e)}},r.safeJsonStringify=function(e){try{return JSON.stringify(e)}catch(t){return n.stringify(e)}}},{vuvuzela:119}],65:[function(e,t,r){(function(t){"use strict";function n(e){return s.btoa(e)}function i(e,t,r){return e.webkitSlice?e.webkitSlice(t,r):e.slice(t,r)}function o(e,t,r,n,o){(r>0||n<t.size)&&(t=i(t,r,n)),s.readAsArrayBuffer(t,function(t){e.append(t),o()})}function a(e,t,r,n,i){(r>0||n<t.length)&&(t=t.substring(r,n)),e.appendBinary(t),i()}Object.defineProperty(r,"__esModule",{value:!0});var s=e("pouchdb-binary-utils"),u=function(e){return e&&"object"==typeof e&&"default"in e?e.default:e}(e("spark-md5")),c=t.setImmediate||t.setTimeout,l=32768;r.binaryMd5=function(e,t){function r(){c(s)}function i(){var e=n(v.end(!0));t(e),v.destroy()}function s(){var t=m*d,n=t+d;++m<h?y(v,e,t,n,r):y(v,e,t,n,i)}var f="string"==typeof e,p=f?e.length:e.size,d=Math.min(l,p),h=Math.ceil(p/d),m=0,v=f?new u:new u.ArrayBuffer,y=f?a:o;s()},r.stringMd5=function(e){return u.hash(e)}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"pouchdb-binary-utils":61,"spark-md5":80}],66:[function(e,t,r){"use strict";function n(e){for(var t,r,n,i,o=e.rev_tree.slice();i=o.pop();){var a=i.ids,s=a[2],u=i.pos;if(s.length)for(var c=0,l=s.length;c<l;c++)o.push({pos:u+1,ids:s[c]});else{var f=!!a[1].deleted,p=a[0];t&&!(n!==f?n:r!==u?r<u:t<p)||(t=p,r=u,n=f)}}return r+"-"+t}function i(e,t){for(var r,n=e.slice();r=n.pop();)for(var i=r.pos,o=r.ids,a=o[2],s=t(0===a.length,i,o[0],r.ctx,o[1]),u=0,c=a.length;u<c;u++)n.push({pos:i+1,ids:a[u],ctx:s})}function o(e,t){return e.pos-t.pos}function a(e){var t=[];i(e,function(e,r,n,i,o){e&&t.push({rev:r+"-"+n,pos:r,opts:o})}),t.sort(o).reverse();for(var r=0,n=t.length;r<n;r++)delete t[r].pos;return t}function s(e){for(var t,r=[],n=e.slice();t=n.pop();){var i=t.pos,o=t.ids,a=o[0],s=o[1],u=o[2],c=0===u.length,l=t.history?t.history.slice():[];l.push({id:a,opts:s}),c&&r.push({pos:i+1-l.length,ids:l});for(var f=0,p=u.length;f<p;f++)n.push({pos:i+1,ids:u[f],history:l})}return r.reverse()}function u(e,t){return e.pos-t.pos}function c(e,t,r){for(var n,i=0,o=e.length;i<o;)r(e[n=i+o>>>1],t)<0?i=n+1:o=n;return i}function l(e,t,r){var n=c(e,t,r);e.splice(n,0,t)}function f(e,t){for(var r,n,i=t,o=e.length;i<o;i++){var a=e[i],s=[a.id,a.opts,[]];n?(n[2].push(s),n=s):r=n=s}return r}function p(e,t){return e[0]<t[0]?-1:1}function d(e,t){for(var r=[{tree1:e,tree2:t}],n=!1;r.length>0;){var i=r.pop(),o=i.tree1,a=i.tree2;(o[1].status||a[1].status)&&(o[1].status="available"===o[1].status||"available"===a[1].status?"available":"missing");for(var s=0;s<a[2].length;s++)if(o[2][0]){for(var u=!1,c=0;c<o[2].length;c++)o[2][c][0]===a[2][s][0]&&(r.push({tree1:o[2][c],tree2:a[2][s]}),u=!0);u||(n="new_branch",l(o[2],a[2][s],p))}else n="new_leaf",o[2][0]=a[2][s]}return{conflicts:n,tree:e}}function h(e,t,r){var n,i=[],o=!1,a=!1;if(!e.length)return{tree:[t],conflicts:"new_leaf"};for(var s=0,c=e.length;s<c;s++){var l=e[s];if(l.pos===t.pos&&l.ids[0]===t.ids[0])n=d(l.ids,t.ids),i.push({pos:l.pos,ids:n.tree}),o=o||n.conflicts,a=!0;else if(!0!==r){var f=l.pos<t.pos?l:t,p=l.pos<t.pos?t:l,h=p.pos-f.pos,m=[],v=[];for(v.push({ids:f.ids,diff:h,parent:null,parentIdx:null});v.length>0;){var y=v.pop();if(0!==y.diff)for(var g=y.ids[2],b=0,_=g.length;b<_;b++)v.push({ids:g[b],diff:y.diff-1,parent:y.ids,parentIdx:b});else y.ids[0]===p.ids[0]&&m.push(y)}var x=m[0];x?(n=d(x.ids,p.ids),x.parent[2][x.parentIdx]=n.tree,i.push({pos:f.pos,ids:f.ids}),o=o||n.conflicts,a=!0):i.push(l)}else i.push(l)}return a||i.push(t),i.sort(u),{tree:i,conflicts:o||"internal_node"}}function m(e,t){for(var r,n,o=s(e),a=0,u=o.length;a<u;a++){var c,l=o[a],p=l.ids;if(p.length>t){r||(r={});var d=p.length-t;c={pos:l.pos+d,ids:f(p,d)};for(var m=0;m<d;m++){var v=l.pos+m+"-"+p[m].id;r[v]=!0}}else c={pos:l.pos,ids:f(p,0)};n=n?h(n,c,!0).tree:[c]}return r&&i(n,function(e,t,n){delete r[t+"-"+n]}),{tree:n,revs:r?Object.keys(r):[]}}function v(e){return e.ids}Object.defineProperty(r,"__esModule",{value:!0}),r.collectConflicts=function(e){for(var t=n(e),r=a(e.rev_tree),i=[],o=0,s=r.length;o<s;o++){var u=r[o];u.rev===t||u.opts.deleted||i.push(u.rev)}return i},r.collectLeaves=a,r.compactTree=function(e){var t=[];return i(e.rev_tree,function(e,r,n,i,o){"available"!==o.status||e||(t.push(r+"-"+n),o.status="missing")}),t},r.isDeleted=function(e,t){t||(t=n(e));for(var r,i=t.substring(t.indexOf("-")+1),o=e.rev_tree.map(v);r=o.pop();){if(r[0]===i)return!!r[1].deleted;o=o.concat(r[2])}},r.isLocalId=function(e){return/^_local/.test(e)},r.merge=function(e,t,r){var n=h(e,t),i=m(n.tree,r);return{tree:i.tree,stemmedRevs:i.revs,conflicts:n.conflicts}},r.revExists=function(e,t){for(var r,n=e.slice(),i=t.split("-"),o=parseInt(i[0],10),a=i[1];r=n.pop();){if(r.pos===o&&r.ids[0]===a)return!0;for(var s=r.ids[2],u=0,c=s.length;u<c;u++)n.push({pos:r.pos+1,ids:s[u]})}return!1},r.rootToLeaf=s,r.traverseRevTree=i,r.winningRev=n,r.latest=function(e,t){for(var r,n=t.rev_tree.slice();r=n.pop();){var i=r.pos,o=r.ids,a=o[0],s=o[1],u=o[2],c=0===u.length,l=r.history?r.history.slice():[];if(l.push({id:a,pos:i,opts:s}),c)for(var f=0,p=l.length;f<p;f++){var d=l[f];if(d.pos+"-"+d.id===e)return i+"-"+a}for(var h=0,m=u.length;h<m;h++)n.push({pos:i+1,ids:u[h],history:l})}throw new Error("Unable to resolve latest revision for id "+t.id+", rev "+e)}},{}],67:[function(e,t,r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e){return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer||"undefined"!=typeof Blob&&e instanceof Blob}function o(e){if("function"==typeof e.slice)return e.slice(0);var t=new ArrayBuffer(e.byteLength),r=new Uint8Array(t),n=new Uint8Array(e);return r.set(n),t}function a(e){if(e instanceof ArrayBuffer)return o(e);var t=e.size,r=e.type;return"function"==typeof e.slice?e.slice(0,t,r):e.webkitSlice(0,t,r)}function s(e){var t=Object.getPrototypeOf(e);if(null===t)return!0;var r=t.constructor;return"function"==typeof r&&r instanceof r&&P.call(r)==T}function u(e){var t,r,n;if(!e||"object"!=typeof e)return e;if(Array.isArray(e)){for(t=[],r=0,n=e.length;r<n;r++)t[r]=u(e[r]);return t}if(e instanceof Date)return e.toISOString();if(i(e))return a(e);if(!s(e))return e;t={};for(r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var o=u(e[r]);void 0!==o&&(t[r]=o)}return t}function c(e){var t=!1;return D(function(r){if(t)throw new Error("once called more than once");t=!0,e.apply(this,r)})}function l(e){return D(function(t){var r=this,n="function"==typeof(t=u(t))[t.length-1]&&t.pop(),i=new A(function(n,i){var o;try{var a=c(function(e,t){e?i(e):n(t)});t.push(a),(o=e.apply(r,t))&&"function"==typeof o.then&&n(o)}catch(e){i(e)}});return n&&i.then(function(e){n(null,e)},n),i})}function f(e,t,r){if(e.constructor.listeners("debug").length){for(var n=["api",e.name,t],i=0;i<r.length-1;i++)n.push(r[i]);e.constructor.emit("debug",n);var o=r[r.length-1];r[r.length-1]=function(r,n){var i=["api",e.name,t];i=i.concat(r?["error",r]:["success",n]),e.constructor.emit("debug",i),o(r,n)}}}function p(e,t){for(var r={},n=0,i=t.length;n<i;n++){var o=t[n];o in e&&(r[o]=e[o])}return r}function d(e){return e}function h(e){return[{ok:e}]}function m(){return"undefined"!=typeof chrome&&void 0!==chrome.storage&&void 0!==chrome.storage.local}function v(){return S}function y(e){m()?chrome.storage.onChanged.addListener(function(t){null!=t.db_name&&e.emit(t.dbName.newValue)}):v()&&("undefined"!=typeof addEventListener?addEventListener("storage",function(t){e.emit(t.key)}):window.attachEvent("storage",function(t){e.emit(t.key)}))}function g(){F.EventEmitter.call(this),this._listeners={},y(this)}function b(e){if("undefined"!==console&&e in console){var t=Array.prototype.slice.call(arguments,1);console[e].apply(console,t)}}function _(e,t){return e=parseInt(e,10)||0,(t=parseInt(t,10))!==t||t<=e?t=(e||1)<<1:t+=1,t>6e5&&(e=3e5,t=6e5),~~((t-e)*Math.random()+e)}function x(e,t,r){try{return!e(t,r)}catch(e){var n="Filter function threw: "+e.toString();return R.createError(R.BAD_REQUEST,n)}}function w(e){if(!e)return null;var t=e.split("/");return 2===t.length?t:1===t.length?[e,e]:null}function k(e,t,r){return new A(function(n,i){e.get(t,function(o,a){if(o){if(404!==o.status)return i(o);a={}}var s=a._rev,u=r(a);if(!u)return n({updated:!1,rev:s});u._id=t,u._rev=s,n(E(e,u,r))})})}function E(e,t,r){return e.put(t).then(function(e){return{updated:!0,rev:e.rev}},function(n){if(409!==n.status)throw n;return k(e,t._id,r)})}Object.defineProperty(r,"__esModule",{value:!0});var S,A=n(e("pouchdb-promise")),D=n(e("argsarray")),C=e("pouchdb-collections"),F=e("events"),O=n(e("inherits")),j=n(e("immediate")),R=e("pouchdb-errors"),B=n(e("uuid/v4")),P=Function.prototype.toString,T=P.call(Object),I=6;if(m())S=!1;else try{localStorage.setItem("_pouch_check_localstorage",1),S=!!localStorage.getItem("_pouch_check_localstorage")}catch(e){S=!1}O(g,F.EventEmitter),g.prototype.addListener=function(e,t,r,n){function i(){if(o._listeners[t])if(a)a="waiting";else{a=!0;var e=p(n,["style","include_docs","attachments","conflicts","filter","doc_ids","view","since","query_params","binary"]);r.changes(e).on("change",function(e){e.seq>n.since&&!n.cancelled&&(n.since=e.seq,n.onChange(e))}).on("complete",function(){"waiting"===a&&j(i),a=!1}).on("error",function(){a=!1})}}if(!this._listeners[t]){var o=this,a=!1;this._listeners[t]=i,this.on(e,i)}},g.prototype.removeListener=function(e,t){t in this._listeners&&(F.EventEmitter.prototype.removeListener.call(this,e,this._listeners[t]),delete this._listeners[t])},g.prototype.notifyLocalWindows=function(e){m()?chrome.storage.local.set({dbName:e}):v()&&(localStorage[e]="a"===localStorage[e]?"b":"a")},g.prototype.notify=function(e){this.emit(e),this.notifyLocalWindows(e)};var L,N,M=L="function"==typeof Object.assign?Object.assign:function(e){for(var t=Object(e),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},q=N=function(){}.name?function(e){return e.name}:function(e){return e.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]},$=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],W="queryKey",U=/(?:^|&)([^&=]*)=?([^&]*)/g,z=/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,V=B;r.adapterFun=function(e,t){return l(D(function(r){if(this._closed)return A.reject(new Error("database is closed"));if(this._destroyed)return A.reject(new Error("database is destroyed"));var n=this;return f(n,e,r),this.taskqueue.isReady?t.apply(this,r):new A(function(t,i){n.taskqueue.addTask(function(o){o?i(o):t(n[e].apply(n,r))})})}))},r.assign=M,r.bulkGetShim=function(e,t,r){function n(){var e=[];m.forEach(function(t){t.docs.forEach(function(r){e.push({id:t.id,docs:[r]})})}),r(null,{results:e})}function i(){++f===l&&n()}function o(e,t,r){m[e]={id:t,docs:r},i()}function a(){if(!(y>=v.length)){var e=Math.min(y+I,v.length),t=v.slice(y,e);s(t,y),y+=t.length}}function s(r,n){r.forEach(function(r,i){var s=n+i,u=c.get(r),l=p(u[0],["atts_since","attachments"]);l.open_revs=u.map(function(e){return e.rev}),l.open_revs=l.open_revs.filter(d);var f=d;0===l.open_revs.length&&(delete l.open_revs,f=h),["revs","attachments","binary","ajax","latest"].forEach(function(e){e in t&&(l[e]=t[e])}),e.get(r,l,function(e,t){var n;n=e?[{error:e}]:f(t),o(s,r,n),a()})})}var u=t.docs,c=new C.Map;u.forEach(function(e){c.has(e.id)?c.get(e.id).push(e):c.set(e.id,[e])});var l=c.size,f=0,m=new Array(l),v=[];c.forEach(function(e,t){v.push(t)});var y=0;a()},r.changesHandler=g,r.clone=u,r.defaultBackOff=function(e){var t=0;return e||(t=2e3),_(e,t)},r.explainError=function(e,t){b("info","The above "+e+" is totally normal. "+t)},r.filterChange=function(e){var t={},r=e.filter&&"function"==typeof e.filter;return t.query=e.query_params,function(n){n.doc||(n.doc={});var i=r&&x(e.filter,n.doc,t);if("object"==typeof i)return i;if(i)return!1;if(e.include_docs){if(!e.attachments)for(var o in n.doc._attachments)n.doc._attachments.hasOwnProperty(o)&&(n.doc._attachments[o].stub=!0)}else delete n.doc;return!0}},r.flatten=function(e){for(var t=[],r=0,n=e.length;r<n;r++)t=t.concat(e[r]);return t},r.functionName=q,r.guardedConsole=b,r.hasLocalStorage=v,r.invalidIdError=function(e){var t;if(e?"string"!=typeof e?t=R.createError(R.INVALID_ID):/^_/.test(e)&&!/^_(design|local)/.test(e)&&(t=R.createError(R.RESERVED_ID)):t=R.createError(R.MISSING_ID),t)throw t},r.isChromeApp=m,r.isCordova=function(){return"undefined"!=typeof cordova||"undefined"!=typeof PhoneGap||"undefined"!=typeof phonegap},r.isRemote=function(e){return"boolean"==typeof e._remote?e._remote:"function"==typeof e.type&&(b("warn","db.type() is deprecated and will be removed in a future version of PouchDB"),"http"===e.type())},r.listenerCount=function(e,t){return"listenerCount"in e?e.listenerCount(t):F.EventEmitter.listenerCount(e,t)},r.nextTick=j,r.normalizeDdocFunctionName=function(e){var t=w(e);return t?t.join("/"):null},r.once=c,r.parseDdocFunctionName=w,r.parseUri=function(e){for(var t=z.exec(e),r={},n=14;n--;){var i=$[n],o=t[n]||"",a=-1!==["user","password"].indexOf(i);r[i]=a?decodeURIComponent(o):o}return r[W]={},r[$[12]].replace(U,function(e,t,n){t&&(r[W][t]=n)}),r},r.pick=p,r.rev=function(){return B().replace(/-/g,"").toLowerCase()},r.scopeEval=function(e,t){var r=[],n=[];for(var i in t)t.hasOwnProperty(i)&&(r.push(i),n.push(t[i]));return r.push(e),Function.apply(null,r).apply(null,n)},r.toPromise=l,r.upsert=k,r.uuid=V},{argsarray:1,events:18,immediate:23,inherits:24,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-promise":68,"uuid/v4":117}],68:[function(e,t,r){arguments[4][58][0].apply(r,arguments)},{dup:58,lie:40}],69:[function(e,t,r){(function(e){"use strict";!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports=function(t,r,n,i){if("function"!=typeof t)throw new TypeError('"callback" argument must be a function');var o,a,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick(function(){t.call(null,r)});case 3:return e.nextTick(function(){t.call(null,r,n)});case 4:return e.nextTick(function(){t.call(null,r,n,i)});default:for(o=new Array(s-1),a=0;a<o.length;)o[a++]=arguments[a];return e.nextTick(function(){t.apply(null,o)})}}:t.exports=e.nextTick}).call(this,e("_process"))},{_process:70}],70:[function(e,t,r){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(e){if(f===setTimeout)return setTimeout(e,0);if((f===n||!f)&&setTimeout)return f=setTimeout,setTimeout(e,0);try{return f(e,0)}catch(t){try{return f.call(null,e,0)}catch(t){return f.call(this,e,0)}}}function a(e){if(p===clearTimeout)return clearTimeout(e);if((p===i||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(e);try{return p(e)}catch(t){try{return p.call(null,e)}catch(t){return p.call(this,e)}}}function s(){v&&h&&(v=!1,h.length?m=h.concat(m):y=-1,m.length&&u())}function u(){if(!v){var e=o(s);v=!0;for(var t=m.length;t;){for(h=m,m=[];++y<t;)h&&h[y].run();y=-1,t=m.length}h=null,v=!1,a(e)}}function c(e,t){this.fun=e,this.array=t}function l(){}var f,p,d=t.exports={};!function(){try{f="function"==typeof setTimeout?setTimeout:n}catch(e){f=n}try{p="function"==typeof clearTimeout?clearTimeout:i}catch(e){p=i}}();var h,m=[],v=!1,y=-1;d.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];m.push(new c(e,t)),1!==m.length||v||o(u)},c.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(e){return[]},d.binding=function(e){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(e){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},{}],71:[function(e,t,r){arguments[4][17][0].apply(r,arguments)},{dup:17}],72:[function(e,t,r){(function(r){function n(e){if(!(this instanceof n))return new n(e);s.call(this,e),u.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",i)}function i(){this.allowHalfOpen||this._writableState.ended||r.nextTick(this.end.bind(this))}t.exports=n;var o=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t},a=e("core-util-is");a.inherits=e("inherits");var s=e("./_stream_readable"),u=e("./_stream_writable");a.inherits(n,s),function(e,t){for(var r=0,n=e.length;r<n;r++)t(e[r],r)}(o(u.prototype),function(e){n.prototype[e]||(n.prototype[e]=u.prototype[e])})}).call(this,e("_process"))},{"./_stream_readable":74,"./_stream_writable":76,_process:70,"core-util-is":6,inherits:24}],73:[function(e,t,r){function n(e){if(!(this instanceof n))return new n(e);i.call(this,e)}t.exports=n;var i=e("./_stream_transform"),o=e("core-util-is");o.inherits=e("inherits"),o.inherits(n,i),n.prototype._transform=function(e,t,r){r(null,e)}},{"./_stream_transform":75,"core-util-is":6,inherits:24}],74:[function(e,t,r){(function(r){function n(t,r){var n=(t=t||{}).highWaterMark;this.highWaterMark=n||0===n?n:16384,this.highWaterMark=~~this.highWaterMark,this.buffer=[],this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=!1,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.calledRead=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.objectMode=!!t.objectMode,this.defaultEncoding=t.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(C||(C=e("string_decoder/").StringDecoder),this.decoder=new C(t.encoding),this.encoding=t.encoding)}function i(e){if(!(this instanceof i))return new i(e);this._readableState=new n(e,this),this.readable=!0,A.call(this)}function o(e,t,r,n,i){var o=c(t,r);if(o)e.emit("error",o);else if(null===r||void 0===r)t.reading=!1,t.ended||l(e,t);else if(t.objectMode||r&&r.length>0)if(t.ended&&!i){s=new Error("stream.push() after EOF");e.emit("error",s)}else if(t.endEmitted&&i){var s=new Error("stream.unshift() after end event");e.emit("error",s)}else!t.decoder||i||n||(r=t.decoder.write(r)),t.length+=t.objectMode?1:r.length,i?t.buffer.unshift(r):(t.reading=!1,t.buffer.push(r)),t.needReadable&&f(e),d(e,t);else i||(t.reading=!1);return a(t)}function a(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}function s(e){if(e>=F)e=F;else{e--;for(var t=1;t<32;t<<=1)e|=e>>t;e++}return e}function u(e,t){return 0===t.length&&t.ended?0:t.objectMode?0===e?0:1:null===e||isNaN(e)?t.flowing&&t.buffer.length?t.buffer[0].length:t.length:e<=0?0:(e>t.highWaterMark&&(t.highWaterMark=s(e)),e>t.length?t.ended?t.length:(t.needReadable=!0,0):e)}function c(e,t){var r=null;return E.isBuffer(t)||"string"==typeof t||null===t||void 0===t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk")),r}function l(e,t){if(t.decoder&&!t.ended){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,t.length>0?f(e):_(e)}function f(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,t.sync?r.nextTick(function(){p(e)}):p(e))}function p(e){e.emit("readable")}function d(e,t){t.readingMore||(t.readingMore=!0,r.nextTick(function(){h(e,t)}))}function h(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function m(e){return function(){var t=e._readableState;t.awaitDrain--,0===t.awaitDrain&&v(e)}}function v(e){function t(e,t,i){!1===e.write(r)&&n.awaitDrain++}var r,n=e._readableState;for(n.awaitDrain=0;n.pipesCount&&null!==(r=e.read());)if(1===n.pipesCount?t(n.pipes):x(n.pipes,t),e.emit("data",r),n.awaitDrain>0)return;if(0===n.pipesCount)return n.flowing=!1,void(S.listenerCount(e,"data")>0&&g(e));n.ranOut=!0}function y(){this._readableState.ranOut&&(this._readableState.ranOut=!1,v(this))}function g(e,t){if(e._readableState.flowing)throw new Error("Cannot switch to old mode now.");var n=t||!1,i=!1;e.readable=!0,e.pipe=A.prototype.pipe,e.on=e.addListener=A.prototype.on,e.on("readable",function(){i=!0;for(var t;!n&&null!==(t=e.read());)e.emit("data",t);null===t&&(i=!1,e._readableState.needReadable=!0)}),e.pause=function(){n=!0,this.emit("pause")},e.resume=function(){n=!1,i?r.nextTick(function(){e.emit("readable")}):this.read(0),this.emit("resume")},e.emit("readable")}function b(e,t){var r,n=t.buffer,i=t.length,o=!!t.decoder,a=!!t.objectMode;if(0===n.length)return null;if(0===i)r=null;else if(a)r=n.shift();else if(!e||e>=i)r=o?n.join(""):E.concat(n,i),n.length=0;else if(e<n[0].length)r=(l=n[0]).slice(0,e),n[0]=l.slice(e);else if(e===n[0].length)r=n.shift();else{r=o?"":new E(e);for(var s=0,u=0,c=n.length;u<c&&s<e;u++){var l=n[0],f=Math.min(e-s,l.length);o?r+=l.slice(0,f):l.copy(r,s,0,f),f<l.length?n[0]=l.slice(f):n.shift(),s+=f}}return r}function _(e){var t=e._readableState;if(t.length>0)throw new Error("endReadable called on non-empty stream");!t.endEmitted&&t.calledRead&&(t.ended=!0,r.nextTick(function(){t.endEmitted||0!==t.length||(t.endEmitted=!0,e.readable=!1,e.emit("end"))}))}function x(e,t){for(var r=0,n=e.length;r<n;r++)t(e[r],r)}function w(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}t.exports=i;var k=e("isarray"),E=e("buffer").Buffer;i.ReadableState=n;var S=e("events").EventEmitter;S.listenerCount||(S.listenerCount=function(e,t){return e.listeners(t).length});var A=e("stream"),D=e("core-util-is");D.inherits=e("inherits");var C;D.inherits(i,A),i.prototype.push=function(e,t){var r=this._readableState;return"string"!=typeof e||r.objectMode||(t=t||r.defaultEncoding)!==r.encoding&&(e=new E(e,t),t=""),o(this,r,e,t,!1)},i.prototype.unshift=function(e){return o(this,this._readableState,e,"",!0)},i.prototype.setEncoding=function(t){C||(C=e("string_decoder/").StringDecoder),this._readableState.decoder=new C(t),this._readableState.encoding=t};var F=8388608;i.prototype.read=function(e){var t=this._readableState;t.calledRead=!0;var r,n=e;if(("number"!=typeof e||e>0)&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return f(this),null;if(0===(e=u(e,t))&&t.ended)return r=null,t.length>0&&t.decoder&&(r=b(e,t),t.length-=r.length),0===t.length&&_(this),r;var i=t.needReadable;return t.length-e<=t.highWaterMark&&(i=!0),(t.ended||t.reading)&&(i=!1),i&&(t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1),i&&!t.reading&&(e=u(n,t)),null===(r=e>0?b(e,t):null)&&(t.needReadable=!0,e=0),t.length-=e,0!==t.length||t.ended||(t.needReadable=!0),t.ended&&!t.endEmitted&&0===t.length&&_(this),r},i.prototype._read=function(e){this.emit("error",new Error("not implemented"))},i.prototype.pipe=function(e,t){function n(e){e===l&&o()}function i(){e.end()}function o(){e.removeListener("close",s),e.removeListener("finish",u),e.removeListener("drain",d),e.removeListener("error",a),e.removeListener("unpipe",n),l.removeListener("end",i),l.removeListener("end",o),e._writableState&&!e._writableState.needDrain||d()}function a(t){c(),e.removeListener("error",a),0===S.listenerCount(e,"error")&&e.emit("error",t)}function s(){e.removeListener("finish",u),c()}function u(){e.removeListener("close",s),c()}function c(){l.unpipe(e)}var l=this,f=this._readableState;switch(f.pipesCount){case 0:f.pipes=e;break;case 1:f.pipes=[f.pipes,e];break;default:f.pipes.push(e)}f.pipesCount+=1;var p=(!t||!1!==t.end)&&e!==r.stdout&&e!==r.stderr?i:o;f.endEmitted?r.nextTick(p):l.once("end",p),e.on("unpipe",n);var d=m(l);return e.on("drain",d),e._events&&e._events.error?k(e._events.error)?e._events.error.unshift(a):e._events.error=[a,e._events.error]:e.on("error",a),e.once("close",s),e.once("finish",u),e.emit("pipe",l),f.flowing||(this.on("readable",y),f.flowing=!0,r.nextTick(function(){v(l)})),e},i.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,this.removeListener("readable",y),t.flowing=!1,e&&e.emit("unpipe",this),this);if(!e){var r=t.pipes,n=t.pipesCount;t.pipes=null,t.pipesCount=0,this.removeListener("readable",y),t.flowing=!1;for(var i=0;i<n;i++)r[i].emit("unpipe",this);return this}return-1===(i=w(t.pipes,e))?this:(t.pipes.splice(i,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this),this)},i.prototype.on=function(e,t){var r=A.prototype.on.call(this,e,t);if("data"!==e||this._readableState.flowing||g(this),"readable"===e&&this.readable){var n=this._readableState;n.readableListening||(n.readableListening=!0,n.emittedReadable=!1,n.needReadable=!0,n.reading?n.length&&f(this):this.read(0))}return r},i.prototype.addListener=i.prototype.on,i.prototype.resume=function(){g(this),this.read(0),this.emit("resume")},i.prototype.pause=function(){g(this,!0),this.emit("pause")},i.prototype.wrap=function(e){var t=this._readableState,r=!1,n=this;e.on("end",function(){if(t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&n.push(e)}n.push(null)}),e.on("data",function(i){t.decoder&&(i=t.decoder.write(i)),(!t.objectMode||null!==i&&void 0!==i)&&(t.objectMode||i&&i.length)&&(n.push(i)||(r=!0,e.pause()))});for(var i in e)"function"==typeof e[i]&&void 0===this[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));return x(["error","close","destroy","pause","resume"],function(t){e.on(t,n.emit.bind(n,t))}),n._read=function(t){r&&(r=!1,e.resume())},n},i._fromList=b}).call(this,e("_process"))},{_process:70,buffer:5,"core-util-is":6,events:18,inherits:24,isarray:77,stream:81,"string_decoder/":96}],75:[function(e,t,r){function n(e,t){this.afterTransform=function(e,r){return i(t,e,r)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null}function i(e,t,r){var n=e._transformState;n.transforming=!1;var i=n.writecb;if(!i)return e.emit("error",new Error("no writecb in Transform class"));n.writechunk=null,n.writecb=null,null!==r&&void 0!==r&&e.push(r),i&&i(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}function o(e){if(!(this instanceof o))return new o(e);s.call(this,e);this._transformState=new n(e,this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,this.once("finish",function(){"function"==typeof this._flush?this._flush(function(e){a(t,e)}):a(t)})}function a(e,t){if(t)return e.emit("error",t);var r=e._writableState,n=(e._readableState,e._transformState);if(r.length)throw new Error("calling transform done when ws.length != 0");if(n.transforming)throw new Error("calling transform done when still transforming");return e.push(null)}t.exports=o;var s=e("./_stream_duplex"),u=e("core-util-is");u.inherits=e("inherits"),u.inherits(o,s),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,s.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,r){throw new Error("not implemented")},o.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0}},{"./_stream_duplex":72,"core-util-is":6,inherits:24}],76:[function(e,t,r){(function(r){function n(e,t,r){this.chunk=e,this.encoding=t,this.callback=r}function i(e,t){var r=(e=e||{}).highWaterMark;this.highWaterMark=r||0===r?r:16384,this.objectMode=!!e.objectMode,this.highWaterMark=~~this.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var n=!1===e.decodeStrings;this.decodeStrings=!n,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){d(t,e)},this.writecb=null,this.writelen=0,this.buffer=[],this.errorEmitted=!1}function o(t){var r=e("./_stream_duplex");if(!(this instanceof o||this instanceof r))return new o(t);this._writableState=new i(t,this),this.writable=!0,w.call(this)}function a(e,t,n){var i=new Error("write after end");e.emit("error",i),r.nextTick(function(){n(i)})}function s(e,t,n,i){var o=!0;if(!_.isBuffer(n)&&"string"!=typeof n&&null!==n&&void 0!==n&&!t.objectMode){var a=new TypeError("Invalid non-string/buffer chunk");e.emit("error",a),r.nextTick(function(){i(a)}),o=!1}return o}function u(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=new _(t,r)),t}function c(e,t,r,i,o){r=u(t,r,i),_.isBuffer(r)&&(i="buffer");var a=t.objectMode?1:r.length;t.length+=a;var s=t.length<t.highWaterMark;return s||(t.needDrain=!0),t.writing?t.buffer.push(new n(r,i,o)):l(e,t,a,r,i,o),s}function l(e,t,r,n,i,o){t.writelen=r,t.writecb=o,t.writing=!0,t.sync=!0,e._write(n,i,t.onwrite),t.sync=!1}function f(e,t,n,i,o){n?r.nextTick(function(){o(i)}):o(i),e._writableState.errorEmitted=!0,e.emit("error",i)}function p(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function d(e,t){var n=e._writableState,i=n.sync,o=n.writecb;if(p(n),t)f(e,n,i,t,o);else{var a=y(e,n);a||n.bufferProcessing||!n.buffer.length||v(e,n),i?r.nextTick(function(){h(e,n,a,o)}):h(e,n,a,o)}}function h(e,t,r,n){r||m(e,t),n(),r&&g(e,t)}function m(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}function v(e,t){t.bufferProcessing=!0;for(var r=0;r<t.buffer.length;r++){var n=t.buffer[r],i=n.chunk,o=n.encoding,a=n.callback;if(l(e,t,t.objectMode?1:i.length,i,o,a),t.writing){r++;break}}t.bufferProcessing=!1,r<t.buffer.length?t.buffer=t.buffer.slice(r):t.buffer.length=0}function y(e,t){return t.ending&&0===t.length&&!t.finished&&!t.writing}function g(e,t){var r=y(e,t);return r&&(t.finished=!0,e.emit("finish")),r}function b(e,t,n){t.ending=!0,g(e,t),n&&(t.finished?r.nextTick(n):e.once("finish",n)),t.ended=!0}t.exports=o;var _=e("buffer").Buffer;o.WritableState=i;var x=e("core-util-is");x.inherits=e("inherits");var w=e("stream");x.inherits(o,w),o.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe. Not readable."))},o.prototype.write=function(e,t,r){var n=this._writableState,i=!1;return"function"==typeof t&&(r=t,t=null),_.isBuffer(e)?t="buffer":t||(t=n.defaultEncoding),"function"!=typeof r&&(r=function(){}),n.ended?a(this,0,r):s(this,n,e,r)&&(i=c(this,n,e,t,r)),i},o.prototype._write=function(e,t,r){r(new Error("not implemented"))},o.prototype.end=function(e,t,r){var n=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),void 0!==e&&null!==e&&this.write(e,t),n.ending||n.finished||b(this,n,r)}}).call(this,e("_process"))},{"./_stream_duplex":72,_process:70,buffer:5,"core-util-is":6,inherits:24,stream:81}],77:[function(e,t,r){t.exports=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)}},{}],78:[function(e,t,r){var n=e("stream");(r=t.exports=e("./lib/_stream_readable.js")).Stream=n,r.Readable=r,r.Writable=e("./lib/_stream_writable.js"),r.Duplex=e("./lib/_stream_duplex.js"),r.Transform=e("./lib/_stream_transform.js"),r.PassThrough=e("./lib/_stream_passthrough.js")},{"./lib/_stream_duplex.js":72,"./lib/_stream_passthrough.js":73,"./lib/_stream_readable.js":74,"./lib/_stream_transform.js":75,"./lib/_stream_writable.js":76,stream:81}],79:[function(e,t,r){function n(e,t){for(var r in e)t[r]=e[r]}function i(e,t,r){return a(e,t,r)}var o=e("buffer"),a=o.Buffer;a.from&&a.alloc&&a.allocUnsafe&&a.allocUnsafeSlow?t.exports=o:(n(o,r),r.Buffer=i),n(a,i),i.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return a(e,t,r)},i.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=a(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},i.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return a(e)},i.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return o.SlowBuffer(e)}},{buffer:5}],80:[function(e,t,r){!function(e){if("object"==typeof r)t.exports=e();else{var n;try{n=window}catch(e){n=self}n.SparkMD5=e()}}(function(e){"use strict";function t(e,t){var r=e[0],n=e[1],i=e[2],o=e[3];n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[0]-680876936|0)<<7|r>>>25)+n|0)&n|~r&i)+t[1]-389564586|0)<<12|o>>>20)+r|0)&r|~o&n)+t[2]+606105819|0)<<17|i>>>15)+o|0)&o|~i&r)+t[3]-1044525330|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[4]-176418897|0)<<7|r>>>25)+n|0)&n|~r&i)+t[5]+1200080426|0)<<12|o>>>20)+r|0)&r|~o&n)+t[6]-1473231341|0)<<17|i>>>15)+o|0)&o|~i&r)+t[7]-45705983|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[8]+1770035416|0)<<7|r>>>25)+n|0)&n|~r&i)+t[9]-1958414417|0)<<12|o>>>20)+r|0)&r|~o&n)+t[10]-42063|0)<<17|i>>>15)+o|0)&o|~i&r)+t[11]-1990404162|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[12]+1804603682|0)<<7|r>>>25)+n|0)&n|~r&i)+t[13]-40341101|0)<<12|o>>>20)+r|0)&r|~o&n)+t[14]-1502002290|0)<<17|i>>>15)+o|0)&o|~i&r)+t[15]+1236535329|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[1]-165796510|0)<<5|r>>>27)+n|0)&i|n&~i)+t[6]-1069501632|0)<<9|o>>>23)+r|0)&n|r&~n)+t[11]+643717713|0)<<14|i>>>18)+o|0)&r|o&~r)+t[0]-373897302|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[5]-701558691|0)<<5|r>>>27)+n|0)&i|n&~i)+t[10]+38016083|0)<<9|o>>>23)+r|0)&n|r&~n)+t[15]-660478335|0)<<14|i>>>18)+o|0)&r|o&~r)+t[4]-405537848|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[9]+568446438|0)<<5|r>>>27)+n|0)&i|n&~i)+t[14]-1019803690|0)<<9|o>>>23)+r|0)&n|r&~n)+t[3]-187363961|0)<<14|i>>>18)+o|0)&r|o&~r)+t[8]+1163531501|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[13]-1444681467|0)<<5|r>>>27)+n|0)&i|n&~i)+t[2]-51403784|0)<<9|o>>>23)+r|0)&n|r&~n)+t[7]+1735328473|0)<<14|i>>>18)+o|0)&r|o&~r)+t[12]-1926607734|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[5]-378558|0)<<4|r>>>28)+n|0)^n^i)+t[8]-2022574463|0)<<11|o>>>21)+r|0)^r^n)+t[11]+1839030562|0)<<16|i>>>16)+o|0)^o^r)+t[14]-35309556|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[1]-1530992060|0)<<4|r>>>28)+n|0)^n^i)+t[4]+1272893353|0)<<11|o>>>21)+r|0)^r^n)+t[7]-155497632|0)<<16|i>>>16)+o|0)^o^r)+t[10]-1094730640|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[13]+681279174|0)<<4|r>>>28)+n|0)^n^i)+t[0]-358537222|0)<<11|o>>>21)+r|0)^r^n)+t[3]-722521979|0)<<16|i>>>16)+o|0)^o^r)+t[6]+76029189|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[9]-640364487|0)<<4|r>>>28)+n|0)^n^i)+t[12]-421815835|0)<<11|o>>>21)+r|0)^r^n)+t[15]+530742520|0)<<16|i>>>16)+o|0)^o^r)+t[2]-995338651|0)<<23|n>>>9)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[0]-198630844|0)<<6|r>>>26)+n|0)|~i))+t[7]+1126891415|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[14]-1416354905|0)<<15|i>>>17)+o|0)|~r))+t[5]-57434055|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[12]+1700485571|0)<<6|r>>>26)+n|0)|~i))+t[3]-1894986606|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[10]-1051523|0)<<15|i>>>17)+o|0)|~r))+t[1]-2054922799|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[8]+1873313359|0)<<6|r>>>26)+n|0)|~i))+t[15]-30611744|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[6]-1560198380|0)<<15|i>>>17)+o|0)|~r))+t[13]+1309151649|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[4]-145523070|0)<<6|r>>>26)+n|0)|~i))+t[11]-1120210379|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[2]+718787259|0)<<15|i>>>17)+o|0)|~r))+t[9]-343485551|0)<<21|n>>>11)+i|0,e[0]=r+e[0]|0,e[1]=n+e[1]|0,e[2]=i+e[2]|0,e[3]=o+e[3]|0}function r(e){var t,r=[];for(t=0;t<64;t+=4)r[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return r}function n(e){var t,r=[];for(t=0;t<64;t+=4)r[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return r}function i(e){var n,i,o,a,s,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(l,r(e.substring(n-64,n)));for(i=(e=e.substring(n-64)).length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<i;n+=1)o[n>>2]|=e.charCodeAt(n)<<(n%4<<3);if(o[n>>2]|=128<<(n%4<<3),n>55)for(t(l,o),n=0;n<16;n+=1)o[n]=0;return a=8*c,a=a.toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(a[2],16),u=parseInt(a[1],16)||0,o[14]=s,o[15]=u,t(l,o),l}function o(e){var r,i,o,a,s,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(l,n(e.subarray(r-64,r)));for(i=(e=r-64<c?e.subarray(r-64):new Uint8Array(0)).length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<i;r+=1)o[r>>2]|=e[r]<<(r%4<<3);if(o[r>>2]|=128<<(r%4<<3),r>55)for(t(l,o),r=0;r<16;r+=1)o[r]=0;return a=8*c,a=a.toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(a[2],16),u=parseInt(a[1],16)||0,o[14]=s,o[15]=u,t(l,o),l}function a(e){var t,r="";for(t=0;t<4;t+=1)r+=h[e>>8*t+4&15]+h[e>>8*t&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function u(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e,t){var r,n=e.length,i=new ArrayBuffer(n),o=new Uint8Array(i);for(r=0;r<n;r+=1)o[r]=e.charCodeAt(r);return t?o:i}function l(e){return String.fromCharCode.apply(null,new Uint8Array(e))}function f(e,t,r){var n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e)),n.set(new Uint8Array(t),e.byteLength),r?n:n.buffer}function p(e){var t,r=[],n=e.length;for(t=0;t<n-1;t+=2)r.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,r)}function d(){this.reset()}var h=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];return"5d41402abc4b2a76b9719d911017c592"!==s(i("hello"))&&function(e,t){var r=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(r>>16)<<16|65535&r},"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function t(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(r,n){var i,o,a,s,u=this.byteLength,c=t(r,u),l=u;return n!==e&&(l=t(n,u)),c>l?new ArrayBuffer(0):(i=l-c,o=new ArrayBuffer(i),a=new Uint8Array(o),s=new Uint8Array(this,c,i),a.set(s),o)}}(),d.prototype.append=function(e){return this.appendBinary(u(e)),this},d.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var n,i=this._buff.length;for(n=64;n<=i;n+=64)t(this._hash,r(this._buff.substring(n-64,n)));return this._buff=this._buff.substring(n-64),this},d.prototype.end=function(e){var t,r,n=this._buff,i=n.length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<i;t+=1)o[t>>2]|=n.charCodeAt(t)<<(t%4<<3);return this._finish(o,i),r=s(this._hash),e&&(r=p(r)),this.reset(),r},d.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},d.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash}},d.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},d.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},d.prototype._finish=function(e,r){var n,i,o,a=r;if(e[a>>2]|=128<<(a%4<<3),a>55)for(t(this._hash,e),a=0;a<16;a+=1)e[a]=0;n=(n=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(n[2],16),o=parseInt(n[1],16)||0,e[14]=i,e[15]=o,t(this._hash,e)},d.hash=function(e,t){return d.hashBinary(u(e),t)},d.hashBinary=function(e,t){var r=s(i(e));return t?p(r):r},d.ArrayBuffer=function(){this.reset()},d.ArrayBuffer.prototype.append=function(e){var r,i=f(this._buff.buffer,e,!0),o=i.length;for(this._length+=e.byteLength,r=64;r<=o;r+=64)t(this._hash,n(i.subarray(r-64,r)));return this._buff=r-64<o?new Uint8Array(i.buffer.slice(r-64)):new Uint8Array(0),this},d.ArrayBuffer.prototype.end=function(e){var t,r,n=this._buff,i=n.length,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<i;t+=1)o[t>>2]|=n[t]<<(t%4<<3);return this._finish(o,i),r=s(this._hash),e&&(r=p(r)),this.reset(),r},d.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},d.ArrayBuffer.prototype.getState=function(){var e=d.prototype.getState.call(this);return e.buff=l(e.buff),e},d.ArrayBuffer.prototype.setState=function(e){return e.buff=c(e.buff,!0),d.prototype.setState.call(this,e)},d.ArrayBuffer.prototype.destroy=d.prototype.destroy,d.ArrayBuffer.prototype._finish=d.prototype._finish,d.ArrayBuffer.hash=function(e,t){var r=s(o(new Uint8Array(e)));return t?p(r):r},d})},{}],81:[function(e,t,r){function n(){i.call(this)}t.exports=n;var i=e("events").EventEmitter;e("inherits")(n,i),n.Readable=e("readable-stream/readable.js"),n.Writable=e("readable-stream/writable.js"),n.Duplex=e("readable-stream/duplex.js"),n.Transform=e("readable-stream/transform.js"),n.PassThrough=e("readable-stream/passthrough.js"),n.Stream=n,n.prototype.pipe=function(e,t){function r(t){e.writable&&!1===e.write(t)&&c.pause&&c.pause()}function n(){c.readable&&c.resume&&c.resume()}function o(){l||(l=!0,e.end())}function a(){l||(l=!0,"function"==typeof e.destroy&&e.destroy())}function s(e){if(u(),0===i.listenerCount(this,"error"))throw e}function u(){c.removeListener("data",r),e.removeListener("drain",n),c.removeListener("end",o),c.removeListener("close",a),c.removeListener("error",s),e.removeListener("error",s),c.removeListener("end",u),c.removeListener("close",u),e.removeListener("close",u)}var c=this;c.on("data",r),e.on("drain",n),e._isStdio||t&&!1===t.end||(c.on("end",o),c.on("close",a));var l=!1;return c.on("error",s),e.on("error",s),c.on("end",u),c.on("close",u),e.on("close",u),e.emit("pipe",c),e}},{events:18,inherits:24,"readable-stream/duplex.js":82,"readable-stream/passthrough.js":91,"readable-stream/readable.js":92,"readable-stream/transform.js":93,"readable-stream/writable.js":94}],82:[function(e,t,r){t.exports=e("./lib/_stream_duplex.js")},{"./lib/_stream_duplex.js":83}],83:[function(e,t,r){"use strict";function n(e){if(!(this instanceof n))return new n(e);c.call(this,e),l.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",i)}function i(){this.allowHalfOpen||this._writableState.ended||a(o,this)}function o(e){e.end()}var a=e("process-nextick-args"),s=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};t.exports=n;var u=e("core-util-is");u.inherits=e("inherits");var c=e("./_stream_readable"),l=e("./_stream_writable");u.inherits(n,c);for(var f=s(l.prototype),p=0;p<f.length;p++){var d=f[p];n.prototype[d]||(n.prototype[d]=l.prototype[d])}Object.defineProperty(n.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}),n.prototype._destroy=function(e,t){this.push(null),this.end(),a(t,e)}},{"./_stream_readable":85,"./_stream_writable":87,"core-util-is":6,inherits:24,"process-nextick-args":69}],84:[function(e,t,r){"use strict";function n(e){if(!(this instanceof n))return new n(e);i.call(this,e)}t.exports=n;var i=e("./_stream_transform"),o=e("core-util-is");o.inherits=e("inherits"),o.inherits(n,i),n.prototype._transform=function(e,t,r){r(null,e)}},{"./_stream_transform":86,"core-util-is":6,inherits:24}],85:[function(e,t,r){(function(r,n){"use strict";function i(e){return L.from(e)}function o(e){return L.isBuffer(e)||e instanceof N}function a(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?P(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}function s(t,r){B=B||e("./_stream_duplex"),t=t||{},this.objectMode=!!t.objectMode,r instanceof B&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var n=t.highWaterMark,i=this.objectMode?16:16384;this.highWaterMark=n||0===n?n:i,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new U,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(W||(W=e("string_decoder/").StringDecoder),this.decoder=new W(t.encoding),this.encoding=t.encoding)}function u(t){if(B=B||e("./_stream_duplex"),!(this instanceof u))return new u(t);this._readableState=new s(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),I.call(this)}function c(e,t,r,n,o){var a=e._readableState;if(null===t)a.reading=!1,m(e,a);else{var s;o||(s=f(a,t)),s?e.emit("error",s):a.objectMode||t&&t.length>0?("string"==typeof t||a.objectMode||Object.getPrototypeOf(t)===L.prototype||(t=i(t)),n?a.endEmitted?e.emit("error",new Error("stream.unshift() after end event")):l(e,a,t,!0):a.ended?e.emit("error",new Error("stream.push() after EOF")):(a.reading=!1,a.decoder&&!r?(t=a.decoder.write(t),a.objectMode||0!==t.length?l(e,a,t,!1):g(e,a)):l(e,a,t,!1))):n||(a.reading=!1)}return p(a)}function l(e,t,r,n){t.flowing&&0===t.length&&!t.sync?(e.emit("data",r),e.read(0)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&v(e)),g(e,t)}function f(e,t){var r;return o(t)||"string"==typeof t||void 0===t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk")),r}function p(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}function d(e){return e>=G?e=G:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}function h(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!==e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=d(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function m(e,t){if(!t.ended){if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,v(e)}}function v(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||($("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?R(y,e):y(e))}function y(e){$("emit readable"),e.emit("readable"),E(e)}function g(e,t){t.readingMore||(t.readingMore=!0,R(b,e,t))}function b(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&($("maybeReadMore read 0"),e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function _(e){return function(){var t=e._readableState;$("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&T(e,"data")&&(t.flowing=!0,E(e))}}function x(e){$("readable nexttick read 0"),e.read(0)}function w(e,t){t.resumeScheduled||(t.resumeScheduled=!0,R(k,e,t))}function k(e,t){t.reading||($("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),E(e),t.flowing&&!t.reading&&e.read(0)}function E(e){var t=e._readableState;for($("flow",t.flowing);t.flowing&&null!==e.read(););}function S(e,t){if(0===t.length)return null;var r;return t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):r=A(e,t.buffer,t.decoder),r}function A(e,t,r){var n;return e<t.head.data.length?(n=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):n=e===t.head.data.length?t.shift():r?D(e,t):C(e,t),n}function D(e,t){var r=t.head,n=1,i=r.data;for(e-=i.length;r=r.next;){var o=r.data,a=e>o.length?o.length:e;if(a===o.length?i+=o:i+=o.slice(0,e),0===(e-=a)){a===o.length?(++n,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=o.slice(a));break}++n}return t.length-=n,i}function C(e,t){var r=L.allocUnsafe(e),n=t.head,i=1;for(n.data.copy(r),e-=n.data.length;n=n.next;){var o=n.data,a=e>o.length?o.length:e;if(o.copy(r,r.length-e,0,a),0===(e-=a)){a===o.length?(++i,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=o.slice(a));break}++i}return t.length-=i,r}function F(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,R(O,t,e))}function O(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function j(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}var R=e("process-nextick-args");t.exports=u;var B,P=e("isarray");u.ReadableState=s;e("events").EventEmitter;var T=function(e,t){return e.listeners(t).length},I=e("./internal/streams/stream"),L=e("safe-buffer").Buffer,N=n.Uint8Array||function(){},M=e("core-util-is");M.inherits=e("inherits");var q=e("util"),$=void 0;$=q&&q.debuglog?q.debuglog("stream"):function(){};var W,U=e("./internal/streams/BufferList"),z=e("./internal/streams/destroy");M.inherits(u,I);var V=["error","close","destroy","pause","resume"];Object.defineProperty(u.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),u.prototype.destroy=z.destroy,u.prototype._undestroy=z.undestroy,u.prototype._destroy=function(e,t){this.push(null),t(e)},u.prototype.push=function(e,t){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof e&&((t=t||n.defaultEncoding)!==n.encoding&&(e=L.from(e,t),t=""),r=!0),c(this,e,t,!1,r)},u.prototype.unshift=function(e){return c(this,e,null,!0,!1)},u.prototype.isPaused=function(){return!1===this._readableState.flowing},u.prototype.setEncoding=function(t){return W||(W=e("string_decoder/").StringDecoder),this._readableState.decoder=new W(t),this._readableState.encoding=t,this};var G=8388608;u.prototype.read=function(e){$("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return $("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?F(this):v(this),null;if(0===(e=h(e,t))&&t.ended)return 0===t.length&&F(this),null;var n=t.needReadable;$("need readable",n),(0===t.length||t.length-e<t.highWaterMark)&&$("length less than watermark",n=!0),t.ended||t.reading?$("reading or ended",n=!1):n&&($("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=h(r,t)));var i;return null===(i=e>0?S(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&F(this)),null!==i&&this.emit("data",i),i},u.prototype._read=function(e){this.emit("error",new Error("_read() is not implemented"))},u.prototype.pipe=function(e,t){function n(e,t){$("onunpipe"),e===p&&t&&!1===t.hasUnpiped&&(t.hasUnpiped=!0,o())}function i(){$("onend"),e.end()}function o(){$("cleanup"),e.removeListener("close",c),e.removeListener("finish",l),e.removeListener("drain",m),e.removeListener("error",u),e.removeListener("unpipe",n),p.removeListener("end",i),p.removeListener("end",f),p.removeListener("data",s),v=!0,!d.awaitDrain||e._writableState&&!e._writableState.needDrain||m()}function s(t){$("ondata"),y=!1,!1!==e.write(t)||y||((1===d.pipesCount&&d.pipes===e||d.pipesCount>1&&-1!==j(d.pipes,e))&&!v&&($("false write response, pause",p._readableState.awaitDrain),p._readableState.awaitDrain++,y=!0),p.pause())}function u(t){$("onerror",t),f(),e.removeListener("error",u),0===T(e,"error")&&e.emit("error",t)}function c(){e.removeListener("finish",l),f()}function l(){$("onfinish"),e.removeListener("close",c),f()}function f(){$("unpipe"),p.unpipe(e)}var p=this,d=this._readableState;switch(d.pipesCount){case 0:d.pipes=e;break;case 1:d.pipes=[d.pipes,e];break;default:d.pipes.push(e)}d.pipesCount+=1,$("pipe count=%d opts=%j",d.pipesCount,t);var h=(!t||!1!==t.end)&&e!==r.stdout&&e!==r.stderr?i:f;d.endEmitted?R(h):p.once("end",h),e.on("unpipe",n);var m=_(p);e.on("drain",m);var v=!1,y=!1;return p.on("data",s),a(e,"error",u),e.once("close",c),e.once("finish",l),e.emit("pipe",p),d.flowing||($("pipe resume"),p.resume()),e},u.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r),this);if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,r);return this}var a=j(t.pipes,e);return-1===a?this:(t.pipes.splice(a,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r),this)},u.prototype.on=function(e,t){var r=I.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&v(this):R(x,this))}return r},u.prototype.addListener=u.prototype.on,u.prototype.resume=function(){var e=this._readableState;return e.flowing||($("resume"),e.flowing=!0,w(this,e)),this},u.prototype.pause=function(){return $("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&($("pause"),this._readableState.flowing=!1,this.emit("pause")),this},u.prototype.wrap=function(e){var t=this._readableState,r=!1,n=this;e.on("end",function(){if($("wrapped end"),t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&n.push(e)}n.push(null)}),e.on("data",function(i){$("wrapped data"),t.decoder&&(i=t.decoder.write(i)),(!t.objectMode||null!==i&&void 0!==i)&&(t.objectMode||i&&i.length)&&(n.push(i)||(r=!0,e.pause()))});for(var i in e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var o=0;o<V.length;o++)e.on(V[o],n.emit.bind(n,V[o]));return n._read=function(t){$("wrapped _read",t),r&&(r=!1,e.resume())},n},u._fromList=S}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./_stream_duplex":83,"./internal/streams/BufferList":88,"./internal/streams/destroy":89,"./internal/streams/stream":90,_process:70,"core-util-is":6,events:18,inherits:24,isarray:30,"process-nextick-args":69,"safe-buffer":79,"string_decoder/":95,util:3}],86:[function(e,t,r){"use strict";function n(e){this.afterTransform=function(t,r){return i(e,t,r)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function i(e,t,r){var n=e._transformState;n.transforming=!1;var i=n.writecb;if(!i)return e.emit("error",new Error("write callback called multiple times"));n.writechunk=null,n.writecb=null,null!==r&&void 0!==r&&e.push(r),i(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}function o(e){if(!(this instanceof o))return new o(e);s.call(this,e),this._transformState=new n(this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.once("prefinish",function(){"function"==typeof this._flush?this._flush(function(e,r){a(t,e,r)}):a(t)})}function a(e,t,r){if(t)return e.emit("error",t);null!==r&&void 0!==r&&e.push(r);var n=e._writableState,i=e._transformState;if(n.length)throw new Error("Calling transform done when ws.length != 0");if(i.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}t.exports=o;var s=e("./_stream_duplex"),u=e("core-util-is");u.inherits=e("inherits"),u.inherits(o,s),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,s.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,r){throw new Error("_transform() is not implemented")},o.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},o.prototype._destroy=function(e,t){var r=this;s.prototype._destroy.call(this,e,function(e){t(e),r.emit("close")})}},{"./_stream_duplex":83,"core-util-is":6,inherits:24}],87:[function(e,t,r){(function(r,n){"use strict";function i(e){var t=this;this.next=null,this.entry=null,this.finish=function(){A(t,e)}}function o(e){return B.from(e)}function a(e){return B.isBuffer(e)||e instanceof P}function s(){}function u(t,r){C=C||e("./_stream_duplex"),t=t||{},this.objectMode=!!t.objectMode,r instanceof C&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var n=t.highWaterMark,o=this.objectMode?16:16384;this.highWaterMark=n||0===n?n:o,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){y(r,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new i(this)}function c(t){if(C=C||e("./_stream_duplex"),!(I.call(c,this)||this instanceof C))return new c(t);this._writableState=new u(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),R.call(this)}function l(e,t){var r=new Error("write after end");e.emit("error",r),D(t,r)}function f(e,t,r,n){var i=!0,o=!1;return null===r?o=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||t.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(e.emit("error",o),D(n,o),i=!1),i}function p(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=B.from(t,r)),t}function d(e,t,r,n,i,o){if(!r){var a=p(t,n,i);n!==a&&(r=!0,i="buffer",n=a)}var s=t.objectMode?1:n.length;t.length+=s;var u=t.length<t.highWaterMark;if(u||(t.needDrain=!0),t.writing||t.corked){var c=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},c?c.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else h(e,t,!1,s,n,i,o);return u}function h(e,t,r,n,i,o,a){t.writelen=n,t.writecb=a,t.writing=!0,t.sync=!0,r?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function m(e,t,r,n,i){--t.pendingcb,r?(D(i,n),D(E,e,t),e._writableState.errorEmitted=!0,e.emit("error",n)):(i(n),e._writableState.errorEmitted=!0,e.emit("error",n),E(e,t))}function v(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function y(e,t){var r=e._writableState,n=r.sync,i=r.writecb;if(v(r),t)m(e,r,n,t,i);else{var o=x(r);o||r.corked||r.bufferProcessing||!r.bufferedRequest||_(e,r),n?F(g,e,r,o,i):g(e,r,o,i)}}function g(e,t,r,n){r||b(e,t),t.pendingcb--,n(),E(e,t)}function b(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}function _(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,o=new Array(n),a=t.corkedRequestsFree;a.entry=r;for(var s=0,u=!0;r;)o[s]=r,r.isBuf||(u=!1),r=r.next,s+=1;o.allBuffers=u,h(e,t,!0,t.length,o,"",a.finish),t.pendingcb++,t.lastBufferedRequest=null,a.next?(t.corkedRequestsFree=a.next,a.next=null):t.corkedRequestsFree=new i(t)}else{for(;r;){var c=r.chunk,l=r.encoding,f=r.callback;if(h(e,t,!1,t.objectMode?1:c.length,c,l,f),r=r.next,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequestCount=0,t.bufferedRequest=r,t.bufferProcessing=!1}function x(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function w(e,t){e._final(function(r){t.pendingcb--,r&&e.emit("error",r),t.prefinished=!0,e.emit("prefinish"),E(e,t)})}function k(e,t){t.prefinished||t.finalCalled||("function"==typeof e._final?(t.pendingcb++,t.finalCalled=!0,D(w,e,t)):(t.prefinished=!0,e.emit("prefinish")))}function E(e,t){var r=x(t);return r&&(k(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"))),r}function S(e,t,r){t.ending=!0,E(e,t),r&&(t.finished?D(r):e.once("finish",r)),t.ended=!0,e.writable=!1}function A(e,t,r){var n=e.entry;for(e.entry=null;n;){var i=n.callback;t.pendingcb--,i(r),n=n.next}t.corkedRequestsFree?t.corkedRequestsFree.next=e:t.corkedRequestsFree=e}var D=e("process-nextick-args");t.exports=c;var C,F=!r.browser&&["v0.10","v0.9."].indexOf(r.version.slice(0,5))>-1?setImmediate:D;c.WritableState=u;var O=e("core-util-is");O.inherits=e("inherits");var j={deprecate:e("util-deprecate")},R=e("./internal/streams/stream"),B=e("safe-buffer").Buffer,P=n.Uint8Array||function(){},T=e("./internal/streams/destroy");O.inherits(c,R),u.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(u.prototype,"buffer",{get:j.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}();var I;"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(I=Function.prototype[Symbol.hasInstance],Object.defineProperty(c,Symbol.hasInstance,{value:function(e){return!!I.call(this,e)||e&&e._writableState instanceof u}})):I=function(e){return e instanceof this},c.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},c.prototype.write=function(e,t,r){var n=this._writableState,i=!1,u=a(e)&&!n.objectMode;return u&&!B.isBuffer(e)&&(e=o(e)),"function"==typeof t&&(r=t,t=null),u?t="buffer":t||(t=n.defaultEncoding),"function"!=typeof r&&(r=s),n.ended?l(this,r):(u||f(this,n,e,r))&&(n.pendingcb++,i=d(this,n,u,e,t,r)),i},c.prototype.cork=function(){this._writableState.corked++},c.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||_(this,e))},c.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},c.prototype._write=function(e,t,r){r(new Error("_write() is not implemented"))},c.prototype._writev=null,c.prototype.end=function(e,t,r){var n=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!==e&&void 0!==e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||S(this,n,r)},Object.defineProperty(c.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),c.prototype.destroy=T.destroy,c.prototype._undestroy=T.undestroy,c.prototype._destroy=function(e,t){this.end(),t(e)}}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./_stream_duplex":83,"./internal/streams/destroy":89,"./internal/streams/stream":90,_process:70,"core-util-is":6,inherits:24,"process-nextick-args":69,"safe-buffer":79,"util-deprecate":111}],88:[function(e,t,r){"use strict";function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t,r){e.copy(t,r)}var o=e("safe-buffer").Buffer;t.exports=function(){function e(){n(this,e),this.head=null,this.tail=null,this.length=0}return e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},e.prototype.clear=function(){this.head=this.tail=null,this.length=0},e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r},e.prototype.concat=function(e){if(0===this.length)return o.alloc(0);if(1===this.length)return this.head.data;for(var t=o.allocUnsafe(e>>>0),r=this.head,n=0;r;)i(r.data,t,n),n+=r.data.length,r=r.next;return t},e}()},{"safe-buffer":79}],89:[function(e,t,r){"use strict";function n(e,t){e.emit("error",t)}var i=e("process-nextick-args");t.exports={destroy:function(e,t){var r=this,o=this._readableState&&this._readableState.destroyed,a=this._writableState&&this._writableState.destroyed;o||a?t?t(e):!e||this._writableState&&this._writableState.errorEmitted||i(n,this,e):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,function(e){!t&&e?(i(n,r,e),r._writableState&&(r._writableState.errorEmitted=!0)):t&&t(e)}))},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},{"process-nextick-args":69}],90:[function(e,t,r){t.exports=e("events").EventEmitter},{events:18}],91:[function(e,t,r){t.exports=e("./readable").PassThrough},{"./readable":92}],92:[function(e,t,r){(r=t.exports=e("./lib/_stream_readable.js")).Stream=r,r.Readable=r,r.Writable=e("./lib/_stream_writable.js"),r.Duplex=e("./lib/_stream_duplex.js"),r.Transform=e("./lib/_stream_transform.js"),r.PassThrough=e("./lib/_stream_passthrough.js")},{"./lib/_stream_duplex.js":83,"./lib/_stream_passthrough.js":84,"./lib/_stream_readable.js":85,"./lib/_stream_transform.js":86,"./lib/_stream_writable.js":87}],93:[function(e,t,r){t.exports=e("./readable").Transform},{"./readable":92}],94:[function(e,t,r){t.exports=e("./lib/_stream_writable.js")},{"./lib/_stream_writable.js":87}],95:[function(e,t,r){"use strict";function n(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}function i(e){var t=n(e);if("string"!=typeof t&&(v.isEncoding===y||!y(e)))throw new Error("Unknown encoding: "+e);return t||e}function o(e){this.encoding=i(e);var t;switch(this.encoding){case"utf16le":this.text=l,this.end=f,t=4;break;case"utf8":this.fillLast=c,t=4;break;case"base64":this.text=p,this.end=d,t=3;break;default:return this.write=h,void(this.end=m)}this.lastNeed=0,this.lastTotal=0,this.lastChar=v.allocUnsafe(t)}function a(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:-1}function s(e,t,r){var n=t.length-1;if(n<r)return 0;var i=a(t[n]);return i>=0?(i>0&&(e.lastNeed=i-1),i):--n<r?0:(i=a(t[n]))>=0?(i>0&&(e.lastNeed=i-2),i):--n<r?0:(i=a(t[n]))>=0?(i>0&&(2===i?i=0:e.lastNeed=i-3),i):0}function u(e,t,r){if(128!=(192&t[0]))return e.lastNeed=0,"".repeat(r);if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"".repeat(r+1);if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,"".repeat(r+2)}}function c(e){var t=this.lastTotal-this.lastNeed,r=u(this,e,t);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function l(e,t){if((e.length-t)%2==0){var r=e.toString("utf16le",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function f(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function p(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function d(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function h(e){return e.toString(this.encoding)}function m(e){return e&&e.length?this.write(e):""}var v=e("safe-buffer").Buffer,y=v.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};r.StringDecoder=o,o.prototype.write=function(e){if(0===e.length)return"";var t,r;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},o.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"".repeat(this.lastTotal-this.lastNeed):t},o.prototype.text=function(e,t){var r=s(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,n),e.toString("utf8",t,n)},o.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},{"safe-buffer":79}],96:[function(e,t,r){function n(e){if(e&&!u(e))throw new Error("Unknown encoding: "+e)}function i(e){return e.toString(this.encoding)}function o(e){this.charReceived=e.length%2,this.charLength=this.charReceived?2:0}function a(e){this.charReceived=e.length%3,this.charLength=this.charReceived?3:0}var s=e("buffer").Buffer,u=s.isEncoding||function(e){switch(e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}},c=r.StringDecoder=function(e){switch(this.encoding=(e||"utf8").toLowerCase().replace(/[-_]/,""),n(e),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=o;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=a;break;default:return void(this.write=i)}this.charBuffer=new s(6),this.charReceived=0,this.charLength=0};c.prototype.write=function(e){for(var t="";this.charLength;){var r=e.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBuffer,this.charReceived,0,r),this.charReceived+=r,this.charReceived<this.charLength)return"";if(e=e.slice(r,e.length),!((i=(t=this.charBuffer.slice(0,this.charLength).toString(this.encoding)).charCodeAt(t.length-1))>=55296&&i<=56319)){if(this.charReceived=this.charLength=0,0===e.length)return t;break}this.charLength+=this.surrogateSize,t=""}this.detectIncompleteChar(e);n=e.length;this.charLength&&(e.copy(this.charBuffer,0,e.length-this.charReceived,n),n-=this.charReceived);var n=(t+=e.toString(this.encoding,0,n)).length-1,i=t.charCodeAt(n);if(i>=55296&&i<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,n)}return t},c.prototype.detectIncompleteChar=function(e){for(var t=e.length>=3?3:e.length;t>0;t--){var r=e[e.length-t];if(1==t&&r>>5==6){this.charLength=2;break}if(t<=2&&r>>4==14){this.charLength=3;break}if(t<=3&&r>>3==30){this.charLength=4;break}}this.charReceived=t},c.prototype.end=function(e){var t="";if(e&&e.length&&(t=this.write(e)),this.charReceived){var r=this.charReceived,n=this.charBuffer,i=this.encoding;t+=n.slice(0,r).toString(i)}return t}},{buffer:5}],97:[function(e,t,r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e){return"function"==typeof e}function o(e){return i(e.prefix)?e.prefix():e}function a(e){var t={};for(var r in e)t[r]=e[r];return t}function s(e,t,r){function n(e,n,i,o){return t.encode([e,r.encodeKey(n,i,o)])}function i(e,t){return t&&t.options&&(e.keyEncoding=e.keyEncoding||t.options.keyEncoding,e.valueEncoding=e.valueEncoding||t.options.valueEncoding),e}return e.open(function(){}),{apply:function(t,a,s){a=a||{};for(var u=[],c=-1,l=t.length;++c<l;){var f=t[c];i(f,f.prefix),f.prefix=o(f.prefix),u.push({key:n(f.prefix,f.key,a,f),value:"del"!==f.type&&r.encodeValue(f.value,a,f),type:f.type})}e.db.batch(u,a,s)},get:function(t,i,o,a){return o.asBuffer=r.valueAsBuffer(o),e.db.get(n(i,t,o),o,function(e,t){e?a(e):a(null,r.decodeValue(t,o))})},createDecoder:function(e){return function(n,i){return{key:r.decodeKey(t.decode(n)[1],e),value:r.decodeValue(i,e)}}},isClosed:function(){return e.isClosed()},close:function(t){return e.close(t)},iterator:function(i){var o=a(i||{}),s=i.prefix||[];return l.toLtgt(i,o,function(e){return n(s,e,o,{})},t.lowerBound,t.upperBound),o.prefix=null,o.keyAsBuffer=o.valueAsBuffer=!1,"number"!=typeof o.limit&&(o.limit=-1),o.keyAsBuffer=t.buffer,o.valueAsBuffer=r.valueAsBuffer(o),function(e){return{next:function(t){return e.next(t)},end:function(t){e.end(t)}}}(e.db.iterator(o))}}}function u(){Error.call(this)}function c(e,t){if(!(this instanceof c))return new c(e,t);g.call(this,{objectMode:!0,highWaterMark:e.highWaterMark}),this._waiting=!1,this._options=e,this._makeData=t}var l=n(e("ltgt")),f=n(e("events")),p=n(e("inherits")),d=n(e("level-codec")),h=n(e("readable-stream"));p(u,Error),u.prototype.name="NotFoundError";var m=f.EventEmitter,v=new u,y=function(e,t,r,n){function i(e){var t,r={};if(n)for(t in n)void 0!==n[t]&&(r[t]=n[t]);if(e)for(t in e)void 0!==e[t]&&(r[t]=e[t]);return r}var o=new m;return o.sublevels={},o.options=n,o.version="6.5.4",o.methods={},t=t||[],o.put=function(r,n,a,s){"function"==typeof a&&(s=a,a={}),e.apply([{key:r,value:n,prefix:t.slice(),type:"put"}],i(a),function(e){if(e)return s(e);o.emit("put",r,n),s(null)})},o.prefix=function(){return t.slice()},o.batch=function(r,n,a){"function"==typeof n&&(a=n,n={}),r=r.map(function(e){return{key:e.key,value:e.value,prefix:e.prefix||t,keyEncoding:e.keyEncoding,valueEncoding:e.valueEncoding,type:e.type}}),e.apply(r,i(n),function(e){if(e)return a(e);o.emit("batch",r),a(null)})},o.get=function(r,n,o){"function"==typeof n&&(o=n,n={}),e.get(r,t,i(n),function(e,t){e?o(v):o(null,t)})},o.sublevel=function(n,a){return o.sublevels[n]=o.sublevels[n]||y(e,t.concat(n),r,i(a))},o.readStream=o.createReadStream=function(n){(n=i(n)).prefix=t;var o,a=e.iterator(n);return(o=r(n,e.createDecoder(n))).setIterator(a),o},o.close=function(t){e.close(t)},o.isOpen=e.isOpen,o.isClosed=e.isClosed,o},g=h.Readable;p(c,g),c.prototype.setIterator=function(e){return this._iterator=e,this._destroyed?e.end(function(){}):this._waiting?(this._waiting=!1,this._read()):this},c.prototype._read=function(){var e=this;if(!e._destroyed)return e._iterator?void e._iterator.next(function(t,r,n){if(t||void 0===r&&void 0===n)return t||e._destroyed||e.push(null),e._cleanup(t);n=e._makeData(r,n),e._destroyed||e.push(n)}):this._waiting=!0},c.prototype._cleanup=function(e){if(!this._destroyed){this._destroyed=!0;var t=this;e&&t.emit("error",e),t._iterator?t._iterator.end(function(){t._iterator=null,t.emit("close")}):t.emit("close")}},c.prototype.destroy=function(){this._cleanup()};var b={encode:function(e){return""+e[0]+""+e[1]},decode:function(e){var t=e.toString(),r=t.indexOf("",1);return[t.substring(1,r),t.substring(r+1)]},lowerBound:"\0",upperBound:""},_=new d;t.exports=function(e){return y(s(e,b,_),[],c,e.options)}},{events:18,inherits:24,"level-codec":31,ltgt:42,"readable-stream":78}],98:[function(e,t,r){arguments[4][83][0].apply(r,arguments)},{"./_stream_readable":100,"./_stream_writable":102,"core-util-is":6,dup:83,inherits:24,"process-nextick-args":69}],99:[function(e,t,r){arguments[4][84][0].apply(r,arguments)},{"./_stream_transform":101,"core-util-is":6,dup:84,inherits:24}],100:[function(e,t,r){arguments[4][85][0].apply(r,arguments)},{"./_stream_duplex":98,"./internal/streams/BufferList":103,"./internal/streams/destroy":104,"./internal/streams/stream":105,_process:70,"core-util-is":6,dup:85,events:18,inherits:24,isarray:30,"process-nextick-args":69,"safe-buffer":79,"string_decoder/":108,util:3}],101:[function(e,t,r){arguments[4][86][0].apply(r,arguments)},{"./_stream_duplex":98,"core-util-is":6,dup:86,inherits:24}],102:[function(e,t,r){arguments[4][87][0].apply(r,arguments)},{"./_stream_duplex":98,"./internal/streams/destroy":104,"./internal/streams/stream":105,_process:70,"core-util-is":6,dup:87,inherits:24,"process-nextick-args":69,"safe-buffer":79,"util-deprecate":111}],103:[function(e,t,r){arguments[4][88][0].apply(r,arguments)},{dup:88,"safe-buffer":79}],104:[function(e,t,r){arguments[4][89][0].apply(r,arguments)},{dup:89,"process-nextick-args":69}],105:[function(e,t,r){arguments[4][90][0].apply(r,arguments)},{dup:90,events:18}],106:[function(e,t,r){arguments[4][92][0].apply(r,arguments)},{"./lib/_stream_duplex.js":98,"./lib/_stream_passthrough.js":99,"./lib/_stream_readable.js":100,"./lib/_stream_transform.js":101,"./lib/_stream_writable.js":102,dup:92}],107:[function(e,t,r){arguments[4][93][0].apply(r,arguments)},{"./readable":106,dup:93}],108:[function(e,t,r){arguments[4][95][0].apply(r,arguments)},{dup:95,"safe-buffer":79}],109:[function(e,t,r){(function(r){function n(e){a.call(this,e),this._destroyed=!1}function i(e,t,r){r(null,e)}function o(e){return function(t,r,n){return"function"==typeof t&&(n=r,r=t,t={}),"function"!=typeof r&&(r=i),"function"!=typeof n&&(n=null),e(t,r,n)}}var a=e("readable-stream/transform"),s=e("util").inherits,u=e("xtend");s(n,a),n.prototype.destroy=function(e){if(!this._destroyed){this._destroyed=!0;var t=this;r.nextTick(function(){e&&t.emit("error",e),t.emit("close")})}},t.exports=o(function(e,t,r){var i=new n(e);return i._transform=t,r&&(i._flush=r),i}),t.exports.ctor=o(function(e,t,r){function i(t){if(!(this instanceof i))return new i(t);this.options=u(e,t),n.call(this,this.options)}return s(i,n),i.prototype._transform=t,r&&(i.prototype._flush=r),i}),t.exports.obj=o(function(e,t,r){var i=new n(u({objectMode:!0,highWaterMark:16},e));return i._transform=t,r&&(i._flush=r),i})}).call(this,e("_process"))},{_process:70,"readable-stream/transform":107,util:114,xtend:120}],110:[function(e,t,r){"use strict";var n=e("lodash.isnull"),i=e("validate.io-undefined"),o=Object.prototype.toString;t.exports=function(e){return n(e)?"[object Null]":i(e)?"[object Undefined]":o.call(e)}},{"lodash.isnull":41,"validate.io-undefined":118}],111:[function(e,t,r){(function(e){function r(t){try{if(!e.localStorage)return!1}catch(e){return!1}var r=e.localStorage[t];return null!=r&&"true"===String(r).toLowerCase()}t.exports=function(e,t){if(r("noDeprecation"))return e;var n=!1;return function(){if(!n){if(r("throwDeprecation"))throw new Error(t);r("traceDeprecation")?console.trace(t):console.warn(t),n=!0}return e.apply(this,arguments)}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],112:[function(e,t,r){arguments[4][24][0].apply(r,arguments)},{dup:24}],113:[function(e,t,r){t.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},{}],114:[function(e,t,r){(function(t,n){function i(e,t){var n={seen:[],stylize:a};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),m(t)?n.showHidden=t:t&&r._extend(n,t),b(n.showHidden)&&(n.showHidden=!1),b(n.depth)&&(n.depth=2),b(n.colors)&&(n.colors=!1),b(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=o),u(n,e,n.depth)}function o(e,t){var r=i.styles[t];return r?"["+i.colors[r][0]+"m"+e+"["+i.colors[r][1]+"m":e}function a(e,t){return e}function s(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}function u(e,t,n){if(e.customInspect&&t&&E(t.inspect)&&t.inspect!==r.inspect&&(!t.constructor||t.constructor.prototype!==t)){var i=t.inspect(n,e);return g(i)||(i=u(e,i,n)),i}var o=c(e,t);if(o)return o;var a=Object.keys(t),m=s(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(t)),k(t)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return l(t);if(0===a.length){if(E(t)){var v=t.name?": "+t.name:"";return e.stylize("[Function"+v+"]","special")}if(_(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(w(t))return e.stylize(Date.prototype.toString.call(t),"date");if(k(t))return l(t)}var y="",b=!1,x=["{","}"];if(h(t)&&(b=!0,x=["[","]"]),E(t)&&(y=" [Function"+(t.name?": "+t.name:"")+"]"),_(t)&&(y=" "+RegExp.prototype.toString.call(t)),w(t)&&(y=" "+Date.prototype.toUTCString.call(t)),k(t)&&(y=" "+l(t)),0===a.length&&(!b||0==t.length))return x[0]+y+x[1];if(n<0)return _(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special");e.seen.push(t);var S;return S=b?f(e,t,n,m,a):a.map(function(r){return p(e,t,n,m,r,b)}),e.seen.pop(),d(S,y,x)}function c(e,t){if(b(t))return e.stylize("undefined","undefined");if(g(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}return y(t)?e.stylize(""+t,"number"):m(t)?e.stylize(""+t,"boolean"):v(t)?e.stylize("null","null"):void 0}function l(e){return"["+Error.prototype.toString.call(e)+"]"}function f(e,t,r,n,i){for(var o=[],a=0,s=t.length;a<s;++a)C(t,String(a))?o.push(p(e,t,r,n,String(a),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(p(e,t,r,n,i,!0))}),o}function p(e,t,r,n,i,o){var a,s,c;if((c=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?s=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(s=e.stylize("[Setter]","special")),C(n,i)||(a="["+i+"]"),s||(e.seen.indexOf(c.value)<0?(s=v(r)?u(e,c.value,null):u(e,c.value,r-1)).indexOf("\n")>-1&&(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),b(a)){if(o&&i.match(/^\d+$/))return s;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function d(e,t,r){var n=0;return e.reduce(function(e,t){return n++,t.indexOf("\n")>=0&&n++,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1]:r[0]+t+" "+e.join(", ")+" "+r[1]}function h(e){return Array.isArray(e)}function m(e){return"boolean"==typeof e}function v(e){return null===e}function y(e){return"number"==typeof e}function g(e){return"string"==typeof e}function b(e){return void 0===e}function _(e){return x(e)&&"[object RegExp]"===S(e)}function x(e){return"object"==typeof e&&null!==e}function w(e){return x(e)&&"[object Date]"===S(e)}function k(e){return x(e)&&("[object Error]"===S(e)||e instanceof Error)}function E(e){return"function"==typeof e}function S(e){return Object.prototype.toString.call(e)}function A(e){return e<10?"0"+e.toString(10):e.toString(10)}function D(){var e=new Date,t=[A(e.getHours()),A(e.getMinutes()),A(e.getSeconds())].join(":");return[e.getDate(),R[e.getMonth()],t].join(" ")}function C(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var F=/%[sdj%]/g;r.format=function(e){if(!g(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(i(arguments[r]));return t.join(" ")}for(var r=1,n=arguments,o=n.length,a=String(e).replace(F,function(e){if("%%"===e)return"%";if(r>=o)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),s=n[r];r<o;s=n[++r])v(s)||!x(s)?a+=" "+s:a+=" "+i(s);return a},r.deprecate=function(e,i){if(b(n.process))return function(){return r.deprecate(e,i).apply(this,arguments)};if(!0===t.noDeprecation)return e;var o=!1;return function(){if(!o){if(t.throwDeprecation)throw new Error(i);t.traceDeprecation?console.trace(i):console.error(i),o=!0}return e.apply(this,arguments)}};var O,j={};r.debuglog=function(e){if(b(O)&&(O=t.env.NODE_DEBUG||""),e=e.toUpperCase(),!j[e])if(new RegExp("\\b"+e+"\\b","i").test(O)){var n=t.pid;j[e]=function(){var t=r.format.apply(r,arguments);console.error("%s %d: %s",e,n,t)}}else j[e]=function(){};return j[e]},r.inspect=i,i.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},i.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},r.isArray=h,r.isBoolean=m,r.isNull=v,r.isNullOrUndefined=function(e){return null==e},r.isNumber=y,r.isString=g,r.isSymbol=function(e){return"symbol"==typeof e},r.isUndefined=b,r.isRegExp=_,r.isObject=x,r.isDate=w,r.isError=k,r.isFunction=E,r.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},r.isBuffer=e("./support/isBuffer");var R=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];r.log=function(){console.log("%s - %s",D(),r.format.apply(r,arguments))},r.inherits=e("inherits"),r._extend=function(e,t){if(!t||!x(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e}}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./support/isBuffer":113,_process:70,inherits:112}],115:[function(e,t,r){for(var n=[],i=0;i<256;++i)n[i]=(i+256).toString(16).substr(1);t.exports=function(e,t){var r=t||0,i=n;return i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+"-"+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]+i[e[r++]]}},{}],116:[function(e,t,r){(function(e){var r,n=e.crypto||e.msCrypto;if(n&&n.getRandomValues){var i=new Uint8Array(16);r=function(){return n.getRandomValues(i),i}}if(!r){var o=new Array(16);r=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),o[t]=e>>>((3&t)<<3)&255;return o}}t.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],117:[function(e,t,r){var n=e("./lib/rng"),i=e("./lib/bytesToUuid");t.exports=function(e,t,r){var o=t&&r||0;"string"==typeof e&&(t="binary"==e?new Array(16):null,e=null);var a=(e=e||{}).random||(e.rng||n)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t)for(var s=0;s<16;++s)t[o+s]=a[s];return t||i(a)}},{"./lib/bytesToUuid":115,"./lib/rng":116}],118:[function(e,t,r){"use strict";t.exports=function(e){return void 0===e}},{}],119:[function(e,t,r){"use strict";function n(e,t,r){var n=r[r.length-1];e===n.element&&(r.pop(),n=r[r.length-1]);var i=n.element,o=n.index;Array.isArray(i)?i.push(e):o===t.length-2?i[t.pop()]=e:t.push(e)}r.stringify=function(e){var t=[];t.push({obj:e});for(var r,n,i,o,a,s,u,c,l,f,p,d="";r=t.pop();)if(n=r.obj,i=r.prefix||"",o=r.val||"",d+=i,o)d+=o;else if("object"!=typeof n)d+=void 0===n?null:JSON.stringify(n);else if(null===n)d+="null";else if(Array.isArray(n)){for(t.push({val:"]"}),a=n.length-1;a>=0;a--)s=0===a?"":",",t.push({obj:n[a],prefix:s});t.push({val:"["})}else{u=[];for(c in n)n.hasOwnProperty(c)&&u.push(c);for(t.push({val:"}"}),a=u.length-1;a>=0;a--)f=n[l=u[a]],p=a>0?",":"",p+=JSON.stringify(l)+":",t.push({obj:f,prefix:p});t.push({val:"{"})}return d},r.parse=function(e){for(var t,r,i,o,a,s,u,c,l,f=[],p=[],d=0;;)if("}"!==(t=e[d++])&&"]"!==t&&void 0!==t)switch(t){case" ":case"\t":case"\n":case":":case",":break;case"n":d+=3,n(null,f,p);break;case"t":d+=3,n(!0,f,p);break;case"f":d+=4,n(!1,f,p);break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":for(r="",d--;;){if(i=e[d++],!/[\d\.\-e\+]/.test(i)){d--;break}r+=i}n(parseFloat(r),f,p);break;case'"':for(o="",a=void 0,s=0;;){if('"'===(u=e[d++])&&("\\"!==a||s%2!=1))break;o+=u,"\\"===(a=u)?s++:s=0}n(JSON.parse('"'+o+'"'),f,p);break;case"[":c={element:[],index:f.length},f.push(c.element),p.push(c);break;case"{":l={element:{},index:f.length},f.push(l.element),p.push(l);break;default:throw new Error("unexpectedly reached end of input: "+t)}else{if(1===f.length)return f.pop();n(f.pop(),f,p)}}},{}],120:[function(e,t,r){t.exports=function(){for(var e={},t=0;t<arguments.length;t++){var r=arguments[t];for(var i in r)n.call(r,i)&&(e[i]=r[i])}return e};var n=Object.prototype.hasOwnProperty},{}]},{},[59])(59)}),t.exports}();!function(){var r="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;void 0===r.lively&&(r.lively={}),"undefined"==typeof btoa&&(r.btoa=function(e){return new Buffer(e).toString("base64")}),"undefined"==typeof atob&&(r.atob=function(e){return new Buffer(e,"base64").toString()}),function(){this.lively=this.lively||{},function(e,t,r,n,i){"use strict";function o(e){if(!w)throw new Error("nodejsRequire can only be used in nodejs!");return"undefined"!=typeof System?System._nodeRequire(e):require("module")._load(e)}function a(e){if(e.startsWith("/"))return e;if(e.match(/[^\/]+:\/\//))return e.startsWith("file:")&&(e=e.replace(/^file:\/\//,"")),e;if(!w)throw new Error("nodejs_leveldbPath called under non-nodejs environment");var t="undefined"!=typeof System&&System.baseURL.startsWith("file://")?System.baseURL.replace("file://",""):x.process.cwd(),r=o("path").join,n=o("fs"),i=n.mkdirSync,a=n.existsSync,s=(n.readdirSync,n.readFileSync);if(e.includes("/"))return r(t,e);try{var u=s(r(t,"../package.json")),c=JSON.parse(u);if("lively.web"===c.name||"lively.next"===c.name){var l=r(t,"../.livelydbs");return a(l)||i(l),r(l,e)}}catch(e){}var f=r(t,".livelydbs");return a(f)||i(f),r(f,e)}function s(){if(!w)throw new Error("nodejs_attemptToLoadProperPouchDB called under non-nodejs environment");if("undefined"!=typeof System){var e=System._nodeRequire("path").join,t=System.normalizeSync("lively.storage/index.js"),n=e(System.normalizeSync("pouchdb",t).replace(/file:\/\//,""),"../../lib/index.js");try{return(k=System._nodeRequire(n)).plugin(r),!0}catch(e){return!1}}try{return(k=require("pouchdb")).plugin(r),!0}catch(e){return!1}}function u(e,t,r){if(void 0===t&&"string"==typeof r&&!r.includes("undefined"))throw new Error("parameter "+e+" is undefined");if("string"==typeof r){var n=void 0===t?"undefined":f(t),i=t?t.constructor.name:"";if(!r.split("|").some(function(e){return n===e||i===e}))throw new Error('parameter "'+e+'" expected to be of type '+r+" but is "+(i||n))}if("function"==typeof r){var o=r(t);if(o&&o.error)throw new Error('check of parameter "'+e+'" failed: '+o.error)}}function c(e,t,r){for(var n in t)u(n,e[n],t[n]);if("function"==typeof r){var i=r(e);if(i&&i.error)throw new Error(i.error)}return e}function l(e,t){return!t||("string"==typeof t?!e.url.includes(t):"function"==typeof t?!t(e):!(t instanceof RegExp)||!t.test(e.url))}t="default"in t?t.default:t,r="default"in r?r.default:r;var f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},p=function(e){return function(){var t=e.apply(this,arguments);return new Promise(function(e,r){function n(i,o){try{var a=t[i](o),s=a.value}catch(e){return void r(e)}if(!a.done)return Promise.resolve(s).then(function(e){n("next",e)},function(e){n("throw",e)});e(s)}return n("next")})}},d=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},h=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),m=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},v=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},y=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},g=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},b=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},x="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:void 0,w="undefined"!=typeof global&&"undefined"!=typeof process,k=t;k.plugin(r);var E=w?function(){var e=!1,t=!1;return function(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e||(e=!0,t=s()),n.adapter||(n.adapter=r.startsWith("http")?"http":t?"leveldb":"memory"),"leveldb"==n.adapter&&(r=a(r)),n=m({},n,{name:r}),new k(n)}}():function(e,t){return new k(m({name:e},t))},S=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};d(this,e),this.name=t,this.options=r,this._pouchdb=null}return h(e,null,[{key:"findDB",value:function(e){return this.databases.get(e)}},{key:"ensureDB",value:function(e,t){var r=this.findDB(e);return r||(r=new this(e,t),this.databases.set(e,r),r)}},{key:"PouchDB",get:function(){return k},set:function(e){k=e}},{key:"databases",get:function(){return this._databases||(this._databases=new Map)}}]),h(e,[{key:"close",value:function(){this._pouchdb&&(this._pouchdb.close(),delete this._pouchdb)}},{key:"isDestroyed",value:function(){return!!this.pouchdb._destroyed}},{key:"destroy",value:function(e){return this.constructor.databases.delete(this.name),this.isDestroyed()?{ok:!0}:this.pouchdb.destroy(e)}},{key:"update",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n){var i,o,a,s,u,c,l,p,d,h,m,v,y,g,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=n||{},i=n,o=i.ensure,a=void 0===o||o,s=i.retryOnConflict,u=void 0===s||s,c=i.maxUpdateAttempts,l=void 0===c?10:c,p={latest:!0},d=this.pouchdb,h=void 0,m=void 0,e.prev=2,e.next=5,d.get(t,p);case 5:h=e.sent,e.next=12;break;case 8:if(e.prev=8,e.t0=e.catch(2),"not_found"===e.t0.name&&a){e.next=12;break}throw e.t0;case 12:return e.next=14,r(h);case 14:if((m=e.sent)&&"object"===(void 0===m?"undefined":f(m))){e.next=17;break}return e.abrupt("return",null);case 17:return m._id!==t&&(m._id=t),h&&m._rev!==h._rev&&(m._rev=h._rev),e.prev=19,e.next=22,d.put(m);case 22:return v=e.sent,y=v.id,g=v.rev,e.abrupt("return",Object.assign(m,{_rev:g}));case 28:if(e.prev=28,e.t1=e.catch(19),!("conflict"===e.t1.name&&u&&b<l)){e.next=32;break}return e.abrupt("return",this.update(t,r,n,b+1));case 32:throw e.t1;case 33:case"end":return e.stop()}},e,this,[[2,8],[19,28]])}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"mixin",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.update(t,function(e){return Object.assign(e||{_id:t},r)},n));case 1:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"set",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.update(t,function(e){return r},n));case 1:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"get",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.prev=0,e.next=3,this.pouchdb.get(t);case 3:return e.abrupt("return",e.sent);case 6:if(e.prev=6,e.t0=e.catch(0),"not_found"!==e.t0.name){e.next=10;break}return e.abrupt("return",void 0);case 10:throw e.t0;case 11:case"end":return e.stop()}},e,this,[[0,6]])}));return function(t){return e.apply(this,arguments)}}()},{key:"has",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.get(t);case 2:return e.abrupt("return",!!e.sent);case 3:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"add",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.pouchdb.post(t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"docList",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n,i,o,a,s,u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.allDocs(u);case 2:for(t=e.sent,r=t.rows,n=[],i=0;i<r.length;i++)o=r[i],a=o.id,s=o.value.rev,n.push({id:a,rev:s});return e.abrupt("return",n);case 7:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"revList",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.get(t,{revs:!0});case 2:return r=e.sent,n=r._id,i=r._revisions,o=i.start,a=i.ids,e.abrupt("return",a.map(function(e){return o--+"-"+e}));case 8:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"getAllRevisions",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=u.skip,n=void 0===r?0:r,i=u.limit,o=void 0===i?0:i,e.next=6,this.revList(t);case 6:return a=e.sent,n>0&&(a=a.slice(n)),o>0&&(a=a.slice(0,o)),s=a.map(function(e){return{rev:e,id:t}}),e.next=12,this.getDocuments(s);case 12:return e.abrupt("return",e.sent);case 13:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"getAll",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.allDocs(m({},n,{include_docs:!0}));case 2:return t=e.sent,r=t.rows,e.abrupt("return",r.map(function(e){return e.doc}));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"setDocuments",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.bulkDocs(t,r);case 2:n=e.sent,i=0;case 4:if(!(i<n.length)){e.next=16;break}if(o=t[i],(a=n[i]).ok||"conflict"!==a.name||o._rev){e.next=13;break}return e.next=9,this.set(o._id,o);case 9:s=e.sent,u=s._id,c=s._rev,n[i]={ok:!0,id:u,rev:c};case 13:i++,e.next=4;break;case 16:return e.abrupt("return",n);case 17:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"getDocuments",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=d.ignoreErrors,n=void 0===r||r,e.next=4,this.pouchdb.bulkGet({docs:t});case 4:i=e.sent,o=i.results,a=[],s=0;case 8:if(!(s<o.length)){e.next=23;break}u=o[s],c=u.docs,l=u.id,console.assert(1===c.length,"getDocuments: expected only one doc for "+l),f=0;case 12:if(!(f<c.length)){e.next=20;break}if(p=c[f],!n||p.ok){e.next=16;break}return e.abrupt("continue",17);case 16:a.push(p.ok||p.error||p);case 17:f++,e.next=12;break;case 20:s++,e.next=8;break;case 23:return e.abrupt("return",a);case 24:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"query",value:function(e,t){return this.pouchdb.query(e,t)}},{key:"remove",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n){var i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(void 0===r){e.next=4;break}e.t0={_id:t,_rev:r},e.next=7;break;case 4:return e.next=6,this.get(t);case 6:e.t0=e.sent;case 7:return i=e.t0,e.abrupt("return",i?this.pouchdb.remove(i):void 0);case 9:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"removeAll",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=this.pouchdb,e.next=3,t.allDocs();case 3:return r=e.sent,e.next=6,Promise.all(r.rows.map(function(e){return t.remove(e.id,e.value.rev)}));case 6:return e.abrupt("return",e.sent);case 7:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"replicateTo",value:function(t,r){return t instanceof e&&(t=t.pouchdb),this.pouchdb.replicate.to(t,r)}},{key:"replicateFrom",value:function(t,r){return t instanceof e&&(t=t.pouchdb),this.pouchdb.replicate.from(t,r)}},{key:"sync",value:function(t,r){return t instanceof e&&(t=t.pouchdb),this.pouchdb.sync(t,r)}},{key:"getConflicts",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.query({map:"function(doc) { if (doc._conflicts) emit(doc._id); }"},{reduce:!1,include_docs:!0,conflicts:!0});case 2:return t=e.sent,r=t.rows,e.abrupt("return",r.map(function(e){return e.doc}));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"resolveConflicts",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l,f,p;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.pouchdb.get("doc",{conflicts:!0});case 2:return n=e.sent,i=n._conflicts.map(function(e){return{id:t,rev:e}}),e.next=6,this.getDocuments(i);case 6:o=e.sent,a=n,s=!0,u=!1,c=void 0,e.prev=11,l=o[Symbol.iterator]();case 13:if(s=(f=l.next()).done){e.next=28;break}return p=f.value,e.next=17,r(a,p);case 17:if(a=e.sent){e.next=20;break}return e.abrupt("return",null);case 20:return e.next=22,this.set(t,a);case 22:return a=e.sent,e.next=25,this.pouchdb.remove(p);case 25:s=!0,e.next=13;break;case 28:e.next=34;break;case 30:e.prev=30,e.t0=e.catch(11),u=!0,c=e.t0;case 34:e.prev=34,e.prev=35,!s&&l.return&&l.return();case 37:if(e.prev=37,!u){e.next=40;break}throw c;case 40:return e.finish(37);case 41:return e.finish(34);case 42:return e.abrupt("return",a);case 43:case"end":return e.stop()}},e,this,[[11,30,34,42],[35,,37,41]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"dump",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=this.name,r=this.pouchdb,e.t0=t,e.t1=r.type(),e.t2=(new Date).toJSON(),e.next=7,r.info();case 7:return e.t3=e.sent,n={name:e.t0,db_type:e.t1,start_time:e.t2,db_info:e.t3},e.next=11,this.getAll({attachments:!0});case 11:return i=e.sent,e.abrupt("return",{header:n,docs:i});case 13:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"backup",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=this.name+"_backup_"+n,r=this.constructor.ensureDB(t),e.next=3,this.replicateTo(r);case 3:return e.abrupt("return",r);case 4:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"migrate",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.getAll();case 2:r=e.sent,n=[],i=[],o=0;case 5:if(!(o<r.length)){e.next=16;break}if(a=r[o],s=t(a,o)){e.next=10;break}return i.push(a),e.abrupt("continue",13);case 10:s.hasOwnProperty("_id")||(s._id=a._id),s.hasOwnProperty("_rev")&&delete s._rev,n.push(s);case 13:o++,e.next=5;break;case 16:return e.next=18,this.setDocuments(n);case 18:return e.abrupt("return",{migrated:n.length,unchanged:i.length});case 19:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"pouchdb",get:function(){if(this._pouchdb)return this._pouchdb;var e=this.name,t=this.options;return this._pouchdb=E(e,t)}}],[{key:"loadDump",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=t.header,n=t.docs,i=a.name||r.name,o=this.ensureDB(i),e.next=3,o.setDocuments(n,{new_edits:!1});case 3:return e.abrupt("return",o);case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()}]),e}(),A=function(){var e,t,r;return"object"==("undefined"==typeof process?"undefined":f(process))&&"object"==f(process.versions)&&process.versions.node&&"renderer"!==process.__atom_type?(r="undefined"!=typeof System?System._nodeRequire("crypto"):require("crypto"),t=function(){var e=r.createHash("sha1");return{update:function(t){return e.update(t)},digest:function(){return e.digest("hex")}}}):(e=new Uint32Array(80),t=function(t){function r(e){var t=e.length;h+=8*t;for(var r=0;r<t;r++)n(e.charCodeAt(r))}function n(e){a[p]|=(255&e)<<d,d?d-=8:(p++,d=24),16===p&&i()}function i(){for(var e=16;e<80;e++){var t=a[e-3]^a[e-8]^a[e-14]^a[e-16];a[e]=t<<1|t>>>31}var r,n,i=s,o=u,d=c,h=l,m=f;for(e=0;e<80;e++){e<20?(r=h^o&(d^h),n=1518500249):e<40?(r=o^d^h,n=1859775393):e<60?(r=o&d|h&(o|d),n=2400959708):(r=o^d^h,n=3395469782);var v=(i<<5|i>>>27)+r+m+n+(0|a[e]);m=h,h=d,d=o<<30|o>>>2,o=i,i=v}for(s=s+i|0,u=u+o|0,c=c+d|0,l=l+h|0,f=f+m|0,p=0,e=0;e<16;e++)a[e]=0}function o(e){for(var t="",r=28;r>=0;r-=4)t+=(e>>r&15).toString(16);return t}var a,s=1732584193,u=4023233417,c=2562383102,l=271733878,f=3285377520,p=0,d=24,h=0;return a=t?e:new Uint32Array(80),{update:function(e){if("string"==typeof e)return r(e);var t=e.length;h+=8*t;for(var i=0;i<t;i++)n(e[i])},digest:function(){n(128),(p>14||14===p&&d<24)&&i(),p=14,d=24,n(0),n(0),n(h>0xffffffffff?h/1099511627776:0),n(h>4294967295?h/4294967296:0);for(var e=24;e>=0;e-=8)n(h>>e);return o(s)+o(u)+o(c)+o(l)+o(f)}}}),function(e){if(void 0===e)return t(!1);var r=t(!0);return r.update(e),r.digest()}}(),D=D||new Map,C=function(){function e(t,r){if(d(this,e),this.name=t,!r.snapshotLocation||!r.snapshotLocation.isResource)throw new Error("ObjectDB needs snapshotLocation!");this.snapshotLocation=r.snapshotLocation,this.__commitDB=null,this.__versionDB=null}return h(e,null,[{key:"find",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!(r=D.get(t))){e.next=3;break}return e.abrupt("return",r);case 3:return n=S.ensureDB("__internal__objectdb-meta"),e.next=6,n.get(t);case 6:if(i=e.sent){e.next=9;break}return e.abrupt("return");case 9:return e.abrupt("return",this.named(t,i));case 10:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"named",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=D.get(e);if(r)return r;if(!t||!t.snapshotLocation)throw new Error("need snapshotLocation");if("string"==typeof t.snapshotLocation)try{t.snapshotLocation=n.resource(t.snapshotLocation)}catch(e){t.snapshotLocation=n.resource(System.baseURL).join(t.snapshotLocation)}var i=new this(e,t);return D.set(e,i),S.ensureDB("__internal__objectdb-meta").set(e,m({},t,{snapshotLocation:t.snapshotLocation.url})).catch(function(e){return console.error("error writing objectdb meta:",e)}),i}}]),h(e,[{key:"destroy",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!(t=S.findDB(this.name+"-commits"))){e.next=4;break}return e.next=4,t.destroy();case 4:if(!(r=S.findDB(this.name+"-version-graph"))){e.next=8;break}return e.next=8,r.destroy();case 8:return D.delete(this.name),n=S.ensureDB("__internal__objectdb-meta"),e.next=12,n.remove(this.name);case 12:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"snapshotResourceFor",value:function(e){var t=e.content.slice(0,2),r=e.content.slice(2);return this.snapshotLocation.join(t+"/"+r+".json")}},{key:"snapshotObject",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n,i,o,a,s,u){var c,l;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return i=i||{},c=function(e){return e},e.next=4,c(n,i);case 4:return l=e.sent,e.abrupt("return",this.commit(t,r,l,o,a,s,u));case 6:case"end":return e.stop()}},e,this)}));return function(t,r,n,i,o,a,s,u){return e.apply(this,arguments)}}()},{key:"loadObject",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n,i,o){var a,s;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=n||{},e.next=3,this.loadSnapshot(t,r,i,o);case 3:return a=e.sent,s=function(e){return e},e.abrupt("return",s(a,n));case 6:case"end":return e.stop()}},e,this)}));return function(t,r,n,i,o){return e.apply(this,arguments)}}()},{key:"has",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.objectStats(t,r);case 2:return e.abrupt("return",!!e.sent);case 3:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"objects",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.objectStats(t);case 2:if(r=e.sent,!t){e.next=5;break}return e.abrupt("return",Object.keys(r||{}));case 5:n={};for(i in r)n[i]=Object.keys(r[i]);return e.abrupt("return",n);case 8:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"objectStats",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,_,x,w,k,E;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n={},e.t0=this.__commitDB,e.t0){e.next=6;break}return e.next=5,this._commitDB();case 5:e.t0=e.sent;case 6:return i=e.t0,o={reduce:!0,group:!0},t&&r?o.key=t+"\0"+r:t&&(o.startkey=t+"\0",o.endkey=t+""),e.prev=9,e.next=12,i.pouchdb.query("nameWithMaxMinTimestamp_index",o);case 12:for(a=e.sent,s=a.rows,u=!0,c=!1,l=void 0,e.prev=17,f=s[Symbol.iterator]();!(u=(p=f.next()).done);u=!0)d=p.value,h=d.key,m=d.value,v=m.count,y=m.max,g=m.min,_=h.split("\0"),x=b(_,2),w=x[0],k=x[1],(E=n[w]||(n[w]={}))[k]={count:v,newest:y,oldest:g};e.next=25;break;case 21:e.prev=21,e.t1=e.catch(17),c=!0,l=e.t1;case 25:e.prev=25,e.prev=26,!u&&f.return&&f.return();case 28:if(e.prev=28,!c){e.next=31;break}throw l;case 31:return e.finish(28);case 32:return e.finish(25);case 33:e.next=39;break;case 35:return e.prev=35,e.t2=e.catch(9),console.error(e.t2),e.abrupt("return",n);case 39:if(!t||!r){e.next=41;break}return e.abrupt("return",(n[t]||{})[r]);case 41:if(!t){e.next=43;break}return e.abrupt("return",n[t]);case 43:return e.abrupt("return",n);case 44:case"end":return e.stop()}},e,this,[[9,35],[17,21,25,33],[26,,28,32]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"getCommits",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"HEAD",s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._log(t,r,a,s);case 2:if((n=e.sent).length){e.next=5;break}return e.abrupt("return",[]);case 5:if(e.t0=this.__commitDB,e.t0){e.next=10;break}return e.next=9,this._commitDB();case 9:e.t0=e.sent;case 10:return i=e.t0,e.next=13,i.getDocuments(n.map(function(e){return{id:e}}));case 13:return o=e.sent,e.abrupt("return",o);case 15:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"getCommit",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.t0=this.__commitDB,e.t0){e.next=5;break}return e.next=4,this._commitDB();case 4:e.t0=e.sent;case 5:return r=e.t0,e.abrupt("return",r.get(t));case 7:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"getCommitsWithIds",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t.length){e.next=2;break}return e.abrupt("return",[]);case 2:if(e.t0=this.__commitDB,e.t0){e.next=7;break}return e.next=6,this._commitDB();case 6:e.t0=e.sent;case 7:return r=e.t0,e.abrupt("return",r.getDocuments(t.map(function(e){return{id:e}})));case 9:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"getLatestCommit",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"HEAD",c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._log(t,r,u,1);case 2:if(n=e.sent,i=b(n,1),o=i[0]){e.next=7;break}return e.abrupt("return",null);case 7:if(e.t0=this.__commitDB,e.t0){e.next=12;break}return e.next=11,this._commitDB();case 11:e.t0=e.sent;case 12:return a=e.t0,e.next=15,a.get(o);case 15:if(!(s=e.sent)||!s.deleted||c){e.next=18;break}return e.abrupt("return",null);case 18:return e.abrupt("return",s);case 19:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"commit",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n,i,o){var a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"HEAD",k=arguments[6];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(a=i.user,s=i.description,u=void 0===s?"no description":s,c=i.tags,l=void 0===c?[]:c,f=i.message,p=void 0===f?"":f,d=i.metadata,t){e.next=3;break}throw new Error("object needs a type");case 3:if(r){e.next=5;break}throw new Error("object needs a name");case 5:if(a){e.next=7;break}throw new Error("Cannot commit "+t+"/"+r+" without user");case 7:if(e.t0=this.__versionDB,e.t0){e.next=12;break}return e.next=11,this._versionDB();case 11:e.t0=e.sent;case 12:return h=e.t0,e.next=15,this.versionGraph(t,r);case 15:if(m=e.sent,v=m?m.refs[w]:null,y=v?[v]:[],!k){e.next=23;break}if(m){e.next=21;break}throw new Error('Trying to store "'+t+"/"+r+'" on top of expected version '+k+" but no version entry exists!");case 21:if(v===k){e.next=23;break}throw new Error('Trying to store "'+t+"/"+r+'" on top of expected version '+k+" but ref "+w+" is of version "+v+"!");case 23:return g=n?JSON.stringify(n):null,b=this._createCommit(t,r,u,l,d,a,p,y,n,g,o),m||(m={refs:{},history:{}}),m.refs[w]=b._id,m.history[b._id]=y,e.next=29,h.set(t+"/"+r,m);case 29:if(e.t1=this.__commitDB,e.t1){e.next=34;break}return e.next=33,this._commitDB();case 33:e.t1=e.sent;case 34:return _=e.t1,e.next=37,_.set(b._id,b);case 37:if(b=e.sent,!n){e.next=49;break}return x=this.snapshotResourceFor(b),e.next=42,x.parent().ensureExistance();case 42:if(!x.canDealWithJSON){e.next=47;break}return e.next=45,x.writeJson(n);case 45:e.next=49;break;case 47:return e.next=49,x.write(g);case 49:return e.abrupt("return",b);case 50:case"end":return e.stop()}},e,this)}));return function(t,r,n,i,o){return e.apply(this,arguments)}}()},{key:"loadSnapshot",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n){var i,o,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"HEAD";return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(i=void 0,!n||"string"==typeof n){e.next=5;break}i=n,e.next=20;break;case 5:if(!n){e.next=17;break}if(e.t0=this.__commitDB,e.t0){e.next=11;break}return e.next=10,this._commitDB();case 10:e.t0=e.sent;case 11:return o=e.t0,e.next=14,o.get(n);case 14:i=e.sent,e.next=20;break;case 17:return e.next=19,this.getLatestCommit(t,r,a);case 19:i=e.sent;case 20:if(i){e.next=22;break}throw new Error("Cannot find commit to loadSnapshot for "+t+"/"+r+" (using "+n+")");case 22:return e.abrupt("return",this.snapshotResourceFor(i).readJson());case 23:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"_createCommit",value:function(e,t,r,n,o,a){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"",u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:[],c=arguments[8],l=arguments[9],f=arguments[10];!f&&c&&c.preview&&(f=c.preview);var p={name:t,type:e,timestamp:Date.now(),author:{name:a.name,email:a.email,realm:a.realm},tags:[],description:r,message:s,preview:f,content:l?A(l):null,deleted:!c,metadata:o,ancestors:u},d=i.obj.dissoc(p,["preview"]),h=A(JSON.stringify(d));return Object.assign(p,{_id:h})}},{key:"_commitDB",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.__commitDB){e.next=2;break}return e.abrupt("return",this.__commitDB);case 2:if(t=this.name+"-commits",!(r=S.findDB(t))){e.next=5;break}return e.abrupt("return",this.__commitDB=r);case 5:return r=S.ensureDB(t),e.next=8,Promise.all([r.has("_design/name_index"),r.has("_design/nameAndTimestamp_index"),r.has("_design/nameWithMaxMinTimestamp_index")]);case 8:if((n=e.sent).every(Boolean)){e.next=16;break}return console.log("Preparing indexes for object storage DB "+t),i={_id:"_design/name_index",views:{name_index:{map:"function (doc) { emit(`${doc.type}\0${doc.name}}`); }"}}},o={_id:"_design/nameAndTimestamp_index",views:{nameAndTimestamp_index:{map:"function (doc) { emit(`${doc.type}\0${doc.name}\0${doc.timestamp}}\0${doc._id}}`); }"}}},a={_id:"_design/nameWithMaxMinTimestamp_index",views:{nameWithMaxMinTimestamp_index:{map:"doc => emit(`${doc.type}\0${doc.name}`, doc.timestamp)",reduce:"_stats"}}},e.next=14,r.setDocuments([i,o,a]);case 14:return e.next=16,Promise.all([r.pouchdb.query("name_index",{stale:"update_after"}),r.pouchdb.query("nameAndTimestamp_index",{stale:"update_after"}),r.pouchdb.query("nameWithMaxMinTimestamp_index",{stale:"update_after"})]);case 16:return e.abrupt("return",this.__commitDB=r);case 17:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"versionGraph",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.t0=this.__versionDB,e.t0){e.next=5;break}return e.next=4,this._versionDB();case 4:e.t0=e.sent;case 5:return n=e.t0,e.next=8,n.get(t+"/"+r);case 8:return i=e.sent,e.abrupt("return",!i||i.deleted?null:i);case 10:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"_log",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){arguments.length>2&&void 0!==arguments[2]&&arguments[2];var n,i,o,a,s,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.versionGraph(t,r);case 2:if((n=e.sent)&&!n.deleted){e.next=5;break}return e.abrupt("return",[]);case 5:i=n.refs.HEAD,o=[];case 6:if(!o.includes(i)){e.next=9;break}throw new Error("cyclic version graph???");case 9:if(o.push(i),a=n.history[i]||[],s=b(a,1),(i=s[0])&&!(o.length>=u)){e.next=15;break}return e.abrupt("break",17);case 15:e.next=6;break;case 17:return e.abrupt("return",o);case 18:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"_findTimestampedVersionsOfObjectNamed",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=v.include_docs,n=void 0===r||r,i=v.descending,o=void 0===i||i,a=v.startTime,s=void 0===a?"0".repeat(13):a,u=v.endTime,c=void 0===u?"9".repeat(13):u,l=t+"\0"+(o?c:s),f=t+"\0"+(o?s:c),e.t0=this.__commitDB,e.t0){e.next=15;break}return e.next=14,this._commitDB();case 14:e.t0=e.sent;case 15:return p=e.t0,e.next=18,p.pouchdb.query("nameAndTimestamp_index",m({},v,{descending:o,include_docs:n,startkey:l,endkey:f}));case 18:return d=e.sent,h=d.rows,e.abrupt("return",n?h.map(function(e){return e.doc}):h.map(function(e){return e.id}));case 21:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_versionDB",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.__versionDB){e.next=2;break}return e.abrupt("return",this.__versionDB);case 2:if(t=this.name+"-version-graph",!(r=S.findDB(t))){e.next=5;break}return e.abrupt("return",this.__versionDB=r);case 5:return r=S.ensureDB(t),e.abrupt("return",this.__versionDB=r);case 7:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"exportToDir",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l=this,f=arguments.length>2&&void 0!==arguments[2]&&arguments[2],p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.t0=this.__commitDB,e.t0){e.next=5;break}return e.next=4,this._commitDB();case 4:e.t0=e.sent;case 5:n=e.t0,i=!0,o=!1,a=void 0,e.prev=10,s=regeneratorRuntime.mark(function e(){var r,n,i,o,a,s,u,d,h,m,v,y,g,b,_,x,w,k;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=c.value,n=r.name,i=r.type,o=t.join(i).join(n).asDirectory(),e.next=5,l.versionGraph(i,n);case 5:return a=e.sent,s=a.refs,u=a.history,d=Object.keys(u),e.next=11,l.getCommitsWithIds(d);case 11:return h=e.sent,p||(h=h.filter(function(e){return!e.deleted})),m=f?h.map(function(e){delete e._rev;var t=l.snapshotResourceFor(e);return{from:t,to:o.join(t.parent().name()+"/"+t.name())}}):[],f||h.forEach(function(e){delete e._rev}),e.next=17,o.ensureExistance();case 17:return e.next=19,o.join("index.json").writeJson({name:n,type:i});case 19:return e.next=21,o.join("commits.json").writeJson(h);case 21:return e.next=23,o.join("history.json").writeJson({refs:s,history:u});case 23:v=!0,y=!1,g=void 0,e.prev=26,b=m[Symbol.iterator]();case 28:if(v=(_=b.next()).done){e.next=36;break}return x=_.value,w=x.from,k=x.to,e.next=33,w.copyTo(k);case 33:v=!0,e.next=28;break;case 36:e.next=42;break;case 38:e.prev=38,e.t0=e.catch(26),y=!0,g=e.t0;case 42:e.prev=42,e.prev=43,!v&&b.return&&b.return();case 45:if(e.prev=45,!y){e.next=48;break}throw g;case 48:return e.finish(45);case 49:return e.finish(42);case 50:case"end":return e.stop()}},e,l,[[26,38,42,50],[43,,45,49]])}),u=r[Symbol.iterator]();case 13:if(i=(c=u.next()).done){e.next=18;break}return e.delegateYield(s(),"t1",15);case 15:i=!0,e.next=13;break;case 18:e.next=24;break;case 20:e.prev=20,e.t2=e.catch(10),o=!0,a=e.t2;case 24:e.prev=24,e.prev=25,!i&&u.return&&u.return();case 27:if(e.prev=27,!o){e.next=30;break}throw a;case 30:return e.finish(27);case 31:return e.finish(24);case 32:case"end":return e.stop()}},e,this,[[10,20,24,32],[25,,27,31]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"exportToSpecs",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=[],t){e.next=10;break}return t=[],e.next=5,this.objectStats();case 5:if(e.t0=e.sent,e.t0){e.next=8;break}e.t0={};case 8:n=e.t0;for(i in n)for(o in n[i])t.push({type:i,name:o});case 10:a=!0,s=!1,u=void 0,e.prev=13,c=t[Symbol.iterator]();case 15:if(a=(l=c.next()).done){e.next=33;break}return f=l.value,p=f.name,d=f.type,e.next=20,this.versionGraph(d,p);case 20:return h=e.sent,m=h.refs,v=h.history,y=Object.keys(v),e.next=26,this.getCommitsWithIds(y);case 26:g=e.sent,b||(g=g.filter(function(e){return!e.deleted})),g.forEach(function(e){delete e._rev}),r.push({type:d,name:p,commits:g,history:{refs:m,history:v}});case 30:a=!0,e.next=15;break;case 33:e.next=39;break;case 35:e.prev=35,e.t1=e.catch(13),s=!0,u=e.t1;case 39:e.prev=39,e.prev=40,!a&&c.return&&c.return();case 42:if(e.prev=42,!s){e.next=45;break}throw u;case 45:return e.finish(42);case 46:return e.finish(39);case 47:return e.abrupt("return",r);case 48:case"end":return e.stop()}},e,this,[[13,35,39,47],[40,,42,46]])}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromDir",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.join("index.json").readJson(),t.join("commits.json").readJson(),t.join("history.json").readJson()]);case 2:if(r=e.sent,n=b(r,3),i=n[0],o=i.type,a=i.name,s=n[1],u=n[2],!m){e.next=15;break}return e.next=12,t.dirList(1,{exclude:function(e){return!e.isDirectory()}});case 12:e.t0=e.sent,e.next=16;break;case 15:e.t0=[];case 16:return c=e.t0,e.abrupt("return",{dir:t,type:o,name:a,commits:s,history:u,snapshotDirs:c});case 18:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}(),m=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.dirList(3,{exclude:function(e){return!e.isDirectory()&&"index.json"!==e.name()}});case 2:r=e.sent,r=r.filter(function(e){return"index.json"===e.name()}),n=r.map(function(e){return e.parent()}),i=this.snapshotLocation,o=[],a=!0,s=!1,u=void 0,e.prev=9,c=n[Symbol.iterator]();case 11:if(a=(l=c.next()).done){e.next=21;break}return f=l.value,e.t0=o,e.next=16,h(f);case 16:e.t1=e.sent,e.t0.push.call(e.t0,e.t1);case 18:a=!0,e.next=11;break;case 21:e.next=27;break;case 23:e.prev=23,e.t2=e.catch(9),s=!0,u=e.t2;case 27:e.prev=27,e.prev=28,!a&&c.return&&c.return();case 30:if(e.prev=30,!s){e.next=33;break}throw u;case 33:return e.finish(30);case 34:return e.finish(27);case 35:return e.abrupt("return",this.importFromSpecs(o,d,m));case 36:case"end":return e.stop()}},e,this,[[9,23,27,35],[28,,30,34]])}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromSpecs",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,m,v,y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(y){e.next=36;break}if(e.t0=this.__versionDB,e.t0){e.next=6;break}return e.next=5,this._versionDB();case 5:e.t0=e.sent;case 6:r=e.t0,n=!0,i=!1,o=void 0,e.prev=10,a=t[Symbol.iterator]();case 12:if(n=(s=a.next()).done){e.next=22;break}return u=s.value,c=u.type,l=u.name,e.next=17,r.get(c+"/"+l);case 17:if(!e.sent){e.next=19;break}throw new Error("Import failed: object "+c+"/"+l+" already exists and overwrite is not allowed");case 19:n=!0,e.next=12;break;case 22:e.next=28;break;case 24:e.prev=24,e.t1=e.catch(10),i=!0,o=e.t1;case 28:e.prev=28,e.prev=29,!n&&a.return&&a.return();case 31:if(e.prev=31,!i){e.next=34;break}throw o;case 34:return e.finish(31);case 35:return e.finish(28);case 36:f=!0,p=!1,d=void 0,e.prev=39,h=t[Symbol.iterator]();case 41:if(f=(m=h.next()).done){e.next=48;break}return v=m.value,e.next=45,this.importFromSpec(v,!0,g);case 45:f=!0,e.next=41;break;case 48:e.next=54;break;case 50:e.prev=50,e.t2=e.catch(39),p=!0,d=e.t2;case 54:e.prev=54,e.prev=55,!f&&h.return&&h.return();case 57:if(e.prev=57,!p){e.next=60;break}throw d;case 60:return e.finish(57);case 61:return e.finish(54);case 62:return e.abrupt("return",t);case 63:case"end":return e.stop()}},e,this,[[10,24,28,36],[29,,31,35],[39,50,54,62],[55,,57,61]])}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromSpec",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.t0=this.__versionDB,e.t0){e.next=5;break}return e.next=4,this._versionDB();case 4:e.t0=e.sent;case 5:if(r=e.t0,e.t1=this.__commitDB,e.t1){e.next=11;break}return e.next=10,this._commitDB();case 10:e.t1=e.sent;case 11:if(n=e.t1,i=this.snapshotLocation,o=t.type,a=t.name,s=t.commits,u=t.history,c=t.snapshotDirs,e.t2=!l,!e.t2){e.next=23;break}return e.next=22,r.get(o+"/"+a);case 22:e.t2=e.sent;case 23:if(!e.t2){e.next=25;break}throw new Error("Import failed: object "+o+"/"+a+" already exists and overwrite is not allowed");case 25:return e.next=27,Promise.all([n.setDocuments(s),r.set(o+"/"+a,u)].concat(_(c&&f?c.map(function(e){return e.copyTo(i.join(e.name()).asDirectory())}):[])));case 27:return e.abrupt("return",t);case 28:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromResource",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r,n,i){var o,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n.readJson();case 2:if(o=e.sent,e.t0=a,!e.t0){e.next=8;break}return e.next=7,this.has(t,r);case 7:e.t0=e.sent;case 8:if(!e.t0){e.next=11;break}return e.next=11,this.delete(t,r,!1);case 11:return e.abrupt("return",this.commit(t,r,o,i));case 12:case"end":return e.stop()}},e,this)}));return function(t,r,n,i){return e.apply(this,arguments)}}()},{key:"delete",value:function(){var e=p(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l,f,p,d,h,v,y,g,b,_,x,w=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n=[],i=[],e.t0=this.__commitDB,e.t0){e.next=6;break}return e.next=5,this._commitDB();case 5:e.t0=e.sent;case 6:return o=e.t0,a={include_docs:!0,startkey:t+"\0"+r+"\0",endkey:t+"\0"+r+""},e.next=10,o.query("nameAndTimestamp_index",a);case 10:for(s=e.sent,u=s.rows,c=!0,l=!1,f=void 0,e.prev=15,p=u[Symbol.iterator]();!(c=(d=p.next()).done);c=!0)h=d.value,v=h.doc,n.push(this.snapshotResourceFor(v)),i.push(m({},v,{_deleted:!0}));e.next=23;break;case 19:e.prev=19,e.t1=e.catch(15),l=!0,f=e.t1;case 23:e.prev=23,e.prev=24,!c&&p.return&&p.return();case 26:if(e.prev=26,!l){e.next=29;break}throw f;case 29:return e.finish(26);case 30:return e.finish(23);case 31:if(e.t2=this.__versionDB,e.t2){e.next=36;break}return e.next=35,this._versionDB();case 35:e.t2=e.sent;case 36:return y=e.t2,e.next=39,y.get(t+"/"+r);case 39:if(g=e.sent,b=g._id,_=g._rev,x={_id:b,_rev:_,deleted:!0},w){e.next=49;break}return e.next=46,o.setDocuments(i);case 46:return e.next=48,y.setDocuments([x]);case 48:Promise.all(n.map(function(e){return e.remove()}));case 49:return e.abrupt("return",{commits:i,history:x,resources:n});case 50:case"end":return e.stop()}},e,this,[[15,19,23,31],[24,,26,30]])}));return function(t,r){return e.apply(this,arguments)}}()},{key:"deleteCommit",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,v,y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"HEAD";return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=void 0,!t||"string"==typeof t){e.next=5;break}r=t,e.next=15;break;case 5:if(!t){e.next=15;break}if(e.t0=this.__commitDB,e.t0){e.next=11;break}return e.next=10,this._commitDB();case 10:e.t0=e.sent;case 11:return n=e.t0,e.next=14,n.get(t);case 14:r=e.sent;case 15:if(r){e.next=17;break}throw new Error("commit needed!");case 17:if(e.t1=this.__versionDB,e.t1){e.next=22;break}return e.next=21,this._versionDB();case 21:e.t1=e.sent;case 22:if(i=e.t1,e.t2=this.__commitDB,e.t2){e.next=28;break}return e.next=27,this._commitDB();case 27:e.t2=e.sent;case 28:return o=e.t2,a=r,s=a.name,u=a.type,c=a._id,l=[this.snapshotResourceFor(r)],f=[m({},r,{_deleted:!0})],e.next=37,i.get(u+"/"+s);case 37:if(p=e.sent){e.next=40;break}throw new Error("No history for "+u+"/"+s+"@"+r._id);case 40:if(p.refs[g]){e.next=42;break}throw new Error("Cannot delete commit "+u+"/"+s+"@"+r._id+" b/c it is not where ref "+g+" is pointing!");case 42:if(d=p.history[r._id]||[],h=b(d,1),(v=h[0])||!(Object.keys(p.history).length<=1)){e.next=47;break}p.deleted=!0,e.next=53;break;case 47:if(v){e.next=51;break}throw new Error("Cannot delete commit "+u+"/"+s+"@"+r._id+" b/c it has no ancestor but there are still other commits!");case 51:delete p.history[r._id],p.refs[g]=v;case 53:if(y){e.next=59;break}return e.next=56,o.setDocuments(f);case 56:return e.next=58,i.set(u+"/"+s,p);case 58:Promise.all(l.map(function(e){return e.remove()}));case 59:return e.abrupt("return",{commits:f,history:p,resources:l});case 60:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()}]),e}(),F={describe:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a;return regeneratorRuntime.wrap(function(r){for(;;)switch(r.prev=r.next){case 0:if(a=function(e,t){var r=e.find(function(e){return e.name===t}).node.value.body,n=r.body||[],i=(r.comments||[]).find(function(e){return e.end<n[0].start}),o={name:t,parameters:[],sideEffect:!1,returns:null,description:""};if(i&&i.text.trim()){var a=lively.lang.string.changeIndent(i.text," ",0).split("\n"),s=!0,u=!1,c=void 0;try{for(var l,f=a[Symbol.iterator]();!(s=(l=f.next()).done);s=!0){var p=l.value;if(p.startsWith("ignore-in-doc")){o.description="";break}p.startsWith("side effect:")?o.sideEffect=JSON.parse(p.split(":")[1]):p.startsWith("returns:")?o.returns=p.split(":")[1].trim():o.description+=p+"\n"}}catch(e){u=!0,c=e}finally{try{!s&&f.return&&f.return()}finally{if(u)throw c}}}var d=!0,h=!1,m=void 0;try{for(var v,y=n[Symbol.iterator]();!(d=(v=y.next()).done);d=!0){var g=v.value;if("checkArgs"===lively.lang.Path("declarations.0.init.callee.name").get(g)){var b=lively.lang.Path("declarations.0.id.properties").get(g);b&&(o.parameters=b.map(function(e){return e.key.name}))}}}catch(e){h=!0,m=e}finally{try{!d&&y.return&&y.return()}finally{if(h)throw m}}return o},r.prev=1,t._methodSpecs){r.next=9;break}return r.next=5,lively.modules.module("lively.storage/objectdb.js").source();case 5:n=r.sent,i=lively.ast.parse(n,{withComments:!0}),o=lively.ast.categorizer.findDecls(i),t._methodSpecs=o.filter(function(e){return e.parent&&"ObjectDBInterface"===e.parent.name});case 9:return r.abrupt("return",e?a(t._methodSpecs,e):t._methodSpecs.map(function(e){return a(t._methodSpecs,e.name)}).filter(Boolean));case 12:return r.prev=12,r.t0=r.catch(1),r.abrupt("return","Error in describe "+r.t0);case 15:case"end":return r.stop()}},r,t,[[1,12]])}))()},ensureDB:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",snapshotLocation:"string|Resource"}),i=n.db,o=n.snapshotLocation,t.next=5,C.find(i);case 5:if(!(a=t.sent)){t.next=8;break}return t.abrupt("return",!1);case 8:return C.named(i,{snapshotLocation:o}),t.abrupt("return",!0);case 10:case"end":return t.stop()}},r,t)}))()},destroyDB:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string"}),i=n.db,t.next=4,C.find(i);case 4:if(o=t.sent){t.next=7;break}return t.abrupt("return",!1);case 7:return t.next=9,o.destroy();case 9:return t.abrupt("return",!0);case 10:case"end":return t.stop()}},r,t)}))()},fetchCommits:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u,l,f,p,d,h,m,v,y,g,b,_,x,w,k,E,S,A,D,F,O,j,R,B,P,T,I,L,N;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",ref:"string|undefined",type:"string|undefined",typesAndNames:"Array|undefined",knownCommitIds:"object|undefined",includeDeleted:"boolean|undefined"}),i=n.db,o=n.ref,a=n.type,s=n.typesAndNames,u=n.knownCommitIds,l=n.includeDeleted,t.next=9,C.find(i);case 9:if(f=t.sent,o||(o="HEAD"),f){t.next=13;break}throw new Error("db "+i+" does not exist");case 13:if(t.t0=f.__commitDB,t.t0){t.next=18;break}return t.next=17,f._commitDB();case 17:t.t0=t.sent;case 18:if(p=t.t0,t.t1=f.__versionDB,t.t1){t.next=24;break}return t.next=23,f._versionDB();case 23:t.t1=t.sent;case 24:if(d=t.t1,h={},m={},!s){t.next=49;break}for(v=h.keys=[],y=!0,g=!1,b=void 0,t.prev=31,_=s[Symbol.iterator]();!(y=(x=_.next()).done);y=!0)w=x.value,k=w.type,E=w.name,S=w.ref,v.push(k+"/"+E),S&&(m[k+"/"+E]=S);t.next=39;break;case 35:t.prev=35,t.t2=t.catch(31),g=!0,b=t.t2;case 39:t.prev=39,t.prev=40,!y&&_.return&&_.return();case 42:if(t.prev=42,!g){t.next=45;break}throw b;case 45:return t.finish(42);case 46:return t.finish(39);case 47:t.next=50;break;case 49:a&&(h.startkey=a+'/\0"',h.endkey=a+'/"');case 50:return t.next=52,d.getAll(h);case 52:A=t.sent,D=[],F=!0,O=!1,j=void 0,t.prev=57,R=A[Symbol.iterator]();case 59:if(F=(B=R.next()).done){t.next=70;break}if(!(P=B.value).deleted){t.next=63;break}return t.abrupt("continue",67);case 63:T=P._id,I=P.refs,o=m[T]||o,((L=I[o])&&!u||!u.hasOwnProperty(L))&&D.push(L);case 67:F=!0,t.next=59;break;case 70:t.next=76;break;case 72:t.prev=72,t.t3=t.catch(57),O=!0,j=t.t3;case 76:t.prev=76,t.prev=77,!F&&R.return&&R.return();case 79:if(t.prev=79,!O){t.next=82;break}throw j;case 82:return t.finish(79);case 83:return t.finish(76);case 84:return t.next=86,f.getCommitsWithIds(D);case 86:return N=t.sent,l||(N=N.filter(function(e){return!e.deleted})),t.abrupt("return",N);case 89:case"end":return t.stop()}},r,t,[[31,35,39,47],[40,,42,46],[57,72,76,84],[77,,79,83]])}))()},fetchVersionGraph:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u,l,f;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",type:"string",name:"string"}),i=n.db,o=n.type,a=n.name,t.next=6,C.find(i);case 6:if(s=t.sent){t.next=9;break}throw new Error("db "+i+" does not exist");case 9:return t.next=11,s.versionGraph(o,a);case 11:return u=t.sent,l=u.refs,f=u.history,t.abrupt("return",{refs:l,history:f});case 15:case"end":return t.stop()}},r,t)}))()},fetchLog:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u,l,f,p,d,h,m,v,y,g,_,x,w,k,E;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",type:"string|undefined",name:"string|undefined",ref:"string|undefined",commit:"string|undefined",limit:"number|undefined",includeCommits:"boolean|undefined",knownCommitIds:"object|undefined"},function(e){return e.type&&e.name||e.commit?null:{error:"Eiter .type + .name or .commit needed!"}}),i=n.db,o=n.type,a=n.name,s=n.ref,u=n.commit,l=n.limit,f=n.includeCommits,p=n.knownCommitIds,t.next=11,C.find(i);case 11:if(d=t.sent,h=s||"HEAD",d){t.next=15;break}throw new Error("db "+i+" does not exist");case 15:if(l||(l=1/0),u||s||(s=h),m=void 0,!u){t.next=27;break}if(m=u,o&&a){t.next=27;break}return t.next=24,d.getCommit(u);case 24:v=t.sent,o=v.type,a=v.name;case 27:return t.next=29,d.versionGraph(o,a);case 29:if(y=t.sent){t.next=32;break}throw new Error("Unknown object "+o+"/"+a);case 32:g=y.refs,_=y.history,m||(m=g[s]),x=m,w=[];case 35:if(!(w.length<l)||w.includes(x)){t.next=44;break}if(w.push(x),(k=_[x])&&k.length){t.next=40;break}return t.abrupt("break",44);case 40:E=b(k,1),x=E[0],t.next=35;break;case 44:if(!f){t.next=49;break}return p&&(w=w.filter(function(e){return!p.hasOwnProperty(e)})),t.next=48,d.getCommitsWithIds(w);case 48:w=t.sent;case 49:return t.abrupt("return",w);case 50:case"end":return t.stop()}},r,t)}))()},fetchSnapshot:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u,l,f,p,d;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",type:"string|undefined",name:"string|undefined",ref:"string|undefined",commit:"string|undefined"},function(e){return e.type&&e.name||e.commit?null:{error:"Eiter .type + .name or .commit needed!"}}),i=n.db,o=n.type,a=n.name,s=n.ref,u=n.commit,t.next=8,C.find(i);case 8:if(l=t.sent,f="HEAD",s=s||f,l){t.next=13;break}throw new Error("db "+i+" does not exist");case 13:if(u){t.next=22;break}return t.next=16,l.versionGraph(o,a);case 16:if(p=t.sent){t.next=19;break}throw new Error("Unknown object "+o+"/"+a);case 19:if(u=p.refs[s]){t.next=22;break}throw new Error("Cannot find commit for ref "+s+" of "+o+"/"+a);case 22:return t.next=24,l.getCommit(u);case 24:if(d=t.sent){t.next=27;break}throw new Error("Cannot find commit "+u);case 27:return t.abrupt("return",l.loadSnapshot(void 0,void 0,d));case 28:case"end":return t.stop()}},r,t)}))()},commit:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u,l,f,p,d;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",type:"string",name:"string",ref:"string|undefined",snapshot:"object",preview:"string|undefined",commitSpec:"object",expectedParentCommit:"string|undefined"}),i=n.db,o=n.type,a=n.name,s=n.ref,u=n.expectedParentCommit,l=n.commitSpec,f=n.snapshot,p=n.preview,t.next=11,C.find(i);case 11:return d=t.sent,s||(s="HEAD"),t.abrupt("return",d.commit(o,a,f,l,p,s,u));case 14:case"end":return t.stop()}},r,t)}))()},exportToSpecs:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",nameAndTypes:"Array|undefined",includeDeleted:"boolean|undefined"}),i=n.db,o=n.nameAndTypes,t.next=5,C.find(i);case 5:if(a=t.sent){t.next=8;break}throw new Error("db "+i+" does not exist");case 8:return t.abrupt("return",a.exportToSpecs(o));case 9:case"end":return t.stop()}},r,t)}))()},exportToDir:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var i,o,a,s,u,l,f,p;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return i=c(e,{db:"string",url:"string",nameAndTypes:"Array|undefined",copyResources:"boolean|undefined",includeDeleted:"boolean|undefined"}),o=i.db,a=i.url,s=i.nameAndTypes,u=i.copyResources,l=i.includeDeleted,t.next=8,C.find(o);case 8:if(f=t.sent,p=void 0,f){t.next=12;break}throw new Error("db "+o+" does not exist");case 12:try{p=n.resource(a)}catch(e){p=n.resource(System.baseURL).join(a)}return t.abrupt("return",f.exportToDir(p,s,u,l));case 14:case"end":return t.stop()}},r,t)}))()},importFromDir:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var i,o,a,s,u,l,f;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return i=c(e,{db:"string",url:"string",overwrite:"boolean|undefined",copyResources:"boolean|undefined"}),o=i.db,a=i.url,s=i.overwrite,u=i.copyResources,t.next=7,C.find(o);case 7:if(l=t.sent,f=void 0,l){t.next=11;break}throw new Error("db "+o+" does not exist");case 11:try{f=n.resource(a)}catch(e){f=n.resource(System.baseURL).join(a)}return t.abrupt("return",l.importFromDir(f,s,u));case 13:case"end":return t.stop()}},r,t)}))()},importFromSpecs:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var n,i,o,a,s,u;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=c(e,{db:"string",specs:"object",overwrite:"boolean|undefined",copyResources:"boolean|undefined"}),i=n.db,o=n.specs,a=n.overwrite,s=n.copyResources,t.next=7,C.find(i);case 7:if(u=t.sent){t.next=10;break}throw new Error("db "+i+" does not exist");case 10:return t.abrupt("return",u.importFromSpecs(o,a,s));case 11:case"end":return t.stop()}},r,t)}))()},importFromResource:function(e){var t=this;return p(regeneratorRuntime.mark(function r(){var i,o,a,s,u,l,f,p,d;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return i=c(e,{db:"string",type:"string",name:"string",url:"string",commitSpec:"object",purgeHistory:"boolean|undefined"}),o=i.db,a=i.type,s=i.name,u=i.url,l=i.commitSpec,f=i.purgeHistory,t.next=9,C.find(o);case 9:if(p=t.sent,d=void 0,p){t.next=13;break}throw new Error("db "+o+" does not exist");case 13:try{d=n.resource(u)}catch(e){d=n.resource(System.baseURL).join(u)}return t.abrupt("return",p.importFromResource(a,s,d,l,f));case 15:case"end":return t.stop()}},r,t)}))()}},O=(function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:document.origin+"/objectdb/";d(this,e),this.serverURL=t}h(e,[{key:"_processResponse",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=t.headers.get("content-type"),e.next=3,t.text();case 3:if(n=e.sent,i=void 0,"application/json"===r)try{i=JSON.parse(n)}catch(e){}if(t.ok&&!i.error){e.next=8;break}throw new Error(i&&i.error||n||t.statusText);case 8:return e.abrupt("return",i||n);case 9:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_GET",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=Object.keys(i).map(function(e){var t=i[e];return"object"===(void 0===t?"undefined":f(t))&&(t=JSON.stringify(t)),e+"="+encodeURIComponent(t)}).join("&"),n=this.serverURL+t+"?"+r,e.t0=this,e.next=4,fetch(n);case 4:return e.t1=e.sent,e.abrupt("return",e.t0._processResponse.call(e.t0,e.t1));case 6:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_POST",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=this.serverURL+t,e.t0=this,e.next=4,fetch(r,{method:"POST",body:JSON.stringify(n),headers:{"content-type":"application/json"}});case 4:return e.t1=e.sent,e.abrupt("return",e.t0._processResponse.call(e.t0,e.t1));case 6:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"describe",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("describe",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"ensureDB",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("ensureDB",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"destroyDB",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("destroyDB",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"fetchCommits",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("fetchCommits",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"fetchVersionGraph",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("fetchVersionGraph",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"fetchLog",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("fetchLog",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"fetchSnapshot",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("fetchSnapshot",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"commit",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("commit",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"exportToSpecs",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._GET("exportToSpecs",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"exportToDir",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("exportToDir",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromDir",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("importFromDir",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromSpecs",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("importFromSpecs",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"importFromResource",value:function(){var e=p(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this._POST("importFromResource",t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()}])}(),/\//g),j=function(e){function t(){return d(this,t),g(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return y(t,S),h(t,null,[{key:"ensureDB",value:function(e,r){return v(t.__proto__||Object.getPrototypeOf(t),"ensureDB",this).call(this,"lively.storage-"+e,r)}}]),t}(),R={name:"lively.storage",matches:function(e){return e.startsWith("lively.storage:")},resourceClass:function(e){function t(){return d(this,t),g(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return y(t,e),h(t,[{key:"read",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=3,this.db.get(this.pathWithoutQuery());case 3:return t=e.sent,r=t&&t.content,e.abrupt("return",r?"string"==typeof r?r:JSON.stringify(r):"");case 6:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"readJson",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.read();case 2:return t=e.sent,e.abrupt("return","string"==typeof t?JSON.parse(t):t);case 4:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"write",value:function(){var e=p(regeneratorRuntime.mark(function e(t){var r=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t||(t=""),!this.isDirectory()){e.next=4;break}throw new Error("Cannot write into a directory! ("+this.url+")");case 4:return e.next=6,this.db.update(this.pathWithoutQuery(),function(e){if(e&&e.isDirectory)throw new Error(r.url+" already exists and is a directory (cannot write into it!)");var n=Date.now();return e?m({},e,{lastModified:n,size:t.length,content:t}):{etag:void 0,type:void 0,contentType:void 0,user:void 0,group:void 0,mode:void 0,lastModified:n,created:n,size:"string"==typeof t?t.length:0,content:t}});case 6:return e.abrupt("return",this);case 7:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"writeJson",value:function(e){return this.write(e)}},{key:"mkdir",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(this.isDirectory()){e.next=3;break}throw new Error("Cannot mkdir a file! ("+this.url+")");case 3:return e.next=5,this.db.get(this.pathWithoutQuery());case 5:if(!(t=e.sent)){e.next=10;break}if(t.isDirectory){e.next=9;break}throw new Error(this.url+" already exists and is a file (cannot mkdir it!)");case 9:return e.abrupt("return",this);case 10:return r=Date.now(),e.next=13,this.db.set(this.pathWithoutQuery(),{etag:void 0,type:void 0,contentType:void 0,user:void 0,group:void 0,mode:void 0,lastModified:r,created:r,isDirectory:!0});case 13:return e.abrupt("return",this);case 14:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"exists",value:function(){var e=p(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.t0=this.isRoot(),e.t0){e.next=6;break}return e.next=5,this.db.get(this.pathWithoutQuery());case 5:e.t0=!!e.sent;case 6:return e.abrupt("return",e.t0);case 7:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"remove",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=this.pathWithoutQuery(),r=this.db,e.next=5,r.docList({startkey:t,endkey:t+""});case 5:return n=e.sent,e.next=8,r.setDocuments(n.map(function(e){return{_id:e.id,_rev:e.rev,_deleted:!0}}));case 8:return e.abrupt("return",this);case 9:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"readProperties",value:function(){return this.db.get(this.pathWithoutQuery())}},{key:"dirList",value:function(){var e=p(regeneratorRuntime.mark(function e(){var t,r,n,i,o,a,s,u,c,f,p,d,h,m,v,y=this,g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(this.isDirectory()){e.next=3;break}return e.abrupt("return",this.asDirectory().dirList(g,b));case 3:return t=b.exclude,r=this.pathWithoutQuery(),n=[],e.next=8,this.db.getAll({startkey:r,endkey:r+""});case 8:i=e.sent,"infinity"===g&&(g=1/0),o=0;case 11:if(!(o<i.length)){e.next=29;break}if(a=i[o],s=a._id,u=a.isDirectory,s.startsWith(r)&&r!==s){e.next=15;break}return e.abrupt("continue",26);case 15:if(c=s.slice(r.length),!((f=c.includes("/")?c.match(O).length+1:1)>g)){e.next=20;break}if("continue"!==(p=function(){var e=y.join(c.split("/").slice(0,g).join("/")+"/");return n.some(function(t){return t.equals(e)})||n.push(e),"continue"}())){e.next=20;break}return e.abrupt("continue",26);case 20:if(d=this.join(c),!t||l(d,t)){e.next=23;break}return e.abrupt("continue",26);case 23:for(n.push(d),h=["created","lastModified","mode","group","user","contentType","type","etag","size"],m={},v=0;v<h.length;v++)d[h[v]]=a[h[v]];case 26:o++,e.next=11;break;case 29:return e.abrupt("return",n);case 30:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"canDealWithJSON",get:function(){return!0}},{key:"db",get:function(){return this._db||(this._db=j.ensureDB(this.host()))}}]),t}(n.Resource)};n.registerExtension(R),e.Database=S,e.ObjectDB=C,e.ObjectDBInterface=F}(this.lively.storage=this.lively.storage||{},e,t,lively.resources,lively.lang)}.call(r),"undefined"!=typeof module&&module.exports&&(module.exports=r.lively.storage)}()}(),function configure(){function decideAboutTranspiler(e){return e.supportsAsyncAwait?"lively.transpiler":"plugin-babel"}function setupLivelyTranspiler(e){function t(e,t,r){this.System=e,this.moduleId=t,this.env=r}if(e.isBrowser){if("undefined"!=typeof Babel&&(System.global.babel=Babel,delete System.global.Babel),!System.global.babel)return void console.error("[lively.modules] in browser environments babel is required to be loaded before lively.modules!")}else System.global.babel=loadBabel_node();console.log("[lively.modules] SystemJS configured with lively.transpiler & babel"),t.prototype.transpileDoit=function(e,t){var r=this.System,e="(async function(__rec) {\n"+e.replace(/(\/\/# sourceURL=.+)$|$/,"\n}).call(this);\n$1"),n=r.babelOptions;return n.plugins&&n.plugins.length||n.presets&&n.presets.length?r.global.babel.transform(e,n).code:e},t.prototype.transpileModule=function(e,t){var r=this.System,n=Object.assign({},r.babelOptions);return n.plugins=n.plugins?n.plugins.slice():[],n.plugins.push("transform-es2015-modules-systemjs"),r.global.babel.transform(e,n).code},System.set("lively.transpiler",System.newModule({default:t})),System._loader.transpilerPromise=Promise.resolve({translate:function(e,r){return new t(this,e.name,{}).transpileModule(e.source,{})}}),System.config({transpiler:"lively.transpiler",babelOptions:{sourceMaps:!1,compact:"auto",comments:"true",presets:e.supportsAsyncAwait?[]:["es2015"]}})}function setupPluginBabelTranspiler(e){var t=!!System.get("@system-env").browser,r=t?findSystemJSPluginBabel_browser():findSystemJSPluginBabel_node(),n=System.global.babel;r||n?r?(console.log("[lively.modules] SystemJS configured with systemjs-plugin-babel transpiler from "+r),System.config({map:{"plugin-babel":r+"/plugin-babel.js","systemjs-babel-build":r+(t?"/systemjs-babel-browser.js":"/systemjs-babel-node.js")},transpiler:"plugin-babel",babelOptions:Object.assign({sourceMaps:"inline",stage3:!0,es2015:!0,modularRuntime:!0},System.babelOptions)})):(console.warn("[lively.modules] Could not find path to systemjs-plugin-babel but babel! Will fallback but there might be features in lively.modules that won't work!"),System.config({transpiler:"babel"})):console.error("[lively.modules] Could not find path to systemjs-plugin-babel nor a babel global! This will likely break lively.modules!")}function featureTest(){var isBrowser=System.get("@system-env").browser||"undefined"!=typeof self,supportsAsyncAwait=!1;try{eval("async function foo() {}"),supportsAsyncAwait=!0}catch(e){}return{supportsAsyncAwait:supportsAsyncAwait,isBrowser:isBrowser}}function loadBabel_node(){if(global.Babel&&!global.babel&&(global.babel=global.Babel),global.babel)return global.babel;var e;try{e=require.cache[require.resolve("lively.modules")]}catch(e){}try{e=require.cache[require.resolve(__dirname+"/../")]}catch(e){}if(!e)throw new Error("Cannot find batch to babel-standalone module");var t=require("module").Module._resolveFilename("babel-standalone",e);global.window=global,global.navigator={};var r=require(t);return delete global.navigator,delete global.window,r}function urlQuery(){return"undefined"!=typeof document&&document.location?(document.location.search||"").replace(/^\?/,"").split("&").reduce(function(query,ea){var split=ea.split("="),key=split[0],value=split[1];return"true"===value||"false"===value?value=eval(value):isNaN(Number(value))||(value=Number(value)),query[key]=value,query},{}):{}}function findSystemJSPluginBabel_browser(){for(var e,t=[].slice.call(document.getElementsByTagName("script")),r=t.length-1;r>=0;r--){var n=t[r].src,i=n.indexOf("lively.modules/");if(i>-1){e=n.slice(0,i)+"lively.next-node_modules/systemjs-plugin-babel";break}var o=n.indexOf("systemjs/dist/system");if(o>-1){e=n.slice(0,o)+"systemjs-plugin-babel";break}var a=n.indexOf("core/lively/bootstrap.js");if(a>-1){e=n.slice(0,a)+"node_modules/lively.modules/node_modules/systemjs-plugin-babel";break}var s=n.match(/(.*)generated\/[^\/]+\/combinedModules.js/);if(s){e=s[1]+"node_modules/lively.modules/node_modules/systemjs-plugin-babel";break}}return e}function findSystemJSPluginBabel_node(){if(global.systemjsPluginBabel)return global.systemjsPluginBabel;for(var e=[function(){var e=require.cache[require.resolve("lively.modules")],t=require("module").Module._resolveFilename("systemjs-plugin-babel",e);if(t)return require("path").dirname(t)},function(){var e=require.resolve("systemjs-plugin-babel");if(e)return require("path").dirname(e)},function(){var e=require.resolve(require("path").join(__dirname,"systemjs-babel-node.js"));if(e)return require("path").dirname(e)}],t=0;t<e.length;t++)try{return e[t]()}catch(e){}return null}if(System.useModuleTranslationCache=!urlQuery().noModuleCache,System.get("lively.transpiler")||System.map["plugin-babel"]&&System.map["systemjs-plugin-babel"])console.log("[lively.modules] System seems already to be configured");else{var features=featureTest(),transpiler=decideAboutTranspiler(features);"lively.transpiler"===transpiler?setupLivelyTranspiler(features):"plugin-babel"===transpiler?setupPluginBabelTranspiler():console.error(`[lively.modules] could not find System transpiler for platform!`)}}(),function(){var semver;!function(e,t){function r(e,t){if(e instanceof n)return e;if("string"!=typeof e)return null;if(e.length>O)return null;if(!(t?R[K]:R[G]).test(e))return null;try{return new n(e,t)}catch(e){return null}}function n(e,t){if(e instanceof n){if(e.loose===t)return e;e=e.version}else if("string"!=typeof e)throw new TypeError("Invalid Version: "+e);if(e.length>O)throw new TypeError("version is longer than "+O+" characters");if(!(this instanceof n))return new n(e,t);F("SemVer",e,t),this.loose=t;var r=e.trim().match(t?R[K]:R[G]);if(!r)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>j||this.major<0)throw new TypeError("Invalid major version");if(this.minor>j||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>j||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map(function(e){if(/^[0-9]+$/.test(e)){var t=+e;if(t>=0&&t<j)return t}return e}):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format()}function i(e,t){var r=ge.test(e),n=ge.test(t);return r&&n&&(e=+e,t=+t),r&&!n?-1:n&&!r?1:e<t?-1:e>t?1:0}function o(e,t,r){return new n(e,r).compare(t)}function a(e,t,r){return o(t,e,r)}function s(e,t,r){return o(e,t,r)>0}function u(e,t,r){return o(e,t,r)<0}function c(e,t,r){return 0===o(e,t,r)}function l(e,t,r){return 0!==o(e,t,r)}function f(e,t,r){return o(e,t,r)>=0}function p(e,t,r){return o(e,t,r)<=0}function d(e,t,r,n){var i;switch(t){case"===":"object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),i=e===r;break;case"!==":"object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),i=e!==r;break;case"":case"=":case"==":i=c(e,r,n);break;case"!=":i=l(e,r,n);break;case">":i=s(e,r,n);break;case">=":i=f(e,r,n);break;case"<":i=u(e,r,n);break;case"<=":i=p(e,r,n);break;default:throw new TypeError("Invalid operator: "+t)}return i}function h(e,t){if(e instanceof h){if(e.loose===t)return e;e=e.value}if(!(this instanceof h))return new h(e,t);F("comparator",e,t),this.loose=t,this.parse(e),this.semver===be?this.value="":this.value=this.operator+this.semver.version,F("comp",this)}function m(e,t){if(e instanceof m&&e.loose===t)return e;if(!(this instanceof m))return new m(e,t);if(this.loose=t,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map(function(e){return this.parseRange(e.trim())},this).filter(function(e){return e.length}),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format()}function v(e,t){return F("comp",e),e=_(e,t),F("caret",e),e=g(e,t),F("tildes",e),e=w(e,t),F("xrange",e),e=E(e,t),F("stars",e),e}function y(e){return!e||"x"===e.toLowerCase()||"*"===e}function g(e,t){return e.trim().split(/\s+/).map(function(e){return b(e,t)}).join(" ")}function b(e,t){var r=t?R[ae]:R[oe];return e.replace(r,function(t,r,n,i,o){F("tilde",e,t,r,n,i,o);var a;return y(r)?a="":y(n)?a=">="+r+".0.0 <"+(+r+1)+".0.0":y(i)?a=">="+r+"."+n+".0 <"+r+"."+(+n+1)+".0":o?(F("replaceTilde pr",o),"-"!==o.charAt(0)&&(o="-"+o),a=">="+r+"."+n+"."+i+o+" <"+r+"."+(+n+1)+".0"):a=">="+r+"."+n+"."+i+" <"+r+"."+(+n+1)+".0",F("tilde return",a),a})}function _(e,t){return e.trim().split(/\s+/).map(function(e){return x(e,t)}).join(" ")}function x(e,t){F("caret",e,t);var r=t?R[le]:R[ce];return e.replace(r,function(t,r,n,i,o){F("caret",e,t,r,n,i,o);var a;return y(r)?a="":y(n)?a=">="+r+".0.0 <"+(+r+1)+".0.0":y(i)?a="0"===r?">="+r+"."+n+".0 <"+r+"."+(+n+1)+".0":">="+r+"."+n+".0 <"+(+r+1)+".0.0":o?(F("replaceCaret pr",o),"-"!==o.charAt(0)&&(o="-"+o),a="0"===r?"0"===n?">="+r+"."+n+"."+i+o+" <"+r+"."+n+"."+(+i+1):">="+r+"."+n+"."+i+o+" <"+r+"."+(+n+1)+".0":">="+r+"."+n+"."+i+o+" <"+(+r+1)+".0.0"):(F("no pr"),a="0"===r?"0"===n?">="+r+"."+n+"."+i+" <"+r+"."+n+"."+(+i+1):">="+r+"."+n+"."+i+" <"+r+"."+(+n+1)+".0":">="+r+"."+n+"."+i+" <"+(+r+1)+".0.0"),F("caret return",a),a})}function w(e,t){return F("replaceXRanges",e,t),e.split(/\s+/).map(function(e){return k(e,t)}).join(" ")}function k(e,t){e=e.trim();var r=t?R[re]:R[te];return e.replace(r,function(t,r,n,i,o,a){F("xRange",e,t,r,n,i,o,a);var s=y(n),u=s||y(i),c=u||y(o),l=c;return"="===r&&l&&(r=""),s?t=">"===r||"<"===r?"<0.0.0":"*":r&&l?(u&&(i=0),c&&(o=0),">"===r?(r=">=",u?(n=+n+1,i=0,o=0):c&&(i=+i+1,o=0)):"<="===r&&(r="<",u?n=+n+1:i=+i+1),t=r+n+"."+i+"."+o):u?t=">="+n+".0.0 <"+(+n+1)+".0.0":c&&(t=">="+n+"."+i+".0 <"+n+"."+(+i+1)+".0"),F("xRange return",t),t})}function E(e,t){return F("replaceStars",e,t),e.trim().replace(R[ve],"")}function S(e,t,r,n,i,o,a,s,u,c,l,f,p){return t=y(r)?"":y(n)?">="+r+".0.0":y(i)?">="+r+"."+n+".0":">="+t,s=y(u)?"":y(c)?"<"+(+u+1)+".0.0":y(l)?"<"+u+"."+(+c+1)+".0":f?"<="+u+"."+c+"."+l+"-"+f:"<="+s,(t+" "+s).trim()}function A(e,t){for(r=0;r<e.length;r++)if(!e[r].test(t))return!1;if(t.prerelease.length){for(var r=0;r<e.length;r++)if(F(e[r].semver),e[r].semver!==be&&e[r].semver.prerelease.length>0){var n=e[r].semver;if(n.major===t.major&&n.minor===t.minor&&n.patch===t.patch)return!0}return!1}return!0}function D(e,t,r){try{t=new m(t,r)}catch(e){return!1}return t.test(e)}function C(e,t,r,i){e=new n(e,i),t=new m(t,i);var o,a,c,l,d;switch(r){case">":o=s,a=p,c=u,l=">",d=">=";break;case"<":o=u,a=f,c=s,l="<",d="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(D(e,t,i))return!1;for(var v=0;v<t.set.length;++v){var y=null,g=null;if(t.set[v].forEach(function(e){e.semver===be&&(e=new h(">=0.0.0")),y=y||e,g=g||e,o(e.semver,y.semver,i)?y=e:c(e.semver,g.semver,i)&&(g=e)}),y.operator===l||y.operator===d)return!1;if((!g.operator||g.operator===l)&&a(e,g.semver))return!1;if(g.operator===d&&c(e,g.semver))return!1}return!0}e={}.exports=n;var F;F="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e)}:function(){},e.SEMVER_SPEC_VERSION="2.0.0";var O=256,j=Number.MAX_SAFE_INTEGER||9007199254740991,R=e.re=[],B=e.src=[],P=0,T=P++;B[T]="0|[1-9]\\d*";var I=P++;B[I]="[0-9]+";var L=P++;B[L]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";var N=P++;B[N]="("+B[T]+")\\.("+B[T]+")\\.("+B[T]+")";var M=P++;B[M]="("+B[I]+")\\.("+B[I]+")\\.("+B[I]+")";var q=P++;B[q]="(?:"+B[T]+"|"+B[L]+")";var $=P++;B[$]="(?:"+B[I]+"|"+B[L]+")";var W=P++;B[W]="(?:-("+B[q]+"(?:\\."+B[q]+")*))";var U=P++;B[U]="(?:-?("+B[$]+"(?:\\."+B[$]+")*))";var z=P++;B[z]="[0-9A-Za-z-]+";var V=P++;B[V]="(?:\\+("+B[z]+"(?:\\."+B[z]+")*))";var G=P++,H="v?"+B[N]+B[W]+"?"+B[V]+"?";B[G]="^"+H+"$";var J="[v=\\s]*"+B[M]+B[U]+"?"+B[V]+"?",K=P++;B[K]="^"+J+"$";var Q=P++;B[Q]="((?:<|>)?=?)";var Y=P++;B[Y]=B[I]+"|x|X|\\*";var X=P++;B[X]=B[T]+"|x|X|\\*";var Z=P++;B[Z]="[v=\\s]*("+B[X]+")(?:\\.("+B[X]+")(?:\\.("+B[X]+")(?:"+B[W]+")?"+B[V]+"?)?)?";var ee=P++;B[ee]="[v=\\s]*("+B[Y]+")(?:\\.("+B[Y]+")(?:\\.("+B[Y]+")(?:"+B[U]+")?"+B[V]+"?)?)?";var te=P++;B[te]="^"+B[Q]+"\\s*"+B[Z]+"$";var re=P++;B[re]="^"+B[Q]+"\\s*"+B[ee]+"$";var ne=P++;B[ne]="(?:~>?)";var ie=P++;B[ie]="(\\s*)"+B[ne]+"\\s+",R[ie]=new RegExp(B[ie],"g");var oe=P++;B[oe]="^"+B[ne]+B[Z]+"$";var ae=P++;B[ae]="^"+B[ne]+B[ee]+"$";var se=P++;B[se]="(?:\\^)";var ue=P++;B[ue]="(\\s*)"+B[se]+"\\s+",R[ue]=new RegExp(B[ue],"g");var ce=P++;B[ce]="^"+B[se]+B[Z]+"$";var le=P++;B[le]="^"+B[se]+B[ee]+"$";var fe=P++;B[fe]="^"+B[Q]+"\\s*("+J+")$|^$";var pe=P++;B[pe]="^"+B[Q]+"\\s*("+H+")$|^$";var de=P++;B[de]="(\\s*)"+B[Q]+"\\s*("+J+"|"+B[Z]+")",R[de]=new RegExp(B[de],"g");var he=P++;B[he]="^\\s*("+B[Z]+")\\s+-\\s+("+B[Z]+")\\s*$";var me=P++;B[me]="^\\s*("+B[ee]+")\\s+-\\s+("+B[ee]+")\\s*$";var ve=P++;B[ve]="(<|>)?=?\\s*\\*";for(var ye=0;ye<P;ye++)F(ye,B[ye]),R[ye]||(R[ye]=new RegExp(B[ye]));e.parse=r,e.valid=function(e,t){var n=r(e,t);return n?n.version:null},e.clean=function(e,t){var n=r(e.trim().replace(/^[=v]+/,""),t);return n?n.version:null},e.SemVer=n,n.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},n.prototype.toString=function(){return this.version},n.prototype.compare=function(e){return F("SemVer.compare",this.version,this.loose,e),e instanceof n||(e=new n(e,this.loose)),this.compareMain(e)||this.comparePre(e)},n.prototype.compareMain=function(e){return e instanceof n||(e=new n(e,this.loose)),i(this.major,e.major)||i(this.minor,e.minor)||i(this.patch,e.patch)},n.prototype.comparePre=function(e){if(e instanceof n||(e=new n(e,this.loose)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var t=0;do{var r=this.prerelease[t],o=e.prerelease[t];if(F("prerelease compare",t,r,o),void 0===r&&void 0===o)return 0;if(void 0===o)return 1;if(void 0===r)return-1;if(r!==o)return i(r,o)}while(++t)},n.prototype.inc=function(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t),this.inc("pre",t);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else{for(var r=this.prerelease.length;--r>=0;)"number"==typeof this.prerelease[r]&&(this.prerelease[r]++,r=-2);-1===r&&this.prerelease.push(0)}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this},e.inc=function(e,t,r,i){"string"==typeof r&&(i=r,r=void 0);try{return new n(e,r).inc(t,i).version}catch(e){return null}},e.diff=function(e,t){if(c(e,t))return null;var n=r(e),i=r(t);if(n.prerelease.length||i.prerelease.length){for(var o in n)if(("major"===o||"minor"===o||"patch"===o)&&n[o]!==i[o])return"pre"+o;return"prerelease"}for(var o in n)if(("major"===o||"minor"===o||"patch"===o)&&n[o]!==i[o])return o},e.compareIdentifiers=i;var ge=/^[0-9]+$/;e.rcompareIdentifiers=function(e,t){return i(t,e)},e.major=function(e,t){return new n(e,t).major},e.minor=function(e,t){return new n(e,t).minor},e.patch=function(e,t){return new n(e,t).patch},e.compare=o,e.compareLoose=function(e,t){return o(e,t,!0)},e.rcompare=a,e.sort=function(t,r){return t.sort(function(t,n){return e.compare(t,n,r)})},e.rsort=function(t,r){return t.sort(function(t,n){return e.rcompare(t,n,r)})},e.gt=s,e.lt=u,e.eq=c,e.neq=l,e.gte=f,e.lte=p,e.cmp=d,e.Comparator=h;var be={};h.prototype.parse=function(e){var t=this.loose?R[fe]:R[pe],r=e.match(t);if(!r)throw new TypeError("Invalid comparator: "+e);this.operator=r[1],"="===this.operator&&(this.operator=""),r[2]?this.semver=new n(r[2],this.loose):this.semver=be},h.prototype.toString=function(){return this.value},h.prototype.test=function(e){return F("Comparator.test",e,this.loose),this.semver===be||("string"==typeof e&&(e=new n(e,this.loose)),d(e,this.operator,this.semver,this.loose))},e.Range=m,m.prototype.format=function(){return this.range=this.set.map(function(e){return e.join(" ").trim()}).join("||").trim(),this.range},m.prototype.toString=function(){return this.range},m.prototype.parseRange=function(e){var t=this.loose;e=e.trim(),F("range",e,t);var r=t?R[me]:R[he];e=e.replace(r,S),F("hyphen replace",e),e=e.replace(R[de],"$1$2$3"),F("comparator trim",e,R[de]),e=(e=(e=e.replace(R[ie],"$1~")).replace(R[ue],"$1^")).split(/\s+/).join(" ");var n=t?R[fe]:R[pe],i=e.split(" ").map(function(e){return v(e,t)}).join(" ").split(/\s+/);return this.loose&&(i=i.filter(function(e){return!!e.match(n)})),i=i.map(function(e){return new h(e,t)})},e.toComparators=function(e,t){return new m(e,t).set.map(function(e){return e.map(function(e){return e.value}).join(" ").trim().split(" ")})},m.prototype.test=function(e){if(!e)return!1;"string"==typeof e&&(e=new n(e,this.loose));for(var t=0;t<this.set.length;t++)if(A(this.set[t],e))return!0;return!1},e.satisfies=D,e.maxSatisfying=function(e,t,r){return e.filter(function(e){return D(e,t,r)}).sort(function(e,t){return a(e,t,r)})[0]||null},e.minSatisfying=function(e,t,r){return e.filter(function(e){return D(e,t,r)}).sort(function(e,t){return o(e,t,r)})[0]||null},e.validRange=function(e,t){try{return new m(e,t).range||"*"}catch(e){return null}},e.ltr=function(e,t,r){return C(e,t,"<",r)},e.gtr=function(e,t,r){return C(e,t,">",r)},e.outside=C,e.prerelease=function(e,t){var n=r(e,t);return n&&n.prerelease.length?n.prerelease:null},semver=e}({});var GLOBAL="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this;this.lively=this.lively||{},function(exports,lively_lang,lively_ast,lively_notifications,lively_vm,lively_resources,lively_classes,semver){"use strict";function install(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:r.name;(e[t]=lively_lang.fun.wrap(e[t],r)).hookFunc=r,r.hookName=n}function remove$1(e,t,r){for(var n=[],i=e[t];i;)n.push(i),i=i.originalFunction;var o="string"==typeof r?n.find(function(e){return e.hookFunc&&e.hookFunc.hookName===r}):n.find(function(e){return e.hookFunc===r});return!!o&&(lively_lang.arr.remove(n,o),e[t]=n.reduceRight(function(e,t){return lively_lang.fun.wrap(e,t.hookFunc||t)}),!0)}function isInstalled(e,t,r){for(var n=e[t];n;){if(n.hookFunc){if("string"==typeof r&&n.hookFunc.hookName===r)return!0;if(n.hookFunc===r)return!0}n=n.originalFunction}return!1}function computeRequireMap(e){if(e.loads){var t=e.loads;return lively_lang.arr.uniq(Object.keys(loadedModules$1(e)).concat(Object.keys(t))).reduce(function(e,r){var n=t[r]?t[r].depMap:{};return e[r]=Object.keys(n).map(function(e){var t=n[e];return"@empty"===t?t+"/"+e:t}),e},{})}return Object.keys(e._loader.moduleRecords).reduce(function(t,r){return t[r]=e._loader.moduleRecords[r].dependencies.filter(Boolean).map(function(e){return e.name}),t},{})}function prepareNodejsCaching(){var e=System._nodeRequire("fs"),t=System._nodeRequire("path");nodejsCacheDir="/"===process.cwd()?t.join(process.env.HOME,".lively.next"):process.cwd(),e.existsSync(nodejsCacheDir)||e.mkdirSync(nodejsCacheDir)}function prepareCodeForCustomCompile(e,t,r,n,i){t=String(t);var o=n.sourceAccessorName,a=n.recorder,s=n.recorderName,u=n.dontTransform,c=n.varDefinitionCallbackName,l=n.embedOriginalCode,f=void 0===l||l,p={topLevelVarRecorder:a,varRecorderName:s,sourceAccessorName:o=f?o:void 0,dontTransform:u,recordGlobals:!0,keepPreviouslyDeclaredValues:!0,declarationWrapperName:c,evalId:n.nextEvalId(),currentModuleAccessor:funcCall(member(funcCall(member(member("__lvVarRecorder","System"),"get"),literal("@lively-env")),"moduleEnv"),literal(r))},d="System.global"===s,h=i?'console.log("[lively.modules] executing module '+r+'");\n':"",m="";d?delete p.declarationWrapperName:(h+='System.get("@lively-env").evaluationStart("'+r+'");\nvar '+s+' = System.get("@lively-env").moduleEnv("'+r+'").recorder;\n'+(f?"\nvar "+o+" = "+JSON.stringify(t)+";\n":""),m+='\nSystem.get("@lively-env").evaluationEnd("'+r+'");');try{var v=h+lively_vm.evalCodeTransform(t,p)+m;return i&&"undefined"!=typeof $world&&$world.get("log")&&$world.get("log").isText&&($world.get("log").textString=v),{source:v,options:p}}catch(e){return console.error("Error in prepareCodeForCustomCompile of "+r+" "+e.stack),{source:t,options:p}}}function prepareTranslatedCodeForSetterCapture(e,t,r,n,i,o){t=String(t);var a=_extends({},i,{topLevelVarRecorder:n.recorder,varRecorderName:n.recorderName,dontTransform:n.dontTransform,recordGlobals:!0,declarationWrapperName:n.varDefinitionCallbackName,currentModuleAccessor:funcCall(member(funcCall(member(member("__lvVarRecorder","System"),"get"),literal("@lively-env")),"moduleEnv"),literal(r))});n.recorderName;try{var s=lively_vm.evalCodeTransformOfSystemRegisterSetters(t,a);return o&&"undefined"!=typeof $world&&$world.get("log")&&$world.get("log").isText&&($world.get("log").textString+=s),s}catch(e){return console.error("Error in prepareTranslatedCodeForSetterCapture",e.stack),t}}function getCachedNodejsModule(e,t){try{var r=e._nodeRequire("module").Module,n=r._resolveFilename(t.name.replace(/^file:\/\//,""));return r._cache[n]}catch(r){e.debug&&console.log("[lively.modules getCachedNodejsModule] %s unknown to nodejs",t.name)}return null}function addNodejsWrapperSource(e,t){var r=getCachedNodejsModule(e,t);return r?(t.metadata.format="esm",t.source="var exports = System._nodeRequire('"+r.id+"'); export default exports;\n"+lively_lang.properties.allOwnPropertiesOrFunctions(r.exports).map(function(e){return lively_ast.isValidIdentifier(e)?"export var "+e+" = exports['"+e+"'];":'/*ignoring export "'+e+'" b/c it is not a valid identifier*/'}).join("\n"),e.debug&&console.log("[lively.modules customTranslate] loading %s from nodejs module cache",t.name),!0):(e.debug&&console.log("[lively.modules customTranslate] %s not yet in nodejs module cache",t.name),!1)}function instrumentSourceOfEsmModuleLoad(System,load){return System.translate(load).then(function(translated){var parsed=lively_ast.parse(translated),callExpression=parsed.body.find(function(e){return e.expression&&"CallExpression"===e.expression.type&&"register"===e.expression.callee.property.name});if(!callExpression)throw new Error("Cannot find register call in translated source of "+load.name);var registerCall=callExpression.expression,depNames=registerCall.arguments[0].elements.map(function(e){return e.value}),declareFuncNode=registerCall.arguments[1],declareFuncSource=translated.slice(declareFuncNode.start,declareFuncNode.end),declare=eval('var __moduleName = "'+load.name+'";('+declareFuncSource+");\n//# sourceURL="+load.name+"\n");return System.debug&&"undefined"!==$world&&$world.get("log")&&$world.get("log").isText&&($world.get("log").textString=declare),{localDeps:depNames,declare:declare}})}function instrumentSourceOfGlobalModuleLoad(e,t){return e.translate(t).then(function(e){return{translated:e}})}function wrapModuleLoad$1(e){isInstalled(e,"translate","lively_modules_translate_hook")||install(e,"translate",function(t,r){return customTranslate.call(e,t,r)})}function unwrapModuleLoad$1(e){remove$1(e,"translate","lively_modules_translate_hook")}function scheduleModuleExportsChange(e,t,r,n,i){var o=e.get("@lively-env").pendingExportChanges,a=module$2(e,t).record();a&&(r in a.exports||i)&&((o[t]||(o[t]={}))[r]=n)}function runScheduledExportChanges(e,t){var r=e.get("@lively-env").pendingExportChanges[t];r&&(clearPendingModuleExportChanges(e,t),updateModuleExports(e,t,r))}function clearPendingModuleExportChanges(e,t){delete e.get("@lively-env").pendingExportChanges[t]}function updateModuleExports(e,t,r){var n=e.debug;module$2(e,t).updateRecord(function(i){var o=[],a=[];if(Object.keys(r).forEach(function(e){var s=r[e];n&&console.log("[lively.vm es6 updateModuleExports] %s export %s = %s",t,e,String(s).slice(0,30).replace(/\n/g,"")+"...");var u=!(e in i.exports);u&&(i.__lively_modules__.evalOnlyExport[e]=!0),i.exports[e]=s,u?o.push(e):a.push(e)}),o.length){var s=e.get(t);Object.isFrozen(s)?(console.warn("[lively.vm es6 updateModuleExports] Since module %s is frozen a new module object was installed in the system. Note that only(!) exisiting module bindings are updated. New exports that were added will only be available in already loaded modules after those are reloaded!",t),e.set(t,e.newModule(i.exports))):(n&&console.log("[lively.vm es6 updateModuleExports] adding new exports to %s",t),o.forEach(function(e){Object.defineProperty(s,e,{configurable:!1,enumerable:!0,get:function(){return i.exports[e]},set:function(){throw new Error("exports cannot be changed from the outside")}})}))}if(a.length){n&&console.log("[lively.vm es6 updateModuleExports] updating %s dependents of %s",i.importers.length,t);for(var u=0,c=i.importers.length;u<c;u++){var l=i.importers[u];if(!l.locked){var f;if(l.dependencies.some(function(e,t){return f=t,e&&e.name===i.name})){if(n){var p=module$2(e,l.name);console.log("[lively.vm es6 updateModuleExports] calling setters of "+p.package().name+"/"+p.pathInPackage())}module$2(e,l.name).evaluationStart(),l.setters[f](i.exports),module$2(e,l.name).evaluationEnd()}}}}})}function doInstantiateGlobalModule(e,t){var r={name:null,deps:null,originalIndices:null,declare:null,execute:null,executingRequire:!1,declarative:!1,normalizedDeps:null,groupIndex:null,evaluated:!1,module:null,esModule:null,esmExports:!1};r.name=t.name,r.esmExports=!0,t.metadata.entry=r,r.deps=[];for(var n in t.metadata.globals){var i=t.metadata.globals[n];i&&r.deps.push(i)}return r.execute=function(r,n,i){var o=module$2(e,i.id).metadata();(n=o&&o.entry&&o.entry.module&&o.entry.module.exports)&&Object.keys(n).forEach(function(t){try{delete e.global[t]}catch(e){console.warn('[lively.modules] executeGlobalModule: Cannot delete global["'+t+'"]')}});var a;if(t.metadata.globals){a={};for(var s in t.metadata.globals)t.metadata.globals[s]&&(a[s]=r(t.metadata.globals[s]))}var u=t.metadata.exports;u&&(t.source+='\nSystem.global["'+u+'"] = '+u+";");var c=e.get("@@global-helpers").prepareGlobal(module$2.id,u,a);return __evaluateGlobalLoadSource(e,t),c()},runExecuteOfGlobalModule(e,r)}function __createEntry(){return{name:null,deps:null,originalIndices:null,declare:null,execute:null,executingRequire:!1,declarative:!1,normalizedDeps:null,groupIndex:null,evaluated:!1,module:null,esModule:null,esmExports:!1}}function __evaluateGlobalLoadSource(e,t){function r(e,t){0==a++&&(o=s.System),s.System=s.SystemJS=e}function n(){0==--a&&(s.System=s.SystemJS=o),i=void 0}var i,o,a=0,s=e.global;return function(e){try{r(this,e),i=e,(0,eval)(e.source),n()}catch(t){throw n(),new Error("Error evaluating "+e.address+":\n"+t.stack)}}.call(e,t)}function runExecuteOfGlobalModule(e,t){var r={},n=t.module={exports:r,id:t.name};t.evaluated=!0;var i=t.execute.call(e.global,function(r){var n=t.deps.find(function(e){return e===r}),i=n&&e.get(t.normalizedDeps[t.deps.indexOf(n)])||e.get(e.decanonicalize(r,t.name));if(i)return i;throw new Error("Module "+r+" not declared as a dependency of "+t.name)},r,n);i&&(n.exports=i),r=n.exports;var o=e.get("@system-env").constructor;return r&&(r.__esModule||r instanceof o)?t.esModule=r:t.esmExports&&r!==e.global?t.esModule=e.newModule(r):t.esModule={default:r},t}function isURL(e){return/^[^:\\]+:\/\//.test(e)}function urlResolve(e){var t=e.match(/^([^:]+:\/\/)(.*)/);if(!t)return e;var r=t[1],n=t[2],i=n;do{i=(n=i).replace(/\/[^\/]+\/\.\./,"")}while(i!=n);return i=i.replace(/(^|[^:])[\/]+/g,"$1/"),i=i.replace(/\/\.\//g,"/"),r+i}function isAbsolute(e){return e.startsWith("/")||e.startsWith("http:")||e.startsWith("https:")||e.startsWith("file:")||e.match(urlStartRe)}function ensureResource(e){return e.isResource?e:lively_resources.resource(e)}function normalizePackageURL(e,t){if((arguments.length>2&&void 0!==arguments[2]?arguments[2]:[]).some(function(e){return e===t}))return t;var r=e.decanonicalize(t.replace(/[\/]+$/,"")+"/");if(!isURL(r))throw new Error("Strange package URL: "+r+" is not a valid URL");return(r=r.match(/\.js/)?r.indexOf(r+".js")>-1?r.replace(/\.js$/,""):r.split("/").slice(0,-1).join("/"):r).match(/\.js$/)&&console.warn("packageURL is expected to point to a directory but seems to be a .js file: "+r),String(r).replace(/\/$/,"")}function lookupPackage$1(e,t){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=PackageRegistry$$1.ofSystem(e),i=n.allPackageURLs(),o=r?t:normalizePackageURL(e,t,i);return{pkg:n.findPackageWithURL(o),url:o,allPackageURLs:i,registry:n}}function ensurePackage$1(e,t){var r=lookupPackage$1(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2]),n=r.pkg,i=r.url,o=r.registry;return n||o.addPackageAt(i,"devPackageDirs")}function getPackage$1(e,t){var r=lookupPackage$1(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2]),n=r.pkg,i=r.url;if(n)return n;throw new Error("[getPackage] package "+t+" (as "+i+") not found")}function applyConfig$1(e,t,r){return getPackage$1(e,r).updateConfig(t)}function importPackage$1(e,t){return Promise.resolve(ensurePackage$1(e,t)).then(function(e){return e.import()})}function removePackage$2(e,t){var r=lookupPackage$1(e,t),n=r.pkg;r.url,r.registry;return n?n.remove():null}function reloadPackage$1(e,t,r){return getPackage$1(e,t).reload(r)}function registerPackage$1(e,t,r){return Promise.resolve(ensurePackage$1(e,t)).then(function(e){return e.register(r)})}function getPackageSpecs(e){return Package.allPackages(e).map(function(e){return e.asSpec()})}function ensureParent(e,t,r){if(r)return r;var n=e.id,i=e.System,o=n.startsWith("file://")?n.replace("file://",""):n;if(r=i._nodeRequire("module").Module._cache[n])return r;r={id:o,filename:o,paths:[]};var a=e.package();return a&&r.paths.push(lively_resources.resource(a.url).join("node_modules/").path()),r}function relative(e,t){return lively_resources.resource(e.id).parent().join(t).url.replace("file://","")}function _require(e,t,r){r=ensureParent(e,t);var n=e.System._nodeRequire("module");return t.startsWith(".")&&(t=relative(e,t)),n._load(t,r)}function _resolve(e,t,r){r=ensureParent(e,t);var n=e.System._nodeRequire("module");return t.startsWith(".")&&(t=relative(e,t)),n._resolveFilename(t,r)}function module$2(e,t,r){var n=livelySystemEnv(e),i=e.decanonicalize(t,r);return n.loadedModules[i]||(n.loadedModules[i]=new ModuleInterface(e,i))}function isModuleLoaded$1(e,t){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=livelySystemEnv(e);return(r?t:e.normalizeSync(t))in n.loadedModules}function livelyProtocol(e,t){var r=t.match(livelyURLRe);if(!r)return e(t);var n=slicedToArray(r,3),i=(n[0],n[1],n[2]);return{read:function(){var e="undefined"!=typeof $world&&$world.getMorphWithId(i);return Promise.resolve(e?e.textString:"/*Could not locate "+i+"*/")},write:function(e){var t="undefined"!=typeof $world&&$world.getMorphWithId(i);return t?(t.textString=e,Promise.resolve(this)):Promise.reject("Could not save morph "+i)}}}function wrapResource(e){e.resource=lively_resources.resource,isInstalled(e,"fetch",fetchResource)&&remove$1(e,"fetch","fetchResource"),install(e,"fetch",fetchResource),isInstalled(e,"resource","livelyProtocol")&&remove$1(e,"fetch","livelyProtocol"),install(e,"resource",livelyProtocol)}function livelySystemEnv(e){return{moduleEnv:function(t){return module$2(e,t)},get itself(){return e.get(e.decanonicalize("lively.modules/index.js"))},evaluationStart:function(t){module$2(e,t).evaluationStart()},evaluationEnd:function(t){module$2(e,t).evaluationEnd()},dumpConfig:function(){return JSON.stringify({baseURL:e.baseURL,transpiler:e.transpiler,defaultJSExtensions:e.defaultJSExtensions,map:e.map,meta:e.meta,packages:e.packages,paths:e.paths,packageConfigPaths:e.packageConfigPaths},null,2)},get packageRegistry(){return e["__lively.modules__packageRegistry"]},set packageRegistry(t){e["__lively.modules__packageRegistry"]=t},packages:e["__lively.modules__packages"]||(e["__lively.modules__packages"]={}),loadedModules:e["__lively.modules__loadedModules"]||(e["__lively.modules__loadedModules"]={}),pendingExportChanges:e["__lively.modules__pendingExportChanges"]||(e["__lively.modules__pendingExportChanges"]={}),notifications:e["__lively.modules__notifications"]||(e["__lively.modules__notifications"]=[]),notificationSubscribers:e["__lively.modules__notificationSubscribers"]||(e["__lively.modules__notificationSubscribers"]={}),options:e["__lively.modules__options"]||(e["__lively.modules__options"]=lively_lang.obj.deepCopy(defaultOptions)),onLoadCallbacks:e["__lively.modules__onLoadCallbacks"]||(e["__lively.modules__onLoadCallbacks"]=[]),modulePackageMapCache:e["__lively.modules__modulePackageMapCache"]}}function systems(){return SystemClass.systems}function nameOfSystem(e){return Object.keys(systems()).detect(function(t){return systems()[t]===e})}function getSystem(e,t){return e&&"string"!=typeof e?e:systems()[e]||(systems()[e]=makeSystem(t))}function removeSystem(e){var t=e&&"string"!=typeof e?nameOfSystem(e):e;delete systems()[t]}function makeSystem(e){return prepareSystem(new SystemClass,e)}function prepareSystem(e,t){e.trace=!0;var r=(t=t||{}).hasOwnProperty("useModuleTranslationCache")?t.useModuleTranslationCache:!urlQuery().noModuleCache;e.useModuleTranslationCache=r,e.set("@lively-env",e.newModule(livelySystemEnv(e))),"undefined"!=typeof WorkerGlobalScope&&e.set("@system-env",e.newModule(_extends({},e.get("@system-env"),{browser:!0,worker:!0})));var n="undefined"!=typeof process&&process.versions&&process.versions.electron;if(n&&e.set("@system-env",e.newModule(_extends({electron:n},e.get("@system-env")))),wrapResource(e),wrapModuleLoad$1(e),isInstalled(e,"normalizeHook")||install(e,"normalize",normalizeHook),isInstalled(e,"decanonicalize","decanonicalizeHook")||install(e,"decanonicalize",decanonicalizeHook),isInstalled(e,"normalizeSync","decanonicalizeHook")||install(e,"normalizeSync",decanonicalizeHook),isInstalled(e,"newModule","newModule_volatile")||install(e,"newModule",newModule_volatile),isInstalled(e,"instantiate","instantiate_triggerOnLoadCallbacks")||install(e,"instantiate",instantiate_triggerOnLoadCallbacks),n){i=["electron"].reduce(function(e,t){return e[t]="@node/"+t,e},{});t.map=lively_lang.obj.merge(i,t.map)}if(isNode){var i=["addons","assert","buffer","child_process","cluster","console","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","punycode","querystring","readline","repl","stream","stringdecoder","timers","tls","tty","url","util","v8","vm","zlib"].reduce(function(e,t){return e[t]="@node/"+t,e},{});t.map=lively_lang.obj.merge(i,t.map)}return t.packageConfigPaths=t.packageConfigPaths||["./node_modules/*/package.json"],t.transpiler||"traceur"!==e.transpiler||("lively.transpiler"===initialSystem.transpiler?(e.set("lively.transpiler",initialSystem.get("lively.transpiler")),e._loader.transpilerPromise=initialSystem._loader.transpilerPromise,e.config({transpiler:"lively.transpiler",babelOptions:Object.assign(initialSystem.babelOptions||{},t.babelOptions)})):e.config({map:{"plugin-babel":initialSystem.map["plugin-babel"],"systemjs-babel-build":initialSystem.map["systemjs-babel-build"]},transpiler:initialSystem.transpiler,babelOptions:Object.assign(initialSystem.babelOptions||{},t.babelOptions)})),e.config(t),e}function urlQuery(){return"undefined"!=typeof document&&document.location?(document.location.search||"").replace(/^\?/,"").split("&").reduce(function(query$$1,ea){var split=ea.split("="),key=split[0],value=split[1];return"true"===value||"false"===value?value=eval(value):isNaN(Number(value))||(value=Number(value)),query$$1[key]=value,query$$1},{}):{}}function preNormalize(e,t,r){".."===t&&(t="../index.js"),t=t.replace(doubleSlashRe,function(e){return":"===e[0]?e:e[0]+"/"});var n=e.get("@lively-env").packageRegistry;if(n){var i=r&&n.findPackageHavingURL(r);if(i){var o=i.map,a=i.url,s=o&&o[t]||e.map[t];s&&("object"===(void 0===s?"undefined":_typeof(s))&&(s=normalize_doMapWithObject(s,i,e)),"string"==typeof s&&""!==s&&(t=s),t.startsWith(".")&&(t=urlResolve(join(a,t))))}}if(n){var u=n.resolvePath(t,r);u&&(u.endsWith("/")&&!t.endsWith("/")&&(u=u.slice(0,-1)),!u.endsWith("/")&&t.endsWith("/")&&(u+="/"),t=u)}return t}function postNormalize(e,t,r){var n=t.replace(jsExtRe,"");if(t.endsWith("/"))return t;var i=e.get("@lively-env").packageRegistry;if(i){var o=i.findPackageWithURL(n);if(o){var a=(o.main||"index.js").replace(dotSlashStartRe,"");return s=n.replace(trailingSlashRe,"")+"/"+a}}else if(n in e.packages&&(a=e.packages[n].main)){var s=n.replace(trailingSlashRe,"")+"/"+a.replace(dotSlashStartRe,"");return s}var u=t.match(jsonJsExtRe);return u?u[1]:t}function normalizeHook(e,t,r,n){var i=this,o=preNormalize(i,t,r);return e(o,r,n).then(function(e){var r=postNormalize(i,e||o,!1);return i.debug&&console.log("[normalize] "+t+" => "+r),r})}function decanonicalizeHook(e,t,r,n){var i=this,o=postNormalize(i,e(preNormalize(i,t,r),r,n),!0);return i.debug&&console.log("[normalizeSync] "+t+" => "+o),o}function normalize_doMapWithObject(e,t,r){var n,i=r.get(t.map["@env"]||"@system-env");for(var o in e){var a="~"==o[0],s=function(e,t){for(var r=e.split(".");r.length;)t=t[r.shift()];return t}(a?o.substr(1):o,i);if(!a&&s||a&&!s){n=e[o];break}}if(n&&"string"!=typeof n)throw new Error("Unable to map a package conditional to a package conditional.");return n}function newModule_volatile(e,t){var r=Object.freeze;Object.freeze=function(e){return e};var n=e(t);return Object.freeze=r,n}function printSystemConfig$1(e){var t={baseURL:(e=getSystem(e)).baseURL,transpiler:e.transpiler,defaultJSExtensions:e.defaultJSExtensions,defaultExtension:e.defaultExtension,map:e.map,meta:e.meta,packages:e.packages,paths:e.paths,packageConfigPaths:e.packageConfigPaths,bundles:e.bundles};return JSON.stringify(t,null,2)}function instantiate_triggerOnLoadCallbacks(e,t){var r=this;return e(t).then(function(e){var n={};return lively_lang.promise.waitFor(6e4,function(){return r.get(t.name)},n).then(function(e){if(e!==n){for(var i=t.name,o=module$2(r,i),a=r.get("@lively-env").onLoadCallbacks,s=a.length;s--;){var u=a[s],c=u.moduleName,l=u.resolved,f=u.callback;if((l?c:r.decanonicalize(c))===i){a.splice(s,1);try{f(o)}catch(e){console.error(e)}}}lively_notifications.emit("lively.modules/moduleloaded",{module:t.name},Date.now(),r)}else console.warn("[lively.modules] instantiate_triggerOnLoadCallbacks for "+t.name+" timed out")}),e})}function whenLoaded$2(e,t,r){var n=e.decanonicalize(t);if(e.get(n))try{r(module$2(e,n))}catch(e){console.error(e)}else e.get("@lively-env").onLoadCallbacks.push({moduleName:t,resolved:!1,callback:r})}function loadedModules$1(e){return e.get("@lively-env").loadedModules}function knownModuleNames(e){var t=e.loads?Object.keys(e.loads):Object.keys(e._loader.moduleRecords);return lively_lang.arr.uniq(t.concat(Object.keys(loadedModules$1(e))))}function resolvePackageDependencies(e,t){var r=_extends({},e.dependencies,e.devDependencies);return Object.keys(r).reduce(function(e,n){var i=r[n],o=lively_lang.obj.values(t).find(function(e){var t=e.name,r=e.version;return t===n&&lively.modules.semver.satisfies(r,i)})||{},a=o.name,s=o.version;return e[n]=a?a+"@"+s:void 0,e},{})}function dependencyGraph(e){function t(e,t){var i=e+"@"+t;if(i in n)return n[i];var o=r.find(function(r){var n=r.name,i=r.version;return n===e&&lively.modules.semver.satisfies(i,t)})||{},a=o.name,s=o.version;return n[i]=a?a+"@"+s:void 0}var r=lively_lang.obj.values(e),n={};return Object.keys(e).reduce(function(r,n){var i=e[n],o=_extends({},i.dependencies,i.devDependencies);return r[n]=Object.keys(o).map(function(e){return t(e,o[e])}).filter(function(e){return!!e}),r},{})}function changeSystem(e,t){return exports.System=e,t&&(GLOBAL.System=e),e}function loadedModules$$1(){return Object.keys(requireMap())}function module$1(e){return module$2(exports.System,e)}function isModuleLoaded$$1(e,t){return isModuleLoaded$1(exports.System,e,t)}function doesModuleExist$$1(e,t){return doesModuleExist$1(exports.System,e,t)}function printSystemConfig$$1(){return printSystemConfig$1(exports.System)}function whenLoaded$1(e,t){return whenLoaded$2(exports.System,e,t)}function importPackage$$1(e){return importPackage$1(exports.System,e)}function registerPackage$$1(e,t){return registerPackage$1(exports.System,e,t)}function removePackage$1(e){return removePackage$2(exports.System,e)}function reloadPackage$$1(e,t){return reloadPackage$1(exports.System,e,t)}function getPackages(){return getPackageSpecs(exports.System)}function getPackage$$1(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return getPackage$1(exports.System,e,t)}function getPackageOfModule(e){return Package.forModuleId(exports.System,e)}function ensurePackage$$1(e){return ensurePackage$1(exports.System,e)}function applyPackageConfig(e,t){return applyConfig$1(exports.System,e,t)}function lookupPackage$$1(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return lookupPackage$1(exports.System,e,t)}function moduleSourceChange$$1(e,t,r){return moduleSourceChange$1(exports.System,e,t,r)}function requireMap(){return computeRequireMap(exports.System)}function isHookInstalled(e,t){return isInstalled(exports.System,e,t)}function installHook(e,t){return install(exports.System,e,t)}function removeHook(e,t){return remove$1(exports.System,e,t)}function wrapModuleLoad$$1(){wrapModuleLoad$1(exports.System)}function unwrapModuleLoad$$1(){unwrapModuleLoad$1(exports.System)}semver="default"in semver?semver.default:semver;var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},asyncToGenerator=function(e){return function(){var t=e.apply(this,arguments);return new Promise(function(e,r){function n(i,o){try{var a=t[i](o),s=a.value}catch(e){return void r(e)}if(!a.done)return Promise.resolve(s).then(function(e){n("next",e)},function(e){n("throw",e)});e(s)}return n("next")})}},classCallCheck=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),defineProperty=function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e},_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},get$1=function e(t,r,n){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,r);if(void 0===i){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,r,n)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(n)},inherits=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},possibleConstructorReturn=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},set$1=function e(t,r,n,i){var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var a=Object.getPrototypeOf(t);null!==a&&e(a,r,n,i)}else if("value"in o&&o.writable)o.value=n;else{var s=o.set;void 0!==s&&s.call(i,n)}return n},slicedToArray=function(){function e(e,t){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{!n&&s.return&&s.return()}finally{if(i)throw o}}return r}return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),customTranslate=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w,k=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n=this,i=n.debug,o=r.metadata,!(a=o&&o.hasOwnProperty("instrument")&&!o.instrument||exceptions.some(function(e){return e(r.name)}))){e.next=4;break}return i&&console.log("[lively.modules customTranslate ignoring] %s",r.name),e.abrupt("return",t(r));case 4:if(!isNode$1||!addNodejsWrapperSource(n,r)){e.next=7;break}return i&&console.log("[lively.modules] loaded %s from nodejs cache",r.name),e.abrupt("return",t(r));case 7:if(s=Date.now(),u=detectModuleFormat(r.source,o),c=module$2(n,r.name),l=!1,f="esm"===u,p="cjs"===u,d="global"===u,c.setSource(r.source),e.prev=10,h=n.useModuleTranslationCache,m=n.global.indexedDB,v=h&&String(lively_lang.string.hashCode(r.source)),!(h&&m&&f)){e.next=25;break}return y=n._livelyModulesTranslationCache||(n._livelyModulesTranslationCache=new BrowserModuleTranslationCache),e.next=16,y.fetchStoredModuleSource(r.name);case 16:if(!((g=e.sent)&&g.hash==v&&g.timestamp>=BrowserModuleTranslationCache.earliestDate)){e.next=23;break}if(!g.source){e.next=23;break}return o.format="register",o.deps=[],i&&console.log("[lively.modules customTranslate] loaded %s from browser cache after %sms",r.name,Date.now()-s),e.abrupt("return",Promise.resolve(g.source));case 23:e.next=36;break;case 25:if(!(isNode$1&&h&&f)){e.next=36;break}return y=n._livelyModulesTranslationCache||(n._livelyModulesTranslationCache=new NodeModuleTranslationCache),e.next=29,y.fetchStoredModuleSource(r.name);case 29:if(!((g=e.sent)&&g.hash==v&&g.timestamp>=NodeModuleTranslationCache.earliestDate)){e.next=36;break}if(!g.source){e.next=36;break}return o.format="register",o.deps=[],i&&console.log("[lively.modules customTranslate] loaded %s from filesystem cache after %sms",r.name,Date.now()-s),e.abrupt("return",Promise.resolve(g.source));case 36:e.next=41;break;case 38:e.prev=38,e.t0=e.catch(10),console.error("[lively.modules customTranslate] error reading module translation cache: "+e.t0.stack);case 41:return b={},f?(c.recorderName="__lvVarRecorder",c.recorder===n.global&&c.unloadEnv(),r.metadata.format="esm",_=prepareCodeForCustomCompile(0,r.source,r.name,c,i),b=_.options,x=_.source,r.source=x,r.metadata["lively.modules instrumented"]=!0,l=!0,i&&console.log("[lively.modules] loaded %s as es6 module",r.name)):"global"===r.metadata.format&&(c.recorderName="System.global",c.recorder=n.global,r.metadata.format="global",w=prepareCodeForCustomCompile(0,r.source,r.name,c,i),b=w.options,x=w.source,r.source=x,r.metadata["lively.modules instrumented"]=!0,l=!0,i&&console.log("[lively.modules] loaded %s as instrumented global module",r.name)),l||i&&console.log("[lively.modules] customTranslate ignoring %s b/c don't know how to handle format %s",r.name,r.metadata.format),e.abrupt("return",t(r).then(function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var o;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(0===t.indexOf("System.register(")&&(i&&console.log("[lively.modules customTranslate] Installing System.register setter captures for %s",r.name),t=prepareTranslatedCodeForSetterCapture(0,t,r.name,c,b,i)),!(isNode$1&&h&&f)){e.next=14;break}return o=n._livelyModulesTranslationCache||(n._livelyModulesTranslationCache=new NodeModuleTranslationCache),e.prev=3,e.next=6,o.cacheModuleSource(r.name,v,t);case 6:i&&console.log("[lively.modules customTranslate] stored cached version in filesystem for %s",r.name),e.next=12;break;case 9:e.prev=9,e.t0=e.catch(3),console.error("[lively.modules customTranslate] failed storing module cache: "+e.t0.stack);case 12:e.next=25;break;case 14:if(!(h&&m&&f)){e.next=25;break}return o=n._livelyModulesTranslationCache||(n._livelyModulesTranslationCache=new BrowserModuleTranslationCache),e.prev=16,e.next=19,o.cacheModuleSource(r.name,v,t);case 19:i&&console.log("[lively.modules customTranslate] stored cached version for %s",r.name),e.next=25;break;case 22:e.prev=22,e.t1=e.catch(16),console.error("[lively.modules customTranslate] failed storing module cache: "+e.t1.stack);case 25:return i&&console.log("[lively.modules customTranslate] done %s after %sms",r.name,Date.now()-s),e.abrupt("return",t);case 27:case"end":return e.stop()}},e,k,[[3,9],[16,22]])}));return function(t){return e.apply(this,arguments)}}()));case 45:case"end":return e.stop()}},e,this,[[10,38]])}));return function(t,r){return e.apply(this,arguments)}}(),funcCall=lively_ast.nodes.funcCall,member=lively_ast.nodes.member,literal=lively_ast.nodes.literal,isNode$1=System.get("@system-env").node,ModuleTranslationCache=function(){function e(){classCallCheck(this,e)}return createClass(e,[{key:"cacheModuleSource",value:function(e,t,r){throw new Error("not yet implemented")}},{key:"fetchStoredModuleSource",value:function(e){throw new Error("not yet implemented")}},{key:"deleteCachedData",value:function(e){throw new Error("not yet implemented")}}],[{key:"earliestDate",get:function(){return+new Date("Sun Nov 06 2016 16:00:00 GMT-0800 (PST)")}}]),e}(),nodejsCacheDir=null,NodeModuleTranslationCache=function(e){function t(){return classCallCheck(this,t),possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return inherits(t,ModuleTranslationCache),createClass(t,[{key:"ensurePath",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.moduleCacheDir.join(t).exists();case 2:if(!e.sent){e.next=4;break}return e.abrupt("return");case 4:r="",o=!0,a=!1,s=void 0,e.prev=8,u=t.split("/")[Symbol.iterator]();case 10:if(o=(c=u.next()).done){e.next=38;break}return l=c.value,r+=l+"/",n=this.moduleCacheDir.join(r),e.next=16,n.exists();case 16:if(e.sent){e.next=26;break}return e.prev=17,e.next=20,n.mkdir();case 20:e.next=26;break;case 22:if(e.prev=22,e.t0=e.catch(17),"EEXIST"==e.t0.code){e.next=26;break}throw e.t0;case 26:return n=lively_resources.resource("file://"+r+"/package.json"),e.next=29,n.exists();case 29:if(!e.sent){e.next=35;break}return e.next=32,n.read();case 32:return i=e.sent,e.next=35,this.moduleCacheDir.join(r+"/package.json").write(i);case 35:o=!0,e.next=10;break;case 38:e.next=44;break;case 40:e.prev=40,e.t1=e.catch(8),a=!0,s=e.t1;case 44:e.prev=44,e.prev=45,!o&&u.return&&u.return();case 47:if(e.prev=47,!a){e.next=50;break}throw s;case 50:return e.finish(47);case 51:return e.finish(44);case 52:case"end":return e.stop()}},e,this,[[8,40,44,52],[17,22],[45,,47,51]])}));return function(t){return e.apply(this,arguments)}}()},{key:"dumpModuleCache",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:e.t0=regeneratorRuntime.keys(System._nodeRequire("module").Module._cache);case 1:if((e.t1=e.t0()).done){e.next=16;break}return t=e.t1.value,r=lively_resources.resource("file://"+t),e.next=6,r.exists();case 6:if(!e.sent){e.next=14;break}return e.t2=this,e.t3=t,e.next=11,r.read();case 11:return e.t4=e.sent,e.next=14,e.t2.cacheModuleSource.call(e.t2,e.t3,"NO_HASH",e.t4);case 14:e.next=1;break;case 16:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"fetchStoredModuleSource",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=t.replace("file://",""),r=t.match(/([^\/]*.)\.js/)[0],n=t.replace(r,""),i=this.moduleCacheDir.join(t),e.next=3,i.exists();case 3:if(e.sent){e.next=5;break}return e.abrupt("return",null);case 5:return e.next=7,i.stat();case 7:return o=e.sent,a=o.birthtime,e.next=11,i.read();case 11:return s=e.sent,e.next=14,this.moduleCacheDir.join(n+"/.hash_"+r).read();case 14:return u=e.sent,e.abrupt("return",{source:s,timestamp:a,hash:u});case 16:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"cacheModuleSource",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n){var i,o;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=t.replace("file://",""),i=t.match(/([^\/]*.)\.js/)[0],o=t.replace(i,""),e.next=3,this.ensurePath(o);case 3:return e.next=5,this.moduleCacheDir.join(t).write(n);case 5:return e.next=7,this.moduleCacheDir.join(o+"/.hash_"+i).write(r);case 7:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"deleteCachedData",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=t.replace("file://",""),r=t.match(/([^\/]*.)\.js/)[0],n=t.replace(r,""),i=this.moduleCacheDir.join(t),e.next=4,i.exists();case 4:if(e.sent){e.next=6;break}return e.abrupt("return",!1);case 6:return e.next=8,i.remove();case 8:return e.abrupt("return",!0);case 9:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"moduleCacheDir",get:function(){return nodejsCacheDir||prepareNodejsCaching(),lively_resources.resource("file://"+nodejsCacheDir+"/.module_cache/")}}]),t}(),BrowserModuleTranslationCache=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"lively.modules-module-translation-cache";classCallCheck(this,t);var r=possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return r.version=2,r.sourceCodeCacheStoreName="sourceCodeStore",r.dbName=e,r.db=r.openDb(),r}return inherits(t,ModuleTranslationCache),createClass(t,[{key:"openDb",value:function(){var e=this,t=System.global.indexedDB.open(this.version);return new Promise(function(r,n){t.onsuccess=function(e){r(this.result)},t.onerror=function(e){return n(e.target)},t.onupgradeneeded=function(t){return t.currentTarget.result.createObjectStore(e.sourceCodeCacheStoreName,{keyPath:"moduleId"})}})}},{key:"deleteDb",value:function(){var e=System.global.indexedDB.deleteDatabase(this.dbName);return new Promise(function(t,r){e.onerror=function(e){return r(e.target)},e.onsuccess=function(e){return t(e)}})}},{key:"closeDb",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t,r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.db;case 2:return t=e.sent,r=t.close(),e.abrupt("return",new Promise(function(e,t){r.onsuccess=function(t){e(this.result)},r.onerror=function(e){return t(e.target.errorCode)}}));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"cacheModuleSource",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n){var i,o=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.db;case 2:return i=e.sent,e.abrupt("return",new Promise(function(e,a){var s=i.transaction([o.sourceCodeCacheStoreName],"readwrite"),u=s.objectStore(o.sourceCodeCacheStoreName),c=Date.now();u.put({moduleId:t,hash:r,source:n,timestamp:c}),s.oncomplete=e,s.onerror=a}));case 4:case"end":return e.stop()}},e,this)}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"fetchStoredModuleSource",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.db;case 2:return r=e.sent,e.abrupt("return",new Promise(function(e,i){var o=r.transaction([n.sourceCodeCacheStoreName]).objectStore(n.sourceCodeCacheStoreName).get(t);o.onerror=i,o.onsuccess=function(t){return e(o.result)}}));case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"deleteCachedData",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.db;case 2:return r=e.sent,e.abrupt("return",new Promise(function(e,i){var o=r.transaction([n.sourceCodeCacheStoreName],"readwrite").objectStore(n.sourceCodeCacheStoreName).delete(t);o.onerror=i,o.onsuccess=function(t){return e(o.result)}}));case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()}]),t}(),node_modulesDir=System.decanonicalize("lively.modules/node_modules/"),exceptions=[function(e){return!e.endsWith(".js")},function(e){return e.endsWith("dist/acorn.js")||e.endsWith("dist/escodegen.browser.js")||e.endsWith("bowser.js")||e.endsWith("TweenMax.min.js")},function(e){return e.endsWith("babel-core/browser.js")||e.endsWith("system.src.js")||e.includes("systemjs-plugin-babel")}],moduleSourceChange$1=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n,i,o){var a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(e.prev=0,t.debug&&console.log("[module change] "+r+" "+n.slice(0,50).replace(/\n/g,"")+" "+i),i&&"es6"!==i&&"esm"!==i&&"register"!==i&&"defined"!==i){e.next=8;break}return e.next=5,moduleSourceChangeEsm(t,r,n,o);case 5:a=e.sent,e.next=15;break;case 8:if("global"!==i){e.next=14;break}return e.next=11,moduleSourceChangeGlobal(t,r,n,o);case 11:a=e.sent,e.next=15;break;case 14:throw new Error("moduleSourceChange is not supported for module "+r+" with format "+i);case 15:return lively_notifications.emit("lively.modules/modulechanged",{module:r,newSource:n,options:o},Date.now(),t),e.abrupt("return",a);case 19:throw e.prev=19,e.t0=e.catch(0),lively_notifications.emit("lively.modules/modulechanged",{module:r,newSource:n,error:e.t0,options:o},Date.now(),t),e.t0;case 23:case"end":return e.stop()}},e,this,[[0,19]])}));return function(t,r,n,i,o){return e.apply(this,arguments)}}(),moduleSourceChangeEsm=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n,i){var o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return o=t.debug,a={status:"loading",source:n,name:r,address:r,linkSets:[],dependencies:[],metadata:{format:"esm"}},e.next=3,instrumentSourceOfEsmModuleLoad(t,a);case 3:s=e.sent,u=function(e,r){return scheduleModuleExportsChange(t,a.name,e,r,!0)},c=s.declare(u),o&&console.log("[lively.vm es6] sourceChange of %s with deps",a.name,s.localDeps),l=[],f=!0,p=!1,d=void 0,e.prev=10,h=s.localDeps[Symbol.iterator]();case 12:if(f=(m=h.next()).done){e.next=25;break}return v=m.value,e.next=16,t.normalize(v,a.name);case 16:return y=e.sent,g=module$2(t,y),e.next=20,g.load();case 20:b=e.sent,l.push({name:v,fullname:y,module:g,exports:b});case 22:f=!0,e.next=12;break;case 25:e.next=31;break;case 27:e.prev=27,e.t0=e.catch(10),p=!0,d=e.t0;case 31:e.prev=31,e.prev=32,!f&&h.return&&h.return();case 34:if(e.prev=34,!p){e.next=37;break}throw d;case 37:return e.finish(34);case 38:return e.finish(31);case 39:return(_=t.loads&&t.loads[a.name])&&(_.deps=l.map(function(e){return e.name}),_.depMap=l.reduce(function(e,t){return e[t.name]=t.fullname,e},{}),_.metadata&&_.metadata.entry&&(_.metadata.entry.deps=_.deps,_.metadata.entry.normalizedDeps=l.map(function(e){return e.fullname}),_.metadata.entry.declare=s.declare)),x=module$2(t,a.name),w=x.record(),l.forEach(function(e,t){return x.addDependencyToModuleRecord(e.module,c.setters[t])}),w&&(w.execute=c.execute),l.forEach(function(e,t){return c.setters[t](e.exports)}),e.abrupt("return",c.execute());case 46:case"end":return e.stop()}},e,this,[[10,27,31,39],[32,,34,38]])}));return function(t,r,n,i){return e.apply(this,arguments)}}(),moduleSourceChangeGlobal=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n,i){var o,a,s;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(o={status:"loading",source:n,name:r,address:r,linkSets:[],dependencies:[],metadata:{format:"global"}},t.get(r)){e.next=4;break}return e.next=4,t.import(r);case 4:return e.next=6,instrumentSourceOfGlobalModuleLoad(t,o);case 6:return a=e.sent,o.source=a.translated,s=doInstantiateGlobalModule(t,o),t.delete(r),t.set(s.name,s.esModule),e.abrupt("return",s.module);case 12:case"end":return e.stop()}},e,this)}));return function(t,r,n,i){return e.apply(this,arguments)}}(),ModulePackageMapping=function(){function e(t){classCallCheck(this,e),this.System=t,this._notificationHandlers=null,this.clearCache(),this.subscribeToSystemChanges()}return createClass(e,null,[{key:"forSystem",value:function(e){var t=e["__lively.modules__modulePackageMapCache"];if(t)return t;var r=new this(e);return e["__lively.modules__modulePackageMapCache"]=r,r}}]),createClass(e,[{key:"subscribeToSystemChanges",value:function(){var e=this;if(!this._notificationHandlers){var t=this.System;this._notificationHandlers=[lively_notifications.subscribe("lively.modules/moduleloaded",function(t){return e.addModuleIdToCache(t.module)},t),lively_notifications.subscribe("lively.modules/moduleunloaded",function(t){return e.removeModuleFromCache(t.module)},t),lively_notifications.subscribe("lively.modules/packageregistered",function(t){return e.clearCache()},t),lively_notifications.subscribe("lively.modules/packageremoved",function(t){return e.clearCache()},t)]}}},{key:"unsubscribeFromSystemChanges",value:function(){if(this._notificationHandlers){var e=this.System;lively_notifications.unsubscribe("lively.modules/moduleloaded",this._notificationHandlers[0],e),lively_notifications.unsubscribe("lively.modules/moduleunloaded",this._notificationHandlers[1],e),lively_notifications.unsubscribe("lively.modules/packageregistered",this._notificationHandlers[2],e),lively_notifications.unsubscribe("lively.modules/packageremoved",this._notificationHandlers[3],e),this._notificationHandlers=null}}},{key:"clearCache",value:function(){this._cacheInitialized=!1,this.packageToModule={},this.modulesToPackage={},this.modulesWithoutPackage={}}},{key:"ensureCache",value:function(){var e=this.System,t=this._cacheInitialized,r=this.packageToModule,n=this.modulesToPackage,i=this.modulesWithoutPackage;if(t)return this;for(var o=Package.allPackageURLs(e),a=0;a<o.length;a++)r[o[a]]=[];for(var s=knownModuleNames(e),u=0;u<s.length;u++){for(var c=s[u],l=void 0,f=0;f<o.length;f++){var p=o[f];c.startsWith(p)&&(!l||l.length<p.length)&&(l=p)}l?(r[l].push(c),n[c]=l):i[c]={}}return this._cacheInitialized=!0,this}},{key:"addModuleIdToCache",value:function(e){this.ensureCache();var t=this.packageToModule,r=this.modulesToPackage,n=this.modulesWithoutPackage;if(r[e])return r[e];if(n[e])return null;for(var i=Object.keys(t),o=void 0,a=0;a<i.length;a++){var s=i[a];e.startsWith(s)&&(!o||o.length<s.length)&&(o=s)}return o?((t[o]||(t[o]=[])).push(e),r[e]=o):(n[e]={},null)}},{key:"removeModuleFromCache",value:function(e){if(this._cacheInitialized){var t=this.packageToModule,r=this.modulesToPackage,n=this.modulesWithoutPackage;if(n.hasOwnProperty(e))delete n[e];else{var i=r[e];i&&(delete r[e],t[i]&&lively_lang.arr.remove(t[i],e))}}}},{key:"getPackageURLForModuleId",value:function(e){return this.modulesToPackage[e]||this.addModuleIdToCache(e)}},{key:"getModuleIdsForPackageURL",value:function(e){return this.ensureCache(),this.packageToModule[e]||[]}}]),e}(),join=lively_lang.string.joinPath,PackageConfiguration=function(){function PackageConfiguration(e){classCallCheck(this,PackageConfiguration),this.pkg=e}return createClass(PackageConfiguration,[{key:"applyConfig",value:function(e){var t=this.System,r=this.packageURL,n=this.pkg,i=(e=lively_lang.obj.deepMerge(n.config,e)).name||r.split("/").slice(-1)[0],o=e.version,a=e.systemjs||{},s=e.lively,u=e.main||"index.js";t.config({map:defineProperty({},i,r),packages:defineProperty({},r,_extends({},a,{meta:_extends({"package.json":{format:"json"}},a.meta),configured:!0}))}),t.packages[r].configured=!0;var c=t.getConfig().packages[r]||{};return c.map||(c.map={}),a&&(s&&s.main?u=s.main:a.main&&(u=a.main),this.applySystemJSConfig(a)),u.match(/\.[^\/\.]+/)||(u+=".js"),c.main=u,n.version=o,n.config=e,n._name=i,n.mergeWithConfig(c),s?this.applyLivelyConfig(s):{subPackages:[]}}},{key:"applySystemJSConfig",value:function(e){var t=this.System;e.packageConfigPaths&&(t.packageConfigPaths=lively_lang.arr.uniq(t.packageConfigPaths.concat(e.packageConfigPaths))),e.packages&&t.config({packages:e.packages}),e.globalmap&&t.config({map:e.globalmap}),e.babelOptions&&t.config({babelOptions:e.babelOptions})}},{key:"applyLivelyConfig",value:function(e){this.applyLivelyConfigMeta(e),this.applyLivelyConfigHooks(e),this.applyLivelyConfigBundles(e)}},{key:"applyLivelyConfigHooks",value:function applyLivelyConfigHooks(livelyConfig){var _this=this;(livelyConfig.hooks||[]).forEach(function(h){try{var f=eval("("+h.source+")");f.name&&isInstalled(_this.System,h.target,f.name)||install(_this.System,h.target,f)}catch(e){console.error("Error installing hook for %s: %s",_this.packageURL,e,h)}})}},{key:"applyLivelyConfigBundles",value:function(e){var t=this;if(!e.bundles)return Promise.resolve();var r=Object.keys(e.bundles).reduce(function(r,n){var i=t.packageURL+"/"+n,o=e.bundles[n].map(function(e){return t.System.decanonicalize(e,t.packageURL+"/")});return r[i]=o,r},{});return this.System.config({bundles:r}),Promise.resolve()}},{key:"applyLivelyConfigMeta",value:function(e){if(e.meta){var t=this.System.getConfig().packages[this.packageURL]||{},r={meta:{},packages:defineProperty({},this.packageURL,t)};Object.keys(e.meta).forEach(function(n){var i=e.meta[n];isURL(n)?r.meta[n]=i:(t.meta||(t.meta={}),t.meta[n]=i)}),this.System.config(r)}}},{key:"System",get:function(){return this.pkg.System}},{key:"packageURL",get:function(){return this.pkg.url}}]),PackageConfiguration}(),urlStartRe=/^[a-z\.-_\+]+:/i,PackageRegistry$$1=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};classCallCheck(this,e),this.System=t,this.packageBaseDirs=r.packageBaseDirs||[],this.devPackageDirs=r.devPackageDirs||[],this.individualPackageDirs=r.individualPackageDirs||[],this._readyPromise=null,this.packageMap={},this._byURL=null}return createClass(e,null,[{key:"ofSystem",value:function(e){var t=e.get("@lively-env").packageRegistry;return t||(t=e["__lively.modules__packageRegistry"]=new this(e)),t}},{key:"forDirectory",value:function(e,t){return new this(e,{packageBaseDirs:[ensureResource(t)]})}},{key:"fromJSON",value:function(e,t){return new this(e).fromJSON(t)}}]),createClass(e,[{key:"resetByURL",value:function(){this._byURL=null}},{key:"allPackageURLs",value:function(){return Object.keys(this.byURL)}},{key:"toJSON",value:function(){function e(e){var r=e.url;return r.startsWith(t.baseURL)?r.slice(t.baseURL.length).replace(/^\//,""):r}var t=this.System,r=this.packageMap,n=this.individualPackageDirs,i=this.devPackageDirs,o=this.packageBaseDirs,a={};for(var s in r){var u=r[s];a[s]={},a[s].latest=u.latest,a[s].versions={};for(var c in u.versions)a[s].versions[c]=u.versions[c].toJSON()}return{packageMap:a,individualPackageDirs:n.map(e),devPackageDirs:i.map(e),packageBaseDirs:o.map(e)}}},{key:"fromJSON",value:function(e){function t(e){return isURL(e)?lively_resources.resource(e):lively_resources.resource(n.baseURL).join(e)}var r={},n=this.System,i=lively_resources.resource(n.baseURL);for(var o in e.packageMap){var a=e.packageMap[o];r[o]={},r[o].latest=a.latest,r[o].versions={};for(var s in a.versions){var u=a.versions[s],c=u.url;isAbsolute(c)||(c=i.join(c).url);var l=new Package.fromJSON(n,_extends({},u,{url:c}));r[o].versions[s]=l}}return this.packageMap=r,this.individualPackageDirs=e.individualPackageDirs.map(t),this.devPackageDirs=e.devPackageDirs.map(t),this.packageBaseDirs=e.packageBaseDirs.map(t),this.resetByURL(),ModulePackageMapping.forSystem(n).clearCache(),this}},{key:"updateFromJSON",value:function(e){var t=this.packageMap;for(var r in e.packageMap){var n=e.packageMap[r];t[r]||(t[r]={}),t[r].latest?semver.gt(n.latest,t[r].latest)&&(t[r].latest=n.latest):t[r].latest,t[r].versions||(t[r].versions={});var i=this.System,o=lively_resources.resource(i.baseURL);for(var a in n.versions){var s=n.versions[a],u=s.url;isAbsolute(u)||(u=o.join(u).url);var c=new Package.fromJSON(i,_extends({},s,{url:u}));t[r].versions[a]=c}}return this.resetByURL(),ModulePackageMapping.forSystem(System).clearCache(),this}},{key:"whenReady",value:function(){return this._readyPromise||Promise.resolve()}},{key:"isReady",value:function(){return!this._readyPromise}},{key:"withPackagesDo",value:function(e){for(var t in this.packageMap){var r=this.packageMap[t].versions;for(var n in r)e(r[n])}}},{key:"findPackage",value:function(e){for(var t in this.packageMap){var r=this.packageMap[t].versions;for(var n in r){var i=r[n];if(e(i))return i}}return null}},{key:"filterPackages",value:function(e){var t=[];return this.withPackagesDo(function(r){return e(r)&&t.push(r)}),t}},{key:"allPackages",value:function(){var e=[];for(var t in this.packageMap){var r=this.packageMap[t].versions;for(var n in r)e.push(r[n])}return e}},{key:"sortPackagesByVersion",value:function(e){return e.sort(function(e,t){return semver.compare(e.version,t.version,!0)})}},{key:"matches",value:function(e,t,r){var n=e.name,i=e.version;return n===t&&(!r||!(!semver.validRange(i||"",!0)||!semver.satisfies(i,r,!0)))}},{key:"coversDirectory",value:function(e){e=ensureResource(e).asDirectory();var t=this.packageBaseDirs,r=this.devPackageDirs;if(this.individualPackageDirs.some(function(t){return t.equals(e)}))return"individualPackageDirs";if(r.some(function(t){return t.equals(e)}))return"devPackageDirs";var n=e.parent().parent();return t.some(function(e){return e.equals(n)})?this.allPackages().find(function(t){return ensureResource(t.url).equals(e)})?"packageCollectionDirs":"maybe packageCollectionDirs":null}},{key:"lookup",value:function(e,t){var r=this,n=this.packageMap[e];if(!n)return null;if(!t||"latest"===t)return n.versions[n.latest];if(!semver.validRange(t,!0))throw new Error("PackageRegistry>>lookup of "+e+": Invalid version - "+t);var i=lively_lang.obj.values(n.versions).filter(function(n){return r.matches(n,e,t)});return i.length<=1?i[0]:lively_lang.arr.last(this.sortPackagesByVersion(i))}},{key:"findPackageDependency",value:function(e,t,r){return r||(r=e.dependencies[t]||e.devDependencies[t]),semver.validRange(r,!0)||(r=null),this.lookup(t,r)}},{key:"findPackageWithURL",value:function(e){return e.isResource&&(e=e.url),e.endsWith("/")&&(e=e.slice(0,-1)),this.byURL[e]}},{key:"findPackageHavingURL",value:function(e){e.isResource&&(e=e.url),e.endsWith("/")&&(e=e.slice(0,-1));var t=1/0,r=null,n=this.byURL;for(var i in n)if(0===e.indexOf(i)){var o=e.slice(i.length).length;o>=t||(t=o,r=n[i])}return r}},{key:"findPackageForPath",value:function(e,t){if(isAbsolute(e))return this.findPackageHavingURL(e);if(e.startsWith("."))return null;var r=e.split("/"),n=slicedToArray(r,1)[0];if(!n)return null;var i=n.indexOf("@"),o=void 0;return i>-1&&(o=n.slice(i+1),n=n.slice(0,i)),!o&&t?this.findPackageDependency(t,n):this.lookup(n,o)}},{key:"resolvePath",value:function(e,t){if(isAbsolute(e))return e;var r=t&&t.isPackage||null;if(!r&&t){if(e.startsWith(".")){var n=lively_resources.resource(t);return n.isDirectory()||(n=n.parent()),n.join(e).withRelativePartsResolved().url}r=this.findPackageHavingURL(t)}var i=this.findPackageForPath(e,r);if(!i)return null;var o=e.indexOf("/"),a=-1===o||o===e.length-1?"":e.slice(o);return a?lively_resources.resource(i.url).join(a).url:i.url}},{key:"update",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t,r,n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w,k,E,S,A,D,C,F,O,j,R,B,P,T,I,L,N=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(this.isReady()){e.next=2;break}return e.abrupt("return",this.whenReady().then(function(){return N.update()}));case 2:t=lively_lang.promise.deferred(),this._readyPromise=t.promise,this.packageBaseDirs=this.packageBaseDirs.map(function(e){return e.asDirectory()}),this.individualPackageDirs=this.individualPackageDirs.map(function(e){return e.asDirectory()}),this.devPackageDirs=this.devPackageDirs.map(function(e){return e.asDirectory()}),r={},e.prev=8,n=!0,i=!1,o=void 0,e.prev=12,a=this.packageBaseDirs[Symbol.iterator]();case 14:if(n=(s=a.next()).done){e.next=77;break}return u=s.value,c=!0,l=!1,f=void 0,e.prev=19,e.next=22,u.dirList(1);case 22:e.t0=Symbol.iterator,p=e.sent[e.t0]();case 24:if(c=(d=p.next()).done){e.next=60;break}return h=d.value,m=!0,v=!1,y=void 0,e.prev=29,e.next=32,h.dirList(1);case 32:e.t1=function(e){return e.isDirectory()},e.t2=Symbol.iterator,g=e.sent.filter(e.t1)[e.t2]();case 35:if(m=(b=g.next()).done){e.next=43;break}return _=b.value,e.next=39,this._discoverPackagesIn(_,r,"packageCollectionDirs");case 39:r=e.sent;case 40:m=!0,e.next=35;break;case 43:e.next=49;break;case 45:e.prev=45,e.t3=e.catch(29),v=!0,y=e.t3;case 49:e.prev=49,e.prev=50,!m&&g.return&&g.return();case 52:if(e.prev=52,!v){e.next=55;break}throw y;case 55:return e.finish(52);case 56:return e.finish(49);case 57:c=!0,e.next=24;break;case 60:e.next=66;break;case 62:e.prev=62,e.t4=e.catch(19),l=!0,f=e.t4;case 66:e.prev=66,e.prev=67,!c&&p.return&&p.return();case 69:if(e.prev=69,!l){e.next=72;break}throw f;case 72:return e.finish(69);case 73:return e.finish(66);case 74:n=!0,e.next=14;break;case 77:e.next=83;break;case 79:e.prev=79,e.t5=e.catch(12),i=!0,o=e.t5;case 83:e.prev=83,e.prev=84,!n&&a.return&&a.return();case 86:if(e.prev=86,!i){e.next=89;break}throw o;case 89:return e.finish(86);case 90:return e.finish(83);case 91:x=!0,w=!1,k=void 0,e.prev=94,E=this.individualPackageDirs[Symbol.iterator]();case 96:if(x=(S=E.next()).done){e.next=104;break}return A=S.value,e.next=100,this._discoverPackagesIn(A,r,"individualPackageDirs");case 100:r=e.sent;case 101:x=!0,e.next=96;break;case 104:e.next=110;break;case 106:e.prev=106,e.t6=e.catch(94),w=!0,k=e.t6;case 110:e.prev=110,e.prev=111,!x&&E.return&&E.return();case 113:if(e.prev=113,!w){e.next=116;break}throw k;case 116:return e.finish(113);case 117:return e.finish(110);case 118:D=!0,C=!1,F=void 0,e.prev=121,O=this.devPackageDirs[Symbol.iterator]();case 123:if(D=(j=O.next()).done){e.next=131;break}return R=j.value,e.next=127,this._discoverPackagesIn(R,r,"devPackageDirs");case 127:r=e.sent;case 128:D=!0,e.next=123;break;case 131:e.next=137;break;case 133:e.prev=133,e.t7=e.catch(121),C=!0,F=e.t7;case 137:e.prev=137,e.prev=138,!D&&O.return&&O.return();case 140:if(e.prev=140,!C){e.next=143;break}throw F;case 143:return e.finish(140);case 144:return e.finish(137);case 145:for(B in r)P=r[B],T=P.pkg,I=P.config,L=P.covered,this.System.debug&&console.log("[PackageRegistry] Adding discovered package "+B+" (from "+L+")"),this._addPackageWithConfig(T,I,B+"/",L);this._updateLatestPackages(),t.resolve(),e.next=153;break;case 150:e.prev=150,e.t8=e.catch(8),t.reject(e.t8);case 153:return e.prev=153,this._readyPromise=null,this.resetByURL(),ModulePackageMapping.forSystem(this.System).clearCache(),e.finish(153);case 158:return e.abrupt("return",this);case 159:case"end":return e.stop()}},e,this,[[8,150,153,158],[12,79,83,91],[19,62,66,74],[29,45,49,57],[50,,52,56],[67,,69,73],[84,,86,90],[94,106,110,118],[111,,113,117],[121,133,137,145],[138,,140,144]])}));return function(){return e.apply(this,arguments)}}()},{key:"addPackageAt",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"individualPackageDirs",l=arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if((r=t.isResource?t.url:t).endsWith("/")&&r.slice(0,-1),!this.byURL[r]){e.next=4;break}throw new Error("package in "+r+" already added to registry");case 4:return e.next=6,this._discoverPackagesIn(ensureResource(t).asDirectory(),{},void 0,l);case 6:n=e.sent,e.t0=regeneratorRuntime.keys(n);case 8:if((e.t1=e.t0()).done){e.next=16;break}if(i=e.t1.value,!this.byURL[i]){e.next=12;break}return e.abrupt("continue",8);case 12:o=n[i],a=o.pkg,s=o.config,u=this._addPackageDir(i,c,!0),this._addPackageWithConfig(a,s,i+"/",u),e.next=8;break;case 16:return this.resetByURL(),ModulePackageMapping.forSystem(this.System).clearCache(),this._updateLatestPackages(),e.abrupt("return",this.findPackageWithURL(t));case 20:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"removePackage",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=e.url,n=e.name,i=e.version,o=ensureResource(r),a=this.coversDirectory(o);"devPackageDirs"===a?this.devPackageDirs=this.devPackageDirs.filter(function(e){return!e.equals(o)}):"individualPackageDirs"===a&&(this.individualPackageDirs=this.individualPackageDirs.filter(function(e){return!e.equals(o)}));var s=this.packageMap;s[n]&&(delete s[n].versions[i],0===Object.keys(s[n].versions).length&&delete s[n]),this.resetByURL(),ModulePackageMapping.forSystem(this.System).clearCache(),t&&this._updateLatestPackages(e.name)}},{key:"updateNameAndVersionOf",value:function(e,t,r,n,i){var o=this.packageMap;o[t]?o[t].versions[r]||console.warn("[PackageRegistry>>updateNameAndVersionOf] No version entry "+r+" of "+t+" found in registry ("+e.url+")"):console.warn("[PackageRegistry>>updateNameAndVersionOf] "+t+"@"+r+" not found in registry ("+e.url+")"),this._addToPackageMap(e,n,i),o[t]&&o[t].versions[r]&&(delete o[t].versions[r],0===Object.keys(o[t].versions).length&&delete o[t]),this._updateLatestPackages(e.name)}},{key:"_updateLatestPackages",value:function(e){var t=this.packageMap;if(e&&t[e])t[e].latest=lively_lang.arr.last(semver.sort(Object.keys(t[e].versions),!0));else for(var r in t)t[r].latest=lively_lang.arr.last(semver.sort(Object.keys(t[r].versions),!0))}},{key:"_discoverPackagesIn",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r,n){var i,o,a,s,u,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t.isDirectory()){e.next=2;break}return e.abrupt("return",r);case 2:if(i=t.asFile().url,!r.hasOwnProperty(i)){e.next=5;break}return e.abrupt("return",r);case 5:return e.prev=5,o=c&&c[i]||new Package(this.System,i),e.next=9,o.tryToLoadPackageConfig();case 9:return a=e.sent,o.setConfig(a),r[i]={pkg:o,config:a,covered:n},this.System.debug&&(s=a.name,u=a.version,console.log("[lively.modules] package "+s+"@"+u+" discovered in "+t.url)),e.abrupt("return",r);case 16:return e.prev=16,e.t0=e.catch(5),e.abrupt("return",r);case 19:case"end":return e.stop()}},e,this,[[5,16]])}));return function(t,r,n){return e.apply(this,arguments)}}()},{key:"_addToPackageMap",value:function(e,t,r){var n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(!t)throw new Error("Cannot add package without name");r||(r="0.0.0");var i=this.packageMap,o=i[t]||(i[t]={versions:{},latest:null});if(o.versions[r]){var a="Redefining version "+r+" of package "+e.url;if(!n)throw new Error(a+" not allowed");console.warn(a)}o.versions[r]=e}},{key:"_addPackageWithConfig",value:function(e,t,r){return(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||this._addPackageDir(r,"individualPackageDirs",!0),e.registerWithConfig(t),this._addToPackageMap(e,e.name,e.version),e}},{key:"_addPackageDir",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"individualPackageDirs",r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(e=ensureResource(e).asDirectory(),("packageCollectionDirs"===t||"maybe packageCollectionDirs"===t)&&(this.coversDirectory(e)||"").includes("packageCollectionDirs"))return"packageCollectionDirs";var n=t,i=this[n].concat(e);return this[n]=r?lively_lang.arr.uniqBy(i,function(e,t){return e.equals(t)}):i,n}},{key:"byURL",get:function(){if(!this._byURL){this._byURL={};var e=!0,t=!1,r=void 0;try{for(var n,i=this.allPackages()[Symbol.iterator]();!(e=(n=i.next()).done);e=!0){var o=n.value;this._byURL[o.url]=o}}catch(e){t=!0,r=e}finally{try{!e&&i.return&&i.return()}finally{if(t)throw r}}}return this._byURL}}]),e}(),Package=function(){function e(t,r,n,i){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};classCallCheck(this,e),this.System=t,this.url=r,this.registerProcess=null,this.map={},this.setConfig(o)}return createClass(e,null,[{key:"allPackages",value:function(e){return lively_lang.obj.values(PackageRegistry$$1.ofSystem(e).byURL)}},{key:"allPackageURLs",value:function(e){return PackageRegistry$$1.ofSystem(e).allPackageURLs()}},{key:"forModule",value:function(e,t){return this.forModuleId(e,t.id)}},{key:"forModuleId",value:function(e,t){var r=ModulePackageMapping.forSystem(e).getPackageURLForModuleId(t);return r?getPackage$1(e,r,!0):null}},{key:"fromJSON",value:function(t,r){return new e(t).fromJSON(r)}}]),createClass(e,[{key:"setConfig",value:function(e){this._name=e.name,this.version=e.version,this.dependencies=e.dependencies||{},this.devDependencies=e.devDependencies||{},this.main=e.main||"index.js",this.systemjs=e.systemjs,this.lively=e.lively}},{key:"toJSON",value:function(){var e=this.System,t=lively_lang.obj.select(this,["url","_name","version","map","dependencies","devDependencies","main","systemjs","lively"]);return t.url.startsWith(e.baseURL)&&(t.url=t.url.slice(e.baseURL.length).replace(/^\//,"")),t}},{key:"fromJSON",value:function(e){var t=this.System;return this.url=e.url,this._name=e._name,this.version=e.version,this.map=e.map||{},this.main=e.main,this.dependencies=e.dependencies||{},this.devDependencies=e.devDependencies||{},this.systemjs=e.systemjs,this.lively=e.lively,isURL(this.url)||(this.url=join(t.baseURL,this.url)),this.registerWithConfig(),this}},{key:"asSpec",value:function(){return _extends({},lively_lang.obj.select(this,["name","main","map","meta","url","address","version","lively"]),{modules:this.modules().map(function(e){return{name:e.id,deps:e.directRequirements().map(function(e){return e.id})}})})}},{key:"path",value:function(){var e=this.System.baseURL;return 0===this.url.indexOf(e)?this.url.slice(e.length):this.url}},{key:"modules",value:function(){var e=this.url,t=this.System;return ModulePackageMapping.forSystem(t).getModuleIdsForPackageURL(e).map(function(e){return module$2(t,e)})}},{key:"resources",value:function(){var t=asyncToGenerator(regeneratorRuntime.mark(function t(r){var n,i,o,a,s,u,c,l=this,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[".git","node_modules",".module_cache","lively.next-node_modules"];return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=this.System,i=this.url,o=e.allPackageURLs(n),a=o.filter(function(e){return e!==i&&!i.startsWith(e)}),t.next=6,lively_resources.resource(i).dirList("infinity",{exclude:f});case 6:return s=t.sent,u=s.filter(function(e){return!e.isDirectory()&&!a.some(function(t){return e.url.startsWith(t)})}).map(function(e){return e.url}),c=lively_lang.arr.pluck(this.modules(),"id"),r&&(u=u.filter(r)),t.abrupt("return",u.map(function(e){var t=e.replace(i,"").replace(/^\//,"");return{isLoaded:c.includes(e),url:e,nameInPackage:t,package:l}}));case 11:case"end":return t.stop()}},t,this)}));return function(e){return t.apply(this,arguments)}}()},{key:"hasResource",value:function(e){this.System;var t=this.url;return(e.startsWith(t)?lively_resources.resource(e):lively_resources.resource(t).join(e)).exists()}},{key:"toString",value:function(){return"Package("+this.name+" - "+this.path()+"/)"}},{key:"mergeWithConfig",value:function(e){var t=e=_extends({},e),r=t.name,n=t.map;return r&&(delete e.name,this._name=r),n&&(delete e.map,Object.assign(this.map,n)),Object.assign(this,e),this}},{key:"addMapping",value:function(e,t){this.map[e]=t,this.System.config({packages:defineProperty({},this.url,{map:defineProperty({},e,t)})})}},{key:"tryToLoadPackageConfig",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t,r,n,i,o;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t=this.System,r=this.url,n=r+"/package.json",t.config({meta:defineProperty({},n,{format:"json"}),packages:defineProperty({},r,{meta:{"package.json":{format:"json"}}})}),t.debug&&console.log("[lively.modules package reading config] %s",n),e.prev=3,e.t0=t.get(n),e.t0){e.next=9;break}return e.next=8,t.import(n);case 8:e.t0=e.sent;case 9:return i=e.t0,lively_lang.arr.pushIfNotIncluded(t.packageConfigPaths,n),e.abrupt("return",i);case 14:return e.prev=14,e.t1=e.catch(3),console.log("[lively.modules package] Unable loading package config %s for package: ",n,e.t1),delete t.meta[n],o=r.split("/").slice(-1)[0],e.abrupt("return",{name:o});case 20:case"end":return e.stop()}},e,this,[[3,14]])}));return function(){return e.apply(this,arguments)}}()},{key:"import",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t,r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.register();case 2:return t=this.url,r=this.System,e.t0=module$2,e.t1=r,e.next=8,r.normalize(t);case 8:return e.t2=e.sent,n=(0,e.t0)(e.t1,e.t2),e.next=12,r.import(n.id);case 12:return i=e.sent,e.next=15,lively_lang.promise.waitFor(1e3,function(){return n.isLoaded()});case 15:return e.abrupt("return",i);case 16:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"isRegistering",value:function(){return!!this.registerProcess}},{key:"register",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.isRegistering()){e.next=2;break}return e.abrupt("return",this.registerProcess.promise);case 2:if(r=this.System,n=this.url,this.registerProcess=lively_lang.promise.deferred(),i=this.registerProcess.promise,r.debug&&console.log("[lively.modules package register] %s",n),e.prev=6,e.t0=t,e.t0){e.next=12;break}return e.next=11,this.tryToLoadPackageConfig();case 11:e.t0=e.sent;case 12:o=e.t0,a=this.registerWithConfig(o),this.registerProcess.resolve(o),e.next=21;break;case 17:throw e.prev=17,e.t1=e.catch(6),this.registerProcess.reject(e.t1),e.t1;case 21:return e.prev=21,delete this.registerProcess,e.finish(21);case 24:return e.abrupt("return",i);case 25:case"end":return e.stop()}},e,this,[[6,17,21,24]])}));return function(t){return e.apply(this,arguments)}}()},{key:"updateConfig",value:function(e){e=_extends({},this.runtimeConfig,e);var t=this.name,r=this.version,n=e,i=n.name,o=n.version;new PackageConfiguration(this).applyConfig(e),t===e.name&&r===e.version||(console.log("[lively.modules] Updating registry "+t+"@"+r+" => "+i+"@"+o),PackageRegistry$$1.ofSystem(this.System).updateNameAndVersionOf(this,t,r,i,o))}},{key:"registerWithConfig",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.runtimeConfig,t=this.System,r=this.url,n=new PackageConfiguration(this).applyConfig(e),i=join(r,"package.json");return t.get(i)||t.set(i,t.newModule(_extends({},e,{default:e}))),lively_notifications.emit("lively.modules/packageregistered",{package:r},Date.now(),t),n}},{key:"remove",value:function(e){e=_extends({forgetEnv:!0,forgetDeps:!1,unloadModules:!0},e);var t=this.System,r=this.url;r=r.replace(/\/$/,""),e.unloadModules&&this.modules().forEach(function(t){return t.unload(e)}),PackageRegistry$$1.ofSystem(t).removePackage(this);var n=t.getConfig(),i=r+"/package.json";t.delete(String(i)),lively_lang.arr.remove(n.packageConfigPaths||[],i),t.config({meta:defineProperty({},i,{}),packages:defineProperty({},r,{}),packageConfigPaths:n.packageConfigPaths}),delete t.packages[r],lively_notifications.emit("lively.modules/packageremoved",{package:this.url},Date.now(),t)}},{key:"reload",value:function(e){var t=this.System,r=this.url,n=PackageRegistry$$1.ofSystem(t),i=n.coversDirectory(r);return this.remove(e),n.addPackageAt(r,i||"devPackageDirs",defineProperty({},r,this)),this.import()}},{key:"fork",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r||(r=lively_resources.resource(this.url).join("../"+t).withRelativePartsResolved().url),e.next=3,this.changeAddress(r,t,!1);case 3:return e.abrupt("return",e.sent);case 4:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"rename",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=lively_resources.resource(this.url).join("../"+t).withRelativePartsResolved().url,e.next=3,this.changeAddress(r,t,!0);case 3:return e.abrupt("return",e.sent);case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"changeAddress",value:function(){var t=asyncToGenerator(regeneratorRuntime.mark(function t(r){var n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w,k,E,S,A,D,C,F,O,j,R,B,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,T=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return r=r.replace(/\/?/,""),n=this.System,i=this.url,o=this.name,a=this.version,t.next=7,this.runtimeConfig;case 7:return s=t.sent,u=lively_resources.resource(i).asDirectory(),c=new e(n,r),t.next=12,lively_resources.resource(r).asDirectory();case 12:return l=t.sent,s.name=P||this.name,f=PackageRegistry$$1.ofSystem(n),p=f.coversDirectory(i),ModulePackageMapping.forSystem(n).clearCache(),n.packages[i]&&(n.packages[r]=n.packages[i],T&&delete n.packages[i]),Object.assign(c,lively_lang.obj.select(this,["_name","map","config"])),t.next=20,l.ensureExistance();case 20:return t.next=22,this.resources(void 0,[]);case 22:t.t0=function(e){return e.url},d=t.sent.map(t.t0),h=this.modules(),m=!0,v=!1,y=void 0,t.prev=28,g=h[Symbol.iterator]();case 30:if(m=(b=g.next()).done){t.next=45;break}if(_=b.value,x=l.join(_.pathInPackage()).url,!T){t.next=38;break}return t.next=36,_.renameTo(x);case 36:t.next=40;break;case 38:return t.next=40,_.copyTo(x);case 40:(w=d.indexOf(_.id))>-1&&d.splice(w,1);case 42:m=!0,t.next=30;break;case 45:t.next=51;break;case 47:t.prev=47,t.t1=t.catch(28),v=!0,y=t.t1;case 51:t.prev=51,t.prev=52,!m&&g.return&&g.return();case 54:if(t.prev=54,!v){t.next=57;break}throw y;case 57:return t.finish(54);case 58:return t.finish(51);case 59:k=!0,E=!1,S=void 0,t.prev=62,A=d[Symbol.iterator]();case 64:if(k=(D=A.next()).done){t.next=72;break}return C=D.value,F=lively_resources.resource(C),O=F.relativePathFrom(u),t.next=69,F.copyTo(l.join(O));case 69:k=!0,t.next=64;break;case 72:t.next=78;break;case 74:t.prev=74,t.t2=t.catch(62),E=!0,S=t.t2;case 78:t.prev=78,t.prev=79,!k&&A.return&&A.return();case 81:if(t.prev=81,!E){t.next=84;break}throw S;case 84:return t.finish(81);case 85:return t.finish(78);case 86:if(!T){t.next=91;break}return t.next=89,this.remove({forgetEnv:!0,forgetDeps:!1});case 89:return t.next=91,u.remove();case 91:if(!P){t.next=112;break}return c.name=P,c.config.name=P,j=lively_resources.resource(r).join("package.json"),t.prev=95,t.next=98,j.exists();case 98:if(!t.sent){t.next=108;break}return t.next=101,j.readJson();case 101:if((R=t.sent).name!==this.name){t.next=106;break}return R.name=P,t.next=106,j.writeJson(R,!0);case 106:(B=n.get(j.url))&&n.set(j.url,n.newModule(_extends({},B,{name:P})));case 108:t.next=112;break;case 110:t.prev=110,t.t3=t.catch(95);case 112:return"individualPackageDirs"!==(p=p||"individualPackageDirs")&&"devPackageDirs"!==p||f._addPackageDir(r,p,!0),f._addPackageWithConfig(c,s,r,p),f.resetByURL(),f._updateLatestPackages(),t.abrupt("return",c);case 118:case"end":return t.stop()}},t,this,[[28,47,51,59],[52,,54,58],[62,74,78,86],[79,,81,85],[95,110]])}));return function(e){return t.apply(this,arguments)}}()},{key:"search",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!i.includeUnloaded){e.next=7;break}return e.next=3,this.resources(function(e){return e.endsWith(".js")},[".git","node_modules","dist",".module_cache","lively.next-node_modules"]);case 3:e.t1=function(e){var t=e.url;return module$2(n.System,t)},e.t0=e.sent.map(e.t1),e.next=8;break;case 7:e.t0=this.modules().filter(function(e){return e.isLoaded()});case 8:return r=e.t0,e.abrupt("return",Promise.all(r.map(function(e){return e.search(t,i).catch(function(t){return console.error("Error searching module "+e.name+":\n"+t.stack),[]})})).then(function(e){return lively_lang.arr.flatten(e,1)}));case 10:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"isPackage",get:function(){return!0}},{key:"name",get:function(){if(this._name)return this._name;var e=this.System.get(this.url+"/package.json");return e&&e.name?e.name:lively_lang.arr.last(this.url.replace(/[\/]+$/,"").split("/"))},set:function(e){return this._name=e}},{key:"nameAndVersion",get:function(){return this.name+"@"+this.version}},{key:"address",get:function(){return this.url},set:function(e){return this.url=e}},{key:"runtimeConfig",get:function(){var e=this.name,t=this.version,r=this.dependencies,n=this.devDependencies,i=this.main,o=this.systemjs,a=this.lively,s={name:e,version:t,dependencies:r||{},devDependencies:n||{}};return i&&(s.main=i),o&&(s.systemjs=o),a&&(s.lively=a),s}}]),e}(),ImportInjector=function(){function e(t,r,n,i,o,a,s){classCallCheck(this,e),this.System=t,this.intoModuleId=r,this.intoPackage=n,this.intoModuleSource=i,this.fromModuleId=o.moduleId,this.importData=o,this.alias=a,this.parsed=s||lively_ast.fuzzyParse(i)}return createClass(e,null,[{key:"run",value:function(e,t,r,n,i){return new this(e,t,r,n,i,arguments.length>5&&void 0!==arguments[5]?arguments[5]:void 0,arguments.length>6&&void 0!==arguments[6]?arguments[6]:void 0).run()}}]),createClass(e,[{key:"run",value:function(){var e=this.generateImportStatement(),t=e.standaloneImport,r=e.importedVarName,n=this.existingImportsOfFromModule(),i=n.imports,o=n.importsOfFromModule,a=n.importsOfVar;if(o=this.importsToBeReused(o,a,e),a.length)return{status:"not modified",newSource:this.intoModuleSource,generated:"",importedVarName:"",standaloneImport:t,from:a[0].start,to:a[0].end};if(o.length){var s=this.modifyExistingImport(o,t);if(s)return s}var u=lively_lang.arr.last(i),c=u?u.end:0;return this.insertNewImport(o,t,r,c)}},{key:"importsToBeReused",value:function(e,t,r){return r.isDefault&&(e=e.filter(function(e){return!e.specifiers.some(function(e){return"ImportDefaultSpecifier"==e.type})})),e}},{key:"generateImportStatement",value:function(){var e=this.intoModuleId,t=this.fromModuleId,r=this.importData,n=this.intoPackage,i=this.alias,o="default"===r.exported,a=i||(o?r.local:r.exported),s=!o&&r.exported!==a,u=n&&n.name,c=t,l=r.packageName,f=r.pathInPackage;if(r.isMain)c=l;else if(u===l)try{(c=lively_resources.resource(t).relativePathFrom(lively_resources.resource(e))).startsWith(".")||(c="./"+c)}catch(e){l&&"no group"!==l&&f&&(c=l+"/"+f)}else l&&"no group"!==l&&f&&(c=l+"/"+f);return{isDefault:o,standaloneImport:o?"import "+a+' from "'+c+'";':"import { "+r.exported+(s?" as "+a:"")+' } from "'+c+'";',importedVarName:a}}},{key:"existingImportsOfFromModule",value:function(){var e=this.System,t=this.fromModuleId,r=this.intoModuleId,n=this.importData,i=n.exported,o=n.local,a=this.parsed,s=this.alias,u="default"===i,c=a.body.filter(function(e){return"ImportDeclaration"===e.type}),l=u?s||o:s||i,f=c.filter(function(n){if(!n.source||"string"!=typeof n.source.value)return null;var i=e.decanonicalize(n.source.value,r);return t===i});return{imports:c,importsOfFromModule:f,importsOfVar:f.filter(function(e){return(e.specifiers||[]).some(function(e){return u?"ImportDefaultSpecifier"===e.type&&e.local.name===l:lively_lang.Path("imported.name").get(e)===i&&lively_lang.Path("local.name").get(e)===l})})}}},{key:"modifyExistingImport",value:function(e,t){var r=lively_lang.arr.flatmap(e,function(e){return e.specifiers||[]});if(!r.length)return null;var n=lively_lang.arr.partition(r,function(e){return"ImportDefaultSpecifier"===e.type}),i=slicedToArray(n,2),o=slicedToArray(i[0],1)[0],a=slicedToArray(i[1],1)[0],s=this.alias,u=this.intoModuleSource,c=this.importData,l=c.exported,f=c.local,p="default"===l;if(p?console.assert(!!a,"no ImportSpecifier found"):console.assert(a||o,"at least one kine of specifier is expected"),p){if((v=u.slice(0,a.start).lastIndexOf("{")-1)<0)return null;var d=(s||f)+",",h=u.slice(0,v),m=u.slice(v);return h.endsWith(" ")&&h.endsWith("\n")||(d=" "+d),m.startsWith(" ")||(d+=" "),{status:"modified",newSource:""+h+d+m,generated:d,standaloneImport:t,importedVarName:s||f,from:v,to:v+d.length}}var v=a?a.end:o.end,y=s&&s!==l,g=y?l+" as "+s:l;return d=a?", "+g:", { "+g+" }",{status:"modified",newSource:""+u.slice(0,v)+d+u.slice(v),generated:d,standaloneImport:t,importedVarName:y?s:l,from:v,to:v+d.length}}},{key:"insertNewImport",value:function(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;e&&e.length&&(n=lively_lang.arr.last(e).end);var i=this.intoModuleSource,o=i.slice(0,n),a=i.slice(n),s=t;return o.length&&!o.endsWith("\n")&&(s="\n"+s),a.length&&!a.startsWith("\n")&&(s+="\n"),{status:"modified",newSource:o+s+a,generated:s,standaloneImport:t,importedVarName:r,from:n,to:n+s.length}}}]),e}(),GlobalInjector=function(){function e(){classCallCheck(this,e)}return createClass(e,null,[{key:"run",value:function(e,t,r){var n=r||lively_ast.fuzzyParse(e,{withComments:!0}),i=n.comments?n.comments.find(function(e){return e.isBlock&&e.text.startsWith("global")}):null,o=i?i.text.replace(/^global\s*/,"").split(",").map(function(e){return e.trim()}).filter(Boolean):[],a=t.filter(function(e){return!o.includes(e)});if(!a.length)return{status:"not modified",newSource:e,generated:"",from:0,to:0};if(!i){var s="/*global "+a.join(",")+"*/\n";return{status:"modified",newSource:s+e,generated:s,from:0,to:s.length}}var u=i.start+"/*".length+i.text.length,c=a.join(",");o.length?c=","+c:i.text.startsWith("global ")||(c=" "+c);var l=u+c.length;return{status:"modified",newSource:e.slice(0,u)+c+e.slice(u),generated:c,from:u,to:l}}}]),e}(),ImportRemover=function(){function e(){classCallCheck(this,e)}return createClass(e,null,[{key:"removeImports",value:function(e,t,r){var n=r||lively_ast.fuzzyParse(e),i=lively_lang.arr.flatmap(n.body,function(e){return"ImportDeclaration"===e.type&&e.specifiers.length?e.specifiers.map(function(t){return{local:t.local,importStmt:e}}):[]}).filter(function(e){return t.some(function(t){return t.local===e.local.name})}),o=i.map(function(e){return{local:e.local.name,from:e.importStmt.source.value}}),a=lively_lang.arr.uniq(i.map(function(e){var t=e.importStmt.specifiers.find(function(t){return e.local===t.local});return lively_lang.arr.remove(e.importStmt.specifiers,t),e.importStmt})).slice().reverse().reduce(function(e,t){var r=e.source,n=e.changes,i=t.start,o=t.end,a=t.specifiers,s=r.slice(0,i),u=r.slice(o),c=r.slice(i,o),l=a.length?lively_ast.stringify(t):"";return l&&l.includes("\n")&&!c.includes("\n")&&(l=l.replace(/\s+/g," ")),r=s+l+u,n=n.concat({replacement:l,start:i,end:o}),{source:r,changes:n}},{source:e,changes:[]});return _extends({},a,{removedImports:o})}},{key:"findUnusedImports",value:function(e){var t="string"==typeof e?lively_ast.fuzzyParse(e):e,r=lively_lang.arr.flatmap(t.body,function(e){return"ImportDeclaration"===e.type&&e.specifiers.length?e.specifiers.map(function(t){return{local:t.local,from:e.source?e.source.value:"",importStmt:e}}):[]}),n=r.map(function(e){return e.local}),i=lively_ast.query.resolveReferences(lively_ast.query.scopes(t)),o=Array.from(i.resolvedRefMap.keys()).filter(function(e){return!n.includes(e)}),a=lively_lang.arr.uniq(o.map(function(e){return e.name}));return r.filter(function(e){return!a.includes(e.local.name)}).map(function(e){return _extends({},e,{local:e.local.name})})}},{key:"removeUnusedImports",value:function(e){var t=lively_ast.fuzzyParse(e);return this.removeImports(e,this.findUnusedImports(t),t)}}]),e}(),detectModuleFormat=function(){var e=/['"]format (esm|es6)['"];/,t=/['"]format cjs['"];/,r=/(^\s*|[}\);\n]\s*)(import\s+(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s+from\s+['"]|\{)|export\s+\*\s+from\s+["']|export\s+(\{|default|function|class|var|const|let|async\s+function))/;return function(n,i){return i&&i.format?("es6"==i.format&&i.format,i.format):e.test(n.slice(0,5e3))||!t.test(n.slice(0,5e3))&&r.test(n)?"esm":"global"}}(),doesModuleExist$1=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n=livelySystemEnv(t),i=a?r:t.normalizeSync(r),!isModuleLoaded$1(t,i,!0)){e.next=3;break}return e.abrupt("return",!0);case 3:if((o=Package.forModuleId(t,i))&&"no group"!==o.name){e.next=8;break}e.t0=t.resource(i).exists(),e.next=11;break;case 8:return e.next=10,o.hasResource(i);case 10:e.t0=e.sent;case 11:return e.abrupt("return",e.t0);case 12:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}(),globalProps={initialized:!1,descriptors:{}},ModuleInterface=function(){function e(t,r){var n=this;if(classCallCheck(this,e),!isURL(r)&&!/^@/.test(r))throw new Error("ModuleInterface constructor called with "+r+" that does not seem to be a fully normalized module id.");this.System=t,this.id=r,this.recorderName="__lvVarRecorder",this.sourceAccessorName="__lvOriginalCode",this._recorder=null,this._source=null,this._ast=null,this._scope=null,this._observersOfTopLevelState=[],this._evaluationsInProgress=0,this._evalId=1,this.createdAt=this.lastModifiedAt=new Date,lively_notifications.subscribe("lively.modules/modulechanged",function(e){e.module===n.id&&n.reset()})}return createClass(e,[{key:"fullName",value:function(){return this.id}},{key:"shortName",value:function(){return this.package().name+"/"+this.pathInPackage()}},{key:"source",value:function(){var e=this;return"@empty"===this.id?Promise.resolve(""):this._source?Promise.resolve(this._source):this.System.resource(this.id).read().then(function(t){return e._source=t})}},{key:"setSource",value:function(e){this._source!==e&&(this.reset(),this._source=e)}},{key:"ast",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this._ast){e.next=2;break}return e.abrupt("return",this._ast);case 2:return e.t0=lively_ast.parse,e.next=5,this.source();case 5:return e.t1=e.sent,e.abrupt("return",this._ast=(0,e.t0)(e.t1));case 7:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"scope",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!this._scope){e.next=2;break}return e.abrupt("return",this._scope);case 2:return e.next=4,this.ast();case 4:return t=e.sent,e.abrupt("return",this._scope=lively_ast.query.topLevelDeclsAndRefs(t).scope);case 6:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"resolvedScope",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=lively_ast.query,e.next=3,this.scope();case 3:return e.t1=e.sent,e.abrupt("return",this._scope=e.t0.resolveReferences.call(e.t0,e.t1));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"metadata",value:function(){var e=this.System.loads?this.System.loads[this.id]:null;return e?e.metadata:null}},{key:"addMetadata",value:function(e){var t=this.System,r=this.id,n=this.metadata(),i=n?Object.assign(n,e):e;return t.config({meta:defineProperty({},r,i)}),t.meta[r]}},{key:"format",value:function(){var e=this.metadata();return e&&e.format?e.format:this._source?detectModuleFormat(this._source):"global"}},{key:"setFormat",value:function(e){return this.addMetadata({format:e})}},{key:"reset",value:function(){this._source=null,this._ast=null,this._scope=null}},{key:"get",value:function(){var e=this.id;return this.System.get(e)}},{key:"load",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=this.id,n=this.System,t&&this.addMetadata(t),e.t0=n.get(r),e.t0){e.next=7;break}return e.next=6,n.import(r);case 6:e.t0=e.sent;case 7:return e.abrupt("return",e.t0);case 8:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"isLoaded",value:function(){return!!this.System.get(this.id)}},{key:"unloadEnv",value:function(){this._recorder=null,this._observersOfTopLevelState=[],delete livelySystemEnv(this.System).loadedModules[this.id]}},{key:"unloadDeps",value:function(e){var t=this;e=lively_lang.obj.merge({forgetDeps:!0,forgetEnv:!0},e),this.dependents().forEach(function(r){t.System.delete(r.id),t.System.loads&&delete t.System.loads[r.id],e.forgetEnv&&r.unloadEnv()})}},{key:"unload",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t=_extends({reset:!0,forgetDeps:!0,forgetEnv:!0},t),r=this.System,n=this.id,t.reset&&this.reset(),t.forgetDeps&&this.unloadDeps(t),this.System.delete(n),r.loads&&delete r.loads[n],r.meta&&delete r.meta[n],t.forgetEnv&&this.unloadEnv(),!(i=r._livelyModulesTranslationCache)){e.next=12;break}return e.next=12,i.deleteCachedData(n);case 12:lively_notifications.emit("lively.modules/moduleunloaded",{module:this.id},Date.now(),this.System);case 13:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"reload",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=lively_lang.obj.merge({reloadDeps:!0,resetEnv:!0},t),r=[this],t.reloadDeps&&(r=this.dependents().concat(r)),e.next=5,this.unload({forgetDeps:t.reloadDeps,forgetEnv:t.resetEnv});case 5:return e.next=7,Promise.all(r.map(function(e){return e.id!==n.id&&e.load()}));case 7:return e.next=9,this.load();case 9:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"copyTo",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=this.System.resource(t),e.next=3,this.source();case 3:return e.t1=e.sent,e.next=6,e.t0.write.call(e.t0,e.t1);case 6:return r=this.System,n=this.recorderName,i=this.sourceAccessorName,o=this._recorder,a=this._source,s=this._ast,u=this._scope,c=this._observersOfTopLevelState,l=module$2(r,t),f=lively_lang.obj.select(this,["_observersOfTopLevelState","_scope","_ast","_source","_recorder","sourceAccessorName","recorderName"]),Object.assign(l,f),r.set(t,r.newModule(r.get(this.id))),e.abrupt("return",l);case 10:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"renameTo",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=s.unload,n=void 0===r||r,i=s.removeFile,o=void 0===i||i,e.next=6,this.copyTo(t);case 6:if(a=e.sent,!n){e.next=10;break}return e.next=10,this.unload({reset:!0,forgetDeps:!1,forgetEnv:!0});case 10:if(!o){e.next=13;break}return e.next=13,this.System.resource(this.id).remove();case 13:return e.abrupt("return",a);case 14:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"whenLoaded",value:function(e){if(this.isLoaded())try{e(this)}catch(e){console.error(e)}else livelySystemEnv(this.System).onLoadCallbacks.push({moduleName:this.id,resolved:!0,callback:e})}},{key:"changeSourceAction",value:function(e){var t=this;return Promise.resolve(this.source()).then(function(t){return e(t)}).then(function(e){return t.changeSource(e)})}},{key:"changeSource",value:function(e,t){t=_extends({doSave:!0,doEval:!0},t);var r=this.System,n=this.id,i=this.format(),o=void 0;return this.reset(),this.lastModifiedAt=new Date,Promise.all([t.doSave&&this.System.resource(n).write(e),t.doEval&&moduleSourceChange$1(r,n,e,i,t).then(function(e){return o=e})]).then(function(){return o})}},{key:"addDependencyToModuleRecord",value:function(e){var t=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},n=this.record(),i=e.record();if(n&&i){var o,a=n.dependencies.some(function(t,r){if(t)return o=r,t&&t.name===e.id});a?i!==n.dependencies[o]&&n.dependencies.splice(o,1,i):n.dependencies.push(i),a&&n.setters[o]||(n.setters[a?o:n.dependencies.length-1]=r);var s;i.importers.some(function(e,r){if(e)return s=r,e&&e.name===t.id})?n!==i.importers[s]&&i.importers.splice(s,1,n):i.importers.push(n)}}},{key:"dependents",value:function(){var e=this;return lively_lang.graph.hull(lively_lang.graph.invert(computeRequireMap(this.System)),this.id).map(function(t){return module$2(e.System,t)})}},{key:"requirements",value:function(){var e=this;return lively_lang.graph.hull(computeRequireMap(this.System),this.id).map(function(t){return module$2(e.System,t)})}},{key:"directRequirements",value:function(){var e=this,t=(this.record()||{}).dependencies||[];return lively_lang.arr.pluck(t.filter(Boolean),"name").map(function(t){return module$2(e.System,t)})}},{key:"define",value:function(e,t){var r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],n=arguments[3],i=this.System,o=this.id,a=this.recorder,s=Symbol.for("lively-object-meta"),u=Symbol.for("lively-module-meta");if("function"!=typeof t||!n||"function"!==n.kind&&"class"!==n.kind||(t[s]=n),t&&t[s]&&!t[u]){var c=this.pathInPackage(),l=this.package();t[u]={package:l?{name:l.name,version:l.version}:{},pathInPackage:c}}return a[e]=t,scheduleModuleExportsChange(i,o,e,t,!1),this.notifyTopLevelObservers(e),(r=r||!this.isEvalutionInProgress())&&runScheduledExportChanges(i,o),t}},{key:"undefine",value:function(e){delete this.recorder[e]}},{key:"subscribeToToplevelDefinitionChanges",value:function(e){return this._observersOfTopLevelState.push(e),e}},{key:"notifyTopLevelObservers",value:function(e){var t=["createOrExtendES6ClassForLively","lively.capturing-declaration-wrapper"],r=this.recorder;lively_lang.arr.include(t,e)||this._observersOfTopLevelState.forEach(function(t){return t(e,r[e])})}},{key:"unsubscribeFromToplevelDefinitionChanges",value:function(e){this._observersOfTopLevelState="string"==typeof e?this._observersOfTopLevelState.filter(function(t){return t.name!==e}):this._observersOfTopLevelState.filter(function(t){return t!==e})}},{key:"evaluationStart",value:function(){this._evaluationsInProgress++}},{key:"evaluationEnd",value:function(){this._evaluationsInProgress--,runScheduledExportChanges(this.System,this.id)}},{key:"nextEvalId",value:function(){return this._evalId++}},{key:"isEvalutionInProgress",value:function(){return this._evaluationsInProgress>0}},{key:"env",value:function(){return this}},{key:"package",value:function(){return Package.forModule(this.System,this)}},{key:"pathInPackage",value:function(){var e=this.package();return e&&0===this.id.indexOf(e.address)?this.id.slice(e.address.length).replace(/^\//,""):this.id}},{key:"imports",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=lively_ast.query,e.next=3,this.scope();case 3:return e.t1=e.sent,e.abrupt("return",e.t0.imports.call(e.t0,e.t1));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"exports",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.t0=lively_ast.query,e.next=3,this.scope();case 3:return e.t1=e.sent,e.abrupt("return",e.t0.exports.call(e.t0,e.t1));case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"addImports",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.source();case 2:for(r=e.sent,n=!0,i=!1,o=void 0,e.prev=6,a=t[Symbol.iterator]();!(n=(s=a.next()).done);n=!0)u=s.value,c=module$2(this.System,u.from||u.moduleId),l=c.package(),f={exported:u.exported||u.local,moduleId:c.id,packageName:l.name,packageURL:l.url,pathInPackage:c.pathInPackage()},p=u.local,d=ImportInjector.run(this.System,this.id,this.package(),r,f,p),r=d.newSource,h=d.standAloneImport;e.next=14;break;case 10:e.prev=10,e.t0=e.catch(6),i=!0,o=e.t0;case 14:e.prev=14,e.prev=15,!n&&a.return&&a.return();case 17:if(e.prev=17,!i){e.next=20;break}throw o;case 20:return e.finish(17);case 21:return e.finish(14);case 22:return e.next=24,this.changeSource(r);case 24:case"end":return e.stop()}},e,this,[[6,10,14,22],[15,,17,21]])}));return function(t){return e.apply(this,arguments)}}()},{key:"addGlobalDeclaration",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.source();case 2:if(r=e.sent,n=GlobalInjector.run(r,t),i=n.status,o=n.newSource,!(a="modified"===i)){e.next=10;break}return e.next=10,this.changeSource(o);case 10:return e.abrupt("return",a);case 11:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"removeImports",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t.length){e.next=2;break}return e.abrupt("return");case 2:return e.next=4,this.source();case 4:return r=e.sent,e.next=7,ImportRemover.removeImports(r,t);case 7:return n=e.sent,i=n.source,o=n.removedImports,e.next=12,this.changeSource(i);case 12:o.forEach(function(e){return delete a.recorder[e.local]});case 13:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_localDeclForRefAt",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.resolvedScope();case 2:return r=e.sent,n=lively_ast.query.refWithDeclAt(t,r),e.abrupt("return",n&&{decl:n.decl,id:n.declId,declModule:this});case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_localDeclForName",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.resolvedScope();case 2:r=e.sent,n=void 0,i=!0,o=!1,a=void 0,e.prev=7,s=r.resolvedRefMap.values()[Symbol.iterator]();case 9:if(i=(u=s.next()).done){e.next=18;break}if(c=u.value,l=c.ref.name,t!==l){e.next=15;break}return n=c,e.abrupt("break",18);case 15:i=!0,e.next=9;break;case 18:e.next=24;break;case 20:e.prev=20,e.t0=e.catch(7),o=!0,a=e.t0;case 24:e.prev=24,e.prev=25,!i&&s.return&&s.return();case 27:if(e.prev=27,!o){e.next=30;break}throw a;case 30:return e.finish(27);case 31:return e.finish(24);case 32:return e.abrupt("return",n&&{decl:n.decl,id:n.declId,declModule:this});case 33:case"end":return e.stop()}},e,this,[[7,20,24,32],[25,,27,31]])}));return function(t){return e.apply(this,arguments)}}()},{key:"_importForNSRefAt",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.resolvedScope();case 2:if(r=e.sent,n=r.node,!((i=lively_ast.query.nodesAtIndex(n,t)).length<2)){e.next=7;break}return e.abrupt("return",[null,null]);case 7:if(o=i[i.length-1],a=i[i.length-2],"Identifier"==o.type&&"MemberExpression"==a.type&&!a.computed&&"Identifier"===a.object.type){e.next=10;break}return e.abrupt("return",[null,null]);case 10:if(s=r.resolvedRefMap.get(a.object)||{},(u=s.decl)&&"ImportDeclaration"===u.type){e.next=13;break}return e.abrupt("return",[null,null]);case 13:return c=a.object.name,l=u.specifiers.find(function(e){return e.local.name===c}),e.abrupt("return","ImportNamespaceSpecifier"!==l.type?[null,null]:[u,l.local,o.name]);case 15:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_resolveImportedDecl",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t){e.next=2;break}return e.abrupt("return",[]);case 2:return r=t.id,n=r.start,i=r.name,o=r.type,e.next=8,this.imports();case 8:if(a=e.sent,!(s=a.find(function(e){return e.local==i}))){e.next=17;break}return u=module$2(this.System,s.fromModule,this.id),e.t0=[t],e.next=15,u.bindingPathForExport(s.imported);case 15:return e.t1=e.sent,e.abrupt("return",e.t0.concat.call(e.t0,e.t1));case 17:return e.abrupt("return",[t]);case 18:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"bindingPathFor",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._localDeclForName(t);case 2:if(!(r=e.sent)){e.next=7;break}return e.next=6,this._resolveImportedDecl(r);case 6:return e.abrupt("return",e.sent);case 7:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"bindingPathForExport",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.resolvedScope();case 2:return e.next=4,this.exports();case 4:if(r=e.sent,!(n=r.find(function(e){return e.exported===t})).fromModule){e.next=17;break}return i=module$2(this.System,n.fromModule,this.id),o={decl:n.node,id:n.declId},o.declModule=this,e.t0=[o],e.next=13,i.bindingPathForExport(n.imported);case 13:return e.t1=e.sent,e.abrupt("return",e.t0.concat.call(e.t0,e.t1));case 17:return e.abrupt("return",this._resolveImportedDecl({decl:n.decl,id:n.declId,declModule:n&&n.decl?this:null}));case 18:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"bindingPathForRefAt",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._localDeclForRefAt(t);case 2:if(!(r=e.sent)){e.next=7;break}return e.next=6,this._resolveImportedDecl(r);case 6:return e.abrupt("return",e.sent);case 7:return e.next=9,this._importForNSRefAt(t);case 9:if(n=e.sent,i=slicedToArray(n,3),o=i[0],a=i[1],s=i[2],o){e.next=16;break}return e.abrupt("return",[]);case 16:return u=module$2(this.System,o.source.value,this.id),e.t0=[{decl:o,declModule:this,id:a}],e.next=20,u.bindingPathForExport(s);case 20:return e.t1=e.sent,e.abrupt("return",e.t0.concat.call(e.t0,e.t1));case 22:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"definitionForRefAt",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.bindingPathForRefAt(t);case 2:return r=e.sent,e.abrupt("return",r.length<1?null:r[r.length-1].decl);case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"ensureRecord",value:function(){var e=this.System,t=e._loader.moduleRecords;return t[this.id]?t[this.id]:t[this.id]={name:this.id,exports:e.newModule({}),dependencies:[],importers:[],setters:[]}}},{key:"record",value:function(){var e=this.System._loader.moduleRecords[this.id];return e?(e.hasOwnProperty("__lively_modules__")||(e.__lively_modules__={evalOnlyExport:{}}),e):null}},{key:"updateRecord",value:function(e){var t=this.record();if(!t)throw new Error("es6 environment global of "+this.id+": module not loaded, cannot get export object!");t.locked=!0;try{return e(t)}finally{t.locked=!1}}},{key:"search",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u,c,l,f,p,d,h,m,v,y=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!(r=_extends({excludedModules:[]},r)).excludedModules.some(function(e){return"string"==typeof e?e===y.id:e instanceof RegExp?e.test(y.id):"function"==typeof e&&e(y.id)})){e.next=3;break}return e.abrupt("return",[]);case 3:return e.next=5,this.source();case 5:for(n=e.sent,i=void 0,t instanceof RegExp?(o="g",t.ignoreCase&&(o+="i"),t.multiline&&(o+="m"),i=RegExp(t.source,o)):i=RegExp(t,"g"),a=void 0,s=[];null!==(a=i.exec(n));)s.push([a.index,a[0].length]);u=0,c=0,l=1,f=0;case 11:if(!(u<n.length&&c<s.length)){e.next=24;break}if("\n"==n[u]&&(l++,f=u+1),p=slicedToArray(s[c],2),d=p[0],h=p[1],u===d){e.next=16;break}return e.abrupt("continue",21);case 16:-1===(m=n.slice(f).indexOf("\n"))?m=n.length:m+=f,v=this.package(),s[c]={moduleId:this.id,packageName:v?v.name:void 0,pathInPackage:v?this.pathInPackage():this.id,isLoaded:this.isLoaded(),length:h,line:l,column:u-f,lineString:n.slice(f,m)},c++;case 21:u++,e.next=11;break;case 24:return e.abrupt("return",s);case 25:case"end":return e.stop()}},e,this)}));return function(t,r){return e.apply(this,arguments)}}()},{key:"toString",value:function(){return"module("+this.id+")"}},{key:"dontTransform",get:function(){return[this.recorderName,this.sourceAccessorName,"global","self","_moduleExport","_moduleImport","localStorage","prompt","alert","fetch","getComputedStyle"].concat(lively_ast.query.knownGlobals)}},{key:"recorder",set:function(e){return this._recorder=e},get:function(){var e;if(this._recorder)return this._recorder;var t=this.System,r=this;if(!globalProps.initialized){globalProps.initialized=!0;for(var n in t.global)t.global.__lookupGetter__(n)&&(globalProps.descriptors[n]={value:void 0,configurable:!0,writable:!0})}var i={};if(t.get("@system-env").node){var o=_require.bind(null,this);o.resolve=_resolve.bind(null,this),i.require={configurable:!0,writable:!0,value:o}}return this._recorder=Object.create(t.global,_extends({},globalProps.descriptors,i,(e={System:{configurable:!0,writable:!0,value:t},__currentLivelyModule:{value:r}},defineProperty(e,lively_vm.defaultClassToFunctionConverterName,{configurable:!0,writable:!0,value:lively_classes.runtime.initializeClass}),defineProperty(e,this.varDefinitionCallbackName,{value:function(e,t,n,i,o){return o=o||{},o.kind=t,r.define(e,n,!1,o)}}),defineProperty(e,"_moduleExport",{value:function(e,n){scheduleModuleExportsChange(t,r.id,e,n,!0)}}),defineProperty(e,"_moduleImport",{value:function(e,n){var i=t.decanonicalize(e,r.id),o=t.get(i);if(o)return r.addDependencyToModuleRecord(module$2(t,i),function(e){return Object.assign(r.recorder,e)}),void 0==n?o:(o.hasOwnProperty(n)||console.warn("import from "+o+": Has no export "+n+"!"),o[n]);console.warn("import of "+n+" failed: "+e+" (tried as "+r.id+") is not loaded!")}}),e)))}},{key:"varDefinitionCallbackName",get:function(){return"defVar_"+this.id}}]),e}(),fetchResource=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t,r){var n,i,o,a,s,u;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n=this,i=n.resource(r.name)){e.next=3;break}return e.abrupt("return",t(r));case 3:return e.prev=3,e.next=6,i.read();case 6:o=e.sent,e.next=12;break;case 9:e.prev=9,e.t0=e.catch(3),a=e.t0;case 12:if(!a||!n.get("@system-env").browser){e.next=24;break}if(s=i.url.startsWith("http"),u=!i.url.startsWith(document.location.origin),!s||!u){e.next=24;break}return e.prev=15,e.next=18,i.makeProxied().read();case 18:o=e.sent,a=null,e.next=24;break;case 22:e.prev=22,e.t1=e.catch(15);case 24:if(!a){e.next=26;break}throw a;case 26:return e.abrupt("return",o);case 27:case"end":return e.stop()}},e,this,[[3,9],[15,22]])}));return function(t,r){return e.apply(this,arguments)}}(),livelyURLRe=/^lively:\/\/([^\/]+)\/(.*)$/,isNode=System.get("@system-env").node,initialSystem=initialSystem||System,SystemClass=System.constructor;SystemClass.systems||(SystemClass.systems={});var defaultOptions={notificationLimit:null},dotSlashStartRe=/^\.?\//,trailingSlashRe=/\/$/,jsExtRe=/\.js$/,jsonJsExtRe=/\.json\.js$/i,doubleSlashRe=/.\/{2,}/g,ExportLookup=function(){function e(t){classCallCheck(this,e),this.System=t,this.subscribeToSystemChanges()}return createClass(e,null,[{key:"forSystem",value:function(e){this._forSystemMap||(this._forSystemMap=new WeakMap);var t=this._forSystemMap.get(e);return t||(t=new this(e),this._forSystemMap.set(e,t),t)}},{key:"run",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:System,t=arguments[1];return this.forSystem(e).systemExports(t)}},{key:"findExportOfValue",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:System;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.run(n);case 2:return r=e.sent,e.abrupt("return",r.find(function(e){var r=e.local,i=e.moduleId,o=module$2(n,i),a=o.recorder||n.get(o.id)||{};try{return a[r]===t}catch(e){return!1}}));case 4:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()}]),createClass(e,[{key:"subscribeToSystemChanges",value:function(){var e=this;if(!this._notificationHandlers){var t=this.System;this._notificationHandlers=[lively_notifications.subscribe("lively.modules/moduleloaded",function(t){return e.clearCacheFor(t.module)},t),lively_notifications.subscribe("lively.modules/modulechanged",function(t){return e.clearCacheFor(t.module)},t),lively_notifications.subscribe("lively.vm/doitresult",function(t){return e.clearCacheFor(t.targetModule)},t)]}}},{key:"unsubscribeFromSystemChanges",value:function(){if(this._notificationHandlers){var e=this.System;lively_notifications.unsubscribe("lively.modules/moduleloaded",this._notificationHandlers[0],e),lively_notifications.unsubscribe("lively.modules/modulechanged",this._notificationHandlers[1],e),lively_notifications.unsubscribe("lively.vm/doitresult",this._notificationHandlers[2],e),this._notificationHandlers=null}}},{key:"clearCacheFor",value:function(e){this.exportByModuleCache[e]=null}},{key:"systemExports",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.rawExportsByModule(t);case 2:return r=e.sent,Object.keys(r).forEach(function(e){return n.resolveExportsOfModule(e,r)}),e.abrupt("return",lively_lang.arr.flatmap(Object.keys(r),function(e){return r[e].resolvedExports||r[e].rawExports}));case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"rawExportsByModule",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=t||{},r=this.System,n=r.get("@lively-env")||{},i=Object.keys(n.loadedModules||{}),o=this.exportByModuleCache,a={},e.next=4,Promise.all(i.map(function(e){return s.rawExportsOfModule(e,t,a).then(function(t){return t?a[e]=t:null})}));case 4:return e.abrupt("return",a);case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"rawExportsOfModule",value:function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h,m,v,y,g,b,_,x,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=this.System,n=this.exportByModuleCache,i=w.excludedPackages||[],o=w.excludedURLs||(w.excludedURLs=i.filter(function(e){return"string"==typeof e})),a=w.excludeFns||(w.excludeFns=i.filter(function(e){return"function"==typeof e})),s=w.excludedPackageURLs||(w.excludedPackageURLs=o.concat(o.map(function(e){return r.decanonicalize(e.replace(/\/?$/,"/")).replace(/\/$/,"")}))),u=w.livelyEnv||(w.livelyEnv=r.get("@lively-env")||{}),c=w.modes||(w.modes=Object.keys(u.loadedModules||{})),!n[t]){e.next=4;break}return l=n[t].rawExports,e.abrupt("return",s.includes(l.packageURL)||a.some(function(e){return e(l.packageURL)})?null:n[t]);case 4:if(f=module$2(r,t),p=f.pathInPackage(),d=f.package(),h=d&&d.main&&p===d.main,m=d?d.url:"",v=d?d.name:"",y=d?d.version:"",g={moduleId:t,isMain:h,pathInPackage:p,packageName:v,packageURL:m,packageVersion:y,exports:[]},!s.includes(m)&&!a.some(function(e){return e(m)})){e.next=7;break}return e.abrupt("return",null);case 7:if(e.prev=7,b=f.format(),!["register","es6","esm"].includes(b)){e.next=15;break}return e.next=12,f.exports();case 12:g.exports=e.sent,e.next=27;break;case 15:return e.next=17,f.load();case 17:_=e.sent,g.exports=[],e.t0=regeneratorRuntime.keys(_);case 20:if((e.t1=e.t0()).done){e.next=27;break}if("__useDefault"!==(x=e.t1.value)&&"default"!==x){e.next=24;break}return e.abrupt("continue",20);case 24:g.exports.push({exported:x,local:x,type:"id"}),e.next=20;break;case 27:e.next=32;break;case 29:e.prev=29,e.t2=e.catch(7),g.error=e.t2;case 32:return e.abrupt("return",n[t]={rawExports:g});case 33:case"end":return e.stop()}},e,this,[[7,29]])}));return function(t){return e.apply(this,arguments)}}()},{key:"resolveExportsOfModule",value:function(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!n[e]){n[e]=!0;var i=t[e];if(i&&!i.resolvedExports){var o=this.System,a=lively_lang.obj.select(i.rawExports,["moduleId","isMain","packageName","packageURL","packageVersion","pathInPackage"]);i.resolvedExports=lively_lang.arr.flatmap(i.rawExports.exports,function(i){var s=i.type,u=i.exported,c=i.local,l=i.fromModule;if("all"!==s)return[_extends({},a,{type:s,exported:u,local:c,fromModule:l})];var f=o.decanonicalize(l,e);return r.resolveExportsOfModule(f,t,n),(t[f].resolvedExports||[]).map(function(e){var t=e.type,r=e.exported,n=e.local,i=e.fromModule;return _extends({},a,{type:t,exported:r,local:n,fromModule:i||l})})}),n[e]=!1}}}},{key:"exportByModuleCache",get:function(){return this._exportByModuleCache||(this._exportByModuleCache={})}}]),e}(),buildPackageMap=function(){var e=asyncToGenerator(regeneratorRuntime.mark(function e(t){var r,n,i,o,a,s,u,c,l,f,p,d,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{maxDepth:0,excludes:[]},m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(r=h.maxDepth,n=h.excludes,!(r>0&&v>r)){e.next=3;break}return e.abrupt("return",m);case 3:return e.prev=3,e.t0=JSON,e.next=7,lively_resources.resource(t).join("package.json").read();case 7:if(e.t1=e.sent,i=e.t0.parse.call(e.t0,e.t1),o=i.name+"@"+i.version,!m[o]&&!n.includes(i.name)){e.next=12;break}return e.abrupt("return",m);case 12:m[o]=_extends({url:t},lively_lang.obj.select(i,["name","version","dependencies","devDependencies","main"])),e.next=18;break;case 15:return e.prev=15,e.t2=e.catch(3),e.abrupt("return",m);case 18:return e.prev=18,e.next=21,lively_resources.resource(t).join("node_modules").dirList(1);case 21:a=e.sent,e.next=27;break;case 24:return e.prev=24,e.t3=e.catch(18),e.abrupt("return",m);case 27:s=!0,u=!1,c=void 0,e.prev=30,l=a[Symbol.iterator]();case 32:if(s=(f=l.next()).done){e.next=41;break}return p=f.value,d=p.url,e.next=37,buildPackageMap(d,h,m,v+1);case 37:m=e.sent;case 38:s=!0,e.next=32;break;case 41:e.next=47;break;case 43:e.prev=43,e.t4=e.catch(30),u=!0,c=e.t4;case 47:e.prev=47,e.prev=48,!s&&l.return&&l.return();case 50:if(e.prev=50,!u){e.next=53;break}throw c;case 53:return e.finish(50);case 54:return e.finish(47);case 55:return e.abrupt("return",m);case 56:case"end":return e.stop()}},e,this,[[3,15],[18,24],[30,43,47,55],[48,,50,54]])}));return function(t){return e.apply(this,arguments)}}(),dependencies=Object.freeze({buildPackageMap:buildPackageMap,resolvePackageDependencies:resolvePackageDependencies,dependencyGraph:dependencyGraph}),GLOBAL="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:void 0;exports.System=exports.System||prepareSystem(GLOBAL.System);var scripting={module:module$2,ensurePackage:ensurePackage$1,registerPackage:registerPackage$1,importPackage:importPackage$1,lookupPackage:lookupPackage$1,ImportInjector:ImportInjector};exports.getSystem=getSystem,exports.removeSystem=removeSystem,exports.loadedModules=loadedModules$$1,exports.printSystemConfig=printSystemConfig$$1,exports.whenLoaded=whenLoaded$1,exports.changeSystem=changeSystem,exports.module=module$1,exports.doesModuleExist=doesModuleExist$$1,exports.isModuleLoaded=isModuleLoaded$$1,exports.importPackage=importPackage$$1,exports.registerPackage=registerPackage$$1,exports.removePackage=removePackage$1,exports.reloadPackage=reloadPackage$$1,exports.getPackages=getPackages,exports.getPackage=getPackage$$1,exports.getPackageOfModule=getPackageOfModule,exports.ensurePackage=ensurePackage$$1,exports.applyPackageConfig=applyPackageConfig,exports.lookupPackage=lookupPackage$$1,exports.moduleSourceChange=moduleSourceChange$$1,exports.requireMap=requireMap,exports.isHookInstalled=isHookInstalled,exports.installHook=installHook,exports.removeHook=removeHook,exports.wrapModuleLoad=wrapModuleLoad$$1,exports.unwrapModuleLoad=unwrapModuleLoad$$1,exports.cjs=dependencies,exports.scripting=scripting,exports.PackageRegistry=PackageRegistry$$1,exports.ExportLookup=ExportLookup,exports.semver=semver}(this.lively.modules=this.lively.modules||{},lively.lang,lively.ast,lively.notifications,lively.vm,lively.resources,lively.classes,semver),"undefined"!=typeof module&&"function"==typeof require&&(module.exports=GLOBAL.lively.modules)}();
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  if (typeof GLOBAL.lively === "undefined") GLOBAL.lively = {};
  (function() {
    this.lively = this.lively || {};
(function (exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

// A `Closure` is a representation of a JavaScript function that controls what
// values are bound to out-of-scope variables. By default JavaScript has no
// reflection capabilities over closed values in functions. When needing to
// serialize execution or when behavior should become part of the state of a
// system it is often necessary to have first-class control over this language
// aspect.
//
// Typically closures aren't created directly but with the help of [`asScriptOf`](#)
//
// Example:
// function func(a) { return a + b; }
// var closureFunc = Closure.fromFunction(func, {b: 3}).recreateFunc();
// closureFunc(4) // => 7
// var closure = closureFunc.livelyClosure // => {
// //   varMapping: { b: 3 },
// //   originalFunc: function func(a) {/*...*/}
// // }
// closure.lookup("b") // => 3
// closure.getFuncSource() // => "function func(a) { return a + b; }"

var parameterRegex = /function[^\(]*\(([^\)]*)\)|\(?([^\)=]*)\)?\s*=>/;

var Closure = function () {
  createClass(Closure, null, [{
    key: "fromFunction",
    value: function fromFunction(func, varMapping) {
      /*show-in-doc*/
      return new this(func, varMapping || {});
    }
  }, {
    key: "fromSource",
    value: function fromSource(source, varMapping) {
      /*show-in-doc*/
      return new this(null, varMapping || {}, source);
    }
  }]);

  function Closure(func, varMapping, source, funcProperties) {
    classCallCheck(this, Closure);

    this.originalFunc = func;
    this.varMapping = varMapping || {};
    this.setFuncSource(source || func);
    this.setFuncProperties(func || funcProperties);
  }

  createClass(Closure, [{
    key: "setFuncSource",


    // accessing
    value: function setFuncSource(src) {
      /*show-in-doc*/
      src = typeof lively !== "undefined" && lively.sourceTransform && typeof lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder === "function" ? lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder(src) : String(src);
      return this.source = src;
    }
  }, {
    key: "getFuncSource",
    value: function getFuncSource() {
      /*show-in-doc*/
      return this.source || this.setFuncSource(this.originalFunc);
    }
  }, {
    key: "hasFuncSource",
    value: function hasFuncSource() {
      /*show-in-doc*/
      return this.source && true;
    }
  }, {
    key: "getFunc",
    value: function getFunc() {
      /*show-in-doc*/
      return this.originalFunc || this.recreateFunc();
    }
  }, {
    key: "getFuncProperties",
    value: function getFuncProperties() {
      // ignore-in-doc
      // a function may have state attached
      return this.funcProperties || (this.funcProperties = {});
    }
  }, {
    key: "setFuncProperties",
    value: function setFuncProperties(obj) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in obj) {
        // The AST implementation assumes that Function objects are some
        // kind of value object. When their identity changes cached state
        // should not be carried over to new function instances. This is a
        // pretty intransparent way to invalidate attributes that are used
        // for caches.
        // @cschuster, can you please fix this by making invalidation more
        // explicit?
        if (obj.hasOwnProperty(name)) props[name] = obj[name];
      }
    }
  }, {
    key: "lookup",
    value: function lookup(name) {
      /*show-in-doc*/
      return this.varMapping[name];
    }
  }, {
    key: "parameterNames",
    value: function parameterNames(methodString) {
      // ignore-in-doc

      if (typeof lively !== "undefined" && lively.ast) {
        return (lively.ast.parseFunction(methodString).params || []).map(function (ea) {
          if (ea.type === "Identifier") return ea.name;
          if (ea.left && ea.left.type === "Identifier") return ea.left.name;
          return null;
        }).filter(Boolean);
      }

      var paramsMatch = parameterRegex.exec(methodString);
      if (!paramsMatch) return [];
      var paramsString = paramsMatch[1] || paramsMatch[2] || "";
      return paramsString.split(",").map(function (ea) {
        return ea.trim();
      });
    }
  }, {
    key: "firstParameter",
    value: function firstParameter(src) {
      // ignore-in-doc
      return this.parameterNames(src)[0] || null;
    }

    // -=-=-=-=-=-=-=-=-=-
    // function creation
    // -=-=-=-=-=-=-=-=-=-

  }, {
    key: "recreateFunc",
    value: function recreateFunc() {
      // Creates a real function object
      return this.recreateFuncFromSource(this.getFuncSource(), this.originalFunc);
    }
  }, {
    key: "recreateFuncFromSource",
    value: function recreateFuncFromSource(funcSource, optFunc) {
      // ignore-in-doc
      // what about objects that are copied by value, e.g. numbers?
      // when those are modified after the originalFunc we captured
      // varMapping then we will have divergent state
      var closureVars = [],
          thisFound = false,
          specificSuperHandling = this.firstParameter(funcSource) === '$super';
      for (var name in this.varMapping) {
        if (!this.varMapping.hasOwnProperty(name)) continue;
        if (name == 'this') {
          thisFound = true;continue;
        }
        // closureVars.push(`var ${name} = this.varMapping.${name};\n`);
        closureVars.push("var " + name + " = this.varMapping." + name + ";\n");
      }

      var src = "";
      if (closureVars.length > 0) src += closureVars.join("\n");
      if (specificSuperHandling) src += '(function superWrapperForClosure() { return ';
      src += "(" + funcSource + ")";
      if (specificSuperHandling) src += '.apply(this, [$super.bind(this)]' + '.concat(Array.from(arguments))) })';
      try {
        var func = evalJS.call(this, src) || this.couldNotCreateFunc(src);
        this.addFuncProperties(func);
        this.originalFunc = func;
        return func;
      } catch (e) {
        // var msg = `Cannot create function ${e} src: ${src}`;
        var msg = "Cannot create function " + e + " src: " + src;
        console.error(msg);
        throw new Error(msg);
      }
    }
  }, {
    key: "addFuncProperties",
    value: function addFuncProperties(func) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in props) {
        if (props.hasOwnProperty(name)) func[name] = props[name];
      }this.addClosureInformation(func);
    }
  }, {
    key: "couldNotCreateFunc",
    value: function couldNotCreateFunc(src) {
      // ignore-in-doc
      var msg = 'Could not recreate closure from source: \n' + src;
      console.error(msg);
      return function () {
        throw new Error(msg);
      };
    }

    // -=-=-=-=-=-
    // conversion
    // -=-=-=-=-=-

  }, {
    key: "asFunction",
    value: function asFunction() {
      /*ignore-in-doc*/
      return this.recreateFunc();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-
    // function modification
    // -=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "addClosureInformation",
    value: function addClosureInformation(f) {
      /*ignore-in-doc-in-doc*/
      f.hasLivelyClosure = true;
      f.livelyClosure = this;
      return f;
    }
  }, {
    key: "isLivelyClosure",
    get: function get() {
      return true;
    }

    // serialization

  }, {
    key: "doNotSerialize",
    get: function get() {
      return ['originalFunc'];
    }
  }]);
  return Closure;
}();

/*global clearTimeout, setTimeout*/

/*
 * Abstractions around first class functions like augmenting and inspecting
 * functions as well as to control function calls like dealing with asynchronous
 * control flows.
 */

// -=-=-=-=-=-=-=-=-
// static functions
// -=-=-=-=-=-=-=-=-

function Empty() {
  /*`function() {}`*/return function () {};
}
function K() {
  /*`function(arg) { return arg; }`*/return function (arg) {
    return arg;
  };
}
function Null() {
  /*`function() { return null; }`*/return function () {
    return null;
  };
}
function False() {
  /*`function() { return false; }`*/return function () {
    return false;
  };
}
function True() {
  /*`function() { return true; }`*/return function () {
    return true;
  };
}
function notYetImplemented() {
  return function () {
    throw new Error('Not yet implemented');
  };
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-
function all(object) {
  // Returns all property names of `object` that reference a function.
  // Example:
  // var obj = {foo: 23, bar: function() { return 42; }};
  // all(obj) // => ["bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

function own(object) {
  // Returns all local (non-prototype) property names of `object` that
  // reference a function.
  // Example:
  // var obj1 = {foo: 23, bar: function() { return 42; }};
  // var obj2 = {baz: function() { return 43; }};
  // obj2.__proto__ = obj1
  // own(obj2) // => ["baz"]
  // /*vs.*/ all(obj2) // => ["baz","bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && object.hasOwnProperty(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-

function argumentNames(f) {
  // Example:
  // argumentNames(function(arg1, arg2) {}) // => ["arg1","arg2"]
  // argumentNames(function(/*var args*/) {}) // => []
  if (f.superclass) return []; // it's a class...
  var src = f.toString(),
      names = "",
      arrowMatch = src.match(/(?:\(([^\)]*)\)|([^\(\)-+!]+))\s*=>/);
  if (arrowMatch) names = arrowMatch[1] || arrowMatch[2] || "";else {
    var headerMatch = src.match(/^[\s\(]*function[^(]*\(([^)]*)\)/);
    if (headerMatch && headerMatch[1]) names = headerMatch[1];
  }
  return names.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',').map(function (ea) {
    return ea.trim();
  }).filter(function (name) {
    return !!name;
  });
}

function qualifiedMethodName(f) {
  // ignore-in-doc
  var objString = "";
  if (f.declaredClass) {
    objString += f.declaredClass + '>>';
  } else if (f.declaredObject) {
    objString += f.declaredObject + '.';
  }
  return objString + (f.methodName || f.displayName || f.name || "anonymous");
}

function extractBody(func) {

  // superflous indent. Useful when you have to stringify code but not want
  // to construct strings by hand.
  // Example:
  // extractBody(function(arg) {
  //   var x = 34;
  //   alert(2 + arg);
  // }) => "var x = 34;\nalert(2 + arg);"
  var codeString = String(func).replace(/^function[^\{]+\{\s*/, '').replace(/\}$/, '').trim(),
      lines = codeString.split(/\n|\r/),
      indent = undefined;
  for (var i = 0; i < lines.length; i++) {
    var m = lines[i].match(/^(\s+)[^\s]/);
    if (m && (indent === undefined || m[1].length < indent.length)) indent = m[1];
  }
  return indent ? codeString.replace(new RegExp("^" + indent, 'gm'), '') : codeString;
}

// -=-=-=-
// timing
// -=-=-=-

function timeToRun(func) {
  // returns synchronous runtime of calling `func` in ms
  // Example:
  // timeToRun(function() { new WebResource("http://google.de").beSync().get() });
  // // => 278 (or something else...)
  var startTime = Date.now();
  func();
  return Date.now() - startTime;
}

function timeToRunN$1(func, n) {
  // Like `timeToRun` but calls function `n` times instead of once. Returns
  // the average runtime of a call in ms.
  var startTime = Date.now();
  for (var i = 0; i < n; i++) {
    func();
  }return (Date.now() - startTime) / n;
}

function delay(func, timeout /*, arg1...argN*/) {
  // Delays calling `func` for `timeout` seconds(!).
  // Example:
  // (function() { alert("Run in the future!"); }).delay(1);
  var args = Array.prototype.slice.call(arguments),
      __method = args.shift(),
      timeout = args.shift() * 1000;
  return setTimeout(function delayed() {
    return __method.apply(__method, args);
  }, timeout);
}

// these last two methods are Underscore.js 1.3.3 and are slightly adapted
// Underscore.js license:
// (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
// Underscore is distributed under the MIT license.

function throttle(func, wait) {
  // Exec func at most once every wait ms even when called more often
  // useful to calm down eagerly running updaters and such.
  // Example:
  // var i = 0;
  // var throttled = throttle(function() { alert(++i + '-' + Date.now()) }, 500);
  // Array.range(0,100).forEach(function(n) { throttled() });
  var context,
      args,
      timeout,
      throttling,
      more,
      result,
      whenDone = debounce(wait, function () {
    more = throttling = false;
  });
  return function () {
    context = this;args = arguments;
    var later = function later() {
      timeout = null;
      if (more) func.apply(context, args);
      whenDone();
    };
    if (!timeout) timeout = setTimeout(later, wait);
    if (throttling) {
      more = true;
    } else {
      result = func.apply(context, args);
    }
    whenDone();
    throttling = true;
    return result;
  };
}

function debounce(wait, func, immediate) {
  // Call `func` after `wait` milliseconds elapsed since the last invocation.
  // Unlike `throttle` an invocation will restart the wait period. This is
  // useful if you have a stream of events that you want to wait for to finish
  // and run a subsequent function afterwards. When you pass arguments to the
  // debounced functions then the arguments from the last call will be use for
  // the invocation.
  //
  // With `immediate` set to true, immediately call `func` but when called again during `wait` before
  // wait ms are done nothing happens. E.g. to not exec a user invoked
  // action twice accidentally.
  // Example:
  // var start = Date.now();
  // var f = debounce(200, function(arg1) {
  //   alert("running after " + (Date.now()-start) + "ms with arg " + arg1);
  // });
  // f("call1");
  // delay(f.curry("call2"), 0.1);
  // delay(f.curry("call3"), 0.15);
  // // => Will eventually output: "running after 352ms with arg call3"
  var timeout;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    if (immediate && !timeout) func.apply(context, args);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

var _throttledByName = {};
function throttleNamed(name, wait, func) {
  // Like `throttle` but remembers the throttled function once created and
  // repeated calls to `throttleNamed` with the identical name will use the same
  // throttled function. This allows to throttle functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the throttled function.
  var store = _throttledByName;
  if (store[name]) return store[name];
  function throttleNamedWrapper() {
    // ignore-in-doc, cleaning up
    debounceNamed(name, wait, function () {
      delete store[name];
    })();
    func.apply(this, arguments);
  }
  return store[name] = throttle(throttleNamedWrapper, wait);
}

var _debouncedByName = {};
function debounceNamed(name, wait, func, immediate) {
  // Like `debounce` but remembers the debounced function once created and
  // repeated calls to `debounceNamed` with the identical name will use the same
  // debounced function. This allows to debounce functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the debounced function.
  var store = _debouncedByName;
  if (store[name]) return store[name];
  function debounceNamedWrapper() {
    // ignore-in-doc, cleaning up
    delete store[name];
    func.apply(this, arguments);
  }
  return store[name] = debounce(wait, debounceNamedWrapper, immediate);
}

var _queues = {};
function createQueue(id, workerFunc) {
  // A simple queue with an attached asynchronous `workerFunc` to process
  // queued tasks. Calling `createQueue` will return an object with the
  // following interface:
  // ```js
  // {
  //   push: function(task) {/**/},
  //   pushAll: function(tasks) {/**/},
  //   handleError: function(err) {}, // Overwrite to handle errors
  //   dran: function() {}, // Overwrite to react when the queue empties
  // }
  // Example:
  // var sum = 0;
  // var q = createQueue("example-queue", function(arg, thenDo) { sum += arg; thenDo(); });
  // q.pushAll([1,2,3]);
  // queues will be remembered by their name
  // createQueue("example-queue").push(4);
  // sum // => 6

  var store = _queues;

  var queue = store[id] || (store[id] = {
    _workerActive: false,
    worker: workerFunc, tasks: [],
    drain: null, // can be overwritten by a function
    push: function push(task) {
      queue.tasks.push(task);
      queue.activateWorker();
    },
    pushAll: function pushAll(tasks) {
      tasks.forEach(function (ea) {
        queue.tasks.push(ea);
      });
      queue.activateWorker();
    },
    pushNoActivate: function pushNoActivate(task) {
      queue.tasks.push(task);
    },
    handleError: function handleError(err) {
      // can be overwritten
      err && console.error('Error in queue: ' + err);
    },
    activateWorker: function activateWorker() {
      function callback(err) {
        queue.handleError(err);queue.activateWorker();
      }
      var tasks = queue.tasks,
          active = queue._workerActive;
      if (tasks.length === 0) {
        if (active) {
          queue._workerActive = false;
          if (typeof queue.drain === 'function') queue.drain();
        }
        delete store[id];
      } else {
        if (!active) queue._workerActive = true;
        try {
          queue.worker(tasks.shift(), callback);
        } catch (err) {
          callback(err);
        }
      }
    }
  });

  return queue;
}

var _queueUntilCallbacks = {};
function workerWithCallbackQueue(id, workerFunc, optTimeout) {
  // This functions helps when you have a long running computation that
  // multiple call sites (independent from each other) depend on. This
  // function does the housekeeping to start the long running computation
  // just once and returns an object that allows to schedule callbacks
  // once the workerFunc is done.
  // Example:
  // var worker = workerWithCallbackQueue("example",
  //   function slowFunction(thenDo) {
  //     var theAnswer = 42;
  //     setTimeout(function() { thenDo(null, theAnswer); });
  //   });
  // // all "call sites" depend on `slowFunction` but don't have to know about
  // // each other
  // worker.whenDone(function callsite1(err, theAnswer) { alert("callback1: " + theAnswer); })
  // worker.whenDone(function callsite2(err, theAnswer) { alert("callback2: " + theAnswer); })
  // workerWithCallbackQueue("example").whenDone(function callsite3(err, theAnswer) { alert("callback3: " + theAnswer); })
  // // => Will eventually show: callback1: 42, callback2: 42 and callback3: 42


  // ignore-in-doc
  // This is how it works:
  // If `id` does not exist, workerFunc is called, otherwise ignored.
  // workerFunc is expected to call thenDoFunc with arguments: error, arg1, ..., argN
  // if called subsequently before workerFunc is done, the other thenDoFunc
  // will "pile up" and called with the same arguments as the first
  // thenDoFunc once workerFunc is done
  var store = _queueUntilCallbacks,
      queueCallbacks = store[id],
      isRunning = !!queueCallbacks;

  if (isRunning) return queueCallbacks;

  var callbacksRun = false,
      canceled = false;

  function cleanup() {
    if (timeoutProc) clearTimeout(timeoutProc);
    callbacksRun = true;
    delete store[id];
  }

  function runCallbacks(args) {
    if (callbacksRun) return;
    cleanup();
    queueCallbacks.callbacks.forEach(function (cb) {
      try {
        cb.apply(null, args);
      } catch (e) {
        console.error("Error when invoking callbacks in queueUntil [" + id + "]:\n" + String(e.stack || e));
      }
    });
  }

  // timeout
  if (optTimeout) {
    var timeoutProc = setTimeout(function () {
      if (callbacksRun) return;
      runCallbacks([new Error("timeout")]);
    }, optTimeout);
  }

  // init the store
  queueCallbacks = store[id] = {
    callbacks: [],
    cancel: function cancel() {
      canceled = true;
      cleanup();
    },
    whenDone: function whenDone(cb) {
      queueCallbacks.callbacks.push(cb);
      return queueCallbacks;
    }
  };

  // call worker, but delay so we can immediately return
  setTimeout(function () {
    if (canceled) return;
    try {
      workerFunc(function () /*args*/{
        runCallbacks(arguments);
      });
    } catch (e) {
      runCallbacks([e]);
    }
  }, 0);

  return queueCallbacks;
}

function _composeAsyncDefaultEndCallback(err, arg1 /*err + args*/) {
  if (err) console.error("lively.lang.composeAsync error", err);
}

function composeAsync() /*functions*/{
  // Composes functions that are asynchronous and expecting continuations to
  // be called in node.js callback style (error is first argument, real
  // arguments follow).
  // A call like `composeAsync(f,g,h)(arg1, arg2)` has a flow of control like:
  //  `f(arg1, arg2, thenDo1)` -> `thenDo1(err, fResult)`
  // -> `g(fResult, thenDo2)` -> `thenDo2(err, gResult)` ->
  // -> `h(fResult, thenDo3)` -> `thenDo2(err, hResult)`
  // Example:
  // composeAsync(
  //   function(a,b, thenDo) { thenDo(null, a+b); },
  //   function(x, thenDo) { thenDo(x*4); }
  //  )(3,2, function(err, result) { alert(result); });

  var toArray$$1 = Array.prototype.slice,
      functions = toArray$$1.call(arguments),
      defaultEndCb = _composeAsyncDefaultEndCallback,
      endCallback = defaultEndCb,
      endSuccess,
      endFailure,
      endPromise = new Promise(function (resolve, reject) {
    endSuccess = resolve;endFailure = reject;
  });

  return functions.reverse().reduce(function (prevFunc, funcOrPromise, i) {

    var nextActivated = false;
    return function () {
      var args = toArray$$1.call(arguments);

      // ignore-in-doc
      // the last arg needs to be function, discard all non-args
      // following it. This allows to have an optional callback func that can
      // even be `undefined`, e.g. when calling this func from a callsite
      // using var args;
      if (endCallback === defaultEndCb && i === functions.length - 1 /*first function*/) {
          while (args.length && typeof args[args.length - 1] !== 'function') {
            args.pop();
          }if (typeof args[args.length - 1] === 'function') endCallback = args.pop();
        }

      function next() /*err and args*/{
        nextActivated = true;
        var args = toArray$$1.call(arguments),
            err = args.shift();
        if (err) {
          endCallback(err);endFailure(err);
        } else prevFunc.apply(null, args);
      }

      if (typeof funcOrPromise === "function") {
        try {
          var result = funcOrPromise.apply(this, args.concat([next]));
          if (result && typeof result.then === "function" && typeof result.catch === "function") {
            result.then(function (value) {
              return next(null, value);
            }).catch(function (err) {
              return next(err);
            });
          }
        } catch (e) {
          console.error('composeAsync: ', e.stack || e);
          if (!nextActivated) {
            endCallback(e);endFailure(e);
          }
        }
      } else if (funcOrPromise && typeof funcOrPromise.then === "function" && typeof funcOrPromise.catch === "function") {
        funcOrPromise.then(function (value) {
          next(null, value);
        }).catch(function (err) {
          next(err);
        });
      } else {
        var err = new Error("Invalid argument to composeAsync: " + funcOrPromise);
        endCallback(err);
        endFailure(err);
      }

      return endPromise;
    };
  }, function () {
    var args = toArray$$1.call(arguments);
    endCallback.apply(null, [null].concat(args));
    endSuccess(args[0]);
  });
}

function compose() /*functions*/{
  // Composes synchronousefunctions:
  // `compose(f,g,h)(arg1, arg2)` = `h(g(f(arg1, arg2)))`
  // Example:
  // compose(
  //   function(a,b) { return a+b; },
  //   function(x) {return x*4}
  // )(3,2) // => 20

  var functions = Array.prototype.slice.call(arguments);
  return functions.reverse().reduce(function (prevFunc, func) {
    return function () {
      return prevFunc(func.apply(this, arguments));
    };
  }, function (x) {
    return x;
  });
}

function flip(f) {
  // Swaps the first two args
  // Example:
  // flip(function(a, b, c) {
  //   return a + b + c; })(' World', 'Hello', '!') // => "Hello World!"
  return function flipped() /*args*/{
    var args = Array.prototype.slice.call(arguments),
        flippedArgs = [args[1], args[0]].concat(args.slice(2));
    return f.apply(null, flippedArgs);
  };
}

function withNull(func) {
  // returns a modified version of func that will have `null` always curried
  // as first arg. Usful e.g. to make a nodejs-style callback work with a
  // then-able:
  // Example:
  // promise.then(withNull(cb)).catch(cb);
  func = func || function () {};
  return function () /*args*/{
    var args = lively.lang.arr.from(arguments);
    func.apply(null, [null].concat(args));
  };
}

function waitFor(timeoutMs, waitTesterFunc, thenDo) {
  // Wait for waitTesterFunc to return true, then run thenDo, passing
  // failure/timout err as first parameter. A timout occurs after
  // timeoutMs. During the wait period waitTesterFunc might be called
  // multiple times.
  var start = Date.now();
  var timeStep = 50;
  if (!thenDo) {
    thenDo = waitTesterFunc;
    waitTesterFunc = timeoutMs;
    timeoutMs = undefined;
  }
  (function test() {
    if (waitTesterFunc()) return thenDo();
    if (timeoutMs) {
      var duration = Date.now() - start,
          timeLeft = timeoutMs - duration;
      if (timeLeft <= 0) return thenDo(new Error('timeout'));
      if (timeLeft < timeStep) timeStep = timeLeft;
    }
    setTimeout(test, timeStep);
  })();
}

function waitForAll(options, funcs, thenDo) {
  // Wait for multiple asynchronous functions. Once all have called the
  // continuation, call `thenDo`.
  // options can be: `{timeout: NUMBER}` (how long to wait in milliseconds).

  if (!thenDo) {
    thenDo = funcs;funcs = options;options = null;
  }
  options = options || {};

  var results = funcs.map(function () {
    return null;
  });
  if (!funcs.length) {
    thenDo(null, results);return;
  }

  var leftFuncs = Array.prototype.slice.call(funcs);

  funcs.forEach(function (f, i) {
    try {
      f(function () /*err and args*/{
        var args = Array.prototype.slice.call(arguments);
        var err = args.shift();
        markAsDone(f, i, err, args);
      });
    } catch (e) {
      markAsDone(f, i, e, null);
    }
  });

  if (options.timeout) {
    setTimeout(function () {
      if (!leftFuncs.length) return;
      var missing = results.map(function (ea, i) {
        return ea === null && i;
      }).filter(function (ea) {
        return typeof ea === 'number';
      }).join(', ');
      var err = new Error("waitForAll timed out, functions at " + missing + " not done");
      markAsDone(null, null, err, null);
    }, options.timeout);
  }

  function markAsDone(f, i, err, result) {
    if (!leftFuncs.length) return;

    var waitForAllErr = null;
    var fidx = leftFuncs.indexOf(f);
    fidx > -1 && leftFuncs.splice(fidx, 1);
    if (err) {
      leftFuncs.length = 0;
      waitForAllErr = new Error("in waitForAll at" + (typeof i === 'number' ? " " + i : "") + ": \n" + (err.stack || String(err)));
    } else if (result) results[i] = result;
    if (!leftFuncs.length) setTimeout(function () {
      thenDo(waitForAllErr, results);
    }, 0);
  }
}

// -=-=-=-=-
// wrapping
// -=-=-=-=-

function curry(func, arg1, arg2, argN /*func and curry args*/) {
  // Return a version of `func` with args applied.
  // Example:
  // var add1 = (function(a, b) { return a + b; }).curry(1);
  // add1(3) // => 4

  if (arguments.length <= 1) return arguments[0];
  var args = Array.prototype.slice.call(arguments),
      func = args.shift();
  function wrappedFunc() {
    return func.apply(this, args.concat(Array.prototype.slice.call(arguments)));
  }
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = func;
  return wrappedFunc;
}

function wrap(func, wrapper) {
  // A `wrapper` is another function that is being called with the arguments
  // of `func` and a proceed function that, when called, runs the originally
  // wrapped function.
  // Example:
  // function original(a, b) { return a+b }
  // var wrapped = wrap(original, function logWrapper(proceed, a, b) {
  //   alert("original called with " + a + "and " + b);
  //   return proceed(a, b);
  // })
  // wrapped(3,4) // => 7 and a message will pop up
  var __method = func;
  var wrappedFunc = function wrapped() {
    var args = Array.prototype.slice.call(arguments);
    var wrapperArgs = wrapper.isWrapper ? args : [__method.bind(this)].concat(args);
    return wrapper.apply(this, wrapperArgs);
  };
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = __method;
  return wrappedFunc;
}

function getOriginal(func) {
  // Get the original function that was augmented by `wrap`. `getOriginal`
  // will traversed as many wrappers as necessary.
  while (func.originalFunction) {
    func = func.originalFunction;
  }return func;
}

function wrapperChain(method) {
  // Function wrappers used for wrapping, cop, and other method
  // manipulations attach a property "originalFunction" to the wrapper. By
  // convention this property references the wrapped method like wrapper
  // -> cop wrapper -> real method.
  // tThis method gives access to the linked list starting with the outmost
  // wrapper.
  var result = [];
  do {
    result.push(method);
    method = method.originalFunction;
  } while (method);
  return result;
}

function replaceMethodForOneCall(obj, methodName, replacement) {
  // Change an objects method for a single invocation.
  // Example:
  // var obj = {foo: function() { return "foo"}};
  // lively.lang.replaceMethodForOneCall(obj, "foo", function() { return "bar"; });
  // obj.foo(); // => "bar"
  // obj.foo(); // => "foo"
  replacement.originalFunction = obj[methodName];
  var reinstall = obj.hasOwnProperty(methodName);
  obj[methodName] = function () {
    if (reinstall) obj[methodName] = replacement.originalFunction;else delete obj[methodName];
    return replacement.apply(this, arguments);
  };
  return obj;
}

function once(func) {
  // Ensure that `func` is only executed once. Multiple calls will not call
  // `func` again but will return the original result.
  if (!func) return undefined;
  if (typeof func !== 'function') throw new Error("once() expecting a function");
  var invoked = false,
      result;
  return function () {
    if (invoked) return result;
    invoked = true;
    return result = func.apply(this, arguments);
  };
}

function either() /*funcs*/{
  // Accepts multiple functions and returns an array of wrapped
  // functions. Those wrapped functions ensure that only one of the original
  // function is run (the first on to be invoked).
  //
  // This is useful if you have multiple asynchronous choices of how the
  // control flow might continue but want to ensure that a continuation
  // is  only triggered once, like in a timeout situation:
  //
  // ```js
  // function outerFunction(callback) {
  //   function timeoutAction() { callback(new Error('timeout!')); }
  //   function otherAction() { callback(null, "All OK"); }
  //   setTimeout(timeoutAction, 200);
  //   doSomethingAsync(otherAction);
  // }
  // ```
  //
  // To ensure that `callback` only runs once you would normally have to write boilerplate like this:
  //
  // ```js
  // var ran = false;
  // function timeoutAction() { if (ran) return; ran = true; callback(new Error('timeout!')); }
  // function otherAction() { if (ran) return; ran = true; callback(null, "All OK"); }
  // ```
  //
  // Since this can get tedious an error prone, especially if more than two choices are involved, `either` can be used like this:
  // Example:
  // function outerFunction(callback) {
  //   var actions = either(
  //     function() { callback(new Error('timeout!')); },
  //     function() { callback(null, "All OK"); });
  //   setTimeout(actions[0], 200);
  //   doSomethingAsync(actions[1]);
  // }
  var funcs = Array.prototype.slice.call(arguments),
      wasCalled = false;
  return funcs.map(function (func) {
    return function () {
      if (wasCalled) return undefined;
      wasCalled = true;
      return func.apply(this, arguments);
    };
  });
}

var _eitherNameRegistry = {};
function eitherNamed(name, func) {
  // Works like [`either`](#) but usage does not require to wrap all
  // functions at once:
  // Example:
  // var log = "", name = "either-example-" + Date.now();
  // function a() { log += "aRun"; };
  // function b() { log += "bRun"; };
  // function c() { log += "cRun"; };
  // setTimeout(eitherNamed(name, a), 100);
  // setTimeout(eitherNamed(name, b), 40);
  // setTimeout(eitherNamed(name, c), 80);
  // setTimeout(function() { alert(log); /* => "bRun" */ }, 150);
  var funcs = Array.prototype.slice.call(arguments);
  var registry = _eitherNameRegistry;
  var name = funcs.shift();
  var eitherCall = registry[name] || (registry[name] = { wasCalled: false, callsLeft: 0 });
  eitherCall.callsLeft++;
  return function () {
    eitherCall.callsLeft--;
    // cleanup the storage if all registered functions fired
    if (eitherCall.callsLeft <= 0) delete registry[name];
    if (eitherCall.wasCalled) return undefined;
    eitherCall.wasCalled = true;
    return func.apply(this, arguments);
  };
}

// -=-=-=-=-
// creation
// -=-=-=-=-
function evalJS(src) {
  return eval(src);
}

function fromString(funcOrString) {
  // Example:
  // fromString("function() { return 3; }")() // => 3
  return evalJS('(' + funcOrString.toString() + ');');
}

function asScript(func, optVarMapping) {
  // Lifts `func` to become a `Closure`, that is that free variables referenced
  // in `func` will be bound to the values of an object that can be passed in as
  // the second parameter. Keys of this object are mapped to the free variables.
  //
  // Please see [`Closure`](#) for a more detailed explanation and examples.
  return Closure.fromFunction(func, optVarMapping).recreateFunc();
}

function asScriptOf(f, obj, optName, optMapping) {
  // Like `asScript` but makes `f` a method of `obj` as `optName` or the name
  // of the function.
  var name = optName || f.name;
  if (!name) {
    throw Error("Function that wants to be a script needs a name: " + this);
  }
  var proto = Object.getPrototypeOf(obj),
      mapping = { "this": obj };
  if (optMapping) mapping = merge([mapping, optMapping]);
  if (proto && proto[name]) {
    var superFunc = function superFunc() {
      try {
        // FIXME super is supposed to be static
        return Object.getPrototypeOf(obj)[name].apply(obj, arguments);
      } catch (e) {
        if ((typeof $world === "undefined" ? "undefined" : _typeof($world)) !== undefined) $world.logError(e, 'Error in $super call');else console.error('Error in $super call: ' + e + '\n' + e.stack);
        return null;
      }
    };
    mapping["$super"] = Closure.fromFunction(superFunc, { obj: obj, name: name }).recreateFunc();
  }
  return addToObject(asScript(f, mapping), obj, name);
}

// -=-=-=-=-=-=-=-=-
// closure related
// -=-=-=-=-=-=-=-=-
function addToObject(f, obj, name) {
  // ignore-in-doc
  f.displayName = name;

  var methodConnections = obj.attributeConnections ? obj.attributeConnections.filter(function (con) {
    return con.getSourceAttrName() === 'update';
  }) : [];

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.disconnect();
  });

  obj[name] = f;

  if (typeof obj === "undefined" ? "undefined" : _typeof(obj)) f.declaredObject = safeToString(obj);

  // suppport for tracing
  if (typeof lively !== "undefined" && obj && lively.Tracing && lively.Tracing.stackTracingEnabled) {
    lively.Tracing.instrumentMethod(obj, name, {
      declaredObject: safeToString(obj)
    });
  }

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.connect();
  });

  return f;
}

function binds(f, varMapping) {
  // ignore-in-doc
  // convenience function
  return Closure.fromFunction(f, varMapping || {}).recreateFunc();
}

function setLocalVarValue(f, name, value) {
  // ignore-in-doc
  if (f.hasLivelyClosure) f.livelyClosure.funcProperties[name] = value;
}

function getVarMapping(f) {
  // ignore-in-doc
  if (f.hasLivelyClosure) return f.livelyClosure.varMapping;
  if (f.isWrapper) return f.originalFunction.varMapping;
  if (f.varMapping) return f.varMapping;
  return {};
}

function setProperty(func, name, value) {
  func[name] = value;
  if (func.hasLivelyClosure) func.livelyClosure.funcProperties[name] = value;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// class-related functions
// -=-=-=-=-=-=-=-=-=-=-=-=-
function functionNames(klass) {
  // Treats passed function as class (constructor).
  // Example:
  // var Klass1 = function() {}
  // Klass1.prototype.foo = function(a, b) { return a + b; };
  // Klass1.prototype.bar = function(a) { return this.foo(a, 3); };
  // Klass1.prototype.baz = 23;
  // functionNames(Klass1); // => ["bar","foo"]

  var result = [],
      lookupObj = klass.prototype;
  while (lookupObj) {
    result = Object.keys(lookupObj).reduce(function (result, name) {
      if (typeof lookupObj[name] === 'function' && result.indexOf(name) === -1) result.push(name);
      return result;
    }, result);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function localFunctionNames(func) {
  return Object.keys(func.prototype).filter(function (name) {
    return typeof func.prototype[name] === 'function';
  });
}

// -=-=-=-=-=-=-=-=-=-=-
// tracing and logging
// -=-=-=-=-=-=-=-=-=-=-

function logErrors(func, prefix) {
  var advice = function logErrorsAdvice(proceed /*,args*/) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      return proceed.apply(func, args);
    } catch (er) {
      if (typeof lively !== "undefined" && lively.morphic && lively.morphic.World && lively.morphic.World.current()) {
        lively.morphic.World.current().logError(er);
        throw er;
      }

      if (prefix) console.warn("ERROR: %s.%s(%s): err: %s %s", func, prefix, args, er, er.stack || "");else console.warn("ERROR: %s %s", er, er.stack || "");
      throw er;
    }
  };

  advice.methodName = "$logErrorsAdvice";
  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logErrorsWrapper";
  return result;
}

function logCompletion(func, module) {
  var advice = function logCompletionAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      var result = proceed.apply(func, args);
    } catch (er) {
      console.warn('failed to load ' + module + ': ' + er);
      if (typeof lively !== 'undefined' && lively.lang.Execution) lively.lang.Execution.showStack();
      throw er;
    }
    console.log('completed ' + module);
    return result;
  };

  advice.methodName = "$logCompletionAdvice::" + module;

  var result = wrap(func, advice);
  result.methodName = "$logCompletionWrapper::" + module;
  result.originalFunction = func;
  return result;
}

function logCalls(func, isUrgent) {
  var original = func,
      advice = function logCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift(), result = proceed.apply(func, args);
    if (isUrgent) {
      console.warn('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    } else {
      console.log('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    }
    return result;
  };

  advice.methodName = "$logCallsAdvice::" + qualifiedMethodName(func);

  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logCallsWrapper::" + qualifiedMethodName(func);
  return result;
}

function traceCalls(func, stack) {
  var advice = function traceCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    stack.push(args);
    var result = proceed.apply(func, args);
    stack.pop();
    return result;
  };
  return wrap(func, advice);
}

function webkitStack() {
  // this won't work in every browser
  try {
    throw new Error();
  } catch (e) {
    // remove "Error" and this function from stack, rewrite it nicely
    return String(e.stack).split(/\n/).slice(2).map(function (line) {
      return line.replace(/^\s*at\s*([^\s]+).*/, '$1');
    }).join('\n');
  }
}



var fun = Object.freeze({
	Empty: Empty,
	K: K,
	Null: Null,
	False: False,
	True: True,
	notYetImplemented: notYetImplemented,
	withNull: withNull,
	all: all,
	own: own,
	argumentNames: argumentNames,
	qualifiedMethodName: qualifiedMethodName,
	extractBody: extractBody,
	timeToRun: timeToRun,
	timeToRunN: timeToRunN$1,
	delay: delay,
	throttle: throttle,
	debounce: debounce,
	throttleNamed: throttleNamed,
	debounceNamed: debounceNamed,
	createQueue: createQueue,
	workerWithCallbackQueue: workerWithCallbackQueue,
	composeAsync: composeAsync,
	compose: compose,
	waitFor: waitFor,
	waitForAll: waitForAll,
	flip: flip,
	curry: curry,
	wrap: wrap,
	binds: binds,
	getOriginal: getOriginal,
	wrapperChain: wrapperChain,
	replaceMethodForOneCall: replaceMethodForOneCall,
	once: once,
	either: either,
	eitherNamed: eitherNamed,
	evalJS: evalJS,
	fromString: fromString,
	asScript: asScript,
	asScriptOf: asScriptOf,
	addToObject: addToObject,
	setLocalVarValue: setLocalVarValue,
	getVarMapping: getVarMapping,
	setProperty: setProperty,
	functionNames: functionNames,
	localFunctionNames: localFunctionNames,
	logErrors: logErrors,
	logCompletion: logCompletion,
	logCalls: logCalls,
	traceCalls: traceCalls,
	webkitStack: webkitStack
});

// show-in-doc
// A Grouping is created by arr.groupBy and maps keys to Arrays.

var Group = function () {
  function Group() {
    classCallCheck(this, Group);
  }

  createClass(Group, [{
    key: "toArray",
    value: function toArray() {
      // Example:
      // var group = arr.groupBy([1,2,3,4,5], function(n) { return n % 2; })
      // group.toArray(); // => [[2,4],[1,3,5]]
      return this.reduceGroups(function (all$$1, _, group) {
        return all$$1.concat([group]);
      }, []);
    }
  }, {
    key: "forEach",
    value: function forEach(iterator, context) {
      // Iteration for each item in each group, called like `iterator(groupKey, groupItem)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        groups[groupName].forEach(iterator.bind(context, groupName));
      });
      return groups;
    }
  }, {
    key: "forEachGroup",
    value: function forEachGroup(iterator, context) {
      // Iteration for each group, called like `iterator(groupKey, group)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        iterator.call(context, groupName, groups[groupName]);
      });
      return groups;
    }
  }, {
    key: "map",
    value: function map(iterator, context) {
      // Map for each item in each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = group.map(iterator.bind(context, groupName));
      });
      return result;
    }
  }, {
    key: "mapGroups",
    value: function mapGroups(iterator, context) {
      // Map for each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = iterator.call(context, groupName, group);
      });
      return result;
    }
  }, {
    key: "keys",
    value: function keys() {
      // show-in-docs
      return Object.keys(this);
    }
  }, {
    key: "reduceGroups",
    value: function reduceGroups(iterator, carryOver, context) {
      // Reduce/fold for each group, called like `iterator(carryOver, groupKey, group)`
      this.forEachGroup(function (groupName, group) {
        carryOver = iterator.call(context, carryOver, groupName, group);
      });
      return carryOver;
    }
  }, {
    key: "count",
    value: function count() {
      // counts the elements of each group
      return this.reduceGroups(function (groupCount, groupName, group) {
        groupCount[groupName] = group.length;
        return groupCount;
      }, {});
    }
  }], [{
    key: "fromArray",
    value: function fromArray(array, hashFunc, context) {
      // Example:
      // Group.fromArray([1,2,3,4,5,6], function(n) { return n % 2; })
      // // => {"0": [2,4,6], "1": [1,3,5]}
      var grouping = new Group();
      for (var i = 0, len = array.length; i < len; i++) {
        var hash = hashFunc.call(context, array[i], i);
        if (!grouping[hash]) grouping[hash] = [];
        grouping[hash].push(array[i]);
      }
      return grouping;
    }
  }, {
    key: "by",
    get: function get() {
      return groupBy;
    }
  }]);
  return Group;
}();

/*global System, global*/

/*
 * Methods to make working with arrays more convenient and collection-like
 * abstractions for groups, intervals, grids.
 */

var GLOBAL$1 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

var features$1 = {
  from: !!Array.from,
  filter: !!Array.prototype.filter,
  find: !!Array.prototype.find,
  findIndex: !!Array.prototype.findIndex,
  includes: !!Array.prototype.includes

  // variety of functions for Arrays


  // -=-=-=-=-=-=-=-
  // array creations
  // -=-=-=-=-=-=-=-

};function range(begin, end, step) {
  // Examples:
  //   arr.range(0,5) // => [0,1,2,3,4,5]
  //   arr.range(0,10,2) // => [0,2,4,6,8,10]
  step = step || 0;
  var result = [];
  if (begin <= end) {
    if (step <= 0) step = -step || 1;
    for (var i = begin; i <= end; i += step) {
      result.push(i);
    }
  } else {
    if (step >= 0) step = -step || -1;
    for (var i = begin; i >= end; i += step) {
      result.push(i);
    }
  }
  return result;
}

var from = features$1.from ? Array.from : function (iterable) {
  // Makes JS arrays out of array like objects like `arguments` or DOM `childNodes`
  if (!iterable) return [];
  if (Array.isArray(iterable)) return iterable;
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length,
      results = new Array(length);
  while (length--) {
    results[length] = iterable[length];
  }return results;
};

function withN(n, obj) {
  // Example:
  //   arr.withN(3, "Hello") // => ["Hello","Hello","Hello"]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = obj;
  }return result;
}

function genN(n, generator) {
  // Number -> Function -> Array
  // Takes a generator function that is called for each `n`.
  // Example:
  //   arr.genN(3, num.random) // => [46,77,95]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = generator(n);
  }return result;
}

// -=-=-=-=-
// filtering
// -=-=-=-=-

function filter(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> [a]
  // Calls `iterator` for each element in `array` and returns a subset of it
  // including the elements for which `iterator` returned a truthy value.
  // Like `Array.prototype.filter`.
  return array.filter(iterator, context);
}

var detect = features$1.find ? function (arr, iterator, context) {
  return arr.find(iterator, context);
} : function (arr, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> a
  // returns the first occurrence of an element in `arr` for which iterator
  // returns a truthy value
  for (var value, i = 0, len = arr.length; i < len; i++) {
    value = arr[i];
    if (iterator.call(context, value, i)) return value;
  }
  return undefined;
};

var findIndex = features$1.findIndex ? function (arr, iterator, context) {
  return arr.findIndex(iterator, context);
} : function (arr, iterator, context) {
  var i = -1;
  return arr.find(function (ea, j) {
    i = j;return iterator.call(ea, context);
  }) ? i : -1;
};

function findAndGet(arr, iterator) {
  // find the first occurence for which `iterator` returns a truthy value and
  // return *this* value, i.e. unlike find the iterator result and not the
  // element of the list is returned
  var result;
  arr.find(function (ea, i) {
    return result = iterator(ea, i);
  });
  return result;
}

function filterByKey(arr, key) {
  // [a] -> String -> [a]
  // Example:
  //   var objects = [{x: 3}, {y: 4}, {x:5}]
  //   arr.filterByKey(objects, "x") // => [{x: 3},{x: 5}]
  return arr.filter(function (ea) {
    return !!ea[key];
  });
}

function grep(arr, filter, context) {
  // [a] -> String|RegExp -> [a]
  // `filter` can be a String or RegExp. Will stringify each element in
  // Example:
  // ["Hello", "World", "Lively", "User"].grep("l") // => ["Hello","World","Lively"]
  if (typeof filter === 'string') filter = new RegExp(filter, 'i');
  return arr.filter(filter.test.bind(filter));
}

function mask(array, mask) {
  // select every element in array for which array's element is truthy
  // Example: [1,2,3].mask([false, true, false]) => [2]
  return array.filter(function (_, i) {
    return !!mask[i];
  });
}

function reject(array, func, context) {
  // show-in-doc
  function iterator(val, i) {
    return !func.call(context, val, i);
  }
  return array.filter(iterator);
}

function rejectByKey(array, key) {
  // show-in-doc
  return array.filter(function (ea) {
    return !ea[key];
  });
}

function without(array, elem) {
  // non-mutating
  // Example:
  // arr.without([1,2,3,4,5,6], 3) // => [1,2,4,5,6]
  return array.filter(function (val) {
    return val !== elem;
  });
}

function withoutAll(array, otherArr) {
  // non-mutating
  // Example:
  // arr.withoutAll([1,2,3,4,5,6], [3,4]) // => [1,2,5,6]
  return array.filter(function (val) {
    return otherArr.indexOf(val) === -1;
  });
}

function uniq(array, sorted) {
  // non-mutating
  // Removes duplicates from array.
  // if sorted == true then assume array is sorted which allows uniq to be more
  // efficient
  // uniq([3,5,6,2,3,4,2,6,4])
  if (!array.length) return array;

  var result = [array[0]];
  if (sorted) {
    for (var i = 1; i < array.length; i++) {
      var val = array[i];
      if (val !== result[result.length]) result.push(val);
    }
  } else {
    for (var _i = 1; _i < array.length; _i++) {
      var _val = array[_i];
      if (result.indexOf(_val) === -1) result.push(_val);
    }
  }
  return result;
}

function uniqBy(array, comparator, context) {
  // like `arr.uniq` but with custom equality: `comparator(a,b)` returns
  // BOOL. True if a and be should be regarded equal, false otherwise.
  var result = array.slice();
  for (var i = result.length; i--;) {
    var item = array[i];
    for (var j = i + 1; j < result.length; j++) {
      if (comparator.call(context, item, result[j])) result.splice(j--, 1);
    }
  }
  return result;
}

function uniqByKey(array, key) {
  // like `arr.uniq` but with equality based on item[key]
  var seen = {},
      result = [];
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (!seen[item[key]]) {
      seen[item[key]] = true;
      result.push(item);
    }
  }
  return result;
}

function compact(array) {
  // removes falsy values
  // Example:
  // arr.compact([1,2,undefined,4,0]) // => [1,2,4]
  return array.filter(Boolean);
}

function mutableCompact(array) {
  // fix gaps that were created with 'delete'
  var i = 0,
      j = 0,
      len = array.length;
  while (i < len) {
    if (array.hasOwnProperty(i)) array[j++] = array[i];
    i++;
  }
  while (j++ < len) {
    array.pop();
  }return array;
}

// -=-=-=-=-
// iteration
// -=-=-=-=-

function forEach$1(array, iterator, context) {
  // [a] -> (a -> Undefined) -> c? -> Undefined
  // `iterator` is called on each element in `array` for side effects. Like
  // `Array.prototype.forEach`.
  return array.forEach(iterator, context);
}

function zip() /*arr, arr2, arr3*/{
  // Takes any number of lists as arguments. Combines them elment-wise.
  // Example:
  // arr.zip([1,2,3], ["a", "b", "c"], ["A", "B"])
  // // => [[1,"a","A"],[2,"b","B"],[3,"c",undefined]]
  var args = Array.from(arguments),
      array = args.shift(),
      iterator = typeof last(args) === 'function' ? args.pop() : function (x) {
    return x;
  },
      collections = [array].concat(args).map(function (ea) {
    return Array.from(ea);
  });
  return array.map(function (value, index) {
    return iterator(pluck(collections, index), index);
  });
}

function flatten(array, optDepth) {
  // Turns a nested collection into a flat one.
  // Example:
  // arr.flatten([1, [2, [3,4,5], [6]], 7,8])
  // // => [1,2,3,4,5,6,7,8]
  if (typeof optDepth === "number") {
    if (optDepth <= 0) return array;
    optDepth--;
  }
  return array.reduce(function (flattened, value) {
    return flattened.concat(Array.isArray(value) ? flatten(value, optDepth) : [value]);
  }, []);
}

function flatmap(array, it, ctx) {
  // the simple version
  // Array.prototype.concat.apply([], array.map(it, ctx));
  // causes stack overflows with really big arrays
  var results = [];
  for (var i = 0; i < array.length; i++) {
    results.push.apply(results, it.call(ctx, array[i], i));
  }
  return results;
}

function interpose(array, delim) {
  // Injects delim between elements of array
  // Example:
  // lively.lang.arr.interpose(["test", "abc", 444], "aha"));
  // // => ["test","aha","abc","aha",444]
  return array.reduce(function (xs, x) {
    if (xs.length > 0) xs.push(delim);
    xs.push(x);return xs;
  }, []);
}

function delimWith(array, delim) {
  // ignore-in-doc
  // previously used, use interpose now!
  return interpose(array, delim);
}

// -=-=-=-=-
// mapping
// -=-=-=-=-

function map$1(array, iterator, context) {
  // [a] -> (a -> b) -> c? -> [b]
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.map(iterator, context);
}

function invoke(array, method, arg1, arg2, arg3, arg4, arg5, arg6) {
  // Calls `method` on each element in `array`, passing all arguments. Often
  // a handy way to avoid verbose `map` calls.
  // Example: arr.invoke(["hello", "world"], "toUpperCase") // => ["HELLO","WORLD"]
  return array.map(function (ea) {
    return ea[method](arg1, arg2, arg3, arg4, arg5, arg6);
  });
}

function pluck(array, property) {
  // Returns `property` or undefined from each element of array. For quick
  // `map`s and similar to `invoke`.
  // Example: arr.pluck(["hello", "world"], 0) // => ["h","w"]
  return array.map(function (ea) {
    return ea[property];
  });
}

// -=-=-=-=-
// folding
// -=-=-=-=-

function reduce(array, iterator, memo, context) {
  // Array -> Function -> Object? -> Object? -> Object?
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.reduce(iterator, memo, context);
}

function reduceRight(array, iterator, memo, context) {
  // show-in-doc
  return array.reduceRight(iterator, memo, context);
}

// -=-=-=-=-
// testing
// -=-=-=-=-

var isArray$1 = Array.isArray;

var includes$1 = features$1.includes ? function (array, object) {
  return array.includes(object);
} : function (array, object) {
  // Example: arr.include([1,2,3], 2) // => true
  return array.indexOf(object) !== -1;
};

var include$1 = includes$1;

function some(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if there is at least one abject in `array` for which
  // `iterator` returns a truthy result. Like `Array.prototype.some`.
  return array.some(iterator, context);
}

function every(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if for all abjects in `array` `iterator` returns a truthy
  // result. Like `Array.prototype.every`.
  return array.every(iterator, context);
}

function equals$2(array, otherArray) {
  // Returns true iff each element in `array` is equal (`==`) to its
  // corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (array[i] && otherArray[i] && array[i].equals && otherArray[i].equals) {
      if (!array[i].equals(otherArray[i])) {
        return false;
      } else {
        continue;
      }
    }
    if (array[i] != otherArray[i]) return false;
  }
  return true;
}

function deepEquals(array, otherArray) {
  // Returns true iff each element in `array` is structurally equal
  // (`lang.obj.equals`) to its corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (!equals$1(array[i], otherArray[i])) return false;
  }
  return true;
}

// -=-=-=-=-
// sorting
// -=-=-=-=-

function isSorted(array, descending) {
  if (descending) {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] < array[i]) return false;
    }
  } else {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] > array[i]) return false;
    }
  }
  return true;
}

function sort(array, sortFunc) {
  // [a] -> (a -> Number)? -> [a]
  // Just `Array.prototype.sort`
  return array.sort(sortFunc);
}

function sortBy(array, iterator, context) {
  // Example:
  // arr.sortBy(["Hello", "Lively", "User"], function(ea) {
  //   return ea.charCodeAt(ea.length-1); }) // => ["Hello","User","Lively"]
  return pluck(array.map(function (value, index) {
    return { value: value, criteria: iterator.call(context, value, index) };
  }).sort(function (left, right) {
    var a = left.criteria,
        b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }), 'value');
}

function sortByKey(array, key) {
  // Example:
  // lively.lang.arr.sortByKey([{x: 3}, {x: 2}, {x: 8}], "x")
  // // => [{x: 2},{x: 3},{x: 8}]
  return sortBy(array, function (ea) {
    return ea[key];
  });
}

function reverse(array) {
  return array.reverse();
}

function reversed(array) {
  return array.slice().reverse();
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// RegExp / String matching
// -=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$1(arr, re, stringifier) {
  // result might include null items if re did not match (usful for masking)
  // Example:
  //   var morphs = $world.withAllSubmorphsDo(function(x) { return x; ;
  //   morphs.mask(morphs.reMatches(/code/i))
  stringifier = stringifier || String;
  return arr.map(function (ea) {
    return stringifier(ea).match(re);
  });
}

// -=-=-=-=-=-
// accessors
// -=-=-=-=-=-

function first(array) {
  return array[0];
}

function last(array) {
  return array[array.length - 1];
}

// -=-=-=-=-=-=-=-
// Set operations
// -=-=-=-=-=-=-=-

function intersect(array1, array2) {
  // set-like intersection
  return uniq(array1).filter(function (item) {
    return array2.indexOf(item) > -1;
  });
}

function union(array1, array2) {
  // set-like union
  var result = array1.slice();
  for (var i = 0; i < array2.length; i++) {
    var item = array2[i];
    if (result.indexOf(item) === -1) result.push(item);
  }
  return result;
}

function pushAt(array, item, index) {
  // inserts `item` at `index`, mutating
  array.splice(index, 0, item);
}

function removeAt(array, index) {
  // inserts item at `index`, mutating
  array.splice(index, 1);
}

function remove(array, item) {
  // removes first occurrence of item in `array`, mutating
  var index = array.indexOf(item);
  if (index >= 0) removeAt(array, index);
  return item;
}

function pushAll$1(array, items) {
  // appends all `items`, mutating
  array.push.apply(array, items);
  return array;
}

function pushAllAt(array, items, idx) {
  // inserts all `items` at `idx`, mutating
  array.splice.apply(array, [idx, 0].concat(items));
}

function pushIfNotIncluded(array, item) {
  // only appends `item` if its not already in `array`, mutating
  if (!array.includes(item)) array.push(item);
}

function replaceAt(array, item, index) {
  // mutating
  array.splice(index, 1, item);
}

function clear(array) {
  // removes all items, mutating
  array.length = 0;return array;
}

function isSubset(list1, list2) {
  // are all elements in list1 in list2?
  for (var i = 0; i < list1.length; i++) {
    if (!list2.includes(list1[i])) return false;
  }return true;
}

// -=-=-=-=-=-=-=-=-=-=-=-
// asynchronous iteration
// -=-=-=-=-=-=-=-=-=-=-=-
function doAndContinue(array, iterator, endFunc, context) {
  // Iterates over array but instead of consecutively calling iterator,
  // iterator gets passed in the invocation for the next iteration step
  // as a function as first parameter. This allows to wait arbitrarily
  // between operation steps, great for managing dependencies between tasks.
  // Related is [`fun.composeAsync`]().
  // Example:
  // arr.doAndContinue([1,2,3,4], function(next, n) {
  //   alert("At " + n);
  //   setTimeout(next, 100);
  // }, function() { alert("Done"); })
  // // If the elements are functions you can leave out the iterator:
  // arr.doAndContinue([
  //   function(next) { alert("At " + 1); next(); },
  //   function(next) { alert("At " + 2); next(); }
  // ], null, function() { alert("Done"); });
  endFunc = endFunc || Null;
  context = context || GLOBAL$1;
  iterator = iterator || function (next, ea, idx) {
    ea.call(context, next, idx);
  };
  return array.reduceRight(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context, nextFunc, ea, idx);
    };
  }, endFunc)();
}

function nestedDelay(array, iterator, waitSecs, endFunc, context, optSynchronChunks) {
  // Calls `iterator` for every element in `array` and waits between iterator
  // calls `waitSecs`. Eventually `endFunc` is called. When passing a number n
  // as `optSynchronChunks`, only every nth iteration is delayed.
  endFunc = endFunc || function () {};
  return array.clone().reverse().reduce(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context || GLOBAL$1, ea, idx);
      // only really delay every n'th call optionally
      if (optSynchronChunks && idx % optSynchronChunks !== 0) {
        nextFunc();
      } else {
        nextFunc.delay(waitSecs);
      }
    };
  }, endFunc)();
}

function forEachShowingProgress() /*array, progressBar, iterator, labelFunc, whenDoneFunc, context or spec*/{
  // ignore-in-doc
  var args = Array.from(arguments),
      array = args.shift(),
      steps = array.length,
      progressBar,
      iterator,
      labelFunc,
      whenDoneFunc,
      context,
      progressBarAdded = false;

  // init args
  if (args.length === 1) {
    progressBar = args[0].progressBar;
    iterator = args[0].iterator;
    labelFunc = args[0].labelFunction;
    whenDoneFunc = args[0].whenDone;
    context = args[0].context;
  } else {
    progressBar = args[0];
    iterator = args[1];
    labelFunc = args[2];
    whenDoneFunc = args[3];
    context = args[4];
  }
  if (!context) context = typeof window !== 'undefined' ? window : global;
  if (!labelFunc) labelFunc = function labelFunc(x) {
    return x;
  };

  // init progressbar
  if (!progressBar) {
    progressBarAdded = true;
    var Global = typeof window !== 'undefined' ? window : global;
    var world = Global.lively && lively.morphic && lively.morphic.World.current();
    progressBar = world ? world.addProgressBar() : {
      setValue: function setValue(val) {},
      setLabel: function setLabel() {},
      remove: function remove() {}
    };
  }
  progressBar.setValue(0);

  // nest functions so that the iterator calls the next after a delay
  array.reduceRight(function (nextFunc, item, idx) {
    return function () {
      try {
        progressBar.setValue(idx / steps);
        if (labelFunc) progressBar.setLabel(labelFunc.call(context, item, idx));
        iterator.call(context, item, idx);
      } catch (e) {
        console.error('Error in forEachShowingProgress at %s (%s)\n%s\n%s', idx, item, e, e.stack);
      }
      nextFunc.delay(0);
    };
  }, function () {
    progressBar.setValue(1);
    if (progressBarAdded) (function () {
      progressBar.remove();
    }).delay(0);
    if (whenDoneFunc) whenDoneFunc.call(context);
  })();

  return array;
}

function swap(array, index1, index2) {
  // mutating
  // Example:
  // var a = [1,2,3,4];
  // arr.swap(a, 3, 1);
  // a // => [1,4,3,2]
  if (index1 < 0) index1 = array.length + index1;
  if (index2 < 0) index2 = array.length + index2;
  var temp = array[index1];
  array[index1] = array[index2];
  array[index2] = temp;
  return array;
}

function rotate(array, times) {
  // non-mutating
  // Example:
  // arr.rotate([1,2,3]) // => [2,3,1]
  times = times || 1;
  return array.slice(times).concat(array.slice(0, times));
}

// -=-=-=-=-
// grouping
// -=-=-=-=-

function groupBy(array, iterator, context) {
  // Applies `iterator` to each element in `array`, and puts the return value
  // into a collection (the group) associated to it's stringified representation
  // (the "hash").
  // See [`Group.prototype`] for available operations on groups.
  // Example:
  // Example 1: Groups characters by how often they occur in a string:
  // var chars = arr.from("Hello World");
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  // // Example 2: Group numbers by a custom qualifier:
  // arr.groupBy([3,4,1,7,4,3,8,4], function(n) {
  //   if (n <= 3) return "small";
  //   if (n <= 7) return "medium";
  //   return "large";
  // });
  // // => {
  // //   large: [8],
  // //   medium: [4,7,4,4],
  // //   small: [3,1,3]
  // // }
  return Group.fromArray(array, iterator, context);
}

function groupByKey(array, key) {
  // var objects = [{x: }]
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  return groupBy(array, function (ea) {
    return ea[key];
  });
}

function partition(array, iterator, context) {
  // Example:
  // var array = [1,2,3,4,5,6];
  // arr.partition(array, function(ea) { return ea > 3; })
  // // => [[1,2,3,4],[5,6]]
  iterator = iterator || function (x) {
    return x;
  };
  var trues = [],
      falses = [];
  array.forEach(function (value, index) {
    (iterator.call(context, value, index) ? trues : falses).push(value);
  });
  return [trues, falses];
}

function batchify(array, constrainedFunc, context) {
  // Takes elements and fits them into subarrays (= batches) so that for
  // each batch constrainedFunc returns true. Note that contrained func
  // should at least produce 1-length batches, otherwise an error is raised
  // Example:
  // // Assume you have list of things that have different sizes and you want to
  // // create sub-arrays of these things, with each sub-array having if possible
  // // less than a `batchMaxSize` of combined things in it:
  // var sizes = [
  //   Math.pow(2, 15), // 32KB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 27), // 128MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 24), // 16MB
  //   Math.pow(2, 26)] // 64MB
  // var batchMaxSize = Math.pow(2, 28)/*256MB*/;
  // function batchConstrained(batch) {
  //   return batch.length == 1 || batch.sum() < batchMaxSize;
  // }
  // var batches = sizes.batchify(batchConstrained);
  // batches.pluck('length') // => [4,1,1,2]
  // batches.map(arr.sum).map(num.humanReadableByteSize) // => ["208.03MB","512MB","512MB","128MB"]

  return findBatches([], array);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function extractBatch(batch, sizes) {
    // ignore-in-doc
    // Array -> Array -> Array[Array,Array]
    // case 1: no sizes to distribute, we are done
    if (!sizes.length) return [batch, []];
    var first = sizes[0],
        rest = sizes.slice(1);
    // if batch is empty we have to take at least one
    // if batch and first still fits, add first
    var candidate = batch.concat([first]);
    if (constrainedFunc.call(context, candidate)) return extractBatch(candidate, rest);
    // otherwise leave first out for now
    var batchAndSizes = extractBatch(batch, rest);
    return [batchAndSizes[0], [first].concat(batchAndSizes[1])];
  }

  function findBatches(batches, sizes) {
    if (!sizes.length) return batches;
    var extracted = extractBatch([], sizes);
    if (!extracted[0].length) throw new Error('Batchify constrained does not ensure consumption ' + 'of at least one item per batch!');
    return findBatches(batches.concat([extracted[0]]), extracted[1]);
  }
}

function toTuples(array, tupleLength) {
  // Creates sub-arrays with length `tupleLength`
  // Example:
  // arr.toTuples(["H","e","l","l","o"," ","W","o","r","l","d"], 4)
  // // => [["H","e","l","l"],["o"," ","W","o"],["r","l","d"]]
  tupleLength = tupleLength || 1;
  return range(0, Math.ceil(array.length / tupleLength) - 1).map(function (n) {
    return array.slice(n * tupleLength, n * tupleLength + tupleLength);
  }, array);
}

var permutations = function () {
  function computePermutations(restArray, values$$1) {
    return !restArray.length ? [values$$1] : flatmap(restArray, function (ea, i) {
      return computePermutations(restArray.slice(0, i).concat(restArray.slice(i + 1)), values$$1.concat([ea]));
    });
  }
  return function (array) {
    return computePermutations(array, []);
  };
}();

function combinationsPick(listOfListsOfValues, pickIndices) {
  // Given a "listOfListsOfValues" in the form of an array of arrays and
  // `pickIndices` list with the size of the number of arrays which indicates what
  // values to pick from each of the arrays, return a list with two values:
  // 1. values picked from each of the arrays, 2. the next pickIndices or null if at end
  // Example:
  //  var searchSpace = [["a", "b", "c"], [1,2]];
  //  arr.combinationsPick(searchSpace, [0,1]);
  //    // => [["a",2], [1,0]]
  //  arr.combinationsPick(searchSpace, [1,0]);
  //    // => [["b",1], [1,1]]
  var values$$1 = listOfListsOfValues.map(function (subspace, i) {
    return subspace[pickIndices[i]];
  }),
      nextState = pickIndices.slice();
  for (var i = listOfListsOfValues.length; i--; i >= 0) {
    var subspace = listOfListsOfValues[i],
        nextIndex = nextState[i] + 1;
    if (subspace[nextIndex]) {
      nextState[i] = nextIndex;break;
    } else if (i === 0) {
      nextState = undefined;break;
    } else {
      nextState[i] = 0;
    }
  }
  return [values$$1, nextState];
}

function combinations(listOfListsOfValues) {
  // Given a "listOfListsOfValues" in the form of an array of arrays,
  // retrieve all the combinations by picking one item from each array.
  // This basically creates a search tree, traverses it and gathers all node
  // values whenever a leaf node is reached.
  // Example:
  //   lively.lang.arr.combinations([['a', 'b', 'c'], [1, 2]])
  //    // => [["a", 1], ["a", 2], ["b", 1], ["b", 2], ["c", 1], ["c", 2]]
  var size = listOfListsOfValues.reduce(function (prod, space) {
    return prod * space.length;
  }, 1),
      searchState = listOfListsOfValues.map(function (_) {
    return 0;
  }),
      results = new Array(size);
  for (var i = 0; i < size; i++) {
    var result = combinationsPick(listOfListsOfValues, searchState);
    results[i] = result[0];
    searchState = result[1];
  }
  return results;
}

function take(arr, n) {
  return arr.slice(0, n);
}

function drop(arr, n) {
  return arr.slice(n);
}

function takeWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(0, i);
}

function dropWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(i);
}

// -=-=-=-=-=-
// randomness
// -=-=-=-=-=-

function shuffle(array) {
  // Ramdomize the order of elements of array. Does not mutate array.
  // Example:
  // shuffle([1,2,3,4,5]) // => [3,1,2,5,4]
  var unusedIndexes = range(0, array.length - 1),
      shuffled = Array(array.length);
  for (var i = 0; i < array.length; i++) {
    var shuffledIndex = unusedIndexes.splice(Math.round(Math.random() * (unusedIndexes.length - 1)), 1);
    shuffled[shuffledIndex] = array[i];
  }
  return shuffled;
}

// -=-=-=-=-=-=-=-
// Number related
// -=-=-=-=-=-=-=-

function max(array, iterator, context) {
  // Example:
  //   var array = [{x:3,y:2}, {x:5,y:1}, {x:1,y:5}];
  //   arr.max(array, function(ea) { return ea.x; }) // => {x: 5, y: 1}
  iterator = iterator || function (x) {
    return x;
  };
  var result;
  array.reduce(function (max, ea, i) {
    var val = iterator.call(context, ea, i);
    if (typeof val !== "number" || val <= max) return max;
    result = ea;return val;
  }, -Infinity);
  return result;
}

function min(array, iterator, context) {
  // Similar to `arr.max`.
  iterator = iterator || function (x) {
    return x;
  };
  return max(array, function (ea, i) {
    return -iterator.call(context, ea, i);
  });
}

function sum(array) {
  // show-in-doc
  var sum = 0;
  for (var i = 0; i < array.length; i++) {
    sum += array[i];
  }return sum;
}

function count$1(array, item) {
  return array.reduce(function (count, ea) {
    return ea === item ? count + 1 : count;
  }, 0);
}

function size$1(array) {
  return array.length;
}

function histogram(data, binSpec) {
  // ignore-in-doc
  // Without a `binSpec` argument partition the data
  // var numbers = arr.genN(10, num.random);
  // var numbers = arr.withN(10, "a");
  // => [65,73,34,94,92,31,27,55,95,48]
  // => [[65,73],[34,94],[92,31],[27,55],[95,48]]
  // => [[82,50,16],[25,43,77],[40,64,31],[51,39,13],[17,34,87],[51,33,30]]
  if (typeof binSpec === 'undefined' || typeof binSpec === 'number') {
    var binNumber = binSpec || function sturge() {
      return Math.ceil(Math.log(data.length) / Math.log(2) + 1);
    }(data);
    var binSize = Math.ceil(Math.round(data.length / binNumber));
    return range(0, binNumber - 1).map(function (i) {
      return data.slice(i * binSize, (i + 1) * binSize);
    });
  } else if (binSpec instanceof Array) {
    // ignore-in-doc
    // bins specifies n threshold values that will create n-1 bins.
    // Each data value d is placed inside a bin i if:
    // threshold[i] >= d && threshold[i+1] < d
    var thresholds = binSpec;
    return data.reduce(function (bins, d) {
      if (d < thresholds[1]) {
        bins[0].push(d);return bins;
      }
      for (var i = 1; i < thresholds.length; i++) {
        if (d >= thresholds[i] && (!thresholds[i + 1] || d <= thresholds[i + 1])) {
          bins[i].push(d);return bins;
        }
      }
      throw new Error("Histogram creation: Cannot group data " + d + " into thresholds " + thresholds);
    }, range(1, thresholds.length).map(function () {
      return [];
    }));
  }
}

// -=-=-=-=-
// Copying
// -=-=-=-=-

function clone$1(array) {
  // shallow copy
  return [].concat(array);
}

// -=-=-=-=-=-
// conversion
// -=-=-=-=-=-

function toArray$3(array) {
  return from(array);
}

// -=-=-=-=-=-
// DEPRECATED
// -=-=-=-=-=-

function each(arr, iterator, context) {
  return arr.forEach(iterator, context);
}

function all$1(arr, iterator, context) {
  return arr.every(iterator, context);
}

function any(arr, iterator, context) {
  return arr.some(iterator, context);
}

function collect(arr, iterator, context) {
  return arr.map(iterator, context);
}

function findAll(arr, iterator, context) {
  return arr.filter(iterator, context);
}

function inject(array, memo, iterator, context) {
  if (context) iterator = iterator.bind(context);
  return array.reduce(iterator, memo);
}

// asynch methods
function mapAsyncSeries(array, iterator, callback) {
  // Apply `iterator` over `array`. Unlike `mapAsync` the invocation of
  // the iterator happens step by step in the order of the items of the array
  // and not concurrently.

  // ignore-in-doc
  // Could simply be:
  // return exports.arr.mapAsync(array, {parallel: 1}, iterator, callback);
  // but the version below is 2x faster

  var result = [],
      callbackTriggered = false;
  return array.reduceRight(function (nextFunc, ea, idx) {
    if (callbackTriggered) return;
    return function (err, eaResult) {
      if (err) return maybeDone(err);
      if (idx > 0) result.push(eaResult);
      try {
        iterator(ea, idx, once(nextFunc));
      } catch (e) {
        maybeDone(e);
      }
    };
  }, function (err, eaResult) {
    result.push(eaResult);
    maybeDone(err, true);
  })();

  function maybeDone(err, finalCall) {
    if (callbackTriggered || !err && !finalCall) return;
    callbackTriggered = true;
    try {
      callback(err, result);
    } catch (e) {
      console.error("Error in mapAsyncSeries - callback invocation error:\n" + (e.stack || e));
    }
  }
}

function mapAsync(array, options, iterator, callback) {
  // Apply `iterator` over `array`. In each iterator gets a callback as third
  // argument that should be called when the iteration is done. After all
  // iterators have called their callbacks, the main `callback` function is
  // invoked with the result array.
  // Example:
  // lively.lang.arr.mapAsync([1,2,3,4],
  //   function(n, i, next) { setTimeout(function() { next(null, n + i); }, 20); },
  //   function(err, result) { /* result => [1,3,5,7] */ });

  if (typeof options === "function") {
    callback = iterator;
    iterator = options;
    options = null;
  }
  options = options || {};

  if (!array.length) return callback && callback(null, []);

  if (!options.parallel) options.parallel = Infinity;

  var results = [],
      completed = [],
      callbackTriggered = false,
      lastIteratorIndex = 0,
      nActive = 0;

  var iterators = array.map(function (item, i) {
    return function () {
      nActive++;
      try {
        iterator(item, i, once(function (err, result) {
          results[i] = err || result;
          maybeDone(i, err);
        }));
      } catch (e) {
        maybeDone(i, e);
      }
    };
  });

  return activate();

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  function activate() {
    while (nActive < options.parallel && lastIteratorIndex < array.length) {
      iterators[lastIteratorIndex++]();
    }
  }

  function maybeDone(idx, err) {
    if (completed.indexOf(idx) > -1) return;
    completed.push(idx);
    nActive--;
    if (callbackTriggered) return;
    if (!err && completed.length < array.length) {
      activate();return;
    }
    callbackTriggered = true;
    try {
      callback && callback(err, results);
    } catch (e) {
      console.error("Error in mapAsync - main callback invocation error:\n" + (e.stack || e));
    }
  }
}

// poly-filling...
if (!features$1.from) Array.from = from;
if (!features$1.filter) Array.prototype.filter = function (it, ctx) {
  return filter(this, it, ctx);
};
if (!features$1.find) Array.prototype.find = function (it, ctx) {
  return detect(this, it, ctx);
};
if (!features$1.findIndex) Array.prototype.findIndex = function (it, ctx) {
  return findIndex(this, it, ctx);
};
if (!features$1.includes) Array.prototype.includes = function (x) {
  return includes$1(this, x);
};



var arr = Object.freeze({
	range: range,
	from: from,
	withN: withN,
	genN: genN,
	filter: filter,
	detect: detect,
	findIndex: findIndex,
	findAndGet: findAndGet,
	filterByKey: filterByKey,
	grep: grep,
	mask: mask,
	reject: reject,
	rejectByKey: rejectByKey,
	without: without,
	withoutAll: withoutAll,
	uniq: uniq,
	uniqBy: uniqBy,
	uniqByKey: uniqByKey,
	compact: compact,
	mutableCompact: mutableCompact,
	forEach: forEach$1,
	zip: zip,
	flatten: flatten,
	flatmap: flatmap,
	interpose: interpose,
	delimWith: delimWith,
	map: map$1,
	invoke: invoke,
	pluck: pluck,
	reduce: reduce,
	reduceRight: reduceRight,
	isArray: isArray$1,
	includes: includes$1,
	include: include$1,
	some: some,
	every: every,
	equals: equals$2,
	deepEquals: deepEquals,
	isSorted: isSorted,
	sort: sort,
	sortBy: sortBy,
	sortByKey: sortByKey,
	reverse: reverse,
	reversed: reversed,
	reMatches: reMatches$1,
	first: first,
	last: last,
	intersect: intersect,
	union: union,
	pushAt: pushAt,
	removeAt: removeAt,
	remove: remove,
	pushAll: pushAll$1,
	pushAllAt: pushAllAt,
	pushIfNotIncluded: pushIfNotIncluded,
	replaceAt: replaceAt,
	clear: clear,
	isSubset: isSubset,
	doAndContinue: doAndContinue,
	nestedDelay: nestedDelay,
	forEachShowingProgress: forEachShowingProgress,
	swap: swap,
	rotate: rotate,
	groupBy: groupBy,
	groupByKey: groupByKey,
	partition: partition,
	batchify: batchify,
	toTuples: toTuples,
	permutations: permutations,
	combinationsPick: combinationsPick,
	combinations: combinations,
	take: take,
	drop: drop,
	takeWhile: takeWhile,
	dropWhile: dropWhile,
	shuffle: shuffle,
	max: max,
	min: min,
	sum: sum,
	count: count$1,
	size: size$1,
	histogram: histogram,
	clone: clone$1,
	toArray: toArray$3,
	each: each,
	all: all$1,
	any: any,
	collect: collect,
	findAll: findAll,
	inject: inject,
	mapAsyncSeries: mapAsyncSeries,
	mapAsync: mapAsync
});

/*
 * Utility functions that help to inspect, enumerate, and create JS objects
 */

// -=-=-=-=-=-=-=-=-
// internal helper
// -=-=-=-=-=-=-=-=-

// serveral methods in lib/object.js are inspired or derived from
// Prototype JavaScript framework, version 1.6.0_rc1
// (c) 2005-2007 Sam Stephenson
// Prototype is freely distributable under the terms of an MIT-style license.
// For details, see the Prototype web site: http://www.prototypejs.org/

function print$1(object) {
  if (object && Array.isArray(object)) {
    return '[' + object.map(print$1) + ']';
  }
  if (typeof object !== "string") {
    return String(object);
  }
  var result = String(object);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function indent$1(str, indentString, depth) {
  if (!depth || depth <= 0) return str;
  while (depth > 0) {
    depth--;str = indentString + str;
  }
  return str;
}

// show-in-doc

// -=-=-=-=-
// testing
// -=-=-=-=-

function isArray$$1(obj) {
  /*show-in-doc*/return Array.isArray(obj);
}

function isElement(object) {
  /*show-in-doc*/return object && object.nodeType == 1;
}

function isFunction(object) {
  /*show-in-doc*/return object instanceof Function;
}

function isBoolean(object) {
  /*show-in-doc*/return typeof object == "boolean";
}

function isString(object) {
  /*show-in-doc*/return typeof object == "string";
}

function isNumber(object) {
  /*show-in-doc*/return typeof object == "number";
}

function isUndefined(object) {
  /*show-in-doc*/return typeof object == "undefined";
}

function isRegExp(object) {
  /*show-in-doc*/return object instanceof RegExp;
}

function isObject(object) {
  /*show-in-doc*/return (typeof object === "undefined" ? "undefined" : _typeof(object)) == "object";
}

function isPrimitive(obj) {
  // show-in-doc
  if (!obj) return true;
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case "string":
    case "number":
    case "boolean":
      return true;
  }
  return false;
}

function isEmpty(object) {
  /*show-in-doc*/
  for (var key in object) {
    if (object.hasOwnProperty(key)) return false;
  }return true;
}

function equals$1(a, b) {
  // Is object `a` structurally equivalent to object `b`? Deep comparison.
  if (a === b) return true;
  if (!a || !b) return a == b;
  if (Array.isArray(a)) return deepEquals(a, b);
  switch (a.constructor) {
    case String:
    case Date:
    case Boolean:
    case Number:
      return a == b;
  }
  if (typeof a.isEqualNode === "function") return a.isEqualNode(b);
  if (typeof a.equals === "function") return a.equals(b);
  var seenInA = [];
  for (var name in a) {
    seenInA.push(name);
    if (typeof a[name] === "function") continue;
    if (!equals$1(a[name], b[name])) return false;
  }
  for (var name in b) {
    if (seenInA.indexOf(name) !== -1) continue;
    if (typeof b[name] === "function") continue;
    if (!equals$1(b[name], a[name])) return false;
  }
  return true;
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-

var keys$1 = Object.keys;

function values(object) {
  // Example:
  // var obj1 = {x: 22}, obj2 = {x: 23, y: {z: 3}};
  // obj2.__proto__ = obj1;
  // obj.values(obj1) // => [22]
  // obj.values(obj2) // => [23,{z: 3}]
  return object ? Object.keys(object).map(function (k) {
    return object[k];
  }) : [];
}

function select(obj, keys) {
  // return a new object that copies all properties with `keys` from `obj`
  var selected = {};
  for (var i = 0; i < keys.length; i++) {
    selected[keys[i]] = obj[keys[i]];
  }return selected;
}

function dissoc(object, keys) {
  var result = {};
  for (var name in object) {
    if (object.hasOwnProperty(name) && keys.indexOf(name) === -1) result[name] = object[name];
  }return result;
}

function addScript(object, funcOrString, optName, optMapping) {
  var func = fromString(funcOrString);
  return asScriptOf(func, object, optName, optMapping);
}

// -=-=-=-=-
// mutation
// -=-=-=-=-
function extend(destination, source) {
  // Add all properties of `source` to `destination`.
  // Example:
  // var dest = {x: 22}, src = {x: 23, y: 24}
  // obj.extend(dest, src);
  // dest // => {x: 23,y: 24}

  var currentCategoryNames = null;
  for (var i = 1; i < arguments.length; i++) {
    if (typeof arguments[i] == "string") {
      var catName = arguments[i];
      if (!destination.categories) destination.categories = {};
      if (!destination.categories[catName]) destination.categories[catName] = [];
      currentCategoryNames = destination.categories[catName];
      continue;
    }

    var source = arguments[i];
    for (var property in source) {
      var getter = source.__lookupGetter__(property),
          setter = source.__lookupSetter__(property);
      if (getter) destination.__defineGetter__(property, getter);
      if (setter) destination.__defineSetter__(property, setter);
      if (getter || setter) continue;
      var sourceObj = source[property];
      destination[property] = sourceObj;
      if (currentCategoryNames) currentCategoryNames.push(property);
      if (typeof sourceObj === "function") {
        if (!sourceObj.displayName) sourceObj.displayName = property;
        // remember the module that contains the definition
        if (typeof lively !== "undefined" && lively.Module && lively.Module.current) sourceObj.sourceModule = lively.Module.current();
      }
    }
  }

  return destination;
}

// -=-=-=-=-
// clone
// -=-=-=-=-

function clone$$1(object) {
  // Shallow copy
  if (isPrimitive(object)) return object;
  if (Array.isArray(object)) return Array.prototype.slice.call(object);
  var clone$$1 = {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) clone$$1[key] = object[key];
  }
  return clone$$1;
}

function extract(object, properties, mapFunc) {
  // Takes a list of properties and returns a new object with those
  // properties shallow-copied from object
  var copied = {};
  for (var i = 0; i < properties.length; i++) {
    if (properties[i] in object) copied[properties[i]] = mapFunc ? mapFunc(properties[i], object[properties[i]]) : object[properties[i]];
  }
  return copied;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-
function inspect(object, options, depth) {
  // Prints a human-readable representation of `obj`. The printed
  // representation will be syntactically correct JavaScript but will not
  // necessarily evaluate to a structurally identical object. `inspect` is
  // meant to be used while interactivively exploring JavaScript programs and
  // state.
  //
  // `options` can be {
  //   printFunctionSource: BOOLEAN,
  //   escapeKeys: BOOLEAN,
  //   maxDepth: NUMBER,
  //   customPrinter: FUNCTION
  // }
  options = options || {};
  depth = depth || 0;

  if (options.customPrinter) {
    var ignoreSignal = options._ignoreSignal || (options._ignoreSignal = {}),
        continueInspectFn = function continueInspectFn(obj) {
      return inspect(obj, options, depth + 1);
    },
        customInspected = options.customPrinter(object, ignoreSignal, continueInspectFn);
    if (customInspected !== ignoreSignal) return customInspected;
  }
  if (!object) return print$1(object);

  // print function
  if (typeof object === 'function') {
    return options.printFunctionSource ? String(object) : 'function' + (object.name ? ' ' + object.name : '') + '(' + argumentNames(object).join(',') + ') {/*...*/}';
  }

  // print "primitive"
  switch (object.constructor) {
    case String:
    case Boolean:
    case RegExp:
    case Number:
      return print$1(object);
  }

  if (typeof object.serializeExpr === 'function') return object.serializeExpr();

  var isArray$$1 = object && Array.isArray(object),
      openBr = isArray$$1 ? '[' : '{',
      closeBr = isArray$$1 ? ']' : '}';
  if (options.maxDepth && depth >= options.maxDepth) return openBr + '/*...*/' + closeBr;

  var printedProps = [];
  if (isArray$$1) {
    printedProps = object.map(function (ea) {
      return inspect(ea, options, depth + 1);
    });
  } else {
    printedProps = Object.keys(object).sort(function (a, b) {
      var aIsFunc = typeof object[a] === 'function',
          bIsFunc = typeof object[b] === 'function';
      if (aIsFunc === bIsFunc) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      }
      return aIsFunc ? 1 : -1;
    }).map(function (key, i) {
      if (isArray$$1) inspect(object[key], options, depth + 1);
      var printedVal = inspect(object[key], options, depth + 1);
      return options.escapeKeys ? JSON.stringify(key) : key + ": " + printedVal;
    });
  }

  if (printedProps.length === 0) {
    return openBr + closeBr;
  }

  var printedPropsJoined = printedProps.join(', '),
      useNewLines = (!isArray$$1 || options.newLineInArrays) && (!options.minLengthForNewLine || printedPropsJoined.length >= options.minLengthForNewLine),
      ind = indent$1('', options.indent || '  ', depth),
      propIndent = indent$1('', options.indent || '  ', depth + 1),
      startBreak = useNewLines && !isArray$$1 ? '\n' + propIndent : '',
      eachBreak = useNewLines ? '\n' + propIndent : '',
      endBreak = useNewLines && !isArray$$1 ? '\n' + ind : '';
  if (useNewLines) printedPropsJoined = printedProps.join(',' + eachBreak);
  return openBr + startBreak + printedPropsJoined + endBreak + closeBr;
}

// -=-=-=-=-
// merging
// -=-=-=-=-
function merge(objs) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies
  if (arguments.length > 1) {
    return merge(Array.prototype.slice.call(arguments));
  }

  if (Array.isArray(objs[0])) {
    // test for all?
    return Array.prototype.concat.apply([], objs);
  }

  return objs.reduce(function (merged, ea) {
    for (var name in ea) {
      if (ea.hasOwnProperty(name)) merged[name] = ea[name];
    }return merged;
  }, {});
}

function deepMerge(objA, objB) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies

  if (!objA) return objB;
  if (!objB) return objA;

  if (Array.isArray(objA)) {
    if (!Array.isArray(objB)) return objB;
    var merged = objA.map(function (ea, i) {
      return deepMerge(ea, objB[i]);
    });
    if (objB.length > objA.length) merged = merged.concat(objB.slice(objA.length));
    return merged;
  }

  if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object") return objB;

  return Object.keys(objA).concat(Object.keys(objB)).reduce(function (merged, name) {
    if (!objA[name]) merged[name] = objB[name];else if (!objB[name]) merged[name] = objA[name];else if (_typeof(objA[name]) !== "object" || _typeof(objB[name]) !== "object") merged[name] = objB[name];else merged[name] = deepMerge(objA[name], objB[name]);
    return merged;
  }, {});
}

function sortKeysWithBeforeAndAfterConstraints(properties) {
  var throwErrorOnMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // Expects `properties` to be a map of keys to objects having optional
  // before/after attributes that, if present, should be lists of other property
  // keys. `sortProperties` will return an ordered list of property keys so
  // that the before / after requirements are fullfilled. If a cyclic
  // dependency is encountered an error will be thrown.
  // Example:
  // ```
  // sortProperties({foo: {}, bar: {after: ["foo"], before: ["baz"]}, "baz": {after: ["foo"]}})
  // // => ["foo","bar","baz"]
  // ```

  // ignore-in-doc
  // 1. convert "before" requirement into "after" and check if all properties
  // mentioned in after/before are actually there
  var keys = [],
      props = [],
      remaining = [];
  for (var key in properties) {
    var prop = properties[key],
        before = prop.hasOwnProperty("before") ? prop.before : prop.before = [],
        after = prop.hasOwnProperty("after") ? prop.after : prop.after = [];

    keys.push(key);
    props.push(prop);

    for (var i = before.length; i--;) {
      var beforePropName = before[i];
      var beforeProp = properties[beforePropName];
      if (!beforeProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized before " + beforePropName + " ") + "but that property cannot be found.");
        before.splice(i, 1);
        continue;
      }
      if (!beforeProp.hasOwnProperty("after")) beforeProp.after = [];
      beforeProp.after.push(key);
    }

    for (var _i = after.length; _i--;) {
      var afterPropName = after[_i];
      var afterProp = properties[afterPropName];
      if (!afterProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized after " + afterPropName + " ") + "but that property cannot be found.");
        after.splice(_i, 1);
      }
    }

    remaining.push(key);
  }

  // ignore-in-doc
  // compute order
  var resolvedGroups = [],
      resolvedKeys = [],
      lastLength = remaining.length + 1;

  while (remaining.length) {
    if (lastLength === remaining.length) throw new Error("Circular dependencies in handler order, could not resolve properties " + remaining.map(function (key) {
      var before = properties[key].before,
          after = properties[key].after;
      if ((!before || !before.length) && (!after || !after.length)) return "";
      var report = key + "\n";
      if (before && before.length) report += "  - before " + before.join(",") + "\n";
      if (after && after.length) report += "  - after " + after.join(",") + "\n";
      return report;
    }).join(""));
    lastLength = remaining.length;
    var resolvedGroup = [];
    for (var _i2 = remaining.length; _i2--;) {
      var _key = remaining[_i2];
      if (isSubset(properties[_key].after, resolvedKeys)) {
        remaining.splice(_i2, 1);
        resolvedKeys.push(_key);
        resolvedGroup.push(_key);
      }
    }
    resolvedGroups.push(resolvedGroup);
  }

  return flatten(resolvedGroups, 1);
}

// -=-=-=-=-=-=-
// inheritance
// -=-=-=-=-=-=-
function inherit(obj) {
  return Object.create(obj);
}

function valuesInPropertyHierarchy(obj, name) {
  // Lookup all properties named name in the proto hierarchy of obj.
  // Example:
  // var a = {foo: 3}, b = Object.create(a), c = Object.create(b);
  // c.foo = 4;
  // obj.valuesInPropertyHierarchy(c, "foo") // => [3,4]
  var result = [],
      lookupObj = obj;
  while (lookupObj) {
    if (lookupObj.hasOwnProperty(name)) result.unshift(lookupObj[name]);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function mergePropertyInHierarchy(obj, propName) {
  // like `merge` but automatically gets all definitions of the value in the
  // prototype chain and merges those.
  // Example:
  // var o1 = {x: {foo: 23}}, o2 = {x: {foo: 24, bar: 15}}, o3 = {x: {baz: "zork"}};
  // o2.__proto__ = o1; o3.__proto__ = o2;
  // obj.mergePropertyInHierarchy(o3, "x");
  // // => {bar: 15, baz: "zork",foo: 24}
  return merge(valuesInPropertyHierarchy(obj, propName));
}

function deepCopy(object) {
  // Recursively traverses `object` and its properties to create a copy.
  if (!object || (typeof object === "undefined" ? "undefined" : _typeof(object)) !== "object" || object instanceof RegExp) return object;
  var result = Array.isArray(object) ? Array(object.length) : {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) result[key] = deepCopy(object[key]);
  }
  return result;
}

// -=-=-=-=-=-=-=-=-
// stringification
// -=-=-=-=-=-=-=-=-
function typeStringOf(obj) {
  // ignore-in-doc
  if (obj === null) return "null";
  if (typeof obj === "undefined") return "undefined";
  return obj.constructor.name;
}

function shortPrintStringOf(obj) {
  // ignore-in-doc
  // primitive values
  if (!isMutableType(obj)) return safeToString(obj);

  // constructed objects
  if (obj.constructor.name !== 'Object' && !Array.isArray(obj)) {
    if (obj.constructor.name) return obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).split(" ")[1].split("]")[0];
  }

  // arrays or plain objects
  var typeString = "";

  function displayTypeAndLength(obj, collectionType, firstBracket, secondBracket) {
    if (obj.constructor.name === collectionType) {
      typeString += firstBracket;
      if (obj.length || Object.keys(obj).length) typeString += "...";
      typeString += secondBracket;
    }
  }
  displayTypeAndLength(obj, "Object", "{", "}");
  displayTypeAndLength(obj, "Array", "[", "]");
  return typeString;
}

function isMutableType(obj) {
  // Is `obj` a value or mutable type?
  var immutableTypes = ["null", "undefined", "Boolean", "Number", "String"];
  return immutableTypes.indexOf(typeStringOf(obj)) === -1;
}

function safeToString(obj) {
  // Like `toString` but catches errors.
  try {
    return (obj ? obj.toString() : String(obj)).replace('\n', '');
  } catch (e) {
    return '<error printing object>';
  }
}

function asObject(obj) {
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case 'string':
      return new String(obj);
    case 'boolean':
      return new Boolean(obj);
    case 'number':
      return new Number(obj);
    default:
      return obj;
  }
}

function newKeyIn(obj) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "_";

  var i = 1,
      key;
  do {
    key = base + "-" + i++;
  } while (key in obj);
  return key;
}



var obj = Object.freeze({
	isArray: isArray$$1,
	isElement: isElement,
	isFunction: isFunction,
	isBoolean: isBoolean,
	isString: isString,
	isNumber: isNumber,
	isUndefined: isUndefined,
	isRegExp: isRegExp,
	isObject: isObject,
	isPrimitive: isPrimitive,
	isEmpty: isEmpty,
	equals: equals$1,
	keys: keys$1,
	values: values,
	select: select,
	dissoc: dissoc,
	addScript: addScript,
	extend: extend,
	clone: clone$$1,
	extract: extract,
	inspect: inspect,
	merge: merge,
	deepMerge: deepMerge,
	inherit: inherit,
	valuesInPropertyHierarchy: valuesInPropertyHierarchy,
	mergePropertyInHierarchy: mergePropertyInHierarchy,
	sortKeysWithBeforeAndAfterConstraints: sortKeysWithBeforeAndAfterConstraints,
	deepCopy: deepCopy,
	typeStringOf: typeStringOf,
	shortPrintStringOf: shortPrintStringOf,
	isMutableType: isMutableType,
	safeToString: safeToString,
	asObject: asObject,
	newKeyIn: newKeyIn
});

/*global btoa,JsDiff*/
/*lively.vm dontTransform: ["btoa"]*/

// String utility methods for printing, parsing, and converting strings.

var features = {
  repeat: !!String.prototype.repeat,
  includes: !!String.prototype.includes,
  startsWith: !!String.prototype.startsWith,
  endsWith: !!String.prototype.endsWith

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // printing and formatting strings
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

};function format() {
  // String+ -> String
  // Takes a variable number of arguments. The first argument is the format
  // string. Placeholders in the format string are marked with `"%s"`.
  // Example:
  //   lively.lang.string.format("Hello %s!", "Lively User"); // => "Hello Lively User!"
  return formatFromArray(Array.prototype.slice.call(arguments));
}

function formatFromArray(objects) {
  var self = objects.shift();
  if (!self) {
    console.log("Error in Strings>>formatFromArray, first arg is undefined");
  }

  function appendText(object, string) {
    return "" + object;
  }

  function appendInteger(value, string) {
    return value.toString();
  }

  function appendFloat(value, string, precision) {
    if (precision > -1) return value.toFixed(precision);else return value.toString();
  }

  function appendObject(value, string) {
    return inspect(value);
  }

  var appenderMap = { s: appendText, d: appendInteger, i: appendInteger, f: appendFloat, o: appendObject };
  var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;

  function parseFormat(fmt) {
    var oldFmt = fmt;
    var parts = [];

    for (var m = reg.exec(fmt); m; m = reg.exec(fmt)) {
      var type = m[8] || m[5],
          appender = type in appenderMap ? appenderMap[type] : appendObject,
          precision = m[3] ? parseInt(m[3]) : m[4] == "." ? -1 : 0;
      parts.push(fmt.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
      parts.push({ appender: appender, precision: precision });

      fmt = fmt.substr(m.index + m[0].length);
    }
    if (fmt) parts.push(fmt.toString());

    return parts;
  }

  var parts = parseFormat(self),
      str = "",
      objIndex = 0;

  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i];
    if (part && (typeof part === "undefined" ? "undefined" : _typeof(part)) == "object") {
      var object = objects[objIndex++];
      str += (part.appender || appendText)(object, str, part.precision);
    } else {
      str += appendText(part, str);
    }
  }
  return str;
}

function indent(str, indentString, depth) {
  // String -> String -> String? -> String
  // Example:
  //   string.indent("Hello", "  ", 2) // => "    Hello"
  if (!depth || depth <= 0) return str;
  var indent = "";while (depth > 0) {
    depth--;indent += indentString;
  }
  return lines(str).map(function (line) {
    return indent + line;
  }).join("\n");
}

function minIndent(str, indentString) {
  // Find out what the minum indentation of the text in str is
  // Example:
  //   minIndent("    Hello", "  ") // => 2
  if (!indentString) indentString = "  ";
  var indentRe = new RegExp("^(" + indentString + ")*", "gm");
  return min(str.match(indentRe).map(function (ea) {
    return Math.floor(ea.length / indentString.length);
  }));
}

function changeIndent(str, indentString, depth) {
  // Add or remove indent from lines in str to match depth
  // Example:
  //   string.changeIndent("    Hello", "  ", 1) // => "  Hello"
  if (!indentString) indentString = "  ";
  if (!depth) depth = 0;
  var existingIndent = minIndent(str, indentString);
  if (existingIndent === depth) return str;
  if (existingIndent < depth) return indent(str, indentString, depth - existingIndent);
  var prefixToRemove = indentString.repeat(existingIndent - depth);
  return lines(str).map(function (line) {
    return line.slice(prefixToRemove.length);
  }).join("\n");
}

function quote(str) {
  // Example:
  //   string.print("fo\"o") // => "\"fo\\\"o\""
  return '"' + str.replace(/"/g, '\\"') + '"';
}

function print(obj) {
  // Prints Arrays and escapes quotations. See `obj.inspect` for how to
  // completely print / inspect JavaScript data strcutures
  // Example:
  //   string.print([[1,2,3], "string", {foo: 23}])
  //      // => [[1,2,3],"string",[object Object]]
  if (obj && Array.isArray(obj)) return '[' + obj.map(print) + ']';
  if (typeof obj !== "string") return String(obj);
  var result = String(obj);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function printNested(list, depth) {
  // Example:
  //   string.printNested([1,2,[3,4,5]]) // => "1\n2\n  3\n  4\n  5\n"
  depth = depth || 0;
  return list.reduce(function (s, ea) {
    return s += Array.isArray(ea) ? printNested(ea, depth + 1) : indent(ea + "\n", '  ', depth);
  }, "");
}

function pad(string, n, left) {
  // Examples:
  // pad("Foo", 2) // => "Foo  "
  // pad("Foo", 2, true) // => "  Foo"
  return left ? ' '.repeat(n) + string : string + ' '.repeat(n);
}

function printTable(tableArray, options) {
  // Array -> Object? -> String
  // Takes a 2D Array and prints a table string. Kind of the reverse
  // operation to `tableize`
  // Example:
  //   string.printTable([["aaa", "b", "c"], ["d", "e","f"]])
  //    // =>
  //    // aaa b c
  //    // d   e f
  var columnWidths = [],
      separator = options && options.separator || ' ',
      alignLeftAll = !options || !options.align || options.align === 'left',
      alignRightAll = options && options.align === 'right';
  function alignRight(columnIndex) {
    if (alignLeftAll) return false;
    if (alignRightAll) return true;
    return options && Array.isArray(options.align) && options.align[columnIndex] === 'right';
  }
  tableArray.forEach(function (row) {
    row.forEach(function (cellVal, i) {
      if (columnWidths[i] === undefined) columnWidths[i] = 0;
      columnWidths[i] = Math.max(columnWidths[i], String(cellVal).length);
    });
  });
  return tableArray.map(function (row) {
    return row.map(function (cellVal, i) {
      var cellString = String(cellVal);
      return pad(cellString, columnWidths[i] - cellString.length, alignRight(i));
    }).join(separator);
  }).join('\n');
}

function printTree(rootNode, nodePrinter, childGetter, indent) {
  // Object -> Function -> Function -> Number? -> String
  // A generic function to print a tree representation from a nested data structure.
  // Receives three arguments:
  // - `rootNode` an object representing the root node of the tree
  // - `nodePrinter` is a function that gets a tree node and should return stringified version of it
  // - `childGetter` is a function that gets a tree node and should return a list of child nodes
  // Example:
  // var root = {name: "a", subs: [{name: "b", subs: [{name: "c"}]}, {name: "d"}]};
  // string.printTree(root, function(n) { return n.name; }, function(n) { return n.subs; });
  // // =>
  // // a
  // // |-b
  // // | \-c
  // // \-d

  var nodeList = [];
  indent = indent || '  ';
  iterator(0, 0, rootNode);
  return nodeList.join('\n');
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function iterator(depth, index, node) {
    // ignore-in-doc
    // 1. Create stringified representation of node
    nodeList[index] = indent.repeat(depth) + nodePrinter(node, depth);
    var children = childGetter(node, depth),
        childIndex = index + 1;
    if (!children || !children.length) return childIndex;
    // 2. If there are children then assemble those linear inside nodeList
    // The childIndex is the pointer of the current items of childList into
    // nodeList.
    var lastIndex = childIndex,
        lastI = children.length - 1;
    children.forEach(function (ea, i) {
      childIndex = iterator(depth + 1, childIndex, ea);
      // 3. When we have printed the recursive version then augment the
      // printed version of the direct children with horizontal slashes
      // directly in front of the represented representation
      var isLast = lastI === i,
          cs = nodeList[lastIndex].split(''),
          fromSlash = depth * indent.length + 1,
          toSlash = depth * indent.length + indent.length;
      for (var i = fromSlash; i < toSlash; i++) {
        cs[i] = '-';
      }if (isLast) cs[depth * indent.length] = '\\';
      nodeList[lastIndex] = cs.join('');
      // 4. For all children (direct and indirect) except for the
      // last one (itself and all its children) add vertical bars in
      // front of each at position of the current nodes depth. This
      // makes is much easier to see which child node belongs to which
      // parent
      if (!isLast) nodeList.slice(lastIndex, childIndex).forEach(function (ea, i) {
        var cs2 = ea.split('');
        cs2[depth * indent.length] = '|';
        nodeList[lastIndex + i] = cs2.join('');
      });
      lastIndex = childIndex;
    });
    return childIndex;
  }
}

function toArray$1(s) {
  // Example:
  // string.toArray("fooo") // => ["f","o","o","o"]
  return s.split('');
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// parsing strings into other entities
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function lines(str) {
  // Example: string.lines("foo\nbar\n\rbaz") // => ["foo","bar","baz"]
  return str.split(/\n\r?/);
}

function paragraphs(string, options) {
  // Examples:
  // var text = "Hello, this is a pretty long sentence\nthat even includes new lines."
  //         + "\n\n\nThis is a sentence in  a new paragraph.";
  // string.paragraphs(text) // => [
  //   // "Hello, this is a pretty long sentence\nthat even includes new lines.",
  //   // "This is a sentence in  a new paragraph."]
  // string.paragraphs(text, {keepEmptyLines: true}) // => [
  //   // "Hello, this is a pretty long sentence\n that even includes new lines.",
  //   // "\n ",
  //   // "This is a sentence in  a new paragraph."]
  var sep = options ? options.sep : '\n\n';
  if (!options || !options.keepEmptyLines) return string.split(new RegExp(sep + '+'));
  function isWhiteSpace(s) {
    return (/^\s*$/.test(s)
    );
  }
  return string.split('\n').concat('').reduce(function (parasAndLast, line) {
    var paras = parasAndLast[0],
        last$$1 = parasAndLast[1];
    if (isWhiteSpace(last$$1) === isWhiteSpace(line)) {
      last$$1 += '\n' + line;
    } else {
      last$$1.length && paras.push(last$$1);last$$1 = line;
    }
    return [paras, last$$1];
  }, [[], ''])[0];
}

function nonEmptyLines(str) {
  // Example: string.nonEmptyLines("foo\n\nbar\n") // => ["foo","bar"]
  return lines(str).compact();
}

function tokens(str, regex) {
  // Example:
  // string.tokens(' a b c') => ['a', 'b', 'c']
  return str.split(regex || /\s+/).filter(function (tok) {
    return !/^\s*$/.test(tok);
  });
}

function tableize(s, options) {
  // String -> Object? -> Array
  // Takes a String representing a "table" and parses it into a 2D-Array (as
  // accepted by the `collection.Grid` methods or `string.printTable`)
  // ```js
  // options = {
  //     convertTypes: BOOLEAN, // automatically convert to Numbers, Dates, ...?
  //     cellSplitter: REGEXP // how to recognize "cells", by default just spaces
  // }
  // ```
  // Examples:
  // string.tableize('a b c\nd e f')
  // // => [["a","b","c"],["d","e","f"]]
  // // can also parse csv like
  // var csv = '"Symbol","Name","LastSale",\n'
  //         + '"FLWS","1-800 FLOWERS.COM, Inc.","5.65",\n'
  //         + '"FCTY","1st Century Bancshares, Inc","5.65",'
  // string.tableize(csv, {cellSplitter: /^\s*"|","|",?\s*$/g})
  // // => [["Symbol","Name","LastSale"],
  // //     ["FLWS","1-800 FLOWERS.COM, Inc.",5.65],
  // //     ["FCTY","1st Century Bancshares, Inc",5.65]]

  options = options || {};
  var splitter = options.cellSplitter || /\s+/,
      emptyStringRe = /^\s*$/,
      convertTypes = options.hasOwnProperty('convertTypes') ? !!options.convertTypes : true,
      _lines = lines(s),
      table = [];
  for (var i = 0; i < _lines.length; i++) {
    var _tokens = tokens(_lines[i], splitter);
    if (convertTypes) {
      _tokens = _tokens.map(function (tok) {
        if (tok.match(emptyStringRe)) return tok;
        var num = Number(tok);
        if (!isNaN(num)) return num;
        var date = new Date(tok);
        if (!isNaN(+date)) return date;
        return tok.trim();
      });
    }
    if (_tokens.length > 0) table.push(_tokens);
  }
  return table;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// (un)escape / encoding / decoding
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function unescapeCharacterEntities(s) {
  // Converts [character entities](http://dev.w3.org/html5/html-author/charref)
  // into utf-8 strings
  // Example:
  //   string.unescapeCharacterEntities("foo &amp;&amp; bar") // => "foo && bar"
  if (typeof document === 'undefined') throw new Error("Cannot unescapeCharacterEntities");
  var div = document.createElement('div');
  div.innerHTML = s;
  return div.textContent;
}

function toQueryParams(s, separator) {
  // Example:
  // string.toQueryParams("http://example.com?foo=23&bar=test")
  //   // => {bar: "test", foo: "23"}
  var match = s.trim().match(/([^?#]*)(#.*)?$/);
  if (!match) return {};

  var hash = match[1].split(separator || '&').inject({}, function (hash, pair) {
    if ((pair = pair.split('='))[0]) {
      var key = decodeURIComponent(pair.shift());
      var value = pair.length > 1 ? pair.join('=') : pair[0];
      if (value != undefined) value = decodeURIComponent(value);

      if (key in hash) {
        if (!Array.isArray(hash[key])) hash[key] = [hash[key]];
        hash[key].push(value);
      } else hash[key] = value;
    }
    return hash;
  });
  return hash;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// file system path support
// -=-=-=-=-=-=-=-=-=-=-=-=-
var pathDotRe = /\/\.\//g;
var pathDoubleDotRe = /\/[^\/]+\/\.\./;
var pathDoubleSlashRe = /(^|[^:])[\/]+/g;
var urlStartRe = /^[a-z0-9-_\.]+:\/\//;
function normalizePath$1(pathString) {
  var urlStartMatch = pathString.match(urlStartRe),
      urlStart = urlStartMatch ? urlStartMatch[0] : null,
      result = urlStart ? pathString.slice(urlStart.length) : pathString;
  // /foo/../bar --> /bar
  do {
    pathString = result;
    result = pathString.replace(pathDoubleDotRe, '');
  } while (result != pathString);
  // foo//bar --> foo/bar
  result = result.replace(pathDoubleSlashRe, '$1/');
  // foo/./bar --> foo/bar
  result = result.replace(pathDotRe, '/');
  if (urlStart) result = urlStart + result;
  return result;
}

function joinPath() /*paths*/{
  // Joins the strings passed as paramters together so that ea string is
  // connected via a single "/".
  // Example:
  // string.joinPath("foo", "bar") // => "foo/bar";
  return normalizePath$1(Array.prototype.slice.call(arguments).reduce(function (path, ea) {
    return typeof ea === "string" ? path.replace(/\/*$/, "") + "/" + ea.replace(/^\/*/, "") : path;
  }));
}

// -=-=-=-=-=-=-=-=-
// ids and hashing
// -=-=-=-=-=-=-=-=-
var newUUIDTemplate = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
var newUUIDRe = /[xy]/g;
var newUUIDReplacer = function newUUIDReplacer(c) {
  var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
  return v.toString(16);
};

function newUUID() {
  // Example:
  //   newUUID() // => "3B3E74D0-85EA-45F2-901C-23ECF3EAB9FB"
  return newUUIDTemplate.replace(newUUIDRe, newUUIDReplacer).toUpperCase();
}

function createDataURI(content, mimeType) {
  // String -> String -> String
  // Takes some string representing content and a mime type.
  // For a list of mime types see: [http://www.iana.org/assignments/media-types/media-types.xhtml]()
  // More about data URIs: [https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs]()
  // Example:
  //   window.open(string.createDataURI('<h1>test</h1>', 'text/html'));
  mimeType = mimeType || "text/plain";
  return "data:" + mimeType + ";base64," + btoa(content);
}

function hashCode(s) {
  // [http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/]()
  // Example: string.hashCode("foo") // => 101574
  var hash = 0,
      len = s.length;
  if (len == 0) return hash;
  for (var i = 0; i < len; i++) {
    var c = s.charCodeAt(i);
    hash = (hash << 5) - hash + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

function md5(string) {
  //  Joseph Myers [http://www.myersdaily.org/joseph/javascript/md5-text.html]()
  // Example:
  //   string.md5("foo") // => "acbd18db4cc2f85cedef654fccc4a4d8"

  /* ignore-in-doc
  this function is much faster,
  so if possible we use it. Some IEs
  are the only ones I know of that
  need the idiotic second function,
  generated by an if clause.  */
  // var add32 = hex(md51("hello")) === "5d41402abc4b2a76b9719d911017c592" ?
  //   function add32(a, b) { return (a + b) & 0xFFFFFFFF; } :
  var add32 = function add32(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF),
        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  };

  function cmn(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32(a << s | a >>> 32 - s, b);
  }

  function ff(a, b, c, d, x, s, t) {
    return cmn(b & c | ~b & d, a, b, x, s, t);
  }

  function gg(a, b, c, d, x, s, t) {
    return cmn(b & d | c & ~d, a, b, x, s, t);
  }

  function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | ~d), a, b, x, s, t);
  }

  function md5cycle(x, k) {
    var a = x[0],
        b = x[1],
        c = x[2],
        d = x[3];

    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);

    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);

    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);

    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);

    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  }

  function md51(s) {
    var n = s.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i;
    for (i = 64; i <= n; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        sl = s.length;
    for (i = 0; i < sl; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
      md5cycle(state, tail);
      i = 16;
      while (i--) {
        tail[i] = 0;
      }
      //			for (i=0; i<16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  }

  /* ignore-in-doc
   * there needs to be support for Unicode here,
   * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps
   * by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise
   * I suggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then
   * how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something
   * like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard
   * itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8
   * 8-bit unsigned value arrays.
   */
  function md5blk(s) {
    // ignore-in-doc
    /* I figured global was faster.   */
    var md5blks = [],
        i; /* Andy King said do it this way. */
    for (i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }

  var hex_chr = '0123456789abcdef'.split('');

  function rhex(n) {
    var s = '',
        j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
    }return s;
  }

  function hex(x) {
    var l = x.length;
    for (var i = 0; i < l; i++) {
      x[i] = rhex(x[i]);
    }return x.join('');
  }

  return hex(md51(string));
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// matching strings / regexps
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$$1(string, re) {
  // Different to the native `match` function this method returns an object
  // with `start`, `end`, and `match` fields
  // Example:
  //   string.reMatches("Hello World", /o/g)
  //   // => [{start: 4, end: 5, match: "o"},{start: 7, end: 8, match: "o"}]
  var matches = [];
  string.replace(re, function (match, idx) {
    matches.push({ match: match, start: idx, end: idx + match.length });
  });
  return matches;
}

function stringMatch(s, patternString, options) {
  // returns `{matched: true}` if success otherwise
  // `{matched: false, error: EXPLANATION, pattern: STRING|RE, pos: NUMBER}`
  // Example:
  //   string.stringMatch("foo 123 bar", "foo __/[0-9]+/__ bar") // => {matched: true}
  //   string.stringMatch("foo aaa bar", "foo __/[0-9]+/__ bar")
  //     // => {
  //     //   error: "foo <--UNMATCHED-->aaa bar",
  //     //   matched: false,
  //     //   pattern: /[0-9]+/,
  //     //   pos: 4
  //     // }
  options = options || {};
  if (!!options.normalizeWhiteSpace) s = s.replace(/\s+/g, ' ');
  if (!!options.ignoreIndent) {
    s = s.replace(/^\s+/gm, '');
    patternString = patternString.replace(/^\s+/gm, '');
  }
  return s == patternString ? { matched: true } : embeddedReMatch(s, patternString);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function splitInThree(string, start, end, startGap, endGap) {
    // ignore-in-doc
    // split string at start and end
    // return (0, start), (start, end), (end, ...)
    startGap = startGap || 0;endGap = endGap || 0;
    return [string.slice(0, start), string.slice(start + startGap, end - endGap), string.slice(end)];
  }

  function matchStringForward(s, pattern) {
    // ignore-in-doc
    // try to match pattern at beginning of string. if matched, return
    // result object with {
    //   match: STRING,
    //   REST: STRING -- remaining string after pattern was consumed
    // }
    if (pattern.constructor !== RegExp) {
      var idx = s.indexOf(pattern);
      if (idx === 0) return { match: pattern, rest: s.slice(pattern.length)
        // no match
      };for (var i = 0; i < pattern.length; i++) {
        // figure out where we failed
        if (pattern[i] != s[i]) return { match: null, pos: i };
      }return { match: null };
    }
    var matches = reMatches$$1(s, pattern);
    // show(matches)
    // show(string.slice(matches[0].end));
    return !matches || !matches.length || matches[0].start !== 0 ? { match: null } : { match: matches[0].match, rest: s.slice(matches[0].end) };
  }

  function matchStringForwardWithAllPatterns(s, patterns) {
    // ignore-in-doc
    // like matchStringForward, just apply list of patterns
    var pos = 0;
    for (var i = 0; i < patterns.length; i++) {
      var p = patterns[i],
          result = matchStringForward(s, p);
      if (!result.match) return { matched: false, pos: pos + (result.pos || 0), pattern: p };
      pos += result.match.length;
      s = result.rest;
    }
    return s.length ? { matched: false, pos: pos } : { matched: true };
  }

  function splitIntoPatterns(matcher) {
    var starts = reMatches$$1(matcher, /__\//g),
        ends = reMatches$$1(matcher, /\/__/g);
    if (starts.length !== ends.length) {
      throw new Error("pattern invalid: " + matcher + " cannot be split into __/.../__ embedded RegExps" + "\nstarts: " + JSON.stringify(starts) + '\nvs ends:\n' + JSON.stringify(ends));
    }
    var consumed = 0;
    return starts.reduce(function (patterns, start, i) {
      var end = ends[i];
      var matcher = patterns.pop();
      var splitted = splitInThree(matcher, start.start - consumed, end.end - consumed, 3, 3);
      if (splitted[0].length) {
        patterns.push(splitted[0]);
        consumed += splitted[0].length;
      }
      try {
        if (splitted[1].length) {
          patterns.push(new RegExp(splitted[1]));
          consumed += splitted[1].length + 3 + 3;
        }
      } catch (e) {
        throw new Error("Cannot create pattern re from: " + inspect(splitted));
      }
      if (splitted[2].length) {
        patterns.push(splitted[2]);
      }
      return patterns;
    }, [matcher]);
  }

  function embeddedReMatch(s, patternString) {
    // ignore-in-doc
    // the main match func
    var patterns = splitIntoPatterns(patternString);
    var result = matchStringForwardWithAllPatterns(s, patterns);
    if (result.matched) return result;
    result.error = s.slice(0, result.pos) + '<--UNMATCHED-->' + s.slice(result.pos);
    return result;
  }
}

function peekRight(s, start, needle) {
  // Finds the next occurence of `needle` (String or RegExp). Returns delta
  // index.
  // Example:
  // peekRight("Hello World", 0, /o/g) // => 4
  // peekRight("Hello World", 5, /o/) // => 2
  s = s.slice(start);
  if (typeof needle === 'string') {
    var idx = s.indexOf(needle);
    return idx === -1 ? null : idx + start;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return matches[0] ? matches[0].start : null;
  }
  return null;
}

function peekLeft(s, start, needle) {
  // Similar to `peekRight`
  s = s.slice(0, start);
  if (typeof needle === 'string') {
    var idx = s.lastIndexOf(needle);
    return idx === -1 ? null : idx;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return last(matches) ? last(matches).start : null;
  }
  return null;
}

function lineIndexComputer(s) {
  // String -> Function
  // For converting character positions to line numbers.
  // Returns a function accepting char positions. If the char pos is outside
  // of the line ranges -1 is returned.
  // Example:
  // var idxComp = lineIndexComputer("Hello\nWorld\n\nfoo");
  // idxComp(3) // => 0 (index 3 is "l")
  // idxComp(6) // => 1 (index 6 is "W")
  // idxComp(12) // => 2 (index 12 is "\n")

  // ignore-in-doc
  // line ranges: list of numbers, each line has two entries:
  // i -> start of line, i+1 -> end of line
  var _lineRanges = lineRanges(s);
  // ignore-in-doc
  // FIXME, this is O(n). Make cumputation more efficient, binary lookup?
  return function (pos) {
    for (var line = 0; line < _lineRanges.length; line++) {
      var lineRange = _lineRanges[line];
      if (pos >= lineRange[0] && pos < lineRange[1]) return line;
    }
    return -1;
  };
}

function lineNumberToIndexesComputer(s) {
  // String -> Function
  // For converting line numbers to [startIndex, endIndex]
  // Example:
  // var idxComp = lineNumberToIndexesComputer("Hello\nWorld\n\nfoo");
  // idxComp(1) // => [6,12]
  return function (lineNo) {
    return lineRanges(s)[lineNo];
  };
}

function lineRanges(s) {
  var from$$1 = 0,
      to = 0,
      linesOfS = lines(s),
      result = [];
  for (var i = 0; i < linesOfS.length; i++) {
    var line = linesOfS[i];
    to = from$$1 + line.length + 1;
    result.push([from$$1, to]);
    from$$1 = to;
  }
  return result;
}

function findLineWithIndexInLineRanges(lineRanges, idx) {
  // given a list of `lineRanges` (produced by
  // `livley.lang.string.lineRanges(string)`) like lineRanges = [[0, 12], [12, 33]]
  // and an string index `idx` into `string`, find the line no (the index into
  // `lineRanges`) that includes idx.  The index intervals include start and exclude end:
  // Example:
  // findLineWithIndex2(lineRanges, 2); // => 0
  // findLineWithIndex2(lineRanges, 12); // => 1
  // findLineWithIndex2(lineRanges, 33); // => 1
  // findLineWithIndex2(lineRanges, 34); // => -1
  // findLineWithIndex2(lineRanges, -4); // => -1
  var nRows = lineRanges.length;
  if (nRows === 0) return -1;
  // let currentRow = Math.floor(nRows/2), lastRow = nRows;
  var startRow = 0,
      endRow = nRows;
  while (true) {
    var middle = startRow + Math.floor((endRow - startRow) / 2),
        _lineRanges$middle = slicedToArray(lineRanges[middle], 2),
        from$$1 = _lineRanges$middle[0],
        to = _lineRanges$middle[1];

    if (idx < from$$1) {
      if (middle === 0) return -1;
      endRow = middle;
      continue;
    }
    if (idx > to) {
      startRow = middle;continue;
    }
    return middle;
  }
  return -1;
}

// -=-=-=-=-
// diffing
// -=-=-=-=-

function diff(s1, s2) {
  if (typeof JsDiff === "undefined") return 'diff not supported';
  return JsDiff.convertChangesToXML(JsDiff.diffWordsWithSpace(s1, s2));
}

// -=-=-=-=-
// testing
// -=-=-=-=-

function empty(s) {
  // show-in-doc
  return s == '';
}

var includes$$1 = features.includes ? function (s, pattern) {
  return s.includes(pattern);
} : function (s, pattern) {
  // Example:
  // include("fooo!", "oo") // => true
  return s.indexOf(pattern) > -1;
};

var include$$1 = includes$$1;

var startsWith = features.startsWith ? function (s, pattern) {
  return s.startsWith(pattern);
} : function (s, pattern) {
  // Example:
  // startsWith("fooo!", "foo") // => true
  return s.indexOf(pattern) === 0;
};

function startsWithVowel(s) {
  // show-in-doc
  var c = s[0];
  return c === 'A' || c === 'E' || c === 'I' || c === 'O' || c === 'U' || c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u' || false;
}

var endsWith = features.endsWith ? function (s, pattern) {
  return s.endsWith(pattern);
} : function (s, pattern) {
  // Example:
  // endsWith("fooo!", "o!") // => true
  var d = s.length - pattern.length;
  return d >= 0 && s.lastIndexOf(pattern) === d;
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// string conversion and manipulation
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function withDecimalPrecision(str, precision) {
  // String -> Number -> String
  // Example: withDecimalPrecision("1.12345678", 3) // => "1.123"
  var floatValue = parseFloat(str);
  return isNaN(floatValue) ? str : floatValue.toFixed(precision);
}

function capitalize(s) {
  // Example:
  // capitalize("foo bar") // => "Foo bar"
  return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}

function camelCaseString(s) {
  // Spaces to camels, including first char
  // Example: camelCaseString("foo bar baz") // => "FooBarBaz"
  return s.split(" ").invoke('capitalize').join("");
}

function camelize(s) {
  // Dashes to camels, excluding first char
  // Example: camelize("foo-bar-baz") // => "fooBarBaz"
  var parts = s.split('-'),
      len = parts.length;
  if (len == 1) return parts[0];

  var camelized = s.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];
  for (var i = 1; i < len; i++) {
    camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
  }return camelized;
}

function truncate(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? s.slice(0, length - truncation.length) + truncation : String(s);
}

function truncateLeft(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? truncation + s.slice(-length) : String(s);
}

function regExpEscape(s) {
  // For creating RegExps from strings and not worrying about proper escaping
  // of RegExp special characters to literally match those.
  // Example:
  // var re = new RegExp(regExpEscape("fooo{20}"));
  // re.test("fooo") // => false
  // re.test("fooo{20}") // => true
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}

function succ(s) {
  // Uses char code.
  // Example:
  // succ("a") // => "b"
  // succ("Z") // => "["
  return s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1);
}

function digitValue(s) {
  // ignore-in-doc
  return s.charCodeAt(0) - "0".charCodeAt(0);
}

var times = features.repeat ? function (s, count$$1) {
  return s.repeat(count$$1);
} : function (s, count$$1) {
  // Example:
  // string.times("test", 3) // => "testtesttest"
  return count$$1 < 1 ? '' : new Array(count$$1 + 1).join(s);
};

function applyChange(string, change) {
  // change is of the form
  // `{start: Number, end: Number, lines: [String], action: "insert"|"remove"}`
  if (change.action === "insert") {
    return string.slice(0, change.start) + change.lines.join("\n") + string.slice(change.start);
  } else if (change.action === "remove") {
    return string.slice(0, change.start) + string.slice(change.end);
  }
  return string;
}

function applyChanges(s, changes) {
  return changes.reduce(function (result, change) {
    return applyChange(s, change);
  }, s);
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// diffing / comparing

function levenshtein(a, b) {
  // How many edit operations separate string a from b?
  // MIT licensed, https://gist.github.com/andrei-
  // Copyright (c) 2011 Andrei Mackenzie and https://github.com/kigiri
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  var tmp, i, j, prev, val, row;
  // swap to save some memory O(min(a,b)) instead of O(a)
  if (a.length > b.length) {
    tmp = a;a = b;b = tmp;
  }

  row = Array(a.length + 1);
  // init the row
  for (i = 0; i <= a.length; i++) {
    row[i] = i;
  } // fill in the rest
  for (i = 1; i <= b.length; i++) {
    prev = i;
    for (j = 1; j <= a.length; j++) {
      if (b[i - 1] === a[j - 1]) {
        val = row[j - 1]; // match
      } else {
        val = Math.min(row[j - 1] + 1, // substitution
        Math.min(prev + 1, // insertion
        row[j] + 1)); // deletion
      }
      row[j - 1] = prev;
      prev = val;
    }
    row[a.length] = prev;
  }
  return row[a.length];
}



var string = Object.freeze({
	format: format,
	formatFromArray: formatFromArray,
	indent: indent,
	minIndent: minIndent,
	changeIndent: changeIndent,
	quote: quote,
	print: print,
	printNested: printNested,
	pad: pad,
	printTable: printTable,
	printTree: printTree,
	toArray: toArray$1,
	lines: lines,
	paragraphs: paragraphs,
	nonEmptyLines: nonEmptyLines,
	tokens: tokens,
	tableize: tableize,
	unescapeCharacterEntities: unescapeCharacterEntities,
	toQueryParams: toQueryParams,
	normalizePath: normalizePath$1,
	joinPath: joinPath,
	newUUID: newUUID,
	createDataURI: createDataURI,
	hashCode: hashCode,
	md5: md5,
	reMatches: reMatches$$1,
	stringMatch: stringMatch,
	peekRight: peekRight,
	peekLeft: peekLeft,
	lineIndexComputer: lineIndexComputer,
	lineNumberToIndexesComputer: lineNumberToIndexesComputer,
	findLineWithIndexInLineRanges: findLineWithIndexInLineRanges,
	lineRanges: lineRanges,
	diff: diff,
	empty: empty,
	includes: includes$$1,
	include: include$$1,
	startsWith: startsWith,
	startsWithVowel: startsWithVowel,
	endsWith: endsWith,
	withDecimalPrecision: withDecimalPrecision,
	capitalize: capitalize,
	camelCaseString: camelCaseString,
	camelize: camelize,
	truncate: truncate,
	truncateLeft: truncateLeft,
	regExpEscape: regExpEscape,
	succ: succ,
	digitValue: digitValue,
	times: times,
	applyChange: applyChange,
	applyChanges: applyChanges,
	levenshtein: levenshtein
});

/*
 * Utility functions for JS Numbers.
 */

function random(min, max) {
  // random number between (and including) `min` and `max`
  min = min || 0;
  max = max || 100;
  return Math.round(Math.random() * (max - min) + min);
}

var normalRandom = function (mean, stdDev) {
  // returns randomized numbers in a normal distribution that can be
  // controlled ising the `mean` and `stdDev` parameters
  var spare,
      isSpareReady = false;
  return function (mean, stdDev) {
    if (isSpareReady) {
      isSpareReady = false;
      return spare * stdDev + mean;
    } else {
      var u, v, s;
      do {
        u = Math.random() * 2 - 1;
        v = Math.random() * 2 - 1;
        s = u * u + v * v;
      } while (s >= 1 || s == 0);
      var mul = Math.sqrt(-2.0 * Math.log(s) / s);
      spare = v * mul;
      isSpareReady = true;
      return mean + stdDev * u * mul;
    }
  };
}();

function randomSmallerInteger(n) {
  return Math.floor(Math.random() * n);
}

function humanReadableByteSize(n) {
  // interpret `n` as byte size and print a more readable version
  // Example:
  //   num.humanReadableByteSize(Math.pow(2,32)) // => "4096MB"
  function round(n) {
    return Math.round(n * 100) / 100;
  }
  if (n < 1000) return String(round(n)) + 'B';
  n = n / 1024;
  if (n < 1000) return String(round(n)) + 'KB';
  n = n / 1024;
  return String(round(n)) + 'MB';
}

function average(numbers) {
  // show-in-doc
  return numbers.reduce(function (sum, n) {
    return sum + n;
  }, 0) / numbers.length;
}

function averageInc(newVal, oldAvg, n) {
  // show-in-doc
  // Example:
  //   let nums = range(0, 10).map(() => random(0, 10))
  //   nums.reduce((avg, ea, i) => avgInc(ea, avg, i+1), 0);
  return (newVal - oldAvg) / n + oldAvg;
}

function median(numbers) {
  // show-in-doc
  var sorted = numbers.sort(function (a, b) {
    return b - a;
  }),
      len = numbers.length;
  return len % 2 === 0 ? 0.5 * (sorted[len / 2 - 1] + sorted[len / 2]) : sorted[(len - 1) / 2];
}

function between(x, a, b, eps) {
  // is `a` <= `x` <= `y`?
  eps = eps || 0;
  var min, max;
  if (a < b) {
    min = a, max = b;
  } else {
    max = a, min = b;
  }
  return max - x + eps >= 0 && min - x - eps <= 0;
}

function sort$1(arr) {
  // numerical sort, JavaScript native `sort` function is lexical by default.
  return arr.sort(function (a, b) {
    return a - b;
  });
}

function parseLength(string, toUnit) {
  // This converts the length value to pixels or the specified `toUnit`.
  // length converstion, supported units are: mm, cm, in, px, pt, pc
  // Examples:
  // num.parseLength('3cm') // => 113.38582677165354
  // num.parseLength('3cm', "in") // => 1.1811023622047243
  toUnit = toUnit || 'px';
  var match = string.match(/([0-9\.]+)\s*(.*)/);
  if (!match || !match[1]) return undefined;
  var length = parseFloat(match[1]),
      fromUnit = match[2];
  return convertLength(length, fromUnit, toUnit);
}

var convertLength = function () {
  // ignore-in-doc
  // num.convertLength(20, 'px', 'pt').roundTo(0.01)
  function toCm(n, unit) {
    // as defined in http://www.w3.org/TR/css3-values/#absolute-lengths
    if (unit === 'cm') return n;else if (unit === 'mm') return n * 0.1;else if (unit === 'in') return n * 2.54;else if (unit === 'px') return n * toCm(1 / 96, 'in');else if (unit === 'pt') return n * toCm(1 / 72, 'in');else if (unit === 'pc') return n * toCm(12, 'pt');
  }
  return function to(length, fromUnit, toUnit) {
    if (fromUnit === toUnit) return length;else if (toUnit === "cm") return toCm(length, fromUnit);else if (fromUnit === "cm") return length / toCm(1, toUnit);else return to(to(length, fromUnit, 'cm'), 'cm', toUnit);
  };
}();

function roundTo(n, quantum) {
  // `quantum` is something like 0.01,

  // for JS rounding to work we need the reciprocal
  quantum = 1 / quantum;
  return Math.round(n * quantum) / quantum;
}

function detent(n, detent, grid, snap) {
  // This function is useful to implement smooth transitions and snapping.
  // Map all values that are within detent/2 of any multiple of grid to
  // that multiple. Otherwise, if snap is true, return self, meaning that
  // the values in the dead zone will never be returned. If snap is
  // false, then expand the range between dead zone so that it covers the
  // range between multiples of the grid, and scale the value by that
  // factor.
  // Examples:
  // // With snapping:
  // num.detent(0.11, 0.2, 0.5, true) // => 0.11
  // num.detent(0.39, 0.2, 0.5, true) // => 0.39
  // num.detent(0.55, 0.2, 0.5, true)  // => 0.5
  // num.detent(0.61, 0.2, 0.5, true)   // => 0.61
  // // Smooth transitions without snapping:
  // num.detent(0.1,  0.2, 0.5) // => 0
  // num.detent(0.11,  0.2, 0.5) // => 0.0166666
  // num.detent(0.34,  0.2, 0.5)  // => 0.4
  // num.detent(0.39,  0.2, 0.5) // => 0.4833334
  // num.detent(0.4,  0.2, 0.5) // => 0.5
  // num.detent(0.6,  0.2, 0.5) // => 0.5
  var r1 = roundTo(n, grid); // Nearest multiple of grid
  if (Math.abs(n - r1) < detent / 2) return r1; // Snap to that multiple...
  if (snap) return n; // ...and return n
  // or compute nearest end of dead zone
  var r2 = n < r1 ? r1 - detent / 2 : r1 + detent / 2;
  // and scale values between dead zones to fill range between multiples
  return r1 + (n - r2) * grid / (grid - detent);
}

function toDegrees(n) {
  // Example:
  // num.toDegrees(Math.PI/2) // => 90
  return n * 180 / Math.PI % 360;
}

function toRadians(n) {
  // Example:
  // num.toRadians(180) // => 3.141592653589793
  return n / 180 * Math.PI;
}

function backoff(attempt) /*ms*/{
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var cap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30000;

  // exponential backoff function
  // https://www.awsarchitectureblog.com/2015/03/backoff.html
  var temp = Math.min(cap, base * Math.pow(2, attempt)),
      sleep = temp / 2 + Math.round(Math.random() * (temp / 2));
  return Math.min(cap, base + Math.random() * (sleep * 3 - base));
}



var num = Object.freeze({
	random: random,
	normalRandom: normalRandom,
	randomSmallerInteger: randomSmallerInteger,
	humanReadableByteSize: humanReadableByteSize,
	average: average,
	averageInc: averageInc,
	median: median,
	between: between,
	sort: sort$1,
	parseLength: parseLength,
	convertLength: convertLength,
	roundTo: roundTo,
	detent: detent,
	toDegrees: toDegrees,
	toRadians: toRadians,
	backoff: backoff
});

function all$2(object, predicate) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if ((object.__lookupGetter__(name) || typeof object[name] !== 'function') && (predicate ? predicate(name, object) : true)) a.push(name);
  }
  return a;
}

function allOwnPropertiesOrFunctions(obj, predicate) {
  // ignore-in-doc
  return Object.getOwnPropertyNames(obj).reduce(function (result, name) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
    return result;
  }, []);
}

function own$1(object) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if (object.hasOwnProperty(name) && (object.__lookupGetter__(name) || object[name] !== 'function')) a.push(name);
  }
  return a;
}

function forEachOwn(object, func, context) {
  // ignore-in-doc
  var result = [];
  for (var name in object) {
    if (!object.hasOwnProperty(name)) continue;
    var value = object[name];
    if (value !== 'function') {
      result.push(func.call(context || this, name, value));
    }
  }
  return result;
}

function nameFor(object, value) {
  // ignore-in-doc
  for (var name in object) {
    if (object[name] === value) return name;
  }return undefined;
}

function values$1(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    values.push(obj[name]);
  }return values;
}

function ownValues(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    if (obj.hasOwnProperty(name)) values.push(obj[name]);
  }return values;
}

function any$1(obj, predicate) {
  // ignore-in-doc
  for (var name in obj) {
    if (predicate(obj, name)) return true;
  }return false;
}

function allProperties(obj, predicate) {
  // ignore-in-doc
  var result = [];
  for (var name in obj) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
  }return result;
}

function hash(obj) {
  // ignore-in-doc
  // Using the property names of `obj` to generate a hash value.
  return Object.keys(obj).sort().join('').hashCode();
}



var properties = Object.freeze({
	all: all$2,
	allOwnPropertiesOrFunctions: allOwnPropertiesOrFunctions,
	own: own$1,
	forEachOwn: forEachOwn,
	nameFor: nameFor,
	values: values$1,
	ownValues: ownValues,
	any: any$1,
	allProperties: allProperties,
	hash: hash
});

/*
 * Util functions to print and work with JS date objects.
 */

var dateFormat = function setupDateFormat() {

    /*
     * Date Format 1.2.3
     * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
     * MIT license
     *
     * Includes enhancements by Scott Trenda <scott.trenda.net>
     * and Kris Kowal <cixar.com/~kris.kowal/>
     *
     * Accepts a date, a mask, or a date and a mask.
     * Returns a formatted version of the given date.
     * The date defaults to the current date/time.
     * The mask defaults to dateFormat.masks.default.
     */

    // http://blog.stevenlevithan.com/archives/date-time-format

    var dateFormat = function () {
        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) {
                val = "0" + val;
            }return val;
        };

        // Regexes and supporting functions are cached through closure
        return function (date, mask, utc) {
            var dF = dateFormat;

            // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
            if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

            // Passing date through Date applies Date.parse, if necessary
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError("invalid date");

            mask = String(dF.masks[mask] || mask || dF.masks["default"]);

            // Allow setting the utc argument via the mask
            if (mask.slice(0, 4) == "UTC:") {
                mask = mask.slice(4);
                utc = true;
            }

            var _ = utc ? "getUTC" : "get",
                d = date[_ + "Date"](),
                D = date[_ + "Day"](),
                m = date[_ + "Month"](),
                y = date[_ + "FullYear"](),
                H = date[_ + "Hours"](),
                M = date[_ + "Minutes"](),
                s = date[_ + "Seconds"](),
                L = date[_ + "Milliseconds"](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                d: d,
                dd: pad(d),
                ddd: dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m: m + 1,
                mm: pad(m + 1),
                mmm: dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy: String(y).slice(2),
                yyyy: y,
                h: H % 12 || 12,
                hh: pad(H % 12 || 12),
                H: H,
                HH: pad(H),
                M: M,
                MM: pad(M),
                s: s,
                ss: pad(s),
                l: pad(L, 3),
                L: pad(L > 99 ? Math.round(L / 10) : L),
                t: H < 12 ? "a" : "p",
                tt: H < 12 ? "am" : "pm",
                T: H < 12 ? "A" : "P",
                TT: H < 12 ? "AM" : "PM",
                Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

            return mask.replace(token, function ($0) {
                return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
            });
        };
    }();

    // Some common format strings
    dateFormat.masks = {
        "default": "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    };

    // Internationalization strings
    dateFormat.i18n = {
        dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };

    return dateFormat;
}(); // end of setupDateFormat


function format$1(date, mask, utc) {
    // Custom date / time stringifier. Provides default masks:
    //
    // Mask           | Pattern
    // ---------------|--------------------------------
    // default        | `"ddd mmm dd yyyy HH:MM:ss"`
    // shortDate      | `"m/d/yy"`
    // mediumDate     | `"mmm d, yyyy"`
    // longDate       | `"mmmm d, yyyy"`
    // fullDate       | `"dddd, mmmm d, yyyy"`
    // shortTime      | `"h:MM TT"`
    // mediumTime     | `"h:MM:ss TT"`
    // longTime       | `"h:MM:ss TT Z"`
    // isoDate        | `"yyyy-mm-dd"`
    // isoTime        | `"HH:MM:ss"`
    // isoDateTime    | `"yyyy-mm-dd'T'HH:MM:ss"`
    // isoUtcDateTime | `"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"`
    //
    // and internationalized strings via `date.format.i18n.dayNames`
    // and `date.format.i18n.dayNames`
    // Examples:
    //   date.format(new Date(), date.format.masks.longTime) // => "7:13:31 PM PDT"
    //   date.format(new Date(), "yyyy/mm/dd") // => "2014/10/09"
    return dateFormat(date, mask, utc);
}

function equals$3(date, otherDate) {
    // show-in-doc
    return otherDate && otherDate instanceof Date && otherDate.getTime() === date.getTime();
}

function relativeTo(date, otherDate) {
    // Prints a human readable difference of two Date objects. The older date
    // goes first.
    // Examples:
    //   var now = new Date();
    //   date.relativeTo(new Date(now-2000), now) // => "2 secs"
    //   date.relativeTo(new Date("10/11/2014"), new Date("10/12/2014")) // => "1 day"
    if (!(otherDate instanceof Date)) return '';
    if (otherDate < date) return '';
    if (otherDate === date) return 'now';
    var minuteString = 'min',
        secondString = 'sec',
        hourString = 'hour',
        dayString = 'day',
        diff = otherDate - date,
        totalSecs = Math.round(diff / 1000),
        secs = totalSecs % 60,
        mins = Math.floor(totalSecs / 60) % 60,
        hours = Math.floor(totalSecs / 60 / 60) % 24,
        days = Math.floor(totalSecs / 60 / 60 / 24),
        parts = [];
    if (days > 0) {
        parts.push(days);
        if (days > 1) dayString += 's';
        parts.push(dayString);
    }
    if (hours > 0 && days < 2) {
        parts.push(hours);
        if (hours > 1) hourString += 's';
        parts.push(hourString);
    }
    if (mins > 0 && hours < 3 && days === 0) {
        parts.push(mins);
        if (mins > 1) minuteString += 's';
        parts.push(minuteString);
    }
    if (secs > 0 && mins < 3 && hours === 0 && days === 0) {
        parts.push(secs);
        if (secs > 1) secondString += 's';
        parts.push(secondString);
    }
    return parts.join(' ');
}



var date = Object.freeze({
	format: format$1,
	equals: equals$3,
	relativeTo: relativeTo
});

/*global require, process, Promise, System*/

/*
 * Methods helping with promises (Promise/A+ model). Not a promise shim.
 */

function promise(obj) {
  // Promise object / function converter
  // Example:
  // promise("foo");
  //   // => Promise({state: "fullfilled", value: "foo"})
  // lively.lang.promise({then: (resolve, reject) => resolve(23)})
  //   // => Promise({state: "fullfilled", value: 23})
  // lively.lang.promise(function(val, thenDo) { thenDo(null, val + 1) })(3)
  //   // => Promise({state: "fullfilled", value: 4})
  return typeof obj === "function" ? promise.convertCallbackFun(obj) : Promise.resolve(obj);
}

function delay$1(ms, resolveVal) {
  // Like `Promise.resolve(resolveVal)` but waits for `ms` milliseconds
  // before resolving
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms, resolveVal);
  });
}

function delayReject(ms, rejectVal) {
  // like `promise.delay` but rejects
  return new Promise(function (_, reject$$1) {
    return setTimeout(reject$$1, ms, rejectVal);
  });
}

function timeout(ms, promise) {
  // Takes a promise and either resolves to the value of the original promise
  // when it succeeds before `ms` milliseconds passed or fails with a timeout
  // error
  return new Promise(function (resolve, reject$$1) {
    var done = false;
    setTimeout(function () {
      return !done && (done = true) && reject$$1(new Error('Promise timed out'));
    }, ms);
    promise.then(function (val) {
      return !done && (done = true) && resolve(val);
    }, function (err) {
      return !done && (done = true) && reject$$1(err);
    });
  });
}

function waitFor$1(ms, tester, timeoutObj) {
  // Tests for a condition calling function `tester` until the result is
  // truthy. Resolves with last return value of `tester`. If `ms` is defined
  // and `ms` milliseconds passed, reject with timeout error
  // if timeoutObj is passed will resolve(!) with this object instead of raise
  // an error
  if (typeof ms === "function") {
    tester = ms;ms = undefined;
  }
  return new Promise(function (resolve, reject$$1) {
    var stopped = false,
        timedout = false,
        timeoutValue = undefined,
        error = undefined,
        value = undefined,
        i = setInterval(function () {
      if (stopped) return clearInterval(i);
      try {
        value = tester();
      } catch (e) {
        error = e;
      }
      if (!value && !error && !timedout) return;
      stopped = true;
      clearInterval(i);
      if (error) return reject$$1(error);
      if (timedout) return typeof timeoutObj === "undefined" ? reject$$1(new Error("timeout")) : resolve(timeoutObj);
      return resolve(value);
    }, 10);
    if (typeof ms === "number") setTimeout(function () {
      return timedout = true;
    }, ms);
  });
}

function deferred() {
  // returns an object
  // `{resolve: FUNCTION, reject: FUNCTION, promise: PROMISE}`
  // that separates the resolve/reject handling from the promise itself
  // Similar to the deprecated `Promise.defer()`
  var resolve,
      reject$$1,
      promise = new Promise(function (_resolve, _reject) {
    resolve = _resolve;reject$$1 = _reject;
  });
  return { resolve: resolve, reject: reject$$1, promise: promise };
}

function convertCallbackFun(func) {
  // Takes a function that accepts a nodejs-style callback function as a last
  // parameter and converts it to a function *not* taking the callback but
  // producing a promise instead. The promise will be resolved with the
  // *first* non-error argument.
  // nodejs callback convention: a function that takes as first parameter an
  // error arg and second+ parameters are the result(s).
  // Example:
  // var fs = require("fs"),
  //     readFile = promise.convertCallbackFun(fs.readFile);
  // readFile("./some-file.txt")
  //   .then(content => console.log(String(content)))
  //   .catch(err => console.error("Could not read file!", err));
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject$$1) {
      args.push(function (err, result) {
        return err ? reject$$1(err) : resolve(result);
      });
      func.apply(self, args);
    });
  };
}

function convertCallbackFunWithManyArgs(func) {
  // like convertCallbackFun but the promise will be resolved with the
  // all non-error arguments wrapped in an array.
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject$$1) {
      args.push(function () /*err + args*/{
        var args = Array.from(arguments),
            err = args.shift();
        return err ? reject$$1(err) : resolve(args);
      });
      func.apply(self, args);
    });
  };
}

function _chainResolveNext(promiseFuncs, prevResult, akku, resolve, reject$$1) {
  var next = promiseFuncs.shift();
  if (!next) resolve(prevResult);else {
    try {
      Promise.resolve(next(prevResult, akku)).then(function (result) {
        return _chainResolveNext(promiseFuncs, result, akku, resolve, reject$$1);
      }).catch(function (err) {
        reject$$1(err);
      });
    } catch (err) {
      reject$$1(err);
    }
  }
}

function chain$1(promiseFuncs) {
  // Similar to Promise.all but takes a list of promise-producing functions
  // (instead of Promises directly) that are run sequentially. Each function
  // gets the result of the previous promise and a shared "state" object passed
  // in. The function should return either a value or a promise. The result of
  // the entire chain call is a promise itself that either resolves to the last
  // returned value or rejects with an error that appeared somewhere in the
  // promise chain. In case of an error the chain stops at that point.
  // Example:
  // lively.lang.promise.chain([
  //   () => Promise.resolve(23),
  //   (prevVal, state) => { state.first = prevVal; return prevVal + 2 },
  //   (prevVal, state) => { state.second = prevVal; return state }
  // ]).then(result => console.log(result));
  // // => prints {first: 23,second: 25}
  return new Promise(function (resolve, reject$$1) {
    return _chainResolveNext(promiseFuncs.slice(), undefined, {}, resolve, reject$$1);
  });
}

function promise_finally(promise, finallyFn) {
  return Promise.resolve(promise).then(function (result) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }return result;
  }).catch(function (err) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }throw err;
  });
}

function parallel(promiseGenFns) {
  var parallelLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;

  // Starts functions from promiseGenFns that are expected to return a promise
  // Once `parallelLimit` promises are unresolved at the same time, stops
  // spawning further promises until a running promise resolves

  if (!promiseGenFns.length) return Promise.resolve([]);

  var results = [],
      error = null,
      index = 0,
      left = promiseGenFns.length,
      resolve = void 0,
      reject$$1 = void 0;

  return new Promise(function (res, rej) {
    resolve = function resolve() {
      return res(results);
    };
    reject$$1 = function reject$$1(err) {
      return rej(error = err);
    };
    spawnMore();
  });

  function spawn() {
    parallelLimit--;
    try {
      var i = index++,
          prom = promiseGenFns[i]();
      prom.then(function (result) {
        parallelLimit++;
        results[i] = result;
        if (--left === 0) resolve();else spawnMore();
      }).catch(function (err) {
        return reject$$1(err);
      });
    } catch (err) {
      reject$$1(err);
    }
  }

  function spawnMore() {
    while (!error && left > 0 && index < promiseGenFns.length && parallelLimit > 0) {
      spawn();
    }
  }
}

// FIXME!
Object.assign(promise, {
  delay: delay$1,
  delayReject: delayReject,
  timeout: timeout,
  waitFor: waitFor$1,
  deferred: deferred,
  convertCallbackFun: convertCallbackFun,
  convertCallbackFunWithManyArgs: convertCallbackFunWithManyArgs,
  chain: chain$1,
  "finally": promise_finally,
  parallel: parallel
});

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// js object path accessor
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

// show-in-doc
// A `Path` is an objectified chain of property names (kind of a "complex"
// getter and setter). Path objects can make access and writes into deeply nested
// structures more convenient. `Path` provide "safe" get and set operations and
// can be used for debugging by providing a hook that allows users to find out
// when get/set operations happen.

function Path(p, splitter) {
  if (p instanceof Path) return p;
  if (!(this instanceof Path)) return new Path(p, splitter);
  this.setSplitter(splitter || '.');
  this.fromPath(p);
}

Object.assign(Path.prototype, {

  get isPathAccessor() {
    return true;
  },

  fromPath: function fromPath(path) {
    // ignore-in-doc
    if (typeof path === "string" && path !== '' && path !== this.splitter) {
      this._parts = path.split(this.splitter);
      this._path = path;
    } else if (Array.isArray(path)) {
      this._parts = [].concat(path);
      this._path = path.join(this.splitter);
    } else {
      this._parts = [];
      this._path = '';
    }
    return this;
  },
  setSplitter: function setSplitter(splitter) {
    // ignore-in-doc
    if (splitter) this.splitter = splitter;
    return this;
  },
  parts: function parts() {
    /*key names as array*/return this._parts;
  },
  size: function size() {
    /*show-in-doc*/return this._parts.length;
  },
  slice: function slice(n, m) {
    /*show-in-doc*/return Path(this.parts().slice(n, m));
  },
  normalizePath: function normalizePath() {
    // ignore-in-doc
    // FIXME: define normalization
    return this._path;
  },
  isRoot: function isRoot(obj) {
    return this._parts.length === 0;
  },
  isIn: function isIn(obj) {
    // Does the Path resolve to a value when applied to `obj`?
    if (this.isRoot()) return true;
    var parent = this.get(obj, -1);
    return parent && parent.hasOwnProperty(this._parts[this._parts.length - 1]);
  },
  equals: function equals(obj) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path(["foo", 1, "bar", "baz"]);
    // // Path's can be both created via strings or pre-parsed with keys in a list.
    // p1.equals(p2) // => true
    return obj && obj.isPathAccessor && this.parts().equals(obj.parts());
  },
  isParentPathOf: function isParentPathOf(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1.bar");
    // p2.isParentPathOf(p1) // => true
    // p1.isParentPathOf(p2) // => false
    otherPath = otherPath && otherPath.isPathAccessor ? otherPath : Path(otherPath);
    var parts = this.parts(),
        otherParts = otherPath.parts();
    for (var i = 0; i < parts.length; i++) {
      if (parts[i] != otherParts[i]) return false;
    }
    return true;
  },
  relativePathTo: function relativePathTo(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1");
    // p2.relativePathTo(p1) // => Path(["bar","baz"])
    // p1.relativePathTo(p2) // => undefined
    otherPath = Path(otherPath);
    return this.isParentPathOf(otherPath) ? otherPath.slice(this.size(), otherPath.size()) : undefined;
  },
  del: function del(obj) {
    if (this.isRoot()) return false;
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part)) {
        parent = parent[part];
      } else return false;
    }
    return delete parent[this._parts[this._parts.length - 1]];
  },
  withParentAndKeyDo: function withParentAndKeyDo(obj, ensure, doFunc) {
    // Deeply resolve path in `obj`, not fully, however, only to the parent
    // element of the last part of path. Take the parent, the key (the last
    // part of path) and pass it to `doFunc`. When `ensure` is true, create
    // objects along path it path does not resolve
    if (this.isRoot()) return doFunc(null, null);
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part) && (_typeof(parent[part]) === "object" || typeof parent[part] === "function")) {
        parent = parent[part];
      } else if (ensure) {
        parent = parent[part] = {};
      } else {
        return doFunc(null, part);
      }
    }
    return doFunc(parent, this._parts[this._parts.length - 1]);
  },
  set: function set(obj, val, ensure) {
    // Deeply resolve path in `obj` and set the resulting property to `val`. If
    // `ensure` is true, create nested structure in between as necessary.
    // Example:
    // var o1 = {foo: {bar: {baz: 42}}};
    // var path = Path("foo.bar.baz");
    // path.set(o1, 43)
    // o1 // => {foo: {bar: {baz: 43}}}
    // var o2 = {foo: {}};
    // path.set(o2, 43, true)
    // o2 // => {foo: {bar: {baz: 43}}}
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? parent[key] = val : undefined;
    });
  },
  defineProperty: function defineProperty(obj, propertySpec, ensure) {
    // like `Path>>set`, however uses Objeect.defineProperty
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? Object.defineProperty(parent, key, propertySpec) : undefined;
    });
  },
  get: function get(obj, n) {
    // show-in-doc
    var parts = n ? this._parts.slice(0, n) : this._parts;
    return parts.reduce(function (current, pathPart) {
      return current ? current[pathPart] : current;
    }, obj);
  },
  concat: function concat(p, splitter) {
    // show-in-doc
    return Path(this.parts().concat(Path(p, splitter).parts()));
  },
  toString: function toString() {
    return this.normalizePath();
  },
  serializeExpr: function serializeExpr() {
    // ignore-in-doc
    return 'lively.lang.Path(' + inspect(this.parts()) + ')';
  },
  watch: function watch(options) {
    // React or be notified on reads or writes to a path in a `target`. Options:
    // ```js
    // {
    //   target: OBJECT,
    //   uninstall: BOOLEAN,
    //   onGet: FUNCTION,
    //   onSet: FUNCTION,
    //   haltWhenChanged: BOOLEAN,
    //   verbose: BOOLEAN
    // }
    // ```
    // Example:
    // // Quite useful for debugging to find out what call-sites change an object.
    // var o = {foo: {bar: 23}};
    // Path("foo.bar").watch({target: o, verbose: true});
    // o.foo.bar = 24; // => You should see: "[object Object].bar changed: 23 -> 24"
    if (!options || this.isRoot()) return;
    var target = options.target,
        parent = this.get(target, -1),
        propName = this.parts().slice(-1)[0],
        newPropName = 'propertyWatcher$' + propName,
        watcherIsInstalled = parent && parent.hasOwnProperty(newPropName),
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged,
        showStack = options.showStack,
        getter = parent.__lookupGetter__(propName),
        setter = parent.__lookupSetter__(propName);
    if (!target || !propName || !parent) return;
    if (uninstall) {
      if (!watcherIsInstalled) return;
      delete parent[propName];
      parent[propName] = parent[newPropName];
      delete parent[newPropName];
      var msg = 'Watcher for ' + parent + '.' + propName + ' uninstalled';
      show(msg);
      return;
    }
    if (watcherIsInstalled) {
      var msg = 'Watcher for ' + parent + '.' + propName + ' already installed';
      show(msg);
      return;
    }
    if (getter || setter) {
      var msg = parent + '["' + propName + '"] is a getter/setter, watching not support';
      console.log(msg);
      if (typeof show === "undefined") show(msg);
      return;
    }
    // observe slots, for debugging
    parent[newPropName] = parent[propName];
    parent.__defineSetter__(propName, function (v) {
      var oldValue = parent[newPropName];
      if (options.onSet) options.onSet(v, oldValue);
      var msg = parent + "." + propName + " changed: " + oldValue + " -> " + v;
      if (showStack) msg += '\n' + (typeof lively !== "undefined" ? lively.printStack() : console.trace());
      if (options.verbose) {
        console.log(msg);
        if (typeof show !== 'undefined') show(msg);
      }
      if (haltWhenChanged) debugger;
      return parent[newPropName] = v;
    });
    parent.__defineGetter__(propName, function () {
      if (options.onGet) options.onGet(parent[newPropName]);
      return parent[newPropName];
    });
    var msg = 'Watcher for ' + parent + '.' + propName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  },
  debugFunctionWrapper: function debugFunctionWrapper(options) {
    // ignore-in-doc
    // options = {target, [haltWhenChanged, showStack, verbose, uninstall]}
    var target = options.target,
        parent = this.get(target, -1),
        funcName = this.parts().slice(-1)[0],
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged === undefined ? true : options.haltWhenChanged,
        showStack = options.showStack,
        func = parent && funcName && parent[funcName],
        debuggerInstalled = func && func.isDebugFunctionWrapper;
    if (!target || !funcName || !func || !parent) return;
    if (uninstall) {
      if (!debuggerInstalled) return;
      parent[funcName] = parent[funcName].debugTargetFunction;
      var msg = 'Uninstalled debugFunctionWrapper for ' + parent + '.' + funcName;
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      show(msg);
      return;
    }
    if (debuggerInstalled) {
      var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' already installed';
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      return;
    }
    var debugFunc = parent[funcName] = func.wrap(function (proceed) {
      var args = Array.from(arguments);
      if (haltWhenChanged) debugger;
      if (showStack) show(lively.printStack());
      if (options.verbose) show(funcName + ' called');
      return args.shift().apply(parent, args);
    });
    debugFunc.isDebugFunctionWrapper = true;
    debugFunc.debugTargetFunction = func;
    var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  }
});

/*
Computation over graphs. Unless otherwise specified a graph is a simple JS
object whose properties are interpreted as nodes that refer to arrays whose
elements describe edges. Example:

```js
var testGraph = {
  "a": ["b", "c"],
  "b": ["c", "d", "e", "f"],
  "d": ["c", "f"],
  "e": ["a", "f"],
  "f": []
}
```
*/

// show-in-doc
function clone$2(graph) {
  // return a copy of graph map
  var cloned = {};
  for (var id in graph) {
    cloned[id] = graph[id].slice();
  }return cloned;
}

function without$1(graph, ids) {
  // return a copy of graph map with ids removed
  var cloned = {};
  for (var id in graph) {
    if (ids.includes(id)) continue;
    cloned[id] = [];
    var refs = graph[id];
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      if (!ids.includes(ref)) cloned[id].push(ref);
    }
  }
  return cloned;
}

function hull(g, id) {
  var ignoredKeyList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

  // Takes a graph in object format and a start id and then traverses the
  // graph and gathers all nodes that can be reached from that start id.
  // Returns a list of those nodes.
  // Optionally use `ignore` list to filter out certain nodes that shouldn't
  // be considered and maxDepth to stop early. By default a maxDepth of 20 is
  // used.
  // Example:
  // var testGraph = {
  // "a": ["b", "c"],
  // "b": ["c", "d", "e", "f"],
  // "d": ["c", "f"],
  // "e": ["a", "f"],
  // "f": []
  // }
  // hull(testGraph, "d") // => ["c", "f"]
  // hull(testGraph, "e") // => ['a', 'f', 'b', 'c', 'd', 'e']
  // hull(testGraph, "e", ["b"]) // => ["a", "f", "c"]

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // below is an optimized variant, the functional but slow version:
  // return uniq(
  //         flatten(
  //           values(
  //             subgraphReachableBy(
  //               graphMap, id, ignore, maxDepth))));

  if (!Array.isArray(g[id])) return [];

  var hull = [],
      visited = {};

  var ignoredKeys = {};
  for (var i = 0; i < ignoredKeyList.length; i++) {
    ignoredKeys[ignoredKeyList[i]] = true;
  }var toVisitList = g[id].slice(),
      toVisitMapAndDistFromRoot = {};
  for (var _i = toVisitList.length; _i--;) {
    var key = toVisitList[_i];
    if (key in ignoredKeys) toVisitList.splice(_i, 1);else toVisitMapAndDistFromRoot[key] = 1;
  }

  if (ignoredKeyList) while (true) {
    if (toVisitList.length === 0) break;
    for (var _i2 = 0; _i2 < toVisitList.length; _i2++) {
      var _key = toVisitList.shift();
      if (_key in visited || _key in ignoredKeys) continue;
      var dist = toVisitMapAndDistFromRoot[_key] || 0;
      if (dist > maxDepth) continue;
      hull.push(_key);
      visited[_key] = true;
      var refs = g[_key];
      if (!refs) continue;
      for (var j = 0; j < refs.length; j++) {
        var refKey = refs[j];
        if (refKey in visited || refKey in toVisitMapAndDistFromRoot) continue;
        toVisitMapAndDistFromRoot[refKey] = dist + 1;
        toVisitList.push(refKey);
      }
    }
  }
  return hull;
}

function subgraphReachableBy(graphMap, startId, ignore) {
  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

  // show-in-doc
  // Like hull but returns subgraph map of `graphMap`
  // Example:
  // subgraphReachableBy(testGraph, "e", [], 2);
  // // => {e: [ 'a', 'f' ], a: [ 'b', 'c' ], f: []}
  if (ignore) graphMap = without$1(graphMap, ignore);
  var ids = [startId],
      step = 0,
      subgraph = {};
  while (ids.length && step++ < maxDepth) {
    var id = ids.shift();
    if (subgraph[id]) continue;
    var newIds = graphMap[id] || [];
    subgraph[id] = newIds;
    ids.push.apply(ids, toConsumableArray(newIds));
  }
  return subgraph;
}

function invert(g) {
  // inverts the references of graph object `g`.
  // Example:
  // invert({a: ["b"], b: ["a", "c"]})
  //   // => {a: ["b"], b: ["a"], c: ["b"]}
  var inverted = {};
  for (var key in g) {
    var refs = g[key];
    for (var i = 0; i < refs.length; i++) {
      var key2 = refs[i];
      if (!inverted[key2]) inverted[key2] = [key];else inverted[key2].push(key);
    }
  }
  return inverted;
}

function sortByReference(depGraph, startNode) {
  // Sorts graph into an array of arrays. Each "bucket" contains the graph
  // nodes that have no other incoming nodes than those already visited. This
  // means, we start with the leaf nodes and then walk our way up.
  // This is useful for computing how to traverse a dependency graph: You get
  // a sorted list of dependencies that also allows circular references.
  // Example:
  // var depGraph = {a: ["b", "c"], b: ["c"], c: ["b"]};
  // sortByReference(depGraph, "a");
  // // => [["c"], ["b"], ["a"]]

  var all$$1 = [startNode].concat(hull(depGraph, startNode)),
      seen = [],
      groups = [];

  while (seen.length !== all$$1.length) {
    var depsRemaining = withoutAll(all$$1, seen).reduce(function (depsRemaining, node) {
      depsRemaining[node] = withoutAll(depGraph[node] || [], seen).length;
      return depsRemaining;
    }, {}),
        min$$1 = withoutAll(all$$1, seen).reduce(function (minNode, node) {
      return depsRemaining[node] <= depsRemaining[minNode] ? node : minNode;
    });

    if (depsRemaining[min$$1] === 0) {
      groups.push(Object.keys(depsRemaining).filter(function (key) {
        return depsRemaining[key] === 0;
      }));
    } else {
      groups.push([min$$1]);
    }

    seen = flatten(groups);
  }

  return groups;
}

function reduce$1(doFunc, graph, rootNode, carryOver, ignore, context) {
  // Starts with `rootNode` and visits all (in)directly related nodes, calling
  // `doFunc` at each node. The result of `doFunc` is passed as first
  // argument to the next iterator call. For the first call the value
  // `carryOver` is used.
  // Example:
  // var depGraph = {a: ["b", "c"],b: ["c"]}
  // graphReduce((_, ea, i) => console.log("%s %s", ea, i), depGraph, "a")

  var visitedNodes = ignore || [],
      index = 0;
  iterator(rootNode);
  return carryOver;

  function iterator(currentNode) {
    if (visitedNodes.indexOf(currentNode) > -1) return;
    carryOver = doFunc.call(context, carryOver, currentNode, index++);
    visitedNodes = visitedNodes.concat([currentNode]);
    var next = withoutAll(graph[currentNode] || [], visitedNodes);
    next.forEach(function (ea) {
      return iterator(ea);
    });
  }
}

function random$1() {
  var nKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

  var g = {},
      keys$$1 = range(1, nKeys).map(String);
  for (var i = 0; i < keys$$1.length; i++) {
    var r = Math.floor(Math.random() * nKeys);
    g[keys$$1[i]] = shuffle(keys$$1).slice(0, r);
  }
  return g;
}



var graph = Object.freeze({
	clone: clone$2,
	without: without$1,
	hull: hull,
	subgraphReachableBy: subgraphReachableBy,
	invert: invert,
	sortByReference: sortByReference,
	reduce: reduce$1,
	random: random$1
});

/*global System, global*/

// show-in-doc
// Intervals are arrays whose first two elements are numbers and the
// first element should be less or equal the second element, see
// [`interval.isInterval`](). This abstraction is useful when working with text
// ranges in rich text, for example.

var GLOBAL$2 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

function isInterval(object) {
  // Example:
  // interval.isInterval([1,12]) // => true
  // interval.isInterval([1,12, {property: 23}]) // => true
  // interval.isInterval([1]) // => false
  // interval.isInterval([12, 1]) // => false
  return Array.isArray(object) && object.length >= 2 && object[0] <= object[1];
}

function sort$2(intervals) {
  // Sorts intervals according to rules defined in [`interval.compare`]().
  return intervals.sort(compare);
}

function compare(a, b) {
  // How [`interval.sort`]() compares.
  // We assume that `a[0] <= a[1] and b[0] <= b[1]` according to `isInterval`
  // ```
  // -3: a < b and non-overlapping, e.g [1,2] and [3,4]
  // -2: a < b and intervals border at each other, e.g [1,3] and [3,4]
  // -1: a < b and overlapping, e.g, [1,3] and [2,4] or [1,3] and [1,4]
  //  0: a = b, e.g. [1,2] and [1,2]
  //  1: a > b and overlapping, e.g. [2,4] and [1,3]
  //  2: a > b and share border, e.g [1,4] and [0,1]
  //  3: a > b and non-overlapping, e.g [2,4] and [0,1]
  // ```
  if (a[0] < b[0]) {
    // -3 || -2 || -1
    if (a[1] < b[0]) return -3;
    if (a[1] === b[0]) return -2;
    return -1;
  }
  if (a[0] === b[0]) {
    // -1 || 0 || 1
    if (a[1] === b[1]) return 0;
    return a[1] < b[1] ? -1 : 1;
  }
  // we know a[0] > b[0], 1 || 2 || 3
  return -1 * compare(b, a);
}

function coalesce(interval1, interval2, optMergeCallback) {
  // Turns two interval into one iff compare(interval1, interval2)  [-2,
  // -1,0,1, 2] (see [`inerval.compare`]()).
  // Otherwise returns null. Optionally uses merge function.
  // Examples:
  //   interval.coalesce([1,4], [5,7]) // => null
  //   interval.coalesce([1,2], [1,2]) // => [1,2]
  //   interval.coalesce([1,4], [3,6]) // => [1,6]
  //   interval.coalesce([3,6], [4,5]) // => [3,6]
  var cmpResult = this.compare(interval1, interval2);
  switch (cmpResult) {
    case -3:
    case 3:
      return null;
    case 0:
      optMergeCallback && optMergeCallback(interval1, interval2, interval1);
      return interval1;
    case 2:
    case 1:
      var temp = interval1;interval1 = interval2;interval2 = temp; // swap
    case -2:
    case -1:
      var coalesced = [interval1[0], Math.max(interval1[1], interval2[1])];
      optMergeCallback && optMergeCallback(interval1, interval2, coalesced);
      return coalesced;
    default:
      throw new Error("Interval compare failed");
  }
}

function coalesceOverlapping(intervals, mergeFunc) {
  // Like `coalesce` but accepts an array of intervals.
  // Example:
  //   interval.coalesceOverlapping([[9,10], [1,8], [3, 7], [15, 20], [14, 21]])
  //   // => [[1,8],[9,10],[14,21]]
  var condensed = [],
      len = intervals.length;
  while (len > 0) {
    var ival = intervals.shift();len--;
    for (var i = 0; i < len; i++) {
      var otherInterval = intervals[i],
          coalesced = coalesce(ival, otherInterval, mergeFunc);
      if (coalesced) {
        ival = coalesced;
        intervals.splice(i, 1);
        len--;i--;
      }
    }
    condensed.push(ival);
  }
  return this.sort(condensed);
}

function mergeOverlapping(intervalsA, intervalsB, mergeFunc) {
  var result = [];
  while (intervalsA.length > 0) {
    var intervalA = intervalsA.shift();

    var toMerge = intervalsB.map(function (intervalB) {
      var cmp = compare(intervalA, intervalB);
      return cmp === -1 || cmp === 0 || cmp === 1;
    });

    result.push(mergeFunc(intervalA, toMerge[0]));

    result.push(intervalA);
  }
  return result;
}

function intervalsInRangeDo(start, end, intervals, iterator, mergeFunc, context) {
  // Merges and iterates through sorted intervals. Will "fill up"
  // intervals. This is currently used for computing text chunks in
  // lively.morphic.TextCore.
  // Example:
  // interval.intervalsInRangeDo(
  //   2, 10, [[0, 1], [5,8], [2,4]],
  //   function(i, isNew) { i.push(isNew); return i; })
  // // => [[2,4,false],[4,5,true],[5,8,false],[8,10,true]]

  context = context || GLOBAL$2;
  // need to be sorted for the algorithm below
  intervals = this.sort(intervals);
  var free = [],
      nextInterval,
      collected = [];
  // merged intervals are already sorted, simply "negate" the interval array;
  while (nextInterval = intervals.shift()) {
    if (nextInterval[1] < start) continue;
    if (nextInterval[0] < start) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[0] = start;
    }
    var nextStart = end < nextInterval[0] ? end : nextInterval[0];
    if (start < nextStart) {
      collected.push(iterator.call(context, [start, nextStart], true));
    }
    if (end < nextInterval[1]) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[1] = end;
    }
    // special case, the newly constructed interval has length 0,
    // happens when intervals contains doubles at the start
    if (nextInterval[0] === nextInterval[1]) {
      var prevInterval;
      if (mergeFunc && (prevInterval = collected.slice(-1)[0])) {
        // arguments: a, b, merged, like in the callback of #merge
        mergeFunc.call(context, prevInterval, nextInterval, prevInterval);
      }
    } else {
      collected.push(iterator.call(context, nextInterval, false));
    }
    start = nextInterval[1];
    if (start >= end) break;
  }
  if (start < end) collected.push(iterator.call(context, [start, end], true));
  return collected;
}

function intervalsInbetween(start, end, intervals) {
  // Computes "free" intervals between the intervals given in range start - end
  // currently used for computing text chunks in lively.morphic.TextCore
  // Example:
  // interval.intervalsInbetween(0, 10,[[1,4], [5,8]])
  // // => [[0,1],[4,5],[8,10]]
  return intervalsInRangeDo(start, end, coalesceOverlapping(Array.prototype.slice.call(intervals)), function (interval, isNew) {
    return isNew ? interval : null;
  }).filter(Boolean);
}

function mapToMatchingIndexes(intervals, intervalsToFind) {
  // Returns an array of indexes of the items in intervals that match
  // items in `intervalsToFind`.
  // Note: We expect intervals and intervals to be sorted according to [`interval.compare`]()!
  // This is the optimized version of:
  // ```
  // return intervalsToFind.collect(function findOne(toFind) {
  //    var startIdx, endIdx;
  //    var start = intervals.detect(function(ea, i) {
  //       startIdx = i; return ea[0] === toFind[0]; });
  //    if (start === undefined) return [];
  //    var end = intervals.detect(function(ea, i) {
  //       endIdx = i; return ea[1] === toFind[1]; });
  //    if (end === undefined) return [];
  //    return Array.range(startIdx, endIdx);
  // });
  // ```

  var startIntervalIndex = 0,
      endIntervalIndex,
      currentInterval;
  return intervalsToFind.map(function (toFind) {
    while (currentInterval = intervals[startIntervalIndex]) {
      if (currentInterval[0] < toFind[0]) {
        startIntervalIndex++;continue;
      }
      break;
    }
    if (currentInterval && currentInterval[0] === toFind[0]) {
      endIntervalIndex = startIntervalIndex;
      while (currentInterval = intervals[endIntervalIndex]) {
        if (currentInterval[1] < toFind[1]) {
          endIntervalIndex++;continue;
        }
        break;
      }
      if (currentInterval && currentInterval[1] === toFind[1]) {
        return range(startIntervalIndex, endIntervalIndex);
      }
    }
    return [];
  });
}



var interval = Object.freeze({
	isInterval: isInterval,
	sort: sort$2,
	compare: compare,
	coalesce: coalesce,
	coalesceOverlapping: coalesceOverlapping,
	mergeOverlapping: mergeOverlapping,
	intervalsInRangeDo: intervalsInRangeDo,
	intervalsInbetween: intervalsInbetween,
	mapToMatchingIndexes: mapToMatchingIndexes
});

// show-in-doc
// Accessor to sub-ranges of arrays. This is used, for example, for rendering
// large lists or tables in which only a part of the items should be used for
// processing or rendering. An array projection provides convenient access and
// can apply operations to sub-ranges.

function create(array, length, optStartIndex) {
  // Example:
  // arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  var startIndex = optStartIndex || 0;
  if (startIndex + length > array.length) startIndex -= startIndex + length - array.length;
  return { array: array, from: startIndex, to: startIndex + length };
}

function toArray$4(projection) {
  // show-in-doc
  return projection.array.slice(projection.from, projection.to);
}

function originalToProjectedIndex(projection, index) {
  // Maps index from original Array to projection.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.originalToProjectedIndex(proj, 1) // => null
  //   arrayProjection.originalToProjectedIndex(proj, 3) // => 0
  //   arrayProjection.originalToProjectedIndex(proj, 5) // => 2
  return index < projection.from || index >= projection.to ? null : index - projection.from;
}

function projectedToOriginalIndex(projection, index) {
  // Inverse to `originalToProjectedIndex`.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.projectedToOriginalIndex(proj, 1) // => 4
  if (index < 0 || index > projection.to - projection.from) return null;
  return projection.from + index;
}

function transformToIncludeIndex(projection, index) {
  // Computes how the projection needs to shift minimally (think "scroll"
  // down or up) so that index becomes "visible" in projection.
  // Example:
  // var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  // arrayProjection.transformToIncludeIndex(proj, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  if (!(index in projection.array)) return null;
  var delta = 0;
  if (index < projection.from) delta = -projection.from + index;
  if (index >= projection.to) delta = index - projection.to + 1;
  if (delta === 0) return projection;
  return create(projection.array, projection.to - projection.from, projection.from + delta);
}



var arrayProjection = Object.freeze({
	create: create,
	toArray: toArray$4,
	originalToProjectedIndex: originalToProjectedIndex,
	projectedToOriginalIndex: projectedToOriginalIndex,
	transformToIncludeIndex: transformToIncludeIndex
});

// show-in-doc
// A grid is a two-dimaensional array, representing a table-like data

function get$2(grid, nRow, nCol) {
  var row = grid[nRow];
  return row ? row[nCol] : undefined;
}

function set$2(grid, nRow, nCol, obj) {
  var row = grid[nRow];
  if (row) row[nCol] = obj;
  return obj;
}

function getRow(grid, nRow) {
  return grid[nRow];
}

function setRow(grid, nRow, newRow) {
  return grid[nRow] = newRow;
}

function getCol(grid, nCol) {
  return grid.reduce(function (col, row) {
    col.push(row[nCol]);return col;
  }, []);
}

function setCol(grid, nCol, newCol) {
  return grid.map(function (row, i) {
    return row[nCol] ? row[nCol] = newCol[i] : undefined;
  });
}

function create$1(rows, columns, initialObj) {
  // Example:
  // grid.create(3, 2, "empty")
  // // => [["empty","empty"],
  // //     ["empty","empty"],
  // //     ["empty","empty"]]
  var result = new Array(rows);
  while (rows > 0) {
    result[--rows] = withN(columns, initialObj);
  }return result;
}

function mapCreate(rows, cols, func, context) {
  // like `grid.create` but takes generator function for cells
  var result = new Array(rows);
  for (var i = 0; i < rows; i++) {
    result[i] = new Array(cols);
    for (var j = 0; j < cols; j++) {
      result[i][j] = func.call(context || this, i, j);
    }
  }
  return result;
}

function forEach$2(grid, func, context) {
  // iterate, `func` is called as `func(cellValue, i, j)`
  grid.forEach(function (row, i) {
    row.forEach(function (val, j) {
      func.call(context || this, val, i, j);
    });
  });
}

function map$2(grid, func, context) {
  // map, `func` is called as `func(cellValue, i, j)`
  var result = new Array(grid.length);
  grid.forEach(function (row, i) {
    result[i] = new Array(row.length);
    row.forEach(function (val, j) {
      result[i][j] = func.call(context || this, val, i, j);
    });
  });
  return result;
}

function toObjects(grid) {
  // The first row of the grid defines the propNames
  // for each following row create a new object with those porperties
  // mapped to the cells of the row as values
  // Example:
  // grid.toObjects([['a', 'b'],[1,2],[3,4]])
  // // => [{a:1,b:2},{a:3,b:4}]
  var props = grid[0],
      objects = new Array(grid.length - 1);
  for (var i = 1; i < grid.length; i++) {
    var obj = objects[i - 1] = {};
    for (var j = 0; j < props.length; j++) {
      obj[props[j]] = grid[i][j];
    }
  }
  return objects;
}

function tableFromObjects(objects, valueForUndefined) {
  // Reverse operation to `grid.toObjects`. Useful for example to convert objectified
  // SQL result sets into tables that can be printed via Strings.printTable.
  // Objects are key/values like [{x:1,y:2},{x:3},{z:4}]. Keys are interpreted as
  // column names and objects as rows.
  // Example:
  // grid.tableFromObjects([{x:1,y:2},{x:3},{z:4}])
  // // => [["x","y","z"],
  // //    [1,2,null],
  // //    [3,null,null],
  // //    [null,null,4]]

  if (!Array.isArray(objects)) objects = [objects];
  var table = [[]],
      columns = table[0],
      rows = objects.reduce(function (rows, ea) {
    return rows.concat([Object.keys(ea).reduce(function (row, col) {
      var colIdx = columns.indexOf(col);
      if (colIdx === -1) {
        colIdx = columns.length;columns.push(col);
      }
      row[colIdx] = ea[col];
      return row;
    }, [])]);
  }, []);
  valueForUndefined = arguments.length === 1 ? null : valueForUndefined;
  rows.forEach(function (row) {
    // fill cells with no value with null
    for (var i = 0; i < columns.length; i++) {
      if (!row[i]) row[i] = valueForUndefined;
    }
  });
  return table.concat(rows);
}



var grid = Object.freeze({
	get: get$2,
	set: set$2,
	getRow: getRow,
	setRow: setRow,
	getCol: getCol,
	setCol: setCol,
	create: create$1,
	mapCreate: mapCreate,
	forEach: forEach$2,
	map: map$2,
	toObjects: toObjects,
	tableFromObjects: tableFromObjects
});

/*
 * Methods for traversing and transforming tree structures.
 */

function prewalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  iterator(treeNode, i, depth);
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return prewalk(ea, iterator, childGetter, counter, depth + 1);
  });
}

function postwalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return postwalk(ea, iterator, childGetter, counter, depth);
  });
  iterator(treeNode, i, depth);
}

function find(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns the first node for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  if (testFunc(treeNode)) return treeNode;
  var children = childGetter(treeNode);
  if (!children || !children.length) return undefined;
  for (var i = 0; i < children.length; i++) {
    var found = find(children[i], testFunc, childGetter);
    if (found) return found;
  }
  return undefined;
}
var detect$1 = find;

function filter$1(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns all nodes for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  var result = [];
  if (testFunc(treeNode)) result.push(treeNode);
  return result.concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return filter$1(n, testFunc, childGetter);
  })));
}

function map$3(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses a `treeNode` recursively and call `mapFunc` on each node. The
  // return values of all mapFunc calls is the result. `childGetter` is a
  // function to retrieve the children from a node.
  return [mapFunc(treeNode, depth)].concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return map$3(n, mapFunc, childGetter, depth + 1);
  })));
}

function mapTree(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses the tree and creates a structurally identical tree but with
  // mapped nodes
  var mappedNodes = (childGetter(treeNode) || []).map(function (n) {
    return mapTree(n, mapFunc, childGetter, depth + 1);
  });
  return mapFunc(treeNode, mappedNodes, depth);
}



var tree = Object.freeze({
	prewalk: prewalk,
	postwalk: postwalk,
	find: find,
	detect: detect$1,
	filter: filter$1,
	map: map$3,
	mapTree: mapTree
});

/*global process, require*/

/*
 * A simple node.js-like cross-platform event emitter implementation that can
 * be used as a mixin. Emitters support the methods: `on(eventName, handlerFunc)`,
 * `once(eventName, handlerFunc)`, `emit(eventName, eventData)`,
 * `removeListener(eventName, handlerFunc)`, `removeAllListeners(eventName)`
 * Example:
 * var emitter = events.makeEmitter({});
 * var log = [];
 * emitter.on("test", function() { log.push("listener1"); });
 * emitter.once("test", function() { log.push("listener2"); });
 * emitter.emit("test");
 * emitter.emit("test");
 * log // => ["listener1","listener2","listener1"]
 * emitter.removeAllListeners("test");
 * emitter.emit("test");
 * log // => is still ["listener1","listener2","listener1"]
 */

var isNode$1 = typeof process !== 'undefined' && process.versions && process.versions.node;

var makeEmitter = isNode$1 ? function (obj, options) {
  if (obj.on && obj.removeListener) return obj;
  var events = typeof System !== "undefined" ? System._nodeRequire("events") : require("events");
  Object.assign(obj, events.EventEmitter.prototype);
  events.EventEmitter.call(obj);
  if (options && options.maxListenerLimit) obj.setMaxListeners(options.maxListenerLimit);

  return obj;
} : function (obj) {
  if (obj.on && obj.removeListener) return obj;

  obj.listeners = {};

  obj.on = function (type, handler) {
    if (!handler) return;
    if (!obj.listeners[type]) obj.listeners[type] = [];
    obj.listeners[type].push(handler);
  };

  obj.once = function (type, handler) {
    if (!handler) return;
    function onceHandler /*ignore-in-docs args*/() {
      obj.removeListener(type, onceHandler);
      handler.apply(this, arguments);
    }
    obj.on(type, onceHandler);
  };

  obj.removeListener = function (type, handler) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = obj.listeners[type].filter(function (h) {
      return h !== handler;
    });
  };

  obj.removeAllListeners = function (type) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = [];
  };

  obj.emit = function () /*type and args*/{
    var args = Array.prototype.slice.call(arguments),
        type = args.shift(),
        handlers = obj.listeners[type];
    if (!handlers || !handlers.length) return;
    handlers.forEach(function (handler) {
      try {
        handler.apply(null, args);
      } catch (e) {
        console.error("Error in event handler: %s", e.stack || String(e));
      }
    });
  };

  return obj;
};



var events = Object.freeze({
	makeEmitter: makeEmitter
});

/*global clearTimeout, setTimeout, clearInterval, setInterval*/

/*
 * A pluggable interface to provide asynchronous, actor-like message
 * communication between JavaScript systems. Provides a unified message protocol
 * and send / receive methods.
 */

var OFFLINE = 'offline';
var ONLINE = 'online';
/*

TODO: move to promises! include broadcast API

renames:
listen() => open()
id() => id

*/

/*

A messenger is an object that provides a common, message-based interface. Messengers expect you to provide an implementation of a small number of methods: `send`, `listen`, `close`, and `isOnline`. A messenger will then provide a unified interface for sending and receiving messages. Common boilerplate functionality such as queuing messages, error handling, dealing with instable connections, heartbeats, etc. is handled by the messenger object automatically (and can be parameterized).

This allows to use a single interface across a range of heterogeneous objects without having to implement every detail of the abstraction repeatedly. This is especially valuable when dealing with asynchronous or remote communication (web workers, XHR requests, WebSockets, node.js processes, ...).

To see a minimal example of how to use messengers for the local communication between JavaScript objects [see this example](#messenger-example).

A more sophisticated example of messengers is [the worker implementation](worker.js) which provides an actor-like worker interface that uses web workers in web browsers and child_process.fork in node.js.

```js
var msger = lively.lang.messenger.create({
  send: function(msg, onSendDone) { console.log(msg); onSendDone(); },
  listen: function(thenDo) { thenDo(); },
  close: function(thenDo) { thenDo(); },
  isOnline: function() { return true }
});
```

#### Messenger interface

The interface methods are build to enable an user to send and receive
messages. Each messenger provides the following methods:

##### msger.id()

Each msger has an id that can either be defined by the user when the
msger is created or is automatically assigned. The id should be unique for each
messenger in a messenger network. It is used as the `target` attribute to
address messages and internally in the messaging implementation for routing.
See the [message protocol](#messenger-message-protocol) description for more info.

##### msger.isOnline()

Can the msger send and receive messages right now?

##### msger.heartbeatEnabled()

Does the msger send automated heartbeat messages?

##### msger.listen(optionalCallback)

Brings the messenger "online": Starts listening for messages and brings it
into a state to send messages. `optionalCallback` is a function that is called
when listening begins. It should accept one argument `error` that is null if no
error occured when listening was started, an Error object otherwise.

##### msger.send(msg, onReceiveFunc)

Sends a message. The message should be structured according to the [message
protocol](#messenger-message-protocol). `onReceiveFunc` is triggered when the `msg` is being
answered. `onReceiveFunc` should take two arguments: `error` and `answer`.
`answer` is itself a message object.

##### msger.sendTo(target, action, data, onReceiveFunc)

A simpler `send`, the `msg` object is automatically assembled. `target`
should be an id of the receiver and `action` a string naming the service that
should be triggered on the receiver.

##### msger.answer(msg, data, expectMore, whenSend)

Assembles an answer message for `msg` that includes `data`. `expectMore`
should be truthy when multiple answers should be send (a streaming response,
see the [messaging protocol](#messenger-message-protocol)).

##### msger.close(thenDo)

Stops listening.

##### msger.whenOnline(thenDo)

Registers a callback that is triggered as soon as a listen attempt succeeds
(or when the messenger is listening already then it succeeds immediately).

##### msger.outgoingMessages()

Returns the messages that are currently inflight or not yet send.

##### msger.addServices(serviceSpec)

Add services to the messenger. `serviceSpec` should be  JS object whose keys
correspond to message actions:

```js
msg.addServices({
  helloWorld: function(msg, messenger) {
    messenger.answer(msg, "received a message!");
  }
});
```

See the examples below for more information.

##### *[event]* msger.on("message")

To allow users to receive messages that were not initiated by a send,
messengers are [event emitters](events.js) that emit `"message"` events
whenever they receive a new message.

The messenger object is used to create new messenger interfaces and ties
them to a specific implementation. Please see [worker.js]() for examples of
how web workers and node.js processes are wrapped to provide a cross-platform
interface to a worker abstraction.


#### <a name="messenger-message-protocol"></a>Message protocol

A message is a JSON object with the following fields:

```js
var messageSchema = {

    // REQUIRED selector for service lookup. By convention action gets
    // postfixed with "Result" for response messages
    action: STRING,

    // REQUIRED target of the message, the id of the receiver
    target: UUID,

    // OPTIONAL arguments
    data: OBJECT,

    // OPTIONAL identifier of the message, will be provided if not set by user
    messageId: UUID,

    // OPTIONAL sender of the message, will be provided if not set by user
    sender: UUID,

    // OPTIONAL identifier of a message that this message answers, will be provided
    inResponseTo: UUID,

    // OPTIONAL if message is an answer. Can be interpreted by the receiver as
    // a streaming response. Lively participants (tracker and clients) will
    // trigger data bindings and fire callbacks for a message for every streaming
    // response
    expectMoreResponses: BOOL,

    // EXPERIMENTAL UUIDs of trackers/sessions handlers that forwarded this
    // message
    route: ARRAY
}
```

The `sendTo` and `answer` methods of messengers will automatically create these
messages. If the user invokes the `send` method then a JS object according to
the schema above should be passed as the first argument.

#### <a name="messenger-example"></a>Messenger examples

The following code implements what is needed to use a messenger to communicate
between any number of local JavaScript objects. Instead of dispatching methods using
a local list of messengers you will most likely use an existing networking /
messaging mechanism.

See the [worker](#) and [its implementation](worker.js) for a real use case in
which forking processes in the browser using Web Workers and in node.js using
child_process.fork is unified.

```js
// spec that defines message sending in terms of receivers in the messengers list
var messengers = [];
var messengerSpec = {
  send: function(msg, onSendDone) {
    var err = null, recv = arr.detect(messengers, function(ea) {
          return ea.id() === msg.target; });
    if (recv) recv.onMessage(msg);
    else err = new Error("Could not find receiver " + msg.target);
    onSendDone(err);
  },
  listen: function(thenDo) { arr.pushIfNotIncluded(messengers, this); },
  close: function(thenDo) { arr.remove(messengers, this); },
  isOnline: function() { return arr.include(messengers, this); }
};

// Create the messengers and add a simple "service"
var msger1 = messenger.create(messengerSpec);
var msger2 = messenger.create(messengerSpec);
msger2.addServices({
  add: function(msg, msger) { msger.answer(msg, {result: msg.data.a + msg.data.b}); }
});

// turn'em on...
msger1.listen();
msger2.listen();

// ...and action!
msger1.sendTo(msger2.id(), 'add', {a: 3, b: 4},
  function(err, answer) { alert(answer.data.result); });
```

*/

function create$2(spec) {

  var expectedMethods = [{ name: "send", args: ['msg', 'callback'] }, { name: "listen", args: ['messenger', 'callback'] }, { name: "close", args: ['messenger', 'callback'] }, { name: "isOnline", args: [] }];

  var ignoredAttributes = expectedMethods.map(function (ea) {
    return ea.name;
  }).concat(["id", "sendHeartbeat", "heartbeatInterval", "ignoreUnknownMessages", "allowConcurrentSends", "sendTimeout", "services"]);

  expectedMethods.forEach(function (exp) {
    if (spec[exp.name]) return;
    var msg = "message implementation needs function " + exp.name + "(" + exp.args.join(',') + ")";
    throw new Error(msg);
  });

  var heartbeatInterval = spec.sendHeartbeat && (spec.heartbeatInterval || 1000);
  var ignoreUnknownMessages = spec.hasOwnProperty("ignoreUnknownMessages") ? spec.ignoreUnknownMessages : false;

  var messenger = {

    _outgoing: [],
    _inflight: [],
    _id: spec.id || newUUID(),
    _ignoreUnknownMessages: ignoreUnknownMessages,
    _services: {},
    _messageCounter: 0,
    _messageResponseCallbacks: {},
    _whenOnlineCallbacks: [],
    _statusWatcherProc: null,
    _startHeartbeatProcessProc: null,
    _listenInProgress: null,
    _heartbeatInterval: heartbeatInterval,
    _status: OFFLINE,

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    _runWhenOnlineCallbacks: function _runWhenOnlineCallbacks() {
      var cbs = messenger._whenOnlineCallbacks.slice();
      messenger._whenOnlineCallbacks = [];
      cbs.forEach(function (ea) {
        try {
          ea.call(null, null, messenger);
        } catch (e) {
          console.error("error in _runWhenOnlineCallbacks: %s", e);
        }
      });
    },

    _ensureStatusWatcher: function _ensureStatusWatcher() {
      if (messenger._statusWatcherProc) return;
      messenger._statusWatcherProc = setInterval(function () {
        if (messenger.isOnline() && messenger._whenOnlineCallbacks.length) messenger._runWhenOnlineCallbacks();
        var prevStatus = messenger._status;
        messenger._status = messenger.isOnline() ? ONLINE : OFFLINE;
        if (messenger._status !== ONLINE && messenger._statusWatcherProc) {
          messenger.reconnect();
        }
        if (messenger._status !== prevStatus && messenger.onStatusChange) {
          messenger.onStatusChange();
        }
      }, 20);
    },

    _addMissingData: function _addMissingData(msg) {
      if (!msg.target) throw new Error("Message needs target!");
      if (!msg.action) throw new Error("Message needs action!");
      if (!msg.data) msg.data = null;
      if (!msg.messageId) msg.messageId = newUUID();
      msg.sender = messenger.id();
      msg.messageIndex = messenger._messageCounter++;
      return msg;
    },

    _queueSend: function _queueSend(msg, onReceiveFunc) {
      if (onReceiveFunc && typeof onReceiveFunc !== 'function') throw new Error("Expecing a when send callback, got: " + onReceiveFunc);
      messenger._outgoing.push([msg, onReceiveFunc]);
    },

    _deliverMessageQueue: function _deliverMessageQueue() {
      if (!spec.allowConcurrentSends && messenger._inflight.length) return;

      var queued = messenger._outgoing.shift();
      if (!queued) return;

      messenger._inflight.push(queued);
      if (messenger.isOnline()) deliver(queued);else messenger.whenOnline(function () {
        deliver(queued);
      });
      startTimeoutProc(queued);

      if (spec.allowConcurrentSends && messenger._outgoing.length) messenger._deliverMessageQueue();

      // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

      function deliver(queued) {
        // ignore-in-doc
        if (messenger._inflight.indexOf(queued) === -1) return; // timed out
        var msg = queued[0],
            callback = queued[1];
        if (callback) messenger._messageResponseCallbacks[msg.messageId] = callback;

        spec.send.call(messenger, msg, function (err) {
          remove(messenger._inflight, queued);
          if (err) onSendError(err, queued);
          messenger._deliverMessageQueue();
        });
      }

      function startTimeoutProc(queued) {
        if (typeof spec.sendTimeout !== 'number') return;
        setTimeout(function () {
          if (messenger._inflight.indexOf(queued) === -1) return; // delivered
          remove(messenger._inflight, queued);
          onSendError(new Error('Timeout sending message'), queued);
          messenger._deliverMessageQueue();
        }, spec.sendTimeout);
      }

      function onSendError(err, queued) {
        var msg = queued[0],
            callback = queued[1];
        delete messenger._messageResponseCallbacks[msg.messageId];
        console.error(err);
        callback && callback(err);
      }
    },

    _startHeartbeatProcess: function _startHeartbeatProcess() {
      if (messenger._startHeartbeatProcessProc) return;
      messenger._startHeartbeatProcessProc = setTimeout(function () {
        spec.sendHeartbeat.call(messenger, function (err, result) {
          messenger._startHeartbeatProcessProc = null;
          messenger._startHeartbeatProcess();
        });
      }, messenger._heartbeatInterval);
    },

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    id: function id() {
      return messenger._id;
    },

    isOnline: function isOnline() {
      return spec.isOnline.call(messenger);
    },

    heartbeatEnabled: function heartbeatEnabled() {
      return typeof messenger._heartbeatInterval === 'number';
    },

    listen: function listen(thenDo) {
      if (messenger._listenInProgress) return;
      messenger._listenInProgress = true;
      messenger._ensureStatusWatcher();
      return spec.listen.call(messenger, function (err) {
        messenger._listenInProgress = null;
        thenDo && thenDo(err);
        if (messenger.heartbeatEnabled()) messenger._startHeartbeatProcess();
      });
      return messenger;
    },

    reconnect: function reconnect() {
      if (messenger._status === ONLINE) return;
      messenger.listen();
      return messenger;
    },

    send: function send(msg, onReceiveFunc) {
      messenger._addMissingData(msg);
      messenger._queueSend(msg, onReceiveFunc);
      messenger._deliverMessageQueue();
      return msg;
    },

    sendTo: function sendTo(target, action, data, onReceiveFunc) {
      var msg = { target: target, action: action, data: data };
      return messenger.send(msg, onReceiveFunc);
    },

    onMessage: function onMessage(msg) {
      messenger.emit("message", msg);
      if (msg.inResponseTo) {
        var cb = messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb && !msg.expectMoreResponses) delete messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb) cb(null, msg);
      } else {
        var action = messenger._services[msg.action];
        if (action) {
          try {
            action.call(null, msg, messenger);
          } catch (e) {
            var errmMsg = String(e.stack || e);
            console.error("Error invoking service: " + errmMsg);
            messenger.answer(msg, { error: errmMsg });
          }
        } else if (!messenger._ignoreUnknownMessages) {
          var err = new Error("messageNotUnderstood: " + msg.action);
          messenger.answer(msg, { error: String(err) });
        }
      }
    },

    answer: function answer(msg, data, expectMore, whenSend) {
      if (typeof expectMore === 'function') {
        whenSend = expectMore;expectMore = false;
      }
      var answer = {
        target: msg.sender,
        action: msg.action + 'Result',
        inResponseTo: msg.messageId,
        data: data };
      if (expectMore) answer.expectMoreResponses = true;
      return messenger.send(answer, whenSend);
    },

    close: function close(thenDo) {
      clearInterval(messenger._statusWatcherProc);
      messenger._statusWatcherProc = null;
      spec.close.call(messenger, function (err) {
        messenger._status = OFFLINE;
        thenDo && thenDo(err);
      });
      return messenger;
    },

    whenOnline: function whenOnline(thenDo) {
      messenger._whenOnlineCallbacks.push(thenDo);
      if (messenger.isOnline()) messenger._runWhenOnlineCallbacks();
      return messenger;
    },

    outgoingMessages: function outgoingMessages() {
      return pluck(messenger._inflight.concat(messenger._outgoing), 0);
    },

    addServices: function addServices(serviceSpec) {
      Object.assign(messenger._services, serviceSpec);
      return messenger;
    }
  };

  if (spec.services) messenger.addServices(spec.services);
  makeEmitter(messenger);

  for (var name in spec) {
    if (ignoredAttributes.indexOf(name) === -1 && spec.hasOwnProperty(name)) {
      messenger[name] = spec[name];
    }
  }

  return messenger;
}



var messenger = Object.freeze({
	create: create$2
});

/*global require, Worker, URL, webkitURL, Blob, BlobBuilder, process, require*/

/*
 * A platform-independent worker interface that will spawn new processes per
 * worker (if the platform you use it on supports it).
 */

var isNodejs = typeof require !== 'undefined' && typeof process !== 'undefined';

// ignore-in-doc
// Code in worker setup is evaluated in the context of workers, it will get to
// workers in a stringified form(!).
var WorkerSetup = {

  loadDependenciesBrowser: function loadDependenciesBrowser(options) {
    var me = typeof self !== "undefined" ? self : this;
    importScripts.apply(me, options.scriptsToLoad || []);
  },

  loadDependenciesNodejs: function loadDependenciesNodejs(options) {
    var lv = global.lively || (global.lively = {});
    lv.lang = require(require("path").join(options.libLocation, "index"));
  },

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // yoshiki and robert, 05/08/13: Inserted code that sets up the lively context
  // and globals of Lively and other required objects:
  initBrowserGlobals: function initBrowserGlobals(options) {
    remoteWorker.send = function (msg) {
      postMessage(msg);
    };
    var me = typeof self !== "undefined" ? self : this;
    var Global = me.Global = me;
    Global.window = Global;
    Global.console = Global.console || function () {
      var c = {};
      ['log', 'error', 'warn'].forEach(function (name) {
        c[name] = function () /*args*/{
          var string = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            string = string.replace('%s', arguments[i]);
          }remoteWorker.send({
            type: name,
            message: ['[', name.toUpperCase(), '] ', string].join('')
          });
        };
      });
      return c;
    }();
  },

  initOnMessageHandler: function initOnMessageHandler(options) {
    if (remoteWorker.on) remoteWorker.on('message', onMessage);else remoteWorker.onmessage = onMessage;

    function onMessage(msg) {
      msg = msg.data.data ? msg.data : msg;
      if (remoteWorker.messenger) remoteWorker.messenger.onMessage(msg);else if (msg.action == "close") {
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
        return;
      }
    }
  },

  initWorkerInterface: function initWorkerInterface(options) {
    remoteWorker.callStringifiedFunction = function (stringifiedFunc, args, thenDo) {
      // ignore-in-doc
      // runs stringified function and passing args. stringifiedFunc might
      // be asynchronous if it takes an addaitional argument. In this case a
      // callback to call when the work is done is passed, otherwise thenDo
      // will be called immediatelly after creating and calling the function

      var func;
      try {
        func = eval('(' + stringifiedFunc + ')');
      } catch (e) {
        thenDo(new Error("Cannot create function from string: " + e.stack || e));
        return;
      }

      // ignore-in-doc
      // when it takes one more arg then we assume that this is the callback
      // to be called by the run func when it considers to be done
      var usesCallback = func.length === args.length + 1;
      var whenDone = lively.lang.fun.once(function (err, result) {
        remoteWorker.isBusy = false;thenDo(err, result);
      });
      remoteWorker.isBusy = true;

      if (usesCallback) args.push(whenDone);

      try {
        var result = func.apply(remoteWorker, args.concat([whenDone]));
      } catch (e) {
        whenDone(e, null);return;
      }

      if (!usesCallback) whenDone(null, result);
    };

    remoteWorker.httpRequest = function (options) {
      if (!options.url) {
        console.log("Error, httpRequest needs url");
        return;
      }
      var req = new XMLHttpRequest(),
          method = options.method || 'GET';
      function handleStateChange() {
        if (req.readyState === 4) {
          // req.status
          options.done && options.done(req);
        }
      }
      req.onreadystatechange = handleStateChange;
      req.open(method, options.url);
      req.send();
    };

    remoteWorker.terminateIfNotBusyIn = function (ms) {
      setTimeout(function () {
        if (remoteWorker.isBusy) {
          remoteWorker.terminateIfNotBusyIn(ms);return;
        }
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
      }, ms);
    };
  },

  // ignore-in-doc
  // setting up the worker messenger interface, this is how the worker
  // should be communicated with
  initWorkerMessenger: function initWorkerMessenger(options) {
    if (!options.useMessenger) return null;
    if (!lively.lang.messenger) throw new Error("worker.create requires messenger.js to be loaded!");
    if (!lively.lang.events) throw new Error("worker.create requires events.js to be loaded!");

    return remoteWorker.messenger = lively.lang.messenger.create({
      services: {

        remoteEval: function remoteEval(msg, messenger) {
          var result;
          try {
            result = eval(msg.data.expr);
          } catch (e) {
            result = e.stack || e;
          }
          messenger.answer(msg, { result: String(result) });
        },

        run: function run(msg, messenger) {
          var funcString = msg.data.func,
              args = msg.data.args;
          if (!funcString) {
            messenger.answer(msg, { error: 'no funcString' });return;
          }
          remoteWorker.callStringifiedFunction(funcString, args, function (err, result) {
            messenger.answer(msg, { error: err ? String(err) : null, result: result });
          });
        },

        close: function close(msg, messenger) {
          messenger.answer(msg, { status: "OK" });
          remoteWorker.send({ type: "closed", workerReady: false });
          remoteWorker.close();
        }
      },

      isOnline: function isOnline() {
        return true;
      },
      send: function send(msg, whenSend) {
        remoteWorker.send(msg);whenSend();
      },
      listen: function listen(whenListening) {
        whenListening();
      },
      close: function close(whenClosed) {
        remoteWorker.send({ type: "closed", workerReady: false });remoteWorker.close();
      }

    });
  }

};

var BrowserWorker = {

  create: function create$3(options) {
    // ignore-in-doc
    // this function instantiates a browser worker object. We provide a
    // messenger-based interface to the pure Worker. Please use create to get an
    // improved interface to a worker

    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    if (!options.libLocation && !options.scriptsToLoad) {
      var workerScript = document.querySelector("script[src$=\"worker.js\"]");
      if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
      options.libLocation = workerScript.src.replace(/worker.js$/, '');
    }

    var workerSetupCode = String(workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.initBrowserGlobals, WorkerSetup.loadDependenciesBrowser, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));
    var workerCode = '(' + workerSetupCode + ')();';
    var worker = new Worker(makeDataURI(workerCode));
    init(options, worker);
    return worker;

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    // ignore-in-doc
    // This code is triggered in the UI process directly after the
    // creation of the worker and sends the setup message to the worker
    // for initializing it.
    function init(options, worker) {
      makeEmitter(worker);

      if (!options.scriptsToLoad) {
        options.scriptsToLoad = ['base.js', 'events.js', 'object.js', 'collection.js', 'function.js', 'string.js', 'number.js', 'date.js', 'messenger.js', 'worker.js'].map(function (ea) {
          return options.libLocation + ea;
        });
      }

      var workerOptions = Object.keys(options).reduce(function (opts, key) {
        if (typeof options[key] !== 'function') opts[key] = options[key];
        return opts;
      }, {});

      worker.onmessage = function (evt) {
        if (evt.data.workerReady !== undefined) {
          worker.ready = !!evt.data.workerReady;
          if (worker.ready) worker.emit("ready");else worker.emit("close");
        } else worker.emit('message', evt.data);
      };

      worker.errors = [];
      worker.onerror = function (evt) {
        console.error(evt);
        worker.errors.push(evt);
        worker.emit("error", evt);
      };

      worker.postMessage({ action: 'setup', options: workerOptions });
    }

    // ignore-in-doc
    // This code is run inside the worker and bootstraps the messenger
    // interface. It also installs a console.log method since since this is not
    // available by default.
    function workerSetupFunction() {
      var remoteWorker = self;
      remoteWorker.onmessage = function (evt) {
        if (evt.data.action !== "setup") {
          throw new Error("expected setup to be first message but got " + JSON.stringify(evt.data));
        }
        var options = evt.data.options || {};
        initBrowserGlobals(options);
        loadDependenciesBrowser(options);
        initOnMessageHandler(options);
        initWorkerInterface(options);
        initWorkerMessenger(options);
        postMessage({ workerReady: true });
      };
      __FUNCTIONDECLARATIONS__;
    }

    function makeDataURI(codeToInclude) {
      // ignore-in-doc
      // see http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
      var blob;
      try {
        blob = new Blob([codeToInclude], { type: "text/javascript" });
      } catch (e) {
        /* ignore-in-doc Backwards-compatibility*/
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(codeToInclude);
        blob = blob.getBlob();
      }
      var urlInterface = typeof webkitURL !== 'undefined' ? webkitURL : URL;
      return urlInterface.createObjectURL(blob);
    }
  }

};

var NodejsWorker = {

  debug: false,
  initCodeFileCreated: false,

  create: function create$3(options) {
    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    // if (!options.libLocation && !options.scriptsToLoad) {
    //   var workerScript = document.querySelector("script[src$=\"worker.js\"]");
    //   if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
    //   options.libLocation = workerScript.src.replace(/worker.js$/, '');
    // }

    var workerProc;
    var worker = makeEmitter({
      ready: false,
      errors: [],

      postMessage: function postMessage(msg) {
        if (!workerProc) {
          worker.emit("error", new Error('nodejs worker process not yet created'));
          return;
        }
        if (!worker.ready) {
          worker.emit("error", new Error('nodejs worker process not ready or already closed'));
          return;
        }
        workerProc.send(msg);
      }
    });

    NodejsWorker.startWorker(options, function (err, _workerProc) {
      if (err) {
        worker.ready = false;worker.emit("error", err);return;
      }

      workerProc = _workerProc;

      workerProc.on('message', function (m) {
        NodejsWorker.debug && console.log('[WORKER PARENT] got message:', m);
        worker.emit("message", m);
      });

      workerProc.on('close', function () {
        console.log("[WORKER PARENT] worker closed");
        worker.emit("close");
      });

      workerProc.on('error', function (err) {
        console.log("[WORKER PARENT] error ", err);
        worker.errors.push(err);
        worker.emit("error", err);
      });

      worker.ready = true;
      worker.emit("ready");
    });

    return worker;
  },

  // this code is run in the context of the worker process
  workerSetupFunction: function workerSetupFunction() {
    var remoteWorker = process;
    var debug = true;
    var close = false;

    debug && console.log("[WORKER] Starting init");
    // ignore-in-doc
    // process.on('message', function(m) {
    //   debug && console.log('[WORKER] got message:', m);
    //   if (m.action === 'ping') process.send({action: 'pong', data: m});
    //   else if (m.action === 'close') close = true;
    //   else if (m.action === 'setup') setup(m.data);
    //   else console.error('[WORKER] unknown message: ', m);
    // });

    remoteWorker.on("message", function (msg) {
      if (msg.action !== "setup") {
        throw new Error("expected setup to be first message but got " + JSON.stringify(msg.data));
      }
      remoteWorker.removeAllListeners("message");
      var options = msg.data.options || {};
      debug && console.log("[WORKER] running setup with options", options);
      loadDependenciesNodejs(options);
      initOnMessageHandler(options);
      initWorkerInterface(options);
      initWorkerMessenger(options);
      remoteWorker.send({ workerReady: true });
    });
    __FUNCTIONDECLARATIONS__;
  },

  ensureInitCodeFile: function ensureInitCodeFile(options, initCode, thenDo) {
    var path = require("path");
    var os = require("os");
    var fs = require("fs");

    var workerTmpDir = path.join(os.tmpDir(), 'lively-nodejs-workers/');
    var fn = path.join(workerTmpDir, 'nodejs-worker-init.js');

    if (!NodejsWorker.initCodeFileCreated) NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);else fs.exists(fn, function (exists) {
      if (exists) thenDo(null, fn);else NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);
    });
  },

  createWorkerCodeFile: function createWorkerCodeFile(options, fileName, initCode, thenDo) {
    var path = require("path");
    var fs = require("fs");
    var exec = require("child_process").exec;

    exec("mkdir -p " + path.dirname(fileName), function (code, out, err) {
      if (code) {
        thenDo(new Error(["[WORKER PARENT] Could not create worker temp dir:", out, err].join('\n')));
        return;
      }
      fs.writeFile(fileName, initCode, function (err) {
        NodejsWorker.debug && console.log('worker code file %s created', fileName);
        NodejsWorker.initCodeFileCreated = true;
        thenDo(err, fileName);
      });
    });
  },

  startWorker: function startWorker(options, thenDo) {
    var util = require("util");
    var fork = require("child_process").fork;

    var workerSetupCode = String(NodejsWorker.workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.loadDependenciesNodejs, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));

    var initCode = util.format("(%s)();\n", workerSetupCode);
    NodejsWorker.ensureInitCodeFile(options, initCode, function (err, codeFileName) {
      if (err) return thenDo(err);
      var worker = fork(codeFileName, {});
      NodejsWorker.debug && console.log('worker forked');
      worker.on('message', function (m) {
        if (m.action === 'pong') console.log("[WORKER pong] ", m);else if (m.action === 'log') console.log("[Message from WORKER] ", m.data);
      });
      worker.once('message', function (m) {
        NodejsWorker.debug && console.log('worker setup done');
        thenDo(null, worker, m);
      });
      worker.on('close', function () {
        NodejsWorker.debug && console.log("[WORKER PARENT] worker closed");
      });
      worker.send({ action: "setup", data: { options: options } });
      global.WORKER = worker;
    });
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // the worker interface, usable both in browser and node.js contexts
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  /*
  Worker objects allow to fork processes in both Web and node.js JavaScript
  environments. They provide this mechanism using web workers in the browser and
  node.js child processes in node.js. The interface is unified for all platforms.
   */

};function fork(options, workerFunc, thenDo) {
  // Fork automatically starts a worker and calls `workerFunc`. `workerFunc`
  // gets as a last paramter a callback, that, when invoked with an error and
  // result object, ends the worker execution.
  //
  // Options are the same as in `create` except for an `args` property that
  // can be an array of objects. These objects will be passed to `workerFunc`
  // as arguments.
  //
  // Note: `workerFunc` will not be able to capture outside variables (create a
  // closure).
  //
  // Example:
  // // When running this inside a browser: Note how the UI does not block.
  // worker.fork({args: [40]},
  //   function(n, thenDo) {
  //     function fib(n) { return n <= 1 ? n : fib(n-1) + fib(n-2); }
  //     thenDo(null, fib(n));
  //   },
  //   function(err, result) { show(err ? err.stack : result); })

  if (!thenDo) {
    thenDo = workerFunc;workerFunc = options;options = null;
  }
  options = options || {};
  var args = options.args || [];
  var w = create$3(options);
  w.run.apply(w, [workerFunc].concat(args).concat(thenDo));
  return w;
}

function create$3(options) {
  // Explicitly creates a first-class worker. Options:
  // ```js
  // {
  //   workerId: STRING, // optional, id for worker, will be auto assigned if not provided
  //   libLocation: STRING, // optional, path to where the lively.lang lib is located. Worker will try to find it automatically if not provided.
  //   scriptsToLoad: ARRAY // optional, list of path/urls to load. Overwrites `libLocation`
  // }
  // ```
  //
  // Example:
  // // this is just a helper function
  // function resultHandler(err, result) { alert(err ? String(err) : result); }
  //
  // // 1. Create the worker
  // var worker = lively.lang.worker.create({libLocation: baseURL});
  //
  // // 2. You can evaluate arbitrary JS code
  // worker.eval("1+2", function(err, result) { show(err ? String(err) : result); });
  //
  // // 3. Arbitrary functions can be called inside the worker context.
  // //    Note: functions shouldn't be closures / capture local state!) and passing
  // //    in arguments!
  // worker.run(
  //   function(a, b, thenDo) { setTimeout(function() { thenDo(null, a+b); }, 300); },
  //   19, 4, resultHandler);
  //
  // // 4. You can also install your own messenger services...
  // worker.run(
  //   function(thenDo) {
  //     self.messenger.addServices({
  //       foo: function(msg, messenger) { messenger.answer(msg, "bar!"); }
  //     });
  //     thenDo(null, "Service installed!");
  //   }, resultHandler);
  //
  // // ... and call them via the messenger interface
  // worker.sendTo("worker", "foo", {}, resultHandler);
  //
  // // 5. afterwards: shut it down
  // worker.close(function(err) { err && show(String(err)); alertOK("worker shutdown"); })

  options = options || {};
  options.useMessenger = true;

  // if (!exports.messenger)
  //   throw new Error("worker.create requires messenger.js to be loaded!")
  // if (!exports.events)
  //   throw new Error("worker.create requires events.js to be loaded!")
  // if (!exports.obj)
  //   throw new Error("worker.create requires object.js to be loaded!")

  var workerId = options.workerId || newUUID();

  var messenger = create$2({
    sendTimeout: 5000,

    send: function send(msg, whenSend) {
      messenger.worker.postMessage(msg);
      whenSend();
    },

    listen: function listen(whenListening) {
      var w = messenger.worker = isNodejs ? NodejsWorker.create(options) : BrowserWorker.create(options);
      w.on("message", function (msg) {
        messenger.onMessage(msg);
      });
      w.on('ready', function () {
        NodejsWorker.debug && console.log("WORKER READY!!!");
      });
      w.on('close', function () {
        NodejsWorker.debug && console.log("WORKER CLOSED...!!!");
      });
      w.once('ready', whenListening);
    },

    close: function close(whenClosed) {
      if (!messenger.worker.ready) return whenClosed(null);
      return messenger.sendTo(workerId, 'close', {}, function (err, answer) {
        err = err || answer.data.error;
        err && console.error("Error in worker messenger close: " + err.stack || err);
        if (err) whenClosed(err);else {
          var closed = false;
          messenger.worker.once('close', function () {
            closed = true;
          });
          waitFor(1000, function () {
            return !!closed;
          }, whenClosed);
        }
      });
    },

    isOnline: function isOnline() {
      return messenger.worker && messenger.worker.ready;
    }

  });

  Object.assign(messenger, {
    eval: function _eval(code, thenDo) {
      messenger.sendTo(workerId, "remoteEval", { expr: code }, function (err, answer) {
        thenDo(err, answer ? answer.data.result : null);
      });
    },
    run: function run() /*runFunc, arg1, ... argN, thenDo*/{
      var args = Array.prototype.slice.call(arguments),
          workerFunc = args.shift(),
          thenDo = args.pop();
      if (typeof workerFunc !== "function") throw new Error("run: no function that should run in worker passed");
      if (typeof thenDo !== "function") throw new Error("run: no callback passed");

      return messenger.sendTo(workerId, 'run', { func: String(workerFunc), args: args }, function (err, answer) {
        thenDo(err || answer.data.error, answer ? answer.data.result : null);
      });
    }
  });

  messenger.listen();

  return messenger;
}



var worker = Object.freeze({
	fork: fork,
	create: create$3
});

var GLOBAL = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

var isNode = typeof process !== "undefined" && process.env && typeof process.exit === "function";

var globalInterfaceSpec = [{ action: "installMethods", target: "Array", sources: ["arr"], methods: ["from", "genN", "range", "withN"] }, { action: "installMethods", target: "Array.prototype", sources: ["arr"], methods: ["all", "any", "batchify", "clear", "clone", "collect", "compact", "delimWith", "detect", "doAndContinue", "each", "equals", "filterByKey", "findAll", "first", "flatten", "forEachShowingProgress", "grep", "groupBy", "groupByKey", "histogram", "include", "inject", "intersect", "invoke", "last", "mapAsync", "mapAsyncSeries", "mask", "max", "min", "mutableCompact", "nestedDelay", "partition", "pluck", "pushAll", "pushAllAt", "pushAt", "pushIfNotIncluded", "reMatches", "reject", "rejectByKey", "remove", "removeAt", "replaceAt", "rotate", "shuffle", "size", "sortBy", "sortByKey", "sum", "swap", "toArray", "toTuples", "union", "uniq", "uniqBy", "without", "withoutAll", "zip"], alias: [["select", "filter"]] }, { action: "installMethods", target: "Date", sources: ["date"], methods: [/*"parse"*/] }, { action: "installMethods", target: "Date.prototype", sources: ["date"], methods: ["equals", "format", "relativeTo"] }, { action: "installMethods", target: "Function", sources: ["fun"], methods: ["fromString"] }, { action: "installMethods", target: "Function.prototype", sources: ["fun"], methods: [/*"addProperties",*/"addToObject", "argumentNames", "asScript", "asScriptOf", "binds", "curry", "delay", "functionNames", "localFunctionNames", "getOriginal", "getVarMapping", "logCalls", "logCompletion", "logErrors", "qualifiedMethodName", "setProperty", "traceCalls", "wrap"] }, { action: "installMethods", target: "Number", sources: ["num"], methods: [] }, { action: "installMethods", target: "Number.prototype", sources: ["num"], methods: ["detent", "randomSmallerInteger", "roundTo", "toDegrees", "toRadians"] }, { action: "installMethods", target: "Object", sources: ["obj"], methods: ["addScript", "clone", "deepCopy", "extend", "inherit", "isArray", "isBoolean", "isElement", "isEmpty", "isFunction", "isNumber", "isObject", "isRegExp", "isString", "isUndefined", "merge", "mergePropertyInHierarchy", "values", "valuesInPropertyHierarchy"] }, { action: "installMethods", target: "Object.prototype", sources: ["obj"], methods: [] }, { action: "installMethods", target: "String.prototype", sources: ["string"], methods: ["camelize", "capitalize", "digitValue", "empty", "hashCode", "include", "pad", "regExpEscape", "startsWithVowel", "succ", "times", "toArray", "toQueryParams", "truncate"] }, { action: "installObject", target: "Numbers", source: "num", methods: ["average", "between", "convertLength", "humanReadableByteSize", "median", "normalRandom", "parseLength", "random", "sort"] }, { action: "installObject", target: "Properties", source: "properties", methods: ["all", "allOwnPropertiesOrFunctions", "allProperties", "any", "forEachOwn", "hash", "nameFor", "own", "ownValues", "values"] }, { action: "installObject", target: "Strings", source: "string", methods: ["camelCaseString", "createDataURI", "diff", "format", "formatFromArray", "indent", "lineIndexComputer", "lines", "md5", "newUUID", "nonEmptyLines", "pad", "paragraphs", "peekLeft", "peekRight", "print", "printNested", "printTable", "printTree", "quote", "reMatches", "stringMatch", "tableize", "tokens", "unescapeCharacterEntities", "withDecimalPrecision"] }, { action: "installObject", target: "Objects", source: "obj", methods: ["asObject", "equals", "inspect", "isMutableType", "safeToString", "shortPrintStringOf", "typeStringOf"] }, { action: "installObject", target: "Functions", source: "fun", methods: ["all", "compose", "composeAsync", "createQueue", "debounce", "debounceNamed", "either", "extractBody", "flip", "notYetImplemented", "once", "own", "throttle", "throttleNamed", "timeToRun", "timeToRunN", "waitFor", "workerWithCallbackQueue", "wrapperChain"] }, { action: "installObject", target: "Grid", source: "grid" }, { action: "installObject", target: "Interval", source: "interval" }, { action: "installObject", target: "lively.ArrayProjection", source: "arrayProjection" }, { action: "installObject", target: "lively.Closure", source: "Closure" }, { action: "installObject", target: "lively.Grouping", source: "Group" }, { action: "installObject", target: "lively.PropertyPath", source: "Path" }, { action: "installObject", target: "lively.Worker", source: "worker" }, { action: "installObject", target: "lively.Class", source: "classHelper" }];

function createLivelyLangObject() {
  return {
    chain: chain$$1,
    noConflict: noConflict,
    installGlobals: installGlobals,
    uninstallGlobals: uninstallGlobals,
    globalInterfaceSpec: globalInterfaceSpec,
    toString: function toString() {
      return "[object lively.lang]";
    }
  };
}

var livelyLang = createLivelyLangObject();



function chain$$1(object) {
  if (!object) return object;

  var chained;
  if (Array.isArray(object)) return createChain(arr, object);
  if (object.constructor.name === "Date") return createChain(date, object);
  switch (typeof object === "undefined" ? "undefined" : _typeof(object)) {
    case 'string':
      return createChain(string, object);
    case 'object':
      return createChain(obj, object);
    case 'function':
      return createChain(fun, object);
    case 'number':
      return createChain(num, object);
  }
  throw new Error("Chain for object " + object + " (" + object.constructor.name + ") no supported");
}

function createChain(interfaceObj, obj) {
  return Object.keys(interfaceObj).reduce(function (chained, methodName) {
    chained[methodName] = function () /*args*/{
      var args = Array.prototype.slice.call(arguments),
          result = interfaceObj[methodName].apply(null, [obj].concat(args));
      return chain$$1(result);
    };
    return chained;
  }, { value: function value() {
      return obj;
    } });
}

function noConflict() {
  if (!isNode) {
    var keepLivelyNS = livelyLang._prevLivelyGlobal;
    if (!keepLivelyNS) delete GLOBAL.lively;else delete GLOBAL.lively.lang;
  }
  return livelyLang;
}

function installGlobals() {
  Object.assign(livelyLang, {
    worker: worker,
    messenger: messenger,
    events: events,
    tree: tree,
    grid: grid,
    arrayProjection: arrayProjection,
    interval: interval,
    graph: graph,
    date: date,
    properties: properties,
    obj: obj,
    arr: arr,
    fun: fun,
    num: num,
    string: string,
    Closure: Closure,
    promise: promise,
    Path: Path,
    Group: Group
  });
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var targetPath = Path(ea.target);
      if (!targetPath.isIn(GLOBAL)) targetPath.set(GLOBAL, {}, true);
      var sourcePath = Path(ea.sources[0]);
      ea.methods.forEach(function (name) {
        installProperty(sourcePath.concat([name]), targetPath.concat([name]));
      });
      if (ea.alias) ea.alias.forEach(function (mapping) {
        installProperty(sourcePath.concat([mapping[1]]), targetPath.concat([mapping[0]]));
      });
    } else if (ea.action === "installObject") {
      var targetPath = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      targetPath.set(GLOBAL, source, true);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

function installProperty(sourcePath, targetPath) {
  if (!sourcePath.isIn(livelyLang)) {
    var err = new Error("property not provided by lively.lang: " + sourcePath);
    console.error(err.stack || err);
    throw err;
  }

  var prop = sourcePath.get(livelyLang);
  if (typeof prop === "function" && targetPath.slice(-2, -1).toString() === "prototype") {
    var origFunc = prop;
    prop = function prop() /*this and args*/{
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this);
      return origFunc.apply(null, args);
    };
    prop.toString = function () {
      return origFunc.toString();
    };
  }
  targetPath.set(GLOBAL, prop, true);
}

function uninstallGlobals() {
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var p = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      var target = p.get(GLOBAL);
      if (!target) return;
      ea.methods.filter(function (name) {
        return source === target[name];
      }).forEach(function (name) {
        delete target[name];
      });
      if (ea.alias) ea.alias.filter(function (name) {
        return source === target[name];
      }).forEach(function (mapping) {
        delete target[mapping[0]];
      });
    } else if (ea.action === "installObject") {
      var p = Path(ea.target);
      p.del(GLOBAL);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

exports.worker = worker;
exports.messenger = messenger;
exports.events = events;
exports.tree = tree;
exports.grid = grid;
exports.arrayProjection = arrayProjection;
exports.interval = interval;
exports.graph = graph;
exports.date = date;
exports.properties = properties;
exports.obj = obj;
exports.arr = arr;
exports.fun = fun;
exports.num = num;
exports.string = string;
exports.Closure = Closure;
exports.promise = promise;
exports.Path = Path;
exports.Group = Group;
exports.livelyLang = livelyLang;
exports.chain = chain$$1;
exports.noConflict = noConflict;
exports.installGlobals = installGlobals;
exports.uninstallGlobals = uninstallGlobals;

}((this.lively.lang = this.lively.lang || {})));

  }).call(GLOBAL);
  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.lang;
})();

  this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

function parse$1(string$$1) {
	var color = new Color$1(string$$1);
	return { red: color.red() / 255, green: color.green() / 255, blue: color.blue() / 255, alpha: color.alpha() };
}

// http://upshots.org/javascript/javascript-color-class
// MIT licensed, Copyright (c) 2011 Mike Dunn
// https://github.com/moagrius/Color/blob/master/LICENSE

var Events = {
	RGB_UPDATED: 'RGBUpdated',
	HSL_UPDATED: 'HSLUpdated',
	HSV_UPDATED: 'HSVUpdated',
	HEX_UPDATED: 'HexUpdated',
	INT_UPDATED: 'IntUpdated',
	UPDATED: 'updated'
};

var namedColors = {
	'transparent': 'rgba(0, 0, 0, 0)', 'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '#00FFFF', 'aquamarine': '#7FFFD4',
	'azure': '#F0FFFF', 'beige': '#F5F5DC', 'bisque': '#FFE4C4', 'black': '#000000', 'blanchedalmond': '#FFEBCD', 'blue': '#0000FF', 'blueviolet': '#8A2BE2',
	'brown': '#A52A2A', 'burlywood': '#DEB887', 'cadetblue': '#5F9EA0', 'chartreuse': '#7FFF00', 'chocolate': '#D2691E', 'coral': '#FF7F50',
	'cornflowerblue': '#6495ED', 'cornsilk': '#FFF8DC', 'crimson': '#DC143C', 'cyan': '#00FFFF', 'darkblue': '#00008B', 'darkcyan': '#008B8B', 'darkgoldenrod': '#B8860B',
	'darkgray': '#A9A9A9', 'darkgrey': '#A9A9A9', 'darkgreen': '#006400', 'darkkhaki': '#BDB76B', 'darkmagenta': '#8B008B', 'darkolivegreen': '#556B2F',
	'darkorange': '#FF8C00', 'darkorchid': '#9932CC', 'darkred': '#8B0000', 'darksalmon': '#E9967A', 'darkseagreen': '#8FBC8F', 'darkslateblue': '#483D8B',
	'darkslategray': '#2F4F4F', 'darkslategrey': '#2F4F4F', 'darkturquoise': '#00CED1', 'darkviolet': '#9400D3', 'deeppink': '#FF1493', 'deepskyblue': '#00BFFF',
	'dimgray': '#696969', 'dimgrey': '#696969', 'dodgerblue': '#1E90FF', 'firebrick': '#B22222', 'floralwhite': '#FFFAF0', 'forestgreen': '#228B22',
	'fuchsia': '#FF00FF', 'gainsboro': '#DCDCDC', 'ghostwhite': '#F8F8FF', 'gold': '#FFD700', 'goldenrod': '#DAA520', 'gray': '#808080', 'grey': '#808080',
	'green': '#008000', 'greenyellow': '#ADFF2F', 'honeydew': '#F0FFF0', 'hotpink': '#FF69B4', 'indianred': '#CD5C5C', 'indigo': '#4B0082', 'ivory': '#FFFFF0',
	'khaki': '#F0E68C', 'lavender': '#E6E6FA', 'lavenderblush': '#FFF0F5', 'lawngreen': '#7CFC00', 'lemonchiffon': '#FFFACD', 'lightblue': '#ADD8E6',
	'lightcoral': '#F08080', 'lightcyan': '#E0FFFF', 'lightgoldenrodyellow': '#FAFAD2', 'lightgray': '#D3D3D3', 'lightgrey': '#D3D3D3', 'lightgreen': '#90EE90',
	'lightpink': '#FFB6C1', 'lightsalmon': '#FFA07A', 'lightseagreen': '#20B2AA', 'lightskyblue': '#87CEFA', 'lightslategray': '#778899',
	'lightslategrey': '#778899', 'lightsteelblue': '#B0C4DE', 'lightyellow': '#FFFFE0', 'lime': '#00FF00', 'limegreen': '#32CD32', 'linen': '#FAF0E6',
	'magenta': '#FF00FF', 'maroon': '#800000', 'mediumaquamarine': '#66CDAA', 'mediumblue': '#0000CD', 'mediumorchid': '#BA55D3', 'mediumpurple': '#9370D8',
	'mediumseagreen': '#3CB371', 'mediumslateblue': '#7B68EE', 'mediumspringgreen': '#00FA9A', 'mediumturquoise': '#48D1CC', 'mediumvioletred': '#C71585',
	'midnightblue': '#191970', 'mintcream': '#F5FFFA', 'mistyrose': '#FFE4E1', 'moccasin': '#FFE4B5', 'navajowhite': '#FFDEAD', 'navy': '#000080', 'oldlace': '#FDF5E6',
	'olive': '#808000', 'olivedrab': '#6B8E23', 'orange': '#FFA500', 'orangered': '#FF4500', 'orchid': '#DA70D6', 'palegoldenrod': '#EEE8AA',
	'palegreen': '#98FB98', 'paleturquoise': '#AFEEEE', 'palevioletred': '#D87093', 'papayawhip': '#FFEFD5', 'peachpuff': '#FFDAB9', 'peru': '#CD853F',
	'pink': '#FFC0CB', 'plum': '#DDA0DD', 'powderblue': '#B0E0E6', 'purple': '#800080', 'red': '#FF0000', 'rosybrown': '#BC8F8F', 'royalblue': '#4169E1',
	'saddlebrown': '#8B4513', 'salmon': '#FA8072', 'sandybrown': '#F4A460', 'seagreen': '#2E8B57', 'seashell': '#FFF5EE', 'sienna': '#A0522D', 'silver': '#C0C0C0',
	'skyblue': '#87CEEB', 'slateblue': '#6A5ACD', 'slategray': '#708090', 'slategrey': '#708090', 'snow': '#FFFAFA', 'springgreen': '#00FF7F',
	'steelblue': '#4682B4', 'tan': '#D2B48C', 'teal': '#008080', 'thistle': '#D8BFD8', 'tomato': '#FF6347', 'turquoise': '#40E0D0', 'violet': '#EE82EE'
};

var absround = function absround(number) {
	return 0.5 + number << 0;
};

var hue2rgb = function hue2rgb(a, b, c) {
	if (c < 0) c += 1;
	if (c > 1) c -= 1;
	if (c < 1 / 6) return a + (b - a) * 6 * c;
	if (c < 1 / 2) return b;
	if (c < 2 / 3) return a + (b - a) * (2 / 3 - c) * 6;
	return a;
};

var p2v = function p2v(p) {
	return isPercent.test(p) ? absround(parseInt(p) * 2.55) : p;
};

var isHex = /^#?([0-9a-f]{3}|[0-9a-f]{6})$/i;
var isHSL = /^hsla?\((\d{1,3}?),\s*(\d{1,3}%),\s*(\d{1,3}%)(,\s*[01]?\.?\d*)?\)$/;
var isRGB = /^rgba?\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?)(,\s*[01]?\.?\d*)?\)$/;
var isPercent = /^\d+(\.\d+)*%$/;

var hexBit = /([0-9a-f])/gi;
var leadHex = /^#/;

var matchHSL = /^hsla?\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%(,\s*([01]?\.?\d*))?\)$/;
var matchRGB = /^rgba?\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?)(,\s*([01]?\.?\d*))?\)$/;

function Color$1(value) {

	this._listeners = {};

	this.subscribe(Events.RGB_UPDATED, this._RGBUpdated);
	this.subscribe(Events.HEX_UPDATED, this._HEXUpdated);
	this.subscribe(Events.HSL_UPDATED, this._HSLUpdated);
	this.subscribe(Events.HSV_UPDATED, this._HSVUpdated);
	this.subscribe(Events.INT_UPDATED, this._INTUpdated);

	this.parse(value);
}

Color$1.prototype._decimal = 0;
Color$1.prototype._hex = '#000000';
Color$1.prototype._red = 0;
Color$1.prototype._green = 0;
Color$1.prototype._blue = 0;
Color$1.prototype._hue = 0;
Color$1.prototype._saturation = 0;
Color$1.prototype._lightness = 0;
Color$1.prototype._brightness = 0;
Color$1.prototype._alpha = 1;

Color$1.prototype.parse = function (value) {
	if (typeof value == 'undefined') {
		return this;
	}
	switch (true) {
		case isFinite(value):
			this.decimal(value);
			this.output = Color$1.INT;
			return this;
		case value instanceof Color$1:
			this.copy(value);
			return this;
		default:
			switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
				case 'object':
					this.set(value);
					return this;
				case 'string':
					switch (true) {
						case namedColors.hasOwnProperty(value):
							value = namedColors[value];
							var stripped = value.replace(leadHex, '');
							this.decimal(parseInt(stripped, 16));
							return this;
						case isHex.test(value):
							var stripped = value.replace(leadHex, '');
							if (stripped.length == 3) {
								stripped = stripped.replace(hexBit, '$1$1');
							};
							this.decimal(parseInt(stripped, 16));
							return this;
						case isRGB.test(value):
							var parts = value.match(matchRGB);
							this.red(p2v(parts[1]));
							this.green(p2v(parts[2]));
							this.blue(p2v(parts[3]));
							this.alpha(parseFloat(parts[5]) || 1);
							this.output = (isPercent.test(parts[1]) ? 2 : 1) + (parts[5] ? 2 : 0);
							return this;
						case isHSL.test(value):
							var parts = value.match(matchHSL);
							this.hue(parseInt(parts[1]));
							this.saturation(parseInt(parts[2]));
							this.lightness(parseInt(parts[3]));
							this.alpha(parseFloat(parts[5]) || 1);
							this.output = parts[5] ? 6 : 5;
							return this;
					};
			};

	}
	return this;
};

Color$1.prototype.clone = function () {
	return new Color$1(this.decimal());
};

Color$1.prototype.copy = function (color) {
	this.set(color.decimal());
	return this;
};

Color$1.prototype.set = function (key, value) {
	if (arguments.length == 1) {
		if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == 'object') {
			for (var p in key) {
				if (typeof this[p] == 'function') {
					this[p](key[p]);
				}
			}
		} else if (isFinite(key)) {
			this.decimal(key);
		}
	} else if (typeof this[key] == 'function') {
		this[key](value);
	}
	return this;
};

Color$1.prototype.interpolate = function (destination, factor) {
	if (!(destination instanceof Color$1)) {
		destination = new Color$1(destination);
	}
	this._red = absround(+this._red + (destination._red - this._red) * factor);
	this._green = absround(+this._green + (destination._green - this._green) * factor);
	this._blue = absround(+this._blue + (destination._blue - this._blue) * factor);
	this._alpha = absround(+this._alpha + (destination._alpha - this._alpha) * factor);
	this.broadcast(Events.RGB_UPDATED);
	this.broadcast(Events.UPDATED);
	return this;
};

Color$1.prototype._RGB2HSL = function () {

	var r = this._red / 255;
	var g = this._green / 255;
	var b = this._blue / 255;

	var max = Math.max(r, g, b);
	var min = Math.min(r, g, b);
	var l = (max + min) / 2;
	var v = max;

	if (max == min) {
		this._hue = 0;
		this._saturation = 0;
		this._lightness = absround(l * 100);
		this._brightness = absround(v * 100);
		return;
	}

	var d = max - min;
	var s = d / (l <= 0.5 ? max + min : 2 - max - min);
	var h = (max == r ? (g - b) / d + (g < b ? 6 : 0) : max == g ? (b - r) / d + 2 : (r - g) / d + 4) / 6;

	this._hue = absround(h * 360);
	this._saturation = absround(s * 100);
	this._lightness = absround(l * 100);
	this._brightness = absround(v * 100);
};

Color$1.prototype._HSL2RGB = function () {
	var h = this._hue / 360;
	var s = this._saturation / 100;
	var l = this._lightness / 100;
	var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	var p = 2 * l - q;
	this._red = absround(hue2rgb(p, q, h + 1 / 3) * 255);
	this._green = absround(hue2rgb(p, q, h) * 255);
	this._blue = absround(hue2rgb(p, q, h - 1 / 3) * 255);
};

Color$1.prototype._HSV2RGB = function () {
	var h = this._hue / 360;
	var s = this._saturation / 100;
	var v = this._brightness / 100;
	var r = 0;
	var g = 0;
	var b = 0;
	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0:
			r = v, g = t, b = p;
			break;
		case 1:
			r = q, g = v, b = p;
			break;
		case 2:
			r = p, g = v, b = t;
			break;
		case 3:
			r = p, g = q, b = v;
			break;
		case 4:
			r = t, g = p, b = v;
			break;
		case 5:
			r = v, g = p, b = q;
			break;
	}
	this._red = absround(r * 255);
	this._green = absround(g * 255);
	this._blue = absround(b * 255);
};

Color$1.prototype._INT2HEX = function () {
	var x = this._decimal.toString(16);
	x = '000000'.substr(0, 6 - x.length) + x;
	this._hex = '#' + x.toUpperCase();
};

Color$1.prototype._INT2RGB = function () {
	this._red = this._decimal >> 16;
	this._green = this._decimal >> 8 & 0xFF;
	this._blue = this._decimal & 0xFF;
};

Color$1.prototype._HEX2INT = function () {
	this._decimal = parseInt(this._hex, 16);
};

Color$1.prototype._RGB2INT = function () {
	this._decimal = this._red << 16 | this._green << 8 & 0xffff | this._blue;
};

Color$1.prototype._RGBUpdated = function () {
	this._RGB2INT();
	this._RGB2HSL();
	this._INT2HEX();
};
Color$1.prototype._HSLUpdated = function () {
	this._HSL2RGB();
	this._RGB2INT();
	this._INT2HEX();
};
Color$1.prototype._HSVUpdated = function () {
	this._HSV2RGB();
	this._RGB2INT();
	this._INT2HEX();
};
Color$1.prototype._HEXUpdated = function () {
	this._HEX2INT();
	this._INT2RGB();
	this._RGB2HSL();
};
Color$1.prototype._INTUpdated = function () {
	this._INT2RGB();
	this._RGB2HSL();
	this._INT2HEX();
};

Color$1.prototype._broadcastUpdate = function () {
	this.broadcast(Event.UPDATED);
};

Color$1.prototype.decimal = function (value) {
	return this._handle('_decimal', value, Events.INT_UPDATED);
};

Color$1.prototype.hex = function (value) {
	return this._handle('_hex', value, Events.HEX_UPDATED);
};

Color$1.prototype.red = function (value) {
	return this._handle('_red', value, Events.RGB_UPDATED);
};

Color$1.prototype.green = function (value) {
	return this._handle('_green', value, Events.RGB_UPDATED);
};

Color$1.prototype.blue = function (value) {
	return this._handle('_blue', value, Events.RGB_UPDATED);
};

Color$1.prototype.hue = function (value) {
	return this._handle('_hue', value, Events.HSL_UPDATED);
};

Color$1.prototype.saturation = function (value) {
	return this._handle('_saturation', value, Events.HSL_UPDATED);
};

Color$1.prototype.lightness = function (value) {
	return this._handle('_lightness', value, Events.HSL_UPDATED);
};

Color$1.prototype.brightness = function (value) {
	return this._handle('_brightness', value, Events.HSV_UPDATED);
};

Color$1.prototype.alpha = function (value) {
	return this._handle('_alpha', value);
};

Color$1.prototype._handle = function (prop, value, event) {
	if (typeof this[prop] != 'undefined') {
		if (typeof value != 'undefined') {
			if (value != this[prop]) {
				this[prop] = value;
				if (event) {
					this.broadcast(event);
				}
			}
			this.broadcast(Event.UPDATED);
		}
	}
	return this[prop];
};

Color$1.prototype.getHex = function () {
	return this._hex;
};

Color$1.prototype.getRGB = function () {
	var components = [absround(this._red), absround(this._green), absround(this._blue)];
	return 'rgb(' + components.join(', ') + ')';
};

Color$1.prototype.getPRGB = function () {
	var components = [absround(100 * this._red / 255) + '%', absround(100 * this._green / 255) + '%', absround(100 * this._blue / 255) + '%'];
	return 'rgb(' + components.join(', ') + ')';
};

Color$1.prototype.getRGBA = function () {
	var components = [absround(this._red), absround(this._green), absround(this._blue), this._alpha];
	return 'rgba(' + components.join(', ') + ')';
};

Color$1.prototype.getPRGBA = function () {
	var components = [absround(100 * this._red / 255) + '%', absround(100 * this._green / 255) + '%', absround(100 * this._blue / 255) + '%', this._alpha];
	return 'rgba(' + components.join(', ') + ')';
};

Color$1.prototype.getHSL = function () {
	var components = [absround(this._hue), absround(this._saturation) + '%', absround(this._lightness) + '%'];
	return 'hsl(' + components.join(', ') + ')';
};

Color$1.prototype.getHSLA = function () {
	var components = [absround(this._hue), absround(this._saturation) + '%', absround(this._lightness) + '%', this._alpha];
	return 'hsla(' + components.join(', ') + ')';
};

Color$1.prototype.format = function (string$$1) {
	var tokens = {
		r: this._red,
		g: this._green,
		b: this._blue,
		h: this._hue,
		s: this._saturation,
		l: this._lightness,
		v: this._brightness,
		a: this._alpha,
		x: this._hex,
		d: this._decimal
	};
	for (var token in tokens) {
		string$$1 = string$$1.split('%' + token + '%').join(tokens[token]);
	}
	return string$$1;
};

Color$1.prototype.output = 0;

Color$1.HEX = 0;
Color$1.RGB = 1;
Color$1.PRGB = 2;
Color$1.RGBA = 3;
Color$1.PRGBA = 4;
Color$1.HSL = 5;
Color$1.HSLA = 6;
Color$1.INT = 7;

Color$1.prototype.toString = function () {
	switch (this.output) {
		case 0:
			return this.getHex();
		case 1:
			return this.getRGB();
		case 2:
			return this.getPRGB();
		case 3:
			return this.getRGBA();
		case 4:
			return this.getPRGBA();
		case 5:
			return this.getHSL();
		case 6:
			return this.getHSLA();
		case 7:
			return this._decimal;
	}
	return this.getHex();
};

Color$1.prototype._listeners = null;
Color$1.prototype._isSubscribed = function (type) {
	return this._listeners[type] != null;
};

Color$1.prototype.subscribe = function (type, callback) {
	if (!this._isSubscribed(type)) {
		this._listeners[type] = [];
	}
	this._listeners[type].push(callback);
};

Color$1.prototype.unsubscribe = function (type, callback) {
	if (!this._isSubscribed(type)) {
		return;
	}
	var stack = this._listeners[type];
	for (var i = 0, l = stack.length; i < l; i++) {
		if (stack[i] === callback) {
			stack.splice(i, 1);
			return this.unsubscribe(type, callback);
		}
	}
};

Color$1.prototype.broadcast = function (type, params) {
	if (!this._isSubscribed(type)) {
		return;
	}
	var stack = this._listeners[type];
	var l = stack.length;
	for (var i = 0; i < l; i++) {
		stack[i].apply(this, params);
	}
};

Color$1.prototype.tween = function (duration, color) {
	if (!(color instanceof Color$1)) {
		color = new Color$1(color);
	}
	var start = +new Date();
	var ref = this;
	this.broadcast('tweenStart');
	var interval = setInterval(function () {
		var ellapsed = +new Date() - start;
		var delta = Math.min(1, ellapsed / duration);
		ref.interpolate(color, delta);
		ref.broadcast('tweenProgress');
		if (delta == 1) {
			clearInterval(interval);
			ref.broadcast('tweenComplete');
		}
	}, 20);
	return interval;
};

Color$1.prototype.bind = function (object, property) {
	var ref = this;
	this.subscribe('updated', function () {
		object[property] = ref.toString();
	});
};

Color$1.random = function () {
	return new Color$1(absround(Math.random() * 16777215));
};

Color$1.bind = function (object, property) {
	var color = new Color$1(object[property]);
	color.bind(object, property);
	return color;
};

// adapted from convert-css-length
// MIT licensed, Copyright (c) 2015 Kyle Mathews
// https://github.com/KyleAMathews/convert-css-length/blob/master/LICENSE

var baseFontSize = "16px";
var parseUnit;
var unit;
var unitLess;

if (System.get("@system-env").browser) {
  try {
    var newBaseFontSize = cssLengthParser(16)(window.getComputedStyle(document.body).fontSize);
    if (newBaseFontSize && newBaseFontSize.slice(0, 3) !== "NaN") baseFontSize = newBaseFontSize;
  } catch (e) {}
}

function unit(length) {
  return parseUnit(length)[1];
}

function unitLess(length) {
  return parseUnit(length)[0];
}

function genericCssLengthParser(baseFontSize) {
  if (baseFontSize == null) {
    baseFontSize = baseFontSize;
  }
  return function (length, toUnit, fromContext, toContext) {
    var fromUnit, outputLength, pxLength;
    if (fromContext == null) {
      fromContext = baseFontSize;
    }
    if (toContext == null) {
      toContext = fromContext;
    }
    fromUnit = unit(length);
    if (fromUnit === toUnit) {
      return length;
    }
    pxLength = unitLess(length);
    if (unit(fromContext) !== "px") {
      console.warn("Parameter fromContext must resolve to a value in pixel units.");
    }
    if (unit(toContext) !== "px") {
      console.warn("Parameter toContext must resolve to a value in pixel units.");
    }
    if (fromUnit !== "px") {
      if (fromUnit === "em") {
        pxLength = unitLess(length) * unitLess(fromContext);
      } else if (fromUnit === "rem") {
        pxLength = unitLess(length) * unitLess(baseFontSize);
      } else if (fromUnit === "ex") {
        pxLength = unitLess(length) * unitLess(fromContext) * 2;
      } else if (fromUnit === "ch" || fromUnit === "vw" || fromUnit === "vh" || fromUnit === "vmin") {
        console.warn(fromUnit + " units can't be reliably converted; Returning original value.");
        return length;
      } else {
        console.warn(fromUnit + " is an unknown or unsupported length unit; Returning original value.");
        return length;
      }
    }
    outputLength = pxLength;
    if (toUnit !== "px") {
      if (toUnit === "em") {
        outputLength = pxLength / unitLess(toContext);
      } else if (toUnit === "rem") {
        outputLength = pxLength / unitLess(baseFontSize);
      } else if (toUnit === "ex") {
        outputLength = pxLength / unitLess(toContext) / 2;
      } else if (toUnit === "ch" || toUnit === "vw" || toUnit === "vh" || toUnit === "vmin") {
        console.warn(toUnit + " units can't be reliably converted; Returning original value.");
        return length;
      } else {
        console.warn(toUnit + " is an unknown or unsupported length unit; Returning original value.");
        return length;
      }
    }
    return parseFloat(outputLength.toFixed(5)) + toUnit;
  };
}

var parseCssLength = genericCssLengthParser(baseFontSize);

function cssLengthToPixels(length) {
  return Number(parseCssLength(length, "px").slice(0, -2));
}

var Point = function () {
  createClass(Point, null, [{
    key: "ensure",
    value: function ensure(duck) {
      return duck instanceof Point ? duck : new Point(duck.x, duck.y);
    }
  }, {
    key: "polar",
    value: function polar(r, theta) {
      // theta=0 is East on the screen,
      // increases in counter-clockwise direction
      return new Point(r * Math.cos(theta), r * Math.sin(theta));
    }
  }, {
    key: "random",
    value: function random(scalePt) {
      return new Point(lively_lang.num.randomSmallerInteger(scalePt.x), lively_lang.num.randomSmallerInteger(scalePt.y));
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(literal) {
      return pt(literal.x, literal.y);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return pt(tuple[0], tuple[1]);
    }
  }]);

  function Point(x, y) {
    classCallCheck(this, Point);

    this.x = x || 0;
    this.y = y || 0;
  }

  createClass(Point, [{
    key: "getX",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    value: function getX() {
      return this.x;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // arithmetic
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return new Point(this.x.toFixed(val), this.y.toFixed(val));
    }
  }, {
    key: "addPt",
    value: function addPt(p) {
      return new Point(this.x + p.x, this.y + p.y);
    }
  }, {
    key: "addXY",
    value: function addXY(dx, dy) {
      return new Point(this.x + dx, this.y + dy);
    }
  }, {
    key: "midPt",
    value: function midPt(p) {
      return new Point((this.x + p.x) / 2, (this.y + p.y) / 2);
    }
  }, {
    key: "subPt",
    value: function subPt(p) {
      return new Point(this.x - p.x, this.y - p.y);
    }
  }, {
    key: "subXY",
    value: function subXY(dx, dy) {
      return new Point(this.x - dx, this.y - dy);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "scaleBy",
    value: function scaleBy(scaleX, scaleYOrUndefined) {
      return new Point(this.x * scaleX, this.y * (scaleYOrUndefined || scaleX));
    }
  }, {
    key: "scaleByPt",
    value: function scaleByPt(scalePt) {
      return new Point(this.x * scalePt.x, this.y * scalePt.y);
    }
  }, {
    key: "negated",
    value: function negated() {
      return new Point(-this.x, -this.y);
    }
  }, {
    key: "inverted",
    value: function inverted() {
      return new Point(1.0 / this.x, 1.0 / this.y);
    }
  }, {
    key: "invertedSafely",
    value: function invertedSafely() {
      return new Point(this.x && 1.0 / this.x, this.y && 1.0 / this.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "lessPt",
    value: function lessPt(p) {
      return this.x < p.x && this.y < p.y;
    }
  }, {
    key: "leqPt",
    value: function leqPt(p) {
      return this.x <= p.x && this.y <= p.y;
    }
  }, {
    key: "eqPt",
    value: function eqPt(p) {
      return this.x == p.x && this.y == p.y;
    }
  }, {
    key: "equals",
    value: function equals(p) {
      return this.x == p.x && this.y == p.y;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "withX",
    value: function withX(x) {
      return pt(x, this.y);
    }
  }, {
    key: "withY",
    value: function withY(y) {
      return pt(this.x, y);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Point(this.x, this.y);
    }
  }, {
    key: "minPt",
    value: function minPt(p, acc) {
      if (!acc) acc = new Point(0, 0);
      acc.x = Math.min(this.x, p.x);
      acc.y = Math.min(this.y, p.y);
      return acc;
    }
  }, {
    key: "maxPt",
    value: function maxPt(p, acc) {
      if (!acc) acc = new Point(0, 0);
      acc.x = Math.max(this.x, p.x);
      acc.y = Math.max(this.y, p.y);
      return acc;
    }
  }, {
    key: "random",
    value: function random() {
      return Point.random(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // point functions
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "normalized",
    value: function normalized() {
      var r = this.r();
      return pt(this.x / r, this.y / r);
    }
  }, {
    key: "fastNormalized",
    value: function fastNormalized() {
      var r = this.fastR();
      return pt(this.x / r, this.y / r);
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(p) {
      return this.x * p.x + this.y * p.y;
    }
  }, {
    key: "matrixTransform",
    value: function matrixTransform(mx, acc) {
      var x = mx.a * this.x + mx.c * this.y + mx.e,
          y = mx.b * this.x + mx.d * this.y + mx.f;
      // if no accumulator passed, allocate a fresh one
      return !acc ? pt(x, y) : Object.assign(acc, { x: x, y: y });
    }
  }, {
    key: "matrixTransformDirection",
    value: function matrixTransformDirection(mx, acc) {
      var x = mx.a * this.x + mx.c * this.y,
          y = mx.b * this.x + mx.d * this.y;
      // if no accumulator passed, allocate a fresh one
      return !acc ? pt(x, y) : Object.assign(acc, { x: x, y: y });
    }
  }, {
    key: "griddedBy",
    value: function griddedBy(grid) {
      return pt(this.x - this.x % grid.x, this.y - this.y % grid.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // geometry computation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "roundTo",
    value: function roundTo(quantum) {
      return new Point(lively_lang.num.roundTo(this.x, quantum), lively_lang.num.roundTo(this.y, quantum));
    }
  }, {
    key: "dist",
    value: function dist(p) {
      var dx = this.x - p.x,
          dy = this.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }, {
    key: "distSquared",
    value: function distSquared(p) {
      var dx = this.x - p.x,
          dy = this.y - p.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "nearestPointOnLineBetween",
    value: function nearestPointOnLineBetween(p1, p2) {
      if (p1.x == p2.x) return pt(p1.x, this.y);
      if (p1.y == p2.y) return pt(this.x, p1.y);
      var x1 = p1.x,
          y1 = p1.y,
          x21 = p2.x - x1,
          y21 = p2.y - y1,
          t = ((this.y - y1) / x21 + (this.x - x1) / y21) / (x21 / y21 + y21 / x21);
      return pt(x1 + t * x21, y1 + t * y21);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // polar coordinates
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "r",
    value: function r() {
      // Polar coordinates (theta=0 is East on screen, and increases in CCW
      // direction
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "fastR",
    value: function fastR() {
      // actually, r() might be faster...
      var a = this.x * this.x + this.y * this.y;
      var x = 17;
      for (var i = 0; i < 6; i++) {
        x = (x + a / x) / 2;
      }return x;
    }
  }, {
    key: "theta",
    value: function theta() {
      return Math.atan2(this.y, this.x);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "asRectangle",
    value: function asRectangle() {
      return new Rectangle(this.x, this.y, 0, 0);
    }
  }, {
    key: "extent",
    value: function extent(ext) {
      return new Rectangle(this.x, this.y, ext.x, ext.y);
    }
  }, {
    key: "extentAsRectangle",
    value: function extentAsRectangle() {
      return new Rectangle(0, 0, this.x, this.y);
    }
  }, {
    key: "lineTo",
    value: function lineTo(end) {
      return new Line(this, end);
    }
  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.x, this.y];
    }
  }, {
    key: "toLiteral",
    value: function toLiteral() {
      return { x: this.x, y: this.y };
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format("pt(%1.f,%1.f)", this.x, this.y);
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return JSON.stringify(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return { __expr__: this.toString(), bindings: { "lively.graphics/geometry-2d.js": ["pt"] } };
    }
  }, {
    key: "isPoint",
    get: function get() {
      return true;
    }
  }]);
  return Point;
}();

var Rectangle = function () {
  createClass(Rectangle, [{
    key: "corners",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    //  initialize
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    get: function get() {
      return ["topLeft", "topRight", "bottomRight", "bottomLeft"];
    }
  }, {
    key: "sides",
    get: function get() {
      return ["leftCenter", "rightCenter", "topCenter", "bottomCenter"];
    }
  }], [{
    key: "fromAny",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // factory methods
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    value: function fromAny(ptA, ptB) {
      return rect(ptA.minPt(ptB), ptA.maxPt(ptB));
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(literal) {
      return new Rectangle(literal.x, literal.y, literal.width, literal.height);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return new Rectangle(tuple[0], tuple[1], tuple[2], tuple[3]);
    }
  }, {
    key: "unionPts",
    value: function unionPts(points) {
      var min = points[0],
          max = points[0];

      // starts from 1 intentionally
      for (var i = 1; i < points.length; i++) {
        min = min.minPt(points[i]);
        max = max.maxPt(points[i]);
      }

      return rect(min, max);
    }
  }, {
    key: "ensure",
    value: function ensure(duck) {
      return duck instanceof Rectangle ? duck : new Rectangle(duck.x, duck.y, duck.width, duck.height);
    }
  }, {
    key: "fromElement",
    value: function fromElement(element) {
      // FIXME
      if (typeof element.getBoundingClientRect === "function") {
        var b = element.getBoundingClientRect();
        return rect(b.left, b.top, b.width, b.height);
      } else if (element.namespaceURI == "http://www.w3.org/1999/xhtml") {
        var x = cssLengthToPixels(element.style.left || "0px"),
            y = cssLengthToPixels(element.style.top || "0px"),
            width = cssLengthToPixels(element.style.width || "0px"),
            height = cssLengthToPixels(element.style.hieght || "0px");
        return new Rectangle(x, y, width, height);
      }
      if (element.namespaceURI == "http://www.w3.org/2000/svg") {
        return new Rectangle(element.x.baseVal.value, element.y.baseVal.value, element.width.baseVal.value, element.height.baseVal.value);
      }
      throw new Error('Cannot create Rectangle from ' + element);
    }
  }, {
    key: "inset",
    value: function inset(left, top, right, bottom) {
      if (top === undefined) top = left;
      if (right === undefined) right = left;
      if (bottom === undefined) bottom = top;
      return new Rectangle(left, top, right - left, bottom - top);
    }
  }]);

  function Rectangle(x, y, w, h) {
    classCallCheck(this, Rectangle);

    this.x = x || 0;
    this.y = y || 0;
    this.width = w || 0;
    this.height = h || 0;
  }

  createClass(Rectangle, [{
    key: "getX",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    value: function getX() {
      return this.x;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "copy",
    value: function copy() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return new Rectangle(this.x.toFixed(val), this.y.toFixed(val), this.width.toFixed(val), this.height.toFixed(val));
    }
  }, {
    key: "withWidth",
    value: function withWidth(w) {
      return new Rectangle(this.x, this.y, w, this.height);
    }
  }, {
    key: "withHeight",
    value: function withHeight(h) {
      return new Rectangle(this.x, this.y, this.width, h);
    }
  }, {
    key: "withX",
    value: function withX(x) {
      return new Rectangle(x, this.y, this.width, this.height);
    }
  }, {
    key: "withY",
    value: function withY(y) {
      return new Rectangle(this.x, y, this.width, this.height);
    }
  }, {
    key: "withExtent",
    value: function withExtent(ext) {
      return new Rectangle(this.x, this.y, ext.x, ext.y);
    }
  }, {
    key: "withTopLeft",
    value: function withTopLeft(p) {
      return Rectangle.fromAny(p, this.bottomRight());
    }
  }, {
    key: "withTopRight",
    value: function withTopRight(p) {
      return Rectangle.fromAny(this.bottomLeft(), p);
    }
  }, {
    key: "withBottomRight",
    value: function withBottomRight(p) {
      return Rectangle.fromAny(p, this.topLeft());
    }
  }, {
    key: "withBottomLeft",
    value: function withBottomLeft(p) {
      return Rectangle.fromAny(p, this.topRight());
    }
  }, {
    key: "withLeftCenter",
    value: function withLeftCenter(p) {
      return new Rectangle(p.x, this.y, this.width + (this.x - p.x), this.height);
    }
  }, {
    key: "withRightCenter",
    value: function withRightCenter(p) {
      return new Rectangle(this.x, this.y, p.x - this.x, this.height);
    }
  }, {
    key: "withTopCenter",
    value: function withTopCenter(p) {
      return new Rectangle(this.x, p.y, this.width, this.height + (this.y - p.y));
    }
  }, {
    key: "withBottomCenter",
    value: function withBottomCenter(p) {
      return new Rectangle(this.x, this.y, this.width, p.y - this.y);
    }
  }, {
    key: "withCenter",
    value: function withCenter(p) {
      return new Rectangle(p.x - this.width / 2, p.y - this.height / 2, this.width, this.height);
    }
  }, {
    key: "insetBy",
    value: function insetBy(d) {
      return new Rectangle(this.x + d, this.y + d, this.width - d * 2, this.height - d * 2);
    }
  }, {
    key: "insetByPt",
    value: function insetByPt(p) {
      return new Rectangle(this.x + p.x, this.y + p.y, this.width - p.x * 2, this.height - p.y * 2);
    }
  }, {
    key: "grid",
    value: function grid(rows, cols) {
      var w = this.width / cols,
          h = this.height / rows;
      return lively_lang.grid.mapCreate(rows, cols, function (i, j) {
        return new Rectangle(w * j, h * i, w, h);
      });
    }
  }, {
    key: "divide",
    value: function divide(relativeRects) {
      // takes an array of rectangles specifying the relative parts to divide
      // this by. Example:
      // rect(0,0,100,50).divide([rect(0.2,0,0.3,0.5)])
      //   === [rect(20,0,30,25)]
      var orig = this;
      return relativeRects.map(function (relRect) {
        return rect(orig.x + orig.width * relRect.x, orig.y + orig.height * relRect.y, orig.width * relRect.width, orig.height * relRect.height);
      });
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.x, this.y, this.width, this.height];
    }
  }, {
    key: "lineTo",
    value: function lineTo(otherRect) {
      var center1 = this.center(),
          center2 = otherRect.center(),
          lineBetween = center1.lineTo(center2),
          start = this.lineIntersection(lineBetween)[0],
          end = otherRect.lineIntersection(lineBetween)[0];
      return start && end && start.lineTo(end);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(other) {
      if (!other) {
        return false;
      }
      return this.x == other.x && this.y == other.y && this.width == other.width && this.height == other.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "inspect",
    value: function inspect() {
      return JSON.stringify(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "topLeft",
    value: function topLeft() {
      return new Point(this.x, this.y);
    }
  }, {
    key: "topRight",
    value: function topRight() {
      return new Point(this.maxX(), this.y);
    }
  }, {
    key: "bottomRight",
    value: function bottomRight() {
      return new Point(this.maxX(), this.maxY());
    }
  }, {
    key: "bottomLeft",
    value: function bottomLeft() {
      return new Point(this.x, this.maxY());
    }
  }, {
    key: "leftCenter",
    value: function leftCenter() {
      return new Point(this.x, this.center().y);
    }
  }, {
    key: "rightCenter",
    value: function rightCenter() {
      return new Point(this.maxX(), this.center().y);
    }
  }, {
    key: "topCenter",
    value: function topCenter() {
      return new Point(this.center().x, this.y);
    }
  }, {
    key: "bottomCenter",
    value: function bottomCenter() {
      return new Point(this.center().x, this.maxY());
    }
  }, {
    key: "extent",
    value: function extent() {
      return new Point(this.width, this.height);
    }
  }, {
    key: "center",
    value: function center() {
      return new Point(this.x + this.width / 2, this.y + this.height / 2);
    }
  }, {
    key: "topEdge",
    value: function topEdge() {
      return new Line(this.topLeft(), this.topRight());
    }
  }, {
    key: "bottomEdge",
    value: function bottomEdge() {
      return new Line(this.bottomLeft(), this.bottomRight());
    }
  }, {
    key: "leftEdge",
    value: function leftEdge() {
      return new Line(this.topLeft(), this.bottomLeft());
    }
  }, {
    key: "rightEdge",
    value: function rightEdge() {
      return new Line(this.topRight(), this.bottomRight());
    }
  }, {
    key: "edges",
    value: function edges() {
      return [this.topEdge(), this.rightEdge(), this.bottomEdge(), this.leftEdge()];
    }
  }, {
    key: "allPoints",
    value: function allPoints() {
      // take rectangle as discrete grid and return all points in the grid
      // rect(3,4,2,3).allPoints() == [pt(3,4),pt(4,4),pt(3,5),pt(4,5),pt(3,6),pt(4,6)]
      // if you want to convert points to indices use
      // var w = 5, h = 7; rect(3,4,2,3).allPoints().map(function(p) { return p.y * w + p.x; }) == [23,24,28,29,33,34]
      var x = this.x,
          y = this.y,
          w = this.width,
          h = this.height,
          points = [];
      for (var j = y; j < y + h; j++) {
        for (var i = x; i < x + w; i++) {
          points.push(pt(i, j));
        }
      }return points;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "isNonEmpty",
    value: function isNonEmpty(rect) {
      return this.width > 0 && this.height > 0;
    }
  }, {
    key: "containsRect",
    value: function containsRect(r) {
      return this.x <= r.x && this.y <= r.y && r.maxX() <= this.maxX() && r.maxY() <= this.maxY();
    }
  }, {
    key: "intersects",
    value: function intersects(r) {
      return this.intersection(r).isNonEmpty();
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return this.x <= p.x && p.x <= this.x + this.width && this.y <= p.y && p.y <= this.y + this.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "translatedBy",
    value: function translatedBy(d) {
      return new Rectangle(this.x + d.x, this.y + d.y, this.width, this.height);
    }
  }, {
    key: "scaleByRect",
    value: function scaleByRect(r) {
      // r is a relative rect, as a pane spec in a window
      return new Rectangle(this.x + r.x * this.width, this.y + r.y * this.height, r.width * this.width, r.height * this.height);
    }
  }, {
    key: "scaleRectIn",
    value: function scaleRectIn(fullRect) {
      // return a relative rect for this as a part of fullRect
      return new Rectangle((this.x - fullRect.x) / fullRect.width, (this.y - fullRect.y) / fullRect.height, this.width / fullRect.width, this.height / fullRect.height);
    }
  }, {
    key: "scaleRectTo",
    value: function scaleRectTo(fullRect) {
      // scale the rect until it reaches the bounds of the full rect
      var height, width, scale;
      if (this.width > this.height) {
        width = this.width;
      } else {
        height = this.height;
      }

      if (width) {
        scale = fullRect.width / width;
      } else {
        scale = fullRect.height / height;
      }

      return this.withExtent(this.extent().scaleBy(scale)).withCenter(this.center());
    }
  }, {
    key: "expandBy",
    value: function expandBy(delta) {
      return this.insetBy(0 - delta);
    }
  }, {
    key: "translateForInclusion",
    value: function translateForInclusion(other) {
      var x = other.x,
          y = other.y,
          r = x + other.width,
          b = y + other.height;
      if (r > this.right()) x -= r - this.right();
      if (b > this.bottom()) y -= b - this.bottom();
      if (x < this.x) x = this.x;
      if (y < this.y) y = this.y;
      return rect(x, y, other.width, other.height);
    }
  }, {
    key: "transformRectForInclusion",
    value: function transformRectForInclusion(other) {
      var topLeft = this.topLeft().maxPt(other.topLeft()),
          newBottomRight = topLeft.addPt(other.extent()),
          innerBottomRight = this.bottomRight().minPt(newBottomRight);
      return rect(topLeft, innerBottomRight);
    }
  }, {
    key: "insetByRect",
    value: function insetByRect(r) {
      return new Rectangle(this.x + r.left(), this.y + r.top(), this.width - (r.left() + r.right()), this.height - (r.top() + r.bottom()));
    }
  }, {
    key: "outsetByRect",
    value: function outsetByRect(r) {
      return new Rectangle(this.x - r.left(), this.y - r.top(), this.width + (r.left() + r.right()), this.height + (r.top() + r.bottom()));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // relations
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "intersection",
    value: function intersection(rect) {
      var nx = Math.max(this.x, rect.x);
      var ny = Math.max(this.y, rect.y);
      var nw = Math.min(this.x + this.width, rect.x + rect.width) - nx;
      var nh = Math.min(this.y + this.height, rect.y + rect.height) - ny;
      return new Rectangle(nx, ny, nw, nh);
    }
  }, {
    key: "union",
    value: function union(r) {
      return rect(this.topLeft().minPt(r.topLeft()), this.bottomRight().maxPt(r.bottomRight()));
    }
  }, {
    key: "lineIntersection",
    value: function lineIntersection(line) {
      return this.edges().map(function (edge) {
        return edge.intersection(line);
      }).filter(function (ea) {
        return !!ea;
      });
    }
  }, {
    key: "dist",
    value: function dist(rect) {
      var p1 = this.closestPointToPt(rect.center());
      var p2 = rect.closestPointToPt(p1);
      return p1.dist(p2);
    }
  }, {
    key: "relativeToAbsPoint",
    value: function relativeToAbsPoint(relPt) {
      return new Point(this.x + this.width * relPt.x, this.y + this.height * relPt.y);
    }
  }, {
    key: "closestPointToPt",
    value: function closestPointToPt(p) {
      // Assume p lies outside me; return a point on my perimeter
      return pt(Math.min(Math.max(this.x, p.x), this.maxX()), Math.min(Math.max(this.y, p.y), this.maxY()));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // properties
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "maxX",
    value: function maxX() {
      return this.x + this.width;
    }
  }, {
    key: "maxY",
    value: function maxY() {
      return this.y + this.height;
    }
  }, {
    key: "realWidth",
    value: function realWidth() {
      return this.x < 0 ? -this.x + this.width : this.width;
    }
  }, {
    key: "realHeight",
    value: function realHeight() {
      return this.y < 0 ? -this.y + this.height : this.height;
    }
  }, {
    key: "area",
    value: function area() {
      var area = this.width * this.height,
          sign = this.width < 0 && this.height < 0 ? -1 : 1;
      return sign * area;
    }
  }, {
    key: "randomPoint",
    value: function randomPoint() {
      return Point.random(pt(this.width, this.height)).addPt(this.topLeft());
    }
  }, {
    key: "constrainPt",
    value: function constrainPt(pt) {
      return pt.maxPt(this.topLeft()).minPt(this.bottomRight());
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // SVG interface
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // modeled after the CSS box model: http://www.w3.org/TR/REC-CSS2/box.html

  }, {
    key: "left",
    value: function left() {
      return this.x;
    }
  }, {
    key: "right",
    value: function right() {
      return this.maxX();
    }
  }, {
    key: "top",
    value: function top() {
      return this.y;
    }
  }, {
    key: "bottom",
    value: function bottom() {
      return this.maxY();
    }
  }, {
    key: "toInsetTuple",
    value: function toInsetTuple() {
      return [this.left(), this.top(), this.right(), this.bottom()];
    }
  }, {
    key: "toAttributeValue",
    value: function toAttributeValue(d) {
      var d = 0.01,
          result = [this.left()];
      if (this.top() === this.bottom() && this.left() === this.right()) {
        if (this.top() === this.left()) result.push(this.top());
      } else result = result.concat([this.top(), this.right(), this.bottom()]);
      return result.invoke('roundTo', d || 0.01);
    }
  }, {
    key: "toLiteral",
    value: function toLiteral() {
      return { x: this.x, y: this.y, width: this.width, height: this.height };
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // part support
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "partNamed",
    value: function partNamed(partName) {
      return this[partName].call(this);
    }
  }, {
    key: "withPartNamed",
    value: function withPartNamed(partName, newValue) {
      return this[this.setterName(partName)].call(this, newValue);
    }
  }, {
    key: "setterName",
    value: function setterName(partName) {
      return "with" + partName[0].toUpperCase() + partName.slice(1);
    }
  }, {
    key: "partNameNear",
    value: function partNameNear(partNames, p, dist) {
      var partName = this.partNameNearest(partNames, p);
      return p.dist(this.partNamed(partName)) < dist ? partName : null;
    }
  }, {
    key: "partNameNearest",
    value: function partNameNearest(partNames, p) {
      var dist = 1.0e99,
          partName = partNames[0];

      for (var i = 0; i < partNames.length; i++) {
        var partName = partNames[i],
            pDist = p.dist(this.partNamed(partName));
        if (pDist < dist) {
          var nearest = partName;dist = pDist;
        }
      }

      return nearest;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // printing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format("rect(%s,%s,%s,%s)", this.x, this.y, this.width, this.height);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return { __expr__: this.toString(), bindings: { "lively.graphics/geometry-2d.js": ["rect"] } };
    }
  }, {
    key: "isRectangle",
    get: function get() {
      return true;
    }
  }]);
  return Rectangle;
}();

var Transform = function () {
  createClass(Transform, [{
    key: "exp",
    get: function get() {
      return 0.0001; /*precision*/
    }
  }]);

  function Transform(translation, rotation, scale) {
    classCallCheck(this, Transform);

    // matrix is a duck with a,b,c,d,e,f, could be an SVG matrix or a
    // Lively Transform
    // alternatively, its a combination of translation rotation and scale
    if (translation) {
      if (translation instanceof Point) {
        var delta = translation,
            angleInRadians = rotation || 0.0,
            scale = scale;
        if (scale === undefined) {
          scale = pt(1.0, 1.0);
        }
        this.a = this.ensureNumber(scale.x * Math.cos(angleInRadians));
        this.b = this.ensureNumber(scale.y * Math.sin(angleInRadians));
        this.c = this.ensureNumber(scale.x * -Math.sin(angleInRadians));
        this.d = this.ensureNumber(scale.y * Math.cos(angleInRadians));
        this.e = this.ensureNumber(delta.x);
        this.f = this.ensureNumber(delta.y);

        // avoid inaccurate translations in Chrome
        if (this.a > 1) this.a = Math.round(this.a * Math.pow(10, 2)) / Math.pow(10, 2);
        if (this.d > 1) this.d = Math.round(this.d * Math.pow(10, 2)) / Math.pow(10, 2);
      } else {
        this.fromMatrix(translation);
      }
    } else {
      this.a = this.d = 1.0;
      this.b = this.c = this.e = this.f = 0.0;
    }
  }

  createClass(Transform, [{
    key: "copy",
    value: function copy() {
      return new Transform(this);
    }
  }, {
    key: "fromMatrix",
    value: function fromMatrix(mx) {
      this.a = this.ensureNumber(mx.a);
      this.b = this.ensureNumber(mx.b);
      this.c = this.ensureNumber(mx.c);
      this.d = this.ensureNumber(mx.d);
      this.e = this.ensureNumber(mx.e);
      this.f = this.ensureNumber(mx.f);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "getRotation",
    value: function getRotation() {
      // in degrees
      // Note the ambiguity with negative scales is resolved by assuming
      // scale x is positive
      var r = lively_lang.num.toDegrees(Math.atan2(-this.c, this.a));

      // don't bother with values very close to 0
      return Math.abs(r) < this.eps ? 0 : r;
    }
  }, {
    key: "getScale",
    value: function getScale() {
      // Note the ambiguity with negative scales and rotation is resolved by assuming scale x is positive
      var a = this.a,
          c = this.c,
          s = Math.sqrt(a * a + c * c);

      // don't bother with values very close to 1
      return Math.abs(s - 1) < this.eps ? 1 : s;
    }
  }, {
    key: "getScalePoint",
    value: function getScalePoint() {
      // Note the ambiguity with negative scales and rotation is resolved by
      // assuming scale x is positive
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          sx = Math.sqrt(a * a + c * c),
          r = Math.atan2(-c, a),
          // radians
      // avoid div by 0
      sy = Math.abs(b) > Math.abs(d) ? b / Math.sin(r) : d / Math.cos(r);
      return pt(sx, sy);
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      return pt(this.e, this.f);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "isTranslation",
    value: function isTranslation() {
      // as specified in:
      // http://www.w3.org/TR/SVG11/coords.html#InterfaceSVGTransform
      return this.a == 1 && this.b == 0 && this.c == 0 && this.d == 1;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toSVGAttributeValue",
    value: function toSVGAttributeValue() {
      var delta = this.getTranslation(),
          attr = "translate(" + delta.x + "," + delta.y + ")",
          theta = this.getRotation(),
          sp = this.getScalePoint();

      if (theta != 0.0) attr += " rotate(" + this.getRotation() + ")"; // in degrees
      if (sp.x != 1.0 || sp.y != 1.0) attr += " scale(" + sp.x + "," + sp.y + ")";

      return attr;
    }
  }, {
    key: "toCSSValue",
    value: function toCSSValue(bounds) {
      var attr = '',
          delta = this.getTranslation();

      attr += "translate(" + delta.x.toFixed(2) + "px," + delta.y.toFixed(2) + "px)";

      if (bounds) {
        // FIXME this is to fix the rotation...!
        var offsetX = bounds.width / 2;
        var offsetY = bounds.height / 2;
        attr += " translate(" + offsetX.toFixed(2) + "px," + offsetY.toFixed(2) + "px)";
      }

      var theta = this.getRotation();
      if (theta != 0.0) attr += " rotate(" + this.getRotation().toFixed(2) + "deg)";

      if (bounds) {
        // FIXME this is to fix the rotation...!
        var offsetX = bounds.width / 2;
        var offsetY = bounds.height / 2;
        attr += " translate(" + (offsetX * -1).toFixed(2) + "px," + (offsetY * -1).toFixed(2) + "px)";
      }

      var sp = this.getScalePoint();
      if (sp.x != 1.0 || sp.y != 1.0) {
        attr += " scale(" + sp.x.toFixed(2) + "," + sp.y.toFixed(2) + ")";
      }

      return attr;
    }
  }, {
    key: "toCSSTransformString",
    value: function toCSSTransformString() {
      var rot = this.getRotation(),
          scale = this.getScale();
      return "translate(" + this.e + "px," + this.f + "px) rotate(" + rot + "deg) scale(" + scale + "," + scale + ")";
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toCSSTransformString();
    }
  }, {
    key: "toMatrix",
    value: function toMatrix() {
      return this.copy();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "transformPoint",
    value: function transformPoint(p, acc) {
      return p.matrixTransform(this, acc);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(p, acc) {
      return p.matrixTransformDirection(this, acc);
    }
  }, {
    key: "matrixTransformForMinMax",
    value: function matrixTransformForMinMax(pt, minPt, maxPt) {
      var x = this.a * pt.x + this.c * pt.y + this.e,
          y = this.b * pt.x + this.d * pt.y + this.f;
      if (x > maxPt.x) maxPt.x = x;
      if (y > maxPt.y) maxPt.y = y;
      if (x < minPt.x) minPt.x = x;
      if (y < minPt.y) minPt.y = y;
    }
  }, {
    key: "transformRectToRect",
    value: function transformRectToRect(r) {
      var minPt = pt(Infinity, Infinity),
          maxPt = pt(-Infinity, -Infinity);
      this.matrixTransformForMinMax(r.topLeft(), minPt, maxPt);
      this.matrixTransformForMinMax(r.bottomRight(), minPt, maxPt);
      if (!this.isTranslation()) {
        this.matrixTransformForMinMax(r.topRight(), minPt, maxPt);
        this.matrixTransformForMinMax(r.bottomLeft(), minPt, maxPt);
      }
      return rect(minPt, maxPt);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // matrix operations
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "preConcatenate",
    value: function preConcatenate(t) {
      var m = this.matrix_ || this.toMatrix();
      this.a = t.a * m.a + t.c * m.b;
      this.b = t.b * m.a + t.d * m.b;
      this.c = t.a * m.c + t.c * m.d;
      this.d = t.b * m.c + t.d * m.d;
      this.e = t.a * m.e + t.c * m.f + t.e;
      this.f = t.b * m.e + t.d * m.f + t.f;
      this.matrix_ = this.toMatrix();
      return this;
    }
  }, {
    key: "invert",
    value: function invert() {
      var m = this.copy();

      var det = m.a * m.d - m.c * m.b,
          invdet = 1 / det;

      this.a = m.d * invdet;
      this.b = -m.b * invdet;
      this.c = -m.c * invdet;
      this.d = m.a * invdet;
      this.e = (m.c * m.f - m.e * m.d) * invdet;
      this.f = -(m.a * m.f - m.b * m.e) * invdet;

      return this;
    }
  }, {
    key: "inverse",
    value: function inverse() {
      var matrix = this.matrix_ || this.toMatrix();
      var result = new this.constructor(matrix);
      result.invert();
      return result;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // helper
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "ensureNumber",
    value: function ensureNumber(value) {
      // note that if a,b,.. f are not numbers, it's usually a
      // problem, which may crash browsers (like Safari) that don't
      // do good typechecking of SVGMatrix properties
      if (isNaN(value)) {
        throw new Error('not a number');
      }
      return value;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "new Transform({a: " + this.a + ", b: " + this.b + ", c: " + this.c + ", d: " + this.d + ", e: " + this.e + ", f: " + this.f + "})",
        bindings: { "lively.graphics/geometry-2d.js": ["Transform"] }
      };
    }
  }, {
    key: "isTransform",
    get: function get() {
      return true;
    }
  }]);
  return Transform;
}();

var Line = function () {
  createClass(Line, null, [{
    key: "fromCoords",
    value: function fromCoords(startX, startY, endX, endY) {
      return new Line(pt(startX, startY), pt(endX, endY));
    }
  }]);

  function Line(start, end) {
    classCallCheck(this, Line);

    this.start = start;
    this.end = end;
  }

  createClass(Line, [{
    key: "withStart",
    value: function withStart(start) {
      return new Line(start, this.end);
    }
  }, {
    key: "withEnd",
    value: function withEnd(end) {
      return new Line(this.start, end);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "sampleN",
    value: function sampleN(n) {
      // return n points that are collinear with this and are between
      // this.start and this.end
      n = n || 10;
      var vector = this.end.subPt(this.start),
          stepPt = vector.scaleBy(1 / n),
          result = [];
      for (var i = 0; i <= n; i++) {
        result.push(this.start.addPt(stepPt.scaleBy(i)));
      }
      return result;
    }
  }, {
    key: "sample",
    value: function sample(length) {
      return this.sampleN(this.length() / length);
    }
  }, {
    key: "length",
    value: function length() {
      return this.start.dist(this.end);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(otherLine) {
      if (!otherLine) return false;
      return this.start.eqPt(otherLine.start) && this.end.eqPt(otherLine.end);
    }
  }, {
    key: "includesPoint",
    value: function includesPoint(p, unconstrained) {
      // test whether p is collinear with this.start, this.end
      // constrained: p also needs to be on segment between start, end
      var x1 = this.start.x,
          y1 = this.start.y,
          x2 = this.end.x,
          y2 = this.end.y,
          x3 = p.x,
          y3 = p.y,
          collinear = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) === 0;
      if (unconstrained || !collinear) return collinear;
      var xMin = Math.min(x1, x2),
          yMin = Math.min(y1, y2),
          xMax = Math.max(x1, x2),
          yMax = Math.max(y1, y2);
      return xMin <= x3 && x3 <= xMax && yMin <= y3 && y3 <= yMax;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // intersection
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "intersection",
    value: function intersection(otherLine, unconstrained) {
      // constrained: intersection has to be between start/ends of this and
      // otherLine
      // http://en.wikipedia.org/wiki/Line-line_intersection
      //       .. (x1, y1)
      //         ..              ..... (x4,y4)
      //           ..    ........
      // (x3,y3) .....X..
      //    .....      ..
      //                 ..  (x2, y2)
      var eps = 0.0001,
          start1 = this.start,
          end1 = this.end,
          start2 = otherLine.start,
          end2 = otherLine.end,
          x1 = start1.x,
          y1 = start1.y,
          x2 = end1.x,
          y2 = end1.y,
          x3 = start2.x,
          y3 = start2.y,
          x4 = end2.x,
          y4 = end2.y;

      var x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)),
          y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));

      // are lines parallel?
      if (x === Infinity || y === Infinity) return null;

      if (!unconstrained) {
        if (!lively_lang.num.between(x, x1, x2, eps) || !lively_lang.num.between(y, y1, y2, eps) || !lively_lang.num.between(x, x3, x4, eps) || !lively_lang.num.between(y, y3, y4, eps)) return null;
      }

      return pt(x, y);
    }
  }, {
    key: "perpendicularLine",
    value: function perpendicularLine() /*c-clockwise, cc-counterclockwise*/{
      var relPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var magn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var rot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "cc";
      var start = this.start,
          vec = this.toVector(),
          fromPos = start.addPt(vec.scaleBy(relPos)),
          thetaOrtho = vec.theta() + (rot === "cc" ? -1 : 1) * Math.PI / 2;

      return new Line(fromPos, fromPos.addPt(Point.polar(magn, thetaOrtho)));
    }
  }, {
    key: "toVector",
    value: function toVector() {
      var start = this.start,
          end = this.end;

      return end.subPt(start);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format('Line((%s,%s), (%s,%s))', this.start.x, this.start.y, this.end.x, this.end.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "Line.fromCoords(" + this.start.x + ", " + this.start.y + ", " + this.end.x + ", " + this.end.y + ")",
        bindings: { "lively.graphics/geometry-2d.js": ["Line"] }
      };
    }
  }, {
    key: "isLine",
    get: function get() {
      return true;
    }
  }]);
  return Line;
}();

function rect(arg1, arg2, arg3, arg4) {
  // arg1 and arg2 can be location and corner or
  // arg1/arg2 = location x/y and arg3/arg4 = extent x/y
  var x, y, w, h;
  if (typeof arg1 === 'number') {
    x = arg1, y = arg2, w = arg3, h = arg4;
  } else {
    x = arg1.x;y = arg1.y;
    w = arg2.x - x;h = arg2.y - y;
  }
  return new Rectangle(x, y, w, h);
}

function pt(x, y) {
  return new Point(x, y);
}

function floor(x) {
  return Math.floor(x * 255.99);
}

var rgbaRegex = new RegExp('\\s*rgba?\\s*\\(\\s*(\\d+)(%?)\\s*,\\s*(\\d+)(%?)\\s*,\\s*(\\d+)(%?)\\s*(?:,\\s*([0-9\\.]+)\\s*)?\\)\\s*');

var ColorHarmony = function () {
  function ColorHarmony() {
    classCallCheck(this, ColorHarmony);
  }

  createClass(ColorHarmony, [{
    key: "offsets",
    value: function offsets() {
      return null;
    }
  }, {
    key: "stepCount",
    value: function stepCount() {
      return 0;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 0;
    }
  }, {
    key: "chord",
    value: function chord(_ref) {
      var _this = this;

      var hue = _ref.hue,
          saturation = _ref.saturation,
          brightness = _ref.brightness;

      var offsets = this.offsets() || lively_lang.arr.range(0, this.steps()).map(function (i) {
        return i * _this.stepSize();
      });
      return offsets.map(function (offset) {
        return Color.hsb(hue + offset % 360, saturation, brightness);
      });
    }
  }, {
    key: "name",
    get: function get() {
      return "Color Harmony";
    }
  }]);
  return ColorHarmony;
}();

var Complementary = function (_ColorHarmony) {
  inherits(Complementary, _ColorHarmony);

  function Complementary() {
    classCallCheck(this, Complementary);
    return possibleConstructorReturn(this, (Complementary.__proto__ || Object.getPrototypeOf(Complementary)).apply(this, arguments));
  }

  createClass(Complementary, [{
    key: "steps",
    value: function steps() {
      return 1;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 180;
    }
  }, {
    key: "name",
    get: function get() {
      return "Complement";
    }
  }]);
  return Complementary;
}(ColorHarmony);

var Triadic = function (_ColorHarmony2) {
  inherits(Triadic, _ColorHarmony2);

  function Triadic() {
    classCallCheck(this, Triadic);
    return possibleConstructorReturn(this, (Triadic.__proto__ || Object.getPrototypeOf(Triadic)).apply(this, arguments));
  }

  createClass(Triadic, [{
    key: "steps",
    value: function steps() {
      return 2;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 120;
    }
  }, {
    key: "name",
    get: function get() {
      return "Triadic";
    }
  }]);
  return Triadic;
}(ColorHarmony);

var Tetradic = function (_ColorHarmony3) {
  inherits(Tetradic, _ColorHarmony3);

  function Tetradic() {
    classCallCheck(this, Tetradic);
    return possibleConstructorReturn(this, (Tetradic.__proto__ || Object.getPrototypeOf(Tetradic)).apply(this, arguments));
  }

  createClass(Tetradic, [{
    key: "offsets",
    value: function offsets() {
      return [0, 60, 180, 240];
    }
  }, {
    key: "name",
    get: function get() {
      return "Tetradic";
    }
  }]);
  return Tetradic;
}(ColorHarmony);

var Quadratic = function (_ColorHarmony4) {
  inherits(Quadratic, _ColorHarmony4);

  function Quadratic() {
    classCallCheck(this, Quadratic);
    return possibleConstructorReturn(this, (Quadratic.__proto__ || Object.getPrototypeOf(Quadratic)).apply(this, arguments));
  }

  createClass(Quadratic, [{
    key: "steps",
    value: function steps() {
      return 3;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 90;
    }
  }, {
    key: "name",
    get: function get() {
      return "Quadratic";
    }
  }]);
  return Quadratic;
}(ColorHarmony);

var Analogous = function (_ColorHarmony5) {
  inherits(Analogous, _ColorHarmony5);

  function Analogous() {
    classCallCheck(this, Analogous);
    return possibleConstructorReturn(this, (Analogous.__proto__ || Object.getPrototypeOf(Analogous)).apply(this, arguments));
  }

  createClass(Analogous, [{
    key: "steps",
    value: function steps() {
      return 5;
    }
  }, {
    key: "offsets",
    value: function offsets() {
      return [-60, -30, 0, 30, 60];
    }
  }, {
    key: "name",
    get: function get() {
      return "Analogous";
    }
  }]);
  return Analogous;
}(ColorHarmony);

var Neutral = function (_ColorHarmony6) {
  inherits(Neutral, _ColorHarmony6);

  function Neutral() {
    classCallCheck(this, Neutral);
    return possibleConstructorReturn(this, (Neutral.__proto__ || Object.getPrototypeOf(Neutral)).apply(this, arguments));
  }

  createClass(Neutral, [{
    key: "offsets",
    value: function offsets() {
      return [-30, -15, 0, 15, 30];
    }
  }, {
    key: "name",
    get: function get() {
      return "Neutral";
    }
  }]);
  return Neutral;
}(ColorHarmony);

var Color = function () {
  createClass(Color, [{
    key: "isColor",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance side
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    get: function get() {
      return true;
    }
  }], [{
    key: "random",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // class side
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    value: function random(min, max) {
      if (min === undefined) min = 0;
      if (max === undefined) max = 255;
      return Color.rgb(lively_lang.num.random(min, max), lively_lang.num.random(min, max), lively_lang.num.random(min, max));
    }
  }, {
    key: "hsb",
    value: function hsb(hue, sat, brt) {
      var s = sat,
          b = brt;
      // zero saturation yields gray with the given brightness
      if (sat == 0) return new Color(b, b, b);
      var h = hue % 360,
          h60 = h / 60,
          i = Math.floor(h60),
          // integer part of hue
      f = h60 - i,
          // fractional part of hue
      p = (1.0 - s) * b,
          q = (1.0 - s * f) * b,
          t = (1.0 - s * (1.0 - f)) * b;

      switch (i) {
        case 0:
          return new Color(b, t, p);
        case 1:
          return new Color(q, b, p);
        case 2:
          return new Color(p, b, t);
        case 3:
          return new Color(p, q, b);
        case 4:
          return new Color(t, p, b);
        case 5:
          return new Color(b, p, q);
        default:
          return new Color(0, 0, 0);
      }
    }
  }, {
    key: "wheel",
    value: function wheel() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      return Color.wheelHsb(n, 0.0, 0.9, 0.7);
    }
  }, {
    key: "wheelHsb",
    value: function wheelHsb(n, hue, sat, brt) {
      // Return an array of n colors of varying hue
      var a = new Array(n),
          step = 360.0 / Math.max(n, 1);
      for (var i = 0; i < n; i++) {
        a[i] = Color.hsb(hue + i * step, sat, brt);
      }
      return a;
    }
  }, {
    key: "rgb",
    value: function rgb(r, g, b) {
      return new Color(r / 255, g / 255, b / 255);
    }
  }, {
    key: "rgbHex",
    value: function rgbHex(colorHexString) {
      var colorData = this.parseHex(colorHexString);
      if (colorData && colorData[0] >= 0 && colorData[1] >= 0 && colorData[2] >= 0) {
        return new Color(colorData[0], colorData[1], colorData[2]);
      } else {
        return null;
      }
    }
  }, {
    key: "rgba",
    value: function rgba(r, g, b, a) {
      return new Color(r / 255, g / 255, b / 255, a);
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(spec) {
      return new Color(spec.r, spec.g, spec.b, spec.a);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return new Color(tuple[0], tuple[1], tuple[2], tuple[3]);
    }
  }, {
    key: "fromTuple8Bit",
    value: function fromTuple8Bit(tuple) {
      return new Color(tuple[0] / 255, tuple[1] / 255, tuple[2] / 255, tuple[3] / 255);
    }
  }, {
    key: "fromString",
    value: function fromString(str) {
      if (!str || str === 'none') {
        return null;
      } else {
        return this.fromTuple(this.parse(str));
      }
    }
  }, {
    key: "parse",
    value: function parse(str) {
      var color;
      if (!str || str === 'none') {
        return null;
      } else {
        color = parse$1(str);
        return [color.red, color.green, color.blue, color.alpha];
      }
    }
  }, {
    key: "parseRGB",
    value: function parseRGB(str) {
      // match string of the form rgb([r],[g],[b]) or rgb([r%],[g%],[b%]),
      // allowing whitespace between all components
      var match = str.match(this.rgbaRegex);
      if (match) {
        var r = parseInt(match[1]) / (match[2] ? 100 : 255);
        var g = parseInt(match[3]) / (match[4] ? 100 : 255);
        var b = parseInt(match[5]) / (match[6] ? 100 : 255);
        var a = match[7] ? parseFloat(match[7]) : 1.0;
        return [r, g, b, a];
      }
      return null;
    }
  }, {
    key: "parseHex",
    value: function parseHex(colStr) {
      var rHex,
          gHex,
          bHex,
          str = '';
      for (var i = 0; i < colStr.length; i++) {
        var c = colStr[i].toLowerCase();
        if (c == 'a' || c == 'b' || c == 'c' || c == 'd' || c == 'e' || c == 'f' || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9') {
          str += c;
        }
      }
      if (str.length == 6) {
        rHex = str.substring(0, 2);
        gHex = str.substring(2, 4);
        bHex = str.substring(4, 6);
      } else if (str.length == 3) {
        // short form like #C00
        rHex = str.substring(0, 1);
        rHex += rHex;
        gHex = str.substring(1, 2);
        gHex += gHex;
        bHex = str.substring(2, 3);
        bHex += bHex;
      } else {
        return null;
      }
      var r = parseInt(rHex, 16) / 255,
          g = parseInt(gHex, 16) / 255,
          b = parseInt(bHex, 16) / 255;
      return [r, g, b];
    }
  }, {
    key: "rgbaRegex",
    get: function get() {
      return rgbaRegex;
    }
  }, {
    key: "named",
    get: function get() {
      if (this._named) return this._named;
      return this._named = {
        black: new Color(0, 0, 0),
        almostBlack: Color.rgb(64, 64, 64),
        white: new Color(1, 1, 1),
        gray: new Color(0.8, 0.8, 0.8),
        red: new Color(0.8, 0, 0),
        green: new Color(0, 0.8, 0),
        yellow: new Color(0.8, 0.8, 0),
        blue: new Color(0, 0, 0.8),
        purple: new Color(1, 0, 1),
        magenta: new Color(1, 0, 1),
        pink: Color.rgb(255, 30, 153),
        turquoise: Color.rgb(0, 240, 255),
        tangerine: Color.rgb(242, 133, 0),
        orange: Color.rgb(255, 153, 0),
        cyan: Color.rgb(0, 255, 255),
        brown: Color.rgb(182, 67, 0),
        limeGreen: Color.rgb(51, 255, 0),
        darkGray: Color.rgb(102, 102, 102),
        lightGray: Color.rgb(230, 230, 230),
        veryLightGray: Color.rgb(243, 243, 243),
        transparent: Color.rgba(0, 0, 0, 0)
      };
    }
  }]);

  function Color(r, g, b, a) {
    classCallCheck(this, Color);

    this.r = r || 0;
    this.g = g || 0;
    this.b = b || 0;
    this.a = a || (a === 0 ? 0 : 1);
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // accessing
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  createClass(Color, [{
    key: "grayValue",
    value: function grayValue() {
      return (this.r + this.g + this.b) / 3;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(other) {
      if (!other) return false;
      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "darker",
    value: function darker(recursion) {
      var result = this.mixedWith(Color.black, 0.5);
      return recursion > 1 ? result.darker(recursion - 1) : result;
    }
  }, {
    key: "lighter",
    value: function lighter(recursion) {
      if (recursion == 0) return this;
      var result = this.mixedWith(Color.white, 0.5);
      return recursion > 1 ? result.lighter(recursion - 1) : result;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // printing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return this.a === 1 ? "rgb(" + floor(this.r) + "," + floor(this.g) + "," + floor(this.b) + ")" : this.toRGBAString();
    }
  }, {
    key: "toRGBAString",
    value: function toRGBAString() {
      function floor(x) {
        return Math.floor(x * 255.99);
      }
      return "rgba(" + floor(this.r) + "," + floor(this.g) + "," + floor(this.b) + "," + this.a + ")";
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      function floor(x) {
        return Math.floor(x * 255.99);
      }
      function addLeadingZero(string$$1) {
        var s = string$$1;
        while (s.length < 2) {
          s = '0' + s;
        }
        return s;
      }
      return addLeadingZero(floor(this.r).toString(16)) + addLeadingZero(floor(this.g).toString(16)) + addLeadingZero(floor(this.b).toString(16));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.r, this.g, this.b, this.a];
    }
  }, {
    key: "toTuple8Bit",
    value: function toTuple8Bit() {
      return [this.r * 255, this.g * 255, this.b * 255, this.a * 255];
    }
  }, {
    key: "toHSB",
    value: function toHSB() {
      var max = Math.max(this.r, this.g, this.b),
          min = Math.min(this.r, this.g, this.b),
          h,
          s,
          b = max;
      if (max == min) {
        h = 0;
      } else if (max == this.r) {
        h = 60 * (0 + (this.g - this.b) / (max - min));
      } else if (max == this.g) {
        h = 60 * (2 + (this.b - this.r) / (max - min));
      } else if (max == this.b) {
        h = 60 * (4 + (this.r - this.g) / (max - min));
      }
      h = (h + 360) % 360;
      s = max == 0 ? 0 : (max - min) / max;
      return [h, s, b];
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "withA",
    value: function withA(a) {
      return new Color(this.r, this.g, this.b, a);
    }
  }, {
    key: "mixedWith",
    value: function mixedWith(other, proportion) {
      // Mix with another color -- 1.0 is all this, 0.0 is all other
      var p = proportion,
          q = 1.0 - p;
      return new Color(this.r * p + other.r * q, this.g * p + other.g * q, this.b * p + other.b * q, this.a * p + other.a * q);
    }

    // FIXME: invert sounds like mutation, versus createInverse or similar

  }, {
    key: "invert",
    value: function invert() {
      return Color.rgb(255 * (1 - this.r), 255 * (1 - this.g), 255 * (1 - this.b));
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      return this.toRGBAString();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "Color." + this.toString(),
        bindings: { "lively.graphics/color.js": ["Color"] }
      };
    }
  }, {
    key: "toJSExpr",
    value: function toJSExpr() {
      return "Color." + (this.name || this.toString());
    }
  }, {
    key: "name",
    get: function get() {
      var _this8 = this;

      var named = Color.named;
      return Object.keys(named).find(function (ea) {
        return named[ea].equals(_this8);
      });
    }
  }]);
  return Color;
}();

Object.assign(Color, Color.named);

var Gradient = function () {
  createClass(Gradient, null, [{
    key: "create",
    value: function create(offsetAndColors) {
      /*
       Create a linear gradient by specifying only the
       stops in a less cumbersome fashion:
         LinearGradient.create({"0": Color.red, ".5": Color.green, ...)
      */
      var parsedStops = [];
      for (var offset in offsetAndColors) {
        parsedStops.push({ offset: Number(offset), color: offsetAndColors[offset] });
      }
      return new this({ stops: parsedStops });
    }
  }]);

  function Gradient(stops) {
    classCallCheck(this, Gradient);

    this.stops = stops.map(function (s) {
      return s;
    }) || [];
  }

  createClass(Gradient, [{
    key: "equals",
    value: function equals(other) {
      if (other && other.isGradient) {
        return this.toString() == other.toString();
      }
      return false;
    }
  }, {
    key: "getStopsLighter",
    value: function getStopsLighter(n) {
      return lively_lang.arr.collect(this.stops, function (ea) {
        return { offset: ea.offset, color: ea.color.lighter(n) };
      });
    }
  }, {
    key: "getStopsDarker",
    value: function getStopsDarker(n) {
      return lively_lang.arr.collect(this.stops, function (ea) {
        return { offset: ea.offset, color: ea.color.darker(n) };
      });
    }
  }, {
    key: "isGradient",
    get: function get() {
      return true;
    }
  }]);
  return Gradient;
}();

var LinearGradient = function (_Gradient) {
  inherits(LinearGradient, _Gradient);

  function LinearGradient(_ref2) {
    var stops = _ref2.stops,
        vector = _ref2.vector;
    classCallCheck(this, LinearGradient);

    var _this9 = possibleConstructorReturn(this, (LinearGradient.__proto__ || Object.getPrototypeOf(LinearGradient)).call(this, stops));

    _this9.vector = vector;
    return _this9;
  }

  createClass(LinearGradient, [{
    key: "angleToRect",
    value: function angleToRect(rad) {
      return Point.polar(1, rad).extentAsRectangle().withCenter(pt(.5, .5));
    }
  }, {
    key: "vectorAsAngle",
    value: function vectorAsAngle() {
      return this.vector.extent().theta();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toCSSString();
    }
  }, {
    key: "lighter",
    value: function lighter(n) {
      return new this.constructor({ stops: this.getStopsLighter(n), vector: this.vector });
    }
  }, {
    key: "darker",
    value: function darker() {
      return new this.constructor({ stops: this.getStopsDarker(), vector: this.vector });
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      // default webkit way of defining gradients
      var deg = lively_lang.num.toDegrees(this.vectorAsAngle()) + 90,
          str = "linear-gradient(" + (deg + "deg,");
      str += this.stops.map(function (s) {
        return s.color.toRGBAString() + " " + ((s.offset * 100).toFixed() + "%");
      }).join(',');
      str += ')';
      return str;
    }
  }, {
    key: "toJSExpr",
    value: function toJSExpr() {
      return "new LinearGradient({stops:, vector})";
    }
  }, {
    key: "type",
    get: function get() {
      return "linearGradient";
    }
  }, {
    key: "vectors",
    get: function get() {
      return {
        northsouth: rect(pt(0, 0), pt(0, 1)),
        northeast: rect(pt(1, 0), pt(0, 1)),
        westeast: rect(pt(1, 0), pt(0, 0)),
        southeast: rect(pt(1, 1), pt(0, 0)),
        southnorth: rect(pt(0, 1), pt(0, 0)),
        southwest: rect(pt(0, 1), pt(1, 0)), // Down and to the left
        eastwest: rect(pt(0, 0), pt(1, 0)),

        northwest: rect(pt(0, 0), pt(1, 1))
      };
    }
  }, {
    key: "vector",
    get: function get() {
      return this._vector;
    },
    set: function set(value) {
      if (!value) this._vector = this.vectors.northsouth;else if (typeof value === "string") this._vector = this.vectors[value.toLowerCase()];else if (typeof value === "number") this._vector = this.angleToRect(value); //radians
      else this._vector = value;
    }
  }]);
  return LinearGradient;
}(Gradient);

var RadialGradient = function (_Gradient2) {
  inherits(RadialGradient, _Gradient2);

  function RadialGradient(_ref3) {
    var stops = _ref3.stops,
        focus = _ref3.focus,
        bounds = _ref3.bounds;
    classCallCheck(this, RadialGradient);

    var _this10 = possibleConstructorReturn(this, (RadialGradient.__proto__ || Object.getPrototypeOf(RadialGradient)).call(this, stops));

    _this10.focus = focus || pt(0.5, 0.5);
    _this10.bounds = bounds || new Rectangle(0, 0, 20, 20);
    return _this10;
  }

  createClass(RadialGradient, [{
    key: "toString",
    value: function toString() {
      return this.toCSSString();
    }
  }, {
    key: "lighter",
    value: function lighter(n) {
      return new this.constructor({ stops: this.getStopsLighter(n), focus: this.focus, bounds: this.bounds });
    }
  }, {
    key: "darker",
    value: function darker() {
      return new this.constructor({ stops: this.getStopsDarker(), focus: this.focus, bounds: this.bounds });
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      var innerCircle = this.focus.scaleBy(100.0),
          ext = this.bounds.extent();
      var str = "radial-gradient(" + ext.x / 2 + "px " + ext.y / 2 + "px at " + innerCircle.x + "% " + innerCircle.y + "%";
      for (var i = 0; i < this.stops.length; i++) {
        str += "," + this.stops[i].color.toRGBAString() + " " + ((this.stops[i].offset * 100).toFixed() + "%");
      }str += ')';
      return str;
    }
  }, {
    key: "type",
    get: function get() {
      return "radialGradient";
    }
  }]);
  return RadialGradient;
}(Gradient);

/*
   Flat design or flat UI colors are quite popular in web design today
   where bold, bright colors are used to create clean, simple interfaces.
*/

var flatDesignColors = ["#1abc9c", "#e8f8f5", "#d1f2eb", "#a3e4d7", "#76d7c4", "#48c9b0", "#1abc9c", "#17a589", "#148f77", "#117864", "#0e6251", "#16a085", "#e8f6f3", "#d0ece7", "#a2d9ce", "#73c6b6", "#45b39d", "#16a085", "#138d75", "#117a65", "#0e6655", "#0b5345", "#2ecc71", "#eafaf1", "#d5f5e3", "#abebc6", "#82e0aa", "#58d68d", "#2ecc71", "#28b463", "#239b56", "#1d8348", "#186a3b", "#27ae60", "#e9f7ef", "#d4efdf", "#a9dfbf", "#7dcea0", "#52be80", "#27ae60", "#229954", "#1e8449", "#196f3d", "#145a32", "#3498db", "#ebf5fb", "#d6eaf8", "#aed6f1", "#85c1e9", "#5dade2", "#3498db", "#2e86c1", "#2874a6", "#21618c", "#1b4f72", "#2980b9", "#eaf2f8", "#d4e6f1", "#a9cce3", "#7fb3d5", "#5499c7", "#2980b9", "#2471a3", "#1f618d", "#1a5276", "#154360", "#9b59b6", "#f5eef8", "#ebdef0", "#d7bde2", "#c39bd3", "#af7ac5", "#9b59b6", "#884ea0", "#76448a", "#633974", "#512e5f", "#8e44ad", "#f4ecf7", "#e8daef", "#d2b4de", "#bb8fce", "#a569bd", "#8e44ad", "#7d3c98", "#6c3483", "#5b2c6f", "#4a235a", "#34495e", "#ebedef", "#d6dbdf", "#aeb6bf", "#85929e", "#5d6d7e", "#34495e", "#2e4053", "#283747", "#212f3c", "#1b2631", "#2c3e50", "#eaecee", "#d5d8dc", "#abb2b9", "#808b96", "#566573", "#2c3e50", "#273746", "#212f3d", "#1c2833", "#17202a", "#f1c40f", "#fef9e7", "#fcf3cf", "#f9e79f", "#f7dc6f", "#f4d03f", "#f1c40f", "#d4ac0d", "#b7950b", "#9a7d0a", "#7d6608", "#f39c12", "#fef5e7", "#fdebd0", "#fad7a0", "#f8c471", "#f5b041", "#f39c12", "#d68910", "#b9770e", "#9c640c", "#7e5109", "#e67e22", "#fdf2e9", "#fae5d3", "#f5cba7", "#f0b27a", "#eb984e", "#e67e22", "#ca6f1e", "#af601a", "#935116", "#784212", "#d35400", "#fbeee6", "#f6ddcc", "#edbb99", "#e59866", "#dc7633", "#d35400", "#ba4a00", "#a04000", "#873600", "#6e2c00", "#e74c3c", "#fdedec", "#fadbd8", "#f5b7b1", "#f1948a", "#ec7063", "#e74c3c", "#cb4335", "#b03a2e", "#943126", "#78281f", "#c0392b", "#f9ebea", "#f2d7d5", "#e6b0aa", "#d98880", "#cd6155", "#c0392b", "#a93226", "#922b21", "#7b241c", "#641e16", "#ecf0f1", "#fdfefe", "#fbfcfc", "#f7f9f9", "#f4f6f7", "#f0f3f4", "#ecf0f1", "#d0d3d4", "#b3b6b7", "#979a9a", "#7b7d7d", "#bdc3c7", "#f8f9f9", "#f2f3f4", "#e5e7e9", "#d7dbdd", "#cacfd2", "#bdc3c7", "#a6acaf", "#909497", "#797d7f", "#626567", "#95a5a6", "#f4f6f6", "#eaeded", "#d5dbdb", "#bfc9ca", "#aab7b8", "#95a5a6", "#839192", "#717d7e", "#5f6a6a", "#4d5656", "#7f8c8d", "#f2f4f4", "#e5e8e8", "#ccd1d1", "#b2babb", "#99a3a4", "#7f8c8d", "#707b7c", "#616a6b", "#515a5a", "#424949"];

/*
  Material design is a visual language and design system developed
  by Google with an almost flat style and vibrant color schemes.
*/

var materialDesignColors = ["#f44336", "#ffebee", "#ffcdd2", "#ef9a9a", "#e57373", "#ef5350", "#f44336", "#e53935", "#d32f2f", "#c62828", "#b71c1c", "#ff8a80", "#ff5252", "#ff1744", "#d50000", "#e91e63", "#fce4ec", "#f8bbd0", "#f48fb1", "#f06292", "#ec407a", "#e91e63", "#d81b60", "#c2185b", "#ad1457", "#880e4f", "#ff80ab", "#ff4081", "#f50057", "#c51162", "#9c27b0", "#f3e5f5", "#e1bee7", "#ce93d8", "#ba68c8", "#ab47bc", "#9c27b0", "#8e24aa", "#7b1fa2", "#6a1b9a", "#4a148c", "#ea80fc", "#e040fb", "#d500f9", "#aa00ff", "#673ab7", "#ede7f6", "#d1c4e9", "#b39ddb", "#9575cd", "#7e57c2", "#673ab7", "#5e35b1", "#512da8", "#4527a0", "#311b92", "#b388ff", "#7c4dff", "#651fff", "#6200ea", "#3f51b5", "#e8eaf6", "#c5cae9", "#9fa8da", "#7986cb", "#5c6bc0", "#3f51b5", "#3949ab", "#303f9f", "#283593", "#1a237e", "#8c9eff", "#536dfe", "#3d5afe", "#304ffe", "#2196f3", "#e3f2fd", "#bbdefb", "#90caf9", "#64b5f6", "#42a5f5", "#2196f3", "#1e88e5", "#1976d2", "#1565c0", "#0d47a1", "#82b1ff", "#448aff", "#2979ff", "#2962ff", "#03a9f4", "#e1f5fe", "#b3e5fc", "#81d4fa", "#4fc3f7", "#29b6f6", "#03a9f4", "#039be5", "#0288d1", "#0277bd", "#01579b", "#80d8ff", "#40c4ff", "#00b0ff", "#0091ea", "#00bcd4", "#e0f7fa", "#b2ebf2", "#80deea", "#4dd0e1", "#26c6da", "#00bcd4", "#00acc1", "#0097a7", "#00838f", "#006064", "#84ffff", "#18ffff", "#00e5ff", "#00b8d4", "#009688", "#e0f2f1", "#b2dfdb", "#80cbc4", "#4db6ac", "#26a69a", "#009688", "#00897b", "#00796b", "#00695c", "#004d40", "#a7ffeb", "#64ffda", "#1de9b6", "#00bfa5", "#4caf50", "#e8f5e9", "#c8e6c9", "#a5d6a7", "#81c784", "#66bb6a", "#4caf50", "#43a047", "#388e3c", "#2e7d32", "#1b5e20", "#b9f6ca", "#69f0ae", "#00e676", "#00c853", "#8bc34a", "#f1f8e9", "#dcedc8", "#c5e1a5", "#aed581", "#9ccc65", "#8bc34a", "#7cb342", "#689f38", "#558b2f", "#33691e", "#ccff90", "#b2ff59", "#76ff03", "#64dd17", "#cddc39", "#f9fbe7", "#f0f4c3", "#e6ee9c", "#dce775", "#d4e157", "#cddc39", "#c0ca33", "#afb42b", "#9e9d24", "#827717", "#f4ff81", "#eeff41", "#c6ff00", "#aeea00", "#ffeb3b", "#fffde7", "#fff9c4", "#fff59d", "#fff176", "#ffee58", "#ffeb3b", "#fdd835", "#fbc02d", "#f9a825", "#f57f17", "#ffff8d", "#ffff00", "#ffea00", "#ffd600", "#ffc107", "#fff8e1", "#ffecb3", "#ffe082", "#ffd54f", "#ffca28", "#ffc107", "#ffb300", "#ffa000", "#ff8f00", "#ff6f00", "#ffe57f", "#ffd740", "#ffc400", "#ffab00", "#ff9800", "#fff3e0", "#ffe0b2", "#ffcc80", "#ffb74d", "#ffa726", "#ff9800", "#fb8c00", "#f57c00", "#ef6c00", "#e65100", "#ffd180", "#ffab40", "#ff9100", "#ff6d00", "#ff5722", "#fbe9e7", "#ffccbc", "#ffab91", "#ff8a65", "#ff7043", "#ff5722", "#f4511e", "#e64a19", "#d84315", "#bf360c", "#ff9e80", "#ff6e40", "#ff3d00", "#dd2c00", "#795548", "#efebe9", "#d7ccc8", "#bcaaa4", "#a1887f", "#8d6e63", "#795548", "#6d4c41", "#5d4037", "#4e342e", "#3e2723", "#9e9e9e", "#fafafa", "#f5f5f5", "#eeeeee", "#e0e0e0", "#bdbdbd", "#9e9e9e", "#757575", "#616161", "#424242", "#212121", "#607d8b", "#eceff1", "#cfd8dc", "#b0bec5", "#90a4ae", "#78909c", "#607d8b", "#546e7a", "#455a64", "#37474f", "#263238", "#ffffff", "#000000"];

var webSafeColors = ["ccff00", "ccff33", "ccff66", "ccff99", "ccffcc", "ccffff", "ffffff", "ffffcc", "ffff99", "ffff66", "ffff33", "ffff00", "cccc00", "cccc33", "cccc66", "cccc99", "cccccc", "ccccff", "ffccff", "ffcccc", "ffcc99", "ffcc66", "ffcc33", "ffcc00", "cc9900", "cc9933", "cc9966", "cc9999", "cc99cc", "cc99ff", "ff99ff", "ff99cc", "ff9999", "ff9966", "ff9933", "ff9900", "cc6600", "cc6633", "cc6666", "cc6699", "cc66cc", "cc66ff", "ff66ff", "ff66cc", "ff6699", "ff6666", "ff6633", "ff6600", "cc3300", "cc3333", "cc3366", "cc3399", "cc33cc", "cc33ff", "ff33ff", "ff33cc", "ff3399", "ff3366", "ff3333", "ff3300", "cc0000", "cc0033", "cc0066", "cc0099", "cc00cc", "cc00ff", "ff00ff", "ff00cc", "ff0099", "ff0066", "ff0033", "ff0000", "660000", "660033", "660066", "660099", "6600cc", "6600ff", "9900ff", "9900cc", "990099", "990066", "990033", "990000", "663300", "663333", "663366", "663399", "6633cc", "6633ff", "9933ff", "9933cc", "993399", "993366", "993333", "993300", "666600", "666633", "666666", "666699", "6666cc", "6666ff", "9966ff", "9966cc", "996699", "996666", "996633", "996600", "669900", "669933", "669966", "669999", "6699cc", "6699ff", "9999ff", "9999cc", "999999", "999966", "999933", "999900", "66cc00", "66cc33", "66cc66", "66cc99", "66cccc", "66ccff", "99ccff", "99cccc", "99cc99", "99cc66", "99cc33", "99cc00", "66ff00", "66ff33", "66ff66", "66ff99", "66ffcc", "66ffff", "99ffff", "99ffcc", "99ff99", "99ff66", "99ff33", "99ff00", "00ff00", "00ff33", "00ff66", "00ff99", "00ffcc", "00ffff", "33ffff", "33ffcc", "33ff99", "33ff66", "33ff33", "33ff00", "00cc00", "00cc33", "00cc66", "00cc99", "00cccc", "00ccff", "33ccff", "33cccc", "33cc99", "33cc66", "33cc33", "33cc00", "009900", "009933", "009966", "009999", "0099cc", "0099ff", "3399ff", "3399cc", "339999", "339966", "339933", "339900", "006600", "006633", "006666", "006699", "0066cc", "0066ff", "3366ff", "3366cc", "336699", "336666", "336633", "336600", "003300", "003333", "003366", "003399", "0033cc", "0033ff", "3333ff", "3333cc", "333399", "333366", "333333", "333300", "000000", "000033", "000066", "000099", "0000cc", "0000ff", "3300ff", "3300cc", "330099", "330066", "330033", "330000"];

exports.Complementary = Complementary;
exports.Triadic = Triadic;
exports.Tetradic = Tetradic;
exports.Quadratic = Quadratic;
exports.Analogous = Analogous;
exports.Neutral = Neutral;
exports.Color = Color;
exports.LinearGradient = LinearGradient;
exports.RadialGradient = RadialGradient;
exports.flatDesignColors = flatDesignColors;
exports.materialDesignColors = materialDesignColors;
exports.webSafeColors = webSafeColors;
exports.Point = Point;
exports.Rectangle = Rectangle;
exports.Transform = Transform;
exports.Line = Line;
exports.rect = rect;
exports.pt = pt;

}((this.lively.graphics = this.lively.graphics || {}),lively.lang));

  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.graphics;
})();
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var AttributeConnection = function () {
  function AttributeConnection(source, sourceProp, target, targetProp, spec) {
    classCallCheck(this, AttributeConnection);

    this.init(source, sourceProp, target, targetProp, spec);
  }

  createClass(AttributeConnection, [{
    key: 'init',
    value: function init(source, sourceProp, target, targetProp, spec) {
      this.doNotSerialize = ['isActive', 'converter', 'updater'];
      this.sourceObj = source;
      this.sourceAttrName = sourceProp;
      this.targetObj = target;
      this.targetMethodName = targetProp;
      this.varMapping = { source: source, target: target };

      spec = _extends({
        removeAfterUpdate: false,
        forceAttributeConnection: false,
        garbageCollect: true,
        signalOnAssignment: true
      }, spec);

      if (spec.removeAfterUpdate) this.removeAfterUpdate = true;
      if (spec.forceAttributeConnection) this.forceAttributeConnection = true;
      if (typeof spec.garbageCollect === "boolean") this.garbageCollect = spec.garbageCollect;
      if (typeof spec.signalOnAssignment === "boolean") this.signalOnAssignment = spec.signalOnAssignment;

      // when converter function references objects from its environment
      // we can't serialize it. To fail as early as possible we will
      // serialize the converter / updater already in the setters
      if (spec.converter) this.setConverter(spec.converter);
      if (spec.updater) this.setUpdater(spec.updater);
      if (spec.varMapping) this.varMapping = Object.assign(spec.varMapping, this.varMapping);

      // ensure that spec is valid
      this.getSpec();

      return this;
    }
  }, {
    key: '__after_deserialize__',
    value: function __after_deserialize__(snapshot, objRef) {
      this.connect();
    }
  }, {
    key: 'onSourceAndTargetRestored',
    value: function onSourceAndTargetRestored() {
      if (this.sourceObj && this.targetObj) this.connect();
    }
  }, {
    key: 'copy',
    value: function copy(copier) {
      return AttributeConnection.fromLiteral(this.toLiteral(), copier);
    }
  }, {
    key: 'fixInstanceAfterCopyingFromSite',
    value: function fixInstanceAfterCopyingFromSite(name, ref, index) {
      // alert("removed connection: "  + this)
      this.disconnect();
    }
  }, {
    key: 'clone',
    value: function clone() {
      //rk 2012-10-09: What is the reason to have clone AND copy?!
      var con = new this.constructor(this.getSourceObj(), this.getSourceAttrName(), this.getTargetObj(), this.getTargetMethodName(), this.getSpec());
      if (this.dependedBy) con.dependedBy = this.dependedBy;
      return con;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing

  }, {
    key: 'getTargetObj',
    value: function getTargetObj() {
      return this.targetObj;
    }
  }, {
    key: 'getSourceObj',
    value: function getSourceObj() {
      return this.sourceObj;
    }
  }, {
    key: 'getSourceAttrName',
    value: function getSourceAttrName() {
      return this.sourceAttrName;
    }
  }, {
    key: 'getTargetMethodName',
    value: function getTargetMethodName() {
      return this.targetMethodName;
    }
  }, {
    key: 'getSourceValue',
    value: function getSourceValue() {
      return this.getSourceObj()[this.getSourceAttrName()];
    }
  }, {
    key: 'getPrivateSourceValue',
    value: function getPrivateSourceValue() {
      return this.sourceObj[this.privateAttrName(this.sourceAttrName)];
    }
  }, {
    key: 'getConverter',
    value: function getConverter() {
      if (!this.converterString) return null;
      if (!this.converter) this.converter = lively_lang.Closure.fromSource(this.converterString, this.varMapping).recreateFunc();
      return this.converter;
    }
  }, {
    key: 'setConverter',
    value: function setConverter(funcOrSource) {
      delete this.converter;
      return this.converterString = funcOrSource ? String(funcOrSource) : null;
    }
  }, {
    key: 'getUpdater',
    value: function getUpdater() {
      if (!this.updaterString) return null;
      if (!this.updater) {
        this.updater = lively_lang.Closure.fromSource(this.updaterString, this.varMapping).recreateFunc();
      }
      return this.updater;
    }
  }, {
    key: 'setUpdater',
    value: function setUpdater(funcOrSource) {
      delete this.updater;
      return this.updaterString = funcOrSource ? String(funcOrSource) : null;
    }
  }, {
    key: 'getSpec',
    value: function getSpec() {
      var spec = {};
      if (this.updaterString) spec.updater = this.getUpdater();
      if (this.converterString) spec.converter = this.getConverter();
      if (this.removeAfterUpdate) spec.removeAfterUpdate = true;
      if (this.forceAttributeConnection) spec.forceAttributeConnection = true;
      if (this.hasOwnProperty("garbageCollect")) spec.garbageCollect = this.garbageCollect;
      if (this.hasOwnProperty("signalOnAssignment")) spec.signalOnAssignment = this.signalOnAssignment;
      return spec;
    }
  }, {
    key: 'resetSpec',
    value: function resetSpec() {
      delete this.garbageCollect;
      delete this.signalOnAssignment;
      delete this.removeAfterUpdate;
      delete this.forceAttributeConnection;
      delete this.converter;
      delete this.converterString;
      delete this.updater;
      delete this.updaterString;
    }
  }, {
    key: 'privateAttrName',
    value: function privateAttrName(attrName) {
      return '$$' + attrName;
    }
  }, {
    key: 'activate',
    value: function activate() {
      this.isActive = true;
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      delete this.isActive;
    }
  }, {
    key: 'connect',
    value: function connect() {
      var existing = this.getExistingConnection();
      if (existing !== this) {
        // when existing == null just add new connection when
        // existing === this then connect was called twice or we are in
        // deserialization. Just do nothing then.
        existing && existing.disconnect();
        this.addAttributeConnection();
      }

      // Check for existing getters that might be there and not belong to
      // lively.bindings We deal with them in addSourceObjGetterAndSetter()

      var sourceObj = this.sourceObj,
          sourceAttrName = this.sourceAttrName,
          forceAttributeConnection = this.forceAttributeConnection,
          existingSetter = sourceObj.__lookupSetter__(sourceAttrName),
          existingGetter = sourceObj.__lookupGetter__(sourceAttrName);

      // Check if a method is the source. We check both the value behind
      // sourceAttrName and $$sourceAttrName because when deserializing
      // scripts those get currently stored in $$sourceAttrName (for
      // non-scripts it doesn't matter since those methods should be in the
      // prototype chain)


      var methodOrValue = !existingSetter && !existingGetter && (this.getSourceValue() || this.getPrivateSourceValue());

      // method connect... FIXME refactori into own class!
      if (typeof methodOrValue === "function" && !forceAttributeConnection) {
        if (!methodOrValue.isWrapped) {
          this.addConnectionWrapper(sourceObj, sourceAttrName, methodOrValue);
        }
      } else {
        // attribute connect
        this.addSourceObjGetterAndSetter(existingGetter, existingSetter);
      }

      return this;
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      var _this = this;

      var sourceObj = this.sourceObj;

      if (!sourceObj || !sourceObj.attributeConnections) return this.removeSourceObjGetterAndSetter();

      sourceObj.attributeConnections = sourceObj.attributeConnections.filter(function (con) {
        return !_this.isSimilarConnection(con);
      });
      var connectionsWithSameSourceAttr = sourceObj.attributeConnections.filter(function (con) {
        return _this.getSourceAttrName() == con.getSourceAttrName();
      });
      if (sourceObj.attributeConnections.length == 0) delete sourceObj.attributeConnections;
      if (connectionsWithSameSourceAttr.length == 0) this.removeSourceObjGetterAndSetter();

      return null;
    }
  }, {
    key: 'update',
    value: function update(newValue, oldValue) {
      // This method is optimized for Safari and Chrome.
      // See tests.BindingTests.BindingsProfiler
      // The following requirements exists:
      // - Complete Customization of control (how often, if at all, binding
      //   should be activated, parameters passed, delay,... )
      // - run converter with oldValue and newValue
      // - when updater is existing run converter only if update is proceeded
      // - bind is slow
      // - arguments is slow when it's items are accessed or it's converted
      //   using arr.from. Note 2014-02-10: We currently need to modify the
      //   argument array for allowing conversion.

      if (this.isActive /*this.isRecursivelyActivated()*/) return null;

      var connection = this,
          updater = this.getUpdater(),
          converter = this.getConverter(),
          target = this.targetObj,
          propName = this.targetMethodName;

      if (!target || !propName) {
        var msg = 'Cannot update ' + this.toString(newValue) + ' because of no target (' + target + ') or targetProp (' + propName + ') ';
        if (this.isWeakConnection) {
          this.disconnect();
        }
        console.error(msg);
        return null;
      }

      var targetMethod = target[propName],
          callOrSetTarget = function callOrSetTarget(arg1 /*newValue*/, arg2 /*oldValue*/, arg3, arg4, arg5, arg6) {
        // use a function and not a method to capture this in self and so
        // that no bind is necessary and oldValue is accessible. Note that
        // when updater calls this method arguments can be more than just
        // the new value
        var args = [arg1, arg2, arg3, arg4, arg5, arg6];
        if (converter) {
          newValue = converter.call(connection, arg1, arg2);
          arg1 = args[0] = newValue;
        }
        var result = typeof targetMethod === 'function' ? targetMethod.apply(target, args) : target[propName] = arg1;
        if (connection.removeAfterUpdate) connection.disconnect();
        return result;
      };

      try {
        this.isActive = true;
        return updater ? updater.call(this, callOrSetTarget, newValue, oldValue) : callOrSetTarget(newValue, oldValue);
      } catch (e) {
        var world = this.sourceObj && typeof this.sourceObj.world === "function" && this.sourceObj.world() || this.targetObj && typeof this.targetObj.world === "function" && this.targetObj.world();
        if (world) {
          world.logError(e, 'AttributeConnection>>update: ');
        } else {
          console.error('Error when trying to update ' + this + ' with value ' + newValue + ':\n' + e + '\n' + e.stack);
        }
      } finally {
        delete this.isActive;
      }

      return null;
    }
  }, {
    key: 'addSourceObjGetterAndSetter',
    value: function addSourceObjGetterAndSetter(existingGetter, existingSetter) {
      if (existingGetter && existingGetter.isAttributeConnectionGetter || existingSetter && existingSetter.isAttributeConnectionSetter) {
        return;
      }

      var sourceObj = this.sourceObj,
          sourceAttrName = this.sourceAttrName,
          newAttrName = this.privateAttrName(sourceAttrName);


      if (sourceObj[newAttrName]) {
        console.warn('newAttrName ' + newAttrName + ' already exists.' + 'Are there already other connections?');
      }

      // add new attr to the serialization ignore list
      if (!sourceObj.hasOwnProperty('doNotSerialize')) sourceObj.doNotSerialize = [];
      lively_lang.arr.pushIfNotIncluded(sourceObj.doNotSerialize, newAttrName);

      if (!sourceObj.hasOwnProperty('doNotCopyProperties')) sourceObj.doNotCopyProperties = [];
      lively_lang.arr.pushIfNotIncluded(sourceObj.doNotCopyProperties, newAttrName);

      if (existingGetter) sourceObj.__defineGetter__(newAttrName, existingGetter);
      if (existingSetter) sourceObj.__defineSetter__(newAttrName, existingSetter);

      // assign old value to new slot
      if (!existingGetter && !existingSetter && sourceObj.hasOwnProperty(sourceAttrName)) sourceObj[newAttrName] = sourceObj[sourceAttrName];

      sourceObj.__defineSetter__(sourceAttrName, function (newVal) {
        var oldVal = sourceObj[newAttrName];
        sourceObj[newAttrName] = newVal;
        if (sourceObj.attributeConnections === undefined) {
          console.error('Sth wrong with sourceObj, has no attributeConnections');
          return null;
        }
        sourceObj.attributeConnections.forEach(function (c) {
          if (c && c.getSourceAttrName() === sourceAttrName && c.signalOnAssignment) c.update(newVal, oldVal);
        });
        return newVal;
      });
      sourceObj.__lookupSetter__(sourceAttrName).isAttributeConnectionSetter = true;

      sourceObj.__defineGetter__(sourceAttrName, function () {
        return sourceObj[newAttrName];
      });
      sourceObj.__lookupGetter__(sourceAttrName).isAttributeConnectionGetter = true;
    }
  }, {
    key: 'addConnectionWrapper',
    value: function addConnectionWrapper(sourceObj, methodName, origMethod) {
      if (typeof origMethod !== "function") {
        throw new Error('addConnectionWrapper didnt get a method to wrap');
      }

      // save so that it can be restored
      if (sourceObj.hasOwnProperty(methodName)) sourceObj[this.privateAttrName(methodName)] = origMethod;
      sourceObj[methodName] = function connectionWrapper() {
        if (this.attributeConnections === undefined) throw new Error('[lively.bindings] Something is wrong with connection source object, it has no attributeConnections');
        var conns = this.attributeConnections.slice(),
            result = this[methodName].originalFunction.apply(this, arguments);
        for (var i = 0; i < conns.length; i++) {
          var c = conns[i];
          if (c.getSourceAttrName() === methodName) c.update(arguments[0]);
        }
        return result;
      };

      sourceObj[methodName].isWrapped = true;
      sourceObj[methodName].isConnectionWrapper = true;
      sourceObj[methodName].originalFunction = origMethod; // for getOriginal()
    }
  }, {
    key: 'removeSourceObjGetterAndSetter',
    value: function removeSourceObjGetterAndSetter() {
      // delete the getter and setter and the slot were the real value was stored
      // assign the real value to the old slot
      var realAttrName = this.sourceAttrName,
          helperAttrName = this.privateAttrName(realAttrName),
          srcObj = this.sourceObj;

      if (!srcObj) return;

      if (srcObj.__lookupGetter__(realAttrName)) {
        delete srcObj[realAttrName];
        if (srcObj.hasOwnProperty(helperAttrName)) {
          try {
            srcObj[realAttrName] = srcObj[helperAttrName];
          } catch (err) {}
          delete srcObj[helperAttrName];
        }
      } else if (srcObj[realAttrName] && srcObj[realAttrName].isConnectionWrapper) {
        srcObj[realAttrName] = srcObj[realAttrName].originalFunction;
      }

      if (srcObj.doNotSerialize && srcObj.doNotSerialize.includes(helperAttrName)) {
        srcObj.doNotSerialize = lively_lang.arr.without(srcObj.doNotSerialize, helperAttrName);
        if (srcObj.doNotSerialize.length == 0) delete srcObj.doNotSerialize;
      }

      if (srcObj.doNotCopyProperties && srcObj.doNotCopyProperties.includes(helperAttrName)) {
        srcObj.doNotCopyProperties = lively_lang.arr.without(srcObj.doNotCopyProperties, helperAttrName);
        if (srcObj.doNotCopyProperties.length == 0) delete srcObj.doNotCopyProperties;
      }
    }
  }, {
    key: 'addAttributeConnection',
    value: function addAttributeConnection() {
      if (!this.sourceObj.attributeConnections) this.sourceObj.attributeConnections = [];
      this.sourceObj.attributeConnections.push(this);
    }
  }, {
    key: 'getExistingConnection',
    value: function getExistingConnection() {
      var conns = this.sourceObj && this.sourceObj.attributeConnections;
      if (!conns) return null;
      for (var i = 0, len = conns.length; i < len; i++) {
        if (this.isSimilarConnection(conns[i])) return conns[i];
      }
      return null;
    }
  }, {
    key: 'isRecursivelyActivated',
    value: function isRecursivelyActivated() {
      // is this enough? Maybe use Stack?
      return this.isActive;
    }
  }, {
    key: 'isSimilarConnection',
    value: function isSimilarConnection(other) {
      if (!other || other.constructor != this.constructor) return false;
      return this.sourceObj == other.sourceObj && this.sourceAttrName == other.sourceAttrName && this.targetObj == other.targetObj && this.targetMethodName == other.targetMethodName;
    }
  }, {
    key: 'toString',
    value: function toString(optValue) {
      try {
        return lively_lang.string.format('AttributeConnection(%s.%s %s %s.%s)', this.getSourceObj(), this.getSourceAttrName(), optValue ? '-->' + String(optValue) + '-->' : '-->', this.getTargetObj(), this.getTargetMethodName());
      } catch (e) {
        return '<Error in AttributeConnection>>toString>';
      }
    }
  }]);
  return AttributeConnection;
}();

function connect(sourceObj, attrName, targetObj, targetMethodName, specOrConverter) {

  // 1: is it a function connection? targetMethodName => "call"
  if (typeof targetObj === "function" && (typeof targetMethodName === "undefined" || (typeof targetMethodName === 'undefined' ? 'undefined' : _typeof(targetMethodName)) === "object")) {
    specOrConverter = targetMethodName;
    targetMethodName = "call";
    // make function.call work, passing "null" as this
    if (!specOrConverter) specOrConverter = {};
    if (!specOrConverter.updater) specOrConverter.updater = function ($upd, val) {
      return $upd(null, val);
    };
  }

  // 2: determine what kind of connection to create. Default is
  //  AttributeConnection but source.connections/
  //  source.getConnectionPoints can specify different settings
  var connectionPoints = sourceObj.getConnectionPoints && sourceObj.getConnectionPoints() || sourceObj.connections,
      connectionPoint = connectionPoints && connectionPoints[attrName],
      klass = connectionPoint && connectionPoint.map && lively.morphic && lively.morphic.GeometryConnection || connectionPoint && connectionPoint.connectionClassType && lively.Class.forName(connectionPoint.connectionClassType) || AttributeConnection,
      spec;

  // 3: connection settings: converter/updater/...
  if (typeof specOrConverter === "function") {
    console.warn('Directly passing a converter function to connect() ' + 'is deprecated! Use spec object instead!');
    spec = { converter: specOrConverter };
  } else spec = specOrConverter;

  if (connectionPoint) spec = lively.lang.obj.merge(connectionPoint, spec);

  // 4: does a similar connection exist? Yes: update it with new specs,
  //  no: create new connection
  var connection = new klass(sourceObj, attrName, targetObj, targetMethodName, spec),
      existing = connection.getExistingConnection();
  if (existing) {
    existing.resetSpec();
    existing.init(sourceObj, attrName, targetObj, targetMethodName, spec);
    return existing;
  }

  var result = connection.connect();

  // 5: notify source object if it has a #onConnect method
  if (typeof sourceObj.onConnect === "function") sourceObj.onConnect(attrName, targetObj, targetMethodName);

  // 6: If wanted updated the connection right now
  if (connectionPoint && connectionPoint.updateOnConnect) connection.update(sourceObj[attrName]);
  return result;
}

function disconnect(sourceObj, attrName, targetObj, targetMethodName) {

  // is it a function connection? targetMethodName => "call"
  if (typeof targetObj === "function" && (typeof targetMethodName === "undefined" || (typeof targetMethodName === 'undefined' ? 'undefined' : _typeof(targetMethodName)) === "object")) {
    targetMethodName = "call";
  }

  if (!sourceObj.attributeConnections) return;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sourceObj.attributeConnections.slice()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var con = _step.value;

      if (con.getSourceAttrName() == attrName && con.getTargetObj() === targetObj && con.getTargetMethodName() == targetMethodName) con.disconnect();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (typeof sourceObj.onDisconnect == 'function') sourceObj.onDisconnect(attrName, targetObj, targetMethodName);
}

function disconnectAll(sourceObj) {
  var con = void 0;
  while (sourceObj.attributeConnections && (con = sourceObj.attributeConnections[0])) {
    con.disconnect();
  }
}

function once(sourceObj, attrName, targetObj, targetMethodName, spec) {
  // function connection:
  if (typeof targetObj === "function" && (typeof targetMethodName === "undefined" || (typeof targetMethodName === 'undefined' ? 'undefined' : _typeof(targetMethodName)) === "object")) {
    spec = targetMethodName;
    targetMethodName = "call";
    spec = spec || {};
    // make function.call work, passing "null" as this
    if (!spec) spec = {};
    if (!spec.updater) spec.updater = function ($upd, val) {
      return $upd(null, val);
    };
  } else spec = spec || {};
  spec = spec || {};
  spec.removeAfterUpdate = true;
  return connect(sourceObj, attrName, targetObj, targetMethodName, spec);
}

function signal(sourceObj, attrName, newVal) {
  var connections = sourceObj.attributeConnections;
  if (!connections) return;
  var oldVal = sourceObj[attrName];
  for (var i = 0, len = connections.length; i < len; i++) {
    var c = connections[i];
    if (c.getSourceAttrName() == attrName) c.update(newVal, oldVal);
  }
}

function callWhenNotNull(sourceObj, sourceProp, targetObj, targetSelector) {
  // ensure that sourceObj[sourceProp] is not null, then run targetObj[targetProp]()
  if (sourceObj[sourceProp] != null) {
    targetObj[targetSelector](sourceObj[sourceProp]);
  } else {
    connect(sourceObj, sourceProp, targetObj, targetSelector, { removeAfterUpdate: true });
  }
}

function callWhenPathNotNull(source, path, target, targetProp) {
  var helper = {
    key: path.pop(),
    whenDefined: function whenDefined(context) {
      callWhenNotNull(context, this.key, target, targetProp);
    }
  };

  while (path.length > 0) {
    helper = {
      key: path.pop(),
      next: helper,
      whenDefined: function whenDefined(context) {
        callWhenNotNull(context, this.key, this.next, 'whenDefined');
      }
    };
  }

  helper.whenDefined(source);
}

function noUpdate(noUpdateSpec, func) {
  var globalNoUpdate = false,
      result;
  if (!func && typeof noUpdateSpec === "function") {
    func = noUpdateSpec;globalNoUpdate = true;
  }
  if (globalNoUpdate) {
    // rather a hack for now
    var proto = AttributeConnection.prototype;
    if (!proto.isActive) proto.isActive = 0;
    proto.isActive++;
    try {
      result = func();
    } finally {
      proto.isActive--;
      if (proto.isActive <= 0) proto.isActive;
    }
  } else {
    var obj = noUpdateSpec.sourceObj,
        attr = noUpdateSpec.sourceAttribute,
        targetObj = noUpdateSpec.targetObj,
        targetAttr = noUpdateSpec.targetAttribute,
        filter = targetObj && targetAttr ? function (ea) {
      return ea.getSourceAttrName() === attr && targetObj === ea.getTargetObj() && targetAttr === ea.getTargetMethodName();
    } : function (ea) {
      return ea.getSourceAttrName() === attr;
    },
        conns = obj.attributeConnections && obj.attributeConnections.filter(filter);
    conns && lively_lang.arr.invoke(conns, 'activate');
    try {
      result = func();
    } finally {
      conns && lively_lang.arr.invoke(conns, 'deactivate');
    }
  }
  return result;
}

exports.connect = connect;
exports.disconnect = disconnect;
exports.disconnectAll = disconnectAll;
exports.once = once;
exports.signal = signal;
exports.noUpdate = noUpdate;
exports.AttributeConnection = AttributeConnection;
exports.callWhenNotNull = callWhenNotNull;
exports.callWhenPathNotNull = callWhenPathNotNull;

}((this.lively.bindings = this.lively.bindings || {}),lively.lang));

  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.bindings;
})();
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj$$1) {
  return typeof obj$$1;
} : function (obj$$1) {
  return obj$$1 && typeof Symbol === "function" && obj$$1.constructor === Symbol && obj$$1 !== Symbol.prototype ? "symbol" : typeof obj$$1;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr$$1, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr$$1[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr$$1, i) {
    if (Array.isArray(arr$$1)) {
      return arr$$1;
    } else if (Symbol.iterator in Object(arr$$1)) {
      return sliceIterator(arr$$1, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr$$1) {
  if (Array.isArray(arr$$1)) {
    for (var i = 0, arr2 = Array(arr$$1.length); i < arr$$1.length; i++) arr2[i] = arr$$1[i];

    return arr2;
  } else {
    return Array.from(arr$$1);
  }
};

/*global Map, System*/
// extensions to native JS objects to support serialization

// Symbol
Object.defineProperty(Symbol.prototype, "__serialize__", {
  configurable: true,
  value: function () {
    var knownSymbols = function () {
      return Object.getOwnPropertyNames(Symbol).filter(function (ea) {
        return _typeof(Symbol[ea]) === "symbol";
      }).reduce(function (map, ea) {
        return map.set(Symbol[ea], "Symbol." + ea);
      }, new Map());
    }(),
        symMatcher = /^Symbol\((.*)\)$/;

    return function () {
      // turns a symbol into a __expr__ object.
      var sym = typeof this[Symbol.toPrimitive] === "function" ? this[Symbol.toPrimitive]() : this,
          symKey = Symbol.keyFor(sym);
      if (symKey) return { __expr__: "Symbol.for(\"" + symKey + "\")" };
      if (knownSymbols.get(sym)) return { __expr__: knownSymbols.get(sym) };
      var match = String(sym).match(symMatcher);
      return { __expr__: match ? "Symbol(\"" + match[1] + "\")" : "Symbol()" };
    };
  }()
});

// System
Object.defineProperty(System, "__serialize__", {
  configurable: true,
  value: function value() {
    return { __expr__: "System" };
  }
});

// window/global
Object.defineProperty(System.global, "__serialize__", {
  configurable: true,
  value: function value() {
    return { __expr__: "System.global" };
  }
});

// Map
Object.defineProperty(Map.prototype, "__serialize__", {
  configurable: true,
  value: function value(pool, snapshots, path) {
    // ensure ObjectRef and snapshot object for map
    var ref = pool.add(this),
        rev = ref.currentRev,
        snapshot = ref.currentSnapshot,
        entries = snapshot.entries = [],
        i = 0;
    snapshots[ref.id] = snapshot;
    // store class info
    pool.classHelper.addClassInfo(ref, this, snapshot);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            key = _step$value[0],
            value = _step$value[1];

        i++;
        // serialize all entries into snapshot.entries
        var serializedKey = ref.snapshotProperty(ref.id, key, path.concat("key", String(i)), snapshots, pool),
            serializedValue = ref.snapshotProperty(ref.id, value, path.concat("value", String(i)), snapshots, pool);
        entries.push(serializedKey, serializedValue);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ref.asRefForSerializedObjMap(rev);
  }
});
Object.defineProperty(Map.prototype, "__deserialize__", {
  configurable: true,
  value: function value(snapshot, ref, serializedObjMap, pool, path) {
    // deserialize entries from snapshot.entries
    var entries = snapshot.entries;

    for (var i = 0; i < entries.length; i = i + 2) {
      var key = entries[i],
          value = entries[i + 1],
          deserializedKey = ref.recreateProperty("key." + i, key, serializedObjMap, pool, path.concat("key", i)),
          deserializedValue = ref.recreateProperty("value." + i, value, serializedObjMap, pool, path.concat("value", i));
      this.set(deserializedKey, deserializedValue);
    }
  }
});

// Set
Object.defineProperty(Set.prototype, "__serialize__", {
  configurable: true,
  value: function value(pool, snapshots, path) {
    // ensure ObjectRef and snapshot object for set
    var ref = pool.add(this),
        rev = ref.currentRev,
        snapshot = ref.currentSnapshot,
        entries = snapshot.entries = [],
        i = 0;
    snapshots[ref.id] = snapshot;
    // store class info
    pool.classHelper.addClassInfo(ref, this, snapshot);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = this[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var entry = _step2.value;

        i++;
        // serialize all entries into snapshot.entries
        var serializedEntry = ref.snapshotProperty(ref.id, entry, path.concat("entry", String(i)), snapshots, pool);
        entries.push(serializedEntry);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return ref.asRefForSerializedObjMap(rev);
  }
});
Object.defineProperty(Set.prototype, "__deserialize__", {
  configurable: true,
  value: function value(snapshot, ref, serializedObjMap, pool, path) {
    // deserialize entries from snapshot.entries
    var entries = snapshot.entries;

    for (var i = 0; i < entries.length; i++) {
      var deserializedEntry = ref.recreateProperty("entry." + i, entries[i], serializedObjMap, pool, path.concat("key", i));
      this.add(deserializedEntry);
    }
  }
});

function isPrimitive(obj$$1) {
  // primitive objects don't need to be registered
  if (obj$$1 == null) return true;
  var t = typeof obj$$1 === "undefined" ? "undefined" : _typeof(obj$$1);
  if ("boolean" === t || "number" === t || "string" === t) return true;
  return false;
}

/*global System*/
var classMetaForSerializationProp = "lively.serializer-class-info";
var moduleMetaInClassProp = Symbol.for("lively-module-meta");

var ClassHelper = function () {
  createClass(ClassHelper, [{
    key: "classNameProperty",
    get: function get() {
      return '__LivelyClassName__';
    }
  }, {
    key: "sourceModuleNameProperty",
    get: function get() {
      return '__SourceModuleName__';
    }
  }], [{
    key: "moduleMetaInClassProp",
    get: function get() {
      return moduleMetaInClassProp;
    }
  }, {
    key: "classMetaForSerializationProp",
    get: function get() {
      return classMetaForSerializationProp;
    }
  }]);

  function ClassHelper(options) {
    classCallCheck(this, ClassHelper);

    this.options = _extends({ ignoreClassNotFound: true }, options);
    this[Symbol.for('lively-instance-restorer')] = true; // for Class.intializer
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // class info persistence

  createClass(ClassHelper, [{
    key: "addClassInfo",
    value: function addClassInfo(objRef, realObj, snapshot) {

      // store class into persistentCopy if original is an instance
      if (!realObj || !realObj.constructor) return;

      var className = realObj.constructor.name;

      if (!className) {
        console.warn("Cannot serialize class info of anonymous class of instance " + realObj);
        return;
      }

      var moduleMeta = realObj.constructor[moduleMetaInClassProp];
      if (className === "Object" && !moduleMeta) return;
      // Errrr FIXME
      if (moduleMeta) {
        delete moduleMeta.lastChange;
        delete moduleMeta.lastSuperclassChange;
      }
      snapshot[classMetaForSerializationProp] = { className: className, module: moduleMeta };
    }
  }, {
    key: "restoreIfClassInstance",
    value: function restoreIfClassInstance(objRef, snapshot) {
      if (!snapshot.hasOwnProperty(classMetaForSerializationProp)) return;
      var meta = snapshot[classMetaForSerializationProp];
      if (!meta.className) return;

      var klass = this.locateClass(meta);
      if (!klass || typeof klass !== "function") {
        var msg = "Trying to deserialize instance of " + JSON.stringify(meta) + " but this class cannot be found!";
        if (!this.options.ignoreClassNotFound) throw new Error(msg);
        console.error(msg);
        return { isClassPlaceHolder: true, className: meta.className };
      }

      // non-lively classes don't understand our instance restorer arg...!'
      var isLivelyClass = klass.hasOwnProperty(Symbol.for("lively-instance-superclass"));
      return isLivelyClass ? new klass(this) : new klass();
    }
  }, {
    key: "locateClass",
    value: function locateClass(meta) {
      // meta = {className, module: {package, pathInPackage}}
      var m = meta.module;
      if (m) {
        var moduleId = m.pathInPackage;
        if (m.package && m.package.name && m.package.name !== "no group" /*FIXME*/) {
            var packagePath = System.decanonicalize(m.package.name.replace(/\/*$/, "/"));
            moduleId = lively_lang.string.joinPath(packagePath, moduleId);
          }

        var livelyEnv = System.get("@lively-env"),
            realModule = livelyEnv.moduleEnv(moduleId) || livelyEnv.moduleEnv(m.pathInPackage);
        if (!realModule) console.warn("Trying to deserialize instance of class " + meta.className + " but the module " + moduleId + " is not yet loaded");else return realModule.recorder[meta.className];
      }

      // is it a global?
      return System.global[meta.className];
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // searching

  }], [{
    key: "sourceModulesInObjRef",
    value: function sourceModulesInObjRef(snapshotedObjRef) {
      //                                  /--- that's the ref
      // from snapshot = {[key]: {..., props: [...]}}
      var modules = [],
          prop = snapshotedObjRef && snapshotedObjRef[classMetaForSerializationProp];
      if (prop && prop.module) modules.push(prop.module);
      return modules;
    }
  }, {
    key: "sourceModulesIn",
    value: function sourceModulesIn(snapshots) {

      var modules = [];

      Object.keys(snapshots).forEach(function (id) {
        var snapshot = snapshots[id];
        if (snapshot && snapshot[classMetaForSerializationProp]) modules.push(snapshot[classMetaForSerializationProp]);
      });

      return lively_lang.arr.uniqBy(modules, function (a, b) {
        var modA = a.module,
            modB = b.module;
        if (!modA && !modB || modA && !modB || !modA && modB) return a.className === b.className;
        return a.className === b.className && modA.package.name == modB.package.name && modA.package.pathInPackage == modB.package.pathInPackage;
      });
    }
  }]);
  return ClassHelper;
}();

/*global System*/
var ExpressionSerializer = function () {
  function ExpressionSerializer(opts) {
    classCallCheck(this, ExpressionSerializer);

    var _prefix$opts = _extends({
      prefix: "__lv_expr__"
    }, opts),
        prefix = _prefix$opts.prefix;

    this.prefix = prefix + ":";
  }

  createClass(ExpressionSerializer, [{
    key: "isSerializedExpression",
    value: function isSerializedExpression(string$$1) {
      return string$$1.indexOf(this.prefix) === 0;
    }
  }, {
    key: "requiredModulesOf__expr__",
    value: function requiredModulesOf__expr__(__expr__) {
      if (!this.isSerializedExpression(__expr__)) return null;

      var _exprStringDecode = this.exprStringDecode(__expr__),
          bindings = _exprStringDecode.bindings;

      return bindings ? Object.keys(bindings) : null;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // encode / decode of serialized expressions
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "exprStringDecode",
    value: function exprStringDecode(string$$1) {
      // 1. read prefix
      // string = "_prefix:{foo}:package/foo.js:foo()"
      // => {expr: "foo()", bindings: {"package/foo.js": ["foo"]}}

      var idx = string$$1.indexOf(":"),
          prefix = string$$1.slice(0, idx),
          rest = string$$1.slice(idx + 1),
          bindings = {},
          hasBindings = false;

      // 2. bindings?
      while (rest && rest.startsWith("{") && (idx = rest.indexOf("}:")) >= 0) {
        hasBindings = true;
        var importedVars = rest.slice(1, idx);
        rest = rest.slice(idx + 2); // skip }:
        idx = rest.indexOf(":"); // end of package
        var from = rest.slice(0, idx),
            imports = importedVars.split(",").filter(function (ea) {
          return Boolean(ea.trim());
        }).map(function (ea) {
          if (!ea.includes(":")) return ea;

          var _ea$split = ea.split(":"),
              _ea$split2 = slicedToArray(_ea$split, 2),
              exported = _ea$split2[0],
              local = _ea$split2[1];

          return { exported: exported, local: local };
        });
        bindings[from] = imports;
        rest = rest.slice(idx + 1); // skip :
      }

      return { __expr__: rest, bindings: hasBindings ? bindings : null };
    }
  }, {
    key: "exprStringEncode",
    value: function exprStringEncode(_ref) {
      var __expr__ = _ref.__expr__,
          bindings = _ref.bindings;

      // {expr: "foo()", bindings: {"package/foo.js": ["foo"]}}
      // => "_prefix:{foo}:package/foo.js:foo()"

      var string$$1 = String(__expr__);
      if (bindings) {
        var keys = Object.keys(bindings);
        for (var i = 0; i < keys.length; i++) {
          var from = keys[i],
              binding = bindings[from];
          if (Array.isArray(binding)) {
            binding = binding.map(function (ea) {
              return typeof ea === "string" ? ea : ea.exported + ":" + ea.local;
            }).join(",");
          }
          string$$1 = "{" + binding + "}:" + from + ":" + string$$1;
        }
      }
      return this.prefix + string$$1;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "convert__expr__obj",
    value: function convert__expr__obj(obj$$1) {
      // obj.__expr__ is encoded serialized expression *without* prefix
      console.assert("__expr__" in obj$$1, "obj has no property __expr__");
      return this.prefix + obj$$1.__expr__;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // deserialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    // note __boundValues__ becomes a dynamically scoped "variable" inside eval

  }, {
    key: "__eval__",
    value: function __eval__(__source__, __boundValues__) {
      return eval(__source__);
    }
  }, {
    key: "deserializeExpr",
    value: function deserializeExpr(encoded) {
      if (!encoded.startsWith(this.prefix)) throw new Error("\"" + encoded + "\" is not a serialized expression, missing prefix \"" + this.prefix + "\"");
      return this.deserializeExprObj(this.exprStringDecode(encoded));
    }
  }, {
    key: "deserializeExprObj",
    value: function deserializeExprObj(_ref2) {
      var source = _ref2.__expr__,
          bindings = _ref2.bindings;


      var __boundValues__ = {};

      if (bindings) {
        var mods = bindings ? Object.keys(bindings) : [];

        // synchronously get modules specified in bindings object and pull out
        // the vars needed for evaluating source. Add those to __boundValues__
        for (var i = 0; i < mods.length; i++) {
          var modName = mods[i],
              vars = bindings[modName],
              exports = System.get(System.decanonicalize(modName));
          if (!exports) throw new Error("[lively.serializer] expression eval: bindings specify to import " + modName + " but this module is not loaded!\nSource: " + source);

          for (var j = 0; j < vars.length; j++) {
            var varName = vars[j],
                local = void 0,
                exported = void 0;
            if (typeof varName === "string") {
              local = varName;exported = varName;
            } else if ((typeof varName === "undefined" ? "undefined" : _typeof(varName)) === "object") {
              local = varName.local; // alias

              exported = varName.exported;
            }
            __boundValues__[local] = exports[exported];
            source = "var " + local + " = __boundValues__." + local + ";\n" + source;
          }
        }
      }

      // evaluate
      return this.__eval__(source, __boundValues__);
    }
  }]);
  return ExpressionSerializer;
}();

/*

Plugins can implement the following methods to hook into and modify the
serialization process

# serialization

beforeSerialization(pool, realObj)
  Called before serialization starts

afterSerialization(pool, realObj, snapshot)
  Called after serialization ended

serializeObject(realObj, isProperty, pool, serializedObjMap, path)
  If an non-null value is returned this is taken as the value to be placed into
  the snapshot

propertiesToSerialize(pool, ref, snapshot, keysSoFar)
  Should either return null or a list of property names to serialize.  Plugins
  implementing this method get chained in the order in which the object pool
  has the plugins installed.  The return value of one plugin gets passed as
  `keysSoFar` to the next plugin.  The initial value of `keysSoFar` is
  Object.getOwnPropertyKeys(obj).  A nullish value is ignored.

additionallySerialize(pool, ref, snapshot, addFn)
  Can modify `snapshot`.  Return value is not used.


# deserialization

beforeDeserialization(pool, idAndSnapshot)
  Called before serialization starts

afterDeserialization(pool, idAndSnapshot)
  Called after deserialization ended

deserializeObject(pool, ref, snapshot, path)
  given snapshot can produce a new object as the instance to be used in the new
  object graph.  A nullish value will result in the deserializer using a plain
  Object instance.

additionallyDeserializeBeforeProperties(pool, ref, newObj, props, snapshot, serializedObjMap, path)
  Gets snapshot.props passed and can modify newObj.  A non-nullish value will
  be used as props, it is passed to the next plugin implementing this method.
  The result of the final plugin will be used for the normal props
  deserialization.

additionallyDeserializeAfterProperties(pool, ref, newObj, snapshot, serializedObjMap, path)
  Called for side effect, can modify newObj

*/



var CustomSerializePlugin = function () {
  function CustomSerializePlugin() {
    classCallCheck(this, CustomSerializePlugin);
  }

  createClass(CustomSerializePlugin, [{
    key: "serializeObject",


    // can realObj be manually serialized, e.g. into an expression?
    value: function serializeObject(realObj, isProperty, pool, serializedObjMap, path) {
      if (typeof realObj.__serialize__ !== "function") return null;
      var serialized = realObj.__serialize__(pool, serializedObjMap, path);
      if (serialized && serialized.hasOwnProperty("__expr__")) {
        var expr = pool.expressionSerializer.exprStringEncode(serialized);
        serialized = isProperty ? expr : { __expr__: expr };
      }
      return serialized;
    }
  }, {
    key: "deserializeObject",
    value: function deserializeObject(pool, ref, snapshot, path) {
      var __expr__ = snapshot.__expr__;

      return __expr__ ? pool.expressionSerializer.deserializeExpr(__expr__) : null;
    }
  }]);
  return CustomSerializePlugin;
}();

var ClassPlugin = function () {
  function ClassPlugin() {
    classCallCheck(this, ClassPlugin);
  }

  createClass(ClassPlugin, [{
    key: "additionallySerialize",


    // record class meta info for re-instantiating
    value: function additionallySerialize(pool, ref, snapshot, addFn) {
      pool.classHelper.addClassInfo(ref, ref.realObj, snapshot);
    }
  }, {
    key: "deserializeObject",
    value: function deserializeObject(pool, ref, snapshot, path) {
      return pool.classHelper.restoreIfClassInstance(ref, snapshot);
    }
  }]);
  return ClassPlugin;
}();

var AdditionallySerializePlugin = function () {
  function AdditionallySerializePlugin() {
    classCallCheck(this, AdditionallySerializePlugin);
  }

  createClass(AdditionallySerializePlugin, [{
    key: "additionallySerialize",

    // for objects with __additionally_serialize__(snapshot, ref, pool, addFn) method

    value: function additionallySerialize(pool, ref, snapshot, addFn) {
      var realObj = ref.realObj;

      if (realObj && typeof realObj.__additionally_serialize__ === "function") realObj.__additionally_serialize__(snapshot, ref, pool, addFn);
    }
  }, {
    key: "additionallyDeserializeBeforeProperties",
    value: function additionallyDeserializeBeforeProperties(pool, ref, newObj, props, snapshot, serializedObjMap, path) {
      if (typeof newObj.__deserialize__ === "function") newObj.__deserialize__(snapshot, ref, serializedObjMap, pool, path);
    }
  }, {
    key: "additionallyDeserializeAfterProperties",
    value: function additionallyDeserializeAfterProperties(pool, ref, newObj, snapshot, serializedObjMap, path) {
      if (typeof newObj.__after_deserialize__ === "function") newObj.__after_deserialize__(snapshot, ref);
    }
  }]);
  return AdditionallySerializePlugin;
}();

var OnlySerializePropsPlugin = function () {
  function OnlySerializePropsPlugin() {
    classCallCheck(this, OnlySerializePropsPlugin);
  }

  createClass(OnlySerializePropsPlugin, [{
    key: "propertiesToSerialize",
    value: function propertiesToSerialize(pool, ref, snapshot, keysSoFar) {
      var realObj = ref.realObj;

      return realObj && realObj.__only_serialize__ || null;
    }
  }]);
  return OnlySerializePropsPlugin;
}();

var DontSerializePropsPlugin = function () {
  function DontSerializePropsPlugin() {
    classCallCheck(this, DontSerializePropsPlugin);
  }

  createClass(DontSerializePropsPlugin, [{
    key: "propertiesToSerialize",
    value: function propertiesToSerialize(pool, ref, snapshot, keysSoFar) {
      var realObj = ref.realObj;

      if (!realObj || !realObj.__dont_serialize__) return null;
      var ignoredKeys = lively_lang.obj.mergePropertyInHierarchy(realObj, "__dont_serialize__"),
          keys = [];
      for (var i = 0; i < keysSoFar.length; i++) {
        var key = keysSoFar[i];
        if (!ignoredKeys.includes(key)) keys.push(key);
      }
      return keys;
    }
  }]);
  return DontSerializePropsPlugin;
}();

var LivelyClassPropertiesPlugin = function () {
  function LivelyClassPropertiesPlugin() {
    classCallCheck(this, LivelyClassPropertiesPlugin);
  }

  createClass(LivelyClassPropertiesPlugin, [{
    key: "propertiesToSerialize",
    value: function propertiesToSerialize(pool, ref, snapshot, keysSoFar) {
      // serialize class properties as indicated by realObj.constructor.properties
      var realObj = ref.realObj,
          classProperties = realObj.constructor[Symbol.for("lively.classes-properties-and-settings")];


      if (!classProperties) return null;

      var properties = classProperties.properties,
          propertySettings = classProperties.propertySettings,
          valueStoreProperty = propertySettings.valueStoreProperty || "_state",
          valueStore = realObj[valueStoreProperty],
          only = !!realObj.__only_serialize__,
          keys = [];


      if (!valueStore) return;

      // if __only_serialize__ is defined we will only consider those properties
      // that are in keysSoFar  it is expected that the OnlySerializePropsPlugin
      // was producing that list.

      if (only) {
        for (var i = 0; i < keysSoFar.length; i++) {
          var _key = keysSoFar[i],
              _spec = properties[_key];
          if (_key === valueStoreProperty) continue;
          if (_spec) {
            if (_spec && (_spec.derived || _spec.readOnly || _spec.hasOwnProperty("serialize") && !_spec.serialize)) continue;
          }
          keys.push(_key);
        }
        return keys;
      }

      // Otherwise properties add to keysSoFar
      var valueStoreKeyIdx = keysSoFar.indexOf(valueStoreProperty);
      if (valueStoreKeyIdx > -1) keysSoFar.splice(valueStoreKeyIdx, 1);

      for (var key in properties) {
        var spec = properties[key],
            idx = keysSoFar.indexOf(key);
        if (spec.derived || spec.readOnly || spec.hasOwnProperty("serialize") && !spec.serialize) {
          if (idx > -1) keysSoFar.splice(idx, 1);
        } else if (idx === -1) keys.push(key);
      }
      return keys.concat(keysSoFar);
    }
  }, {
    key: "additionallyDeserializeBeforeProperties",
    value: function additionallyDeserializeBeforeProperties(pool, ref, newObj, props, snapshot, serializedObjMap, path) {
      // deserialize class properties as indicated by realObj.constructor.properties
      var classProperties = newObj.constructor[Symbol.for("lively.classes-properties-and-settings")];
      if (!classProperties) return props;

      var properties = classProperties.properties,
          propertySettings = classProperties.propertySettings,
          valueStoreProperty = propertySettings.valueStoreProperty || "_state",
          props = snapshot.props;

      // if props has a valueStoreProperty then we directly deserialize that.
      // As of 2017-02-26 this is for backwards compat.

      if (props[valueStoreProperty]) return props;

      props = lively_lang.obj.clone(props);

      if (!newObj.hasOwnProperty(valueStoreProperty)) newObj.initializeProperties();

      var valueStore = newObj[valueStoreProperty],
          sortedKeys = lively_lang.obj.sortKeysWithBeforeAndAfterConstraints(properties);
      for (var i = 0; i < sortedKeys.length; i++) {
        var key = sortedKeys[i],
            spec = properties[key];
        if (!props.hasOwnProperty(key)) continue;
        ref.recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path);
        delete props[key];
      }

      return props;
    }
  }]);
  return LivelyClassPropertiesPlugin;
}();

var plugins = {
  livelyClassPropertiesPlugin: new LivelyClassPropertiesPlugin(),
  dontSerializePropsPlugin: new DontSerializePropsPlugin(),
  onlySerializePropsPlugin: new OnlySerializePropsPlugin(),
  additionallySerializePlugin: new AdditionallySerializePlugin(),
  classPlugin: new ClassPlugin(),
  customSerializePlugin: new CustomSerializePlugin()
};

var allPlugins = [plugins.customSerializePlugin, plugins.classPlugin, plugins.additionallySerializePlugin, plugins.onlySerializePropsPlugin, plugins.dontSerializePropsPlugin, plugins.livelyClassPropertiesPlugin];

/*

This module defines the classes ObjectPool and ObjectRef.  ObjectPool builds an
index of objects.


For serialization, the pool starts with a single root object for which it
creates an object ref.  The object ref then traverses all its properties and
recursively adds non-primitive objects to the pool, building a snapshot (a
serializable copy) of the objects it encounters.  A snapshot is a simple JS
map/object whose keys are ids if the serialized objects and whose values are
the snapshot representation of those objects.


Example:

new ObjectPool().snapshotObject({foo: {bar: 23}}); // =>
{
  id: "EDF8404A-243A-4858-9C98-0BFEE7DB369E"
  snapshot: {
    "A1CB461E-9187-4711-BEBA-B9E3D1B6D900": {
      props: {
        bar: {key: "bar",value: 23}
      },
      rev: 0
    },
    "EDF8404A-243A-4858-9C98-0BFEE7DB369E": {
      props: {
        foo: {
          key: "foo",
          value: {__ref__: true, id: "A1CB461E-9187-4711-BEBA-B9E3D1B6D900", rev: 0}
        }
      },
      rev: 0
    }
  }
}

For deserialization the process is reversed, i.e. object refs are created from
a snapshot which then re-instantiate objects.  Object properties are hooked up
so that a copy of the original object graph is re-created.

*/

var debugSerialization = false;
var debugDeserialization = false;

var ObjectPool = function () {
  createClass(ObjectPool, null, [{
    key: "withDefaultPlugins",
    value: function withDefaultPlugins(options) {
      return new this(_extends({ plugins: allPlugins }, options));
    }
  }, {
    key: "resolveFromSnapshotAndId",
    value: function resolveFromSnapshotAndId(snapshotAndId, options) {
      return new this(options).resolveFromSnapshotAndId(snapshotAndId);
    }
  }, {
    key: "fromSnapshot",
    value: function fromSnapshot(snapshoted, options) {
      return new this(options).readSnapshot(snapshoted);
    }
  }, {
    key: "withObject",
    value: function withObject(obj$$1, options) {
      var pool = new this(options);
      pool.add(obj$$1);
      return pool;
    }
  }]);

  function ObjectPool(options) {
    classCallCheck(this, ObjectPool);

    this.options = _extends({ ignoreClassNotFound: true, idPropertyName: "id" }, options);
    this.reset();
  }

  createClass(ObjectPool, [{
    key: "reset",
    value: function reset() {
      this.uuidGen = lively_lang.string.newUUID;
      this._obj_ref_map = new Map();
      this._id_ref_map = {};

      var options = this.options;

      this.classHelper = new ClassHelper(options);
      this.expressionSerializer = new ExpressionSerializer();

      if (options.idPropertyName) this.idPropertyName = options.idPropertyName;
      if (options.uuidGen) this.uuidGen = options.uuidGen;
      if (options.reinitializeIds) this.reinitializeIds = options.reinitializeIds;
      if (options.hasOwnProperty("ignoreClassNotFound")) this.classHelper.options.ignoreClassNotFound = options.ignoreClassNotFound;

      var ps = this.plugins = {
        serializeObject: [],
        additionallySerialize: [],
        propertiesToSerialize: [],
        deserializeObject: [],
        additionallyDeserializeBeforeProperties: [],
        additionallyDeserializeAfterProperties: [],
        afterDeserialization: [],
        beforeDeserialization: [],
        afterSerialization: [],
        beforeSerialization: []
      };

      if (options.plugins) {
        options.plugins.forEach(function (p) {
          if (typeof p.serializeObject === "function") ps.serializeObject.push(p);
          if (typeof p.additionallySerialize === "function") ps.additionallySerialize.push(p);
          if (typeof p.propertiesToSerialize === "function") ps.propertiesToSerialize.push(p);
          if (typeof p.deserializeObject === "function") ps.deserializeObject.push(p);
          if (typeof p.additionallyDeserializeBeforeProperties === "function") ps.additionallyDeserializeBeforeProperties.push(p);
          if (typeof p.additionallyDeserializeAfterProperties === "function") ps.additionallyDeserializeAfterProperties.push(p);
          if (typeof p.beforeDeserialization === "function") ps.beforeDeserialization.push(p);
          if (typeof p.afterDeserialization === "function") ps.afterDeserialization.push(p);
          if (typeof p.beforeSerialization === "function") ps.beforeSerialization.push(p);
          if (typeof p.afterSerialization === "function") ps.afterSerialization.push(p);
        });
      }
    }
  }, {
    key: "knowsId",
    value: function knowsId(id) {
      return !!this._id_ref_map[id];
    }
  }, {
    key: "refForId",
    value: function refForId(id) {
      return this._id_ref_map[id];
    }
  }, {
    key: "resolveToObj",
    value: function resolveToObj(id) {
      var ref = this._id_ref_map[id];return ref ? ref.realObj : undefined;
    }
  }, {
    key: "ref",
    value: function ref(obj$$1) {
      return this._obj_ref_map.get(obj$$1);
    }
  }, {
    key: "objects",
    value: function objects() {
      return Array.from(this._obj_ref_map.keys());
    }
  }, {
    key: "objectRefs",
    value: function objectRefs() {
      return Array.from(this._obj_ref_map.values());
    }
  }, {
    key: "internalAddRef",
    value: function internalAddRef(ref) {
      if (ref.realObj) this._obj_ref_map.set(ref.realObj, ref);
      this._id_ref_map[ref.id] = ref;
      return ref;
    }
  }, {
    key: "add",
    value: function add(obj$$1) {
      var _this = this;

      // adds an object to the object pool and returns a "ref" object
      // that is guaranteed to be JSON.stringifyable and that can be used as a place
      // holder in a serialized graph / list

      // primitive objects don't need to be registered
      if (isPrimitive(obj$$1)) return undefined;

      if (Array.isArray(obj$$1)) return obj$$1.map(function (element) {
        return _this.add(element);
      });

      var idPropertyName = obj$$1.__serialization_id_property__ || this.idPropertyName;
      return this.ref(obj$$1) || this.internalAddRef(new ObjectRef(obj$$1[idPropertyName] || this.uuidGen(), obj$$1, undefined, this.idPropertyName));
    }
  }, {
    key: "snapshot",
    value: function snapshot(id) {
      // traverses the object graph and create serialized representation => snapshot
      var snapshot = {};
      this.plugin_beforeSerialization(snapshot, id);
      for (var i = 0, ids = Object.keys(this._id_ref_map); i < ids.length; i++) {
        var ref = this._id_ref_map[ids[i]];
        ref.snapshotObject(snapshot, this);
      }
      snapshot = this.plugin_afterSerialization(snapshot, id);
      return snapshot;
    }
  }, {
    key: "snapshotObject",
    value: function snapshotObject(obj$$1) {
      var _add = this.add(obj$$1),
          id = _add.id,
          snapshot = this.snapshot(id);

      return { id: id, snapshot: snapshot };
    }
  }, {
    key: "readSnapshot",
    value: function readSnapshot(snapshot) {
      // populates object pool with object refs read from the dead snapshot
      if (snapshot.hasOwnProperty("id")) {
        throw new Error("readSnapshot expects simple serialized object map, not id-snapshot pair!");
      }
      for (var i = 0, ids = Object.keys(snapshot); i < ids.length; i++) {
        if (!this.resolveToObj(ids[i])) ObjectRef.fromSnapshot(ids[i], snapshot, this, [], this.idPropertyName);
      }return this;
    }
  }, {
    key: "resolveFromSnapshotAndId",
    value: function resolveFromSnapshotAndId(idAndSnapshot) {
      if (!idAndSnapshot.hasOwnProperty("id")) throw new Error("idAndSnapshot does not have id");
      if (!idAndSnapshot.hasOwnProperty("snapshot")) throw new Error("idAndSnapshot does not have snapshot");
      idAndSnapshot = this.plugin_beforeDeserialization(idAndSnapshot);
      var _idAndSnapshot = idAndSnapshot,
          id = _idAndSnapshot.id,
          snapshot = _idAndSnapshot.snapshot;

      this.readSnapshot(snapshot);
      this.plugin_afterDeserialization(idAndSnapshot);
      return this.resolveToObj(id);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  }, {
    key: "plugin_beforeSerialization",
    value: function plugin_beforeSerialization(snapshot, rootId) {
      for (var i = 0; i < this.plugins.beforeSerialization.length; i++) {
        var p = this.plugins.beforeSerialization[i];
        p.beforeSerialization(this, snapshot, rootId);
      }
    }
  }, {
    key: "plugin_afterSerialization",
    value: function plugin_afterSerialization(snapshot, rootId) {
      for (var i = 0; i < this.plugins.afterSerialization.length; i++) {
        var p = this.plugins.afterSerialization[i],
            result = p.afterSerialization(this, snapshot, rootId);
        if (result) snapshot = result;
      }
      return snapshot;
    }
  }, {
    key: "plugin_beforeDeserialization",
    value: function plugin_beforeDeserialization(idAndSnapshot) {
      for (var i = 0; i < this.plugins.beforeDeserialization.length; i++) {
        var p = this.plugins.beforeDeserialization[i],
            result = p.beforeDeserialization(this, idAndSnapshot);
        if (result) idAndSnapshot = result;
      }
      return idAndSnapshot;
    }
  }, {
    key: "plugin_afterDeserialization",
    value: function plugin_afterDeserialization(idAndSnapshot) {
      for (var i = 0; i < this.plugins.afterDeserialization.length; i++) {
        var p = this.plugins.afterDeserialization[i];
        p.afterDeserialization(this, idAndSnapshot);
      }
    }
  }, {
    key: "plugin_serializeObject",
    value: function plugin_serializeObject(realObj, isProperty, serializedObjMap, path) {
      for (var i = 0; i < this.plugins.serializeObject.length; i++) {
        var p = this.plugins.serializeObject[i],
            serialized = p.serializeObject(realObj, isProperty, this, serializedObjMap, path);
        if (serialized) return serialized;
      }
    }
  }, {
    key: "plugin_propertiesToSerialize",
    value: function plugin_propertiesToSerialize(ref, snapshot, keys) {
      for (var i = 0; i < this.plugins.propertiesToSerialize.length; i++) {
        var p = this.plugins.propertiesToSerialize[i],
            result = p.propertiesToSerialize(this, ref, snapshot, keys);
        if (result) keys = result;
      }
      return keys;
    }
  }, {
    key: "plugin_additionallySerialize",
    value: function plugin_additionallySerialize(ref, snapshot, serializedObjMap, path) {
      // add more / custom stuff to snapshot or modify it somehow
      var addFn = this.plugins.additionallySerialize.length ? __additionally_serialize__addObjectFunction(ref, snapshot, serializedObjMap, this, path) : null;
      for (var i = 0; i < this.plugins.additionallySerialize.length; i++) {
        var p = this.plugins.additionallySerialize[i];
        p.additionallySerialize(this, ref, snapshot, addFn);
      }
    }
  }, {
    key: "plugin_deserializeObject",
    value: function plugin_deserializeObject(ref, snapshot, path) {
      for (var i = 0; i < this.plugins.deserializeObject.length; i++) {
        var p = this.plugins.deserializeObject[i],
            newObj = p.deserializeObject(this, ref, snapshot, path);
        if (newObj) return newObj;
      }
    }
  }, {
    key: "plugin_additionallyDeserializeBeforeProperties",
    value: function plugin_additionallyDeserializeBeforeProperties(ref, newObj, props, snapshot, serializedObjMap, path) {
      for (var i = 0; i < this.plugins.additionallyDeserializeBeforeProperties.length; i++) {
        var p = this.plugins.additionallyDeserializeBeforeProperties[i],
            result = p.additionallyDeserializeBeforeProperties(this, ref, newObj, props, snapshot, serializedObjMap, path);
        if (result) props = result;
      }
      return props;
    }
  }, {
    key: "plugin_additionallyDeserializeAfterProperties",
    value: function plugin_additionallyDeserializeAfterProperties(ref, newObj, snapshot, serializedObjMap, path) {
      for (var i = 0; i < this.plugins.additionallyDeserializeAfterProperties.length; i++) {
        var p = this.plugins.additionallyDeserializeAfterProperties[i];
        p.additionallyDeserializeAfterProperties(this, ref, newObj, snapshot, serializedObjMap, path);
      }
    }
  }]);
  return ObjectPool;
}();

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// ObjectRef

function __additionally_serialize__addObjectFunction(objRef, snapshot, serializedObjMap, pool) {
  var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

  // passed into __additionally_serialize__ as a parameter to allow object to add
  // other objects to serialization

  return function (key, value) {
    var verbatim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return snapshot.props[key] = verbatim ? { key: key, value: value, verbatim: verbatim } : { key: key, value: objRef.snapshotProperty(objRef.id, value, path.concat([key]), serializedObjMap, pool) };
  };
}

var ObjectRef = function () {
  createClass(ObjectRef, null, [{
    key: "fromSnapshot",
    value: function fromSnapshot(id, snapshot, pool) {
      var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var idPropertyName = arguments[4];

      var ref = new this(id, undefined, undefined, idPropertyName);
      return pool.internalAddRef(ref).recreateObjFromSnapshot(snapshot, pool, path);
    }
  }]);

  function ObjectRef(id, realObj, snapshot) {
    var idPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "id";
    classCallCheck(this, ObjectRef);

    this.id = id;
    this.idPropertyName = idPropertyName;
    this.realObj = realObj;
    this.snapshotVersions = [];
    this.snapshots = {};
    if (snapshot) {
      var rev = snapshot.rev || 0;
      this.snapshotVersions.push(rev);
      this.snapshots[rev] = snapshot;
    }
  }

  createClass(ObjectRef, [{
    key: "asRefForSerializedObjMap",
    value: function asRefForSerializedObjMap() {
      var rev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "????";

      return { __ref__: true, id: this.id, rev: rev };
    }
  }, {
    key: "snapshotObject",
    value: function snapshotObject(serializedObjMap, pool) {
      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      // serializedObjMap: maps ids to snapshots

      debugSerialization && console.log("[serialize] " + path.join("."));

      if (path.length > 100) throw new Error("Stopping serializer, encountered a possibly infinit loop: " + path.join("."));

      var id = this.id,
          realObj = this.realObj,
          snapshots = this.snapshots,
          rev = void 0,
          ref = void 0;


      if (!realObj) {
        console.error("Cannot marshall object ref " + id + ", no real object!");
        return _extends({}, this.asRefForSerializedObjMap(), { isMissing: true });
      }

      rev = realObj._rev || 0;
      ref = this.asRefForSerializedObjMap(rev);
      lively_lang.arr.pushIfNotIncluded(this.snapshotVersions, rev);

      // do we already have serialized a current version of realObj?
      if (snapshots[rev]) {
        if (!serializedObjMap[id]) serializedObjMap[id] = snapshots[rev];
        return ref;
      }

      var idType = typeof id === "undefined" ? "undefined" : _typeof(id);
      if (idType === "number") {
        id = String(id);idType = "string";
      }
      if (idType !== "string") {
        throw new Error("Error snapshoting " + realObj + ": " + ("id is not a string but " + id + " ") + ("(serialization path: " + path.join(".") + ")"));
      }

      var serialized = pool.plugin_serializeObject(realObj, false, serializedObjMap, path);
      if (serialized) {
        snapshots[rev] = serializedObjMap[id] = serialized;
        return ref;
      }

      // serialize properties
      var keys = Object.getOwnPropertyNames(realObj),
          props = {},
          snapshot = snapshots[rev] = serializedObjMap[id] = { rev: rev, props: props },
          pluginKeys = pool.plugin_propertiesToSerialize(this, snapshot, keys);
      if (pluginKeys) keys = pluginKeys;

      // do the generic serialization, i.e. enumerate all properties and
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        props[key] = {
          key: key,
          value: this.snapshotProperty(id, realObj[key], path.concat([key]), serializedObjMap, pool)
        };
      }

      // add more / custom stuff to snapshot or modify it somehow    
      pool.plugin_additionallySerialize(this, snapshot, serializedObjMap, path);

      return ref;
    }
  }, {
    key: "snapshotProperty",
    value: function snapshotProperty(sourceObjId, value, path, serializedObjMap, pool) {
      var _this2 = this;

      // returns the value to serialize, i.e. what to put into the snapshot object

      if (typeof value === "function") return undefined; // FIXME

      if (isPrimitive(value)) return value; // stored as is

      var serialized = pool.plugin_serializeObject(value, true, serializedObjMap, path);
      if (serialized) return serialized;

      if (Array.isArray(value)) return value.map(function (ea, i) {
        return _this2.snapshotProperty(sourceObjId, ea, path.concat(i), serializedObjMap, pool);
      });

      var objectRef = pool.add(value);
      return !objectRef || !objectRef.isObjectRef ? objectRef : objectRef.snapshotObject(serializedObjMap, pool, path);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  }, {
    key: "recreateObjFromSnapshot",
    value: function recreateObjFromSnapshot(serializedObjMap, pool, path) {
      // serializedObjMap: map from ids to object snapshots

      if (this.realObj) return this;

      debugDeserialization && console.log("[deserialize] " + this.id + " (via " + path.join(".") + ")");

      var snapshot = serializedObjMap[this.id];
      if (!snapshot) {
        console.error("Cannot recreateObjFromSnapshot ObjectRef " + (this.id + " b/c of missing snapshot in snapshot map!"));
        return this;
      }

      var rev = snapshot.rev,
          newObj = void 0;
      rev = rev || 0;
      this.snapshotVersions.push(rev);
      this.snapshots[rev] = snapshot;

      newObj = pool.plugin_deserializeObject(this, snapshot, path);

      if (!newObj) newObj = {};
      if (typeof newObj._rev === "undefined" && (typeof newObj === "undefined" ? "undefined" : _typeof(newObj)) === "object") newObj._rev = rev || 0;

      this.realObj = newObj;

      pool.internalAddRef(this); // for updating realObj

      if (!newObj) return this;

      var props = snapshot.props;

      var pluginProps = pool.plugin_additionallyDeserializeBeforeProperties(this, newObj, props, snapshot, serializedObjMap, path);
      if (pluginProps) props = pluginProps;

      if (props) {
        // deserialize generic properties
        for (var key in props) {
          this.recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path);
        }
      }

      var idPropertyName = newObj.__serialization_id_property__ || this.idPropertyName;
      if (pool.reinitializeIds && newObj.hasOwnProperty(idPropertyName)) newObj[idPropertyName] = pool.reinitializeIds(this.id, this);

      pool.plugin_additionallyDeserializeAfterProperties(this, newObj, snapshot, serializedObjMap, path);

      return this;
    }
  }, {
    key: "recreatePropertyAndSetProperty",
    value: function recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path) {
      try {
        var _ref = props[key] || { value: "NON EXISTING" },
            verbatim = _ref.verbatim,
            value = _ref.value;

        newObj[key] = verbatim ? value : this.recreateProperty(key, value, serializedObjMap, pool, path.concat(key));
      } catch (e) {
        var objString;
        try {
          objString = String(newObj);
        } catch (e) {
          objString = "[some " + newObj.constructor.name + "]";
        }
        if (!e.__seen) {
          var printedProp = key + " of " + objString + " (" + JSON.stringify(value) + ")";
          console.error("Error deserializing property " + printedProp);
          e.__seen = true;
        } else console.error("Error deserializing property " + key + " of " + objString);
        throw e;
      }
    }
  }, {
    key: "recreateProperty",
    value: function recreateProperty(key, value, serializedObjMap, pool, path) {
      var _this3 = this;

      if (typeof value === "string" && pool.expressionSerializer.isSerializedExpression(value)) return pool.expressionSerializer.deserializeExpr(value);

      if (isPrimitive(value)) return value;

      if (Array.isArray(value)) return value.map(function (ea, i) {
        return _this3.recreateProperty(i, ea, serializedObjMap, pool, path.concat(i));
      });

      var idPropertyName = value.__serialization_id_property__ || this.idPropertyName,
          valueRef = pool.refForId(value[idPropertyName]) || ObjectRef.fromSnapshot(value[idPropertyName], serializedObjMap, pool, path, this.idPropertyName);
      return valueRef.realObj;
    }
  }, {
    key: "isObjectRef",
    get: function get() {
      return true;
    }
  }, {
    key: "currentSnapshot",
    get: function get() {
      var rev = void 0;
      if (!this.snapshotVersions.length) {
        rev = 0;
        this.snapshotVersions.push(rev);
      } else rev = lively_lang.arr.last(this.snapshotVersions);
      return this.snapshots[rev] || (this.snapshots[rev] = { rev: rev, props: {} });
    }
  }, {
    key: "currentRev",
    get: function get() {
      return this.snapshotVersions.length ? lively_lang.arr.last(this.snapshotVersions) : 0;
    }
  }]);
  return ObjectRef;
}();

/*global alert*/
function referenceGraph(snapshot) {
  var ids = Object.keys(snapshot),
      g = {};
  for (var id in snapshot) {
    g[id] = referencesOfId(snapshot, id);
  }return g;
}

function isReference(value) {
  return value && value.__ref__;
}

function referencesOfId(snapshot, id, withPath) {
  // all the ids an regObj (given by id) points to
  var ref = snapshot[id],
      result = [];
  for (var key in ref.props) {
    var _ref = ref.props[key] || {},
        value = _ref.value,
        verbatim = _ref.verbatim;

    if (Array.isArray(value)) {
      result.push.apply(result, toConsumableArray(referencesInArray(snapshot, value, withPath && key)));
      continue;
    }
    if (verbatim || !value || !isReference(value)) continue;
    result.push(withPath ? { key: key, id: value.id } : value.id);
  }

  // FIXME hack for maps and sets...
  if (ref.hasOwnProperty("entries")) {
    for (var i = 0; i < ref.entries.length; i++) {
      var entry = ref.entries[i];
      if (Array.isArray(entry)) {
        result.push.apply(result, toConsumableArray(referencesInArray(snapshot, entry, withPath && entry)));continue;
      } else if (!entry || !isReference(entry)) {} else result.push(withPath ? { key: entry, id: entry.id } : entry.id);
    }
  }
  return result;
}

function referencesInArray(snapshot, arr$$1, optPath) {
  // helper for referencesOfId
  var result = [];
  for (var i = 0; i < arr$$1.length; i++) {
    var value = arr$$1[i];
    if (Array.isArray(value)) {
      var path = optPath ? optPath + '[' + i + ']' : undefined;
      result.push.apply(result, toConsumableArray(referencesInArray(snapshot, value, path)));
      continue;
    }
    if (!value || !isReference(value)) continue;
    result.push(optPath ? { key: optPath + '[' + i + ']', id: value.id } : value.id);
  }
  return result;
}







function removeUnreachableObjects(rootIds, snapshot) {
  var idsToRemove = lively_lang.arr.withoutAll(Object.keys(snapshot), rootIds),
      refGraph = referenceGraph(snapshot);
  rootIds.forEach(function (rootId) {
    var subGraph = lively_lang.graph.subgraphReachableBy(refGraph, rootId);
    for (var i = idsToRemove.length; i--;) {
      var id = idsToRemove[i];
      if (id in subGraph) idsToRemove.splice(i, 1);
    }
  });

  idsToRemove.forEach(function (id) {
    return delete snapshot[id];
  });
  return idsToRemove;
}

var defaultExprSerializer = new ExpressionSerializer();

function requiredModulesOfSnapshot(snapshot) {
  var exprSerializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultExprSerializer;

  // knows how to extract lively.modules packages/modules from __expr__ and
  // class data

  if (snapshot.snapshot) snapshot = snapshot.snapshot;

  var modules = [];

  for (var i = 0, ids = Object.keys(snapshot); i < ids.length; i++) {
    var _modules2;

    var ref = snapshot[ids[i]];

    if (ref.__expr__) {
      var _modules;

      var exprModules = exprSerializer.requiredModulesOf__expr__(ref.__expr__);
      if (exprModules) (_modules = modules).push.apply(_modules, toConsumableArray(exprModules));
      continue;
    }

    var classModules = ClassHelper.sourceModulesInObjRef(ref);
    if (classModules && classModules.length) (_modules2 = modules).push.apply(_modules2, toConsumableArray(classModules.map(function (spec) {
      return (spec.package && spec.package.name || "") + "/" + spec.pathInPackage;
    })));

    if (ref.props) {
      for (var j = 0; j < ref.props.length; j++) {
        var val = ref.props[j].value;
        if (typeof val === "string") {
          var _modules3;

          var _exprModules = exprSerializer.requiredModulesOf__expr__(val);
          if (_exprModules) (_modules3 = modules).push.apply(_modules3, toConsumableArray(_exprModules));
        }
      }
    }
  }

  modules = lively_lang.arr.uniq(modules);

  return modules;
}

var _name$version$depende = {
  name: "lively.serializer2",
  version: "0.1.3",
  dependencies: {
    "lively.lang": "^1.0.5"
  },
  devDependencies: {
    "mocha-es6": "*",
    rollup: "^0.36.1",
    "rollup-plugin-babel": "^2.6.1",
    "babel-plugin-external-helpers": "^6.8.0",
    "babel-plugin-syntax-object-rest-spread": "^6.13.0",
    "babel-plugin-transform-async-to-generator": "^6.16.0",
    "babel-plugin-transform-object-rest-spread": "^6.16.0",
    "babel-preset-es2015": "^6.16.0",
    "babel-preset-es2015-rollup": "^1.1.1",
    "babel-regenerator-runtime": "^6.5.0",
    "babel-plugin-inline-json-import": "^0.2.1"
  },
  scripts: {
    test: "mocha-es6 tests/{test,*-test}.js",
    build: "node build.js"
  }
};
var serializerVersion = _name$version$depende.version;

function normalizeOptions(options) {
  options = _extends({ plugins: allPlugins, reinitializeIds: false }, options);
  if (options.reinitializeIds && typeof options.reinitializeIds !== "function") throw new Error("serializer option 'reinitializeIds' needs to be a function(id, ref) => id");
  return options;
}

function normalizeMigrations() {
  var migrations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return {
    before: migrations.filter(function (ea) {
      return typeof ea.snapshotConverter === "function";
    }),
    after: migrations.filter(function (ea) {
      return typeof ea.objectConverter === "function";
    })
  };
}

function runMigrations(migrations, method, idAndSnapshot, pool) {
  for (var i = 0; i < migrations.length; i++) {
    var migration = migrations[i];
    try {
      idAndSnapshot = migration[method](idAndSnapshot, pool);
    } catch (err) {
      console.error("migration " + migration.name + " failed:");
      console.error(err);
    }
  }
  return idAndSnapshot;
}

var majorAndMinorVersionRe = /\.[^\.]+$/; // x.y.z => x.y

function serialize(obj$$1, options) {
  options = normalizeOptions(options);
  var objPool = options.objPool || new ObjectPool(options),
      requiredVersion = "~" + serializerVersion.replace(majorAndMinorVersionRe, ""),
      // semver
  snapshotAndId = objPool.snapshotObject(obj$$1);
  // object hooks are allowed to modify the snapshot graph and remove
  // references. To only serialize what's needed we cleanup the graph after all
  // hooks are done.
  removeUnreachableObjects([snapshotAndId.id], snapshotAndId.snapshot);
  snapshotAndId.requiredVersion = requiredVersion;
  return snapshotAndId;
}

function deserialize(idAndSnapshot, options) {
  options = normalizeOptions(options);
  var id = idAndSnapshot.id,
      snapshot = idAndSnapshot.snapshot,
      requiredVersion = idAndSnapshot.requiredVersion;

  if (requiredVersion && !lively.modules.semver.satisfies(serializerVersion, requiredVersion)) console.warn("[lively.serializer deserialization] snapshot requires version " + (requiredVersion + " but serializer has incompatible version ") + (serializerVersion + ". Deserialization might fail...!"));
  var objPool = options.objPool || new ObjectPool(options);
  return objPool.resolveFromSnapshotAndId(idAndSnapshot);
}

function deserializeWithMigrations(idAndSnapshot, migrations, options) {
  options = normalizeOptions(options);
  var objPool = options.objPool || (options.objPool = new ObjectPool(options)),
      _normalizeMigrations = normalizeMigrations(migrations),
      before = _normalizeMigrations.before,
      after = _normalizeMigrations.after,
      wait = void 0;

  runMigrations(before, "snapshotConverter", idAndSnapshot, objPool);
  if (typeof options.onDeserializationStart === "function") wait = options.onDeserializationStart(idAndSnapshot, options);
  return wait instanceof Promise ? wait.then(step2) : step2();

  function step2() {
    var deserialized = deserialize(idAndSnapshot, options);
    runMigrations(after, "objectConverter", idAndSnapshot, objPool);
    return deserialized;
  }
}

function copy(obj$$1, options) {
  return deserialize(serialize(obj$$1, options), options);
}

exports.serialize = serialize;
exports.deserialize = deserialize;
exports.deserializeWithMigrations = deserializeWithMigrations;
exports.copy = copy;
exports.ObjectRef = ObjectRef;
exports.ObjectPool = ObjectPool;
exports.requiredModulesOfSnapshot = requiredModulesOfSnapshot;
exports.removeUnreachableObjects = removeUnreachableObjects;

}((this.lively.serializer2 = this.lively.serializer2 || {}),lively.lang));

  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.serializer2;
})();

(function() {

var PouchDB = (function() {
  var exports = {}, module = {exports: exports};
// INLINED /Users/robert/Lively/lively-dev2/lively.storage/node_modules/pouchdb/dist/pouchdb.js
// PouchDB 6.3.2
// 
// (c) 2012-2017 Dale Harvey and the PouchDB team
// PouchDB may be freely distributed under the Apache license, version 2.0.
// For all details and documentation:
// http://pouchdb.com
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PouchDB = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}
},{}],2:[function(_dereq_,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_(3);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,_dereq_(9))
},{"3":3,"9":9}],3:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_(8);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"8":8}],4:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],5:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],7:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(5);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"5":5}],8:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],9:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(_dereq_,module,exports){
(function (factory) {
    if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals (with support for web workers)
        var glob;

        try {
            glob = window;
        } catch (e) {
            glob = self;
        }

        glob.SparkMD5 = factory();
    }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));

},{}],11:[function(_dereq_,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],12:[function(_dereq_,module,exports){
(function (global){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],13:[function(_dereq_,module,exports){
var rng = _dereq_(12);
var bytesToUuid = _dereq_(11);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"11":11,"12":12}],14:[function(_dereq_,module,exports){
'use strict';

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\t':
      case '\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\d\.\-e\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};

},{}],15:[function(_dereq_,module,exports){
(function (global){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lie = _interopDefault(_dereq_(7));
var getArguments = _interopDefault(_dereq_(1));
var events = _dereq_(4);
var inherits = _interopDefault(_dereq_(6));
var nextTick = _interopDefault(_dereq_(5));
var v4 = _interopDefault(_dereq_(13));
var debug = _interopDefault(_dereq_(2));
var Md5 = _interopDefault(_dereq_(10));
var vuvuzela = _interopDefault(_dereq_(14));

/* istanbul ignore next */
var PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;

function isBinaryObject(object) {
  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
    (typeof Blob !== 'undefined' && object instanceof Blob);
}

function cloneArrayBuffer(buff) {
  if (typeof buff.slice === 'function') {
    return buff.slice(0);
  }
  // IE10-11 slice() polyfill
  var target = new ArrayBuffer(buff.byteLength);
  var targetArray = new Uint8Array(target);
  var sourceArray = new Uint8Array(buff);
  targetArray.set(sourceArray);
  return target;
}

function cloneBinaryObject(object) {
  if (object instanceof ArrayBuffer) {
    return cloneArrayBuffer(object);
  }
  var size = object.size;
  var type = object.type;
  // Blob
  if (typeof object.slice === 'function') {
    return object.slice(0, size, type);
  }
  // PhantomJS slice() replacement
  return object.webkitSlice(0, size, type);
}

// most of this is borrowed from lodash.isPlainObject:
// https://github.com/fis-components/lodash.isplainobject/
// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(value) {
  var proto = Object.getPrototypeOf(value);
  /* istanbul ignore if */
  if (proto === null) { // not sure when this happens, but I guess it can
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

function clone(object) {
  var newObject;
  var i;
  var len;

  if (!object || typeof object !== 'object') {
    return object;
  }

  if (Array.isArray(object)) {
    newObject = [];
    for (i = 0, len = object.length; i < len; i++) {
      newObject[i] = clone(object[i]);
    }
    return newObject;
  }

  // special case: to avoid inconsistencies between IndexedDB
  // and other backends, we automatically stringify Dates
  if (object instanceof Date) {
    return object.toISOString();
  }

  if (isBinaryObject(object)) {
    return cloneBinaryObject(object);
  }

  if (!isPlainObject(object)) {
    return object; // don't clone objects like Workers
  }

  newObject = {};
  for (i in object) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(object, i)) {
      var value = clone(object[i]);
      if (typeof value !== 'undefined') {
        newObject[i] = value;
      }
    }
  }
  return newObject;
}

function once(fun) {
  var called = false;
  return getArguments(function (args) {
    /* istanbul ignore if */
    if (called) {
      // this is a smoke test and should never actually happen
      throw new Error('once called more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
}

function toPromise(func) {
  //create the function we will be returning
  return getArguments(function (args) {
    // Clone arguments
    args = clone(args);
    var self = this;
    // if the last argument is a function, assume its a callback
    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    var promise = new PouchPromise$1(function (fulfill, reject) {
      var resp;
      try {
        var callback = once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    return promise;
  });
}

function logApiCall(self, name, args) {
  /* istanbul ignore if */
  if (self.constructor.listeners('debug').length) {
    var logArgs = ['api', self.name, name];
    for (var i = 0; i < args.length - 1; i++) {
      logArgs.push(args[i]);
    }
    self.constructor.emit('debug', logArgs);

    // override the callback itself to log the response
    var origCallback = args[args.length - 1];
    args[args.length - 1] = function (err, res) {
      var responseArgs = ['api', self.name, name];
      responseArgs = responseArgs.concat(
        err ? ['error', err] : ['success', res]
      );
      self.constructor.emit('debug', responseArgs);
      origCallback(err, res);
    };
  }
}

function adapterFun(name, callback) {
  return toPromise(getArguments(function (args) {
    if (this._closed) {
      return PouchPromise$1.reject(new Error('database is closed'));
    }
    if (this._destroyed) {
      return PouchPromise$1.reject(new Error('database is destroyed'));
    }
    var self = this;
    logApiCall(self, name, args);
    if (!this.taskqueue.isReady) {
      return new PouchPromise$1(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
}

function mangle(key) {
  return '$' + key;
}
function unmangle(key) {
  return key.substring(1);
}
function Map$1() {
  this._store = {};
}
Map$1.prototype.get = function (key) {
  var mangled = mangle(key);
  return this._store[mangled];
};
Map$1.prototype.set = function (key, value) {
  var mangled = mangle(key);
  this._store[mangled] = value;
  return true;
};
Map$1.prototype.has = function (key) {
  var mangled = mangle(key);
  return mangled in this._store;
};
Map$1.prototype["delete"] = function (key) {
  var mangled = mangle(key);
  var res = mangled in this._store;
  delete this._store[mangled];
  return res;
};
Map$1.prototype.forEach = function (cb) {
  var keys = Object.keys(this._store);
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var value = this._store[key];
    key = unmangle(key);
    cb(value, key);
  }
};
Object.defineProperty(Map$1.prototype, 'size', {
  get: function () {
    return Object.keys(this._store).length;
  }
});

function Set$1(array) {
  this._store = new Map$1();

  // init with an array
  if (array && Array.isArray(array)) {
    for (var i = 0, len = array.length; i < len; i++) {
      this.add(array[i]);
    }
  }
}
Set$1.prototype.add = function (key) {
  return this._store.set(key, true);
};
Set$1.prototype.has = function (key) {
  return this._store.has(key);
};
Set$1.prototype.forEach = function (cb) {
  this._store.forEach(function (value, key) {
    cb(key);
  });
};
Object.defineProperty(Set$1.prototype, 'size', {
  get: function () {
    return this._store.size;
  }
});

/* global Map,Set,Symbol */
// Based on https://kangax.github.io/compat-table/es6/ we can sniff out
// incomplete Map/Set implementations which would otherwise cause our tests to fail.
// Notably they fail in IE11 and iOS 8.4, which this prevents.
function supportsMapAndSet() {
  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
    return false;
  }
  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return prop && 'get' in prop && Map[Symbol.species] === Map;
}

// based on https://github.com/montagejs/collections
/* global Map,Set */

var ExportedSet;
var ExportedMap;

{
  if (supportsMapAndSet()) { // prefer built-in Map/Set
    ExportedSet = Set;
    ExportedMap = Map;
  } else { // fall back to our polyfill
    ExportedSet = Set$1;
    ExportedMap = Map$1;
  }
}

// like underscore/lodash _.pick()
function pick(obj, arr) {
  var res = {};
  for (var i = 0, len = arr.length; i < len; i++) {
    var prop = arr[i];
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  }
  return res;
}

// Most browsers throttle concurrent requests at 6, so it's silly
// to shim _bulk_get by trying to launch potentially hundreds of requests
// and then letting the majority time out. We can handle this ourselves.
var MAX_NUM_CONCURRENT_REQUESTS = 6;

function identityFunction(x) {
  return x;
}

function formatResultForOpenRevsGet(result) {
  return [{
    ok: result
  }];
}

// shim for P/CouchDB adapters that don't directly implement _bulk_get
function bulkGet(db, opts, callback) {
  var requests = opts.docs;

  // consolidate into one request per doc if possible
  var requestsById = new ExportedMap();
  requests.forEach(function (request) {
    if (requestsById.has(request.id)) {
      requestsById.get(request.id).push(request);
    } else {
      requestsById.set(request.id, [request]);
    }
  });

  var numDocs = requestsById.size;
  var numDone = 0;
  var perDocResults = new Array(numDocs);

  function collapseResultsAndFinish() {
    var results = [];
    perDocResults.forEach(function (res) {
      res.docs.forEach(function (info) {
        results.push({
          id: res.id,
          docs: [info]
        });
      });
    });
    callback(null, {results: results});
  }

  function checkDone() {
    if (++numDone === numDocs) {
      collapseResultsAndFinish();
    }
  }

  function gotResult(docIndex, id, docs) {
    perDocResults[docIndex] = {id: id, docs: docs};
    checkDone();
  }

  var allRequests = [];
  requestsById.forEach(function (value, key) {
    allRequests.push(key);
  });

  var i = 0;

  function nextBatch() {

    if (i >= allRequests.length) {
      return;
    }

    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
    var batch = allRequests.slice(i, upTo);
    processBatch(batch, i);
    i += batch.length;
  }

  function processBatch(batch, offset) {
    batch.forEach(function (docId, j) {
      var docIdx = offset + j;
      var docRequests = requestsById.get(docId);

      // just use the first request as the "template"
      // TODO: The _bulk_get API allows for more subtle use cases than this,
      // but for now it is unlikely that there will be a mix of different
      // "atts_since" or "attachments" in the same request, since it's just
      // replicate.js that is using this for the moment.
      // Also, atts_since is aspirational, since we don't support it yet.
      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
      docOpts.open_revs = docRequests.map(function (request) {
        // rev is optional, open_revs disallowed
        return request.rev;
      });

      // remove falsey / undefined revisions
      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

      var formatResult = identityFunction;

      if (docOpts.open_revs.length === 0) {
        delete docOpts.open_revs;

        // when fetching only the "winning" leaf,
        // transform the result so it looks like an open_revs
        // request
        formatResult = formatResultForOpenRevsGet;
      }

      // globally-supplied options
      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
        if (param in opts) {
          docOpts[param] = opts[param];
        }
      });
      db.get(docId, docOpts, function (err, res) {
        var result;
        /* istanbul ignore if */
        if (err) {
          result = [{error: err}];
        } else {
          result = formatResult(res);
        }
        gotResult(docIdx, docId, result);
        nextBatch();
      });
    });
  }

  nextBatch();

}

function isChromeApp() {
  return (typeof chrome !== "undefined" &&
    typeof chrome.storage !== "undefined" &&
    typeof chrome.storage.local !== "undefined");
}

var hasLocal;

if (isChromeApp()) {
  hasLocal = false;
} else {
  try {
    localStorage.setItem('_pouch_check_localstorage', 1);
    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
  } catch (e) {
    hasLocal = false;
  }
}

function hasLocalStorage() {
  return hasLocal;
}

// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We
// avoid using process.nextTick() directly because the polyfill is very large and we don't
// need all of it (see: https://github.com/defunctzombie/node-process).
// "immediate" 3.0.8 is used by lie, and it's a smaller version of the latest "immediate"
// package, so it's the one we use.
// When we use nextTick() in our codebase, we only care about not releasing Zalgo
// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).
// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest
// (least latency) option, which is "immediate" due to use of microtasks.
// All of our nextTicks are isolated to this one function so we can easily swap out one
// implementation for another.

inherits(Changes, events.EventEmitter);

/* istanbul ignore next */
function attachBrowserEvents(self) {
  if (isChromeApp()) {
    chrome.storage.onChanged.addListener(function (e) {
      // make sure it's event addressed to us
      if (e.db_name != null) {
        //object only has oldValue, newValue members
        self.emit(e.dbName.newValue);
      }
    });
  } else if (hasLocalStorage()) {
    if (typeof addEventListener !== 'undefined') {
      addEventListener("storage", function (e) {
        self.emit(e.key);
      });
    } else { // old IE
      window.attachEvent("storage", function (e) {
        self.emit(e.key);
      });
    }
  }
}

function Changes() {
  events.EventEmitter.call(this);
  this._listeners = {};

  attachBrowserEvents(this);
}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  /* istanbul ignore if */
  if (this._listeners[id]) {
    return;
  }
  var self = this;
  var inprogress = false;
  function eventFunction() {
    /* istanbul ignore if */
    if (!self._listeners[id]) {
      return;
    }
    if (inprogress) {
      inprogress = 'waiting';
      return;
    }
    inprogress = true;
    var changesOpts = pick(opts, [
      'style', 'include_docs', 'attachments', 'conflicts', 'filter',
      'doc_ids', 'view', 'since', 'query_params', 'binary'
    ]);

    /* istanbul ignore next */
    function onError() {
      inprogress = false;
    }

    db.changes(changesOpts).on('change', function (c) {
      if (c.seq > opts.since && !opts.cancelled) {
        opts.since = c.seq;
        opts.onChange(c);
      }
    }).on('complete', function () {
      if (inprogress === 'waiting') {
        nextTick(eventFunction);
      }
      inprogress = false;
    }).on('error', onError);
  }
  this._listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  /* istanbul ignore if */
  if (!(id in this._listeners)) {
    return;
  }
  events.EventEmitter.prototype.removeListener.call(this, dbName,
    this._listeners[id]);
  delete this._listeners[id];
};


/* istanbul ignore next */
Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (isChromeApp()) {
    chrome.storage.local.set({dbName: dbName});
  } else if (hasLocalStorage()) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

function guardedConsole(method) {
  /* istanbul ignore else */
  if (console !== 'undefined' && method in console) {
    var args = Array.prototype.slice.call(arguments, 1);
    console[method].apply(console, args);
  }
}

function randomNumber(min, max) {
  var maxTimeout = 600000; // Hard-coded default of 10 minutes
  min = parseInt(min, 10) || 0;
  max = parseInt(max, 10);
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
  if (max > maxTimeout) {
    min = maxTimeout >> 1; // divide by two
    max = maxTimeout;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
function explainError(status, str) {
  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
}

var assign;
{
  if (typeof Object.assign === 'function') {
    assign = Object.assign;
  } else {
    // lite Object.assign polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    assign = function (target) {
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }
}

var $inject_Object_assign = assign;

inherits(PouchError, Error);

function PouchError(status, error, reason) {
  Error.call(this, reason);
  this.status = status;
  this.name = error;
  this.message = reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    for (var p in error) {
      if (typeof error[p] !== 'function') {
        this[p] = error[p];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

function tryFilter(filter, doc, req) {
  try {
    return !filter(doc, req);
  } catch (err) {
    var msg = 'Filter function threw: ' + err.toString();
    return createError(BAD_REQUEST, msg);
  }
}

function filterChange(opts) {
  var req = {};
  var hasFilter = opts.filter && typeof opts.filter === 'function';
  req.query = opts.query_params;

  return function filter(change) {
    if (!change.doc) {
      // CSG sends events on the changes feed that don't have documents,
      // this hack makes a whole lot of existing code robust.
      change.doc = {};
    }

    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

    if (typeof filterReturn === 'object') {
      return filterReturn;
    }

    if (filterReturn) {
      return false;
    }

    if (!opts.include_docs) {
      delete change.doc;
    } else if (!opts.attachments) {
      for (var att in change.doc._attachments) {
        /* istanbul ignore else */
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
}

function flatten(arrs) {
  var res = [];
  for (var i = 0, len = arrs.length; i < len; i++) {
    res = res.concat(arrs[i]);
  }
  return res;
}

// shim for Function.prototype.name,
// for browsers that don't support it like IE

/* istanbul ignore next */
function f() {}

var hasName = f.name;
var res;

// We dont run coverage in IE
/* istanbul ignore else */
if (hasName) {
  res = function (fun) {
    return fun.name;
  };
} else {
  res = function (fun) {
    return fun.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
  };
}

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
function invalidIdError(id) {
  var err;
  if (!id) {
    err = createError(MISSING_ID);
  } else if (typeof id !== 'string') {
    err = createError(INVALID_ID);
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = createError(RESERVED_ID);
  }
  if (err) {
    throw err;
  }
}

// Checks if a PouchDB object is "remote" or not. This is
// designed to opt-in to certain optimizations, such as
// avoiding checks for "dependentDbs" and other things that
// we know only apply to local databases. In general, "remote"
// should be true for the http adapter, and for third-party
// adapters with similar expensive boundaries to cross for
// every API call, such as socket-pouch and worker-pouch.
// Previously, this was handled via db.type() === 'http'
// which is now deprecated.

function isRemote(db) {
  if (typeof db._remote === 'boolean') {
    return db._remote;
  }
  /* istanbul ignore next */
  if (typeof db.type === 'function') {
    guardedConsole('warn',
      'db.type() is deprecated and will be removed in ' +
      'a future version of PouchDB');
    return db.type() === 'http';
  }
  /* istanbul ignore next */
  return false;
}

function listenerCount(ee, type) {
  return 'listenerCount' in ee ? ee.listenerCount(type) :
                                 events.EventEmitter.listenerCount(ee, type);
}

function parseDesignDocFunctionName(s) {
  if (!s) {
    return null;
  }
  var parts = s.split('/');
  if (parts.length === 2) {
    return parts;
  }
  if (parts.length === 1) {
    return [s, s];
  }
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var normalized = parseDesignDocFunctionName(s);
  return normalized ? normalized.join('/') : null;
}

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var qName ="queryKey";
var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
/* eslint maxlen: 0, no-useless-escape: 0 */
var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

function parseUri(str) {
  var m = parser.exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = keys[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[qName] = {};
  uri[keys[12]].replace(qParser, function ($0, $1, $2) {
    if ($1) {
      uri[qName][$1] = $2;
    }
  });

  return uri;
}

// Based on https://github.com/alexdavid/scope-eval v0.0.3
// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
// This is basically just a wrapper around new Function()

function scopeEval(source, scope) {
  var keys = [];
  var values = [];
  for (var key in scope) {
    if (scope.hasOwnProperty(key)) {
      keys.push(key);
      values.push(scope[key]);
    }
  }
  keys.push(source);
  return Function.apply(null, keys).apply(null, values);
}

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new PouchPromise$1(function (fulfill, reject) {
    db.get(docId, function (err, doc) {
      if (err) {
        /* istanbul ignore next */
        if (err.status !== 404) {
          return reject(err);
        }
        doc = {};
      }

      // the user might change the _rev, so save it for posterity
      var docRev = doc._rev;
      var newDoc = diffFun(doc);

      if (!newDoc) {
        // if the diffFun returns falsy, we short-circuit as
        // an optimization
        return fulfill({updated: false, rev: docRev});
      }

      // users aren't allowed to modify these values,
      // so reset them here
      newDoc._id = docId;
      newDoc._rev = docRev;
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc).then(function (res) {
    return {
      updated: true,
      rev: res.rev
    };
  }, function (err) {
    /* istanbul ignore next */
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc._id, diffFun);
  });
}

function rev() {
  return v4().replace(/-/g, '').toLowerCase();
}

var uuid = v4;

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var winningDeleted;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var deleted = !!tree[1].deleted;
    var id = tree[0];
    // sort by deleted, then pos, then id
    if (!winningId || (winningDeleted !== deleted ? winningDeleted :
        winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
      winningDeleted = deleted;
    }
  }

  return winningPos + '-' + winningId;
}

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
function traverseRevTree(revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
}

function sortByPos(a, b) {
  return a.pos - b.pos;
}

function collectLeaves(revs) {
  var leaves = [];
  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(sortByPos).reverse();
  for (var i = 0, len = leaves.length; i < len; i++) {
    delete leaves[i].pos;
  }
  return leaves;
}

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
function collectConflicts(metadata) {
  var win = winningRev(metadata);
  var leaves = collectLeaves(metadata.rev_tree);
  var conflicts = [];
  for (var i = 0, len = leaves.length; i < len; i++) {
    var leaf = leaves[i];
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  }
  return conflicts;
}

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
function compactTree(metadata) {
  var revs = [];
  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                               revHash, ctx, opts) {
    if (opts.status === 'available' && !isLeaf) {
      revs.push(pos + '-' + revHash);
      opts.status = 'missing';
    }
  });
  return revs;
}

// build up a list of all the paths to the leafs in this revision tree
function rootToLeaf(revs) {
  var paths = [];
  var toVisit = revs.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      paths.push({pos: (pos + 1 - history.length), ids: history});
    }
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], history: history});
    }
  }
  return paths.reverse();
}

// for a better overview of what this is doing, read:
// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl
//
// But for a quick intro, CouchDB uses a revision tree to store a documents
// history, A -> B -> C, when a document has conflicts, that is a branch in the
// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format
//
// KeyTree = [Path ... ]
// Path = {pos: position_from_root, ids: Tree}
// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]

function sortByPos$1(a, b) {
  return a.pos - b.pos;
}

// classic binary search
function binarySearch(arr, item, comparator) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1;
    if (comparator(arr[mid], item) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}

// assuming the arr is sorted, insert the item in the proper place
function insertSorted(arr, item, comparator) {
  var idx = binarySearch(arr, item, comparator);
  arr.splice(idx, 0, item);
}

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
function pathToTree(path, numStemmed) {
  var root;
  var leaf;
  for (var i = numStemmed, len = path.length; i < len; i++) {
    var node = path[i];
    var currentLeaf = [node.id, node.opts, []];
    if (leaf) {
      leaf[2].push(currentLeaf);
      leaf = currentLeaf;
    } else {
      root = leaf = currentLeaf;
    }
  }
  return root;
}

// compare the IDs of two trees
function compareTree(a, b) {
  return a[0] < b[0] ? -1 : 1;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
        tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        insertSorted(tree1[2], tree2[2][i], compareTree);
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  for (var i = 0, len = tree.length; i < len; i++) {
    var branch = tree[i];
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        var elements = item.ids[2];
        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
          trees.push({
            ids: elements[j],
            diff: item.diff - 1,
            parent: item.ids,
            parentIdx: j
          });
        }
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  }

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(sortByPos$1);

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths
  var paths = rootToLeaf(tree);
  var stemmedRevs;

  var result;
  for (var i = 0, len = paths.length; i < len; i++) {
    // Then for each path, we cut off the start of the path based on the
    // `depth` to stem to, and generate a new set of flat trees
    var path = paths[i];
    var stemmed = path.ids;
    var node;
    if (stemmed.length > depth) {
      // only do the stemming work if we actually need to stem
      if (!stemmedRevs) {
        stemmedRevs = {}; // avoid allocating this object unnecessarily
      }
      var numStemmed = stemmed.length - depth;
      node = {
        pos: path.pos + numStemmed,
        ids: pathToTree(stemmed, numStemmed)
      };

      for (var s = 0; s < numStemmed; s++) {
        var rev = (path.pos + s) + '-' + stemmed[s].id;
        stemmedRevs[rev] = true;
      }
    } else { // no need to actually stem
      node = {
        pos: path.pos,
        ids: pathToTree(stemmed, 0)
      };
    }

    // Then we remerge all those flat trees together, ensuring that we dont
    // connect trees that would go beyond the depth limit
    if (result) {
      result = doMerge(result, node, true).tree;
    } else {
      result = [node];
    }
  }

  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
  if (stemmedRevs) {
    traverseRevTree(result, function (isLeaf, pos, revHash) {
      // some revisions may have been removed in a branch but not in another
      delete stemmedRevs[pos + '-' + revHash];
    });
  }

  return {
    tree: result,
    revs: stemmedRevs ? Object.keys(stemmedRevs) : []
  };
}

function merge(tree, path, depth) {
  var newTree = doMerge(tree, path);
  var stemmed = stem(newTree.tree, depth);
  return {
    tree: stemmed.tree,
    stemmedRevs: stemmed.revs,
    conflicts: newTree.conflicts
  };
}

// return true if a rev exists in the rev tree, false otherwise
function revExists(revs, rev) {
  var toVisit = revs.slice();
  var splitRev = rev.split('-');
  var targetPos = parseInt(splitRev[0], 10);
  var targetId = splitRev[1];

  var node;
  while ((node = toVisit.pop())) {
    if (node.pos === targetPos && node.ids[0] === targetId) {
      return true;
    }
    var branches = node.ids[2];
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: node.pos + 1, ids: branches[i]});
    }
  }
  return false;
}

function getTrees(node) {
  return node.ids;
}

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
function isDeleted(metadata, rev) {
  if (!rev) {
    rev = winningRev(metadata);
  }
  var id = rev.substring(rev.indexOf('-') + 1);
  var toVisit = metadata.rev_tree.map(getTrees);

  var tree;
  while ((tree = toVisit.pop())) {
    if (tree[0] === id) {
      return !!tree[1].deleted;
    }
    toVisit = toVisit.concat(tree[2]);
  }
}

function isLocalId(id) {
  return (/^_local/).test(id);
}

// returns the current leaf node for a given revision
function latest(rev, metadata) {
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, pos: pos, opts: opts});

    if (isLeaf) {
      for (var i = 0, len = history.length; i < len; i++) {
        var historyNode = history[i];
        var historyRev = historyNode.pos + '-' + historyNode.id;

        if (historyRev === rev) {
          // return the rev of this leaf
          return pos + '-' + id;
        }
      }
    }

    for (var j = 0, l = branches.length; j < l; j++) {
      toVisit.push({pos: pos + 1, ids: branches[j], history: history});
    }
  }

  /* istanbul ignore next */
  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
}

inherits(Changes$2, events.EventEmitter);

function tryCatchInChangeListener(self, change) {
  // isolate try/catches to avoid V8 deoptimizations
  try {
    self.emit('change', change);
  } catch (e) {
    guardedConsole('error', 'Error in .on("change", function):', e);
  }
}

function Changes$2(db, opts, callback) {
  events.EventEmitter.call(this);
  var self = this;
  this.db = db;
  opts = opts ? clone(opts) : {};
  var complete = opts.complete = once(function (err, resp) {
    if (err) {
      if (listenerCount(self, 'error') > 0) {
        self.emit('error', err);
      }
    } else {
      self.emit('complete', resp);
    }
    self.removeAllListeners();
    db.removeListener('destroyed', onDestroy);
  });
  if (callback) {
    self.on('complete', function (resp) {
      callback(null, resp);
    });
    self.on('error', callback);
  }
  function onDestroy() {
    self.cancel();
  }
  db.once('destroyed', onDestroy);

  opts.onChange = function (change) {
    /* istanbul ignore if */
    if (self.isCancelled) {
      return;
    }
    tryCatchInChangeListener(self, change);
  };

  var promise = new PouchPromise$1(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });
  self.once('cancel', function () {
    db.removeListener('destroyed', onDestroy);
    opts.complete(null, {status: 'cancelled'});
  });
  this.then = promise.then.bind(promise);
  this['catch'] = promise['catch'].bind(promise);
  this.then(function (result) {
    complete(null, result);
  }, complete);



  if (!db.taskqueue.isReady) {
    db.taskqueue.addTask(function (failed) {
      if (failed) {
        opts.complete(failed);
      } else if (self.isCancelled) {
        self.emit('cancel');
      } else {
        self.validateChanges(opts);
      }
    });
  } else {
    self.validateChanges(opts);
  }
}
Changes$2.prototype.cancel = function () {
  this.isCancelled = true;
  if (this.db.taskqueue.isReady) {
    this.emit('cancel');
  }
};
function processChange(doc, metadata, opts) {
  var changeList = [{rev: doc._rev}];
  if (opts.style === 'all_docs') {
    changeList = collectLeaves(metadata.rev_tree)
    .map(function (x) { return {rev: x.rev}; });
  }
  var change = {
    id: metadata.id,
    changes: changeList,
    doc: doc
  };

  if (isDeleted(metadata, doc._rev)) {
    change.deleted = true;
  }
  if (opts.conflicts) {
    change.doc._conflicts = collectConflicts(metadata);
    if (!change.doc._conflicts.length) {
      delete change.doc._conflicts;
    }
  }
  return change;
}

Changes$2.prototype.validateChanges = function (opts) {
  var callback = opts.complete;
  var self = this;

  /* istanbul ignore else */
  if (PouchDB$5._changesFilterPlugin) {
    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {
      if (err) {
        return callback(err);
      }
      self.doChanges(opts);
    });
  } else {
    self.doChanges(opts);
  }
};

Changes$2.prototype.doChanges = function (opts) {
  var self = this;
  var callback = opts.complete;

  opts = clone(opts);
  if ('live' in opts && !('continuous' in opts)) {
    opts.continuous = opts.live;
  }
  opts.processChange = processChange;

  if (opts.since === 'latest') {
    opts.since = 'now';
  }
  if (!opts.since) {
    opts.since = 0;
  }
  if (opts.since === 'now') {
    this.db.info().then(function (info) {
      /* istanbul ignore if */
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      opts.since = info.update_seq;
      self.doChanges(opts);
    }, callback);
    return;
  }

  /* istanbul ignore else */
  if (PouchDB$5._changesFilterPlugin) {
    PouchDB$5._changesFilterPlugin.normalize(opts);
    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {
      return PouchDB$5._changesFilterPlugin.filter(this, opts);
    }
  } else {
    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
      if (key in opts) {
        guardedConsole('warn',
          'The "' + key + '" option was passed in to changes/replicate, ' +
          'but pouchdb-changes-filter plugin is not installed, so it ' +
          'was ignored. Please install the plugin to enable filtering.'
        );
      }
    });
  }

  if (!('descending' in opts)) {
    opts.descending = false;
  }

  // 0 and 1 should return 1 document
  opts.limit = opts.limit === 0 ? 1 : opts.limit;
  opts.complete = callback;
  var newPromise = this.db._changes(opts);
  /* istanbul ignore else */
  if (newPromise && typeof newPromise.cancel === 'function') {
    var cancel = self.cancel;
    self.cancel = getArguments(function (args) {
      newPromise.cancel();
      cancel.apply(this, args);
    });
  }
};

/*
 * A generic pouch adapter
 */

function compare(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
function yankError(callback, docId) {
  return function (err, results) {
    if (err || (results[0] && results[0].error)) {
      err = err || results[0];
      err.docId = docId;
      callback(err);
    } else {
      callback(null, results.length ? results[0]  : results);
    }
  };
}

// clean docs given to us by the user
function cleanDocs(docs) {
  for (var i = 0; i < docs.length; i++) {
    var doc = docs[i];
    if (doc._deleted) {
      delete doc._attachments; // ignore atts for deleted docs
    } else if (doc._attachments) {
      // filter out extraneous keys from _attachments
      var atts = Object.keys(doc._attachments);
      for (var j = 0; j < atts.length; j++) {
        var att = atts[j];
        doc._attachments[att] = pick(doc._attachments[att],
          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
      }
    }
  }
}

// compare two docs, first by _id then by _rev
function compareByIdThenRev(a, b) {
  var idCompare = compare(a._id, b._id);
  if (idCompare !== 0) {
    return idCompare;
  }
  var aStart = a._revisions ? a._revisions.start : 0;
  var bStart = b._revisions ? b._revisions.start : 0;
  return compare(aStart, bStart);
}

// for every node in a revision tree computes its distance from the closest
// leaf
function computeHeight(revs) {
  var height = {};
  var edges = [];
  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
    var rev$$1 = pos + "-" + id;
    if (isLeaf) {
      height[rev$$1] = 0;
    }
    if (prnt !== undefined) {
      edges.push({from: prnt, to: rev$$1});
    }
    return rev$$1;
  });

  edges.reverse();
  edges.forEach(function (edge) {
    if (height[edge.from] === undefined) {
      height[edge.from] = 1 + height[edge.to];
    } else {
      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
    }
  });
  return height;
}

function allDocsKeysQuery(api, opts, callback) {
  var keys =  ('limit' in opts) ?
      opts.keys.slice(opts.skip, opts.limit + opts.skip) :
      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
  if (opts.descending) {
    keys.reverse();
  }
  if (!keys.length) {
    return api._allDocs({limit: 0}, callback);
  }
  var finalResults = {
    offset: opts.skip
  };
  return PouchPromise$1.all(keys.map(function (key) {
    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);
    ['limit', 'skip', 'keys'].forEach(function (optKey) {
      delete subOpts[optKey];
    });
    return new PouchPromise$1(function (resolve, reject) {
      api._allDocs(subOpts, function (err, res) {
        /* istanbul ignore if */
        if (err) {
          return reject(err);
        }
        finalResults.total_rows = res.total_rows;
        resolve(res.rows[0] || {key: key, error: 'not_found'});
      });
    });
  })).then(function (results) {
    finalResults.rows = results;
    return finalResults;
  });
}

// all compaction is done in a queue, to avoid attaching
// too many listeners at once
function doNextCompaction(self) {
  var task = self._compactionQueue[0];
  var opts = task.opts;
  var callback = task.callback;
  self.get('_local/compaction')["catch"](function () {
    return false;
  }).then(function (doc) {
    if (doc && doc.last_seq) {
      opts.last_seq = doc.last_seq;
    }
    self._compact(opts, function (err, res) {
      /* istanbul ignore if */
      if (err) {
        callback(err);
      } else {
        callback(null, res);
      }
      nextTick(function () {
        self._compactionQueue.shift();
        if (self._compactionQueue.length) {
          doNextCompaction(self);
        }
      });
    });
  });
}

function attachmentNameError(name) {
  if (name.charAt(0) === '_') {
    return name + ' is not a valid attachment name, attachment ' +
      'names cannot start with \'_\'';
  }
  return false;
}

inherits(AbstractPouchDB, events.EventEmitter);

function AbstractPouchDB() {
  events.EventEmitter.call(this);
}

AbstractPouchDB.prototype.post =
  adapterFun('post', function (doc, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return callback(createError(NOT_AN_OBJECT));
  }
  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));
});

AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return cb(createError(NOT_AN_OBJECT));
  }
  invalidIdError(doc._id);
  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
    if (doc._deleted) {
      return this._removeLocal(doc, cb);
    } else {
      return this._putLocal(doc, cb);
    }
  }
  var self = this;
  if (opts.force && doc._rev) {
    transformForceOptionToNewEditsOption();
    putDoc(function (err) {
      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};
      cb(err, result);
    });
  } else {
    putDoc(cb);
  }

  function transformForceOptionToNewEditsOption() {
    var parts = doc._rev.split('-');
    var oldRevId = parts[1];
    var oldRevNum = parseInt(parts[0], 10);

    var newRevNum = oldRevNum + 1;
    var newRevId = rev();

    doc._revisions = {
      start: newRevNum,
      ids: [newRevId, oldRevId]
    };
    doc._rev = newRevNum + '-' + newRevId;
    opts.new_edits = false;
  }
  function putDoc(next) {
    if (typeof self._put === 'function' && opts.new_edits !== false) {
      self._put(doc, opts, next);
    } else {
      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));
    }
  }
});

AbstractPouchDB.prototype.putAttachment =
  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,
                                              blob, type) {
  var api = this;
  if (typeof type === 'function') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
  /* istanbul ignore if */
  if (typeof type === 'undefined') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  if (!type) {
    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
  }

  function createAttachment(doc) {
    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
    doc._attachments = doc._attachments || {};
    doc._attachments[attachmentId] = {
      content_type: type,
      data: blob,
      revpos: ++prevrevpos
    };
    return api.put(doc);
  }

  return api.get(docId).then(function (doc) {
    if (doc._rev !== rev$$1) {
      throw createError(REV_CONFLICT);
    }

    return createAttachment(doc);
  }, function (err) {
     // create new doc
    /* istanbul ignore else */
    if (err.reason === MISSING_DOC.message) {
      return createAttachment({_id: docId});
    } else {
      throw err;
    }
  });
});

AbstractPouchDB.prototype.removeAttachment =
  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,
                                                 callback) {
  var self = this;
  self.get(docId, function (err, obj) {
    /* istanbul ignore if */
    if (err) {
      callback(err);
      return;
    }
    if (obj._rev !== rev$$1) {
      callback(createError(REV_CONFLICT));
      return;
    }
    /* istanbul ignore if */
    if (!obj._attachments) {
      return callback();
    }
    delete obj._attachments[attachmentId];
    if (Object.keys(obj._attachments).length === 0) {
      delete obj._attachments;
    }
    self.put(obj, callback);
  });
});

AbstractPouchDB.prototype.remove =
  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
  var doc;
  if (typeof optsOrRev === 'string') {
    // id, rev, opts, callback style
    doc = {
      _id: docOrId,
      _rev: optsOrRev
    };
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
  } else {
    // doc, opts, callback style
    doc = docOrId;
    if (typeof optsOrRev === 'function') {
      callback = optsOrRev;
      opts = {};
    } else {
      callback = opts;
      opts = optsOrRev;
    }
  }
  opts = opts || {};
  opts.was_delete = true;
  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
  newDoc._deleted = true;
  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
    return this._removeLocal(doc, callback);
  }
  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));
});

AbstractPouchDB.prototype.revsDiff =
  adapterFun('revsDiff', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  var ids = Object.keys(req);

  if (!ids.length) {
    return callback(null, {});
  }

  var count = 0;
  var missing = new ExportedMap();

  function addToMissing(id, revId) {
    if (!missing.has(id)) {
      missing.set(id, {missing: []});
    }
    missing.get(id).missing.push(revId);
  }

  function processDoc(id, rev_tree) {
    // Is this fast enough? Maybe we should switch to a set simulated by a map
    var missingForId = req[id].slice(0);
    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
      opts) {
        var rev$$1 = pos + '-' + revHash;
        var idx = missingForId.indexOf(rev$$1);
        if (idx === -1) {
          return;
        }

        missingForId.splice(idx, 1);
        /* istanbul ignore if */
        if (opts.status !== 'available') {
          addToMissing(id, rev$$1);
        }
      });

    // Traversing the tree is synchronous, so now `missingForId` contains
    // revisions that were not found in the tree
    missingForId.forEach(function (rev$$1) {
      addToMissing(id, rev$$1);
    });
  }

  ids.map(function (id) {
    this._getRevisionTree(id, function (err, rev_tree) {
      if (err && err.status === 404 && err.message === 'missing') {
        missing.set(id, {missing: req[id]});
      } else if (err) {
        /* istanbul ignore next */
        return callback(err);
      } else {
        processDoc(id, rev_tree);
      }

      if (++count === ids.length) {
        // convert LazyMap to object
        var missingObj = {};
        missing.forEach(function (value, key) {
          missingObj[key] = value;
        });
        return callback(null, missingObj);
      }
    });
  }, this);
});

// _bulk_get API for faster replication, as described in
// https://github.com/apache/couchdb-chttpd/pull/33
// At the "abstract" level, it will just run multiple get()s in
// parallel, because this isn't much of a performance cost
// for local databases (except the cost of multiple transactions, which is
// small). The http adapter overrides this in order
// to do a more efficient single HTTP request.
AbstractPouchDB.prototype.bulkGet =
  adapterFun('bulkGet', function (opts, callback) {
  bulkGet(this, opts, callback);
});

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
AbstractPouchDB.prototype.compactDocument =
  adapterFun('compactDocument', function (docId, maxHeight, callback) {
  var self = this;
  this._getRevisionTree(docId, function (err, revTree) {
    /* istanbul ignore if */
    if (err) {
      return callback(err);
    }
    var height = computeHeight(revTree);
    var candidates = [];
    var revs = [];
    Object.keys(height).forEach(function (rev$$1) {
      if (height[rev$$1] > maxHeight) {
        candidates.push(rev$$1);
      }
    });

    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
      var rev$$1 = pos + '-' + revHash;
      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {
        revs.push(rev$$1);
      }
    });
    self._doCompaction(docId, revs, callback);
  });
});

// compact the whole database using single document
// compaction
AbstractPouchDB.prototype.compact =
  adapterFun('compact', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  opts = opts || {};

  self._compactionQueue = self._compactionQueue || [];
  self._compactionQueue.push({opts: opts, callback: callback});
  if (self._compactionQueue.length === 1) {
    doNextCompaction(self);
  }
});
AbstractPouchDB.prototype._compact = function (opts, callback) {
  var self = this;
  var changesOpts = {
    return_docs: false,
    last_seq: opts.last_seq || 0
  };
  var promises = [];

  function onChange(row) {
    promises.push(self.compactDocument(row.id, 0));
  }
  function onComplete(resp) {
    var lastSeq = resp.last_seq;
    PouchPromise$1.all(promises).then(function () {
      return upsert(self, '_local/compaction', function deltaFunc(doc) {
        if (!doc.last_seq || doc.last_seq < lastSeq) {
          doc.last_seq = lastSeq;
          return doc;
        }
        return false; // somebody else got here first, don't update
      });
    }).then(function () {
      callback(null, {ok: true});
    })["catch"](callback);
  }
  self.changes(changesOpts)
    .on('change', onChange)
    .on('complete', onComplete)
    .on('error', callback);
};

/* Begin api wrappers. Specific functionality to storage belongs in the
   _[method] */
AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof id !== 'string') {
    return cb(createError(INVALID_ID));
  }
  if (isLocalId(id) && typeof this._getLocal === 'function') {
    return this._getLocal(id, cb);
  }
  var leaves = [], self = this;

  function finishOpenRevs() {
    var result = [];
    var count = leaves.length;
    /* istanbul ignore if */
    if (!count) {
      return cb(null, result);
    }

    // order with open_revs is unspecified
    leaves.forEach(function (leaf) {
      self.get(id, {
        rev: leaf,
        revs: opts.revs,
        latest: opts.latest,
        attachments: opts.attachments
      }, function (err, doc) {
        if (!err) {
          // using latest=true can produce duplicates
          var existing;
          for (var i = 0, l = result.length; i < l; i++) {
            if (result[i].ok && result[i].ok._rev === doc._rev) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            result.push({ok: doc});
          }
        } else {
          result.push({missing: leaf});
        }
        count--;
        if (!count) {
          cb(null, result);
        }
      });
    });
  }

  if (opts.open_revs) {
    if (opts.open_revs === "all") {
      this._getRevisionTree(id, function (err, rev_tree) {
        if (err) {
          return cb(err);
        }
        leaves = collectLeaves(rev_tree).map(function (leaf) {
          return leaf.rev;
        });
        finishOpenRevs();
      });
    } else {
      if (Array.isArray(opts.open_revs)) {
        leaves = opts.open_revs;
        for (var i = 0; i < leaves.length; i++) {
          var l = leaves[i];
          // looks like it's the only thing couchdb checks
          if (!(typeof (l) === "string" && /^\d+-/.test(l))) {
            return cb(createError(INVALID_REV));
          }
        }
        finishOpenRevs();
      } else {
        return cb(createError(UNKNOWN_ERROR, 'function_clause'));
      }
    }
    return; // open_revs does not like other options
  }

  return this._get(id, opts, function (err, result) {
    if (err) {
      err.docId = id;
      return cb(err);
    }

    var doc = result.doc;
    var metadata = result.metadata;
    var ctx = result.ctx;

    if (opts.conflicts) {
      var conflicts = collectConflicts(metadata);
      if (conflicts.length) {
        doc._conflicts = conflicts;
      }
    }

    if (isDeleted(metadata, doc._rev)) {
      doc._deleted = true;
    }

    if (opts.revs || opts.revs_info) {
      var splittedRev = doc._rev.split('-');
      var revNo       = parseInt(splittedRev[0], 10);
      var revHash     = splittedRev[1];

      var paths = rootToLeaf(metadata.rev_tree);
      var path = null;

      for (var i = 0; i < paths.length; i++) {
        var currentPath = paths[i];
        var hashIndex = currentPath.ids.map(function (x) { return x.id; })
          .indexOf(revHash);
        var hashFoundAtRevPos = hashIndex === (revNo - 1);

        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {
          path = currentPath;
        }
      }

      var indexOfRev = path.ids.map(function (x) { return x.id; })
        .indexOf(doc._rev.split('-')[1]) + 1;
      var howMany = path.ids.length - indexOfRev;
      path.ids.splice(indexOfRev, howMany);
      path.ids.reverse();

      if (opts.revs) {
        doc._revisions = {
          start: (path.pos + path.ids.length) - 1,
          ids: path.ids.map(function (rev$$1) {
            return rev$$1.id;
          })
        };
      }
      if (opts.revs_info) {
        var pos =  path.pos + path.ids.length;
        doc._revs_info = path.ids.map(function (rev$$1) {
          pos--;
          return {
            rev: pos + '-' + rev$$1.id,
            status: rev$$1.opts.status
          };
        });
      }
    }

    if (opts.attachments && doc._attachments) {
      var attachments = doc._attachments;
      var count = Object.keys(attachments).length;
      if (count === 0) {
        return cb(null, doc);
      }
      Object.keys(attachments).forEach(function (key) {
        this._getAttachment(doc._id, key, attachments[key], {
          // Previously the revision handling was done in adapter.js
          // getAttachment, however since idb-next doesnt we need to
          // pass the rev through
          rev: doc._rev,
          binary: opts.binary,
          ctx: ctx
        }, function (err, data) {
          var att = doc._attachments[key];
          att.data = data;
          delete att.stub;
          delete att.length;
          if (!--count) {
            cb(null, doc);
          }
        });
      }, self);
    } else {
      if (doc._attachments) {
        for (var key in doc._attachments) {
          /* istanbul ignore else */
          if (doc._attachments.hasOwnProperty(key)) {
            doc._attachments[key].stub = true;
          }
        }
      }
      cb(null, doc);
    }
  });
});

// TODO: I dont like this, it forces an extra read for every
// attachment read and enforces a confusing api between
// adapter.js and the adapter implementation
AbstractPouchDB.prototype.getAttachment =
  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
  var self = this;
  if (opts instanceof Function) {
    callback = opts;
    opts = {};
  }
  this._get(docId, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (res.doc._attachments && res.doc._attachments[attachmentId]) {
      opts.ctx = res.ctx;
      opts.binary = true;
      self._getAttachment(docId, attachmentId,
                          res.doc._attachments[attachmentId], opts, callback);
    } else {
      return callback(createError(MISSING_DOC));
    }
  });
});

AbstractPouchDB.prototype.allDocs =
  adapterFun('allDocs', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
  if (opts.start_key) {
    opts.startkey = opts.start_key;
  }
  if (opts.end_key) {
    opts.endkey = opts.end_key;
  }
  if ('keys' in opts) {
    if (!Array.isArray(opts.keys)) {
      return callback(new TypeError('options.keys must be an array'));
    }
    var incompatibleOpt =
      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
      return incompatibleOpt in opts;
    })[0];
    if (incompatibleOpt) {
      callback(createError(QUERY_PARSE_ERROR,
        'Query parameter `' + incompatibleOpt +
        '` is not compatible with multi-get'
      ));
      return;
    }
    if (!isRemote(this)) {
      return allDocsKeysQuery(this, opts, callback);
    }
  }

  return this._allDocs(opts, callback);
});

AbstractPouchDB.prototype.changes = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return new Changes$2(this, opts, callback);
};

AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
  this._closed = true;
  this.emit('closed');
  return this._close(callback);
});

AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
  var self = this;
  this._info(function (err, info) {
    if (err) {
      return callback(err);
    }
    // assume we know better than the adapter, unless it informs us
    info.db_name = info.db_name || self.name;
    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
    info.adapter = self.adapter;
    callback(null, info);
  });
});

AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
  return this._id(callback);
});

/* istanbul ignore next */
AbstractPouchDB.prototype.type = function () {
  return (typeof this._type === 'function') ? this._type() : this.adapter;
};

AbstractPouchDB.prototype.bulkDocs =
  adapterFun('bulkDocs', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  if (Array.isArray(req)) {
    req = {
      docs: req
    };
  }

  if (!req || !req.docs || !Array.isArray(req.docs)) {
    return callback(createError(MISSING_BULK_DOCS));
  }

  for (var i = 0; i < req.docs.length; ++i) {
    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
      return callback(createError(NOT_AN_OBJECT));
    }
  }

  var attachmentError;
  req.docs.forEach(function (doc) {
    if (doc._attachments) {
      Object.keys(doc._attachments).forEach(function (name) {
        attachmentError = attachmentError || attachmentNameError(name);
        if (!doc._attachments[name].content_type) {
          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
        }
      });
    }
  });

  if (attachmentError) {
    return callback(createError(BAD_REQUEST, attachmentError));
  }

  if (!('new_edits' in opts)) {
    if ('new_edits' in req) {
      opts.new_edits = req.new_edits;
    } else {
      opts.new_edits = true;
    }
  }

  var adapter = this;
  if (!opts.new_edits && !isRemote(adapter)) {
    // ensure revisions of the same doc are sorted, so that
    // the local adapter processes them correctly (#2935)
    req.docs.sort(compareByIdThenRev);
  }

  cleanDocs(req.docs);

  // in the case of conflicts, we want to return the _ids to the user
  // however, the underlying adapter may destroy the docs array, so
  // create a copy here
  var ids = req.docs.map(function (doc) {
    return doc._id;
  });

  return this._bulkDocs(req, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (!opts.new_edits) {
      // this is what couch does when new_edits is false
      res = res.filter(function (x) {
        return x.error;
      });
    }
    // add ids for error/conflict responses (not required for CouchDB)
    if (!isRemote(adapter)) {
      for (var i = 0, l = res.length; i < l; i++) {
        res[i].id = res[i].id || ids[i];
      }
    }

    callback(null, res);
  });
});

AbstractPouchDB.prototype.registerDependentDatabase =
  adapterFun('registerDependentDatabase', function (dependentDb,
                                                          callback) {
  var depDB = new this.constructor(dependentDb, this.__opts);

  function diffFun(doc) {
    doc.dependentDbs = doc.dependentDbs || {};
    if (doc.dependentDbs[dependentDb]) {
      return false; // no update required
    }
    doc.dependentDbs[dependentDb] = true;
    return doc;
  }
  upsert(this, '_local/_pouch_dependentDbs', diffFun)
    .then(function () {
      callback(null, {db: depDB});
    })["catch"](callback);
});

AbstractPouchDB.prototype.destroy =
  adapterFun('destroy', function (opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

  function destroyDb() {
    // call destroy method of the particular adaptor
    self._destroy(opts, function (err, resp) {
      if (err) {
        return callback(err);
      }
      self._destroyed = true;
      self.emit('destroyed');
      callback(null, resp || { 'ok': true });
    });
  }

  if (isRemote(self)) {
    // no need to check for dependent DBs if it's a remote DB
    return destroyDb();
  }

  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
    if (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        return callback(err);
      } else { // no dependencies
        return destroyDb();
      }
    }
    var dependentDbs = localDoc.dependentDbs;
    var PouchDB = self.constructor;
    var deletedMap = Object.keys(dependentDbs).map(function (name) {
      // use_prefix is only false in the browser
      /* istanbul ignore next */
      var trueName = usePrefix ?
        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
      return new PouchDB(trueName, self.__opts).destroy();
    });
    PouchPromise$1.all(deletedMap).then(destroyDb, callback);
  });
});

function TaskQueue$1() {
  this.isReady = false;
  this.failed = false;
  this.queue = [];
}

TaskQueue$1.prototype.execute = function () {
  var fun;
  if (this.failed) {
    while ((fun = this.queue.shift())) {
      fun(this.failed);
    }
  } else {
    while ((fun = this.queue.shift())) {
      fun();
    }
  }
};

TaskQueue$1.prototype.fail = function (err) {
  this.failed = err;
  this.execute();
};

TaskQueue$1.prototype.ready = function (db) {
  this.isReady = true;
  this.db = db;
  this.execute();
};

TaskQueue$1.prototype.addTask = function (fun) {
  this.queue.push(fun);
  if (this.failed) {
    this.execute();
  }
};

function parseAdapter(name, opts) {
  var match = name.match(/([a-z-]*):\/\/(.*)/);
  if (match) {
    // the http adapter expects the fully qualified name
    return {
      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
      adapter: match[1]
    };
  }

  var adapters = PouchDB$5.adapters;
  var preferredAdapters = PouchDB$5.preferredAdapters;
  var prefix = PouchDB$5.prefix;
  var adapterName = opts.adapter;

  if (!adapterName) { // automatically determine adapter
    for (var i = 0; i < preferredAdapters.length; ++i) {
      adapterName = preferredAdapters[i];
      // check for browsers that have been upgraded from websql-only to websql+idb
      /* istanbul ignore if */
      if (adapterName === 'idb' && 'websql' in adapters &&
          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
        // log it, because this can be confusing during development
        guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' +
          ' avoid data loss, because it was already opened with WebSQL.');
        continue; // keep using websql to avoid user data loss
      }
      break;
    }
  }

  var adapter = adapters[adapterName];

  // if adapter is invalid, then an error will be thrown later
  var usePrefix = (adapter && 'use_prefix' in adapter) ?
    adapter.use_prefix : true;

  return {
    name: usePrefix ? (prefix + name) : name,
    adapter: adapterName
  };
}

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
function prepareForDestruction(self) {

  function onDestroyed(from_constructor) {
    self.removeListener('closed', onClosed);
    if (!from_constructor) {
      self.constructor.emit('destroyed', self.name);
    }
  }

  function onClosed() {
    self.removeListener('destroyed', onDestroyed);
    self.constructor.emit('unref', self);
  }

  self.once('destroyed', onDestroyed);
  self.once('closed', onClosed);
  self.constructor.emit('ref', self);
}

inherits(PouchDB$5, AbstractPouchDB);
function PouchDB$5(name, opts) {
  // In Node our test suite only tests this for PouchAlt unfortunately
  /* istanbul ignore if */
  if (!(this instanceof PouchDB$5)) {
    return new PouchDB$5(name, opts);
  }

  var self = this;
  opts = opts || {};

  if (name && typeof name === 'object') {
    opts = name;
    name = opts.name;
    delete opts.name;
  }

  this.__opts = opts = clone(opts);

  self.auto_compaction = opts.auto_compaction;
  self.prefix = PouchDB$5.prefix;

  if (typeof name !== 'string') {
    throw new Error('Missing/invalid DB name');
  }

  var prefixedName = (opts.prefix || '') + name;
  var backend = parseAdapter(prefixedName, opts);

  opts.name = backend.name;
  opts.adapter = opts.adapter || backend.adapter;

  self.name = name;
  self._adapter = opts.adapter;
  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

  if (!PouchDB$5.adapters[opts.adapter] ||
      !PouchDB$5.adapters[opts.adapter].valid()) {
    throw new Error('Invalid Adapter: ' + opts.adapter);
  }

  AbstractPouchDB.call(self);
  self.taskqueue = new TaskQueue$1();

  self.adapter = opts.adapter;

  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {
    if (err) {
      return self.taskqueue.fail(err);
    }
    prepareForDestruction(self);

    self.emit('created', self);
    PouchDB$5.emit('created', self.name);
    self.taskqueue.ready(self);
  });

}

PouchDB$5.adapters = {};
PouchDB$5.preferredAdapters = [];

PouchDB$5.prefix = '_pouch_';

var eventEmitter = new events.EventEmitter();

function setUpEventEmitter(Pouch) {
  Object.keys(events.EventEmitter.prototype).forEach(function (key) {
    if (typeof events.EventEmitter.prototype[key] === 'function') {
      Pouch[key] = eventEmitter[key].bind(eventEmitter);
    }
  });

  // these are created in constructor.js, and allow us to notify each DB with
  // the same name that it was destroyed, via the constructor object
  var destructListeners = Pouch._destructionListeners = new ExportedMap();

  Pouch.on('ref', function onConstructorRef(db) {
    if (!destructListeners.has(db.name)) {
      destructListeners.set(db.name, []);
    }
    destructListeners.get(db.name).push(db);
  });

  Pouch.on('unref', function onConstructorUnref(db) {
    if (!destructListeners.has(db.name)) {
      return;
    }
    var dbList = destructListeners.get(db.name);
    var pos = dbList.indexOf(db);
    if (pos < 0) {
      /* istanbul ignore next */
      return;
    }
    dbList.splice(pos, 1);
    if (dbList.length > 1) {
      /* istanbul ignore next */
      destructListeners.set(db.name, dbList);
    } else {
      destructListeners["delete"](db.name);
    }
  });

  Pouch.on('destroyed', function onConstructorDestroyed(name) {
    if (!destructListeners.has(name)) {
      return;
    }
    var dbList = destructListeners.get(name);
    destructListeners["delete"](name);
    dbList.forEach(function (db) {
      db.emit('destroyed',true);
    });
  });
}

setUpEventEmitter(PouchDB$5);

PouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {
  /* istanbul ignore else */
  if (obj.valid()) {
    PouchDB$5.adapters[id] = obj;
    if (addToPreferredAdapters) {
      PouchDB$5.preferredAdapters.push(id);
    }
  }
};

PouchDB$5.plugin = function (obj) {
  if (typeof obj === 'function') { // function style for plugins
    obj(PouchDB$5);
  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
    throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
  } else {
    Object.keys(obj).forEach(function (id) { // object style for plugins
      PouchDB$5.prototype[id] = obj[id];
    });
  }
  if (this.__defaults) {
    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);
  }
  return PouchDB$5;
};

PouchDB$5.defaults = function (defaultOpts) {
  function PouchAlt(name, opts) {
    if (!(this instanceof PouchAlt)) {
      return new PouchAlt(name, opts);
    }

    opts = opts || {};

    if (name && typeof name === 'object') {
      opts = name;
      name = opts.name;
      delete opts.name;
    }

    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
    PouchDB$5.call(this, name, opts);
  }

  inherits(PouchAlt, PouchDB$5);

  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();
  Object.keys(PouchDB$5).forEach(function (key) {
    if (!(key in PouchAlt)) {
      PouchAlt[key] = PouchDB$5[key];
    }
  });

  // make default options transitive
  // https://github.com/pouchdb/pouchdb/issues/5922
  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);

  return PouchAlt;
};

// managed automatically by set-version.js
var version = "6.3.2";

function debugPouch(PouchDB) {
  PouchDB.debug = debug;
  var logs = {};
  /* istanbul ignore next */
  PouchDB.on('debug', function (args) {
    // first argument is log identifier
    var logId = args[0];
    // rest should be passed verbatim to debug module
    var logArgs = args.slice(1);
    if (!logs[logId]) {
      logs[logId] = debug('pouchdb:' + logId);
    }
    logs[logId].apply(null, logArgs);
  });
}

// this would just be "return doc[field]", but fields
// can be "deep" due to dot notation
function getFieldFromDoc(doc, parsedField) {
  var value = doc;
  for (var i = 0, len = parsedField.length; i < len; i++) {
    var key = parsedField[i];
    value = value[key];
    if (!value) {
      break;
    }
  }
  return value;
}

function compare$1(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Converts a string in dot notation to an array of its components, with backslash escaping
function parseField(fieldName) {
  // fields may be deep (e.g. "foo.bar.baz"), so parse
  var fields = [];
  var current = '';
  for (var i = 0, len = fieldName.length; i < len; i++) {
    var ch = fieldName[i];
    if (ch === '.') {
      if (i > 0 && fieldName[i - 1] === '\\') { // escaped delimiter
        current = current.substring(0, current.length - 1) + '.';
      } else { // not escaped, so delimiter
        fields.push(current);
        current = '';
      }
    } else { // normal character
      current += ch;
    }
  }
  fields.push(current);
  return fields;
}

var combinationFields = ['$or', '$nor', '$not'];
function isCombinationalField(field) {
  return combinationFields.indexOf(field) > -1;
}

function getKey(obj) {
  return Object.keys(obj)[0];
}

function getValue(obj) {
  return obj[getKey(obj)];
}


// flatten an array of selectors joined by an $and operator
function mergeAndedSelectors(selectors) {

  // sort to ensure that e.g. if the user specified
  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
  // just {$gt: 'b'}
  var res = {};

  selectors.forEach(function (selector) {
    Object.keys(selector).forEach(function (field) {
      var matcher = selector[field];
      if (typeof matcher !== 'object') {
        matcher = {$eq: matcher};
      }

      if (isCombinationalField(field)) {
        if (matcher instanceof Array) {
          res[field] = matcher.map(function (m) {
            return mergeAndedSelectors([m]);
          });
        } else {
          res[field] = mergeAndedSelectors([matcher]);
        }
      } else {
        var fieldMatchers = res[field] = res[field] || {};
        Object.keys(matcher).forEach(function (operator) {
          var value = matcher[operator];

          if (operator === '$gt' || operator === '$gte') {
            return mergeGtGte(operator, value, fieldMatchers);
          } else if (operator === '$lt' || operator === '$lte') {
            return mergeLtLte(operator, value, fieldMatchers);
          } else if (operator === '$ne') {
            return mergeNe(value, fieldMatchers);
          } else if (operator === '$eq') {
            return mergeEq(value, fieldMatchers);
          }
          fieldMatchers[operator] = value;
        });
      }
    });
  });

  return res;
}



// collapse logically equivalent gt/gte values
function mergeGtGte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$gte !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gte) { // more specificity
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value >= fieldMatchers.$gte) { // more specificity
        delete fieldMatchers.$gte;
        fieldMatchers.$gt = value;
      }
    }
  } else if (typeof fieldMatchers.$gt !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gt) { // more specificity
        delete fieldMatchers.$gt;
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value > fieldMatchers.$gt) { // more specificity
        fieldMatchers.$gt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// collapse logically equivalent lt/lte values
function mergeLtLte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$lte !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lte) { // more specificity
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value <= fieldMatchers.$lte) { // more specificity
        delete fieldMatchers.$lte;
        fieldMatchers.$lt = value;
      }
    }
  } else if (typeof fieldMatchers.$lt !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lt) { // more specificity
        delete fieldMatchers.$lt;
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value < fieldMatchers.$lt) { // more specificity
        fieldMatchers.$lt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// combine $ne values into one array
function mergeNe(value, fieldMatchers) {
  if ('$ne' in fieldMatchers) {
    // there are many things this could "not" be
    fieldMatchers.$ne.push(value);
  } else { // doesn't exist yet
    fieldMatchers.$ne = [value];
  }
}

// add $eq into the mix
function mergeEq(value, fieldMatchers) {
  // these all have less specificity than the $eq
  // TODO: check for user errors here
  delete fieldMatchers.$gt;
  delete fieldMatchers.$gte;
  delete fieldMatchers.$lt;
  delete fieldMatchers.$lte;
  delete fieldMatchers.$ne;
  fieldMatchers.$eq = value;
}


//
// normalize the selector
//
function massageSelector(input) {
  var result = clone(input);
  var wasAnded = false;
  if ('$and' in result) {
    result = mergeAndedSelectors(result['$and']);
    wasAnded = true;
  }

  ['$or', '$nor'].forEach(function (orOrNor) {
    if (orOrNor in result) {
      // message each individual selector
      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
      result[orOrNor].forEach(function (subSelector) {
        var fields = Object.keys(subSelector);
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var matcher = subSelector[field];
          if (typeof matcher !== 'object' || matcher === null) {
            subSelector[field] = {$eq: matcher};
          }
        }
      });
    }
  });

  if ('$not' in result) {
    //This feels a little like forcing, but it will work for now,
    //I would like to come back to this and make the merging of selectors a little more generic
    result['$not'] = mergeAndedSelectors([result['$not']]);
  }

  var fields = Object.keys(result);

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var matcher = result[field];

    if (typeof matcher !== 'object' || matcher === null) {
      matcher = {$eq: matcher};
    } else if ('$ne' in matcher && !wasAnded) {
      // I put these in an array, since there may be more than one
      // but in the "mergeAnded" operation, I already take care of that
      matcher.$ne = [matcher.$ne];
    }
    result[field] = matcher;
  }

  return result;
}

function pad(str, padWith, upToLength) {
  var padding = '';
  var targetLength = upToLength - str.length;
  /* istanbul ignore next */
  while (padding.length < targetLength) {
    padding += padWith;
  }
  return padding;
}

function padLeft(str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return padding + str;
}

var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
var MAGNITUDE_DIGITS = 3; // ditto
var SEP = ''; // set to '_' for easier debugging 

function collate(a, b) {

  if (a === b) {
    return 0;
  }

  a = normalizeKey(a);
  b = normalizeKey(b);

  var ai = collationIndex(a);
  var bi = collationIndex(b);
  if ((ai - bi) !== 0) {
    return ai - bi;
  }
  switch (typeof a) {
    case 'number':
      return a - b;
    case 'boolean':
      return a < b ? -1 : 1;
    case 'string':
      return stringCollate(a, b);
  }
  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
}

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
function normalizeKey(key) {
  switch (typeof key) {
    case 'undefined':
      return null;
    case 'number':
      if (key === Infinity || key === -Infinity || isNaN(key)) {
        return null;
      }
      return key;
    case 'object':
      var origKey = key;
      if (Array.isArray(key)) {
        var len = key.length;
        key = new Array(len);
        for (var i = 0; i < len; i++) {
          key[i] = normalizeKey(origKey[i]);
        }
      /* istanbul ignore next */
      } else if (key instanceof Date) {
        return key.toJSON();
      } else if (key !== null) { // generic object
        key = {};
        for (var k in origKey) {
          if (origKey.hasOwnProperty(k)) {
            var val = origKey[k];
            if (typeof val !== 'undefined') {
              key[k] = normalizeKey(val);
            }
          }
        }
      }
  }
  return key;
}

function indexify(key) {
  if (key !== null) {
    switch (typeof key) {
      case 'boolean':
        return key ? 1 : 0;
      case 'number':
        return numToIndexableString(key);
      case 'string':
        // We've to be sure that key does not contain \u0000
        // Do order-preserving replacements:
        // 0 -> 1, 1
        // 1 -> 1, 2
        // 2 -> 2, 2
        return key
          .replace(/\u0002/g, '\u0002\u0002')
          .replace(/\u0001/g, '\u0001\u0002')
          .replace(/\u0000/g, '\u0001\u0001');
      case 'object':
        var isArray = Array.isArray(key);
        var arr = isArray ? key : Object.keys(key);
        var i = -1;
        var len = arr.length;
        var result = '';
        if (isArray) {
          while (++i < len) {
            result += toIndexableString(arr[i]);
          }
        } else {
          while (++i < len) {
            var objKey = arr[i];
            result += toIndexableString(objKey) +
                toIndexableString(key[objKey]);
          }
        }
        return result;
    }
  }
  return '';
}

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
function toIndexableString(key) {
  var zero = '\u0000';
  key = normalizeKey(key);
  return collationIndex(key) + SEP + indexify(key) + zero;
}

function parseNumber(str, i) {
  var originalIdx = i;
  var num;
  var zero = str[i] === '1';
  if (zero) {
    num = 0;
    i++;
  } else {
    var neg = str[i] === '0';
    i++;
    var numAsString = '';
    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
    /* istanbul ignore next */
    if (neg) {
      magnitude = -magnitude;
    }
    i += MAGNITUDE_DIGITS;
    while (true) {
      var ch = str[i];
      if (ch === '\u0000') {
        break;
      } else {
        numAsString += ch;
      }
      i++;
    }
    numAsString = numAsString.split('.');
    if (numAsString.length === 1) {
      num = parseInt(numAsString, 10);
    } else {
      /* istanbul ignore next */
      num = parseFloat(numAsString[0] + '.' + numAsString[1]);
    }
    /* istanbul ignore next */
    if (neg) {
      num = num - 10;
    }
    /* istanbul ignore next */
    if (magnitude !== 0) {
      // parseFloat is more reliable than pow due to rounding errors
      // e.g. Number.MAX_VALUE would return Infinity if we did
      // num * Math.pow(10, magnitude);
      num = parseFloat(num + 'e' + magnitude);
    }
  }
  return {num: num, length : i - originalIdx};
}

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
function pop(stack, metaStack) {
  var obj = stack.pop();

  if (metaStack.length) {
    var lastMetaElement = metaStack[metaStack.length - 1];
    if (obj === lastMetaElement.element) {
      // popping a meta-element, e.g. an object whose value is another object
      metaStack.pop();
      lastMetaElement = metaStack[metaStack.length - 1];
    }
    var element = lastMetaElement.element;
    var lastElementIndex = lastMetaElement.index;
    if (Array.isArray(element)) {
      element.push(obj);
    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
      var key = stack.pop();
      element[key] = obj;
    } else {
      stack.push(obj); // obj with key only
    }
  }
}

function parseIndexableString(str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;

  /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
  while (true) {
    var collationIndex = str[i++];
    if (collationIndex === '\u0000') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case '1':
        stack.push(null);
        break;
      case '2':
        stack.push(str[i] === '1');
        i++;
        break;
      case '3':
        var parsedNum = parseNumber(str, i);
        stack.push(parsedNum.num);
        i += parsedNum.length;
        break;
      case '4':
        var parsedStr = '';
        /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
        while (true) {
          var ch = str[i];
          if (ch === '\u0000') {
            break;
          }
          parsedStr += ch;
          i++;
        }
        // perform the reverse of the order-preserving replacement
        // algorithm (see above)
        parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
          .replace(/\u0001\u0002/g, '\u0001')
          .replace(/\u0002\u0002/g, '\u0002');
        stack.push(parsedStr);
        break;
      case '5':
        var arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '6':
        var objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      /* istanbul ignore next */
      default:
        throw new Error(
          'bad collationIndex or unexpectedly reached end of input: ' +
            collationIndex);
    }
  }
}

function arrayCollate(a, b) {
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; i++) {
    var sort = collate(a[i], b[i]);
    if (sort !== 0) {
      return sort;
    }
  }
  return (a.length === b.length) ? 0 :
    (a.length > b.length) ? 1 : -1;
}
function stringCollate(a, b) {
  // See: https://github.com/daleharvey/pouchdb/issues/40
  // This is incompatible with the CouchDB implementation, but its the
  // best we can do for now
  return (a === b) ? 0 : ((a > b) ? 1 : -1);
}
function objectCollate(a, b) {
  var ak = Object.keys(a), bk = Object.keys(b);
  var len = Math.min(ak.length, bk.length);
  for (var i = 0; i < len; i++) {
    // First sort the keys
    var sort = collate(ak[i], bk[i]);
    if (sort !== 0) {
      return sort;
    }
    // if the keys are equal sort the values
    sort = collate(a[ak[i]], b[bk[i]]);
    if (sort !== 0) {
      return sort;
    }

  }
  return (ak.length === bk.length) ? 0 :
    (ak.length > bk.length) ? 1 : -1;
}
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
function collationIndex(x) {
  var id = ['boolean', 'number', 'string', 'object'];
  var idx = id.indexOf(typeof x);
  //false if -1 otherwise true, but fast!!!!1
  if (~idx) {
    if (x === null) {
      return 1;
    }
    if (Array.isArray(x)) {
      return 5;
    }
    return idx < 3 ? (idx + 2) : (idx + 3);
  }
  /* istanbul ignore next */
  if (Array.isArray(x)) {
    return 5;
  }
}

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
function numToIndexableString(num) {

  if (num === 0) {
    return '1';
  }

  // convert number to exponential format for easier and
  // more succinct string sorting
  var expFormat = num.toExponential().split(/e\+?/);
  var magnitude = parseInt(expFormat[1], 10);

  var neg = num < 0;

  var result = neg ? '0' : '2';

  // first sort by magnitude
  // it's easier if all magnitudes are positive
  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

  result += SEP + magString;

  // then sort by the factor
  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
  /* istanbul ignore next */
  if (neg) { // for negative reverse ordering
    factor = 10 - factor;
  }

  var factorStr = factor.toFixed(20);

  // strip zeros from the end
  factorStr = factorStr.replace(/\.?0+$/, '');

  result += SEP + factorStr;

  return result;
}

// create a comparator based on the sort object
function createFieldSorter(sort) {

  function getFieldValuesAsArray(doc) {
    return sort.map(function (sorting) {
      var fieldName = getKey(sorting);
      var parsedField = parseField(fieldName);
      var docFieldValue = getFieldFromDoc(doc, parsedField);
      return docFieldValue;
    });
  }

  return function (aRow, bRow) {
    var aFieldValues = getFieldValuesAsArray(aRow.doc);
    var bFieldValues = getFieldValuesAsArray(bRow.doc);
    var collation = collate(aFieldValues, bFieldValues);
    if (collation !== 0) {
      return collation;
    }
    // this is what mango seems to do
    return compare$1(aRow.doc._id, bRow.doc._id);
  };
}

function filterInMemoryFields(rows, requestDef, inMemoryFields) {
  rows = rows.filter(function (row) {
    return rowFilter(row.doc, requestDef.selector, inMemoryFields);
  });

  if (requestDef.sort) {
    // in-memory sort
    var fieldSorter = createFieldSorter(requestDef.sort);
    rows = rows.sort(fieldSorter);
    if (typeof requestDef.sort[0] !== 'string' &&
        getValue(requestDef.sort[0]) === 'desc') {
      rows = rows.reverse();
    }
  }

  if ('limit' in requestDef || 'skip' in requestDef) {
    // have to do the limit in-memory
    var skip = requestDef.skip || 0;
    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
    rows = rows.slice(skip, limit);
  }
  return rows;
}

function rowFilter(doc, selector, inMemoryFields) {
  return inMemoryFields.every(function (field) {
    var matcher = selector[field];
    var parsedField = parseField(field);
    var docFieldValue = getFieldFromDoc(doc, parsedField);
    if (isCombinationalField(field)) {
      return matchCominationalSelector(field, matcher, doc);
    }

    return matchSelector(matcher, doc, parsedField, docFieldValue);
  });
}

function matchSelector(matcher, doc, parsedField, docFieldValue) {
  if (!matcher) {
    // no filtering necessary; this field is just needed for sorting
    return true;
  }

  return Object.keys(matcher).every(function (userOperator) {
    var userValue = matcher[userOperator];
    return match(userOperator, doc, userValue, parsedField, docFieldValue);
  });
}

function matchCominationalSelector(field, matcher, doc) {

  if (field === '$or') {
    return matcher.some(function (orMatchers) {
      return rowFilter(doc, orMatchers, Object.keys(orMatchers));
    });
  }

  if (field === '$not') {
    return !rowFilter(doc, matcher, Object.keys(matcher));
  }

  //`$nor`
  return !matcher.find(function (orMatchers) {
    return rowFilter(doc, orMatchers, Object.keys(orMatchers));
  });

}

function match(userOperator, doc, userValue, parsedField, docFieldValue) {
  if (!matchers[userOperator]) {
    throw new Error('unknown operator "' + userOperator +
      '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
  }
  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
}

function fieldExists(docFieldValue) {
  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
}

function fieldIsNotUndefined(docFieldValue) {
  return typeof docFieldValue !== 'undefined';
}

function modField(docFieldValue, userValue) {
  var divisor = userValue[0];
  var mod = userValue[1];
  if (divisor === 0) {
    throw new Error('Bad divisor, cannot divide by zero');
  }

  if (parseInt(divisor, 10) !== divisor ) {
    throw new Error('Divisor is not an integer');
  }

  if (parseInt(mod, 10) !== mod ) {
    throw new Error('Modulus is not an integer');
  }

  if (parseInt(docFieldValue, 10) !== docFieldValue) {
    return false;
  }

  return docFieldValue % divisor === mod;
}

function arrayContainsValue(docFieldValue, userValue) {
  return userValue.some(function (val) {
    if (docFieldValue instanceof Array) {
      return docFieldValue.indexOf(val) > -1;
    }

    return docFieldValue === val;
  });
}

function arrayContainsAllValues(docFieldValue, userValue) {
  return userValue.every(function (val) {
    return docFieldValue.indexOf(val) > -1;
  });
}

function arraySize(docFieldValue, userValue) {
  return docFieldValue.length === userValue;
}

function regexMatch(docFieldValue, userValue) {
  var re = new RegExp(userValue);

  return re.test(docFieldValue);
}

function typeMatch(docFieldValue, userValue) {

  switch (userValue) {
    case 'null':
      return docFieldValue === null;
    case 'boolean':
      return typeof (docFieldValue) === 'boolean';
    case 'number':
      return typeof (docFieldValue) === 'number';
    case 'string':
      return typeof (docFieldValue) === 'string';
    case 'array':
      return docFieldValue instanceof Array;
    case 'object':
      return ({}).toString.call(docFieldValue) === '[object Object]';
  }

  throw new Error(userValue + ' not supported as a type.' +
                  'Please use one of object, string, array, number, boolean or null.');

}

var matchers = {

  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.some(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.some(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    /* istanbul ignore next */
    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.every(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.every(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$eq': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
  },

  '$gte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
  },

  '$gt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
  },

  '$lte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
  },

  '$lt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
  },

  '$exists': function (doc, userValue, parsedField, docFieldValue) {
    //a field that is null is still considered to exist
    if (userValue) {
      return fieldIsNotUndefined(docFieldValue);
    }

    return !fieldIsNotUndefined(docFieldValue);
  },

  '$mod': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
  },

  '$ne': function (doc, userValue, parsedField, docFieldValue) {
    return userValue.every(function (neValue) {
      return collate(docFieldValue, neValue) !== 0;
    });
  },
  '$in': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
  },

  '$nin': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
  },

  '$size': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
  },

  '$all': function (doc, userValue, parsedField, docFieldValue) {
    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
  },

  '$regex': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
  },

  '$type': function (doc, userValue, parsedField, docFieldValue) {
    return typeMatch(docFieldValue, userValue);
  }
};

// return true if the given doc matches the supplied selector
function matchesSelector(doc, selector) {
  /* istanbul ignore if */
  if (typeof selector !== 'object') {
    // match the CouchDB error message
    throw new Error('Selector error: expected a JSON object');
  }

  selector = massageSelector(selector);
  var row = {
    'doc': doc
  };

  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
  return rowsMatched && rowsMatched.length === 1;
}

function evalFilter(input) {
  return scopeEval('"use strict";\nreturn ' + input + ';', {});
}

function evalView(input) {
  var code = [
    'return function(doc) {',
    '  "use strict";',
    '  var emitted = false;',
    '  var emit = function (a, b) {',
    '    emitted = true;',
    '  };',
    '  var view = ' + input + ';',
    '  view(doc);',
    '  if (emitted) {',
    '    return true;',
    '  }',
    '};'
  ].join('\n');

  return scopeEval(code, {});
}

function validate(opts, callback) {
  if (opts.selector) {
    if (opts.filter && opts.filter !== '_selector') {
      var filterName = typeof opts.filter === 'string' ?
        opts.filter : 'function';
      return callback(new Error('selector invalid for filter "' + filterName + '"'));
    }
  }
  callback();
}

function normalize(opts) {
  if (opts.view && !opts.filter) {
    opts.filter = '_view';
  }

  if (opts.selector && !opts.filter) {
    opts.filter = '_selector';
  }

  if (opts.filter && typeof opts.filter === 'string') {
    if (opts.filter === '_view') {
      opts.view = normalizeDesignDocFunctionName(opts.view);
    } else {
      opts.filter = normalizeDesignDocFunctionName(opts.filter);
    }
  }
}

function shouldFilter(changesHandler, opts) {
  return opts.filter && typeof opts.filter === 'string' &&
    !opts.doc_ids && !isRemote(changesHandler.db);
}

function filter(changesHandler, opts) {
  var callback = opts.complete;
  if (opts.filter === '_view') {
    if (!opts.view || typeof opts.view !== 'string') {
      var err = createError(BAD_REQUEST,
        '`view` filter parameter not found or invalid.');
      return callback(err);
    }
    // fetch a view from a design doc, make it behave like a filter
    var viewName = parseDesignDocFunctionName(opts.view);
    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&
        ddoc.views[viewName[1]].map;
      if (!mapFun) {
        return callback(createError(MISSING_DOC,
          (ddoc.views ? 'missing json key: ' + viewName[1] :
            'missing json key: views')));
      }
      opts.filter = evalView(mapFun);
      changesHandler.doChanges(opts);
    });
  } else if (opts.selector) {
    opts.filter = function (doc) {
      return matchesSelector(doc, opts.selector);
    };
    changesHandler.doChanges(opts);
  } else {
    // fetch a filter from a design doc
    var filterName = parseDesignDocFunctionName(opts.filter);
    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
      if (!filterFun) {
        return callback(createError(MISSING_DOC,
          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
            : 'missing json key: filters')));
      }
      opts.filter = evalFilter(filterFun);
      changesHandler.doChanges(opts);
    });
  }
}

function applyChangesFilterPlugin(PouchDB) {
  PouchDB._changesFilterPlugin = {
    validate: validate,
    normalize: normalize,
    shouldFilter: shouldFilter,
    filter: filter
  };
}

// TODO: remove from pouchdb-core (breaking)
PouchDB$5.plugin(debugPouch);

// TODO: remove from pouchdb-core (breaking)
PouchDB$5.plugin(applyChangesFilterPlugin);

PouchDB$5.version = version;

function toObject(array) {
  return array.reduce(function (obj, item) {
    obj[item] = true;
    return obj;
  }, {});
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats',
  // Specific to Couchbase Sync Gateway
  '_removed'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

function parseRevisionInfo(rev$$1) {
  if (!/^\d+-./.test(rev$$1)) {
    return createError(INVALID_REV);
  }
  var idx = rev$$1.indexOf('-');
  var left = rev$$1.substring(0, idx);
  var right = rev$$1.substring(idx + 1);
  return {
    prefix: parseInt(left, 10),
    id: right
  };
}

function makeRevTreeFromRevisions(revisions, opts) {
  var pos = revisions.start - revisions.ids.length + 1;

  var revisionIds = revisions.ids;
  var ids = [revisionIds[0], opts, []];

  for (var i = 1, len = revisionIds.length; i < len; i++) {
    ids = [revisionIds[i], {status: 'missing'}, [ids]];
  }

  return [{
    pos: pos,
    ids: ids
  }];
}

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
function parseDoc(doc, newEdits) {

  var nRevNum;
  var newRevId;
  var revInfo;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = uuid();
    }
    newRevId = rev();
    if (doc._rev) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      doc._rev_tree = [{
        pos: revInfo.prefix,
        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = revInfo.prefix + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      nRevNum = revInfo.prefix;
      newRevId = revInfo.id;
      doc._rev_tree = [{
        pos: nRevNum,
        ids: [newRevId, opts, []]
      }];
    }
  }

  invalidIdError(doc._id);

  doc._rev = nRevNum + '-' + newRevId;

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(doc, key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        var error = createError(DOC_VALIDATION, key);
        error.message = DOC_VALIDATION.message + ': ' + key;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
}

var thisAtob = function (str) {
  return atob(str);
};

var thisBtoa = function (str) {
  return btoa(str);
};

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
function createBlob(parts, properties) {
  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                  WebKitBlobBuilder;
    var builder = new Builder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function binaryStringToArrayBuffer(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
}

function binStringToBluffer(binString, type) {
  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
}

function b64ToBluffer(b64, type) {
  return binStringToBluffer(thisAtob(b64), type);
}

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
function arrayBufferToBinaryString(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
}

// shim for browsers that don't support it
function readAsBinaryString(blob, callback) {
  if (typeof FileReader === 'undefined') {
    // fix for Firefox in a web worker
    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
    return callback(arrayBufferToBinaryString(
      new FileReaderSync().readAsArrayBuffer(blob)));
  }

  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
}

function blobToBinaryString(blobOrBuffer, callback) {
  readAsBinaryString(blobOrBuffer, function (bin) {
    callback(bin);
  });
}

function blobToBase64(blobOrBuffer, callback) {
  blobToBinaryString(blobOrBuffer, function (base64) {
    callback(thisBtoa(base64));
  });
}

// simplified API. universal browser support is assumed
function readAsArrayBuffer(blob, callback) {
  if (typeof FileReader === 'undefined') {
    // fix for Firefox in a web worker:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
    return callback(new FileReaderSync().readAsArrayBuffer(blob));
  }

  var reader = new FileReader();
  reader.onloadend = function (e) {
    var result = e.target.result || new ArrayBuffer(0);
    callback(result);
  };
  reader.readAsArrayBuffer(blob);
}

// this is not used in the browser

var setImmediateShim = global.setImmediate || global.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function rawToBase64(raw) {
  return thisBtoa(raw);
}

function sliceBlob(blob, start, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start, end);
  }
  return blob.slice(start, end);
}

function appendBlob(buffer, blob, start, end, callback) {
  if (start > 0 || end < blob.size) {
    // only slice blob if we really need to
    blob = sliceBlob(blob, start, end);
  }
  readAsArrayBuffer(blob, function (arrayBuffer) {
    buffer.append(arrayBuffer);
    callback();
  });
}

function appendString(buffer, string, start, end, callback) {
  if (start > 0 || end < string.length) {
    // only create a substring if we really need to
    string = string.substring(start, end);
  }
  buffer.appendBinary(string);
  callback();
}

function binaryMd5(data, callback) {
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.size;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();

  var append = inputIsString ? appendString : appendBlob;

  function next() {
    setImmediateShim(loadNextChunk);
  }

  function done() {
    var raw = buffer.end(true);
    var base64 = rawToBase64(raw);
    callback(base64);
    buffer.destroy();
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end, next);
    } else {
      append(buffer, data, start, end, done);
    }
  }
  loadNextChunk();
}

function stringMd5(string) {
  return Md5.hash(string);
}

function parseBase64(data) {
  try {
    return thisAtob(data);
  } catch (e) {
    var err = createError(BAD_ARG,
      'Attachment is not a valid base64 string');
    return {error: err};
  }
}

function preprocessString(att, blobType, callback) {
  var asBinary = parseBase64(att.data);
  if (asBinary.error) {
    return callback(asBinary.error);
  }

  att.length = asBinary.length;
  if (blobType === 'blob') {
    att.data = binStringToBluffer(asBinary, att.content_type);
  } else if (blobType === 'base64') {
    att.data = thisBtoa(asBinary);
  } else { // binary
    att.data = asBinary;
  }
  binaryMd5(asBinary, function (result) {
    att.digest = 'md5-' + result;
    callback();
  });
}

function preprocessBlob(att, blobType, callback) {
  binaryMd5(att.data, function (md5) {
    att.digest = 'md5-' + md5;
    // size is for blobs (browser), length is for buffers (node)
    att.length = att.data.size || att.data.length || 0;
    if (blobType === 'binary') {
      blobToBinaryString(att.data, function (binString) {
        att.data = binString;
        callback();
      });
    } else if (blobType === 'base64') {
      blobToBase64(att.data, function (b64) {
        att.data = b64;
        callback();
      });
    } else {
      callback();
    }
  });
}

function preprocessAttachment(att, blobType, callback) {
  if (att.stub) {
    return callback();
  }
  if (typeof att.data === 'string') { // input is a base64 string
    preprocessString(att, blobType, callback);
  } else { // input is a blob
    preprocessBlob(att, blobType, callback);
  }
}

function preprocessAttachments(docInfos, blobType, callback) {

  if (!docInfos.length) {
    return callback();
  }

  var docv = 0;
  var overallErr;

  docInfos.forEach(function (docInfo) {
    var attachments = docInfo.data && docInfo.data._attachments ?
      Object.keys(docInfo.data._attachments) : [];
    var recv = 0;

    if (!attachments.length) {
      return done();
    }

    function processedAttachment(err) {
      overallErr = err;
      recv++;
      if (recv === attachments.length) {
        done();
      }
    }

    for (var key in docInfo.data._attachments) {
      if (docInfo.data._attachments.hasOwnProperty(key)) {
        preprocessAttachment(docInfo.data._attachments[key],
          blobType, processedAttachment);
      }
    }
  });

  function done() {
    docv++;
    if (docInfos.length === docv) {
      if (overallErr) {
        callback(overallErr);
      } else {
        callback();
      }
    }
  }
}

function updateDoc(revLimit, prev, docInfo, results,
                   i, cb, writeDoc, newEdits) {

  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {
    results[i] = docInfo;
    return cb();
  }

  // sometimes this is pre-calculated. historically not always
  var previousWinningRev = prev.winningRev || winningRev(prev);
  var previouslyDeleted = 'deleted' in prev ? prev.deleted :
    isDeleted(prev, previousWinningRev);
  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
    isDeleted(docInfo.metadata);
  var isRoot = /^1-/.test(docInfo.metadata.rev);

  if (previouslyDeleted && !deleted && newEdits && isRoot) {
    var newDoc = docInfo.data;
    newDoc._rev = previousWinningRev;
    newDoc._id = docInfo.metadata.id;
    docInfo = parseDoc(newDoc, newEdits);
  }

  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

  var inConflict = newEdits && ((
    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

  if (inConflict) {
    var err = createError(REV_CONFLICT);
    results[i] = err;
    return cb();
  }

  var newRev = docInfo.metadata.rev;
  docInfo.metadata.rev_tree = merged.tree;
  docInfo.stemmedRevs = merged.stemmedRevs || [];
  /* istanbul ignore else */
  if (prev.rev_map) {
    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
  }

  // recalculate
  var winningRev$$1 = winningRev(docInfo.metadata);
  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);

  // calculate the total number of documents that were added/removed,
  // from the perspective of total_rows/doc_count
  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
    previouslyDeleted < winningRevIsDeleted ? -1 : 1;

  var newRevIsDeleted;
  if (newRev === winningRev$$1) {
    // if the new rev is the same as the winning rev, we can reuse that value
    newRevIsDeleted = winningRevIsDeleted;
  } else {
    // if they're not the same, then we need to recalculate
    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
  }

  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
    true, delta, i, cb);
}

function rootIsMissing(docInfo) {
  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
}

function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                     writeDoc, opts, overallCallback) {

  // Default to 1000 locally
  revLimit = revLimit || 1000;

  function insertDoc(docInfo, resultsIdx, callback) {
    // Cant insert new deleted documents
    var winningRev$$1 = winningRev(docInfo.metadata);
    var deleted = isDeleted(docInfo.metadata, winningRev$$1);
    if ('was_delete' in opts && deleted) {
      results[resultsIdx] = createError(MISSING_DOC, 'deleted');
      return callback();
    }

    // 4712 - detect whether a new document was inserted with a _rev
    var inConflict = newEdits && rootIsMissing(docInfo);

    if (inConflict) {
      var err = createError(REV_CONFLICT);
      results[resultsIdx] = err;
      return callback();
    }

    var delta = deleted ? 0 : 1;

    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
      delta, resultsIdx, callback);
  }

  var newEdits = opts.new_edits;
  var idsToDocs = new ExportedMap();

  var docsDone = 0;
  var docsToDo = docInfos.length;

  function checkAllDocsDone() {
    if (++docsDone === docsToDo && overallCallback) {
      overallCallback();
    }
  }

  docInfos.forEach(function (currentDoc, resultsIdx) {

    if (currentDoc._id && isLocalId(currentDoc._id)) {
      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
      api[fun](currentDoc, {ctx: tx}, function (err, res) {
        results[resultsIdx] = err || res;
        checkAllDocsDone();
      });
      return;
    }

    var id = currentDoc.metadata.id;
    if (idsToDocs.has(id)) {
      docsToDo--; // duplicate
      idsToDocs.get(id).push([currentDoc, resultsIdx]);
    } else {
      idsToDocs.set(id, [[currentDoc, resultsIdx]]);
    }
  });

  // in the case of new_edits, the user can provide multiple docs
  // with the same id. these need to be processed sequentially
  idsToDocs.forEach(function (docs, id) {
    var numDone = 0;

    function docWritten() {
      if (++numDone < docs.length) {
        nextDoc();
      } else {
        checkAllDocsDone();
      }
    }
    function nextDoc() {
      var value = docs[numDone];
      var currentDoc = value[0];
      var resultsIdx = value[1];

      if (fetchedDocs.has(id)) {
        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
          resultsIdx, docWritten, writeDoc, newEdits);
      } else {
        // Ensure stemming applies to new writes as well
        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
        currentDoc.metadata.rev_tree = merged.tree;
        currentDoc.stemmedRevs = merged.stemmedRevs || [];
        insertDoc(currentDoc, resultsIdx, docWritten);
      }
    }
    nextDoc();
  });
}

// IndexedDB requires a versioned database structure, so we use the
// version here to manage migrations.
var ADAPTER_VERSION = 5;

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
// Keyed by document id
var DOC_STORE = 'document-store';
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE = 'by-sequence';
// Where we store attachments
var ATTACH_STORE = 'attach-store';
// Where we store many-to-many relations
// between attachment digests and seqs
var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

// Where we store database-wide meta data in a single record
// keyed by id: META_STORE
var META_STORE = 'meta-store';
// Where we store local documents
var LOCAL_STORE = 'local-store';
// Where we detect blob support
var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

function safeJsonParse(str) {
  // This try/catch guards against stack overflow errors.
  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
  // cannot overflow.
  try {
    return JSON.parse(str);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.parse(str);
  }
}

function safeJsonStringify(json) {
  try {
    return JSON.stringify(json);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.stringify(json);
  }
}

function idbError(callback) {
  return function (evt) {
    var message = 'unknown_error';
    if (evt.target && evt.target.error) {
      message = evt.target.error.name || evt.target.error.message;
    }
    callback(createError(IDB_ERROR, message, evt.type));
  };
}

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
function encodeMetadata(metadata, winningRev, deleted) {
  return {
    data: safeJsonStringify(metadata),
    winningRev: winningRev,
    deletedOrLocal: deleted ? '1' : '0',
    seq: metadata.seq, // highest seq for this doc
    id: metadata.id
  };
}

function decodeMetadata(storedObject) {
  if (!storedObject) {
    return null;
  }
  var metadata = safeJsonParse(storedObject.data);
  metadata.winningRev = storedObject.winningRev;
  metadata.deleted = storedObject.deletedOrLocal === '1';
  metadata.seq = storedObject.seq;
  return metadata;
}

// read the doc back out from the database. we don't store the
// _id or _rev because we already have _doc_id_rev.
function decodeDoc(doc) {
  if (!doc) {
    return doc;
  }
  var idx = doc._doc_id_rev.lastIndexOf(':');
  doc._id = doc._doc_id_rev.substring(0, idx - 1);
  doc._rev = doc._doc_id_rev.substring(idx + 1);
  delete doc._doc_id_rev;
  return doc;
}

// Read a blob from the database, encoding as necessary
// and translating from base64 if the IDB doesn't support
// native Blobs
function readBlobData(body, type, asBlob, callback) {
  if (asBlob) {
    if (!body) {
      callback(createBlob([''], {type: type}));
    } else if (typeof body !== 'string') { // we have blob support
      callback(body);
    } else { // no blob support
      callback(b64ToBluffer(body, type));
    }
  } else { // as base64 string
    if (!body) {
      callback('');
    } else if (typeof body !== 'string') { // we have blob support
      readAsBinaryString(body, function (binary) {
        callback(thisBtoa(binary));
      });
    } else { // no blob support
      callback(body);
    }
  }
}

function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
  var attachments = Object.keys(doc._attachments || {});
  if (!attachments.length) {
    return cb && cb();
  }
  var numDone = 0;

  function checkDone() {
    if (++numDone === attachments.length && cb) {
      cb();
    }
  }

  function fetchAttachment(doc, att) {
    var attObj = doc._attachments[att];
    var digest = attObj.digest;
    var req = txn.objectStore(ATTACH_STORE).get(digest);
    req.onsuccess = function (e) {
      attObj.body = e.target.result.body;
      checkDone();
    };
  }

  attachments.forEach(function (att) {
    if (opts.attachments && opts.include_docs) {
      fetchAttachment(doc, att);
    } else {
      doc._attachments[att].stub = true;
      checkDone();
    }
  });
}

// IDB-specific postprocessing necessary because
// we don't know whether we stored a true Blob or
// a base64-encoded string, and if it's a Blob it
// needs to be read outside of the transaction context
function postProcessAttachments(results, asBlob) {
  return PouchPromise$1.all(results.map(function (row) {
    if (row.doc && row.doc._attachments) {
      var attNames = Object.keys(row.doc._attachments);
      return PouchPromise$1.all(attNames.map(function (att) {
        var attObj = row.doc._attachments[att];
        if (!('body' in attObj)) { // already processed
          return;
        }
        var body = attObj.body;
        var type = attObj.content_type;
        return new PouchPromise$1(function (resolve) {
          readBlobData(body, type, asBlob, function (data) {
            row.doc._attachments[att] = $inject_Object_assign(
              pick(attObj, ['digest', 'content_type']),
              {data: data}
            );
            resolve();
          });
        });
      }));
    }
  }));
}

function compactRevs(revs, docId, txn) {

  var possiblyOrphanedDigests = [];
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var attStore = txn.objectStore(ATTACH_STORE);
  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
  var count = revs.length;

  function checkDone() {
    count--;
    if (!count) { // done processing all revs
      deleteOrphanedAttachments();
    }
  }

  function deleteOrphanedAttachments() {
    if (!possiblyOrphanedDigests.length) {
      return;
    }
    possiblyOrphanedDigests.forEach(function (digest) {
      var countReq = attAndSeqStore.index('digestSeq').count(
        IDBKeyRange.bound(
          digest + '::', digest + '::\uffff', false, false));
      countReq.onsuccess = function (e) {
        var count = e.target.result;
        if (!count) {
          // orphaned
          attStore["delete"](digest);
        }
      };
    });
  }

  revs.forEach(function (rev$$1) {
    var index = seqStore.index('_doc_id_rev');
    var key = docId + "::" + rev$$1;
    index.getKey(key).onsuccess = function (e) {
      var seq = e.target.result;
      if (typeof seq !== 'number') {
        return checkDone();
      }
      seqStore["delete"](seq);

      var cursor = attAndSeqStore.index('seq')
        .openCursor(IDBKeyRange.only(seq));

      cursor.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          var digest = cursor.value.digestSeq.split('::')[0];
          possiblyOrphanedDigests.push(digest);
          attAndSeqStore["delete"](cursor.primaryKey);
          cursor["continue"]();
        } else { // done
          checkDone();
        }
      };
    };
  });
}

function openTransactionSafely(idb, stores, mode) {
  try {
    return {
      txn: idb.transaction(stores, mode)
    };
  } catch (err) {
    return {
      error: err
    };
  }
}

var changesHandler = new Changes();

function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
  var docInfos = req.docs;
  var txn;
  var docStore;
  var bySeqStore;
  var attachStore;
  var attachAndSeqStore;
  var metaStore;
  var docInfoError;
  var metaDoc;

  for (var i = 0, len = docInfos.length; i < len; i++) {
    var doc = docInfos[i];
    if (doc._id && isLocalId(doc._id)) {
      continue;
    }
    doc = docInfos[i] = parseDoc(doc, opts.new_edits);
    if (doc.error && !docInfoError) {
      docInfoError = doc;
    }
  }

  if (docInfoError) {
    return callback(docInfoError);
  }

  var allDocsProcessed = false;
  var docCountDelta = 0;
  var results = new Array(docInfos.length);
  var fetchedDocs = new ExportedMap();
  var preconditionErrored = false;
  var blobType = api._meta.blobSupport ? 'blob' : 'base64';

  preprocessAttachments(docInfos, blobType, function (err) {
    if (err) {
      return callback(err);
    }
    startTransaction();
  });

  function startTransaction() {

    var stores = [
      DOC_STORE, BY_SEQ_STORE,
      ATTACH_STORE,
      LOCAL_STORE, ATTACH_AND_SEQ_STORE,
      META_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    txn = txnResult.txn;
    txn.onabort = idbError(callback);
    txn.ontimeout = idbError(callback);
    txn.oncomplete = complete;
    docStore = txn.objectStore(DOC_STORE);
    bySeqStore = txn.objectStore(BY_SEQ_STORE);
    attachStore = txn.objectStore(ATTACH_STORE);
    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
    metaStore = txn.objectStore(META_STORE);

    metaStore.get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result;
      updateDocCountIfReady();
    };

    verifyAttachments(function (err) {
      if (err) {
        preconditionErrored = true;
        return callback(err);
      }
      fetchExistingDocs();
    });
  }

  function onAllDocsProcessed() {
    allDocsProcessed = true;
    updateDocCountIfReady();
  }

  function idbProcessDocs() {
    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                txn, results, writeDoc, opts, onAllDocsProcessed);
  }

  function updateDocCountIfReady() {
    if (!metaDoc || !allDocsProcessed) {
      return;
    }
    // caching the docCount saves a lot of time in allDocs() and
    // info(), which is why we go to all the trouble of doing this
    metaDoc.docCount += docCountDelta;
    metaStore.put(metaDoc);
  }

  function fetchExistingDocs() {

    if (!docInfos.length) {
      return;
    }

    var numFetched = 0;

    function checkDone() {
      if (++numFetched === docInfos.length) {
        idbProcessDocs();
      }
    }

    function readMetadata(event) {
      var metadata = decodeMetadata(event.target.result);

      if (metadata) {
        fetchedDocs.set(metadata.id, metadata);
      }
      checkDone();
    }

    for (var i = 0, len = docInfos.length; i < len; i++) {
      var docInfo = docInfos[i];
      if (docInfo._id && isLocalId(docInfo._id)) {
        checkDone(); // skip local docs
        continue;
      }
      var req = docStore.get(docInfo.metadata.id);
      req.onsuccess = readMetadata;
    }
  }

  function complete() {
    if (preconditionErrored) {
      return;
    }

    changesHandler.notify(api._meta.name);
    callback(null, results);
  }

  function verifyAttachment(digest, callback) {

    var req = attachStore.get(digest);
    req.onsuccess = function (e) {
      if (!e.target.result) {
        var err = createError(MISSING_STUB,
          'unknown stub attachment with digest ' +
          digest);
        err.status = 412;
        callback(err);
      } else {
        callback();
      }
    };
  }

  function verifyAttachments(finish) {


    var digests = [];
    docInfos.forEach(function (docInfo) {
      if (docInfo.data && docInfo.data._attachments) {
        Object.keys(docInfo.data._attachments).forEach(function (filename) {
          var att = docInfo.data._attachments[filename];
          if (att.stub) {
            digests.push(att.digest);
          }
        });
      }
    });
    if (!digests.length) {
      return finish();
    }
    var numDone = 0;
    var err;

    function checkDone() {
      if (++numDone === digests.length) {
        finish(err);
      }
    }
    digests.forEach(function (digest) {
      verifyAttachment(digest, function (attErr) {
        if (attErr && !err) {
          err = attErr;
        }
        checkDone();
      });
    });
  }

  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                    isUpdate, delta, resultsIdx, callback) {

    docInfo.metadata.winningRev = winningRev$$1;
    docInfo.metadata.deleted = winningRevIsDeleted;

    var doc = docInfo.data;
    doc._id = docInfo.metadata.id;
    doc._rev = docInfo.metadata.rev;

    if (newRevIsDeleted) {
      doc._deleted = true;
    }

    var hasAttachments = doc._attachments &&
      Object.keys(doc._attachments).length;
    if (hasAttachments) {
      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
        isUpdate, resultsIdx, callback);
    }

    docCountDelta += delta;
    updateDocCountIfReady();

    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
      isUpdate, resultsIdx, callback);
  }

  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
                     isUpdate, resultsIdx, callback) {

    var doc = docInfo.data;
    var metadata = docInfo.metadata;

    doc._doc_id_rev = metadata.id + '::' + metadata.rev;
    delete doc._id;
    delete doc._rev;

    function afterPutDoc(e) {
      var revsToDelete = docInfo.stemmedRevs || [];

      if (isUpdate && api.auto_compaction) {
        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
      }

      if (revsToDelete && revsToDelete.length) {
        compactRevs(revsToDelete, docInfo.metadata.id, txn);
      }

      metadata.seq = e.target.result;
      // Current _rev is calculated from _rev_tree on read
      // delete metadata.rev;
      var metadataToStore = encodeMetadata(metadata, winningRev$$1,
        winningRevIsDeleted);
      var metaDataReq = docStore.put(metadataToStore);
      metaDataReq.onsuccess = afterPutMetadata;
    }

    function afterPutDocError(e) {
      // ConstraintError, need to update, not put (see #1638 for details)
      e.preventDefault(); // avoid transaction abort
      e.stopPropagation(); // avoid transaction onerror
      var index = bySeqStore.index('_doc_id_rev');
      var getKeyReq = index.getKey(doc._doc_id_rev);
      getKeyReq.onsuccess = function (e) {
        var putReq = bySeqStore.put(doc, e.target.result);
        putReq.onsuccess = afterPutDoc;
      };
    }

    function afterPutMetadata() {
      results[resultsIdx] = {
        ok: true,
        id: metadata.id,
        rev: metadata.rev
      };
      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
      insertAttachmentMappings(docInfo, metadata.seq, callback);
    }

    var putReq = bySeqStore.put(doc);

    putReq.onsuccess = afterPutDoc;
    putReq.onerror = afterPutDocError;
  }

  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
                            isUpdate, resultsIdx, callback) {


    var doc = docInfo.data;

    var numDone = 0;
    var attachments = Object.keys(doc._attachments);

    function collectResults() {
      if (numDone === attachments.length) {
        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
          isUpdate, resultsIdx, callback);
      }
    }

    function attachmentSaved() {
      numDone++;
      collectResults();
    }

    attachments.forEach(function (key) {
      var att = docInfo.data._attachments[key];
      if (!att.stub) {
        var data = att.data;
        delete att.data;
        att.revpos = parseInt(winningRev$$1, 10);
        var digest = att.digest;
        saveAttachment(digest, data, attachmentSaved);
      } else {
        numDone++;
        collectResults();
      }
    });
  }

  // map seqs to attachment digests, which
  // we will need later during compaction
  function insertAttachmentMappings(docInfo, seq, callback) {

    var attsAdded = 0;
    var attsToAdd = Object.keys(docInfo.data._attachments || {});

    if (!attsToAdd.length) {
      return callback();
    }

    function checkDone() {
      if (++attsAdded === attsToAdd.length) {
        callback();
      }
    }

    function add(att) {
      var digest = docInfo.data._attachments[att].digest;
      var req = attachAndSeqStore.put({
        seq: seq,
        digestSeq: digest + '::' + seq
      });

      req.onsuccess = checkDone;
      req.onerror = function (e) {
        // this callback is for a constaint error, which we ignore
        // because this docid/rev has already been associated with
        // the digest (e.g. when new_edits == false)
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
        checkDone();
      };
    }
    for (var i = 0; i < attsToAdd.length; i++) {
      add(attsToAdd[i]); // do in parallel
    }
  }

  function saveAttachment(digest, data, callback) {


    var getKeyReq = attachStore.count(digest);
    getKeyReq.onsuccess = function (e) {
      var count = e.target.result;
      if (count) {
        return callback(); // already exists
      }
      var newAtt = {
        digest: digest,
        body: data
      };
      var putReq = attachStore.put(newAtt);
      putReq.onsuccess = callback;
    };
  }
}

// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
// we're not processing each document one-at-a-time.
function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {

  // Bail out of getAll()/getAllKeys() in the following cases:
  // 1) either method is unsupported - we need both
  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,
  //    not really clear the user wants a batched approach where the entire DB is read into memory,
  //    perhaps they are filtering on a per-doc basis)
  // 3) descending  no real way to do this via getAll()/getAllKeys()

  var useGetAll = typeof objectStore.getAll === 'function' &&
    typeof objectStore.getAllKeys === 'function' &&
    batchSize > 1 && !descending;

  var keysBatch;
  var valuesBatch;
  var pseudoCursor;

  function onGetAll(e) {
    valuesBatch = e.target.result;
    if (keysBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function onGetAllKeys(e) {
    keysBatch = e.target.result;
    if (valuesBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function continuePseudoCursor() {
    if (!keysBatch.length) { // no more results
      return onBatch();
    }
    // fetch next batch, exclusive start
    var lastKey = keysBatch[keysBatch.length - 1];
    var newKeyRange;
    if (keyRange && keyRange.upper) {
      try {
        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
          true, keyRange.upperOpen);
      } catch (e) {
        if (e.name === "DataError" && e.code === 0) {
          return onBatch(); // we're done, startkey and endkey are equal
        }
      }
    } else {
      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
    }
    keyRange = newKeyRange;
    keysBatch = null;
    valuesBatch = null;
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  }

  function onCursor(e) {
    var cursor = e.target.result;
    if (!cursor) { // done
      return onBatch();
    }
    // regular IDBCursor acts like a batch where batch size is always 1
    onBatch([cursor.key], [cursor.value], cursor);
  }

  if (useGetAll) {
    pseudoCursor = {"continue": continuePseudoCursor};
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  } else if (descending) {
    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
  } else {
    objectStore.openCursor(keyRange).onsuccess = onCursor;
  }
}

// simple shim for objectStore.getAll(), falling back to IDBCursor
function getAll(objectStore, keyRange, onSuccess) {
  if (typeof objectStore.getAll === 'function') {
    // use native getAll
    objectStore.getAll(keyRange).onsuccess = onSuccess;
    return;
  }
  // fall back to cursors
  var values = [];

  function onCursor(e) {
    var cursor = e.target.result;
    if (cursor) {
      values.push(cursor.value);
      cursor["continue"]();
    } else {
      onSuccess({
        target: {
          result: values
        }
      });
    }
  }

  objectStore.openCursor(keyRange).onsuccess = onCursor;
}

function createKeyRange(start, end, inclusiveEnd, key, descending) {
  try {
    if (start && end) {
      if (descending) {
        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
      } else {
        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
      }
    } else if (start) {
      if (descending) {
        return IDBKeyRange.upperBound(start);
      } else {
        return IDBKeyRange.lowerBound(start);
      }
    } else if (end) {
      if (descending) {
        return IDBKeyRange.lowerBound(end, !inclusiveEnd);
      } else {
        return IDBKeyRange.upperBound(end, !inclusiveEnd);
      }
    } else if (key) {
      return IDBKeyRange.only(key);
    }
  } catch (e) {
    return {error: e};
  }
  return null;
}

function idbAllDocs(opts, idb, callback) {
  var start = 'startkey' in opts ? opts.startkey : false;
  var end = 'endkey' in opts ? opts.endkey : false;
  var key = 'key' in opts ? opts.key : false;
  var skip = opts.skip || 0;
  var limit = typeof opts.limit === 'number' ? opts.limit : -1;
  var inclusiveEnd = opts.inclusive_end !== false;

  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
  var keyRangeError = keyRange && keyRange.error;
  if (keyRangeError && !(keyRangeError.name === "DataError" &&
      keyRangeError.code === 0)) {
    // DataError with error code 0 indicates start is less than end, so
    // can just do an empty query. Else need to throw
    return callback(createError(IDB_ERROR,
      keyRangeError.name, keyRangeError.message));
  }

  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

  if (opts.attachments) {
    stores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, stores, 'readonly');
  if (txnResult.error) {
    return callback(txnResult.error);
  }
  var txn = txnResult.txn;
  txn.oncomplete = onTxnComplete;
  txn.onabort = idbError(callback);
  var docStore = txn.objectStore(DOC_STORE);
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var metaStore = txn.objectStore(META_STORE);
  var docIdRevIndex = seqStore.index('_doc_id_rev');
  var results = [];
  var docCount;

  metaStore.get(META_STORE).onsuccess = function (e) {
    docCount = e.target.result.docCount;
  };

  // if the user specifies include_docs=true, then we don't
  // want to block the main cursor while we're fetching the doc
  function fetchDocAsynchronously(metadata, row, winningRev$$1) {
    var key = metadata.id + "::" + winningRev$$1;
    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {
      row.doc = decodeDoc(e.target.result);
      if (opts.conflicts) {
        var conflicts = collectConflicts(metadata);
        if (conflicts.length) {
          row.doc._conflicts = conflicts;
        }
      }
      fetchAttachmentsIfNecessary(row.doc, opts, txn);
    };
  }

  function allDocsInner(winningRev$$1, metadata) {
    var row = {
      id: metadata.id,
      key: metadata.id,
      value: {
        rev: winningRev$$1
      }
    };
    var deleted = metadata.deleted;
    if (opts.deleted === 'ok') {
      results.push(row);
      // deleted docs are okay with "keys" requests
      if (deleted) {
        row.value.deleted = true;
        row.doc = null;
      } else if (opts.include_docs) {
        fetchDocAsynchronously(metadata, row, winningRev$$1);
      }
    } else if (!deleted && skip-- <= 0) {
      results.push(row);
      if (opts.include_docs) {
        fetchDocAsynchronously(metadata, row, winningRev$$1);
      }
    }
  }

  function processBatch(batchValues) {
    for (var i = 0, len = batchValues.length; i < len; i++) {
      if (results.length === limit) {
        break;
      }
      var batchValue = batchValues[i];
      var metadata = decodeMetadata(batchValue);
      var winningRev$$1 = metadata.winningRev;
      allDocsInner(winningRev$$1, metadata);
    }
  }

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor) {
      return;
    }
    processBatch(batchValues);
    if (results.length < limit) {
      cursor["continue"]();
    }
  }

  function onGetAll(e) {
    var values = e.target.result;
    if (opts.descending) {
      values = values.reverse();
    }
    processBatch(values);
  }

  function onResultsReady() {
    callback(null, {
      total_rows: docCount,
      offset: opts.skip,
      rows: results
    });
  }

  function onTxnComplete() {
    if (opts.attachments) {
      postProcessAttachments(results, opts.binary).then(onResultsReady);
    } else {
      onResultsReady();
    }
  }

  // don't bother doing any requests if start > end or limit === 0
  if (keyRangeError || limit === 0) {
    return;
  }
  if (limit === -1) { // just fetch everything
    return getAll(docStore, keyRange, onGetAll);
  }
  // else do a cursor
  // choose a batch size based on the skip, since we'll need to skip that many
  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
function checkBlobSupport(txn) {
  return new PouchPromise$1(function (resolve) {
    var blob = createBlob(['']);
    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

    req.onsuccess = function () {
      var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
      var matchedEdge = navigator.userAgent.match(/Edge\//);
      // MS Edge pretends to be Chrome 42:
      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
      resolve(matchedEdge || !matchedChrome ||
        parseInt(matchedChrome[1], 10) >= 43);
    };

    txn.onabort = function (e) {
      // If the transaction aborts now its due to not being able to
      // write to the database, likely due to the disk being full
      e.preventDefault();
      e.stopPropagation();
      resolve(false);
    };
  })["catch"](function () {
    return false; // error, so assume unsupported
  });
}

function countDocs(txn, cb) {
  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
    cb(e.target.result);
  };
}

// This task queue ensures that IDB open calls are done in their own tick
// and sequentially - i.e. we wait for the async IDB open to *fully* complete
// before calling the next one. This works around IE/Edge race conditions in IDB.

var running = false;
var queue = [];

function tryCode(fun, err, res, PouchDB) {
  try {
    fun(err, res);
  } catch (err) {
    // Shouldn't happen, but in some odd cases
    // IndexedDB implementations might throw a sync
    // error, in which case this will at least log it.
    PouchDB.emit('error', err);
  }
}

function applyNext() {
  if (running || !queue.length) {
    return;
  }
  running = true;
  queue.shift()();
}

function enqueueTask(action, callback, PouchDB) {
  queue.push(function runAction() {
    action(function runCallback(err, res) {
      tryCode(callback, err, res, PouchDB);
      running = false;
      nextTick(function runNext() {
        applyNext(PouchDB);
      });
    });
  });
  applyNext();
}

function changes(opts, api, dbName, idb) {
  opts = clone(opts);

  if (opts.continuous) {
    var id = dbName + ':' + uuid();
    changesHandler.addListener(dbName, id, api, opts);
    changesHandler.notify(dbName);
    return {
      cancel: function () {
        changesHandler.removeListener(dbName, id);
      }
    };
  }

  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);

  opts.since = opts.since || 0;
  var lastSeq = opts.since;

  var limit = 'limit' in opts ? opts.limit : -1;
  if (limit === 0) {
    limit = 1; // per CouchDB _changes spec
  }
  var returnDocs;
  if ('return_docs' in opts) {
    returnDocs = opts.return_docs;
  } else if ('returnDocs' in opts) {
    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
    returnDocs = opts.returnDocs;
  } else {
    returnDocs = true;
  }

  var results = [];
  var numResults = 0;
  var filter = filterChange(opts);
  var docIdsToMetadata = new ExportedMap();

  var txn;
  var bySeqStore;
  var docStore;
  var docIdRevIndex;

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor || !batchKeys.length) { // done
      return;
    }

    var winningDocs = new Array(batchKeys.length);
    var metadatas = new Array(batchKeys.length);

    function processMetadataAndWinningDoc(metadata, winningDoc) {
      var change = opts.processChange(winningDoc, metadata, opts);
      lastSeq = change.seq = metadata.seq;

      var filtered = filter(change);
      if (typeof filtered === 'object') { // anything but true/false indicates error
        return opts.complete(filtered);
      }

      if (filtered) {
        numResults++;
        if (returnDocs) {
          results.push(change);
        }
        // process the attachment immediately
        // for the benefit of live listeners
        if (opts.attachments && opts.include_docs) {
          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
            postProcessAttachments([change], opts.binary).then(function () {
              opts.onChange(change);
            });
          });
        } else {
          opts.onChange(change);
        }
      }
    }

    function onBatchDone() {
      for (var i = 0, len = winningDocs.length; i < len; i++) {
        if (numResults === limit) {
          break;
        }
        var winningDoc = winningDocs[i];
        if (!winningDoc) {
          continue;
        }
        var metadata = metadatas[i];
        processMetadataAndWinningDoc(metadata, winningDoc);
      }

      if (numResults !== limit) {
        cursor["continue"]();
      }
    }

    // Fetch all metadatas/winningdocs from this batch in parallel, then process
    // them all only once all data has been collected. This is done in parallel
    // because it's faster than doing it one-at-a-time.
    var numDone = 0;
    batchValues.forEach(function (value, i) {
      var doc = decodeDoc(value);
      var seq = batchKeys[i];
      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
        metadatas[i] = metadata;
        winningDocs[i] = winningDoc;
        if (++numDone === batchKeys.length) {
          onBatchDone();
        }
      });
    });
  }

  function onGetMetadata(doc, seq, metadata, cb) {
    if (metadata.seq !== seq) {
      // some other seq is later
      return cb();
    }

    if (metadata.winningRev === doc._rev) {
      // this is the winning doc
      return cb(metadata, doc);
    }

    // fetch winning doc in separate request
    var docIdRev = doc._id + '::' + metadata.winningRev;
    var req = docIdRevIndex.get(docIdRev);
    req.onsuccess = function (e) {
      cb(metadata, decodeDoc(e.target.result));
    };
  }

  function fetchWinningDocAndMetadata(doc, seq, cb) {
    if (docIds && !docIds.has(doc._id)) {
      return cb();
    }

    var metadata = docIdsToMetadata.get(doc._id);
    if (metadata) { // cached
      return onGetMetadata(doc, seq, metadata, cb);
    }
    // metadata not cached, have to go fetch it
    docStore.get(doc._id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      docIdsToMetadata.set(doc._id, metadata);
      onGetMetadata(doc, seq, metadata, cb);
    };
  }

  function finish() {
    opts.complete(null, {
      results: results,
      last_seq: lastSeq
    });
  }

  function onTxnComplete() {
    if (!opts.continuous && opts.attachments) {
      // cannot guarantee that postProcessing was already done,
      // so do it again
      postProcessAttachments(results).then(finish);
    } else {
      finish();
    }
  }

  var objectStores = [DOC_STORE, BY_SEQ_STORE];
  if (opts.attachments) {
    objectStores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
  if (txnResult.error) {
    return opts.complete(txnResult.error);
  }
  txn = txnResult.txn;
  txn.onabort = idbError(opts.complete);
  txn.oncomplete = onTxnComplete;

  bySeqStore = txn.objectStore(BY_SEQ_STORE);
  docStore = txn.objectStore(DOC_STORE);
  docIdRevIndex = bySeqStore.index('_doc_id_rev');

  var keyRange = (opts.since && !opts.descending) ?
    IDBKeyRange.lowerBound(opts.since, true) : null;

  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
}

var cachedDBs = new ExportedMap();
var blobSupportPromise;
var openReqList = new ExportedMap();

function IdbPouch(opts, callback) {
  var api = this;

  enqueueTask(function (thisCallback) {
    init(api, opts, thisCallback);
  }, callback, api.constructor);
}

function init(api, opts, callback) {

  var dbName = opts.name;

  var idb = null;
  api._meta = null;

  // called when creating a fresh new database
  function createSchema(db) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

    // added in v2
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    // added in v3
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});

    // added in v4
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 2
  // unfortunately "deletedOrLocal" is a misnomer now that we no longer
  // store local docs in the main doc-store, but whaddyagonnado
  function addDeletedOrLocalIndex(txn, callback) {
    var docStore = txn.objectStore(DOC_STORE);
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    docStore.openCursor().onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var deleted = isDeleted(metadata);
        metadata.deletedOrLocal = deleted ? "1" : "0";
        docStore.put(metadata);
        cursor["continue"]();
      } else {
        callback();
      }
    };
  }

  // migration to version 3 (part 1)
  function createLocalStoreSchema(db) {
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
  }

  // migration to version 3 (part 2)
  function migrateLocalStore(txn, cb) {
    var localStore = txn.objectStore(LOCAL_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);

    var cursor = docStore.openCursor();
    cursor.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var docId = metadata.id;
        var local = isLocalId(docId);
        var rev$$1 = winningRev(metadata);
        if (local) {
          var docIdRev = docId + "::" + rev$$1;
          // remove all seq entries
          // associated with this docId
          var start = docId + "::";
          var end = docId + "::~";
          var index = seqStore.index('_doc_id_rev');
          var range = IDBKeyRange.bound(start, end, false, false);
          var seqCursor = index.openCursor(range);
          seqCursor.onsuccess = function (e) {
            seqCursor = e.target.result;
            if (!seqCursor) {
              // done
              docStore["delete"](cursor.primaryKey);
              cursor["continue"]();
            } else {
              var data = seqCursor.value;
              if (data._doc_id_rev === docIdRev) {
                localStore.put(data);
              }
              seqStore["delete"](seqCursor.primaryKey);
              seqCursor["continue"]();
            }
          };
        } else {
          cursor["continue"]();
        }
      } else if (cb) {
        cb();
      }
    };
  }

  // migration to version 4 (part 1)
  function addAttachAndSeqStore(db) {
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 4 (part 2)
  function migrateAttsAndSeqs(txn, callback) {
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    // need to actually populate the table. this is the expensive part,
    // so as an optimization, check first that this database even
    // contains attachments
    var req = attStore.count();
    req.onsuccess = function (e) {
      var count = e.target.result;
      if (!count) {
        return callback(); // done
      }

      seqStore.openCursor().onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          return callback(); // done
        }
        var doc = cursor.value;
        var seq = cursor.primaryKey;
        var atts = Object.keys(doc._attachments || {});
        var digestMap = {};
        for (var j = 0; j < atts.length; j++) {
          var att = doc._attachments[atts[j]];
          digestMap[att.digest] = true; // uniq digests, just in case
        }
        var digests = Object.keys(digestMap);
        for (j = 0; j < digests.length; j++) {
          var digest = digests[j];
          attAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });
        }
        cursor["continue"]();
      };
    };
  }

  // migration to version 5
  // Instead of relying on on-the-fly migration of metadata,
  // this brings the doc-store to its modern form:
  // - metadata.winningrev
  // - metadata.seq
  // - stringify the metadata when storing it
  function migrateMetadata(txn) {

    function decodeMetadataCompat(storedObject) {
      if (!storedObject.data) {
        // old format, when we didn't store it stringified
        storedObject.deleted = storedObject.deletedOrLocal === '1';
        return storedObject;
      }
      return decodeMetadata(storedObject);
    }

    // ensure that every metadata has a winningRev and seq,
    // which was previously created on-the-fly but better to migrate
    var bySeqStore = txn.objectStore(BY_SEQ_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var cursor = docStore.openCursor();
    cursor.onsuccess = function (e) {
      var cursor = e.target.result;
      if (!cursor) {
        return; // done
      }
      var metadata = decodeMetadataCompat(cursor.value);

      metadata.winningRev = metadata.winningRev ||
        winningRev(metadata);

      function fetchMetadataSeq() {
        // metadata.seq was added post-3.2.0, so if it's missing,
        // we need to fetch it manually
        var start = metadata.id + '::';
        var end = metadata.id + '::\uffff';
        var req = bySeqStore.index('_doc_id_rev').openCursor(
          IDBKeyRange.bound(start, end));

        var metadataSeq = 0;
        req.onsuccess = function (e) {
          var cursor = e.target.result;
          if (!cursor) {
            metadata.seq = metadataSeq;
            return onGetMetadataSeq();
          }
          var seq = cursor.primaryKey;
          if (seq > metadataSeq) {
            metadataSeq = seq;
          }
          cursor["continue"]();
        };
      }

      function onGetMetadataSeq() {
        var metadataToStore = encodeMetadata(metadata,
          metadata.winningRev, metadata.deleted);

        var req = docStore.put(metadataToStore);
        req.onsuccess = function () {
          cursor["continue"]();
        };
      }

      if (metadata.seq) {
        return onGetMetadataSeq();
      }

      fetchMetadataSeq();
    };

  }

  api._remote = false;
  api.type = function () {
    return 'idb';
  };

  api._id = toPromise(function (callback) {
    callback(null, api._meta.instanceId);
  });

  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
    idbBulkDocs(opts, req, reqOpts, api, idb, callback);
  };

  // First we look up the metadata in the ids database, then we fetch the
  // current revision(s) from the by sequence store
  api._get = function idb_get(id, opts, callback) {
    var doc;
    var metadata;
    var err;
    var txn = opts.ctx;
    if (!txn) {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: txn});
    }

    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      // we can determine the result here if:
      // 1. there is no such document
      // 2. the document is deleted and we don't ask about specific rev
      // When we ask with opts.rev we expect the answer to be either
      // doc (possibly with _deleted=true) or missing error
      if (!metadata) {
        err = createError(MISSING_DOC, 'missing');
        return finish();
      }

      var rev$$1;
      if (!opts.rev) {
        rev$$1 = metadata.winningRev;
        var deleted = isDeleted(metadata);
        if (deleted) {
          err = createError(MISSING_DOC, "deleted");
          return finish();
        }
      } else {
        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;
      }

      var objectStore = txn.objectStore(BY_SEQ_STORE);
      var key = metadata.id + '::' + rev$$1;

      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
        doc = e.target.result;
        if (doc) {
          doc = decodeDoc(doc);
        }
        if (!doc) {
          err = createError(MISSING_DOC, 'missing');
          return finish();
        }
        finish();
      };
    };
  };

  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var txn;
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }
    var digest = attachment.digest;
    var type = attachment.content_type;

    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
      var body = e.target.result.body;
      readBlobData(body, type, opts.binary, function (blobData) {
        callback(null, blobData);
      });
    };
  };

  api._info = function idb_info(callback) {
    var updateSeq;
    var docCount;

    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      docCount = e.target.result.docCount;
    };
    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
      var cursor = e.target.result;
      updateSeq = cursor ? cursor.key : 0;
    };

    txn.oncomplete = function () {
      callback(null, {
        doc_count: docCount,
        update_seq: updateSeq,
        // for debugging
        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
      });
    };
  };

  api._allDocs = function idb_allDocs(opts, callback) {
    idbAllDocs(opts, idb, callback);
  };

  api._changes = function idbChanges(opts) {
    return changes(opts, api, dbName, idb);
  };

  api._close = function (callback) {
    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
    // "Returns immediately and closes the connection in a separate thread..."
    idb.close();
    cachedDBs["delete"](dbName);
    callback();
  };

  api._getRevisionTree = function (docId, callback) {
    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    var req = txn.objectStore(DOC_STORE).get(docId);
    req.onsuccess = function (event) {
      var doc = decodeMetadata(event.target.result);
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        callback(null, doc.rev_tree);
      }
    };
  };

  // This function removes revisions of document docId
  // which are listed in revs and sets this document
  // revision to to rev_tree
  api._doCompaction = function (docId, revs, callback) {
    var stores = [
      DOC_STORE,
      BY_SEQ_STORE,
      ATTACH_STORE,
      ATTACH_AND_SEQ_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;

    var docStore = txn.objectStore(DOC_STORE);

    docStore.get(docId).onsuccess = function (event) {
      var metadata = decodeMetadata(event.target.result);
      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev$$1 = pos + '-' + revHash;
        if (revs.indexOf(rev$$1) !== -1) {
          opts.status = 'missing';
        }
      });
      compactRevs(revs, docId, txn);
      var winningRev$$1 = metadata.winningRev;
      var deleted = metadata.deleted;
      txn.objectStore(DOC_STORE).put(
        encodeMetadata(metadata, winningRev$$1, deleted));
    };
    txn.onabort = idbError(callback);
    txn.oncomplete = function () {
      callback();
    };
  };


  api._getLocal = function (id, callback) {
    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var tx = txnResult.txn;
    var req = tx.objectStore(LOCAL_STORE).get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        delete doc['_doc_id_rev']; // for backwards compat
        callback(null, doc);
      }
    };
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    if (!oldRev) {
      doc._rev = '0-1';
    } else {
      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }

    var tx = opts.ctx;
    var ret;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.onerror = idbError(callback);
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }

    var oStore = tx.objectStore(LOCAL_STORE);
    var req;
    if (oldRev) {
      req = oStore.get(id);
      req.onsuccess = function (e) {
        var oldDoc = e.target.result;
        if (!oldDoc || oldDoc._rev !== oldRev) {
          callback(createError(REV_CONFLICT));
        } else { // update
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };
    } else { // new doc
      req = oStore.add(doc);
      req.onerror = function (e) {
        // constraint error, already exists
        callback(createError(REV_CONFLICT));
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
      };
      req.onsuccess = function () {
        ret = {ok: true, id: doc._id, rev: doc._rev};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      };
    }
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var tx = opts.ctx;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }
    var ret;
    var id = doc._id;
    var oStore = tx.objectStore(LOCAL_STORE);
    var req = oStore.get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var oldDoc = e.target.result;
      if (!oldDoc || oldDoc._rev !== doc._rev) {
        callback(createError(MISSING_DOC));
      } else {
        oStore["delete"](id);
        ret = {ok: true, id: id, rev: '0-0'};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      }
    };
  };

  api._destroy = function (opts, callback) {
    changesHandler.removeAllListeners(dbName);

    //Close open request for "dbName" database to fix ie delay.
    var openReq = openReqList.get(dbName);
    if (openReq && openReq.result) {
      openReq.result.close();
      cachedDBs["delete"](dbName);
    }
    var req = indexedDB.deleteDatabase(dbName);

    req.onsuccess = function () {
      //Remove open request from the list.
      openReqList["delete"](dbName);
      if (hasLocalStorage() && (dbName in localStorage)) {
        delete localStorage[dbName];
      }
      callback(null, { 'ok': true });
    };

    req.onerror = idbError(callback);
  };

  var cached = cachedDBs.get(dbName);

  if (cached) {
    idb = cached.idb;
    api._meta = cached.global;
    return nextTick(function () {
      callback(null, api);
    });
  }

  var req;
  if (opts.storage) {
    req = tryStorageOption(dbName, opts.storage);
  } else {
    req = indexedDB.open(dbName, ADAPTER_VERSION);
  }

  openReqList.set(dbName, req);

  req.onupgradeneeded = function (e) {
    var db = e.target.result;
    if (e.oldVersion < 1) {
      return createSchema(db); // new db, initial schema
    }
    // do migrations

    var txn = e.currentTarget.transaction;
    // these migrations have to be done in this function, before
    // control is returned to the event loop, because IndexedDB

    if (e.oldVersion < 3) {
      createLocalStoreSchema(db); // v2 -> v3
    }
    if (e.oldVersion < 4) {
      addAttachAndSeqStore(db); // v3 -> v4
    }

    var migrations = [
      addDeletedOrLocalIndex, // v1 -> v2
      migrateLocalStore,      // v2 -> v3
      migrateAttsAndSeqs,     // v3 -> v4
      migrateMetadata         // v4 -> v5
    ];

    var i = e.oldVersion;

    function next() {
      var migration = migrations[i - 1];
      i++;
      if (migration) {
        migration(txn, next);
      }
    }

    next();
  };

  req.onsuccess = function (e) {

    idb = e.target.result;

    idb.onversionchange = function () {
      idb.close();
      cachedDBs["delete"](dbName);
    };

    idb.onabort = function (e) {
      guardedConsole('error', 'Database has a global failure', e.target.error);
      idb.close();
      cachedDBs["delete"](dbName);
    };

    // Do a few setup operations (in parallel as much as possible):
    // 1. Fetch meta doc
    // 2. Check blob support
    // 3. Calculate docCount
    // 4. Generate an instanceId if necessary
    // 5. Store docCount and instanceId on meta doc

    var txn = idb.transaction([
      META_STORE,
      DETECT_BLOB_SUPPORT_STORE,
      DOC_STORE
    ], 'readwrite');

    var storedMetaDoc = false;
    var metaDoc;
    var docCount;
    var blobSupport;
    var instanceId;

    function completeSetup() {
      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
        return;
      }
      api._meta = {
        name: dbName,
        instanceId: instanceId,
        blobSupport: blobSupport
      };

      cachedDBs.set(dbName, {
        idb: idb,
        global: api._meta
      });
      callback(null, api);
    }

    function storeMetaDocIfReady() {
      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
        return;
      }
      var instanceKey = dbName + '_id';
      if (instanceKey in metaDoc) {
        instanceId = metaDoc[instanceKey];
      } else {
        metaDoc[instanceKey] = instanceId = uuid();
      }
      metaDoc.docCount = docCount;
      txn.objectStore(META_STORE).put(metaDoc);
    }

    //
    // fetch or generate the instanceId
    //
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result || { id: META_STORE };
      storeMetaDocIfReady();
    };

    //
    // countDocs
    //
    countDocs(txn, function (count) {
      docCount = count;
      storeMetaDocIfReady();
    });

    //
    // check blob support
    //
    if (!blobSupportPromise) {
      // make sure blob support is only checked once
      blobSupportPromise = checkBlobSupport(txn);
    }

    blobSupportPromise.then(function (val) {
      blobSupport = val;
      completeSetup();
    });

    // only when the metadata put transaction has completed,
    // consider the setup done
    txn.oncomplete = function () {
      storedMetaDoc = true;
      completeSetup();
    };
  };

  req.onerror = function () {
    var msg = 'Failed to open indexedDB, are you in private browsing mode?';
    guardedConsole('error', msg);
    callback(createError(IDB_ERROR, msg));
  };
}

IdbPouch.valid = function () {
  // Issue #2533, we finally gave up on doing bug
  // detection instead of browser sniffing. Safari brought us
  // to our knees.
  var isSafari = typeof openDatabase !== 'undefined' &&
    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&
    !/Chrome/.test(navigator.userAgent) &&
    !/BlackBerry/.test(navigator.platform);

  // some outdated implementations of IDB that appear on Samsung
  // and HTC Android devices <4.4 are missing IDBKeyRange
  return !isSafari && typeof indexedDB !== 'undefined' &&
    typeof IDBKeyRange !== 'undefined';
};

function tryStorageOption(dbName, storage) {
  try { // option only available in Firefox 26+
    return indexedDB.open(dbName, {
      version: ADAPTER_VERSION,
      storage: storage
    });
  } catch (err) {
      return indexedDB.open(dbName, ADAPTER_VERSION);
  }
}

var IDBPouch = function (PouchDB) {
  PouchDB.adapter('idb', IdbPouch, true);
};

//
// Parsing hex strings. Yeah.
//
// So basically we need this because of a bug in WebSQL:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
//
// UTF-8 and UTF-16 are provided as separate functions
// for meager performance improvements
//

function decodeUtf8(str) {
  return decodeURIComponent(escape(str));
}

function hexToInt(charCode) {
  // '0'-'9' is 48-57
  // 'A'-'F' is 65-70
  // SQLite will only give us uppercase hex
  return charCode < 65 ? (charCode - 48) : (charCode - 55);
}


// Example:
// pragma encoding=utf8;
// select hex('A');
// returns '41'
function parseHexUtf8(str, start, end) {
  var result = '';
  while (start < end) {
    result += String.fromCharCode(
      (hexToInt(str.charCodeAt(start++)) << 4) |
        hexToInt(str.charCodeAt(start++)));
  }
  return result;
}

// Example:
// pragma encoding=utf16;
// select hex('A');
// returns '4100'
// notice that the 00 comes after the 41 (i.e. it's swizzled)
function parseHexUtf16(str, start, end) {
  var result = '';
  while (start < end) {
    // UTF-16, so swizzle the bytes
    result += String.fromCharCode(
      (hexToInt(str.charCodeAt(start + 2)) << 12) |
        (hexToInt(str.charCodeAt(start + 3)) << 8) |
        (hexToInt(str.charCodeAt(start)) << 4) |
        hexToInt(str.charCodeAt(start + 1)));
    start += 4;
  }
  return result;
}

function parseHexString(str, encoding) {
  if (encoding === 'UTF-8') {
    return decodeUtf8(parseHexUtf8(str, 0, str.length));
  } else {
    return parseHexUtf16(str, 0, str.length);
  }
}

function quote(str) {
  return "'" + str + "'";
}

var ADAPTER_VERSION$1 = 7; // used to manage migrations

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
var DOC_STORE$1 = quote('document-store');
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE$1 = quote('by-sequence');
// Where we store attachments
var ATTACH_STORE$1 = quote('attach-store');
var LOCAL_STORE$1 = quote('local-store');
var META_STORE$1 = quote('metadata-store');
// where we store many-to-many relations between attachment
// digests and seqs
var ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');

// escapeBlob and unescapeBlob are workarounds for a websql bug:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
// The goal is to never actually insert the \u0000 character
// in the database.
function escapeBlob(str) {
  return str
    .replace(/\u0002/g, '\u0002\u0002')
    .replace(/\u0001/g, '\u0001\u0002')
    .replace(/\u0000/g, '\u0001\u0001');
}

function unescapeBlob(str) {
  return str
    .replace(/\u0001\u0001/g, '\u0000')
    .replace(/\u0001\u0002/g, '\u0001')
    .replace(/\u0002\u0002/g, '\u0002');
}

function stringifyDoc(doc) {
  // don't bother storing the id/rev. it uses lots of space,
  // in persistent map/reduce especially
  delete doc._id;
  delete doc._rev;
  return JSON.stringify(doc);
}

function unstringifyDoc(doc, id, rev$$1) {
  doc = JSON.parse(doc);
  doc._id = id;
  doc._rev = rev$$1;
  return doc;
}

// question mark groups IN queries, e.g. 3 -> '(?,?,?)'
function qMarks(num) {
  var s = '(';
  while (num--) {
    s += '?';
    if (num) {
      s += ',';
    }
  }
  return s + ')';
}

function select(selector, table, joiner, where, orderBy) {
  return 'SELECT ' + selector + ' FROM ' +
    (typeof table === 'string' ? table : table.join(' JOIN ')) +
    (joiner ? (' ON ' + joiner) : '') +
    (where ? (' WHERE ' +
    (typeof where === 'string' ? where : where.join(' AND '))) : '') +
    (orderBy ? (' ORDER BY ' + orderBy) : '');
}

function compactRevs$1(revs, docId, tx) {

  if (!revs.length) {
    return;
  }

  var numDone = 0;
  var seqs = [];

  function checkDone() {
    if (++numDone === revs.length) { // done
      deleteOrphans();
    }
  }

  function deleteOrphans() {
    // find orphaned attachment digests

    if (!seqs.length) {
      return;
    }

    var sql = 'SELECT DISTINCT digest AS digest FROM ' +
      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);

    tx.executeSql(sql, seqs, function (tx, res) {

      var digestsToCheck = [];
      for (var i = 0; i < res.rows.length; i++) {
        digestsToCheck.push(res.rows.item(i).digest);
      }
      if (!digestsToCheck.length) {
        return;
      }

      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +
        ' WHERE seq IN (' +
        seqs.map(function () { return '?'; }).join(',') +
        ')';
      tx.executeSql(sql, seqs, function (tx) {

        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +
          ' WHERE digest IN (' +
          digestsToCheck.map(function () { return '?'; }).join(',') +
          ')';
        tx.executeSql(sql, digestsToCheck, function (tx, res) {
          var nonOrphanedDigests = new ExportedSet();
          for (var i = 0; i < res.rows.length; i++) {
            nonOrphanedDigests.add(res.rows.item(i).digest);
          }
          digestsToCheck.forEach(function (digest) {
            if (nonOrphanedDigests.has(digest)) {
              return;
            }
            tx.executeSql(
              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',
              [digest]);
            tx.executeSql(
              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);
          });
        });
      });
    });
  }

  // update by-seq and attach stores in parallel
  revs.forEach(function (rev$$1) {
    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +
      ' WHERE doc_id=? AND rev=?';

    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {
      if (!res.rows.length) { // already deleted
        return checkDone();
      }
      var seq = res.rows.item(0).seq;
      seqs.push(seq);

      tx.executeSql(
        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);
    });
  });
}

function websqlError(callback) {
  return function (event) {
    guardedConsole('error', 'WebSQL threw an error', event);
    // event may actually be a SQLError object, so report is as such
    var errorNameMatch = event && event.constructor.toString()
        .match(/function ([^(]+)/);
    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;
    var errorReason = event.target || event.message;
    callback(createError(WSQ_ERROR, errorReason, errorName));
  };
}

function getSize(opts) {
  if ('size' in opts) {
    // triggers immediate popup in iOS, fixes #2347
    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,
    return opts.size * 1000000;
  }
  // In iOS, doesn't matter as long as it's <= 5000000.
  // Except that if you request too much, our tests fail
  // because of the native "do you accept?" popup.
  // In Android <=4.3, this value is actually used as an
  // honest-to-god ceiling for data, so we need to
  // set it to a decently high number.
  var isAndroid = typeof navigator !== 'undefined' &&
    /Android/.test(navigator.userAgent);
  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash
}

function websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {
  var newEdits = opts.new_edits;
  var userDocs = req.docs;

  // Parse the docs, give them a sequence number for the result
  var docInfos = userDocs.map(function (doc) {
    if (doc._id && isLocalId(doc._id)) {
      return doc;
    }
    var newDoc = parseDoc(doc, newEdits);
    return newDoc;
  });

  var docInfoErrors = docInfos.filter(function (docInfo) {
    return docInfo.error;
  });
  if (docInfoErrors.length) {
    return callback(docInfoErrors[0]);
  }

  var tx;
  var results = new Array(docInfos.length);
  var fetchedDocs = new ExportedMap();

  var preconditionErrored;
  function complete() {
    if (preconditionErrored) {
      return callback(preconditionErrored);
    }
    websqlChanges.notify(api._name);
    callback(null, results);
  }

  function verifyAttachment(digest, callback) {
    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +
      ' WHERE digest=?';
    tx.executeSql(sql, [digest], function (tx, result) {
      if (result.rows.item(0).cnt === 0) {
        var err = createError(MISSING_STUB,
          'unknown stub attachment with digest ' +
          digest);
        callback(err);
      } else {
        callback();
      }
    });
  }

  function verifyAttachments(finish) {
    var digests = [];
    docInfos.forEach(function (docInfo) {
      if (docInfo.data && docInfo.data._attachments) {
        Object.keys(docInfo.data._attachments).forEach(function (filename) {
          var att = docInfo.data._attachments[filename];
          if (att.stub) {
            digests.push(att.digest);
          }
        });
      }
    });
    if (!digests.length) {
      return finish();
    }
    var numDone = 0;
    var err;

    function checkDone() {
      if (++numDone === digests.length) {
        finish(err);
      }
    }
    digests.forEach(function (digest) {
      verifyAttachment(digest, function (attErr) {
        if (attErr && !err) {
          err = attErr;
        }
        checkDone();
      });
    });
  }

  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                    isUpdate, delta, resultsIdx, callback) {

    function finish() {
      var data = docInfo.data;
      var deletedInt = newRevIsDeleted ? 1 : 0;

      var id = data._id;
      var rev = data._rev;
      var json = stringifyDoc(data);
      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +
        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';
      var sqlArgs = [id, rev, json, deletedInt];

      // map seqs to attachment digests, which
      // we will need later during compaction
      function insertAttachmentMappings(seq, callback) {
        var attsAdded = 0;
        var attsToAdd = Object.keys(data._attachments || {});

        if (!attsToAdd.length) {
          return callback();
        }
        function checkDone() {
          if (++attsAdded === attsToAdd.length) {
            callback();
          }
          return false; // ack handling a constraint error
        }
        function add(att) {
          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +
            ' (digest, seq) VALUES (?,?)';
          var sqlArgs = [data._attachments[att].digest, seq];
          tx.executeSql(sql, sqlArgs, checkDone, checkDone);
          // second callback is for a constaint error, which we ignore
          // because this docid/rev has already been associated with
          // the digest (e.g. when new_edits == false)
        }
        for (var i = 0; i < attsToAdd.length; i++) {
          add(attsToAdd[i]); // do in parallel
        }
      }

      tx.executeSql(sql, sqlArgs, function (tx, result) {
        var seq = result.insertId;
        insertAttachmentMappings(seq, function () {
          dataWritten(tx, seq);
        });
      }, function () {
        // constraint error, recover by updating instead (see #1638)
        var fetchSql = select('seq', BY_SEQ_STORE$1, null,
          'doc_id=? AND rev=?');
        tx.executeSql(fetchSql, [id, rev], function (tx, res) {
          var seq = res.rows.item(0).seq;
          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +
            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';
          var sqlArgs = [json, deletedInt, id, rev];
          tx.executeSql(sql, sqlArgs, function (tx) {
            insertAttachmentMappings(seq, function () {
              dataWritten(tx, seq);
            });
          });
        });
        return false; // ack that we've handled the error
      });
    }

    function collectResults(attachmentErr) {
      if (!err) {
        if (attachmentErr) {
          err = attachmentErr;
          callback(err);
        } else if (recv === attachments.length) {
          finish();
        }
      }
    }

    var err = null;
    var recv = 0;

    docInfo.data._id = docInfo.metadata.id;
    docInfo.data._rev = docInfo.metadata.rev;
    var attachments = Object.keys(docInfo.data._attachments || {});


    if (newRevIsDeleted) {
      docInfo.data._deleted = true;
    }

    function attachmentSaved(err) {
      recv++;
      collectResults(err);
    }

    attachments.forEach(function (key) {
      var att = docInfo.data._attachments[key];
      if (!att.stub) {
        var data = att.data;
        delete att.data;
        att.revpos = parseInt(winningRev$$1, 10);
        var digest = att.digest;
        saveAttachment(digest, data, attachmentSaved);
      } else {
        recv++;
        collectResults();
      }
    });

    if (!attachments.length) {
      finish();
    }

    function dataWritten(tx, seq) {
      var id = docInfo.metadata.id;

      var revsToCompact = docInfo.stemmedRevs || [];
      if (isUpdate && api.auto_compaction) {
        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);
      }
      if (revsToCompact.length) {
        compactRevs$1(revsToCompact, id, tx);
      }

      docInfo.metadata.seq = seq;
      var rev = docInfo.metadata.rev;
      delete docInfo.metadata.rev;

      var sql = isUpdate ?
      'UPDATE ' + DOC_STORE$1 +
      ' SET json=?, max_seq=?, winningseq=' +
      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +
      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'
        : 'INSERT INTO ' + DOC_STORE$1 +
      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';
      var metadataStr = safeJsonStringify(docInfo.metadata);
      var params = isUpdate ?
        [metadataStr, seq, winningRev$$1, id] :
        [id, seq, seq, metadataStr];
      tx.executeSql(sql, params, function () {
        results[resultsIdx] = {
          ok: true,
          id: docInfo.metadata.id,
          rev: rev
        };
        fetchedDocs.set(id, docInfo.metadata);
        callback();
      });
    }
  }

  function websqlProcessDocs() {
    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,
                results, writeDoc, opts);
  }

  function fetchExistingDocs(callback) {
    if (!docInfos.length) {
      return callback();
    }

    var numFetched = 0;

    function checkDone() {
      if (++numFetched === docInfos.length) {
        callback();
      }
    }

    docInfos.forEach(function (docInfo) {
      if (docInfo._id && isLocalId(docInfo._id)) {
        return checkDone(); // skip local docs
      }
      var id = docInfo.metadata.id;
      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +
      ' WHERE id = ?', [id], function (tx, result) {
        if (result.rows.length) {
          var metadata = safeJsonParse(result.rows.item(0).json);
          fetchedDocs.set(id, metadata);
        }
        checkDone();
      });
    });
  }

  function saveAttachment(digest, data, callback) {
    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';
    tx.executeSql(sql, [digest], function (tx, result) {
      if (result.rows.length) { // attachment already exists
        return callback();
      }
      // we could just insert before selecting and catch the error,
      // but my hunch is that it's cheaper not to serialize the blob
      // from JS to C if we don't have to (TODO: confirm this)
      sql = 'INSERT INTO ' + ATTACH_STORE$1 +
      ' (digest, body, escaped) VALUES (?,?,1)';
      tx.executeSql(sql, [digest, escapeBlob(data)], function () {
        callback();
      }, function () {
        // ignore constaint errors, means it already exists
        callback();
        return false; // ack we handled the error
      });
    });
  }

  preprocessAttachments(docInfos, 'binary', function (err) {
    if (err) {
      return callback(err);
    }
    db.transaction(function (txn) {
      tx = txn;
      verifyAttachments(function (err) {
        if (err) {
          preconditionErrored = err;
        } else {
          fetchExistingDocs(websqlProcessDocs);
        }
      });
    }, websqlError(callback), complete);
  });
}

var cachedDatabases = new ExportedMap();

// openDatabase passed in through opts (e.g. for node-websql)
function openDatabaseWithOpts(opts) {
  return opts.websql(opts.name, opts.version, opts.description, opts.size);
}

function openDBSafely(opts) {
  try {
    return {
      db: openDatabaseWithOpts(opts)
    };
  } catch (err) {
    return {
      error: err
    };
  }
}

function openDB$1(opts) {
  var cachedResult = cachedDatabases.get(opts.name);
  if (!cachedResult) {
    cachedResult = openDBSafely(opts);
    cachedDatabases.set(opts.name, cachedResult);
  }
  return cachedResult;
}

var websqlChanges = new Changes();

function fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {
  var attachments = Object.keys(doc._attachments || {});
  if (!attachments.length) {
    return cb && cb();
  }
  var numDone = 0;

  function checkDone() {
    if (++numDone === attachments.length && cb) {
      cb();
    }
  }

  function fetchAttachment(doc, att) {
    var attObj = doc._attachments[att];
    var attOpts = {binary: opts.binary, ctx: txn};
    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {
      doc._attachments[att] = $inject_Object_assign(
        pick(attObj, ['digest', 'content_type']),
        { data: data }
      );
      checkDone();
    });
  }

  attachments.forEach(function (att) {
    if (opts.attachments && opts.include_docs) {
      fetchAttachment(doc, att);
    } else {
      doc._attachments[att].stub = true;
      checkDone();
    }
  });
}

var POUCH_VERSION = 1;

// these indexes cover the ground for most allDocs queries
var BY_SEQ_STORE_DELETED_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'by-seq-deleted-idx\' ON ' +
  BY_SEQ_STORE$1 + ' (seq, deleted)';
var BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =
  'CREATE UNIQUE INDEX IF NOT EXISTS \'by-seq-doc-id-rev\' ON ' +
    BY_SEQ_STORE$1 + ' (doc_id, rev)';
var DOC_STORE_WINNINGSEQ_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'doc-winningseq-idx\' ON ' +
  DOC_STORE$1 + ' (winningseq)';
var ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'attach-seq-seq-idx\' ON ' +
    ATTACH_AND_SEQ_STORE$1 + ' (seq)';
var ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =
  'CREATE UNIQUE INDEX IF NOT EXISTS \'attach-seq-digest-idx\' ON ' +
    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';

var DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +
  '.seq = ' + DOC_STORE$1 + '.winningseq';

var SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +
  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +
  BY_SEQ_STORE$1 + '.json AS data, ' +
  BY_SEQ_STORE$1 + '.rev AS rev, ' +
  DOC_STORE$1 + '.json AS metadata';

function WebSqlPouch$1(opts, callback) {
  var api = this;
  var instanceId = null;
  var size = getSize(opts);
  var idRequests = [];
  var encoding;

  api._name = opts.name;

  // extend the options here, because sqlite plugin has a ton of options
  // and they are constantly changing, so it's more prudent to allow anything
  var websqlOpts = $inject_Object_assign({}, opts, {
    version: POUCH_VERSION,
    description: opts.name,
    size: size
  });
  var openDBResult = openDB$1(websqlOpts);
  if (openDBResult.error) {
    return websqlError(callback)(openDBResult.error);
  }
  var db = openDBResult.db;
  if (typeof db.readTransaction !== 'function') {
    // doesn't exist in sqlite plugin
    db.readTransaction = db.transaction;
  }

  function dbCreated() {
    // note the db name in case the browser upgrades to idb
    if (hasLocalStorage()) {
      window.localStorage['_pouch__websqldb_' + api._name] = true;
    }
    callback(null, api);
  }

  // In this migration, we added the 'deleted' and 'local' columns to the
  // by-seq and doc store tables.
  // To preserve existing user data, we re-process all the existing JSON
  // and add these values.
  // Called migration2 because it corresponds to adapter version (db_version) #2
  function runMigration2(tx, callback) {
    // index used for the join in the allDocs query
    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);

    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +
      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {
      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +
        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {
        tx.executeSql('CREATE INDEX IF NOT EXISTS \'doc-store-local-idx\' ON ' +
          DOC_STORE$1 + ' (local, id)');

        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +
          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +
          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';

        tx.executeSql(sql, [], function (tx, result) {

          var deleted = [];
          var local = [];

          for (var i = 0; i < result.rows.length; i++) {
            var item = result.rows.item(i);
            var seq = item.seq;
            var metadata = JSON.parse(item.metadata);
            if (isDeleted(metadata)) {
              deleted.push(seq);
            }
            if (isLocalId(metadata.id)) {
              local.push(metadata.id);
            }
          }
          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +
            qMarks(local.length), local, function () {
            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +
              ' SET deleted = 1 WHERE seq IN ' +
              qMarks(deleted.length), deleted, callback);
          });
        });
      });
    });
  }

  // in this migration, we make all the local docs unversioned
  function runMigration3(tx, callback) {
    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +
      ' (id UNIQUE, rev, json)';
    tx.executeSql(local, [], function () {
      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +
        BY_SEQ_STORE$1 + '.json AS data ' +
        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +
        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +
        DOC_STORE$1 + '.winningseq WHERE local = 1';
      tx.executeSql(sql, [], function (tx, res) {
        var rows = [];
        for (var i = 0; i < res.rows.length; i++) {
          rows.push(res.rows.item(i));
        }
        function doNext() {
          if (!rows.length) {
            return callback(tx);
          }
          var row = rows.shift();
          var rev$$1 = JSON.parse(row.data)._rev;
          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +
              ' (id, rev, json) VALUES (?,?,?)',
              [row.id, rev$$1, row.data], function (tx) {
            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',
                [row.id], function (tx) {
              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',
                  [row.seq], function () {
                doNext();
              });
            });
          });
        }
        doNext();
      });
    });
  }

  // in this migration, we remove doc_id_rev and just use rev
  function runMigration4(tx, callback) {

    function updateRows(rows) {
      function doNext() {
        if (!rows.length) {
          return callback(tx);
        }
        var row = rows.shift();
        var doc_id_rev = parseHexString(row.hex, encoding);
        var idx = doc_id_rev.lastIndexOf('::');
        var doc_id = doc_id_rev.substring(0, idx);
        var rev$$1 = doc_id_rev.substring(idx + 2);
        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +
          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';
        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {
          doNext();
        });
      }
      doNext();
    }

    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';
    tx.executeSql(sql, [], function (tx) {
      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';
      tx.executeSql(sql, [], function (tx) {
        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {
          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;
          tx.executeSql(sql, [], function (tx, res) {
            var rows = [];
            for (var i = 0; i < res.rows.length; i++) {
              rows.push(res.rows.item(i));
            }
            updateRows(rows);
          });
        });
      });
    });
  }

  // in this migration, we add the attach_and_seq table
  // for issue #2818
  function runMigration5(tx, callback) {

    function migrateAttsAndSeqs(tx) {
      // need to actually populate the table. this is the expensive part,
      // so as an optimization, check first that this database even
      // contains attachments
      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;
      tx.executeSql(sql, [], function (tx, res) {
        var count = res.rows.item(0).cnt;
        if (!count) {
          return callback(tx);
        }

        var offset = 0;
        var pageSize = 10;
        function nextPage() {
          var sql = select(
            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',
            [DOC_STORE$1, BY_SEQ_STORE$1],
            DOC_STORE_AND_BY_SEQ_JOINER,
            null,
            DOC_STORE$1 + '.id '
          );
          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;
          offset += pageSize;
          tx.executeSql(sql, [], function (tx, res) {
            if (!res.rows.length) {
              return callback(tx);
            }
            var digestSeqs = {};
            function addDigestSeq(digest, seq) {
              // uniq digest/seq pairs, just in case there are dups
              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);
              if (seqs.indexOf(seq) === -1) {
                seqs.push(seq);
              }
            }
            for (var i = 0; i < res.rows.length; i++) {
              var row = res.rows.item(i);
              var doc = unstringifyDoc(row.data, row.id, row.rev);
              var atts = Object.keys(doc._attachments || {});
              for (var j = 0; j < atts.length; j++) {
                var att = doc._attachments[atts[j]];
                addDigestSeq(att.digest, row.seq);
              }
            }
            var digestSeqPairs = [];
            Object.keys(digestSeqs).forEach(function (digest) {
              var seqs = digestSeqs[digest];
              seqs.forEach(function (seq) {
                digestSeqPairs.push([digest, seq]);
              });
            });
            if (!digestSeqPairs.length) {
              return nextPage();
            }
            var numDone = 0;
            digestSeqPairs.forEach(function (pair) {
              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +
                ' (digest, seq) VALUES (?,?)';
              tx.executeSql(sql, pair, function () {
                if (++numDone === digestSeqPairs.length) {
                  nextPage();
                }
              });
            });
          });
        }
        nextPage();
      });
    }

    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
    tx.executeSql(attachAndRev, [], function (tx) {
      tx.executeSql(
        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {
          tx.executeSql(
            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],
            migrateAttsAndSeqs);
        });
    });
  }

  // in this migration, we use escapeBlob() and unescapeBlob()
  // instead of reading out the binary as HEX, which is slow
  function runMigration6(tx, callback) {
    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +
      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';
    tx.executeSql(sql, [], callback);
  }

  // issue #3136, in this migration we need a "latest seq" as well
  // as the "winning seq" in the doc store
  function runMigration7(tx, callback) {
    var sql = 'ALTER TABLE ' + DOC_STORE$1 +
      ' ADD COLUMN max_seq INTEGER';
    tx.executeSql(sql, [], function (tx) {
      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +
        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';
      tx.executeSql(sql, [], function (tx) {
        // add unique index after filling, else we'll get a constraint
        // error when we do the ALTER TABLE
        var sql =
          'CREATE UNIQUE INDEX IF NOT EXISTS \'doc-max-seq-idx\' ON ' +
          DOC_STORE$1 + ' (max_seq)';
        tx.executeSql(sql, [], callback);
      });
    });
  }

  function checkEncoding(tx, cb) {
    // UTF-8 on chrome/android, UTF-16 on safari < 7.1
    tx.executeSql('SELECT HEX("a") AS hex', [], function (tx, res) {
        var hex = res.rows.item(0).hex;
        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';
        cb();
      }
    );
  }

  function onGetInstanceId() {
    while (idRequests.length > 0) {
      var idCallback = idRequests.pop();
      idCallback(null, instanceId);
    }
  }

  function onGetVersion(tx, dbVersion) {
    if (dbVersion === 0) {
      // initial schema

      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +
        ' (dbid, db_version INTEGER)';
      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +
        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';
      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
      // TODO: migrate winningseq to INTEGER
      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +
        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';
      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +
        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +
        'json, deleted TINYINT(1), doc_id, rev)';
      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +
        ' (id UNIQUE, rev, json)';

      // creates
      tx.executeSql(attach);
      tx.executeSql(local);
      tx.executeSql(attachAndRev, [], function () {
        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);
        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);
      });
      tx.executeSql(doc, [], function () {
        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
        tx.executeSql(seq, [], function () {
          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);
          tx.executeSql(meta, [], function () {
            // mark the db version, and new dbid
            var initSeq = 'INSERT INTO ' + META_STORE$1 +
              ' (db_version, dbid) VALUES (?,?)';
            instanceId = uuid();
            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];
            tx.executeSql(initSeq, initSeqArgs, function () {
              onGetInstanceId();
            });
          });
        });
      });
    } else { // version > 0

      var setupDone = function () {
        var migrated = dbVersion < ADAPTER_VERSION$1;
        if (migrated) {
          // update the db version within this transaction
          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +
            ADAPTER_VERSION$1);
        }
        // notify db.id() callers
        var sql = 'SELECT dbid FROM ' + META_STORE$1;
        tx.executeSql(sql, [], function (tx, result) {
          instanceId = result.rows.item(0).dbid;
          onGetInstanceId();
        });
      };

      // would love to use promises here, but then websql
      // ends the transaction early
      var tasks = [
        runMigration2,
        runMigration3,
        runMigration4,
        runMigration5,
        runMigration6,
        runMigration7,
        setupDone
      ];

      // run each migration sequentially
      var i = dbVersion;
      var nextMigration = function (tx) {
        tasks[i - 1](tx, nextMigration);
        i++;
      };
      nextMigration(tx);
    }
  }

  function setup() {
    db.transaction(function (tx) {
      // first check the encoding
      checkEncoding(tx, function () {
        // then get the version
        fetchVersion(tx);
      });
    }, websqlError(callback), dbCreated);
  }

  function fetchVersion(tx) {
    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;
    tx.executeSql(sql, [], function (tx, result) {
      if (!result.rows.length) {
        // database hasn't even been created yet (version 0)
        onGetVersion(tx, 0);
      } else if (!/db_version/.test(result.rows.item(0).sql)) {
        // table was created, but without the new db_version column,
        // so add it.
        tx.executeSql('ALTER TABLE ' + META_STORE$1 +
          ' ADD COLUMN db_version INTEGER', [], function () {
          // before version 2, this column didn't even exist
          onGetVersion(tx, 1);
        });
      } else { // column exists, we can safely get it
        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,
          [], function (tx, result) {
          var dbVersion = result.rows.item(0).db_version;
          onGetVersion(tx, dbVersion);
        });
      }
    });
  }

  setup();

  function getMaxSeq(tx, callback) {
    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;
    tx.executeSql(sql, [], function (tx, res) {
      var updateSeq = res.rows.item(0).seq || 0;
      callback(updateSeq);
    });
  }

  function countDocs(tx, callback) {
    // count the total rows
    var sql = select(
      'COUNT(' + DOC_STORE$1 + '.id) AS \'num\'',
      [DOC_STORE$1, BY_SEQ_STORE$1],
      DOC_STORE_AND_BY_SEQ_JOINER,
      BY_SEQ_STORE$1 + '.deleted=0');

    tx.executeSql(sql, [], function (tx, result) {
      callback(result.rows.item(0).num);
    });
  }

  api._remote = false;
  api.type = function () {
    return 'websql';
  };

  api._id = toPromise(function (callback) {
    callback(null, instanceId);
  });

  api._info = function (callback) {
    var seq;
    var docCount;
    db.readTransaction(function (tx) {
      getMaxSeq(tx, function (theSeq) {
        seq = theSeq;
      });
      countDocs(tx, function (theDocCount) {
        docCount = theDocCount;
      });
    }, websqlError(callback), function () {
      callback(null, {
        doc_count: docCount,
        update_seq: seq,
        websql_encoding: encoding
      });
    });
  };

  api._bulkDocs = function (req, reqOpts, callback) {
    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);
  };

  function latest$$1(tx, id, rev$$1, callback, finish) {
    var sql = select(
        SELECT_DOCS,
        [DOC_STORE$1, BY_SEQ_STORE$1],
        DOC_STORE_AND_BY_SEQ_JOINER,
        DOC_STORE$1 + '.id=?');
    var sqlArgs = [id];

    tx.executeSql(sql, sqlArgs, function (a, results) {
      if (!results.rows.length) {
        var err = createError(MISSING_DOC, 'missing');
        return finish(err);
      }
      var item = results.rows.item(0);
      var metadata = safeJsonParse(item.metadata);
      callback(latest(rev$$1, metadata));
    });
  }

  api._get = function (id, opts, callback) {
    var doc;
    var metadata;
    var tx = opts.ctx;
    if (!tx) {
      return db.readTransaction(function (txn) {
        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);
      });
    }

    function finish(err) {
      callback(err, {doc: doc, metadata: metadata, ctx: tx});
    }

    var sql;
    var sqlArgs;

    if (!opts.rev) {
      sql = select(
        SELECT_DOCS,
        [DOC_STORE$1, BY_SEQ_STORE$1],
        DOC_STORE_AND_BY_SEQ_JOINER,
        DOC_STORE$1 + '.id=?');
      sqlArgs = [id];
    } else if (opts.latest) {
      latest$$1(tx, id, opts.rev, function (latestRev) {
        opts.latest = false;
        opts.rev = latestRev;
        api._get(id, opts, callback);
      }, finish);
      return;
    } else {
      sql = select(
        SELECT_DOCS,
        [DOC_STORE$1, BY_SEQ_STORE$1],
        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',
        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);
      sqlArgs = [id, opts.rev];
    }

    tx.executeSql(sql, sqlArgs, function (a, results) {
      if (!results.rows.length) {
        var missingErr = createError(MISSING_DOC, 'missing');
        return finish(missingErr);
      }
      var item = results.rows.item(0);
      metadata = safeJsonParse(item.metadata);
      if (item.deleted && !opts.rev) {
        var deletedErr = createError(MISSING_DOC, 'deleted');
        return finish(deletedErr);
      }
      doc = unstringifyDoc(item.data, metadata.id, item.rev);
      finish();
    });
  };

  api._allDocs = function (opts, callback) {
    var results = [];
    var totalRows;

    var start = 'startkey' in opts ? opts.startkey : false;
    var end = 'endkey' in opts ? opts.endkey : false;
    var key = 'key' in opts ? opts.key : false;
    var descending = 'descending' in opts ? opts.descending : false;
    var limit = 'limit' in opts ? opts.limit : -1;
    var offset = 'skip' in opts ? opts.skip : 0;
    var inclusiveEnd = opts.inclusive_end !== false;

    var sqlArgs = [];
    var criteria = [];

    if (key !== false) {
      criteria.push(DOC_STORE$1 + '.id = ?');
      sqlArgs.push(key);
    } else if (start !== false || end !== false) {
      if (start !== false) {
        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');
        sqlArgs.push(start);
      }
      if (end !== false) {
        var comparator = descending ? '>' : '<';
        if (inclusiveEnd) {
          comparator += '=';
        }
        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');
        sqlArgs.push(end);
      }
      if (key !== false) {
        criteria.push(DOC_STORE$1 + '.id = ?');
        sqlArgs.push(key);
      }
    }

    if (opts.deleted !== 'ok') {
      // report deleted if keys are specified
      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');
    }

    db.readTransaction(function (tx) {
      // count the docs in parallel to other operations
      countDocs(tx, function (docCount) {
        totalRows = docCount;
      });

      if (limit === 0) {
        return;
      }

      // do a single query to fetch the documents
      var sql = select(
        SELECT_DOCS,
        [DOC_STORE$1, BY_SEQ_STORE$1],
        DOC_STORE_AND_BY_SEQ_JOINER,
        criteria,
        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')
        );
      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;

      tx.executeSql(sql, sqlArgs, function (tx, result) {
        for (var i = 0, l = result.rows.length; i < l; i++) {
          var item = result.rows.item(i);
          var metadata = safeJsonParse(item.metadata);
          var id = metadata.id;
          var data = unstringifyDoc(item.data, id, item.rev);
          var winningRev$$1 = data._rev;
          var doc = {
            id: id,
            key: id,
            value: {rev: winningRev$$1}
          };
          if (opts.include_docs) {
            doc.doc = data;
            doc.doc._rev = winningRev$$1;
            if (opts.conflicts) {
              var conflicts = collectConflicts(metadata);
              if (conflicts.length) {
                doc.doc._conflicts = conflicts;
              }
            }
            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);
          }
          if (item.deleted) {
            if (opts.deleted === 'ok') {
              doc.value.deleted = true;
              doc.doc = null;
            } else {
              continue;
            }
          }
          results.push(doc);
        }
      });
    }, websqlError(callback), function () {
      callback(null, {
        total_rows: totalRows,
        offset: opts.skip,
        rows: results
      });
    });
  };

  api._changes = function (opts) {
    opts = clone(opts);

    if (opts.continuous) {
      var id = api._name + ':' + uuid();
      websqlChanges.addListener(api._name, id, api, opts);
      websqlChanges.notify(api._name);
      return {
        cancel: function () {
          websqlChanges.removeListener(api._name, id);
        }
      };
    }

    var descending = opts.descending;

    // Ignore the `since` parameter when `descending` is true
    opts.since = opts.since && !descending ? opts.since : 0;

    var limit = 'limit' in opts ? opts.limit : -1;
    if (limit === 0) {
      limit = 1; // per CouchDB _changes spec
    }

    var returnDocs;
    if ('return_docs' in opts) {
      returnDocs = opts.return_docs;
    } else if ('returnDocs' in opts) {
      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }
    var results = [];
    var numResults = 0;

    function fetchChanges() {

      var selectStmt =
        DOC_STORE$1 + '.json AS metadata, ' +
        DOC_STORE$1 + '.max_seq AS maxSeq, ' +
        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +
        BY_SEQ_STORE$1 + '.rev AS winningRev ';

      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;

      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +
        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';

      var criteria = ['maxSeq > ?'];
      var sqlArgs = [opts.since];

      if (opts.doc_ids) {
        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));
        sqlArgs = sqlArgs.concat(opts.doc_ids);
      }

      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');

      var sql = select(selectStmt, from, joiner, criteria, orderBy);

      var filter = filterChange(opts);
      if (!opts.view && !opts.filter) {
        // we can just limit in the query
        sql += ' LIMIT ' + limit;
      }

      var lastSeq = opts.since || 0;
      db.readTransaction(function (tx) {
        tx.executeSql(sql, sqlArgs, function (tx, result) {
          function reportChange(change) {
            return function () {
              opts.onChange(change);
            };
          }
          for (var i = 0, l = result.rows.length; i < l; i++) {
            var item = result.rows.item(i);
            var metadata = safeJsonParse(item.metadata);
            lastSeq = item.maxSeq;

            var doc = unstringifyDoc(item.winningDoc, metadata.id,
              item.winningRev);
            var change = opts.processChange(doc, metadata, opts);
            change.seq = item.maxSeq;

            var filtered = filter(change);
            if (typeof filtered === 'object') {
              return opts.complete(filtered);
            }

            if (filtered) {
              numResults++;
              if (returnDocs) {
                results.push(change);
              }
              // process the attachment immediately
              // for the benefit of live listeners
              if (opts.attachments && opts.include_docs) {
                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,
                  reportChange(change));
              } else {
                reportChange(change)();
              }
            }
            if (numResults === limit) {
              break;
            }
          }
        });
      }, websqlError(opts.complete), function () {
        if (!opts.continuous) {
          opts.complete(null, {
            results: results,
            last_seq: lastSeq
          });
        }
      });
    }

    fetchChanges();
  };

  api._close = function (callback) {
    //WebSQL databases do not need to be closed
    callback();
  };

  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var res;
    var tx = opts.ctx;
    var digest = attachment.digest;
    var type = attachment.content_type;
    var sql = 'SELECT escaped, ' +
      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +
      ATTACH_STORE$1 + ' WHERE digest=?';
    tx.executeSql(sql, [digest], function (tx, result) {
      // websql has a bug where \u0000 causes early truncation in strings
      // and blobs. to work around this, we used to use the hex() function,
      // but that's not performant. after migration 6, we remove \u0000
      // and add it back in afterwards
      var item = result.rows.item(0);
      var data = item.escaped ? unescapeBlob(item.body) :
        parseHexString(item.body, encoding);
      if (opts.binary) {
        res = binStringToBluffer(data, type);
      } else {
        res = thisBtoa(data);
      }
      callback(null, res);
    });
  };

  api._getRevisionTree = function (docId, callback) {
    db.readTransaction(function (tx) {
      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
      tx.executeSql(sql, [docId], function (tx, result) {
        if (!result.rows.length) {
          callback(createError(MISSING_DOC));
        } else {
          var data = safeJsonParse(result.rows.item(0).metadata);
          callback(null, data.rev_tree);
        }
      });
    });
  };

  api._doCompaction = function (docId, revs, callback) {
    if (!revs.length) {
      return callback();
    }
    db.transaction(function (tx) {

      // update doc store
      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
      tx.executeSql(sql, [docId], function (tx, result) {
        var metadata = safeJsonParse(result.rows.item(0).metadata);
        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                           revHash, ctx, opts) {
          var rev$$1 = pos + '-' + revHash;
          if (revs.indexOf(rev$$1) !== -1) {
            opts.status = 'missing';
          }
        });

        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';
        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);
      });

      compactRevs$1(revs, docId, tx);
    }, websqlError(callback), function () {
      callback();
    });
  };

  api._getLocal = function (id, callback) {
    db.readTransaction(function (tx) {
      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';
      tx.executeSql(sql, [id], function (tx, res) {
        if (res.rows.length) {
          var item = res.rows.item(0);
          var doc = unstringifyDoc(item.json, id, item.rev);
          callback(null, doc);
        } else {
          callback(createError(MISSING_DOC));
        }
      });
    });
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    var newRev;
    if (!oldRev) {
      newRev = doc._rev = '0-1';
    } else {
      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }
    var json = stringifyDoc(doc);

    var ret;
    function putLocal(tx) {
      var sql;
      var values;
      if (oldRev) {
        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +
          'WHERE id=? AND rev=?';
        values = [newRev, json, id, oldRev];
      } else {
        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';
        values = [id, newRev, json];
      }
      tx.executeSql(sql, values, function (tx, res) {
        if (res.rowsAffected) {
          ret = {ok: true, id: id, rev: newRev};
          if (opts.ctx) { // return immediately
            callback(null, ret);
          }
        } else {
          callback(createError(REV_CONFLICT));
        }
      }, function () {
        callback(createError(REV_CONFLICT));
        return false; // ack that we handled the error
      });
    }

    if (opts.ctx) {
      putLocal(opts.ctx);
    } else {
      db.transaction(putLocal, websqlError(callback), function () {
        if (ret) {
          callback(null, ret);
        }
      });
    }
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var ret;

    function removeLocal(tx) {
      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';
      var params = [doc._id, doc._rev];
      tx.executeSql(sql, params, function (tx, res) {
        if (!res.rowsAffected) {
          return callback(createError(MISSING_DOC));
        }
        ret = {ok: true, id: doc._id, rev: '0-0'};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      });
    }

    if (opts.ctx) {
      removeLocal(opts.ctx);
    } else {
      db.transaction(removeLocal, websqlError(callback), function () {
        if (ret) {
          callback(null, ret);
        }
      });
    }
  };

  api._destroy = function (opts, callback) {
    websqlChanges.removeAllListeners(api._name);
    db.transaction(function (tx) {
      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,
        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];
      stores.forEach(function (store) {
        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);
      });
    }, websqlError(callback), function () {
      if (hasLocalStorage()) {
        delete window.localStorage['_pouch__websqldb_' + api._name];
        delete window.localStorage[api._name];
      }
      callback(null, {'ok': true});
    });
  };
}

function canOpenTestDB() {
  try {
    openDatabase('_pouch_validate_websql', 1, '', 1);
    return true;
  } catch (err) {
    return false;
  }
}

// WKWebView had a bug where WebSQL would throw a DOM Exception 18
// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and
// https://github.com/pouchdb/pouchdb/issues/5079)
// This has been fixed in latest WebKit, so we try to detect it here.
function isValidWebSQL() {
  // WKWebView UA:
  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)
  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75
  // Chrome for iOS UA:
  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)
  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60
  //   Mobile/9B206 Safari/7534.48.3
  // Firefox for iOS UA:
  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4
  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4

  // indexedDB is null on some UIWebViews and undefined in others
  // see: https://bugs.webkit.org/show_bug.cgi?id=137034
  if (typeof indexedDB === 'undefined' || indexedDB === null ||
      !/iP(hone|od|ad)/.test(navigator.userAgent)) {
    // definitely not WKWebView, avoid creating an unnecessary database
    return true;
  }
  // Cache the result in LocalStorage. Reason we do this is because if we
  // call openDatabase() too many times, Safari craps out in SauceLabs and
  // starts throwing DOM Exception 14s.
  var hasLS = hasLocalStorage();
  // Include user agent in the hash, so that if Safari is upgraded, we don't
  // continually think it's broken.
  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;
  if (hasLS && localStorage[localStorageKey]) {
    return localStorage[localStorageKey] === '1';
  }
  var openedTestDB = canOpenTestDB();
  if (hasLS) {
    localStorage[localStorageKey] = openedTestDB ? '1' : '0';
  }
  return openedTestDB;
}

function valid() {
  if (typeof openDatabase !== 'function') {
    return false;
  }
  return isValidWebSQL();
}

function openDB(name, version, description, size) {
  // Traditional WebSQL API
  return openDatabase(name, version, description, size);
}

function WebSQLPouch(opts, callback) {
  var _opts = $inject_Object_assign({
    websql: openDB
  }, opts);

  WebSqlPouch$1.call(this, _opts, callback);
}

WebSQLPouch.valid = valid;

WebSQLPouch.use_prefix = true;

var WebSqlPouch = function (PouchDB) {
  PouchDB.adapter('websql', WebSQLPouch, true);
};

/* global fetch */
/* global Headers */
function wrappedFetch() {
  var wrappedPromise = {};

  var promise = new PouchPromise$1(function (resolve, reject) {
    wrappedPromise.resolve = resolve;
    wrappedPromise.reject = reject;
  });

  var args = new Array(arguments.length);

  for (var i = 0; i < args.length; i++) {
    args[i] = arguments[i];
  }

  wrappedPromise.promise = promise;

  PouchPromise$1.resolve().then(function () {
    return fetch.apply(null, args);
  }).then(function (response) {
    wrappedPromise.resolve(response);
  })["catch"](function (error) {
    wrappedPromise.reject(error);
  });

  return wrappedPromise;
}

function fetchRequest(options, callback) {
  var wrappedPromise, timer, response;

  var headers = new Headers();

  var fetchOptions = {
    method: options.method,
    credentials: 'include',
    headers: headers
  };

  if (options.json) {
    headers.set('Accept', 'application/json');
    headers.set('Content-Type', options.headers['Content-Type'] ||
      'application/json');
  }

  if (options.body &&
      options.processData &&
      typeof options.body !== 'string') {
    fetchOptions.body = JSON.stringify(options.body);
  } else if ('body' in options) {
    fetchOptions.body = options.body;
  } else {
    fetchOptions.body = null;
  }

  Object.keys(options.headers).forEach(function (key) {
    if (options.headers.hasOwnProperty(key)) {
      headers.set(key, options.headers[key]);
    }
  });

  wrappedPromise = wrappedFetch(options.url, fetchOptions);

  if (options.timeout > 0) {
    timer = setTimeout(function () {
      wrappedPromise.reject(new Error('Load timeout for resource: ' +
        options.url));
    }, options.timeout);
  }

  wrappedPromise.promise.then(function (fetchResponse) {
    response = {
      statusCode: fetchResponse.status
    };

    if (options.timeout > 0) {
      clearTimeout(timer);
    }

    if (response.statusCode >= 200 && response.statusCode < 300) {
      return options.binary ? fetchResponse.blob() : fetchResponse.text();
    }

    return fetchResponse.json();
  }).then(function (result) {
    if (response.statusCode >= 200 && response.statusCode < 300) {
      callback(null, response, result);
    } else {
      result.status = response.statusCode;
      callback(result);
    }
  })["catch"](function (error) {
    if (!error) {
      // this happens when the listener is canceled
      error = new Error('canceled');
    }
    callback(error);
  });

  return {abort: wrappedPromise.reject};
}

function xhRequest(options, callback) {

  var xhr, timer;
  var timedout = false;

  var abortReq = function () {
    xhr.abort();
    cleanUp();
  };

  var timeoutReq = function () {
    timedout = true;
    xhr.abort();
    cleanUp();
  };

  var ret = {abort: abortReq};

  var cleanUp = function () {
    clearTimeout(timer);
    ret.abort = function () {};
    if (xhr) {
      xhr.onprogress = undefined;
      if (xhr.upload) {
        xhr.upload.onprogress = undefined;
      }
      xhr.onreadystatechange = undefined;
      xhr = undefined;
    }
  };

  if (options.xhr) {
    xhr = new options.xhr();
  } else {
    xhr = new XMLHttpRequest();
  }

  try {
    xhr.open(options.method, options.url);
  } catch (exception) {
    return callback(new Error(exception.name || 'Url is invalid'));
  }

  xhr.withCredentials = ('withCredentials' in options) ?
    options.withCredentials : true;

  if (options.method === 'GET') {
    delete options.headers['Content-Type'];
  } else if (options.json) {
    options.headers.Accept = 'application/json';
    options.headers['Content-Type'] = options.headers['Content-Type'] ||
      'application/json';
    if (options.body &&
        options.processData &&
        typeof options.body !== "string") {
      options.body = JSON.stringify(options.body);
    }
  }

  if (options.binary) {
    xhr.responseType = 'arraybuffer';
  }

  if (!('body' in options)) {
    options.body = null;
  }

  for (var key in options.headers) {
    if (options.headers.hasOwnProperty(key)) {
      xhr.setRequestHeader(key, options.headers[key]);
    }
  }

  if (options.timeout > 0) {
    timer = setTimeout(timeoutReq, options.timeout);
    xhr.onprogress = function () {
      clearTimeout(timer);
      if (xhr.readyState !== 4) {
        timer = setTimeout(timeoutReq, options.timeout);
      }
    };
    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9
      xhr.upload.onprogress = xhr.onprogress;
    }
  }

  xhr.onreadystatechange = function () {
    if (xhr.readyState !== 4) {
      return;
    }

    var response = {
      statusCode: xhr.status
    };

    if (xhr.status >= 200 && xhr.status < 300) {
      var data;
      if (options.binary) {
        data = createBlob([xhr.response || ''], {
          type: xhr.getResponseHeader('Content-Type')
        });
      } else {
        data = xhr.responseText;
      }
      callback(null, response, data);
    } else {
      var err = {};
      if (timedout) {
        err = new Error('ETIMEDOUT');
        err.code = 'ETIMEDOUT';
      } else if (typeof xhr.response === 'string') {
        try {
          err = JSON.parse(xhr.response);
        } catch (e) {}
      }
      err.status = xhr.status;
      callback(err);
    }
    cleanUp();
  };

  if (options.body && (options.body instanceof Blob)) {
    readAsArrayBuffer(options.body, function (arrayBuffer) {
      xhr.send(arrayBuffer);
    });
  } else {
    xhr.send(options.body);
  }

  return ret;
}

function testXhr() {
  try {
    new XMLHttpRequest();
    return true;
  } catch (err) {
    return false;
  }
}

var hasXhr = testXhr();

function ajax$1(options, callback) {
  if (!false && (hasXhr || options.xhr)) {
    return xhRequest(options, callback);
  } else {
    return fetchRequest(options, callback);
  }
}

// the blob already has a type; do nothing
var res$2 = function () {};

function defaultBody() {
  return '';
}

function ajaxCore$1(options, callback) {

  options = clone(options);

  var defaultOptions = {
    method : "GET",
    headers: {},
    json: true,
    processData: true,
    timeout: 10000,
    cache: false
  };

  options = $inject_Object_assign(defaultOptions, options);

  function onSuccess(obj, resp, cb) {
    if (!options.binary && options.json && typeof obj === 'string') {
      /* istanbul ignore next */
      try {
        obj = JSON.parse(obj);
      } catch (e) {
        // Probably a malformed JSON from server
        return cb(e);
      }
    }
    if (Array.isArray(obj)) {
      obj = obj.map(function (v) {
        if (v.error || v.missing) {
          return generateErrorFromResponse(v);
        } else {
          return v;
        }
      });
    }
    if (options.binary) {
      res$2(obj, resp);
    }
    cb(null, obj, resp);
  }

  if (options.json) {
    if (!options.binary) {
      options.headers.Accept = 'application/json';
    }
    options.headers['Content-Type'] = options.headers['Content-Type'] ||
      'application/json';
  }

  if (options.binary) {
    options.encoding = null;
    options.json = false;
  }

  if (!options.processData) {
    options.json = false;
  }

  return ajax$1(options, function (err, response, body) {

    if (err) {
      return callback(generateErrorFromResponse(err));
    }

    var error;
    var content_type = response.headers && response.headers['content-type'];
    var data = body || defaultBody();

    // CouchDB doesn't always return the right content-type for JSON data, so
    // we check for ^{ and }$ (ignoring leading/trailing whitespace)
    if (!options.binary && (options.json || !options.processData) &&
        typeof data !== 'object' &&
        (/json/.test(content_type) ||
         (/^[\s]*\{/.test(data) && /\}[\s]*$/.test(data)))) {
      try {
        data = JSON.parse(data.toString());
      } catch (e) {}
    }

    if (response.statusCode >= 200 && response.statusCode < 300) {
      onSuccess(data, response, callback);
    } else {
      error = generateErrorFromResponse(data);
      error.status = response.statusCode;
      callback(error);
    }
  });
}

function ajax(opts, callback) {

  // cache-buster, specifically designed to work around IE's aggressive caching
  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/
  // Also Safari caches POSTs, so we need to cache-bust those too.
  var ua = (navigator && navigator.userAgent) ?
    navigator.userAgent.toLowerCase() : '';

  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;
  var isIE = ua.indexOf('msie') !== -1;
  var isEdge = ua.indexOf('edge') !== -1;

  // it appears the new version of safari also caches GETs,
  // see https://github.com/pouchdb/pouchdb/issues/5010
  var shouldCacheBust = (isSafari ||
    ((isIE || isEdge) && opts.method === 'GET'));

  var cache = 'cache' in opts ? opts.cache : true;

  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs

  if (!isBlobUrl && (shouldCacheBust || !cache)) {
    var hasArgs = opts.url.indexOf('?') !== -1;
    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();
  }

  return ajaxCore$1(opts, callback);
}

// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool
// but much smaller in code size. limits the number of concurrent promises that are executed


function pool(promiseFactories, limit) {
  return new PouchPromise$1(function (resolve, reject) {
    var running = 0;
    var current = 0;
    var done = 0;
    var len = promiseFactories.length;
    var err;

    function runNext() {
      running++;
      promiseFactories[current++]().then(onSuccess, onError);
    }

    function doNext() {
      if (++done === len) {
        /* istanbul ignore if */
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      } else {
        runNextBatch();
      }
    }

    function onSuccess() {
      running--;
      doNext();
    }

    /* istanbul ignore next */
    function onError(thisErr) {
      running--;
      err = err || thisErr;
      doNext();
    }

    function runNextBatch() {
      while (running < limit && current < len) {
        runNext();
      }
    }

    runNextBatch();
  });
}

var CHANGES_BATCH_SIZE = 25;
var MAX_SIMULTANEOUS_REVS = 50;
var CHANGES_TIMEOUT_BUFFER = 5000;
var DEFAULT_HEARTBEAT = 10000;

var supportsBulkGetMap = {};

function readAttachmentsAsBlobOrBuffer(row) {
  var atts = row.doc && row.doc._attachments;
  if (!atts) {
    return;
  }
  Object.keys(atts).forEach(function (filename) {
    var att = atts[filename];
    att.data = b64ToBluffer(att.data, att.content_type);
  });
}

function encodeDocId(id) {
  if (/^_design/.test(id)) {
    return '_design/' + encodeURIComponent(id.slice(8));
  }
  if (/^_local/.test(id)) {
    return '_local/' + encodeURIComponent(id.slice(7));
  }
  return encodeURIComponent(id);
}

function preprocessAttachments$2(doc) {
  if (!doc._attachments || !Object.keys(doc._attachments)) {
    return PouchPromise$1.resolve();
  }

  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {
    var attachment = doc._attachments[key];
    if (attachment.data && typeof attachment.data !== 'string') {
      return new PouchPromise$1(function (resolve) {
        blobToBase64(attachment.data, resolve);
      }).then(function (b64) {
        attachment.data = b64;
      });
    }
  }));
}

function hasUrlPrefix(opts) {
  if (!opts.prefix) {
    return false;
  }

  var protocol = parseUri(opts.prefix).protocol;

  return protocol === 'http' || protocol === 'https';
}

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
function getHost(name, opts) {

  // encode db name if opts.prefix is a url (#5574)
  if (hasUrlPrefix(opts)) {
    var dbName = opts.name.substr(opts.prefix.length);
    name = opts.prefix + encodeURIComponent(dbName);
  }

  // Prase the URI into all its little bits
  var uri = parseUri(name);

  // Store the user and password as a separate auth object
  if (uri.user || uri.password) {
    uri.auth = {username: uri.user, password: uri.password};
  }

  // Split the path part of the URI into parts using '/' as the delimiter
  // after removing any leading '/' and any trailing '/'
  var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

  // Store the first part as the database name and remove it from the parts
  // array
  uri.db = parts.pop();
  // Prevent double encoding of URI component
  if (uri.db.indexOf('%') === -1) {
    uri.db = encodeURIComponent(uri.db);
  }

  // Restore the path by joining all the remaining parts (all the parts
  // except for the database name) with '/'s
  uri.path = parts.join('/');

  return uri;
}

// Generate a URL with the host data given by opts and the given path
function genDBUrl(opts, path) {
  return genUrl(opts, opts.db + '/' + path);
}

// Generate a URL with the host data given by opts and the given path
function genUrl(opts, path) {
  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  var pathDel = !opts.path ? '' : '/';

  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  return opts.protocol + '://' + opts.host +
         (opts.port ? (':' + opts.port) : '') +
         '/' + opts.path + pathDel + path;
}

function paramsToStr(params) {
  return '?' + Object.keys(params).map(function (k) {
    return k + '=' + encodeURIComponent(params[k]);
  }).join('&');
}

// Implements the PouchDB API for dealing with CouchDB instances over HTTP
function HttpPouch(opts, callback) {

  // The functions that will be publicly available for HttpPouch
  var api = this;

  var host = getHost(opts.name, opts);
  var dbUrl = genDBUrl(host, '');

  opts = clone(opts);
  var ajaxOpts = opts.ajax || {};

  if (opts.auth || host.auth) {
    var nAuth = opts.auth || host.auth;
    var str = nAuth.username + ':' + nAuth.password;
    var token = thisBtoa(unescape(encodeURIComponent(str)));
    ajaxOpts.headers = ajaxOpts.headers || {};
    ajaxOpts.headers.Authorization = 'Basic ' + token;
  }

  // Not strictly necessary, but we do this because numerous tests
  // rely on swapping ajax in and out.
  api._ajax = ajax;

  function ajax$$1(userOpts, options, callback) {
    var reqAjax = userOpts.ajax || {};
    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);
    var defaultHeaders = clone(ajaxOpts.headers || {});
    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,
      options.headers || {});
    /* istanbul ignore if */
    if (api.constructor.listeners('debug').length) {
      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);
    }
    return api._ajax(reqOpts, callback);
  }

  function ajaxPromise(userOpts, opts) {
    return new PouchPromise$1(function (resolve, reject) {
      ajax$$1(userOpts, opts, function (err, res) {
        /* istanbul ignore if */
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  function adapterFun$$1(name, fun) {
    return adapterFun(name, getArguments(function (args) {
      setup().then(function () {
        return fun.apply(this, args);
      })["catch"](function (e) {
        var callback = args.pop();
        callback(e);
      });
    }));
  }

  var setupPromise;

  function setup() {
    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release
    if (opts.skipSetup || opts.skip_setup) {
      return PouchPromise$1.resolve();
    }

    // If there is a setup in process or previous successful setup
    // done then we will use that
    // If previous setups have been rejected we will try again
    if (setupPromise) {
      return setupPromise;
    }

    var checkExists = {method: 'GET', url: dbUrl};
    setupPromise = ajaxPromise({}, checkExists)["catch"](function (err) {
      if (err && err.status && err.status === 404) {
        // Doesnt exist, create it
        explainError(404, 'PouchDB is just detecting if the remote exists.');
        return ajaxPromise({}, {method: 'PUT', url: dbUrl});
      } else {
        return PouchPromise$1.reject(err);
      }
    })["catch"](function (err) {
      // If we try to create a database that already exists, skipped in
      // istanbul since its catching a race condition.
      /* istanbul ignore if */
      if (err && err.status && err.status === 412) {
        return true;
      }
      return PouchPromise$1.reject(err);
    });

    setupPromise["catch"](function () {
      setupPromise = null;
    });

    return setupPromise;
  }

  nextTick(function () {
    callback(null, api);
  });

  api._remote = true;
  /* istanbul ignore next */
  api.type = function () {
    return 'http';
  };

  api.id = adapterFun$$1('id', function (callback) {
    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {
      var uuid$$1 = (result && result.uuid) ?
        (result.uuid + host.db) : genDBUrl(host, '');
      callback(null, uuid$$1);
    });
  });

  api.request = adapterFun$$1('request', function (options, callback) {
    options.url = genDBUrl(host, options.url);
    ajax$$1({}, options, callback);
  });

  // Sends a POST request to the host calling the couchdb _compact function
  //    version: The version of CouchDB it is running
  api.compact = adapterFun$$1('compact', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);
    ajax$$1(opts, {
      url: genDBUrl(host, '_compact'),
      method: 'POST'
    }, function () {
      function ping() {
        api.info(function (err, res) {
          // CouchDB may send a "compact_running:true" if it's
          // already compacting. PouchDB Server doesn't.
          /* istanbul ignore else */
          if (res && !res.compact_running) {
            callback(null, {ok: true});
          } else {
            setTimeout(ping, opts.interval || 200);
          }
        });
      }
      // Ping the http if it's finished compaction
      ping();
    });
  });

  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
    var self = this;

    function doBulkGet(cb) {
      var params = {};
      if (opts.revs) {
        params.revs = true;
      }
      if (opts.attachments) {
        /* istanbul ignore next */
        params.attachments = true;
      }
      if (opts.latest) {
        params.latest = true;
      }
      ajax$$1(opts, {
        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),
        method: 'POST',
        body: { docs: opts.docs}
      }, cb);
    }

    /* istanbul ignore next */
    function doBulkGetShim() {
      // avoid "url too long error" by splitting up into multiple requests
      var batchSize = MAX_SIMULTANEOUS_REVS;
      var numBatches = Math.ceil(opts.docs.length / batchSize);
      var numDone = 0;
      var results = new Array(numBatches);

      function onResult(batchNum) {
        return function (err, res) {
          // err is impossible because shim returns a list of errs in that case
          results[batchNum] = res.results;
          if (++numDone === numBatches) {
            callback(null, {results: flatten(results)});
          }
        };
      }

      for (var i = 0; i < numBatches; i++) {
        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);
        subOpts.ajax = ajaxOpts;
        subOpts.docs = opts.docs.slice(i * batchSize,
          Math.min(opts.docs.length, (i + 1) * batchSize));
        bulkGet(self, subOpts, onResult(i));
      }
    }

    // mark the whole database as either supporting or not supporting _bulk_get
    var dbUrl = genUrl(host, '');
    var supportsBulkGet = supportsBulkGetMap[dbUrl];

    /* istanbul ignore next */
    if (typeof supportsBulkGet !== 'boolean') {
      // check if this database supports _bulk_get
      doBulkGet(function (err, res) {
        if (err) {
          supportsBulkGetMap[dbUrl] = false;
          explainError(
            err.status,
            'PouchDB is just detecting if the remote ' +
            'supports the _bulk_get API.'
          );
          doBulkGetShim();
        } else {
          supportsBulkGetMap[dbUrl] = true;
          callback(null, res);
        }
      });
    } else if (supportsBulkGet) {
      doBulkGet(callback);
    } else {
      doBulkGetShim();
    }
  });

  // Calls GET on the host, which gets back a JSON string containing
  //    couchdb: A welcome string
  //    version: The version of CouchDB it is running
  api._info = function (callback) {
    setup().then(function () {
      ajax$$1({}, {
        method: 'GET',
        url: genDBUrl(host, '')
      }, function (err, res) {
        /* istanbul ignore next */
        if (err) {
        return callback(err);
        }
        res.host = genDBUrl(host, '');
        callback(null, res);
      });
    })["catch"](callback);
  };

  // Get the document with the given id from the database given by host.
  // The id could be solely the _id in the database, or it may be a
  // _design/ID or _local/ID path
  api.get = adapterFun$$1('get', function (id, opts, callback) {
    // If no options were given, set the callback to the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};

    if (opts.revs) {
      params.revs = true;
    }

    if (opts.revs_info) {
      params.revs_info = true;
    }

    if (opts.latest) {
      params.latest = true;
    }

    if (opts.open_revs) {
      if (opts.open_revs !== "all") {
        opts.open_revs = JSON.stringify(opts.open_revs);
      }
      params.open_revs = opts.open_revs;
    }

    if (opts.rev) {
      params.rev = opts.rev;
    }

    if (opts.conflicts) {
      params.conflicts = opts.conflicts;
    }

    id = encodeDocId(id);

    // Set the options for the ajax call
    var options = {
      method: 'GET',
      url: genDBUrl(host, id + paramsToStr(params))
    };

    function fetchAttachments(doc) {
      var atts = doc._attachments;
      var filenames = atts && Object.keys(atts);
      if (!atts || !filenames.length) {
        return;
      }
      // we fetch these manually in separate XHRs, because
      // Sync Gateway would normally send it back as multipart/mixed,
      // which we cannot parse. Also, this is more efficient than
      // receiving attachments as base64-encoded strings.
      function fetch(filename) {
        var att = atts[filename];
        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
          '?rev=' + doc._rev;
        return ajaxPromise(opts, {
          method: 'GET',
          url: genDBUrl(host, path),
          binary: true
        }).then(function (blob) {
          if (opts.binary) {
            return blob;
          }
          return new PouchPromise$1(function (resolve) {
            blobToBase64(blob, resolve);
          });
        }).then(function (data) {
          delete att.stub;
          delete att.length;
          att.data = data;
        });
      }

      var promiseFactories = filenames.map(function (filename) {
        return function () {
          return fetch(filename);
        };
      });

      // This limits the number of parallel xhr requests to 5 any time
      // to avoid issues with maximum browser request limits
      return pool(promiseFactories, 5);
    }

    function fetchAllAttachments(docOrDocs) {
      if (Array.isArray(docOrDocs)) {
        return PouchPromise$1.all(docOrDocs.map(function (doc) {
          if (doc.ok) {
            return fetchAttachments(doc.ok);
          }
        }));
      }
      return fetchAttachments(docOrDocs);
    }

    ajaxPromise(opts, options).then(function (res) {
      return PouchPromise$1.resolve().then(function () {
        if (opts.attachments) {
          return fetchAllAttachments(res);
        }
      }).then(function () {
        callback(null, res);
      });
    })["catch"](function (e) {
      e.docId = id;
      callback(e);
    });
  });

  // Delete the document given by doc from the database given by host.
  api.remove = adapterFun$$1('remove',
      function (docOrId, optsOrRev, opts, callback) {
    var doc;
    if (typeof optsOrRev === 'string') {
      // id, rev, opts, callback style
      doc = {
        _id: docOrId,
        _rev: optsOrRev
      };
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
    } else {
      // doc, opts, callback style
      doc = docOrId;
      if (typeof optsOrRev === 'function') {
        callback = optsOrRev;
        opts = {};
      } else {
        callback = opts;
        opts = optsOrRev;
      }
    }

    var rev$$1 = (doc._rev || opts.rev);

    // Delete the document
    ajax$$1(opts, {
      method: 'DELETE',
      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1
    }, callback);
  });

  function encodeAttachmentId(attachmentId) {
    return attachmentId.split("/").map(encodeURIComponent).join("/");
  }

  // Get the attachment
  api.getAttachment =
    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,
                                                callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var params = opts.rev ? ('?rev=' + opts.rev) : '';
    var url = genDBUrl(host, encodeDocId(docId)) + '/' +
      encodeAttachmentId(attachmentId) + params;
    ajax$$1(opts, {
      method: 'GET',
      url: url,
      binary: true
    }, callback);
  });

  // Remove the attachment given by the id and rev
  api.removeAttachment =
    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,
                                                   callback) {

    var url = genDBUrl(host, encodeDocId(docId) + '/' +
      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;

    ajax$$1({}, {
      method: 'DELETE',
      url: url
    }, callback);
  });

  // Add the attachment given by blob and its contentType property
  // to the document with the given id, the revision given by rev, and
  // add it to the database given by host.
  api.putAttachment =
    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,
                                                type, callback) {
    if (typeof type === 'function') {
      callback = type;
      type = blob;
      blob = rev$$1;
      rev$$1 = null;
    }
    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
    var url = genDBUrl(host, id);
    if (rev$$1) {
      url += '?rev=' + rev$$1;
    }

    if (typeof blob === 'string') {
      // input is assumed to be a base64 string
      var binary;
      try {
        binary = thisAtob(blob);
      } catch (err) {
        return callback(createError(BAD_ARG,
                        'Attachment is not a valid base64 string'));
      }
      blob = binary ? binStringToBluffer(binary, type) : '';
    }

    var opts = {
      headers: {'Content-Type': type},
      method: 'PUT',
      url: url,
      processData: false,
      body: blob,
      timeout: ajaxOpts.timeout || 60000
    };
    // Add the attachment
    ajax$$1({}, opts, callback);
  });

  // Update/create multiple documents given by req in the database
  // given by host.
  api._bulkDocs = function (req, opts, callback) {
    // If new_edits=false then it prevents the database from creating
    // new revision numbers for the documents. Instead it just uses
    // the old ones. This is used in database replication.
    req.new_edits = opts.new_edits;

    setup().then(function () {
      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));
    }).then(function () {
      // Update/create the documents
      ajax$$1(opts, {
        method: 'POST',
        url: genDBUrl(host, '_bulk_docs'),
        timeout: opts.timeout,
        body: req
      }, function (err, results) {
        if (err) {
          return callback(err);
        }
        results.forEach(function (result) {
          result.ok = true; // smooths out cloudant not adding this
        });
        callback(null, results);
      });
    })["catch"](callback);
  };


  // Update/create document
  api._put = function (doc, opts, callback) {
    setup().then(function () {
      return preprocessAttachments$2(doc);
    }).then(function () {
      // Update/create the document
      ajax$$1(opts, {
        method: 'PUT',
        url: genDBUrl(host, encodeDocId(doc._id)),
        body: doc
      }, function (err, result) {
        if (err) {
          err.docId = doc && doc._id;
          return callback(err);
        }
        callback(null, result);
      });
    })["catch"](callback);
  };


  // Get a listing of the documents in the database given
  // by host and ordered by increasing id.
  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};
    var body;
    var method = 'GET';

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if (opts.include_docs) {
      params.include_docs = true;
    }

    // added in CouchDB 1.6.0
    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.key) {
      params.key = JSON.stringify(opts.key);
    }

    if (opts.start_key) {
      opts.startkey = opts.start_key;
    }

    if (opts.startkey) {
      params.startkey = JSON.stringify(opts.startkey);
    }

    if (opts.end_key) {
      opts.endkey = opts.end_key;
    }

    if (opts.endkey) {
      params.endkey = JSON.stringify(opts.endkey);
    }

    if (typeof opts.inclusive_end !== 'undefined') {
      params.inclusive_end = !!opts.inclusive_end;
    }

    if (typeof opts.limit !== 'undefined') {
      params.limit = opts.limit;
    }

    if (typeof opts.skip !== 'undefined') {
      params.skip = opts.skip;
    }

    var paramStr = paramsToStr(params);

    if (typeof opts.keys !== 'undefined') {
      method = 'POST';
      body = {keys: opts.keys};
    }

    // Get the document listing
    ajaxPromise(opts, {
      method: method,
      url: genDBUrl(host, '_all_docs' + paramStr),
      body: body
    }).then(function (res) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        res.rows.forEach(readAttachmentsAsBlobOrBuffer);
      }
      callback(null, res);
    })["catch"](callback);
  });

  // Get a list of changes made to documents in the database given by host.
  // TODO According to the README, there should be two other methods here,
  // api.changes.addListener and api.changes.removeListener.
  api._changes = function (opts) {

    // We internally page the results of a changes request, this means
    // if there is a large set of changes to be returned we can start
    // processing them quicker instead of waiting on the entire
    // set of changes to return and attempting to process them at once
    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

    opts = clone(opts);

    if (opts.continuous && !('heartbeat' in opts)) {
      opts.heartbeat = DEFAULT_HEARTBEAT;
    }

    var requestTimeout = ('timeout' in opts) ? opts.timeout :
      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :
      30 * 1000;

    // ensure CHANGES_TIMEOUT_BUFFER applies
    if ('timeout' in opts && opts.timeout &&
      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
    }

    if ('heartbeat' in opts && opts.heartbeat &&
       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
    }

    var params = {};
    if ('timeout' in opts && opts.timeout) {
      params.timeout = opts.timeout;
    }

    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
    var returnDocs;
    if ('return_docs' in opts) {
      returnDocs = opts.return_docs;
    } else if ('returnDocs' in opts) {
      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }
    //
    var leftToFetch = limit;

    if (opts.style) {
      params.style = opts.style;
    }

    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
      params.include_docs = true;
    }

    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.continuous) {
      params.feed = 'longpoll';
    }

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if ('heartbeat' in opts) {
      // If the heartbeat value is false, it disables the default heartbeat
      if (opts.heartbeat) {
        params.heartbeat = opts.heartbeat;
      }
    }

    if (opts.filter && typeof opts.filter === 'string') {
      params.filter = opts.filter;
    }

    if (opts.view && typeof opts.view === 'string') {
      params.filter = '_view';
      params.view = opts.view;
    }

    // If opts.query_params exists, pass it through to the changes request.
    // These parameters may be used by the filter on the source database.
    if (opts.query_params && typeof opts.query_params === 'object') {
      for (var param_name in opts.query_params) {
        /* istanbul ignore else */
        if (opts.query_params.hasOwnProperty(param_name)) {
          params[param_name] = opts.query_params[param_name];
        }
      }
    }

    var method = 'GET';
    var body;

    if (opts.doc_ids) {
      // set this automagically for the user; it's annoying that couchdb
      // requires both a "filter" and a "doc_ids" param.
      params.filter = '_doc_ids';
      method = 'POST';
      body = {doc_ids: opts.doc_ids };
    }
    /* istanbul ignore next */
    else if (opts.selector) {
      // set this automagically for the user, similar to above
      params.filter = '_selector';
      method = 'POST';
      body = {selector: opts.selector };
    }

    var xhr;
    var lastFetchedSeq;

    // Get all the changes starting wtih the one immediately after the
    // sequence number given by since.
    var fetch = function (since, callback) {
      if (opts.aborted) {
        return;
      }
      params.since = since;
      // "since" can be any kind of json object in Coudant/CouchDB 2.x
      /* istanbul ignore next */
      if (typeof params.since === "object") {
        params.since = JSON.stringify(params.since);
      }

      if (opts.descending) {
        if (limit) {
          params.limit = leftToFetch;
        }
      } else {
        params.limit = (!limit || leftToFetch > batchSize) ?
          batchSize : leftToFetch;
      }

      // Set the options for the ajax call
      var xhrOpts = {
        method: method,
        url: genDBUrl(host, '_changes' + paramsToStr(params)),
        timeout: requestTimeout,
        body: body
      };
      lastFetchedSeq = since;

      /* istanbul ignore if */
      if (opts.aborted) {
        return;
      }

      // Get the changes
      setup().then(function () {
        xhr = ajax$$1(opts, xhrOpts, callback);
      })["catch"](callback);
    };

    // If opts.since exists, get all the changes from the sequence
    // number given by opts.since. Otherwise, get all the changes
    // from the sequence number 0.
    var results = {results: []};

    var fetched = function (err, res) {
      if (opts.aborted) {
        return;
      }
      var raw_results_length = 0;
      // If the result of the ajax call (res) contains changes (res.results)
      if (res && res.results) {
        raw_results_length = res.results.length;
        results.last_seq = res.last_seq;
        // For each change
        var req = {};
        req.query = opts.query_params;
        res.results = res.results.filter(function (c) {
          leftToFetch--;
          var ret = filterChange(opts)(c);
          if (ret) {
            if (opts.include_docs && opts.attachments && opts.binary) {
              readAttachmentsAsBlobOrBuffer(c);
            }
            if (returnDocs) {
              results.results.push(c);
            }
            opts.onChange(c);
          }
          return ret;
        });
      } else if (err) {
        // In case of an error, stop listening for changes and call
        // opts.complete
        opts.aborted = true;
        opts.complete(err);
        return;
      }

      // The changes feed may have timed out with no results
      // if so reuse last update sequence
      if (res && res.last_seq) {
        lastFetchedSeq = res.last_seq;
      }

      var finished = (limit && leftToFetch <= 0) ||
        (res && raw_results_length < batchSize) ||
        (opts.descending);

      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
        // Queue a call to fetch again with the newest sequence number
        nextTick(function () { fetch(lastFetchedSeq, fetched); });
      } else {
        // We're done, call the callback
        opts.complete(null, results);
      }
    };

    fetch(opts.since || 0, fetched);

    // Return a method to cancel this method from processing any more
    return {
      cancel: function () {
        opts.aborted = true;
        if (xhr) {
          xhr.abort();
        }
      }
    };
  };

  // Given a set of document/revision IDs (given by req), tets the subset of
  // those that do NOT correspond to revisions stored in the database.
  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    // Get the missing document/revision IDs
    ajax$$1(opts, {
      method: 'POST',
      url: genDBUrl(host, '_revs_diff'),
      body: req
    }, callback);
  });

  api._close = function (callback) {
    callback();
  };

  api._destroy = function (options, callback) {
    ajax$$1(options, {
      url: genDBUrl(host, ''),
      method: 'DELETE'
    }, function (err, resp) {
      if (err && err.status && err.status !== 404) {
        return callback(err);
      }
      callback(null, resp);
    });
  };
}

// HttpPouch is a valid adapter.
HttpPouch.valid = function () {
  return true;
};

var HttpPouch$1 = function (PouchDB) {
  PouchDB.adapter('http', HttpPouch, false);
  PouchDB.adapter('https', HttpPouch, false);
};

function QueryParseError(message) {
  this.status = 400;
  this.name = 'query_parse_error';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, QueryParseError);
  } catch (e) {}
}

inherits(QueryParseError, Error);

function NotFoundError(message) {
  this.status = 404;
  this.name = 'not_found';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, NotFoundError);
  } catch (e) {}
}

inherits(NotFoundError, Error);

function BuiltInError(message) {
  this.status = 500;
  this.name = 'invalid_value';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, BuiltInError);
  } catch (e) {}
}

inherits(BuiltInError, Error);

function promisedCallback(promise, callback) {
  if (callback) {
    promise.then(function (res) {
      nextTick(function () {
        callback(null, res);
      });
    }, function (reason) {
      nextTick(function () {
        callback(reason);
      });
    });
  }
  return promise;
}

function callbackify(fun) {
  return getArguments(function (args) {
    var cb = args.pop();
    var promise = fun.apply(this, args);
    if (typeof cb === 'function') {
      promisedCallback(promise, cb);
    }
    return promise;
  });
}

// Promise finally util similar to Q.finally
function fin(promise, finalPromiseFactory) {
  return promise.then(function (res) {
    return finalPromiseFactory().then(function () {
      return res;
    });
  }, function (reason) {
    return finalPromiseFactory().then(function () {
      throw reason;
    });
  });
}

function sequentialize(queue, promiseFactory) {
  return function () {
    var args = arguments;
    var that = this;
    return queue.add(function () {
      return promiseFactory.apply(that, args);
    });
  };
}

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
function uniq(arr) {
  var theSet = new ExportedSet(arr);
  var result = new Array(theSet.size);
  var index = -1;
  theSet.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

function mapToKeysArray(map) {
  var result = new Array(map.size);
  var index = -1;
  map.forEach(function (value, key) {
    result[++index] = key;
  });
  return result;
}

function createBuiltInError(name) {
  var message = 'builtin ' + name +
    ' function requires map values to be numbers' +
    ' or number arrays';
  return new BuiltInError(message);
}

function sum(values) {
  var result = 0;
  for (var i = 0, len = values.length; i < len; i++) {
    var num = values[i];
    if (typeof num !== 'number') {
      if (Array.isArray(num)) {
        // lists of numbers are also allowed, sum them separately
        result = typeof result === 'number' ? [result] : result;
        for (var j = 0, jLen = num.length; j < jLen; j++) {
          var jNum = num[j];
          if (typeof jNum !== 'number') {
            throw createBuiltInError('_sum');
          } else if (typeof result[j] === 'undefined') {
            result.push(jNum);
          } else {
            result[j] += jNum;
          }
        }
      } else { // not array/number
        throw createBuiltInError('_sum');
      }
    } else if (typeof result === 'number') {
      result += num;
    } else { // add number to array
      result[0] += num;
    }
  }
  return result;
}

var log = guardedConsole.bind(null, 'log');
var isArray = Array.isArray;
var toJSON = JSON.parse;

function evalFunctionWithEval(func, emit) {
  return scopeEval(
    "return (" + func.replace(/;\s*$/, "") + ");",
    {
      emit: emit,
      sum: sum,
      log: log,
      isArray: isArray,
      toJSON: toJSON
    }
  );
}

/*
 * Simple task queue to sequentialize actions. Assumes
 * callbacks will eventually fire (once).
 */


function TaskQueue$2() {
  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });
}
TaskQueue$2.prototype.add = function (promiseFactory) {
  this.promise = this.promise["catch"](function () {
    // just recover
  }).then(function () {
    return promiseFactory();
  });
  return this.promise;
};
TaskQueue$2.prototype.finish = function () {
  return this.promise;
};

function stringify(input) {
  if (!input) {
    return 'undefined'; // backwards compat for empty reduce
  }
  // for backwards compat with mapreduce, functions/strings are stringified
  // as-is. everything else is JSON-stringified.
  switch (typeof input) {
    case 'function':
      // e.g. a mapreduce map
      return input.toString();
    case 'string':
      // e.g. a mapreduce built-in _reduce function
      return input.toString();
    default:
      // e.g. a JSON object in the case of mango queries
      return JSON.stringify(input);
  }
}

/* create a string signature for a view so we can cache it and uniq it */
function createViewSignature(mapFun, reduceFun) {
  // the "undefined" part is for backwards compatibility
  return stringify(mapFun) + stringify(reduceFun) + 'undefined';
}

function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
  var viewSignature = createViewSignature(mapFun, reduceFun);

  var cachedViews;
  if (!temporary) {
    // cache this to ensure we don't try to update the same view twice
    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
    if (cachedViews[viewSignature]) {
      return cachedViews[viewSignature];
    }
  }

  var promiseForView = sourceDB.info().then(function (info) {

    var depDbName = info.db_name + '-mrview-' +
      (temporary ? 'temp' : stringMd5(viewSignature));

    // save the view name in the source db so it can be cleaned up if necessary
    // (e.g. when the _design doc is deleted, remove all associated view data)
    function diffFunction(doc) {
      doc.views = doc.views || {};
      var fullViewName = viewName;
      if (fullViewName.indexOf('/') === -1) {
        fullViewName = viewName + '/' + viewName;
      }
      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
      /* istanbul ignore if */
      if (depDbs[depDbName]) {
        return; // no update necessary
      }
      depDbs[depDbName] = true;
      return doc;
    }
    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
        var db = res.db;
        db.auto_compaction = true;
        var view = {
          name: depDbName,
          db: db,
          sourceDB: sourceDB,
          adapter: sourceDB.adapter,
          mapFun: mapFun,
          reduceFun: reduceFun
        };
        return view.db.get('_local/lastSeq')["catch"](function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
        }).then(function (lastSeqDoc) {
          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
          if (cachedViews) {
            view.db.once('destroyed', function () {
              delete cachedViews[viewSignature];
            });
          }
          return view;
        });
      });
    });
  });

  if (cachedViews) {
    cachedViews[viewSignature] = promiseForView;
  }
  return promiseForView;
}

var persistentQueues = {};
var tempViewQueue = new TaskQueue$2();
var CHANGES_BATCH_SIZE$1 = 50;

function parseViewName(name) {
  // can be either 'ddocname/viewname' or just 'viewname'
  // (where the ddoc name is the same)
  return name.indexOf('/') === -1 ? [name, name] : name.split('/');
}

function isGenOne(changes) {
  // only return true if the current change is 1-
  // and there are no other leafs
  return changes.length === 1 && /^1-/.test(changes[0].rev);
}

function emitError(db, e) {
  try {
    db.emit('error', e);
  } catch (err) {
    guardedConsole('error',
      'The user\'s map/reduce function threw an uncaught error.\n' +
      'You can debug this error by doing:\n' +
      'myDatabase.on(\'error\', function (err) { debugger; });\n' +
      'Please double-check your map/reduce function.');
    guardedConsole('error', e);
  }
}

/**
 * Returns an "abstract" mapreduce object of the form:
 *
 *   {
 *     query: queryFun,
 *     viewCleanup: viewCleanupFun
 *   }
 *
 * Arguments are:
 *
 * localDoc: string
 *   This is for the local doc that gets saved in order to track the
 *   "dependent" DBs and clean them up for viewCleanup. It should be
 *   unique, so that indexer plugins don't collide with each other.
 * mapper: function (mapFunDef, emit)
 *   Returns a map function based on the mapFunDef, which in the case of
 *   normal map/reduce is just the de-stringified function, but may be
 *   something else, such as an object in the case of pouchdb-find.
 * reducer: function (reduceFunDef)
 *   Ditto, but for reducing. Modules don't have to support reducing
 *   (e.g. pouchdb-find).
 * ddocValidator: function (ddoc, viewName)
 *   Throws an error if the ddoc or viewName is not valid.
 *   This could be a way to communicate to the user that the configuration for the
 *   indexer is invalid.
 */
function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {

  function tryMap(db, fun, doc) {
    // emit an event if there was an error thrown by a map function.
    // putting try/catches in a single function also avoids deoptimizations.
    try {
      fun(doc);
    } catch (e) {
      emitError(db, e);
    }
  }

  function tryReduce(db, fun, keys, values, rereduce) {
    // same as above, but returning the result or an error. there are two separate
    // functions to avoid extra memory allocations since the tryCode() case is used
    // for custom map functions (common) vs this function, which is only used for
    // custom reduce functions (rare)
    try {
      return {output : fun(keys, values, rereduce)};
    } catch (e) {
      emitError(db, e);
      return {error: e};
    }
  }

  function sortByKeyThenValue(x, y) {
    var keyCompare = collate(x.key, y.key);
    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
  }

  function sliceResults(results, limit, skip) {
    skip = skip || 0;
    if (typeof limit === 'number') {
      return results.slice(skip, limit + skip);
    } else if (skip > 0) {
      return results.slice(skip);
    }
    return results;
  }

  function rowToDocId(row) {
    var val = row.value;
    // Users can explicitly specify a joined doc _id, or it
    // defaults to the doc _id that emitted the key/value.
    var docId = (val && typeof val === 'object' && val._id) || row.id;
    return docId;
  }

  function readAttachmentsAsBlobOrBuffer(res) {
    res.rows.forEach(function (row) {
      var atts = row.doc && row.doc._attachments;
      if (!atts) {
        return;
      }
      Object.keys(atts).forEach(function (filename) {
        var att = atts[filename];
        atts[filename].data = b64ToBluffer(att.data, att.content_type);
      });
    });
  }

  function postprocessAttachments(opts) {
    return function (res) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        readAttachmentsAsBlobOrBuffer(res);
      }
      return res;
    };
  }

  function addHttpParam(paramName, opts, params, asJson) {
    // add an http param from opts to params, optionally json-encoded
    var val = opts[paramName];
    if (typeof val !== 'undefined') {
      if (asJson) {
        val = encodeURIComponent(JSON.stringify(val));
      }
      params.push(paramName + '=' + val);
    }
  }

  function coerceInteger(integerCandidate) {
    if (typeof integerCandidate !== 'undefined') {
      var asNumber = Number(integerCandidate);
      // prevents e.g. '1foo' or '1.1' being coerced to 1
      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
        return asNumber;
      } else {
        return integerCandidate;
      }
    }
  }

  function coerceOptions(opts) {
    opts.group_level = coerceInteger(opts.group_level);
    opts.limit = coerceInteger(opts.limit);
    opts.skip = coerceInteger(opts.skip);
    return opts;
  }

  function checkPositiveInteger(number) {
    if (number) {
      if (typeof number !== 'number') {
        return  new QueryParseError('Invalid value for integer: "' +
          number + '"');
      }
      if (number < 0) {
        return new QueryParseError('Invalid value for positive integer: ' +
          '"' + number + '"');
      }
    }
  }

  function checkQueryParseError(options, fun) {
    var startkeyName = options.descending ? 'endkey' : 'startkey';
    var endkeyName = options.descending ? 'startkey' : 'endkey';

    if (typeof options[startkeyName] !== 'undefined' &&
      typeof options[endkeyName] !== 'undefined' &&
      collate(options[startkeyName], options[endkeyName]) > 0) {
      throw new QueryParseError('No rows can match your key range, ' +
        'reverse your start_key and end_key or set {descending : true}');
    } else if (fun.reduce && options.reduce !== false) {
      if (options.include_docs) {
        throw new QueryParseError('{include_docs:true} is invalid for reduce');
      } else if (options.keys && options.keys.length > 1 &&
        !options.group && !options.group_level) {
        throw new QueryParseError('Multi-key fetches for reduce views must use ' +
          '{group: true}');
      }
    }
    ['group_level', 'limit', 'skip'].forEach(function (optionName) {
      var error = checkPositiveInteger(options[optionName]);
      if (error) {
        throw error;
      }
    });
  }

  function httpQuery(db, fun, opts) {
    // List of parameters to add to the PUT request
    var params = [];
    var body;
    var method = 'GET';

    // If opts.reduce exists and is defined, then add it to the list
    // of parameters.
    // If reduce=false then the results are that of only the map function
    // not the final result of map and reduce.
    addHttpParam('reduce', opts, params);
    addHttpParam('include_docs', opts, params);
    addHttpParam('attachments', opts, params);
    addHttpParam('limit', opts, params);
    addHttpParam('descending', opts, params);
    addHttpParam('group', opts, params);
    addHttpParam('group_level', opts, params);
    addHttpParam('skip', opts, params);
    addHttpParam('stale', opts, params);
    addHttpParam('conflicts', opts, params);
    addHttpParam('startkey', opts, params, true);
    addHttpParam('start_key', opts, params, true);
    addHttpParam('endkey', opts, params, true);
    addHttpParam('end_key', opts, params, true);
    addHttpParam('inclusive_end', opts, params);
    addHttpParam('key', opts, params, true);

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    params = params === '' ? '' : '?' + params;

    // If keys are supplied, issue a POST to circumvent GET query string limits
    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.keys !== 'undefined') {
      var MAX_URL_LENGTH = 2000;
      // according to http://stackoverflow.com/a/417184/680742,
      // the de facto URL length limit is 2000 characters

      var keysAsString =
        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
        // If the keys are short enough, do a GET. we do this to work around
        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
        params += (params[0] === '?' ? '&' : '?') + keysAsString;
      } else {
        method = 'POST';
        if (typeof fun === 'string') {
          body = {keys: opts.keys};
        } else { // fun is {map : mapfun}, so append to this
          fun.keys = opts.keys;
        }
      }
    }

    // We are referencing a query defined in the design doc
    if (typeof fun === 'string') {
      var parts = parseViewName(fun);
      return db.request({
        method: method,
        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,
        body: body
      }).then(
        /* istanbul ignore next */
        function (result) {
          // fail the entire request if the result contains an error
          result.rows.forEach(function (row) {
            if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
              throw new Error(row.reason);
            }
          });

          return result;
      })
      .then(postprocessAttachments(opts));
    }

    // We are using a temporary view, terrible for performance, good for testing
    body = body || {};
    Object.keys(fun).forEach(function (key) {
      if (Array.isArray(fun[key])) {
        body[key] = fun[key];
      } else {
        body[key] = fun[key].toString();
      }
    });
    return db.request({
      method: 'POST',
      url: '_temp_view' + params,
      body: body
    }).then(postprocessAttachments(opts));
  }

  // custom adapters can define their own api._query
  // and override the default behavior
  /* istanbul ignore next */
  function customQuery(db, fun, opts) {
    return new PouchPromise$1(function (resolve, reject) {
      db._query(fun, opts, function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  // custom adapters can define their own api._viewCleanup
  // and override the default behavior
  /* istanbul ignore next */
  function customViewCleanup(db) {
    return new PouchPromise$1(function (resolve, reject) {
      db._viewCleanup(function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  function defaultsTo(value) {
    return function (reason) {
      /* istanbul ignore else */
      if (reason.status === 404) {
        return value;
      } else {
        throw reason;
      }
    };
  }

  // returns a promise for a list of docs to update, based on the input docId.
  // the order doesn't matter, because post-3.2.0, bulkDocs
  // is an atomic operation in all three adapters.
  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
    var metaDocId = '_local/doc_' + docId;
    var defaultMetaDoc = {_id: metaDocId, keys: []};
    var docData = docIdsToChangesAndEmits.get(docId);
    var indexableKeysToKeyValues = docData[0];
    var changes = docData[1];

    function getMetaDoc() {
      if (isGenOne(changes)) {
        // generation 1, so we can safely assume initial state
        // for performance reasons (avoids unnecessary GETs)
        return PouchPromise$1.resolve(defaultMetaDoc);
      }
      return view.db.get(metaDocId)["catch"](defaultsTo(defaultMetaDoc));
    }

    function getKeyValueDocs(metaDoc) {
      if (!metaDoc.keys.length) {
        // no keys, no need for a lookup
        return PouchPromise$1.resolve({rows: []});
      }
      return view.db.allDocs({
        keys: metaDoc.keys,
        include_docs: true
      });
    }

    function processKeyValueDocs(metaDoc, kvDocsRes) {
      var kvDocs = [];
      var oldKeys = new ExportedSet();

      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
        var row = kvDocsRes.rows[i];
        var doc = row.doc;
        if (!doc) { // deleted
          continue;
        }
        kvDocs.push(doc);
        oldKeys.add(doc._id);
        doc._deleted = !indexableKeysToKeyValues.has(doc._id);
        if (!doc._deleted) {
          var keyValue = indexableKeysToKeyValues.get(doc._id);
          if ('value' in keyValue) {
            doc.value = keyValue.value;
          }
        }
      }
      var newKeys = mapToKeysArray(indexableKeysToKeyValues);
      newKeys.forEach(function (key) {
        if (!oldKeys.has(key)) {
          // new doc
          var kvDoc = {
            _id: key
          };
          var keyValue = indexableKeysToKeyValues.get(key);
          if ('value' in keyValue) {
            kvDoc.value = keyValue.value;
          }
          kvDocs.push(kvDoc);
        }
      });
      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
      kvDocs.push(metaDoc);

      return kvDocs;
    }

    return getMetaDoc().then(function (metaDoc) {
      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
        return processKeyValueDocs(metaDoc, kvDocsRes);
      });
    });
  }

  // updates all emitted key/value docs and metaDocs in the mrview database
  // for the given batch of documents from the source database
  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
    var seqDocId = '_local/lastSeq';
    return view.db.get(seqDocId)[
      "catch"](defaultsTo({_id: seqDocId, seq: 0}))
      .then(function (lastSeqDoc) {
        var docIds = mapToKeysArray(docIdsToChangesAndEmits);
        return PouchPromise$1.all(docIds.map(function (docId) {
          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
        })).then(function (listOfDocsToPersist) {
          var docsToPersist = flatten(listOfDocsToPersist);
          lastSeqDoc.seq = seq;
          docsToPersist.push(lastSeqDoc);
          // write all docs in a single operation, update the seq once
          return view.db.bulkDocs({docs : docsToPersist});
        });
      });
  }

  function getQueue(view) {
    var viewName = typeof view === 'string' ? view : view.name;
    var queue = persistentQueues[viewName];
    if (!queue) {
      queue = persistentQueues[viewName] = new TaskQueue$2();
    }
    return queue;
  }

  function updateView(view) {
    return sequentialize(getQueue(view), function () {
      return updateViewInQueue(view);
    })();
  }

  function updateViewInQueue(view) {
    // bind the emit function once
    var mapResults;
    var doc;

    function emit(key, value) {
      var output = {id: doc._id, key: normalizeKey(key)};
      // Don't explicitly store the value unless it's defined and non-null.
      // This saves on storage space, because often people don't use it.
      if (typeof value !== 'undefined' && value !== null) {
        output.value = normalizeKey(value);
      }
      mapResults.push(output);
    }

    var mapFun = mapper(view.mapFun, emit);

    var currentSeq = view.seq || 0;

    function processChange(docIdsToChangesAndEmits, seq) {
      return function () {
        return saveKeyValues(view, docIdsToChangesAndEmits, seq);
      };
    }

    var queue = new TaskQueue$2();

    function processNextBatch() {
      return view.sourceDB.changes({
        conflicts: true,
        include_docs: true,
        style: 'all_docs',
        since: currentSeq,
        limit: CHANGES_BATCH_SIZE$1
      }).then(processBatch);
    }

    function processBatch(response) {
      var results = response.results;
      if (!results.length) {
        return;
      }
      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
      if (results.length < CHANGES_BATCH_SIZE$1) {
        return;
      }
      return processNextBatch();
    }

    function createDocIdsToChangesAndEmits(results) {
      var docIdsToChangesAndEmits = new ExportedMap();
      for (var i = 0, len = results.length; i < len; i++) {
        var change = results[i];
        if (change.doc._id[0] !== '_') {
          mapResults = [];
          doc = change.doc;

          if (!doc._deleted) {
            tryMap(view.sourceDB, mapFun, doc);
          }
          mapResults.sort(sortByKeyThenValue);

          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
          docIdsToChangesAndEmits.set(change.doc._id, [
            indexableKeysToKeyValues,
            change.changes
          ]);
        }
        currentSeq = change.seq;
      }
      return docIdsToChangesAndEmits;
    }

    function createIndexableKeysToKeyValues(mapResults) {
      var indexableKeysToKeyValues = new ExportedMap();
      var lastKey;
      for (var i = 0, len = mapResults.length; i < len; i++) {
        var emittedKeyValue = mapResults[i];
        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
          complexKey.push(i); // dup key+id, so make it unique
        }
        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
        lastKey = emittedKeyValue.key;
      }
      return indexableKeysToKeyValues;
    }

    return processNextBatch().then(function () {
      return queue.finish();
    }).then(function () {
      view.seq = currentSeq;
    });
  }

  function reduceView(view, results, options) {
    if (options.group_level === 0) {
      delete options.group_level;
    }

    var shouldGroup = options.group || options.group_level;

    var reduceFun = reducer(view.reduceFun);

    var groups = [];
    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
      options.group_level;
    results.forEach(function (e) {
      var last = groups[groups.length - 1];
      var groupKey = shouldGroup ? e.key : null;

      // only set group_level for array keys
      if (shouldGroup && Array.isArray(groupKey)) {
        groupKey = groupKey.slice(0, lvl);
      }

      if (last && collate(last.groupKey, groupKey) === 0) {
        last.keys.push([e.key, e.id]);
        last.values.push(e.value);
        return;
      }
      groups.push({
        keys: [[e.key, e.id]],
        values: [e.value],
        groupKey: groupKey
      });
    });
    results = [];
    for (var i = 0, len = groups.length; i < len; i++) {
      var e = groups[i];
      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
        // CouchDB returns an error if a built-in errors out
        throw reduceTry.error;
      }
      results.push({
        // CouchDB just sets the value to null if a non-built-in errors out
        value: reduceTry.error ? null : reduceTry.output,
        key: e.groupKey
      });
    }
    // no total_rows/offset when reducing
    return {rows: sliceResults(results, options.limit, options.skip)};
  }

  function queryView(view, opts) {
    return sequentialize(getQueue(view), function () {
      return queryViewInQueue(view, opts);
    })();
  }

  function queryViewInQueue(view, opts) {
    var totalRows;
    var shouldReduce = view.reduceFun && opts.reduce !== false;
    var skip = opts.skip || 0;
    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
      // equivalent query
      opts.limit = 0;
      delete opts.keys;
    }

    function fetchFromView(viewOpts) {
      viewOpts.include_docs = true;
      return view.db.allDocs(viewOpts).then(function (res) {
        totalRows = res.total_rows;
        return res.rows.map(function (result) {

          // implicit migration - in older versions of PouchDB,
          // we explicitly stored the doc as {id: ..., key: ..., value: ...}
          // this is tested in a migration test
          /* istanbul ignore next */
          if ('value' in result.doc && typeof result.doc.value === 'object' &&
            result.doc.value !== null) {
            var keys = Object.keys(result.doc.value).sort();
            // this detection method is not perfect, but it's unlikely the user
            // emitted a value which was an object with these 3 exact keys
            var expectedKeys = ['id', 'key', 'value'];
            if (!(keys < expectedKeys || keys > expectedKeys)) {
              return result.doc.value;
            }
          }

          var parsedKeyAndDocId = parseIndexableString(result.doc._id);
          return {
            key: parsedKeyAndDocId[0],
            id: parsedKeyAndDocId[1],
            value: ('value' in result.doc ? result.doc.value : null)
          };
        });
      });
    }

    function onMapResultsReady(rows) {
      var finalResults;
      if (shouldReduce) {
        finalResults = reduceView(view, rows, opts);
      } else {
        finalResults = {
          total_rows: totalRows,
          offset: skip,
          rows: rows
        };
      }
      if (opts.include_docs) {
        var docIds = uniq(rows.map(rowToDocId));

        return view.sourceDB.allDocs({
          keys: docIds,
          include_docs: true,
          conflicts: opts.conflicts,
          attachments: opts.attachments,
          binary: opts.binary
        }).then(function (allDocsRes) {
          var docIdsToDocs = new ExportedMap();
          allDocsRes.rows.forEach(function (row) {
            docIdsToDocs.set(row.id, row.doc);
          });
          rows.forEach(function (row) {
            var docId = rowToDocId(row);
            var doc = docIdsToDocs.get(docId);
            if (doc) {
              row.doc = doc;
            }
          });
          return finalResults;
        });
      } else {
        return finalResults;
      }
    }

    if (typeof opts.keys !== 'undefined') {
      var keys = opts.keys;
      var fetchPromises = keys.map(function (key) {
        var viewOpts = {
          startkey : toIndexableString([key]),
          endkey   : toIndexableString([key, {}])
        };
        return fetchFromView(viewOpts);
      });
      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);
    } else { // normal query, no 'keys'
      var viewOpts = {
        descending : opts.descending
      };
      var startkey;
      var endkey;
      if ('start_key' in opts) {
        startkey = opts.start_key;
      }
      if ('startkey' in opts) {
        startkey = opts.startkey;
      }
      if ('end_key' in opts) {
        endkey = opts.end_key;
      }
      if ('endkey' in opts) {
        endkey = opts.endkey;
      }
      if (typeof startkey !== 'undefined') {
        viewOpts.startkey = opts.descending ?
          toIndexableString([startkey, {}]) :
          toIndexableString([startkey]);
      }
      if (typeof endkey !== 'undefined') {
        var inclusiveEnd = opts.inclusive_end !== false;
        if (opts.descending) {
          inclusiveEnd = !inclusiveEnd;
        }

        viewOpts.endkey = toIndexableString(
          inclusiveEnd ? [endkey, {}] : [endkey]);
      }
      if (typeof opts.key !== 'undefined') {
        var keyStart = toIndexableString([opts.key]);
        var keyEnd = toIndexableString([opts.key, {}]);
        if (viewOpts.descending) {
          viewOpts.endkey = keyStart;
          viewOpts.startkey = keyEnd;
        } else {
          viewOpts.startkey = keyStart;
          viewOpts.endkey = keyEnd;
        }
      }
      if (!shouldReduce) {
        if (typeof opts.limit === 'number') {
          viewOpts.limit = opts.limit;
        }
        viewOpts.skip = skip;
      }
      return fetchFromView(viewOpts).then(onMapResultsReady);
    }
  }

  function httpViewCleanup(db) {
    return db.request({
      method: 'POST',
      url: '_view_cleanup'
    });
  }

  function localViewCleanup(db) {
    return db.get('_local/' + localDocName).then(function (metaDoc) {
      var docsToViews = new ExportedMap();
      Object.keys(metaDoc.views).forEach(function (fullViewName) {
        var parts = parseViewName(fullViewName);
        var designDocName = '_design/' + parts[0];
        var viewName = parts[1];
        var views = docsToViews.get(designDocName);
        if (!views) {
          views = new ExportedSet();
          docsToViews.set(designDocName, views);
        }
        views.add(viewName);
      });
      var opts = {
        keys : mapToKeysArray(docsToViews),
        include_docs : true
      };
      return db.allDocs(opts).then(function (res) {
        var viewsToStatus = {};
        res.rows.forEach(function (row) {
          var ddocName = row.key.substring(8); // cuts off '_design/'
          docsToViews.get(row.key).forEach(function (viewName) {
            var fullViewName = ddocName + '/' + viewName;
            /* istanbul ignore if */
            if (!metaDoc.views[fullViewName]) {
              // new format, without slashes, to support PouchDB 2.2.0
              // migration test in pouchdb's browser.migration.js verifies this
              fullViewName = viewName;
            }
            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
            // design doc deleted, or view function nonexistent
            var statusIsGood = row.doc && row.doc.views &&
              row.doc.views[viewName];
            viewDBNames.forEach(function (viewDBName) {
              viewsToStatus[viewDBName] =
                viewsToStatus[viewDBName] || statusIsGood;
            });
          });
        });
        var dbsToDelete = Object.keys(viewsToStatus).filter(
          function (viewDBName) { return !viewsToStatus[viewDBName]; });
        var destroyPromises = dbsToDelete.map(function (viewDBName) {
          return sequentialize(getQueue(viewDBName), function () {
            return new db.constructor(viewDBName, db.__opts).destroy();
          })();
        });
        return PouchPromise$1.all(destroyPromises).then(function () {
          return {ok: true};
        });
      });
    }, defaultsTo({ok: true}));
  }

  function queryPromised(db, fun, opts) {
    /* istanbul ignore next */
    if (typeof db._query === 'function') {
      return customQuery(db, fun, opts);
    }
    if (isRemote(db)) {
      return httpQuery(db, fun, opts);
    }

    if (typeof fun !== 'string') {
      // temp_view
      checkQueryParseError(opts, fun);

      tempViewQueue.add(function () {
        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ 'temp_view/temp_view',
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ true,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          return fin(updateView(view).then(function () {
            return queryView(view, opts);
          }), function () {
            return view.db.destroy();
          });
        });
      });
      return tempViewQueue.finish();
    } else {
      // persistent view
      var fullViewName = fun;
      var parts = parseViewName(fullViewName);
      var designDocName = parts[0];
      var viewName = parts[1];
      return db.get('_design/' + designDocName).then(function (doc) {
        var fun = doc.views && doc.views[viewName];

        if (!fun) {
          // basic validator; it's assumed that every subclass would want this
          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
            viewName);
        }

        ddocValidator(doc, viewName);
        checkQueryParseError(opts, fun);

        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ fullViewName,
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ false,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          if (opts.stale === 'ok' || opts.stale === 'update_after') {
            if (opts.stale === 'update_after') {
              nextTick(function () {
                updateView(view);
              });
            }
            return queryView(view, opts);
          } else { // stale not ok
            return updateView(view).then(function () {
              return queryView(view, opts);
            });
          }
        });
      });
    }
  }

  function abstractQuery(fun, opts, callback) {
    var db = this;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = opts ? coerceOptions(opts) : {};

    if (typeof fun === 'function') {
      fun = {map : fun};
    }

    var promise = PouchPromise$1.resolve().then(function () {
      return queryPromised(db, fun, opts);
    });
    promisedCallback(promise, callback);
    return promise;
  }

  var abstractViewCleanup = callbackify(function () {
    var db = this;
    /* istanbul ignore next */
    if (typeof db._viewCleanup === 'function') {
      return customViewCleanup(db);
    }
    if (isRemote(db)) {
      return httpViewCleanup(db);
    }
    return localViewCleanup(db);
  });

  return {
    query: abstractQuery,
    viewCleanup: abstractViewCleanup
  };
}

var builtInReduce = {
  _sum: function (keys, values) {
    return sum(values);
  },

  _count: function (keys, values) {
    return values.length;
  },

  _stats: function (keys, values) {
    // no need to implement rereduce=true, because Pouch
    // will never call it
    function sumsqr(values) {
      var _sumsqr = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        _sumsqr += (num * num);
      }
      return _sumsqr;
    }
    return {
      sum     : sum(values),
      min     : Math.min.apply(null, values),
      max     : Math.max.apply(null, values),
      count   : values.length,
      sumsqr : sumsqr(values)
    };
  }
};

function getBuiltIn(reduceFunString) {
  if (/^_sum/.test(reduceFunString)) {
    return builtInReduce._sum;
  } else if (/^_count/.test(reduceFunString)) {
    return builtInReduce._count;
  } else if (/^_stats/.test(reduceFunString)) {
    return builtInReduce._stats;
  } else if (/^_/.test(reduceFunString)) {
    throw new Error(reduceFunString + ' is not a supported reduce function.');
  }
}

function mapper(mapFun, emit) {
  // for temp_views one can use emit(doc, emit), see #38
  if (typeof mapFun === "function" && mapFun.length === 2) {
    var origMap = mapFun;
    return function (doc) {
      return origMap(doc, emit);
    };
  } else {
    return evalFunctionWithEval(mapFun.toString(), emit);
  }
}

function reducer(reduceFun) {
  var reduceFunString = reduceFun.toString();
  var builtIn = getBuiltIn(reduceFunString);
  if (builtIn) {
    return builtIn;
  } else {
    return evalFunctionWithEval(reduceFunString);
  }
}

function ddocValidator(ddoc, viewName) {
  var fun = ddoc.views && ddoc.views[viewName];
  if (typeof fun.map !== 'string') {
    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +
      viewName + ', instead found object of type: ' + typeof fun.map);
  }
}

var localDocName = 'mrviews';
var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);

function query(fun, opts, callback) {
  return abstract.query.call(this, fun, opts, callback);
}

function viewCleanup(callback) {
  return abstract.viewCleanup.call(this, callback);
}

var mapreduce = {
  query: query,
  viewCleanup: viewCleanup
};

function isGenOne$1(rev$$1) {
  return /^1-/.test(rev$$1);
}

function fileHasChanged(localDoc, remoteDoc, filename) {
  return !localDoc._attachments ||
         !localDoc._attachments[filename] ||
         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
}

function getDocAttachments(db, doc) {
  var filenames = Object.keys(doc._attachments);
  return PouchPromise$1.all(filenames.map(function (filename) {
    return db.getAttachment(doc._id, filename, {rev: doc._rev});
  }));
}

function getDocAttachmentsFromTargetOrSource(target, src, doc) {
  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
  var filenames = Object.keys(doc._attachments);

  if (!doCheckForLocalAttachments) {
    return getDocAttachments(src, doc);
  }

  return target.get(doc._id).then(function (localDoc) {
    return PouchPromise$1.all(filenames.map(function (filename) {
      if (fileHasChanged(localDoc, doc, filename)) {
        return src.getAttachment(doc._id, filename);
      }

      return target.getAttachment(localDoc._id, filename);
    }));
  })["catch"](function (error) {
    /* istanbul ignore if */
    if (error.status !== 404) {
      throw error;
    }

    return getDocAttachments(src, doc);
  });
}

function createBulkGetOpts(diffs) {
  var requests = [];
  Object.keys(diffs).forEach(function (id) {
    var missingRevs = diffs[id].missing;
    missingRevs.forEach(function (missingRev) {
      requests.push({
        id: id,
        rev: missingRev
      });
    });
  });

  return {
    docs: requests,
    revs: true,
    latest: true
  };
}

//
// Fetch all the documents from the src as described in the "diffs",
// which is a mapping of docs IDs to revisions. If the state ever
// changes to "cancelled", then the returned promise will be rejected.
// Else it will be resolved with a list of fetched documents.
//
function getDocs(src, target, diffs, state) {
  diffs = clone(diffs); // we do not need to modify this

  var resultDocs = [],
      ok = true;

  function getAllDocs() {

    var bulkGetOpts = createBulkGetOpts(diffs);

    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
      return;
    }

    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
      /* istanbul ignore if */
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {
        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {
          var remoteDoc = doc.ok;

          if (doc.error) {
            // when AUTO_COMPACTION is set, docs can be returned which look
            // like this: {"missing":"1-7c3ac256b693c462af8442f992b83696"}
            ok = false;
          }

          if (!remoteDoc || !remoteDoc._attachments) {
            return remoteDoc;
          }

          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)
                   .then(function (attachments) {
                           var filenames = Object.keys(remoteDoc._attachments);
                           attachments
                             .forEach(function (attachment, i) {
                                        var att = remoteDoc._attachments[filenames[i]];
                                        delete att.stub;
                                        delete att.length;
                                        att.data = attachment;
                                      });

                                      return remoteDoc;
                                    });
        }));
      }))

      .then(function (results) {
        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
      });
    });
  }

  function hasAttachments(doc) {
    return doc._attachments && Object.keys(doc._attachments).length > 0;
  }

  function hasConflicts(doc) {
    return doc._conflicts && doc._conflicts.length > 0;
  }

  function fetchRevisionOneDocs(ids) {
    // Optimization: fetch gen-1 docs and attachments in
    // a single request using _all_docs
    return src.allDocs({
      keys: ids,
      include_docs: true,
      conflicts: true
    }).then(function (res) {
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      res.rows.forEach(function (row) {
        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||
            hasAttachments(row.doc) || hasConflicts(row.doc)) {
          // if any of these conditions apply, we need to fetch using get()
          return;
        }

        // strip _conflicts array to appease CSG (#5793)
        /* istanbul ignore if */
        if (row.doc._conflicts) {
          delete row.doc._conflicts;
        }

        // the doc we got back from allDocs() is sufficient
        resultDocs.push(row.doc);
        delete diffs[row.id];
      });
    });
  }

  function getRevisionOneDocs() {
    // filter out the generation 1 docs and get them
    // leaving the non-generation one docs to be got otherwise
    var ids = Object.keys(diffs).filter(function (id) {
      var missing = diffs[id].missing;
      return missing.length === 1 && isGenOne$1(missing[0]);
    });
    if (ids.length > 0) {
      return fetchRevisionOneDocs(ids);
    }
  }

  function returnResult() {
    return { ok:ok, docs:resultDocs };
  }

  return PouchPromise$1.resolve()
    .then(getRevisionOneDocs)
    .then(getAllDocs)
    .then(returnResult);
}

var CHECKPOINT_VERSION = 1;
var REPLICATOR = "pouchdb";
// This is an arbitrary number to limit the
// amount of replication history we save in the checkpoint.
// If we save too much, the checkpoing docs will become very big,
// if we save fewer, we'll run a greater risk of having to
// read all the changes from 0 when checkpoint PUTs fail
// CouchDB 2.0 has a more involved history pruning,
// but let's go for the simple version for now.
var CHECKPOINT_HISTORY_SIZE = 5;
var LOWEST_SEQ = 0;

function updateCheckpoint(db, id, checkpoint, session, returnValue) {
  return db.get(id)["catch"](function (err) {
    if (err.status === 404) {
      if (db.adapter === 'http' || db.adapter === 'https') {
        explainError(
          404, 'PouchDB is just checking if a remote checkpoint exists.'
        );
      }
      return {
        session_id: session,
        _id: id,
        history: [],
        replicator: REPLICATOR,
        version: CHECKPOINT_VERSION
      };
    }
    throw err;
  }).then(function (doc) {
    if (returnValue.cancelled) {
      return;
    }

    // if the checkpoint has not changed, do not update
    if (doc.last_seq === checkpoint) {
      return;
    }

    // Filter out current entry for this replication
    doc.history = (doc.history || []).filter(function (item) {
      return item.session_id !== session;
    });

    // Add the latest checkpoint to history
    doc.history.unshift({
      last_seq: checkpoint,
      session_id: session
    });

    // Just take the last pieces in history, to
    // avoid really big checkpoint docs.
    // see comment on history size above
    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

    doc.version = CHECKPOINT_VERSION;
    doc.replicator = REPLICATOR;

    doc.session_id = session;
    doc.last_seq = checkpoint;

    return db.put(doc)["catch"](function (err) {
      if (err.status === 409) {
        // retry; someone is trying to write a checkpoint simultaneously
        return updateCheckpoint(db, id, checkpoint, session, returnValue);
      }
      throw err;
    });
  });
}

function Checkpointer(src, target, id, returnValue, opts) {
  this.src = src;
  this.target = target;
  this.id = id;
  this.returnValue = returnValue;
  this.opts = opts;
}

Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
  var self = this;
  return this.updateTarget(checkpoint, session).then(function () {
    return self.updateSource(checkpoint, session);
  });
};

Checkpointer.prototype.updateTarget = function (checkpoint, session) {
  if (this.opts.writeTargetCheckpoint) {
    return updateCheckpoint(this.target, this.id, checkpoint,
      session, this.returnValue);
  } else {
    return PouchPromise$1.resolve(true);
  }
};

Checkpointer.prototype.updateSource = function (checkpoint, session) {
  if (this.opts.writeSourceCheckpoint) {
    var self = this;
    if (this.readOnlySource) {
      return PouchPromise$1.resolve(true);
    }
    return updateCheckpoint(this.src, this.id, checkpoint,
      session, this.returnValue)[
      "catch"](function (err) {
        if (isForbiddenError(err)) {
          self.readOnlySource = true;
          return true;
        }
        throw err;
      });
  } else {
    return PouchPromise$1.resolve(true);
  }
};

var comparisons = {
  "undefined": function (targetDoc, sourceDoc) {
    // This is the previous comparison function
    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
      return sourceDoc.last_seq;
    }
    /* istanbul ignore next */
    return 0;
  },
  "1": function (targetDoc, sourceDoc) {
    // This is the comparison function ported from CouchDB
    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
  }
};

Checkpointer.prototype.getCheckpoint = function () {
  var self = this;
  return self.target.get(self.id).then(function (targetDoc) {
    if (self.readOnlySource) {
      return PouchPromise$1.resolve(targetDoc.last_seq);
    }

    return self.src.get(self.id).then(function (sourceDoc) {
      // Since we can't migrate an old version doc to a new one
      // (no session id), we just go with the lowest seq in this case
      /* istanbul ignore if */
      if (targetDoc.version !== sourceDoc.version) {
        return LOWEST_SEQ;
      }

      var version;
      if (targetDoc.version) {
        version = targetDoc.version.toString();
      } else {
        version = "undefined";
      }

      if (version in comparisons) {
        return comparisons[version](targetDoc, sourceDoc);
      }
      /* istanbul ignore next */
      return LOWEST_SEQ;
    }, function (err) {
      if (err.status === 404 && targetDoc.last_seq) {
        return self.src.put({
          _id: self.id,
          last_seq: LOWEST_SEQ
        }).then(function () {
          return LOWEST_SEQ;
        }, function (err) {
          if (isForbiddenError(err)) {
            self.readOnlySource = true;
            return targetDoc.last_seq;
          }
          /* istanbul ignore next */
          return LOWEST_SEQ;
        });
      }
      throw err;
    });
  })["catch"](function (err) {
    if (err.status !== 404) {
      throw err;
    }
    return LOWEST_SEQ;
  });
};
// This checkpoint comparison is ported from CouchDBs source
// they come from here:
// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

function compareReplicationLogs(srcDoc, tgtDoc) {
  if (srcDoc.session_id === tgtDoc.session_id) {
    return {
      last_seq: srcDoc.last_seq,
      history: srcDoc.history
    };
  }

  return compareReplicationHistory(srcDoc.history, tgtDoc.history);
}

function compareReplicationHistory(sourceHistory, targetHistory) {
  // the erlang loop via function arguments is not so easy to repeat in JS
  // therefore, doing this as recursion
  var S = sourceHistory[0];
  var sourceRest = sourceHistory.slice(1);
  var T = targetHistory[0];
  var targetRest = targetHistory.slice(1);

  if (!S || targetHistory.length === 0) {
    return {
      last_seq: LOWEST_SEQ,
      history: []
    };
  }

  var sourceId = S.session_id;
  /* istanbul ignore if */
  if (hasSessionId(sourceId, targetHistory)) {
    return {
      last_seq: S.last_seq,
      history: sourceHistory
    };
  }

  var targetId = T.session_id;
  if (hasSessionId(targetId, sourceRest)) {
    return {
      last_seq: T.last_seq,
      history: targetRest
    };
  }

  return compareReplicationHistory(sourceRest, targetRest);
}

function hasSessionId(sessionId, history) {
  var props = history[0];
  var rest = history.slice(1);

  if (!sessionId || history.length === 0) {
    return false;
  }

  if (sessionId === props.session_id) {
    return true;
  }

  return hasSessionId(sessionId, rest);
}

function isForbiddenError(err) {
  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
}

var STARTING_BACK_OFF = 0;

function backOff(opts, returnValue, error, callback) {
  if (opts.retry === false) {
    returnValue.emit('error', error);
    returnValue.removeAllListeners();
    return;
  }
  if (typeof opts.back_off_function !== 'function') {
    opts.back_off_function = defaultBackOff;
  }
  returnValue.emit('requestError', error);
  if (returnValue.state === 'active' || returnValue.state === 'pending') {
    returnValue.emit('paused', error);
    returnValue.state = 'stopped';
    var backOffSet = function backoffTimeSet() {
      opts.current_back_off = STARTING_BACK_OFF;
    };
    var removeBackOffSetter = function removeBackOffTimeSet() {
      returnValue.removeListener('active', backOffSet);
    };
    returnValue.once('paused', removeBackOffSetter);
    returnValue.once('active', backOffSet);
  }

  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
  opts.current_back_off = opts.back_off_function(opts.current_back_off);
  setTimeout(callback, opts.current_back_off);
}

function sortObjectPropertiesByKey(queryParams) {
  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
    result[key] = queryParams[key];
    return result;
  }, {});
}

// Generate a unique id particular to this replication.
// Not guaranteed to align perfectly with CouchDB's rep ids.
function generateReplicationId(src, target, opts) {
  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
  var filterFun = opts.filter ? opts.filter.toString() : '';
  var queryParams = '';
  var filterViewName =  '';
  var selector = '';

  // possibility for checkpoints to be lost here as behaviour of
  // JSON.stringify is not stable (see #6226)
  /* istanbul ignore if */
  if (opts.selector) {
    selector = JSON.stringify(opts.selector);
  }

  if (opts.filter && opts.query_params) {
    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
  }

  if (opts.filter && opts.filter === '_view') {
    filterViewName = opts.view.toString();
  }

  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {
    var queryData = res[0] + res[1] + filterFun + filterViewName +
      queryParams + docIds + selector;
    return new PouchPromise$1(function (resolve) {
      binaryMd5(queryData, resolve);
    });
  }).then(function (md5sum) {
    // can't use straight-up md5 alphabet, because
    // the char '/' is interpreted as being for attachments,
    // and + is also not url-safe
    md5sum = md5sum.replace(/\//g, '.').replace(/\+/g, '_');
    return '_local/' + md5sum;
  });
}

function replicate(src, target, opts, returnValue, result) {
  var batches = [];               // list of batches to be processed
  var currentBatch;               // the batch currently being processed
  var pendingBatch = {
    seq: 0,
    changes: [],
    docs: []
  }; // next batch, not yet ready to be processed
  var writingCheckpoint = false;  // true while checkpoint is being written
  var changesCompleted = false;   // true when all changes received
  var replicationCompleted = false; // true when replication has completed
  var last_seq = 0;
  var continuous = opts.continuous || opts.live || false;
  var batch_size = opts.batch_size || 100;
  var batches_limit = opts.batches_limit || 10;
  var changesPending = false;     // true while src.changes is running
  var doc_ids = opts.doc_ids;
  var selector = opts.selector;
  var repId;
  var checkpointer;
  var changedDocs = [];
  // Like couchdb, every replication gets a unique session id
  var session = uuid();

  result = result || {
    ok: true,
    start_time: new Date(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };

  var changesOpts = {};
  returnValue.ready(src, target);

  function initCheckpointer() {
    if (checkpointer) {
      return PouchPromise$1.resolve();
    }
    return generateReplicationId(src, target, opts).then(function (res) {
      repId = res;

      var checkpointOpts = {};
      if (opts.checkpoint === false) {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'source') {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'target') {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };
      } else {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };
      }

      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
    });
  }

  function writeDocs() {
    changedDocs = [];

    if (currentBatch.docs.length === 0) {
      return;
    }
    var docs = currentBatch.docs;
    var bulkOpts = {timeout: opts.timeout};
    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }

      // `res` doesn't include full documents (which live in `docs`), so we create a map of 
      // (id -> error), and check for errors while iterating over `docs`
      var errorsById = Object.create(null);
      res.forEach(function (res) {
        if (res.error) {
          errorsById[res.id] = res;
        }
      });

      var errorsNo = Object.keys(errorsById).length;
      result.doc_write_failures += errorsNo;
      result.docs_written += docs.length - errorsNo;

      docs.forEach(function (doc) {
        var error = errorsById[doc._id];
        if (error) {
          result.errors.push(error);
          if (error.name === 'unauthorized' || error.name === 'forbidden') {
            returnValue.emit('denied', clone(error));
          } else {
            throw error;
          }
        } else {
          changedDocs.push(doc);
        }
      });

    }, function (err) {
      result.doc_write_failures += docs.length;
      throw err;
    });
  }

  function finishBatch() {
    if (currentBatch.error) {
      throw new Error('There was a problem getting docs.');
    }
    result.last_seq = last_seq = currentBatch.seq;
    var outResult = clone(result);
    if (changedDocs.length) {
      outResult.docs = changedDocs;
      returnValue.emit('change', outResult);
    }
    writingCheckpoint = true;
    return checkpointer.writeCheckpoint(currentBatch.seq,
        session).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      currentBatch = undefined;
      getChanges();
    })["catch"](function (err) {
      onCheckpointError(err);
      throw err;
    });
  }

  function getDiffs() {
    var diff = {};
    currentBatch.changes.forEach(function (change) {
      // Couchbase Sync Gateway emits these, but we can ignore them
      /* istanbul ignore if */
      if (change.id === "_user/") {
        return;
      }
      diff[change.id] = change.changes.map(function (x) {
        return x.rev;
      });
    });
    return target.revsDiff(diff).then(function (diffs) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      // currentBatch.diffs elements are deleted as the documents are written
      currentBatch.diffs = diffs;
    });
  }

  function getBatchDocs() {
    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
      currentBatch.error = !got.ok;
      got.docs.forEach(function (doc) {
        delete currentBatch.diffs[doc._id];
        result.docs_read++;
        currentBatch.docs.push(doc);
      });
    });
  }

  function startNextBatch() {
    if (returnValue.cancelled || currentBatch) {
      return;
    }
    if (batches.length === 0) {
      processPendingBatch(true);
      return;
    }
    currentBatch = batches.shift();
    getDiffs()
      .then(getBatchDocs)
      .then(writeDocs)
      .then(finishBatch)
      .then(startNextBatch)[
      "catch"](function (err) {
        abortReplication('batch processing terminated with error', err);
      });
  }


  function processPendingBatch(immediate) {
    if (pendingBatch.changes.length === 0) {
      if (batches.length === 0 && !currentBatch) {
        if ((continuous && changesOpts.live) || changesCompleted) {
          returnValue.state = 'pending';
          returnValue.emit('paused');
        }
        if (changesCompleted) {
          completeReplication();
        }
      }
      return;
    }
    if (
      immediate ||
      changesCompleted ||
      pendingBatch.changes.length >= batch_size
    ) {
      batches.push(pendingBatch);
      pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      };
      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
        returnValue.state = 'active';
        returnValue.emit('active');
      }
      startNextBatch();
    }
  }


  function abortReplication(reason, err) {
    if (replicationCompleted) {
      return;
    }
    if (!err.message) {
      err.message = reason;
    }
    result.ok = false;
    result.status = 'aborting';
    batches = [];
    pendingBatch = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication(err);
  }


  function completeReplication(fatalError) {
    if (replicationCompleted) {
      return;
    }
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      result.status = 'cancelled';
      if (writingCheckpoint) {
        return;
      }
    }
    result.status = result.status || 'complete';
    result.end_time = new Date();
    result.last_seq = last_seq;
    replicationCompleted = true;

    if (fatalError) {
      // need to extend the error because Firefox considers ".result" read-only
      fatalError = createError(fatalError);
      fatalError.result = result;

      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {
        returnValue.emit('error', fatalError);
        returnValue.removeAllListeners();
      } else {
        backOff(opts, returnValue, fatalError, function () {
          replicate(src, target, opts, returnValue);
        });
      }
    } else {
      returnValue.emit('complete', result);
      returnValue.removeAllListeners();
    }
  }


  function onChange(change) {
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    var filter = filterChange(opts)(change);
    if (!filter) {
      return;
    }
    pendingBatch.seq = change.seq;
    pendingBatch.changes.push(change);
    processPendingBatch(batches.length === 0 && changesOpts.live);
  }


  function onChangesComplete(changes) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }

    // if no results were returned then we're done,
    // else fetch more
    if (changes.results.length > 0) {
      changesOpts.since = changes.last_seq;
      getChanges();
      processPendingBatch(true);
    } else {

      var complete = function () {
        if (continuous) {
          changesOpts.live = true;
          getChanges();
        } else {
          changesCompleted = true;
        }
        processPendingBatch(true);
      };

      // update the checkpoint so we start from the right seq next time
      if (!currentBatch && changes.results.length === 0) {
        writingCheckpoint = true;
        checkpointer.writeCheckpoint(changes.last_seq,
            session).then(function () {
          writingCheckpoint = false;
          result.last_seq = last_seq = changes.last_seq;
          complete();
        })[
        "catch"](onCheckpointError);
      } else {
        complete();
      }
    }
  }


  function onChangesError(err) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    abortReplication('changes rejected', err);
  }


  function getChanges() {
    if (!(
      !changesPending &&
      !changesCompleted &&
      batches.length < batches_limit
      )) {
      return;
    }
    changesPending = true;
    function abortChanges() {
      changes.cancel();
    }
    function removeListener() {
      returnValue.removeListener('cancel', abortChanges);
    }

    if (returnValue._changes) { // remove old changes() and listeners
      returnValue.removeListener('cancel', returnValue._abortChanges);
      returnValue._changes.cancel();
    }
    returnValue.once('cancel', abortChanges);

    var changes = src.changes(changesOpts)
      .on('change', onChange);
    changes.then(removeListener, removeListener);
    changes.then(onChangesComplete)[
      "catch"](onChangesError);

    if (opts.retry) {
      // save for later so we can cancel if necessary
      returnValue._changes = changes;
      returnValue._abortChanges = abortChanges;
    }
  }


  function startChanges() {
    initCheckpointer().then(function () {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      return checkpointer.getCheckpoint().then(function (checkpoint) {
        last_seq = checkpoint;
        changesOpts = {
          since: last_seq,
          limit: batch_size,
          batch_size: batch_size,
          style: 'all_docs',
          doc_ids: doc_ids,
          selector: selector,
          return_docs: true // required so we know when we're done
        };
        if (opts.filter) {
          if (typeof opts.filter !== 'string') {
            // required for the client-side filter in onChange
            changesOpts.include_docs = true;
          } else { // ddoc filter
            changesOpts.filter = opts.filter;
          }
        }
        if ('heartbeat' in opts) {
          changesOpts.heartbeat = opts.heartbeat;
        }
        if ('timeout' in opts) {
          changesOpts.timeout = opts.timeout;
        }
        if (opts.query_params) {
          changesOpts.query_params = opts.query_params;
        }
        if (opts.view) {
          changesOpts.view = opts.view;
        }
        getChanges();
      });
    })["catch"](function (err) {
      abortReplication('getCheckpoint rejected with ', err);
    });
  }

  /* istanbul ignore next */
  function onCheckpointError(err) {
    writingCheckpoint = false;
    abortReplication('writeCheckpoint completed with error', err);
  }

  /* istanbul ignore if */
  if (returnValue.cancelled) { // cancelled immediately
    completeReplication();
    return;
  }

  if (!returnValue._addedListeners) {
    returnValue.once('cancel', completeReplication);

    if (typeof opts.complete === 'function') {
      returnValue.once('error', opts.complete);
      returnValue.once('complete', function (result) {
        opts.complete(null, result);
      });
    }
    returnValue._addedListeners = true;
  }

  if (typeof opts.since === 'undefined') {
    startChanges();
  } else {
    initCheckpointer().then(function () {
      writingCheckpoint = true;
      return checkpointer.writeCheckpoint(opts.since, session);
    }).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      last_seq = opts.since;
      startChanges();
    })["catch"](onCheckpointError);
  }
}

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
inherits(Replication, events.EventEmitter);
function Replication() {
  events.EventEmitter.call(this);
  this.cancelled = false;
  this.state = 'pending';
  var self = this;
  var promise = new PouchPromise$1(function (fulfill, reject) {
    self.once('complete', fulfill);
    self.once('error', reject);
  });
  self.then = function (resolve, reject) {
    return promise.then(resolve, reject);
  };
  self["catch"] = function (reject) {
    return promise["catch"](reject);
  };
  // As we allow error handling via "error" event as well,
  // put a stub in here so that rejecting never throws UnhandledError.
  self["catch"](function () {});
}

Replication.prototype.cancel = function () {
  this.cancelled = true;
  this.state = 'cancelled';
  this.emit('cancel');
};

Replication.prototype.ready = function (src, target) {
  var self = this;
  if (self._readyCalled) {
    return;
  }
  self._readyCalled = true;

  function onDestroy() {
    self.cancel();
  }
  src.once('destroyed', onDestroy);
  target.once('destroyed', onDestroy);
  function cleanup() {
    src.removeListener('destroyed', onDestroy);
    target.removeListener('destroyed', onDestroy);
  }
  self.once('complete', cleanup);
};

function toPouch(db, opts) {
  var PouchConstructor = opts.PouchConstructor;
  if (typeof db === 'string') {
    return new PouchConstructor(db, opts);
  } else {
    return db;
  }
}

function replicateWrapper(src, target, opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }

  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
    throw createError(BAD_REQUEST,
                       "`doc_ids` filter parameter is not a list.");
  }

  opts.complete = callback;
  opts = clone(opts);
  opts.continuous = opts.continuous || opts.live;
  opts.retry = ('retry' in opts) ? opts.retry : false;
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  var replicateRet = new Replication(opts);
  var srcPouch = toPouch(src, opts);
  var targetPouch = toPouch(target, opts);
  replicate(srcPouch, targetPouch, opts, replicateRet);
  return replicateRet;
}

inherits(Sync, events.EventEmitter);
function sync$1(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  opts = clone(opts);
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  src = toPouch(src, opts);
  target = toPouch(target, opts);
  return new Sync(src, target, opts, callback);
}

function Sync(src, target, opts, callback) {
  var self = this;
  this.canceled = false;

  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;

  this.push = replicateWrapper(src, target, optsPush);
  this.pull = replicateWrapper(target, src, optsPull);

  this.pushPaused = true;
  this.pullPaused = true;

  function pullChange(change) {
    self.emit('change', {
      direction: 'pull',
      change: change
    });
  }
  function pushChange(change) {
    self.emit('change', {
      direction: 'push',
      change: change
    });
  }
  function pushDenied(doc) {
    self.emit('denied', {
      direction: 'push',
      doc: doc
    });
  }
  function pullDenied(doc) {
    self.emit('denied', {
      direction: 'pull',
      doc: doc
    });
  }
  function pushPaused() {
    self.pushPaused = true;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('paused');
    }
  }
  function pullPaused() {
    self.pullPaused = true;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('paused');
    }
  }
  function pushActive() {
    self.pushPaused = false;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('active', {
        direction: 'push'
      });
    }
  }
  function pullActive() {
    self.pullPaused = false;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('active', {
        direction: 'pull'
      });
    }
  }

  var removed = {};

  function removeAll(type) { // type is 'push' or 'pull'
    return function (event, func) {
      var isChange = event === 'change' &&
        (func === pullChange || func === pushChange);
      var isDenied = event === 'denied' &&
        (func === pullDenied || func === pushDenied);
      var isPaused = event === 'paused' &&
        (func === pullPaused || func === pushPaused);
      var isActive = event === 'active' &&
        (func === pullActive || func === pushActive);

      if (isChange || isDenied || isPaused || isActive) {
        if (!(event in removed)) {
          removed[event] = {};
        }
        removed[event][type] = true;
        if (Object.keys(removed[event]).length === 2) {
          // both push and pull have asked to be removed
          self.removeAllListeners(event);
        }
      }
    };
  }

  if (opts.live) {
    this.push.on('complete', self.pull.cancel.bind(self.pull));
    this.pull.on('complete', self.push.cancel.bind(self.push));
  }

  function addOneListener(ee, event, listener) {
    if (ee.listeners(event).indexOf(listener) == -1) {
      ee.on(event, listener);
    }
  }

  this.on('newListener', function (event) {
    if (event === 'change') {
      addOneListener(self.pull, 'change', pullChange);
      addOneListener(self.push, 'change', pushChange);
    } else if (event === 'denied') {
      addOneListener(self.pull, 'denied', pullDenied);
      addOneListener(self.push, 'denied', pushDenied);
    } else if (event === 'active') {
      addOneListener(self.pull, 'active', pullActive);
      addOneListener(self.push, 'active', pushActive);
    } else if (event === 'paused') {
      addOneListener(self.pull, 'paused', pullPaused);
      addOneListener(self.push, 'paused', pushPaused);
    }
  });

  this.on('removeListener', function (event) {
    if (event === 'change') {
      self.pull.removeListener('change', pullChange);
      self.push.removeListener('change', pushChange);
    } else if (event === 'denied') {
      self.pull.removeListener('denied', pullDenied);
      self.push.removeListener('denied', pushDenied);
    } else if (event === 'active') {
      self.pull.removeListener('active', pullActive);
      self.push.removeListener('active', pushActive);
    } else if (event === 'paused') {
      self.pull.removeListener('paused', pullPaused);
      self.push.removeListener('paused', pushPaused);
    }
  });

  this.pull.on('removeListener', removeAll('pull'));
  this.push.on('removeListener', removeAll('push'));

  var promise = PouchPromise$1.all([
    this.push,
    this.pull
  ]).then(function (resp) {
    var out = {
      push: resp[0],
      pull: resp[1]
    };
    self.emit('complete', out);
    if (callback) {
      callback(null, out);
    }
    self.removeAllListeners();
    return out;
  }, function (err) {
    self.cancel();
    if (callback) {
      // if there's a callback, then the callback can receive
      // the error event
      callback(err);
    } else {
      // if there's no callback, then we're safe to emit an error
      // event, which would otherwise throw an unhandled error
      // due to 'error' being a special event in EventEmitters
      self.emit('error', err);
    }
    self.removeAllListeners();
    if (callback) {
      // no sense throwing if we're already emitting an 'error' event
      throw err;
    }
  });

  this.then = function (success, err) {
    return promise.then(success, err);
  };

  this["catch"] = function (err) {
    return promise["catch"](err);
  };
}

Sync.prototype.cancel = function () {
  if (!this.canceled) {
    this.canceled = true;
    this.push.cancel();
    this.pull.cancel();
  }
};

function replication(PouchDB) {
  PouchDB.replicate = replicateWrapper;
  PouchDB.sync = sync$1;

  Object.defineProperty(PouchDB.prototype, 'replicate', {
    get: function () {
      var self = this;
      return {
        from: function (other, opts, callback) {
          return self.constructor.replicate(other, self, opts, callback);
        },
        to: function (other, opts, callback) {
          return self.constructor.replicate(self, other, opts, callback);
        }
      };
    }
  });

  PouchDB.prototype.sync = function (dbName, opts, callback) {
    return this.constructor.sync(this, dbName, opts, callback);
  };
}

PouchDB$5.plugin(IDBPouch)
  .plugin(WebSqlPouch)
  .plugin(HttpPouch$1)
  .plugin(mapreduce)
  .plugin(replication);

// Pull from src because pouchdb-node/pouchdb-browser themselves
// are aggressively optimized and jsnext:main would normally give us this
// aggressive bundle.

module.exports = PouchDB$5;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"1":1,"10":10,"13":13,"14":14,"2":2,"4":4,"5":5,"6":6,"7":7}]},{},[15])(15)
});
// INLINED END /Users/robert/Lively/lively-dev2/lively.storage/node_modules/pouchdb/dist/pouchdb.js
  return module.exports;
})();

var pouchdbAdapterMem = (function() {
  var exports = {}, module = {exports: exports};
// INLINED undefined
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pouchdbAdapterMemory = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}
},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
(function (Buffer){
var isArrayBuffer = require('is-array-buffer-x')

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom

}).call(this,require("buffer").Buffer)
},{"buffer":5,"is-array-buffer-x":25}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":2,"ieee754":22}],6:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":26}],7:[function(require,module,exports){
var util = require('util')
  , AbstractIterator = require('abstract-leveldown').AbstractIterator


function DeferredIterator (options) {
  AbstractIterator.call(this, options)

  this._options = options
  this._iterator = null
  this._operations = []
}

util.inherits(DeferredIterator, AbstractIterator)

DeferredIterator.prototype.setDb = function (db) {
  var it = this._iterator = db.iterator(this._options)
  this._operations.forEach(function (op) {
    it[op.method].apply(it, op.args)
  })
}

DeferredIterator.prototype._operation = function (method, args) {
  if (this._iterator)
    return this._iterator[method].apply(this._iterator, args)
  this._operations.push({ method: method, args: args })
}

'next end'.split(' ').forEach(function (m) {
  DeferredIterator.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

module.exports = DeferredIterator;

},{"abstract-leveldown":12,"util":114}],8:[function(require,module,exports){
(function (Buffer,process){
var util              = require('util')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
  , DeferredIterator  = require('./deferred-iterator')

function DeferredLevelDOWN (location) {
  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '') // optional location, who cares?
  this._db         = undefined
  this._operations = []
  this._iterators  = []
}

util.inherits(DeferredLevelDOWN, AbstractLevelDOWN)

// called by LevelUP when we have a real DB to take its place
DeferredLevelDOWN.prototype.setDb = function (db) {
  this._db = db
  this._operations.forEach(function (op) {
    db[op.method].apply(db, op.args)
  })
  this._iterators.forEach(function (it) {
    it.setDb(db)
  })
}

DeferredLevelDOWN.prototype._open = function (options, callback) {
  return process.nextTick(callback)
}

// queue a new deferred operation
DeferredLevelDOWN.prototype._operation = function (method, args) {
  if (this._db)
    return this._db[method].apply(this._db, args)
  this._operations.push({ method: method, args: args })
}

// deferrables
'put get del batch approximateSize'.split(' ').forEach(function (m) {
  DeferredLevelDOWN.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

DeferredLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

DeferredLevelDOWN.prototype._iterator = function (options) {
  if (this._db)
    return this._db.iterator.apply(this._db, arguments)
  var it = new DeferredIterator(options)
  this._iterators.push(it)
  return it
}

module.exports                  = DeferredLevelDOWN
module.exports.DeferredIterator = DeferredIterator

}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))
},{"../is-buffer/index.js":26,"./deferred-iterator":7,"_process":70,"abstract-leveldown":12,"util":114}],9:[function(require,module,exports){
(function (process){
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractChainedBatch (db) {
  this._db         = db
  this._operations = []
  this._written    = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written)
    throw new Error('write() already called on this batch')
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err)
    throw err

  if (!this._db._isBuffer(key)) key = String(key)
  if (!this._db._isBuffer(value)) value = String(value)

  if (typeof this._put == 'function' )
    this._put(key, value)
  else
    this._operations.push({ type: 'put', key: key, value: value })

  return this
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err) throw err

  if (!this._db._isBuffer(key)) key = String(key)

  if (typeof this._del == 'function' )
    this._del(key)
  else
    this._operations.push({ type: 'del', key: key })

  return this
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()

  this._operations = []

  if (typeof this._clear == 'function' )
    this._clear()

  return this
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('write() requires a callback argument')
  if (typeof options != 'object')
    options = {}

  this._written = true

  if (typeof this._write == 'function' )
    return this._write(callback)

  if (typeof this._db._batch == 'function')
    return this._db._batch(this._operations, options, callback)

  process.nextTick(callback)
}

module.exports = AbstractChainedBatch
}).call(this,require('_process'))
},{"_process":70}],10:[function(require,module,exports){
(function (process){
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractIterator (db) {
  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback != 'function')
    throw new Error('next() requires a callback argument')

  if (self._ended)
    return callback(new Error('cannot call next() after end()'))
  if (self._nexting)
    return callback(new Error('cannot call next() before previous next() has completed'))

  self._nexting = true
  if (typeof self._next == 'function') {
    return self._next(function () {
      self._nexting = false
      callback.apply(null, arguments)
    })
  }

  process.nextTick(function () {
    self._nexting = false
    callback()
  })
}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback != 'function')
    throw new Error('end() requires a callback argument')

  if (this._ended)
    return callback(new Error('end() already called on iterator'))

  this._ended = true

  if (typeof this._end == 'function')
    return this._end(callback)

  process.nextTick(callback)
}

module.exports = AbstractIterator

}).call(this,require('_process'))
},{"_process":70}],11:[function(require,module,exports){
(function (Buffer,process){
/* Copyright (c) 2013 Rod Vagg, MIT License */

var xtend                = require('xtend')
  , AbstractIterator     = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')

function AbstractLevelDOWN (location) {
  if (!arguments.length || location === undefined)
    throw new Error('constructor requires at least a location argument')

  if (typeof location != 'string')
    throw new Error('constructor requires a location string argument')

  this.location = location
  this.status = 'new'
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('open() requires a callback argument')

  if (typeof options != 'object')
    options = {}

  options.createIfMissing = options.createIfMissing != false
  options.errorIfExists = !!options.errorIfExists

  if (typeof this._open == 'function') {
    this.status = 'opening'
    this._open(options, function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'open'
      callback()
    })
  } else {
    this.status = 'open'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.close = function (callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof callback != 'function')
    throw new Error('close() requires a callback argument')

  if (typeof this._close == 'function') {
    this.status = 'closing'
    this._close(function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'closed'
      callback()
    })
  } else {
    this.status = 'closed'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('get() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  options.asBuffer = options.asBuffer != false

  if (typeof this._get == 'function')
    return this._get(key, options, callback)

  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('put() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  // coerce value to string in node, don't touch it in browser
  // (indexeddb can store any JS type)
  if (value != null && !this._isBuffer(value) && !process.browser)
    value = String(value)

  if (typeof options != 'object')
    options = {}

  if (typeof this._put == 'function')
    return this._put(key, value, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('del() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  if (typeof this._del == 'function')
    return this._del(key, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length)
    return this._chainedBatch()

  if (typeof options == 'function')
    callback = options

  if (typeof array == 'function')
    callback = array

  if (typeof callback != 'function')
    throw new Error('batch(array) requires a callback argument')

  if (!Array.isArray(array))
    return callback(new Error('batch(array) requires an array argument'))

  if (!options || typeof options != 'object')
    options = {}

  var i = 0
    , l = array.length
    , e
    , err

  for (; i < l; i++) {
    e = array[i]
    if (typeof e != 'object')
      continue

    if (err = this._checkKey(e.type, 'type', this._isBuffer))
      return callback(err)

    if (err = this._checkKey(e.key, 'key', this._isBuffer))
      return callback(err)
  }

  if (typeof this._batch == 'function')
    return this._batch(array, options, callback)

  process.nextTick(callback)
}

//TODO: remove from here, not a necessary primitive
AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
  if (   start == null
      || end == null
      || typeof start == 'function'
      || typeof end == 'function') {
    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
  }

  if (typeof callback != 'function')
    throw new Error('approximateSize() requires a callback argument')

  if (!this._isBuffer(start))
    start = String(start)

  if (!this._isBuffer(end))
    end = String(end)

  if (typeof this._approximateSize == 'function')
    return this._approximateSize(start, end, callback)

  process.nextTick(function () {
    callback(null, 0)
  })
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  var self = this

  options = xtend(options)

  ;[ 'start', 'end', 'gt', 'gte', 'lt', 'lte' ].forEach(function (o) {
    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
      delete options[o]
  })

  options.reverse = !!options.reverse
  options.keys = options.keys != false
  options.values = options.values != false
  options.limit = 'limit' in options ? options.limit : -1
  options.keyAsBuffer = options.keyAsBuffer != false
  options.valueAsBuffer = options.valueAsBuffer != false

  return options
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options != 'object')
    options = {}

  options = this._setupIteratorOptions(options)

  if (typeof this._iterator == 'function')
    return this._iterator(options)

  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

AbstractLevelDOWN.prototype._checkKey = function (obj, type) {

  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')

  if (this._isBuffer(obj)) {
    if (obj.length === 0)
      return new Error(type + ' cannot be an empty Buffer')
  } else if (String(obj) === '')
    return new Error(type + ' cannot be an empty String')
}

module.exports = AbstractLevelDOWN

}).call(this,{"isBuffer":require("../../../is-buffer/index.js")},require('_process'))
},{"../../../is-buffer/index.js":26,"./abstract-chained-batch":9,"./abstract-iterator":10,"_process":70,"xtend":120}],12:[function(require,module,exports){
exports.AbstractLevelDOWN    = require('./abstract-leveldown')
exports.AbstractIterator     = require('./abstract-iterator')
exports.AbstractChainedBatch = require('./abstract-chained-batch')
exports.isLevelDOWN          = require('./is-leveldown')

},{"./abstract-chained-batch":9,"./abstract-iterator":10,"./abstract-leveldown":11,"./is-leveldown":13}],13:[function(require,module,exports){
var AbstractLevelDOWN = require('./abstract-leveldown')

function isLevelDOWN (db) {
  if (!db || typeof db !== 'object')
    return false
  return Object.keys(AbstractLevelDOWN.prototype).filter(function (name) {
    // TODO remove approximateSize check when method is gone
    return name[0] != '_' && name != 'approximateSize'
  }).every(function (name) {
    return typeof db[name] == 'function'
  })
}

module.exports = isLevelDOWN

},{"./abstract-leveldown":11}],14:[function(require,module,exports){
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
"use strict";
function Deque(capacity) {
    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    if (isArray(capacity)) {
        var len = capacity.length;
        for (var i = 0; i < len; ++i) {
            this[i] = capacity[i];
        }
        this._length = len;
    }
}

Deque.prototype.toArray = function Deque$toArray() {
    var len = this._length;
    var ret = new Array(len);
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        ret[j] = this[(front + j) & (capacity - 1)];
    }
    return ret;
};

Deque.prototype.push = function Deque$push(item) {
    var argsLength = arguments.length;
    var length = this._length;
    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = (this._front + length) & (this._capacity - 1);
                this[j] = arguments[i];
                length++;
                this._length = length;
            }
            return length;
        }
        else {
            var j = this._front;
            for (var i = 0; i < argsLength; ++i) {
                this[(j + length) & (capacity - 1)] = arguments[i];
                j++;
            }
            this._length = length + argsLength;
            return length + argsLength;
        }

    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = item;
    this._length = length + 1;
    return length + 1;
};

Deque.prototype.pop = function Deque$pop() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var i = (this._front + length - 1) & (this._capacity - 1);
    var ret = this[i];
    this[i] = void 0;
    this._length = length - 1;
    return ret;
};

Deque.prototype.shift = function Deque$shift() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var front = this._front;
    var ret = this[front];
    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length = length - 1;
    return ret;
};

Deque.prototype.unshift = function Deque$unshift(item) {
    var length = this._length;
    var argsLength = arguments.length;


    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (((( this._front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
            }
            return length;
        }
        else {
            var front = this._front;
            for (var i = argsLength - 1; i >= 0; i--) {
                var j = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                front = j;
            }
            this._front = front;
            this._length = length + argsLength;
            return length + argsLength;
        }
    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var capacity = this._capacity;
    var i = (((( this._front - 1 ) &
        ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = item;
    this._length = length + 1;
    this._front = i;
    return length + 1;
};

Deque.prototype.peekBack = function Deque$peekBack() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var index = (this._front + length - 1) & (this._capacity - 1);
    return this[index];
};

Deque.prototype.peekFront = function Deque$peekFront() {
    if (this._length === 0) {
        return void 0;
    }
    return this[this._front];
};

Deque.prototype.get = function Deque$get(index) {
    var i = index;
    if ((i !== (i | 0))) {
        return void 0;
    }
    var len = this._length;
    if (i < 0) {
        i = i + len;
    }
    if (i < 0 || i >= len) {
        return void 0;
    }
    return this[(this._front + i) & (this._capacity - 1)];
};

Deque.prototype.isEmpty = function Deque$isEmpty() {
    return this._length === 0;
};

Deque.prototype.clear = function Deque$clear() {
    var len = this._length;
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        this[(front + j) & (capacity - 1)] = void 0;
    }
    this._length = 0;
    this._front = 0;
};

Deque.prototype.toString = function Deque$toString() {
    return this.toArray().toString();
};

Deque.prototype.valueOf = Deque.prototype.toString;
Deque.prototype.removeFront = Deque.prototype.shift;
Deque.prototype.removeBack = Deque.prototype.pop;
Deque.prototype.insertFront = Deque.prototype.unshift;
Deque.prototype.insertBack = Deque.prototype.push;
Deque.prototype.enqueue = Deque.prototype.push;
Deque.prototype.dequeue = Deque.prototype.shift;
Deque.prototype.toJSON = Deque.prototype.toArray;

Object.defineProperty(Deque.prototype, "length", {
    get: function() {
        return this._length;
    },
    set: function() {
        throw new RangeError("");
    }
});

Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
    }
};

Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};


var isArray = Array.isArray;

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

function getCapacity(capacity) {
    if (typeof capacity !== "number") {
        if (isArray(capacity)) {
            capacity = capacity.length;
        }
        else {
            return 16;
        }
    }
    return pow2AtLeast(
        Math.min(
            Math.max(16, capacity), 1073741824)
    );
}

module.exports = Deque;

},{}],15:[function(require,module,exports){
var prr = require('prr')

function init (type, message, cause) {
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : !!message && typeof message != 'string' ? message.message : message

  }, 'ewr')
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
  init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init.call(this, type, message, cause)
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code
      this.path    = this.cause.path
      this.errno   = this.cause.errno
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
    }
    Error.call(this)
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, arguments.callee)
  }
  err.prototype = !!proto ? new proto() : new CustomError()
  return err
}

module.exports = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  }
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
}

},{"prr":17}],16:[function(require,module,exports){
var all = module.exports.all = [
  {
    errno: -2,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: -1,
    code: 'UNKNOWN',
    description: 'unknown error'
  },
  {
    errno: 0,
    code: 'OK',
    description: 'success'
  },
  {
    errno: 1,
    code: 'EOF',
    description: 'end of file'
  },
  {
    errno: 2,
    code: 'EADDRINFO',
    description: 'getaddrinfo error'
  },
  {
    errno: 3,
    code: 'EACCES',
    description: 'permission denied'
  },
  {
    errno: 4,
    code: 'EAGAIN',
    description: 'resource temporarily unavailable'
  },
  {
    errno: 5,
    code: 'EADDRINUSE',
    description: 'address already in use'
  },
  {
    errno: 6,
    code: 'EADDRNOTAVAIL',
    description: 'address not available'
  },
  {
    errno: 7,
    code: 'EAFNOSUPPORT',
    description: 'address family not supported'
  },
  {
    errno: 8,
    code: 'EALREADY',
    description: 'connection already in progress'
  },
  {
    errno: 9,
    code: 'EBADF',
    description: 'bad file descriptor'
  },
  {
    errno: 10,
    code: 'EBUSY',
    description: 'resource busy or locked'
  },
  {
    errno: 11,
    code: 'ECONNABORTED',
    description: 'software caused connection abort'
  },
  {
    errno: 12,
    code: 'ECONNREFUSED',
    description: 'connection refused'
  },
  {
    errno: 13,
    code: 'ECONNRESET',
    description: 'connection reset by peer'
  },
  {
    errno: 14,
    code: 'EDESTADDRREQ',
    description: 'destination address required'
  },
  {
    errno: 15,
    code: 'EFAULT',
    description: 'bad address in system call argument'
  },
  {
    errno: 16,
    code: 'EHOSTUNREACH',
    description: 'host is unreachable'
  },
  {
    errno: 17,
    code: 'EINTR',
    description: 'interrupted system call'
  },
  {
    errno: 18,
    code: 'EINVAL',
    description: 'invalid argument'
  },
  {
    errno: 19,
    code: 'EISCONN',
    description: 'socket is already connected'
  },
  {
    errno: 20,
    code: 'EMFILE',
    description: 'too many open files'
  },
  {
    errno: 21,
    code: 'EMSGSIZE',
    description: 'message too long'
  },
  {
    errno: 22,
    code: 'ENETDOWN',
    description: 'network is down'
  },
  {
    errno: 23,
    code: 'ENETUNREACH',
    description: 'network is unreachable'
  },
  {
    errno: 24,
    code: 'ENFILE',
    description: 'file table overflow'
  },
  {
    errno: 25,
    code: 'ENOBUFS',
    description: 'no buffer space available'
  },
  {
    errno: 26,
    code: 'ENOMEM',
    description: 'not enough memory'
  },
  {
    errno: 27,
    code: 'ENOTDIR',
    description: 'not a directory'
  },
  {
    errno: 28,
    code: 'EISDIR',
    description: 'illegal operation on a directory'
  },
  {
    errno: 29,
    code: 'ENONET',
    description: 'machine is not on the network'
  },
  {
    errno: 31,
    code: 'ENOTCONN',
    description: 'socket is not connected'
  },
  {
    errno: 32,
    code: 'ENOTSOCK',
    description: 'socket operation on non-socket'
  },
  {
    errno: 33,
    code: 'ENOTSUP',
    description: 'operation not supported on socket'
  },
  {
    errno: 34,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: 35,
    code: 'ENOSYS',
    description: 'function not implemented'
  },
  {
    errno: 36,
    code: 'EPIPE',
    description: 'broken pipe'
  },
  {
    errno: 37,
    code: 'EPROTO',
    description: 'protocol error'
  },
  {
    errno: 38,
    code: 'EPROTONOSUPPORT',
    description: 'protocol not supported'
  },
  {
    errno: 39,
    code: 'EPROTOTYPE',
    description: 'protocol wrong type for socket'
  },
  {
    errno: 40,
    code: 'ETIMEDOUT',
    description: 'connection timed out'
  },
  {
    errno: 41,
    code: 'ECHARSET',
    description: 'invalid Unicode character'
  },
  {
    errno: 42,
    code: 'EAIFAMNOSUPPORT',
    description: 'address family for hostname not supported'
  },
  {
    errno: 44,
    code: 'EAISERVICE',
    description: 'servname not supported for ai_socktype'
  },
  {
    errno: 45,
    code: 'EAISOCKTYPE',
    description: 'ai_socktype not supported'
  },
  {
    errno: 46,
    code: 'ESHUTDOWN',
    description: 'cannot send after transport endpoint shutdown'
  },
  {
    errno: 47,
    code: 'EEXIST',
    description: 'file already exists'
  },
  {
    errno: 48,
    code: 'ESRCH',
    description: 'no such process'
  },
  {
    errno: 49,
    code: 'ENAMETOOLONG',
    description: 'name too long'
  },
  {
    errno: 50,
    code: 'EPERM',
    description: 'operation not permitted'
  },
  {
    errno: 51,
    code: 'ELOOP',
    description: 'too many symbolic links encountered'
  },
  {
    errno: 52,
    code: 'EXDEV',
    description: 'cross-device link not permitted'
  },
  {
    errno: 53,
    code: 'ENOTEMPTY',
    description: 'directory not empty'
  },
  {
    errno: 54,
    code: 'ENOSPC',
    description: 'no space left on device'
  },
  {
    errno: 55,
    code: 'EIO',
    description: 'i/o error'
  },
  {
    errno: 56,
    code: 'EROFS',
    description: 'read-only file system'
  },
  {
    errno: 57,
    code: 'ENODEV',
    description: 'no such device'
  },
  {
    errno: 58,
    code: 'ESPIPE',
    description: 'invalid seek'
  },
  {
    errno: 59,
    code: 'ECANCELED',
    description: 'operation canceled'
  }
]

module.exports.errno = {}
module.exports.code = {}

all.forEach(function (error) {
  module.exports.errno[error.errno] = error
  module.exports.code[error.code] = error
})

module.exports.custom = require('./custom')(module.exports)
module.exports.create = module.exports.custom.createError

},{"./custom":15}],17:[function(require,module,exports){
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else
    context[name] = definition()
})('prr', this, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options)
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            }

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k

        options = makeOptions(value, options)

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k]
              setProperty(obj, k, options)
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      }

  return prr
})
},{}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],19:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}],20:[function(require,module,exports){
/**
 * @file Tests if ES6 Symbol is supported.
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-symbol-support-x
 */

'use strict';

/**
 * Indicates if `Symbol`exists and creates the correct type.
 * `true`, if it exists and creates the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = typeof Symbol === 'function' && typeof Symbol('') === 'symbol';

},{}],21:[function(require,module,exports){
/**
 * @file Tests if ES6 @@toStringTag is supported.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag|26.3.1 @@toStringTag}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-to-string-tag-x
 */

'use strict';

/**
 * Indicates if `Symbol.toStringTag`exists and is the correct type.
 * `true`, if it exists and is the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = require('has-symbol-support-x') && typeof Symbol.toStringTag === 'symbol';

},{"has-symbol-support-x":20}],22:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],23:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],24:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],25:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ArrayBuffer.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-buffer-x
 */

/* global ArrayBuffer */

'use strict';

var isObjectLike = require('is-object-like-x');
var hasABuf = typeof ArrayBuffer === 'function';
var toStringTag;
var aBufTag;
var bLength;

if (hasABuf) {
  if (require('has-to-string-tag-x')) {
    try {
      bLength = Object.getOwnPropertyDescriptor(
        ArrayBuffer.prototype,
        'byteLength'
      ).get;
      bLength = typeof bLength.call(new ArrayBuffer(4)) === 'number' && bLength;
    } catch (ignore) {}
  }

  if (Boolean(bLength) === false) {
    toStringTag = require('to-string-tag-x');
    aBufTag = '[object ArrayBuffer]';
  }
}

/**
 * Determine if an `object` is an `ArrayBuffer`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is an `ArrayBuffer`,
 *  else false`.
 * @example
 * var isArrayBuffer = require('is-array-buffer-x');
 *
 * isArrayBuffer(new ArrayBuffer(4)); // true
 * isArrayBuffer(null); // false
 * isArrayBuffer([]); // false
 */
module.exports = function isArrayBuffer(object) {
  if (hasABuf === false || isObjectLike(object) === false) {
    return false;
  }

  if (Boolean(bLength) === false) {
    return toStringTag(object) === aBufTag;
  }

  try {
    return typeof bLength.call(object) === 'number';
  } catch (ignore) {}

  return false;
};

},{"has-to-string-tag-x":21,"is-object-like-x":28,"to-string-tag-x":110}],26:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],27:[function(require,module,exports){
/**
 * @file Determine whether a given value is a function object.
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-function-x
 */

'use strict';

var fToString = Function.prototype.toString;
var toStringTag = require('to-string-tag-x');
var hasToStringTag = require('has-to-string-tag-x');
var isPrimitive = require('is-primitive');
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var asyncTag = '[object AsyncFunction]';

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFunc(value) {
  try {
    var fnStr = fToString.call(value);
    var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
    var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
    var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
    return constructorRegex.test(spaceStripped);
  } catch (ignore) {}

  return false; // not a function
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @private
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 */
var tryFuncToString = function funcToString(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }

    fToString.call(value);
    return true;
  } catch (ignore) {}

  return false;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 * @example
 * var isFunction = require('is-function-x');
 *
 * isFunction(); // false
 * isFunction(Number.MIN_VALUE); // false
 * isFunction('abc'); // false
 * isFunction(true); // false
 * isFunction({ name: 'abc' }); // false
 * isFunction(function () {}); // true
 * isFunction(new Function ()); // true
 * isFunction(function* test1() {}); // true
 * isFunction(function test2(a, b) {}); // true
 - isFunction(async function test3() {}); // true
 * isFunction(class Test {}); // false
 * isFunction((x, y) => {return this;}); // true
 */
module.exports = function isFunction(value) {
  if (isPrimitive(value)) {
    return false;
  }

  if (hasToStringTag) {
    return tryFuncToString(value);
  }

  if (isES6ClassFn(value)) {
    return false;
  }

  var strTag = toStringTag(value);
  return strTag === funcTag || strTag === genTag || strTag === asyncTag;
};

},{"has-to-string-tag-x":21,"is-primitive":29,"to-string-tag-x":110}],28:[function(require,module,exports){
/**
 * @file Determine if a value is object like.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-object-like-x
 */

'use strict';

var isFunction = require('is-function-x');
var isPrimitive = require('is-primitive');

/**
 * Checks if `value` is object-like. A value is object-like if it's not a
 * primitive and not a function.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 * var isObjectLike = require('is-object-like-x');
 *
 * isObjectLike({});
 * // => true
 *
 * isObjectLike([1, 2, 3]);
 * // => true
 *
 * isObjectLike(_.noop);
 * // => false
 *
 * isObjectLike(null);
 * // => false
 */
module.exports = function isObjectLike(value) {
  return isPrimitive(value) === false && isFunction(value) === false;
};

},{"is-function-x":27,"is-primitive":29}],29:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

// see http://jsperf.com/testing-value-is-primitive/7
module.exports = function isPrimitive(value) {
  return value == null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],30:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],31:[function(require,module,exports){
var encodings = require('./lib/encodings');

module.exports = Codec;

function Codec(opts){
  this.opts = opts || {};
  this.encodings = encodings;
}

Codec.prototype._encoding = function(encoding){
  if (typeof encoding == 'string') encoding = encodings[encoding];
  if (!encoding) encoding = encodings.id;
  return encoding;
};

Codec.prototype._keyEncoding = function(opts, batchOpts){
  return this._encoding(batchOpts && batchOpts.keyEncoding
    || opts && opts.keyEncoding
    || this.opts.keyEncoding);
};

Codec.prototype._valueEncoding = function(opts, batchOpts){
  return this._encoding(
    batchOpts && (batchOpts.valueEncoding || batchOpts.encoding)
    || opts && (opts.valueEncoding || opts.encoding)
    || (this.opts.valueEncoding || this.opts.encoding));
};

Codec.prototype.encodeKey = function(key, opts, batchOpts){
  return this._keyEncoding(opts, batchOpts).encode(key);
};

Codec.prototype.encodeValue = function(value, opts, batchOpts){
  return this._valueEncoding(opts, batchOpts).encode(value);
};

Codec.prototype.decodeKey = function(key, opts){
  return this._keyEncoding(opts).decode(key);
};

Codec.prototype.decodeValue = function(value, opts){
  return this._valueEncoding(opts).decode(value);
};

Codec.prototype.encodeBatch = function(ops, opts){
  var self = this;

  return ops.map(function(_op){
    var op = {
      type: _op.type,
      key: self.encodeKey(_op.key, opts, _op)
    };
    if (self.keyAsBuffer(opts, _op)) op.keyEncoding = 'binary';
    if (_op.prefix) op.prefix = _op.prefix;
    if ('value' in _op) {
      op.value = self.encodeValue(_op.value, opts, _op);
      if (self.valueAsBuffer(opts, _op)) op.valueEncoding = 'binary';
    }
    return op;
  });
};

var ltgtKeys = ['lt', 'gt', 'lte', 'gte', 'start', 'end'];

Codec.prototype.encodeLtgt = function(ltgt){
  var self = this;
  var ret = {};
  Object.keys(ltgt).forEach(function(key){
    ret[key] = ltgtKeys.indexOf(key) > -1
      ? self.encodeKey(ltgt[key], ltgt)
      : ltgt[key]
  });
  return ret;
};

Codec.prototype.createStreamDecoder = function(opts){
  var self = this;

  if (opts.keys && opts.values) {
    return function(key, value){
      return {
        key: self.decodeKey(key, opts),
        value: self.decodeValue(value, opts)
      };
    };
  } else if (opts.keys) {
    return function(key) {
      return self.decodeKey(key, opts);
    }; 
  } else if (opts.values) {
    return function(_, value){
      return self.decodeValue(value, opts);
    }
  } else {
    return function(){};
  }
};

Codec.prototype.keyAsBuffer = function(opts){
  return this._keyEncoding(opts).buffer;
};

Codec.prototype.valueAsBuffer = function(opts){
  return this._valueEncoding(opts).buffer;
};


},{"./lib/encodings":32}],32:[function(require,module,exports){
(function (Buffer){

exports.utf8 = exports['utf-8'] = {
  encode: function(data){
    return isBinary(data)
      ? data
      : String(data);
  },
  decode: function(data){
    return typeof data === 'string'
      ? data
      : String(data)
  },
  buffer: false,
  type: 'utf8'
};

exports.json = {
  encode: JSON.stringify,
  decode: JSON.parse,
  buffer: false,
  type: 'json'
};

exports.binary = {
  encode: function(data){
    return isBinary(data)
      ? data
      : new Buffer(data);      
  },
  decode: identity,
  buffer: true,
  type: 'binary'
};

exports.none = {
  encode: function(data){
    return data;
  },
  decode: function(data){
    return data;
  },
  buffer: false,
  type: 'id'
};

exports.id = exports.none;

var bufferEncodings = [
  'hex',
  'ascii',
  'base64',
  'ucs2',
  'ucs-2',
  'utf16le',
  'utf-16le'
];

bufferEncodings.forEach(function(type){
  exports[type] = {
    encode: function(data){
      return isBinary(data)
        ? data
        : new Buffer(data, type);
    },
    decode: function(buffer){
      return buffer.toString(type);
    },
    buffer: true,
    type: type
  };
});

function identity(value){
  return value;
}

function isBinary(data){
  return data === undefined
    || data === null
    || Buffer.isBuffer(data);
}


}).call(this,require("buffer").Buffer)
},{"buffer":5}],33:[function(require,module,exports){
/* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var createError   = require('errno').create
  , LevelUPError  = createError('LevelUPError')
  , NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status   = 404

module.exports = {
    LevelUPError        : LevelUPError
  , InitializationError : createError('InitializationError', LevelUPError)
  , OpenError           : createError('OpenError', LevelUPError)
  , ReadError           : createError('ReadError', LevelUPError)
  , WriteError          : createError('WriteError', LevelUPError)
  , NotFoundError       : NotFoundError
  , EncodingError       : createError('EncodingError', LevelUPError)
}

},{"errno":16}],34:[function(require,module,exports){
var inherits = require('inherits');
var Readable = require('readable-stream').Readable;
var extend = require('xtend');
var EncodingError = require('level-errors').EncodingError;

module.exports = ReadStream;
inherits(ReadStream, Readable);

function ReadStream(iterator, options){
  if (!(this instanceof ReadStream)) return new ReadStream(iterator, options);
  Readable.call(this, extend(options, {
    objectMode: true
  }));
  this._iterator = iterator;
  this._destroyed = false;
  this._decoder = null;
  if (options && options.decoder) this._decoder = options.decoder;
  this.on('end', this._cleanup.bind(this));
}

ReadStream.prototype._read = function(){
  var self = this;
  if (this._destroyed) return;

  this._iterator.next(function(err, key, value){
    if (self._destroyed) return;
    if (err) return self.emit('error', err);
    if (key === undefined && value === undefined) {
      self.push(null);
    } else {
      if (!self._decoder) return self.push({ key: key, value: value });

      try {
        var value = self._decoder(key, value);
      } catch (err) {
        self.emit('error', new EncodingError(err));
        self.push(null);
        return;
      }
      self.push(value);
    }
  });
};

ReadStream.prototype.destroy =
ReadStream.prototype._cleanup = function(){
  var self = this;
  if (this._destroyed) return;
  this._destroyed = true;

  this._iterator.end(function(err){
    if (err) return self.emit('error', err);
    self.emit('close');
  });
};


},{"inherits":24,"level-errors":33,"readable-stream":78,"xtend":120}],35:[function(require,module,exports){
/* Copyright (c) 2012-2016 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var util          = require('./util')
  , WriteError    = require('level-errors').WriteError

  , getOptions    = util.getOptions
  , dispatchError = util.dispatchError

function Batch (levelup, codec) {
  this._levelup = levelup
  this._codec = codec
  this.batch = levelup.db.batch()
  this.ops = []
  this.length = 0
}

Batch.prototype.put = function (key_, value_, options) {
  options = getOptions(options)

  var key   = this._codec.encodeKey(key_, options)
    , value = this._codec.encodeValue(value_, options)

  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }
  this.ops.push({ type : 'put', key : key, value : value })
  this.length++

  return this
}

Batch.prototype.del = function (key_, options) {
  options = getOptions(options)

  var key = this._codec.encodeKey(key_, options)

  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }
  this.ops.push({ type : 'del', key : key })
  this.length++

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  this.length = 0
  return this
}

Batch.prototype.write = function (callback) {
  var levelup = this._levelup
    , ops     = this.ops

  try {
    this.batch.write(function (err) {
      if (err)
        return dispatchError(levelup, new WriteError(err), callback)
      levelup.emit('batch', ops)
      if (callback)
        callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }
}

module.exports = Batch

},{"./util":37,"level-errors":33}],36:[function(require,module,exports){
(function (process){
/* Copyright (c) 2012-2016 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var EventEmitter        = require('events').EventEmitter
  , inherits            = require('util').inherits
  , deprecate           = require('util').deprecate
  , extend              = require('xtend')
  , prr                 = require('prr')
  , DeferredLevelDOWN   = require('deferred-leveldown')
  , IteratorStream      = require('level-iterator-stream')

  , errors              = require('level-errors')
  , WriteError          = errors.WriteError
  , ReadError           = errors.ReadError
  , NotFoundError       = errors.NotFoundError
  , OpenError           = errors.OpenError
  , EncodingError       = errors.EncodingError
  , InitializationError = errors.InitializationError
  , LevelUPError        = errors.LevelUPError

  , util                = require('./util')
  , Batch               = require('./batch')
  , Codec               = require('level-codec')

  , getOptions          = util.getOptions
  , defaultOptions      = util.defaultOptions
  , getLevelDOWN        = require('./leveldown')
  , dispatchError       = util.dispatchError
  , isDefined           = util.isDefined

function getCallback (options, callback) {
  return typeof options == 'function' ? options : callback
}

// Possible LevelUP#_status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (location, options, callback) {
  if (!(this instanceof LevelUP))
    return new LevelUP(location, options, callback)

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof location == 'function') {
    options = typeof options == 'object' ? options : {}
    options.db = location
    location = null
  } else if (typeof location == 'object' && typeof location.db == 'function') {
    options = location
    location = null
  }


  if (typeof options == 'function') {
    callback = options
    options  = {}
  }

  if ((!options || typeof options.db != 'function') && typeof location != 'string') {
    error = new InitializationError(
        'Must provide a location for the database')
    if (callback) {
      return process.nextTick(function () {
        callback(error)
      })
    }
    throw error
  }

  options      = getOptions(options)
  this.options = extend(defaultOptions, options)
  this._codec = new Codec(this.options)
  this._status = 'new'
  // set this.location as enumerable but not configurable or writable
  prr(this, 'location', location, 'e')

  this.open(callback)
}

inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (callback) {
  var self = this
    , dbFactory
    , db

  if (this.isOpen()) {
    if (callback)
      process.nextTick(function () { callback(null, self) })
    return this
  }

  if (this._isOpening()) {
    return callback && this.once(
        'open'
      , function () { callback(null, self) }
    )
  }

  this.emit('opening')
  this._status = 'opening'
  this.db      = new DeferredLevelDOWN(this.location)

  if (typeof this.options.db !== 'function' &&
      typeof getLevelDOWN !== 'function') {
    throw new LevelUPError('missing db factory, you need to set options.db')
  }

  dbFactory = this.options.db || getLevelDOWN()
  db = dbFactory(this.location)

  db.open(this.options, function (err) {
    if (err) {
      return dispatchError(self, new OpenError(err), callback)
    } else {
      self.db.setDb(db)
      self.db = db
      self._status = 'open'
      if (callback)
        callback(null, self)
      self.emit('open')
      self.emit('ready')
    }
  })
}

LevelUP.prototype.close = function (callback) {
  var self = this

  if (this.isOpen()) {
    this._status = 'closing'
    this.db.close(function () {
      self._status = 'closed'
      self.emit('closed')
      if (callback)
        callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = new DeferredLevelDOWN(this.location)
  } else if (this._status == 'closed' && callback) {
    return process.nextTick(callback)
  } else if (this._status == 'closing' && callback) {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }
}

LevelUP.prototype.isOpen = function () {
  return this._status == 'open'
}

LevelUP.prototype._isOpening = function () {
  return this._status == 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos/).test(this._status)
}

function maybeError(db, options, callback) {
  if (!db._isOpening() && !db.isOpen()) {
    dispatchError(
        db
      , new ReadError('Database is not open')
      , callback
    )
    return true
  }
}

function writeError (db, message, callback) {
  dispatchError(
      db
     , new WriteError(message)
     , callback
  )
}

function readError (db, message, callback) {
  dispatchError(
      db
     , new ReadError(message)
     , callback
  )
}


LevelUP.prototype.get = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (maybeError(this, options, callback))
    return

  if (key_ === null || key_ === undefined || 'function' !== typeof callback)
    return readError(this
      , 'get() requires key and callback arguments', callback)

  options = util.getOptions(options)
  key = this._codec.encodeKey(key_, options)

  options.asBuffer = this._codec.valueAsBuffer(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err) || err.notFound) {
        err = new NotFoundError(
            'Key not found in database [' + key_ + ']', err)
      } else {
        err = new ReadError(err)
      }
      return dispatchError(self, err, callback)
    }
    if (callback) {
      try {
        value = self._codec.decodeValue(value, options)
      } catch (e) {
        return callback(new EncodingError(e))
      }
      callback(null, value)
    }
  })
}

LevelUP.prototype.put = function (key_, value_, options, callback) {
  var self = this
    , key
    , value

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined)
    return writeError(this, 'put() requires a key argument', callback)

  if (maybeError(this, options, callback))
    return

  options = getOptions(options)
  key     = this._codec.encodeKey(key_, options)
  value   = this._codec.encodeValue(value_, options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('put', key_, value_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.del = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined)
    return writeError(this, 'del() requires a key argument', callback)

  if (maybeError(this, options, callback))
    return

  options = getOptions(options)
  key     = this._codec.encodeKey(key_, options)

  this.db.del(key, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('del', key_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.batch = function (arr_, options, callback) {
  var self = this
    , keyEnc
    , valueEnc
    , arr

  if (!arguments.length)
    return new Batch(this, this._codec)

  callback = getCallback(options, callback)

  if (!Array.isArray(arr_))
    return writeError(this, 'batch() requires an array argument', callback)

  if (maybeError(this, options, callback))
    return

  options  = getOptions(options)
  arr      = self._codec.encodeBatch(arr_, options)
  arr      = arr.map(function (op) {
    if (!op.type && op.key !== undefined && op.value !== undefined)
      op.type = 'put'
    return op
  })

  this.db.batch(arr, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('batch', arr_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {   
  var self = this    
    , start    
    , end    
   
  callback = getCallback(options, callback)    
   
  options = getOptions(options)    
   
  if (start_ === null || start_ === undefined    
        || end_ === null || end_ === undefined || 'function' !== typeof callback)    
    return readError(this, 'approximateSize() requires start, end and callback arguments', callback)   
   
  start = this._codec.encodeKey(start_, options)   
  end   = this._codec.encodeKey(end_, options)   
   
  this.db.approximateSize(start, end, function (err, size) {   
    if (err) {   
      return dispatchError(self, new OpenError(err), callback)   
    } else if (callback) {   
      callback(null, size)   
    }    
  })   
}, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead')

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  options = extend( {keys: true, values: true}, this.options, options)

  options.keyEncoding   = options.keyEncoding
  options.valueEncoding = options.valueEncoding

  options = this._codec.encodeLtgt(options);
  options.keyAsBuffer   = this._codec.keyAsBuffer(options)
  options.valueAsBuffer = this._codec.valueAsBuffer(options)

  if ('number' !== typeof options.limit)
    options.limit = -1

  return new IteratorStream(this.db.iterator(options), extend(options, {
    decoder: this._codec.createStreamDecoder(options)
  }))
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function utilStatic (name) {
  return function (location, callback) {
    getLevelDOWN()[name](location, callback || function () {})
  }
}

module.exports         = LevelUP
module.exports.errors  = require('level-errors')
module.exports.destroy = deprecate(
    utilStatic('destroy')
  , 'levelup.destroy() is deprecated. Use leveldown.destroy() instead'
)
module.exports.repair  = deprecate(
    utilStatic('repair')
  , 'levelup.repair() is deprecated. Use leveldown.repair() instead'
)


}).call(this,require('_process'))
},{"./batch":35,"./leveldown":3,"./util":37,"_process":70,"deferred-leveldown":8,"events":18,"level-codec":38,"level-errors":33,"level-iterator-stream":34,"prr":71,"util":114,"xtend":120}],37:[function(require,module,exports){
/* Copyright (c) 2012-2016 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var extend         = require('xtend')
  , defaultOptions = {
        createIfMissing : true
      , errorIfExists   : false
      , keyEncoding     : 'utf8'
      , valueEncoding   : 'utf8'
      , compression     : true
    }

function getOptions (options) {
  if (typeof options == 'string')
    options = { valueEncoding: options }
  if (typeof options != 'object')
    options = {}
  return options
}

function dispatchError (db, error, callback) {
  typeof callback == 'function' ? callback(error) : db.emit('error', error)
}

function isDefined (v) {
  return typeof v !== 'undefined'
}

module.exports = {
    defaultOptions  : defaultOptions
  , getOptions      : getOptions
  , dispatchError   : dispatchError
  , isDefined       : isDefined
}

},{"xtend":120}],38:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./lib/encodings":39,"dup":31}],39:[function(require,module,exports){
(function (Buffer){

exports.utf8 = exports['utf-8'] = {
  encode: function(data){
    return isBinary(data)
      ? data
      : String(data);
  },
  decode: identity,
  buffer: false,
  type: 'utf8'
};

exports.json = {
  encode: JSON.stringify,
  decode: JSON.parse,
  buffer: false,
  type: 'json'
};

exports.binary = {
  encode: function(data){
    return isBinary(data)
      ? data
      : new Buffer(data);      
  },
  decode: identity,
  buffer: true,
  type: 'binary'
};

exports.id = {
  encode: function(data){
    return data;
  },
  decode: function(data){
    return data;
  },
  buffer: false,
  type: 'id'
};

var bufferEncodings = [
  'hex',
  'ascii',
  'base64',
  'ucs2',
  'ucs-2',
  'utf16le',
  'utf-16le'
];

bufferEncodings.forEach(function(type){
  exports[type] = {
    encode: function(data){
      return isBinary(data)
        ? data
        : new Buffer(data, type);
    },
    decode: function(buffer){
      return buffer.toString(type);
    },
    buffer: true,
    type: type
  };
});

function identity(value){
  return value;
}

function isBinary(data){
  return data === undefined
    || data === null
    || Buffer.isBuffer(data);
}


}).call(this,require("buffer").Buffer)
},{"buffer":5}],40:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":23}],41:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],42:[function(require,module,exports){
(function (Buffer){

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key)
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range, def) {
  var k = lowerBoundKey(range)
  return k ? range[k] : def
}

var lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

var upperBoundInclusive = exports.upperBoundInclusive =
  function (range) {
    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return !lowerBoundInclusive(range)
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return !upperBoundInclusive(range)
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range, def) {
  var k = upperBoundKey(range)
  return k ? range[k] : def
}

exports.start = function (range, def) {
  return range.reverse ? upperBound(range, def) : lowerBound(range, def)
}
exports.end = function (range, def) {
  return range.reverse ? lowerBound(range, def) : upperBound(range, def)
}
exports.startInclusive = function (range) {
  return (
    range.reverse
  ? upperBoundInclusive(range)
  : lowerBoundInclusive(range)
  )
}
exports.endInclusive = function (range) {
  return (
    range.reverse
  ? lowerBoundInclusive(range)
  : upperBoundInclusive(range)
  )
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt, false)
    else            _range.gte = map(range[lb], false)
  }
  else if(defaults)
    _range.gte = map(lower, false)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt, true)
    else            _range.lte = map(range[ub], true)
  }
  else if(defaults)
    _range.lte = map(upper, true)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  //if range was used mutably
  //(in level-sublevel it's part of an options object
  //that has more properties on it.)
  if(has(_range, 'max'))   delete _range.max
  if(has(_range, 'min'))   delete _range.min
  if(has(_range, 'start')) delete _range.start
  if(has(_range, 'end'))   delete _range.end

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}



}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":26}],43:[function(require,module,exports){
module.exports = require('immediate')

},{"immediate":50}],44:[function(require,module,exports){
(function (Buffer){
var inherits          = require('inherits')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
  , AbstractIterator  = require('abstract-leveldown').AbstractIterator
  , ltgt              = require('ltgt')
  , createRBT = require('functional-red-black-tree')
  , globalStore       = {}

// In Node, use global.setImmediate. In the browser, use a consistent
// microtask library to give consistent microtask experience to all browsers
var setImmediate = require('./immediate')

function gt(value) {
  return ltgt.compare(value, this._end) > 0
}

function gte(value) {
  return ltgt.compare(value, this._end) >= 0
}

function lt(value) {
  return ltgt.compare(value, this._end) < 0
}

function lte(value) {
  return ltgt.compare(value, this._end) <= 0
}


function MemIterator (db, options) {
  AbstractIterator.call(this, db)
  this._limit   = options.limit

  if (this._limit === -1)
    this._limit = Infinity

  var tree = db._store[db._location]

  this.keyAsBuffer = options.keyAsBuffer !== false
  this.valueAsBuffer = options.valueAsBuffer !== false
  this._reverse   = options.reverse
  this._options = options
  this._done = 0

  if (!this._reverse) {
    this._incr = 'next'
    this._start = ltgt.lowerBound(options)
    this._end = ltgt.upperBound(options)

    if (typeof this._start === 'undefined')
      this._tree = tree.begin
    else if (ltgt.lowerBoundInclusive(options))
      this._tree = tree.ge(this._start)
    else
      this._tree = tree.gt(this._start)

    if (this._end) {
      if (ltgt.upperBoundInclusive(options))
        this._test = lte
      else
        this._test = lt
    }

  } else {
    this._incr = 'prev'
    this._start = ltgt.upperBound(options)
    this._end = ltgt.lowerBound(options)

    if (typeof this._start === 'undefined')
      this._tree = tree.end
    else if (ltgt.upperBoundInclusive(options))
      this._tree = tree.le(this._start)
    else
      this._tree = tree.lt(this._start)

    if (this._end) {
      if (ltgt.lowerBoundInclusive(options))
        this._test = gte
      else
        this._test = gt
    }

  }

}

inherits(MemIterator, AbstractIterator)

MemIterator.prototype._next = function (callback) {
  var key
    , value

  if (this._done++ >= this._limit)
    return setImmediate(callback)

  if (!this._tree.valid)
    return setImmediate(callback)

  key = this._tree.key
  value = this._tree.value

  if (!this._test(key))
    return setImmediate(callback)

  if (this.keyAsBuffer)
    key = new Buffer(key)

  if (this.valueAsBuffer)
    value = new Buffer(value)

  this._tree[this._incr]()

  setImmediate(function callNext() {
    callback(null, key, value)
  })
}

MemIterator.prototype._test = function () {return true}

function MemDOWN (location) {
  if (!(this instanceof MemDOWN))
    return new MemDOWN(location)

  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '')

  this._location = this.location ? ('$' + this.location) : '_tree'
  this._store = this.location ? globalStore: this
  this._store[this._location] = this._store[this._location] || createRBT(ltgt.compare)
}

MemDOWN.clearGlobalStore = function (strict) {
  if (strict) {
    Object.keys(globalStore).forEach(function (key) {
      delete globalStore[key]
    })
  } else {
    globalStore = {}
  }
}

inherits(MemDOWN, AbstractLevelDOWN)

MemDOWN.prototype._open = function (options, callback) {
  var self = this
  setImmediate(function callNext() { callback(null, self) })
}

MemDOWN.prototype._put = function (key, value, options, callback) {
  if (typeof value === 'undefined' || value === null) value = ''

  var iter = this._store[this._location].find(key)

  if (iter.valid) {
    this._store[this._location] = iter.update(value)
  } else {
    this._store[this._location] = this._store[this._location].insert(key, value)
  }

  setImmediate(callback)
}

MemDOWN.prototype._get = function (key, options, callback) {
  var value = this._store[this._location].get(key)

  if (typeof value === 'undefined') {
    // 'NotFound' error, consistent with LevelDOWN API
    return setImmediate(function callNext() { callback(new Error('NotFound')) })
  }

  if (options.asBuffer !== false && !this._isBuffer(value))
    value = new Buffer(String(value))

  setImmediate(function callNext () {
    callback(null, value)
  })

}

MemDOWN.prototype._del = function (key, options, callback) {
  this._store[this._location] = this._store[this._location].remove(key)
  setImmediate(callback)
}

MemDOWN.prototype._batch = function (array, options, callback) {
  var i = -1
    , key
    , value
    , iter
    , len = array.length
    , tree = this._store[this._location]

  while (++i < len) {
    if (!array[i])
      continue

    key = this._isBuffer(array[i].key) ? array[i].key : String(array[i].key)
    iter = tree.find(key)

    if (array[i].type === 'put') {
      value = this._isBuffer(array[i].value) ? array[i].value : String(array[i].value)
      tree = iter.valid ? iter.update(value) : tree.insert(key, value)
    } else {
      tree = iter.remove()
    }
  }

  this._store[this._location] = tree

  setImmediate(callback)
}

MemDOWN.prototype._iterator = function (options) {
  return new MemIterator(this, options)
}

MemDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

MemDOWN.destroy = function (name, callback) {
  var key = '$' + name

  if (key in globalStore)
    delete globalStore[key]

  setImmediate(callback)
}

module.exports = MemDOWN

}).call(this,require("buffer").Buffer)
},{"./immediate":43,"abstract-leveldown":48,"buffer":5,"functional-red-black-tree":19,"inherits":24,"ltgt":56}],45:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"_process":70,"dup":9}],46:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"_process":70,"dup":10}],47:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"../../../is-buffer/index.js":26,"./abstract-chained-batch":45,"./abstract-iterator":46,"_process":70,"dup":11,"xtend":120}],48:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./abstract-chained-batch":45,"./abstract-iterator":46,"./abstract-leveldown":47,"./is-leveldown":49,"dup":12}],49:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./abstract-leveldown":47,"dup":13}],50:[function(require,module,exports){
'use strict';
var types = [
  require('./nextTick'),
  require('./mutation.js'),
  require('./messageChannel'),
  require('./stateChange'),
  require('./timeout')
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}

},{"./messageChannel":51,"./mutation.js":52,"./nextTick":53,"./stateChange":54,"./timeout":55}],51:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],52:[function(require,module,exports){
(function (global){
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],53:[function(require,module,exports){
(function (process){
'use strict';
exports.test = function () {
  // Don't get fooled by e.g. browserify environments.
  return (typeof process !== 'undefined') && !process.browser;
};

exports.install = function (func) {
  return function () {
    process.nextTick(func);
  };
};

}).call(this,require('_process'))
},{"_process":70}],54:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],55:[function(require,module,exports){
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
},{}],56:[function(require,module,exports){
(function (Buffer){

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key)
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range) {
  var k = lowerBoundKey(range)
  return k && range[k]
}

var lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

var upperBoundInclusive = exports.upperBoundInclusive =
  function (range) {
    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return !lowerBoundInclusive(range)
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return !upperBoundInclusive(range)
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range) {
  var k = upperBoundKey(range)
  return k && range[k]
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt, false)
    else            _range.gte = map(range[lb], false)
  }
  else if(defaults)
    _range.gte = map(lower, false)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt, true)
    else            _range.lte = map(range[ub], true)
  }
  else if(defaults)
    _range.lte = map(upper, true)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  //if range was used mutably
  //(in level-sublevel it's part of an options object
  //that has more properties on it.)
  if(has(_range, 'max'))   delete _range.max
  if(has(_range, 'min'))   delete _range.min
  if(has(_range, 'start')) delete _range.start
  if(has(_range, 'end'))   delete _range.end

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}






}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})
},{"../../../is-buffer/index.js":26}],57:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pouchdbCollections = require('pouchdb-collections');
var Promise = _interopDefault(require('pouchdb-promise'));
var levelup = _interopDefault(require('levelup'));
var sublevel = _interopDefault(require('sublevel-pouchdb'));
var through2 = require('through2');
var getArguments = _interopDefault(require('argsarray'));
var Deque = _interopDefault(require('double-ended-queue'));
var bufferFrom = _interopDefault(require('buffer-from'));
var pouchdbUtils = require('pouchdb-utils');
var pouchdbAdapterUtils = require('pouchdb-adapter-utils');
var pouchdbMerge = require('pouchdb-merge');
var pouchdbJson = require('pouchdb-json');
var pouchdbMd5 = require('pouchdb-md5');
var pouchdbBinaryUtils = require('pouchdb-binary-utils');
var pouchdbErrors = require('pouchdb-errors');

function readAsBlobOrBuffer(storedObject, type) {
  // In the browser, we've stored a binary string. This now comes back as a
  // browserified Node-style Buffer (implemented as a typed array),
  // but we want a Blob instead.
  var byteArray = new Uint8Array(storedObject);
  return pouchdbBinaryUtils.blob([byteArray], {type: type});
}

// In the browser, we store a binary string
function prepareAttachmentForStorage(attData, cb) {
  pouchdbBinaryUtils.readAsBinaryString(attData, cb);
}

function createEmptyBlobOrBuffer(type) {
  return pouchdbBinaryUtils.blob([''], {type: type});
}

// similar to an idb or websql transaction object
// designed to be passed around. basically just caches
// things in-memory and then does a big batch() operation
// when you're done

function getCacheFor(transaction, store) {
  var prefix = store.prefix()[0];
  var cache = transaction._cache;
  var subCache = cache.get(prefix);
  if (!subCache) {
    subCache = new pouchdbCollections.Map();
    cache.set(prefix, subCache);
  }
  return subCache;
}

function LevelTransaction() {
  this._batch = [];
  this._cache = new pouchdbCollections.Map();
}

LevelTransaction.prototype.get = function (store, key, callback) {
  var cache = getCacheFor(this, store);
  var exists = cache.get(key);
  if (exists) {
    return pouchdbUtils.nextTick(function () {
      callback(null, exists);
    });
  } else if (exists === null) { // deleted marker
    /* istanbul ignore next */
    return pouchdbUtils.nextTick(function () {
      callback({name: 'NotFoundError'});
    });
  }
  store.get(key, function (err, res) {
    if (err) {
      /* istanbul ignore else */
      if (err.name === 'NotFoundError') {
        cache.set(key, null);
      }
      return callback(err);
    }
    cache.set(key, res);
    callback(null, res);
  });
};

LevelTransaction.prototype.batch = function (batch) {
  for (var i = 0, len = batch.length; i < len; i++) {
    var operation = batch[i];

    var cache = getCacheFor(this, operation.prefix);

    if (operation.type === 'put') {
      cache.set(operation.key, operation.value);
    } else {
      cache.set(operation.key, null);
    }
  }
  this._batch = this._batch.concat(batch);
};

LevelTransaction.prototype.execute = function (db, callback) {

  var keys = new pouchdbCollections.Set();
  var uniqBatches = [];

  // remove duplicates; last one wins
  for (var i = this._batch.length - 1; i >= 0; i--) {
    var operation = this._batch[i];
    var lookupKey = operation.prefix.prefix()[0] + '\xff' + operation.key;
    if (keys.has(lookupKey)) {
      continue;
    }
    keys.add(lookupKey);
    uniqBatches.push(operation);
  }

  db.batch(uniqBatches, callback);
};

var DOC_STORE = 'document-store';
var BY_SEQ_STORE = 'by-sequence';
var ATTACHMENT_STORE = 'attach-store';
var BINARY_STORE = 'attach-binary-store';
var LOCAL_STORE = 'local-store';
var META_STORE = 'meta-store';

// leveldb barks if we try to open a db multiple times
// so we cache opened connections here for initstore()
var dbStores = new pouchdbCollections.Map();

// store the value of update_seq in the by-sequence store the key name will
// never conflict, since the keys in the by-sequence store are integers
var UPDATE_SEQ_KEY = '_local_last_update_seq';
var DOC_COUNT_KEY = '_local_doc_count';
var UUID_KEY = '_local_uuid';

var MD5_PREFIX = 'md5-';

var safeJsonEncoding = {
  encode: pouchdbJson.safeJsonStringify,
  decode: pouchdbJson.safeJsonParse,
  buffer: false,
  type: 'cheap-json'
};

var levelChanges = new pouchdbUtils.changesHandler();

// winningRev and deleted are performance-killers, but
// in newer versions of PouchDB, they are cached on the metadata
function getWinningRev(metadata) {
  return 'winningRev' in metadata ?
    metadata.winningRev : pouchdbMerge.winningRev(metadata);
}

function getIsDeleted(metadata, winningRev$$1) {
  return 'deleted' in metadata ?
    metadata.deleted : pouchdbAdapterUtils.isDeleted(metadata, winningRev$$1);
}

function fetchAttachment(att, stores, opts) {
  var type = att.content_type;
  return new Promise(function (resolve, reject) {
    stores.binaryStore.get(att.digest, function (err, buffer) {
      var data;
      if (err) {
        /* istanbul ignore if */
        if (err.name !== 'NotFoundError') {
          return reject(err);
        } else {
          // empty
          if (!opts.binary) {
            data = '';
          } else {
            data = pouchdbBinaryUtils.binaryStringToBlobOrBuffer('', type);
          }
        }
      } else { // non-empty
        if (opts.binary) {
          data = readAsBlobOrBuffer(buffer, type);
        } else {
          data = buffer.toString('base64');
        }
      }
      delete att.stub;
      delete att.length;
      att.data = data;
      resolve();
    });
  });
}

function fetchAttachments(results, stores, opts) {
  var atts = [];
  results.forEach(function (row) {
    if (!(row.doc && row.doc._attachments)) {
      return;
    }
    var attNames = Object.keys(row.doc._attachments);
    attNames.forEach(function (attName) {
      var att = row.doc._attachments[attName];
      if (!('data' in att)) {
        atts.push(att);
      }
    });
  });

  return Promise.all(atts.map(function (att) {
    return fetchAttachment(att, stores, opts);
  }));
}

function LevelPouch(opts, callback) {
  opts = pouchdbUtils.clone(opts);
  var api = this;
  var instanceId;
  var stores = {};
  var revLimit = opts.revs_limit;
  var db;
  var name = opts.name;
  // TODO: this is undocumented and unused probably
  /* istanbul ignore else */
  if (typeof opts.createIfMissing === 'undefined') {
    opts.createIfMissing = true;
  }

  var leveldown = opts.db;

  var dbStore;
  var leveldownName = pouchdbUtils.functionName(leveldown);
  if (dbStores.has(leveldownName)) {
    dbStore = dbStores.get(leveldownName);
  } else {
    dbStore = new pouchdbCollections.Map();
    dbStores.set(leveldownName, dbStore);
  }
  if (dbStore.has(name)) {
    db = dbStore.get(name);
    afterDBCreated();
  } else {
    dbStore.set(name, sublevel(levelup(name, opts, function (err) {
      /* istanbul ignore if */
      if (err) {
        dbStore.delete(name);
        return callback(err);
      }
      db = dbStore.get(name);
      db._docCount  = -1;
      db._queue = new Deque();
      /* istanbul ignore else */
      if (typeof opts.migrate === 'object') { // migration for leveldown
        opts.migrate.doMigrationOne(name, db, afterDBCreated);
      } else {
        afterDBCreated();
      }
    })));
  }

  function afterDBCreated() {
    stores.docStore = db.sublevel(DOC_STORE, {valueEncoding: safeJsonEncoding});
    stores.bySeqStore = db.sublevel(BY_SEQ_STORE, {valueEncoding: 'json'});
    stores.attachmentStore =
      db.sublevel(ATTACHMENT_STORE, {valueEncoding: 'json'});
    stores.binaryStore = db.sublevel(BINARY_STORE, {valueEncoding: 'binary'});
    stores.localStore = db.sublevel(LOCAL_STORE, {valueEncoding: 'json'});
    stores.metaStore = db.sublevel(META_STORE, {valueEncoding: 'json'});
    /* istanbul ignore else */
    if (typeof opts.migrate === 'object') { // migration for leveldown
      opts.migrate.doMigrationTwo(db, stores, afterLastMigration);
    } else {
      afterLastMigration();
    }
  }

  function afterLastMigration() {
    stores.metaStore.get(UPDATE_SEQ_KEY, function (err, value) {
      if (typeof db._updateSeq === 'undefined') {
        db._updateSeq = value || 0;
      }
      stores.metaStore.get(DOC_COUNT_KEY, function (err, value) {
        db._docCount = !err ? value : 0;
        stores.metaStore.get(UUID_KEY, function (err, value) {
          instanceId = !err ? value : pouchdbUtils.uuid();
          stores.metaStore.put(UUID_KEY, instanceId, function () {
            pouchdbUtils.nextTick(function () {
              callback(null, api);
            });
          });
        });
      });
    });
  }

  function countDocs(callback) {
    /* istanbul ignore if */
    if (db.isClosed()) {
      return callback(new Error('database is closed'));
    }
    return callback(null, db._docCount); // use cached value
  }

  api._remote = false;
  /* istanbul ignore next */
  api.type = function () {
    return 'leveldb';
  };

  api._id = function (callback) {
    callback(null, instanceId);
  };

  api._info = function (callback) {
    var res = {
      doc_count: db._docCount,
      update_seq: db._updateSeq,
      backend_adapter: pouchdbUtils.functionName(leveldown)
    };
    return pouchdbUtils.nextTick(function () {
      callback(null, res);
    });
  };

  function tryCode(fun, args) {
    try {
      fun.apply(null, args);
    } catch (err) {
      args[args.length - 1](err);
    }
  }

  function executeNext() {
    var firstTask = db._queue.peekFront();

    if (firstTask.type === 'read') {
      runReadOperation(firstTask);
    } else { // write, only do one at a time
      runWriteOperation(firstTask);
    }
  }

  function runReadOperation(firstTask) {
    // do multiple reads at once simultaneously, because it's safe

    var readTasks = [firstTask];
    var i = 1;
    var nextTask = db._queue.get(i);
    while (typeof nextTask !== 'undefined' && nextTask.type === 'read') {
      readTasks.push(nextTask);
      i++;
      nextTask = db._queue.get(i);
    }

    var numDone = 0;

    readTasks.forEach(function (readTask) {
      var args = readTask.args;
      var callback = args[args.length - 1];
      args[args.length - 1] = getArguments(function (cbArgs) {
        callback.apply(null, cbArgs);
        if (++numDone === readTasks.length) {
          pouchdbUtils.nextTick(function () {
            // all read tasks have finished
            readTasks.forEach(function () {
              db._queue.shift();
            });
            if (db._queue.length) {
              executeNext();
            }
          });
        }
      });
      tryCode(readTask.fun, args);
    });
  }

  function runWriteOperation(firstTask) {
    var args = firstTask.args;
    var callback = args[args.length - 1];
    args[args.length - 1] = getArguments(function (cbArgs) {
      callback.apply(null, cbArgs);
      pouchdbUtils.nextTick(function () {
        db._queue.shift();
        if (db._queue.length) {
          executeNext();
        }
      });
    });
    tryCode(firstTask.fun, args);
  }

  // all read/write operations to the database are done in a queue,
  // similar to how websql/idb works. this avoids problems such
  // as e.g. compaction needing to have a lock on the database while
  // it updates stuff. in the future we can revisit this.
  function writeLock(fun) {
    return getArguments(function (args) {
      db._queue.push({
        fun: fun,
        args: args,
        type: 'write'
      });

      if (db._queue.length === 1) {
        pouchdbUtils.nextTick(executeNext);
      }
    });
  }

  // same as the writelock, but multiple can run at once
  function readLock(fun) {
    return getArguments(function (args) {
      db._queue.push({
        fun: fun,
        args: args,
        type: 'read'
      });

      if (db._queue.length === 1) {
        pouchdbUtils.nextTick(executeNext);
      }
    });
  }

  function formatSeq(n) {
    return ('0000000000000000' + n).slice(-16);
  }

  function parseSeq(s) {
    return parseInt(s, 10);
  }

  api._get = readLock(function (id, opts, callback) {
    opts = pouchdbUtils.clone(opts);

    stores.docStore.get(id, function (err, metadata) {

      if (err || !metadata) {
        return callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'missing'));
      }

      var rev;
      if (!opts.rev) {
        rev = getWinningRev(metadata);
        var deleted = getIsDeleted(metadata, rev);
        if (deleted) {
          return callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, "deleted"));
        }
      } else {
        rev = opts.latest ? pouchdbMerge.latest(opts.rev, metadata) : opts.rev;
      }

      var seq = metadata.rev_map[rev];

      stores.bySeqStore.get(formatSeq(seq), function (err, doc) {
        if (!doc) {
          return callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC));
        }
        /* istanbul ignore if */
        if ('_id' in doc && doc._id !== metadata.id) {
          // this failing implies something very wrong
          return callback(new Error('wrong doc returned'));
        }
        doc._id = metadata.id;
        if ('_rev' in doc) {
          /* istanbul ignore if */
          if (doc._rev !== rev) {
            // this failing implies something very wrong
            return callback(new Error('wrong doc returned'));
          }
        } else {
          // we didn't always store this
          doc._rev = rev;
        }
        return callback(null, {doc: doc, metadata: metadata});
      });
    });
  });

  // not technically part of the spec, but if putAttachment has its own
  // method...
  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var digest = attachment.digest;
    var type = attachment.content_type;

    stores.binaryStore.get(digest, function (err, attach) {
      if (err) {
        /* istanbul ignore if */
        if (err.name !== 'NotFoundError') {
          return callback(err);
        }
        // Empty attachment
        return callback(null, opts.binary ? createEmptyBlobOrBuffer(type) : '');
      }

      if (opts.binary) {
        callback(null, readAsBlobOrBuffer(attach, type));
      } else {
        callback(null, attach.toString('base64'));
      }
    });
  };

  api._bulkDocs = writeLock(function (req, opts, callback) {
    var newEdits = opts.new_edits;
    var results = new Array(req.docs.length);
    var fetchedDocs = new pouchdbCollections.Map();
    var stemmedRevs = new pouchdbCollections.Map();

    var txn = new LevelTransaction();
    var docCountDelta = 0;
    var newUpdateSeq = db._updateSeq;

    // parse the docs and give each a sequence number
    var userDocs = req.docs;
    var docInfos = userDocs.map(function (doc) {
      if (doc._id && pouchdbAdapterUtils.isLocalId(doc._id)) {
        return doc;
      }
      var newDoc = pouchdbAdapterUtils.parseDoc(doc, newEdits);

      if (newDoc.metadata && !newDoc.metadata.rev_map) {
        newDoc.metadata.rev_map = {};
      }

      return newDoc;
    });
    var infoErrors = docInfos.filter(function (doc) {
      return doc.error;
    });

    if (infoErrors.length) {
      return callback(infoErrors[0]);
    }

    // verify any stub attachments as a precondition test

    function verifyAttachment(digest, callback) {
      txn.get(stores.attachmentStore, digest, function (levelErr) {
        if (levelErr) {
          var err = pouchdbErrors.createError(pouchdbErrors.MISSING_STUB,
                                'unknown stub attachment with digest ' +
                                digest);
          callback(err);
        } else {
          callback();
        }
      });
    }

    function verifyAttachments(finish) {
      var digests = [];
      userDocs.forEach(function (doc) {
        if (doc && doc._attachments) {
          Object.keys(doc._attachments).forEach(function (filename) {
            var att = doc._attachments[filename];
            if (att.stub) {
              digests.push(att.digest);
            }
          });
        }
      });
      if (!digests.length) {
        return finish();
      }
      var numDone = 0;
      var err;

      digests.forEach(function (digest) {
        verifyAttachment(digest, function (attErr) {
          if (attErr && !err) {
            err = attErr;
          }

          if (++numDone === digests.length) {
            finish(err);
          }
        });
      });
    }

    function fetchExistingDocs(finish) {
      var numDone = 0;
      var overallErr;
      function checkDone() {
        if (++numDone === userDocs.length) {
          return finish(overallErr);
        }
      }

      userDocs.forEach(function (doc) {
        if (doc._id && pouchdbAdapterUtils.isLocalId(doc._id)) {
          // skip local docs
          return checkDone();
        }
        txn.get(stores.docStore, doc._id, function (err, info) {
          if (err) {
            /* istanbul ignore if */
            if (err.name !== 'NotFoundError') {
              overallErr = err;
            }
          } else {
            fetchedDocs.set(doc._id, info);
          }
          checkDone();
        });
      });
    }

    function compact(revsMap, callback) {
      var promise = Promise.resolve();
      revsMap.forEach(function (revs, docId) {
        // TODO: parallelize, for now need to be sequential to
        // pass orphaned attachment tests
        promise = promise.then(function () {
          return new Promise(function (resolve, reject) {
            api._doCompactionNoLock(docId, revs, {ctx: txn}, function (err) {
              /* istanbul ignore if */
              if (err) {
                return reject(err);
              }
              resolve();
            });
          });
        });
      });

      promise.then(function () {
        callback();
      }, callback);
    }

    function autoCompact(callback) {
      var revsMap = new pouchdbCollections.Map();
      fetchedDocs.forEach(function (metadata, docId) {
        revsMap.set(docId, pouchdbMerge.compactTree(metadata));
      });
      compact(revsMap, callback);
    }

    function finish() {
      compact(stemmedRevs, function (error) {
        /* istanbul ignore if */
        if (error) {
          complete(error);
        }
        if (api.auto_compaction) {
          return autoCompact(complete);
        }
        complete();
      });
    }

    function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                      isUpdate, delta, resultsIdx, callback2) {
      docCountDelta += delta;

      var err = null;
      var recv = 0;

      docInfo.metadata.winningRev = winningRev$$1;
      docInfo.metadata.deleted = winningRevIsDeleted;

      docInfo.data._id = docInfo.metadata.id;
      docInfo.data._rev = docInfo.metadata.rev;

      if (newRevIsDeleted) {
        docInfo.data._deleted = true;
      }

      if (docInfo.stemmedRevs.length) {
        stemmedRevs.set(docInfo.metadata.id, docInfo.stemmedRevs);
      }

      var attachments = docInfo.data._attachments ?
        Object.keys(docInfo.data._attachments) :
        [];

      function attachmentSaved(attachmentErr) {
        recv++;
        if (!err) {
          /* istanbul ignore if */
          if (attachmentErr) {
            err = attachmentErr;
            callback2(err);
          } else if (recv === attachments.length) {
            finish();
          }
        }
      }

      function onMD5Load(doc, key, data, attachmentSaved) {
        return function (result) {
          saveAttachment(doc, MD5_PREFIX + result, key, data, attachmentSaved);
        };
      }

      function doMD5(doc, key, attachmentSaved) {
        return function (data) {
          pouchdbMd5.binaryMd5(data, onMD5Load(doc, key, data, attachmentSaved));
        };
      }

      for (var i = 0; i < attachments.length; i++) {
        var key = attachments[i];
        var att = docInfo.data._attachments[key];

        if (att.stub) {
          // still need to update the refs mapping
          var id = docInfo.data._id;
          var rev = docInfo.data._rev;
          saveAttachmentRefs(id, rev, att.digest, attachmentSaved);
          continue;
        }
        var data;
        if (typeof att.data === 'string') {
          // input is assumed to be a base64 string
          try {
            data = pouchdbBinaryUtils.atob(att.data);
          } catch (e) {
            callback(pouchdbErrors.createError(pouchdbErrors.BAD_ARG,
                     'Attachment is not a valid base64 string'));
            return;
          }
          doMD5(docInfo, key, attachmentSaved)(data);
        } else {
          prepareAttachmentForStorage(att.data,
            doMD5(docInfo, key, attachmentSaved));
        }
      }

      function finish() {
        var seq = docInfo.metadata.rev_map[docInfo.metadata.rev];
        /* istanbul ignore if */
        if (seq) {
          // check that there aren't any existing revisions with the same
          // revision id, else we shouldn't do anything
          return callback2();
        }
        seq = ++newUpdateSeq;
        docInfo.metadata.rev_map[docInfo.metadata.rev] =
          docInfo.metadata.seq = seq;
        var seqKey = formatSeq(seq);
        var batch = [{
          key: seqKey,
          value: docInfo.data,
          prefix: stores.bySeqStore,
          type: 'put'
        }, {
          key: docInfo.metadata.id,
          value: docInfo.metadata,
          prefix: stores.docStore,
          type: 'put'
        }];
        txn.batch(batch);
        results[resultsIdx] = {
          ok: true,
          id: docInfo.metadata.id,
          rev: docInfo.metadata.rev
        };
        fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
        callback2();
      }

      if (!attachments.length) {
        finish();
      }
    }

    // attachments are queued per-digest, otherwise the refs could be
    // overwritten by concurrent writes in the same bulkDocs session
    var attachmentQueues = {};

    function saveAttachmentRefs(id, rev, digest, callback) {

      function fetchAtt() {
        return new Promise(function (resolve, reject) {
          txn.get(stores.attachmentStore, digest, function (err, oldAtt) {
            /* istanbul ignore if */
            if (err && err.name !== 'NotFoundError') {
              return reject(err);
            }
            resolve(oldAtt);
          });
        });
      }

      function saveAtt(oldAtt) {
        var ref = [id, rev].join('@');
        var newAtt = {};

        if (oldAtt) {
          if (oldAtt.refs) {
            // only update references if this attachment already has them
            // since we cannot migrate old style attachments here without
            // doing a full db scan for references
            newAtt.refs = oldAtt.refs;
            newAtt.refs[ref] = true;
          }
        } else {
          newAtt.refs = {};
          newAtt.refs[ref] = true;
        }

        return new Promise(function (resolve) {
          txn.batch([{
            type: 'put',
            prefix: stores.attachmentStore,
            key: digest,
            value: newAtt
          }]);
          resolve(!oldAtt);
        });
      }

      // put attachments in a per-digest queue, to avoid two docs with the same
      // attachment overwriting each other
      var queue = attachmentQueues[digest] || Promise.resolve();
      attachmentQueues[digest] = queue.then(function () {
        return fetchAtt().then(saveAtt).then(function (isNewAttachment) {
          callback(null, isNewAttachment);
        }, callback);
      });
    }

    function saveAttachment(docInfo, digest, key, data, callback) {
      var att = docInfo.data._attachments[key];
      delete att.data;
      att.digest = digest;
      att.length = data.length;
      var id = docInfo.metadata.id;
      var rev = docInfo.metadata.rev;
      att.revpos = parseInt(rev, 10);

      saveAttachmentRefs(id, rev, digest, function (err, isNewAttachment) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        // do not try to store empty attachments
        if (data.length === 0) {
          return callback(err);
        }
        if (!isNewAttachment) {
          // small optimization - don't bother writing it again
          return callback(err);
        }
        txn.batch([{
          type: 'put',
          prefix: stores.binaryStore,
          key: digest,
          value: bufferFrom(data, 'binary')
        }]);
        callback();
      });
    }

    function complete(err) {
      /* istanbul ignore if */
      if (err) {
        return pouchdbUtils.nextTick(function () {
          callback(err);
        });
      }
      txn.batch([
        {
          prefix: stores.metaStore,
          type: 'put',
          key: UPDATE_SEQ_KEY,
          value: newUpdateSeq
        },
        {
          prefix: stores.metaStore,
          type: 'put',
          key: DOC_COUNT_KEY,
          value: db._docCount + docCountDelta
        }
      ]);
      txn.execute(db, function (err) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        db._docCount += docCountDelta;
        db._updateSeq = newUpdateSeq;
        levelChanges.notify(name);
        pouchdbUtils.nextTick(function () {
          callback(null, results);
        });
      });
    }

    if (!docInfos.length) {
      return callback(null, []);
    }

    verifyAttachments(function (err) {
      if (err) {
        return callback(err);
      }
      fetchExistingDocs(function (err) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        pouchdbAdapterUtils.processDocs(revLimit, docInfos, api, fetchedDocs, txn, results,
                    writeDoc, opts, finish);
      });
    });
  });
  api._allDocs = readLock(function (opts, callback) {
    opts = pouchdbUtils.clone(opts);
    countDocs(function (err, docCount) {
      /* istanbul ignore if */
      if (err) {
        return callback(err);
      }
      var readstreamOpts = {};
      var skip = opts.skip || 0;
      if (opts.startkey) {
        readstreamOpts.gte = opts.startkey;
      }
      if (opts.endkey) {
        readstreamOpts.lte = opts.endkey;
      }
      if (opts.key) {
        readstreamOpts.gte = readstreamOpts.lte = opts.key;
      }
      if (opts.descending) {
        readstreamOpts.reverse = true;
        // switch start and ends
        var tmp = readstreamOpts.lte;
        readstreamOpts.lte = readstreamOpts.gte;
        readstreamOpts.gte = tmp;
      }
      var limit;
      if (typeof opts.limit === 'number') {
        limit = opts.limit;
      }
      if (limit === 0 ||
          ('start' in readstreamOpts && 'end' in readstreamOpts &&
          readstreamOpts.start > readstreamOpts.end)) {
        // should return 0 results when start is greater than end.
        // normally level would "fix" this for us by reversing the order,
        // so short-circuit instead
        return callback(null, {
          total_rows: docCount,
          offset: opts.skip,
          rows: []
        });
      }
      var results = [];
      var docstream = stores.docStore.readStream(readstreamOpts);

      var throughStream = through2.obj(function (entry, _, next) {
        var metadata = entry.value;
        // winningRev and deleted are performance-killers, but
        // in newer versions of PouchDB, they are cached on the metadata
        var winningRev$$1 = getWinningRev(metadata);
        var deleted = getIsDeleted(metadata, winningRev$$1);
        if (!deleted) {
          if (skip-- > 0) {
            next();
            return;
          } else if (typeof limit === 'number' && limit-- <= 0) {
            docstream.unpipe();
            docstream.destroy();
            next();
            return;
          }
        } else if (opts.deleted !== 'ok') {
          next();
          return;
        }
        function allDocsInner(data) {
          var doc = {
            id: metadata.id,
            key: metadata.id,
            value: {
              rev: winningRev$$1
            }
          };
          if (opts.include_docs) {
            doc.doc = data;
            doc.doc._rev = doc.value.rev;
            if (opts.conflicts) {
              var conflicts = pouchdbMerge.collectConflicts(metadata);
              if (conflicts.length) {
                doc.doc._conflicts = conflicts;
              }
            }
            for (var att in doc.doc._attachments) {
              if (doc.doc._attachments.hasOwnProperty(att)) {
                doc.doc._attachments[att].stub = true;
              }
            }
          }
          if (opts.inclusive_end === false && metadata.id === opts.endkey) {
            return next();
          } else if (deleted) {
            if (opts.deleted === 'ok') {
              doc.value.deleted = true;
              doc.doc = null;
            } else {
              /* istanbul ignore next */
              return next();
            }
          }
          results.push(doc);
          next();
        }
        if (opts.include_docs) {
          var seq = metadata.rev_map[winningRev$$1];
          stores.bySeqStore.get(formatSeq(seq), function (err, data) {
            allDocsInner(data);
          });
        }
        else {
          allDocsInner();
        }
      }, function (next) {
        Promise.resolve().then(function () {
          if (opts.include_docs && opts.attachments) {
            return fetchAttachments(results, stores, opts);
          }
        }).then(function () {
          callback(null, {
            total_rows: docCount,
            offset: opts.skip,
            rows: results
          });
        }, callback);
        next();
      }).on('unpipe', function () {
        throughStream.end();
      });

      docstream.on('error', callback);

      docstream.pipe(throughStream);
    });
  });

  api._changes = function (opts) {
    opts = pouchdbUtils.clone(opts);

    if (opts.continuous) {
      var id = name + ':' + pouchdbUtils.uuid();
      levelChanges.addListener(name, id, api, opts);
      levelChanges.notify(name);
      return {
        cancel: function () {
          levelChanges.removeListener(name, id);
        }
      };
    }

    var descending = opts.descending;
    var results = [];
    var lastSeq = opts.since || 0;
    var called = 0;
    var streamOpts = {
      reverse: descending
    };
    var limit;
    if ('limit' in opts && opts.limit > 0) {
      limit = opts.limit;
    }
    if (!streamOpts.reverse) {
      streamOpts.start = formatSeq(opts.since || 0);
    }

    var docIds = opts.doc_ids && new pouchdbCollections.Set(opts.doc_ids);
    var filter = pouchdbUtils.filterChange(opts);
    var docIdsToMetadata = new pouchdbCollections.Map();

    var returnDocs;
    if ('return_docs' in opts) {
      returnDocs = opts.return_docs;
    } else if ('returnDocs' in opts) {
      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }

    function complete() {
      opts.done = true;
      if (returnDocs && opts.limit) {
        /* istanbul ignore if */
        if (opts.limit < results.length) {
          results.length = opts.limit;
        }
      }
      changeStream.unpipe(throughStream);
      changeStream.destroy();
      if (!opts.continuous && !opts.cancelled) {
        if (opts.include_docs && opts.attachments) {
          fetchAttachments(results, stores, opts).then(function () {
            opts.complete(null, {results: results, last_seq: lastSeq});
          });
        } else {
          opts.complete(null, {results: results, last_seq: lastSeq});
        }
      }
    }
    var changeStream = stores.bySeqStore.readStream(streamOpts);
    var throughStream = through2.obj(function (data, _, next) {
      if (limit && called >= limit) {
        complete();
        return next();
      }
      if (opts.cancelled || opts.done) {
        return next();
      }

      var seq = parseSeq(data.key);
      var doc = data.value;

      if (seq === opts.since && !descending) {
        // couchdb ignores `since` if descending=true
        return next();
      }

      if (docIds && !docIds.has(doc._id)) {
        return next();
      }

      var metadata;

      function onGetMetadata(metadata) {
        var winningRev$$1 = getWinningRev(metadata);

        function onGetWinningDoc(winningDoc) {

          var change = opts.processChange(winningDoc, metadata, opts);
          change.seq = metadata.seq;

          var filtered = filter(change);
          if (typeof filtered === 'object') {
            return opts.complete(filtered);
          }

          if (filtered) {
            called++;

            if (opts.attachments && opts.include_docs) {
              // fetch attachment immediately for the benefit
              // of live listeners
              fetchAttachments([change], stores, opts).then(function () {
                opts.onChange(change);
              });
            } else {
              opts.onChange(change);
            }

            if (returnDocs) {
              results.push(change);
            }
          }
          next();
        }

        if (metadata.seq !== seq) {
          // some other seq is later
          return next();
        }

        lastSeq = seq;

        if (winningRev$$1 === doc._rev) {
          return onGetWinningDoc(doc);
        }

        // fetch the winner

        var winningSeq = metadata.rev_map[winningRev$$1];

        stores.bySeqStore.get(formatSeq(winningSeq), function (err, doc) {
          onGetWinningDoc(doc);
        });
      }

      metadata = docIdsToMetadata.get(doc._id);
      if (metadata) { // cached
        return onGetMetadata(metadata);
      }
      // metadata not cached, have to go fetch it
      stores.docStore.get(doc._id, function (err, metadata) {
        /* istanbul ignore if */
        if (opts.cancelled || opts.done || db.isClosed() ||
          pouchdbAdapterUtils.isLocalId(metadata.id)) {
          return next();
        }
        docIdsToMetadata.set(doc._id, metadata);
        onGetMetadata(metadata);
      });
    }, function (next) {
      if (opts.cancelled) {
        return next();
      }
      if (returnDocs && opts.limit) {
        /* istanbul ignore if */
        if (opts.limit < results.length) {
          results.length = opts.limit;
        }
      }

      next();
    }).on('unpipe', function () {
      throughStream.end();
      complete();
    });
    changeStream.pipe(throughStream);
    return {
      cancel: function () {
        opts.cancelled = true;
        complete();
      }
    };
  };

  api._close = function (callback) {
    /* istanbul ignore if */
    if (db.isClosed()) {
      return callback(pouchdbErrors.createError(pouchdbErrors.NOT_OPEN));
    }
    db.close(function (err) {
      /* istanbul ignore if */
      if (err) {
        callback(err);
      } else {
        dbStore.delete(name);
        callback();
      }
    });
  };

  api._getRevisionTree = function (docId, callback) {
    stores.docStore.get(docId, function (err, metadata) {
      if (err) {
        callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC));
      } else {
        callback(null, metadata.rev_tree);
      }
    });
  };

  api._doCompaction = writeLock(function (docId, revs, opts, callback) {
    api._doCompactionNoLock(docId, revs, opts, callback);
  });

  // the NoLock version is for use by bulkDocs
  api._doCompactionNoLock = function (docId, revs, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    if (!revs.length) {
      return callback();
    }
    var txn = opts.ctx || new LevelTransaction();

    txn.get(stores.docStore, docId, function (err, metadata) {
      /* istanbul ignore if */
      if (err) {
        return callback(err);
      }
      var seqs = revs.map(function (rev) {
        var seq = metadata.rev_map[rev];
        delete metadata.rev_map[rev];
        return seq;
      });
      pouchdbMerge.traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev = pos + '-' + revHash;
        if (revs.indexOf(rev) !== -1) {
          opts.status = 'missing';
        }
      });

      var batch = [];
      batch.push({
        key: metadata.id,
        value: metadata,
        type: 'put',
        prefix: stores.docStore
      });

      var digestMap = {};
      var numDone = 0;
      var overallErr;
      function checkDone(err) {
        /* istanbul ignore if */
        if (err) {
          overallErr = err;
        }
        if (++numDone === revs.length) { // done
          /* istanbul ignore if */
          if (overallErr) {
            return callback(overallErr);
          }
          deleteOrphanedAttachments();
        }
      }

      function finish(err) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        txn.batch(batch);
        if (opts.ctx) {
          // don't execute immediately
          return callback();
        }
        txn.execute(db, callback);
      }

      function deleteOrphanedAttachments() {
        var possiblyOrphanedAttachments = Object.keys(digestMap);
        if (!possiblyOrphanedAttachments.length) {
          return finish();
        }
        var numDone = 0;
        var overallErr;
        function checkDone(err) {
          /* istanbul ignore if */
          if (err) {
            overallErr = err;
          }
          if (++numDone === possiblyOrphanedAttachments.length) {
            finish(overallErr);
          }
        }
        var refsToDelete = new pouchdbCollections.Map();
        revs.forEach(function (rev) {
          refsToDelete.set(docId + '@' + rev, true);
        });
        possiblyOrphanedAttachments.forEach(function (digest) {
          txn.get(stores.attachmentStore, digest, function (err, attData) {
            /* istanbul ignore if */
            if (err) {
              if (err.name === 'NotFoundError') {
                return checkDone();
              } else {
                return checkDone(err);
              }
            }
            var refs = Object.keys(attData.refs || {}).filter(function (ref) {
              return !refsToDelete.has(ref);
            });
            var newRefs = {};
            refs.forEach(function (ref) {
              newRefs[ref] = true;
            });
            if (refs.length) { // not orphaned
              batch.push({
                key: digest,
                type: 'put',
                value: {refs: newRefs},
                prefix: stores.attachmentStore
              });
            } else { // orphaned, can safely delete
              batch = batch.concat([{
                key: digest,
                type: 'del',
                prefix: stores.attachmentStore
              }, {
                key: digest,
                type: 'del',
                prefix: stores.binaryStore
              }]);
            }
            checkDone();
          });
        });
      }

      seqs.forEach(function (seq) {
        batch.push({
          key: formatSeq(seq),
          type: 'del',
          prefix: stores.bySeqStore
        });
        txn.get(stores.bySeqStore, formatSeq(seq), function (err, doc) {
          /* istanbul ignore if */
          if (err) {
            if (err.name === 'NotFoundError') {
              return checkDone();
            } else {
              return checkDone(err);
            }
          }
          var atts = Object.keys(doc._attachments || {});
          atts.forEach(function (attName) {
            var digest = doc._attachments[attName].digest;
            digestMap[digest] = true;
          });
          checkDone();
        });
      });
    });
  };

  api._getLocal = function (id, callback) {
    stores.localStore.get(id, function (err, doc) {
      if (err) {
        callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC));
      } else {
        callback(null, doc);
      }
    });
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    if (opts.ctx) {
      api._putLocalNoLock(doc, opts, callback);
    } else {
      api._putLocalWithLock(doc, opts, callback);
    }
  };

  api._putLocalWithLock = writeLock(function (doc, opts, callback) {
    api._putLocalNoLock(doc, opts, callback);
  });

  // the NoLock version is for use by bulkDocs
  api._putLocalNoLock = function (doc, opts, callback) {
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;

    var txn = opts.ctx || new LevelTransaction();

    txn.get(stores.localStore, id, function (err, resp) {
      if (err && oldRev) {
        return callback(pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT));
      }
      if (resp && resp._rev !== oldRev) {
        return callback(pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT));
      }
      doc._rev =
          oldRev ? '0-' + (parseInt(oldRev.split('-')[1], 10) + 1) : '0-1';
      var batch = [
        {
          type: 'put',
          prefix: stores.localStore,
          key: id,
          value: doc
        }
      ];

      txn.batch(batch);
      var ret = {ok: true, id: doc._id, rev: doc._rev};

      if (opts.ctx) {
        // don't execute immediately
        return callback(null, ret);
      }
      txn.execute(db, function (err) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        callback(null, ret);
      });
    });
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    if (opts.ctx) {
      api._removeLocalNoLock(doc, opts, callback);
    } else {
      api._removeLocalWithLock(doc, opts, callback);
    }
  };

  api._removeLocalWithLock = writeLock(function (doc, opts, callback) {
    api._removeLocalNoLock(doc, opts, callback);
  });

  // the NoLock version is for use by bulkDocs
  api._removeLocalNoLock = function (doc, opts, callback) {
    var txn = opts.ctx || new LevelTransaction();
    txn.get(stores.localStore, doc._id, function (err, resp) {
      if (err) {
        /* istanbul ignore if */
        if (err.name !== 'NotFoundError') {
          return callback(err);
        } else {
          return callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC));
        }
      }
      if (resp._rev !== doc._rev) {
        return callback(pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT));
      }
      txn.batch([{
        prefix: stores.localStore,
        type: 'del',
        key: doc._id
      }]);
      var ret = {ok: true, id: doc._id, rev: '0-0'};
      if (opts.ctx) {
        // don't execute immediately
        return callback(null, ret);
      }
      txn.execute(db, function (err) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        callback(null, ret);
      });
    });
  };

  // close and delete open leveldb stores
  api._destroy = function (opts, callback) {
    var dbStore;
    var leveldownName = pouchdbUtils.functionName(leveldown);
    /* istanbul ignore else */
    if (dbStores.has(leveldownName)) {
      dbStore = dbStores.get(leveldownName);
    } else {
      return callDestroy(name, callback);
    }

    /* istanbul ignore else */
    if (dbStore.has(name)) {
      levelChanges.removeAllListeners(name);

      dbStore.get(name).close(function () {
        dbStore.delete(name);
        callDestroy(name, callback);
      });
    } else {
      callDestroy(name, callback);
    }
  };
  function callDestroy(name, cb) {
    leveldown.destroy(name, cb);
  }
}

module.exports = LevelPouch;

},{"argsarray":1,"buffer-from":4,"double-ended-queue":14,"levelup":36,"pouchdb-adapter-utils":60,"pouchdb-binary-utils":61,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-json":64,"pouchdb-md5":65,"pouchdb-merge":66,"pouchdb-promise":58,"pouchdb-utils":67,"sublevel-pouchdb":97,"through2":109}],58:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lie = _interopDefault(require('lie'));

/* istanbul ignore next */
var PouchPromise = typeof Promise === 'function' ? Promise : lie;

module.exports = PouchPromise;

},{"lie":40}],59:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pouchdbUtils = require('pouchdb-utils');
var CoreLevelPouch = _interopDefault(require('pouchdb-adapter-leveldb-core'));
var memdown = _interopDefault(require('memdown'));

function MemDownPouch(opts, callback) {
  var _opts = pouchdbUtils.assign({
    db: memdown
  }, opts);

  CoreLevelPouch.call(this, _opts, callback);
}

// overrides for normal LevelDB behavior on Node
MemDownPouch.valid = function () {
  return true;
};
MemDownPouch.use_prefix = false;

var index = function (PouchDB) {
  PouchDB.adapter('memory', MemDownPouch, true);
};

module.exports = index;

},{"memdown":44,"pouchdb-adapter-leveldb-core":57,"pouchdb-utils":67}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pouchdbUtils = require('pouchdb-utils');
var pouchdbErrors = require('pouchdb-errors');
var pouchdbMerge = require('pouchdb-merge');
var pouchdbBinaryUtils = require('pouchdb-binary-utils');
var pouchdbMd5 = require('pouchdb-md5');
var pouchdbCollections = require('pouchdb-collections');

function toObject(array) {
  return array.reduce(function (obj, item) {
    obj[item] = true;
    return obj;
  }, {});
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats',
  // Specific to Couchbase Sync Gateway
  '_removed'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

function parseRevisionInfo(rev$$1) {
  if (!/^\d+-./.test(rev$$1)) {
    return pouchdbErrors.createError(pouchdbErrors.INVALID_REV);
  }
  var idx = rev$$1.indexOf('-');
  var left = rev$$1.substring(0, idx);
  var right = rev$$1.substring(idx + 1);
  return {
    prefix: parseInt(left, 10),
    id: right
  };
}

function makeRevTreeFromRevisions(revisions, opts) {
  var pos = revisions.start - revisions.ids.length + 1;

  var revisionIds = revisions.ids;
  var ids = [revisionIds[0], opts, []];

  for (var i = 1, len = revisionIds.length; i < len; i++) {
    ids = [revisionIds[i], {status: 'missing'}, [ids]];
  }

  return [{
    pos: pos,
    ids: ids
  }];
}

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
function parseDoc(doc, newEdits) {

  var nRevNum;
  var newRevId;
  var revInfo;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = pouchdbUtils.uuid();
    }
    newRevId = pouchdbUtils.rev();
    if (doc._rev) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      doc._rev_tree = [{
        pos: revInfo.prefix,
        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = revInfo.prefix + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      nRevNum = revInfo.prefix;
      newRevId = revInfo.id;
      doc._rev_tree = [{
        pos: nRevNum,
        ids: [newRevId, opts, []]
      }];
    }
  }

  pouchdbUtils.invalidIdError(doc._id);

  doc._rev = nRevNum + '-' + newRevId;

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(doc, key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        var error = pouchdbErrors.createError(pouchdbErrors.DOC_VALIDATION, key);
        error.message = pouchdbErrors.DOC_VALIDATION.message + ': ' + key;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
}

function parseBase64(data) {
  try {
    return pouchdbBinaryUtils.atob(data);
  } catch (e) {
    var err = pouchdbErrors.createError(pouchdbErrors.BAD_ARG,
      'Attachment is not a valid base64 string');
    return {error: err};
  }
}

function preprocessString(att, blobType, callback) {
  var asBinary = parseBase64(att.data);
  if (asBinary.error) {
    return callback(asBinary.error);
  }

  att.length = asBinary.length;
  if (blobType === 'blob') {
    att.data = pouchdbBinaryUtils.binaryStringToBlobOrBuffer(asBinary, att.content_type);
  } else if (blobType === 'base64') {
    att.data = pouchdbBinaryUtils.btoa(asBinary);
  } else { // binary
    att.data = asBinary;
  }
  pouchdbMd5.binaryMd5(asBinary, function (result) {
    att.digest = 'md5-' + result;
    callback();
  });
}

function preprocessBlob(att, blobType, callback) {
  pouchdbMd5.binaryMd5(att.data, function (md5) {
    att.digest = 'md5-' + md5;
    // size is for blobs (browser), length is for buffers (node)
    att.length = att.data.size || att.data.length || 0;
    if (blobType === 'binary') {
      pouchdbBinaryUtils.blobOrBufferToBinaryString(att.data, function (binString) {
        att.data = binString;
        callback();
      });
    } else if (blobType === 'base64') {
      pouchdbBinaryUtils.blobOrBufferToBase64(att.data, function (b64) {
        att.data = b64;
        callback();
      });
    } else {
      callback();
    }
  });
}

function preprocessAttachment(att, blobType, callback) {
  if (att.stub) {
    return callback();
  }
  if (typeof att.data === 'string') { // input is a base64 string
    preprocessString(att, blobType, callback);
  } else { // input is a blob
    preprocessBlob(att, blobType, callback);
  }
}

function preprocessAttachments(docInfos, blobType, callback) {

  if (!docInfos.length) {
    return callback();
  }

  var docv = 0;
  var overallErr;

  docInfos.forEach(function (docInfo) {
    var attachments = docInfo.data && docInfo.data._attachments ?
      Object.keys(docInfo.data._attachments) : [];
    var recv = 0;

    if (!attachments.length) {
      return done();
    }

    function processedAttachment(err) {
      overallErr = err;
      recv++;
      if (recv === attachments.length) {
        done();
      }
    }

    for (var key in docInfo.data._attachments) {
      if (docInfo.data._attachments.hasOwnProperty(key)) {
        preprocessAttachment(docInfo.data._attachments[key],
          blobType, processedAttachment);
      }
    }
  });

  function done() {
    docv++;
    if (docInfos.length === docv) {
      if (overallErr) {
        callback(overallErr);
      } else {
        callback();
      }
    }
  }
}

function updateDoc(revLimit, prev, docInfo, results,
                   i, cb, writeDoc, newEdits) {

  if (pouchdbMerge.revExists(prev.rev_tree, docInfo.metadata.rev)) {
    results[i] = docInfo;
    return cb();
  }

  // sometimes this is pre-calculated. historically not always
  var previousWinningRev = prev.winningRev || pouchdbMerge.winningRev(prev);
  var previouslyDeleted = 'deleted' in prev ? prev.deleted :
    pouchdbMerge.isDeleted(prev, previousWinningRev);
  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
    pouchdbMerge.isDeleted(docInfo.metadata);
  var isRoot = /^1-/.test(docInfo.metadata.rev);

  if (previouslyDeleted && !deleted && newEdits && isRoot) {
    var newDoc = docInfo.data;
    newDoc._rev = previousWinningRev;
    newDoc._id = docInfo.metadata.id;
    docInfo = parseDoc(newDoc, newEdits);
  }

  var merged = pouchdbMerge.merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

  var inConflict = newEdits && ((
    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

  if (inConflict) {
    var err = pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT);
    results[i] = err;
    return cb();
  }

  var newRev = docInfo.metadata.rev;
  docInfo.metadata.rev_tree = merged.tree;
  docInfo.stemmedRevs = merged.stemmedRevs || [];
  /* istanbul ignore else */
  if (prev.rev_map) {
    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
  }

  // recalculate
  var winningRev$$1 = pouchdbMerge.winningRev(docInfo.metadata);
  var winningRevIsDeleted = pouchdbMerge.isDeleted(docInfo.metadata, winningRev$$1);

  // calculate the total number of documents that were added/removed,
  // from the perspective of total_rows/doc_count
  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
    previouslyDeleted < winningRevIsDeleted ? -1 : 1;

  var newRevIsDeleted;
  if (newRev === winningRev$$1) {
    // if the new rev is the same as the winning rev, we can reuse that value
    newRevIsDeleted = winningRevIsDeleted;
  } else {
    // if they're not the same, then we need to recalculate
    newRevIsDeleted = pouchdbMerge.isDeleted(docInfo.metadata, newRev);
  }

  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
    true, delta, i, cb);
}

function rootIsMissing(docInfo) {
  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
}

function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                     writeDoc, opts, overallCallback) {

  // Default to 1000 locally
  revLimit = revLimit || 1000;

  function insertDoc(docInfo, resultsIdx, callback) {
    // Cant insert new deleted documents
    var winningRev$$1 = pouchdbMerge.winningRev(docInfo.metadata);
    var deleted = pouchdbMerge.isDeleted(docInfo.metadata, winningRev$$1);
    if ('was_delete' in opts && deleted) {
      results[resultsIdx] = pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'deleted');
      return callback();
    }

    // 4712 - detect whether a new document was inserted with a _rev
    var inConflict = newEdits && rootIsMissing(docInfo);

    if (inConflict) {
      var err = pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT);
      results[resultsIdx] = err;
      return callback();
    }

    var delta = deleted ? 0 : 1;

    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
      delta, resultsIdx, callback);
  }

  var newEdits = opts.new_edits;
  var idsToDocs = new pouchdbCollections.Map();

  var docsDone = 0;
  var docsToDo = docInfos.length;

  function checkAllDocsDone() {
    if (++docsDone === docsToDo && overallCallback) {
      overallCallback();
    }
  }

  docInfos.forEach(function (currentDoc, resultsIdx) {

    if (currentDoc._id && pouchdbMerge.isLocalId(currentDoc._id)) {
      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
      api[fun](currentDoc, {ctx: tx}, function (err, res) {
        results[resultsIdx] = err || res;
        checkAllDocsDone();
      });
      return;
    }

    var id = currentDoc.metadata.id;
    if (idsToDocs.has(id)) {
      docsToDo--; // duplicate
      idsToDocs.get(id).push([currentDoc, resultsIdx]);
    } else {
      idsToDocs.set(id, [[currentDoc, resultsIdx]]);
    }
  });

  // in the case of new_edits, the user can provide multiple docs
  // with the same id. these need to be processed sequentially
  idsToDocs.forEach(function (docs, id) {
    var numDone = 0;

    function docWritten() {
      if (++numDone < docs.length) {
        nextDoc();
      } else {
        checkAllDocsDone();
      }
    }
    function nextDoc() {
      var value = docs[numDone];
      var currentDoc = value[0];
      var resultsIdx = value[1];

      if (fetchedDocs.has(id)) {
        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
          resultsIdx, docWritten, writeDoc, newEdits);
      } else {
        // Ensure stemming applies to new writes as well
        var merged = pouchdbMerge.merge([], currentDoc.metadata.rev_tree[0], revLimit);
        currentDoc.metadata.rev_tree = merged.tree;
        currentDoc.stemmedRevs = merged.stemmedRevs || [];
        insertDoc(currentDoc, resultsIdx, docWritten);
      }
    }
    nextDoc();
  });
}

exports.invalidIdError = pouchdbUtils.invalidIdError;
exports.isDeleted = pouchdbMerge.isDeleted;
exports.isLocalId = pouchdbMerge.isLocalId;
exports.normalizeDdocFunctionName = pouchdbUtils.normalizeDdocFunctionName;
exports.parseDdocFunctionName = pouchdbUtils.parseDdocFunctionName;
exports.parseDoc = parseDoc;
exports.preprocessAttachments = preprocessAttachments;
exports.processDocs = processDocs;
exports.updateDoc = updateDoc;

},{"pouchdb-binary-utils":61,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-md5":65,"pouchdb-merge":66,"pouchdb-utils":67}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var thisAtob = function (str) {
  return atob(str);
};

var thisBtoa = function (str) {
  return btoa(str);
};

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
function createBlob(parts, properties) {
  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                  WebKitBlobBuilder;
    var builder = new Builder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function binaryStringToArrayBuffer(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
}

function binStringToBluffer(binString, type) {
  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
}

function b64ToBluffer(b64, type) {
  return binStringToBluffer(thisAtob(b64), type);
}

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
function arrayBufferToBinaryString(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
}

// shim for browsers that don't support it
function readAsBinaryString(blob, callback) {
  if (typeof FileReader === 'undefined') {
    // fix for Firefox in a web worker
    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
    return callback(arrayBufferToBinaryString(
      new FileReaderSync().readAsArrayBuffer(blob)));
  }

  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
}

function blobToBinaryString(blobOrBuffer, callback) {
  readAsBinaryString(blobOrBuffer, function (bin) {
    callback(bin);
  });
}

function blobToBase64(blobOrBuffer, callback) {
  blobToBinaryString(blobOrBuffer, function (base64) {
    callback(thisBtoa(base64));
  });
}

// simplified API. universal browser support is assumed
function readAsArrayBuffer(blob, callback) {
  if (typeof FileReader === 'undefined') {
    // fix for Firefox in a web worker:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
    return callback(new FileReaderSync().readAsArrayBuffer(blob));
  }

  var reader = new FileReader();
  reader.onloadend = function (e) {
    var result = e.target.result || new ArrayBuffer(0);
    callback(result);
  };
  reader.readAsArrayBuffer(blob);
}

// this is not used in the browser
function typedBuffer() {
}

exports.atob = thisAtob;
exports.btoa = thisBtoa;
exports.base64StringToBlobOrBuffer = b64ToBluffer;
exports.binaryStringToArrayBuffer = binaryStringToArrayBuffer;
exports.binaryStringToBlobOrBuffer = binStringToBluffer;
exports.blob = createBlob;
exports.blobOrBufferToBase64 = blobToBase64;
exports.blobOrBufferToBinaryString = blobToBinaryString;
exports.readAsArrayBuffer = readAsArrayBuffer;
exports.readAsBinaryString = readAsBinaryString;
exports.typedBuffer = typedBuffer;

},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function mangle(key) {
  return '$' + key;
}
function unmangle(key) {
  return key.substring(1);
}
function Map$1() {
  this._store = {};
}
Map$1.prototype.get = function (key) {
  var mangled = mangle(key);
  return this._store[mangled];
};
Map$1.prototype.set = function (key, value) {
  var mangled = mangle(key);
  this._store[mangled] = value;
  return true;
};
Map$1.prototype.has = function (key) {
  var mangled = mangle(key);
  return mangled in this._store;
};
Map$1.prototype.delete = function (key) {
  var mangled = mangle(key);
  var res = mangled in this._store;
  delete this._store[mangled];
  return res;
};
Map$1.prototype.forEach = function (cb) {
  var keys = Object.keys(this._store);
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var value = this._store[key];
    key = unmangle(key);
    cb(value, key);
  }
};
Object.defineProperty(Map$1.prototype, 'size', {
  get: function () {
    return Object.keys(this._store).length;
  }
});

function Set$1(array) {
  this._store = new Map$1();

  // init with an array
  if (array && Array.isArray(array)) {
    for (var i = 0, len = array.length; i < len; i++) {
      this.add(array[i]);
    }
  }
}
Set$1.prototype.add = function (key) {
  return this._store.set(key, true);
};
Set$1.prototype.has = function (key) {
  return this._store.has(key);
};
Set$1.prototype.forEach = function (cb) {
  this._store.forEach(function (value, key) {
    cb(key);
  });
};
Object.defineProperty(Set$1.prototype, 'size', {
  get: function () {
    return this._store.size;
  }
});

/* global Map,Set,Symbol */
// Based on https://kangax.github.io/compat-table/es6/ we can sniff out
// incomplete Map/Set implementations which would otherwise cause our tests to fail.
// Notably they fail in IE11 and iOS 8.4, which this prevents.
function supportsMapAndSet() {
  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
    return false;
  }
  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return prop && 'get' in prop && Map[Symbol.species] === Map;
}

// based on https://github.com/montagejs/collections
/* global Map,Set */

{
  if (supportsMapAndSet()) { // prefer built-in Map/Set
    exports.Set = Set;
    exports.Map = Map;
  } else { // fall back to our polyfill
    exports.Set = Set$1;
    exports.Map = Map$1;
  }
}

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var inherits = _interopDefault(require('inherits'));

inherits(PouchError, Error);

function PouchError(status, error, reason) {
  Error.call(this, reason);
  this.status = status;
  this.name = error;
  this.message = reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    for (var p in error) {
      if (typeof error[p] !== 'function') {
        this[p] = error[p];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

exports.UNAUTHORIZED = UNAUTHORIZED;
exports.MISSING_BULK_DOCS = MISSING_BULK_DOCS;
exports.MISSING_DOC = MISSING_DOC;
exports.REV_CONFLICT = REV_CONFLICT;
exports.INVALID_ID = INVALID_ID;
exports.MISSING_ID = MISSING_ID;
exports.RESERVED_ID = RESERVED_ID;
exports.NOT_OPEN = NOT_OPEN;
exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
exports.BAD_ARG = BAD_ARG;
exports.INVALID_REQUEST = INVALID_REQUEST;
exports.QUERY_PARSE_ERROR = QUERY_PARSE_ERROR;
exports.DOC_VALIDATION = DOC_VALIDATION;
exports.BAD_REQUEST = BAD_REQUEST;
exports.NOT_AN_OBJECT = NOT_AN_OBJECT;
exports.DB_MISSING = DB_MISSING;
exports.WSQ_ERROR = WSQ_ERROR;
exports.LDB_ERROR = LDB_ERROR;
exports.FORBIDDEN = FORBIDDEN;
exports.INVALID_REV = INVALID_REV;
exports.FILE_EXISTS = FILE_EXISTS;
exports.MISSING_STUB = MISSING_STUB;
exports.IDB_ERROR = IDB_ERROR;
exports.INVALID_URL = INVALID_URL;
exports.createError = createError;
exports.generateErrorFromResponse = generateErrorFromResponse;

},{"inherits":24}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var vuvuzela = _interopDefault(require('vuvuzela'));

function safeJsonParse(str) {
  // This try/catch guards against stack overflow errors.
  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
  // cannot overflow.
  try {
    return JSON.parse(str);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.parse(str);
  }
}

function safeJsonStringify(json) {
  try {
    return JSON.stringify(json);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.stringify(json);
  }
}

exports.safeJsonParse = safeJsonParse;
exports.safeJsonStringify = safeJsonStringify;

},{"vuvuzela":119}],65:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pouchdbBinaryUtils = require('pouchdb-binary-utils');
var Md5 = _interopDefault(require('spark-md5'));

var setImmediateShim = global.setImmediate || global.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function rawToBase64(raw) {
  return pouchdbBinaryUtils.btoa(raw);
}

function sliceBlob(blob, start, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start, end);
  }
  return blob.slice(start, end);
}

function appendBlob(buffer, blob, start, end, callback) {
  if (start > 0 || end < blob.size) {
    // only slice blob if we really need to
    blob = sliceBlob(blob, start, end);
  }
  pouchdbBinaryUtils.readAsArrayBuffer(blob, function (arrayBuffer) {
    buffer.append(arrayBuffer);
    callback();
  });
}

function appendString(buffer, string, start, end, callback) {
  if (start > 0 || end < string.length) {
    // only create a substring if we really need to
    string = string.substring(start, end);
  }
  buffer.appendBinary(string);
  callback();
}

function binaryMd5(data, callback) {
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.size;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();

  var append = inputIsString ? appendString : appendBlob;

  function next() {
    setImmediateShim(loadNextChunk);
  }

  function done() {
    var raw = buffer.end(true);
    var base64 = rawToBase64(raw);
    callback(base64);
    buffer.destroy();
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end, next);
    } else {
      append(buffer, data, start, end, done);
    }
  }
  loadNextChunk();
}

function stringMd5(string) {
  return Md5.hash(string);
}

exports.binaryMd5 = binaryMd5;
exports.stringMd5 = stringMd5;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"pouchdb-binary-utils":61,"spark-md5":80}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var winningDeleted;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var deleted = !!tree[1].deleted;
    var id = tree[0];
    // sort by deleted, then pos, then id
    if (!winningId || (winningDeleted !== deleted ? winningDeleted :
        winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
      winningDeleted = deleted;
    }
  }

  return winningPos + '-' + winningId;
}

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
function traverseRevTree(revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
}

function sortByPos(a, b) {
  return a.pos - b.pos;
}

function collectLeaves(revs) {
  var leaves = [];
  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(sortByPos).reverse();
  for (var i = 0, len = leaves.length; i < len; i++) {
    delete leaves[i].pos;
  }
  return leaves;
}

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
function collectConflicts(metadata) {
  var win = winningRev(metadata);
  var leaves = collectLeaves(metadata.rev_tree);
  var conflicts = [];
  for (var i = 0, len = leaves.length; i < len; i++) {
    var leaf = leaves[i];
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  }
  return conflicts;
}

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
function compactTree(metadata) {
  var revs = [];
  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                               revHash, ctx, opts) {
    if (opts.status === 'available' && !isLeaf) {
      revs.push(pos + '-' + revHash);
      opts.status = 'missing';
    }
  });
  return revs;
}

// build up a list of all the paths to the leafs in this revision tree
function rootToLeaf(revs) {
  var paths = [];
  var toVisit = revs.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      paths.push({pos: (pos + 1 - history.length), ids: history});
    }
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], history: history});
    }
  }
  return paths.reverse();
}

// for a better overview of what this is doing, read:
// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl
//
// But for a quick intro, CouchDB uses a revision tree to store a documents
// history, A -> B -> C, when a document has conflicts, that is a branch in the
// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format
//
// KeyTree = [Path ... ]
// Path = {pos: position_from_root, ids: Tree}
// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]

function sortByPos$1(a, b) {
  return a.pos - b.pos;
}

// classic binary search
function binarySearch(arr, item, comparator) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1;
    if (comparator(arr[mid], item) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}

// assuming the arr is sorted, insert the item in the proper place
function insertSorted(arr, item, comparator) {
  var idx = binarySearch(arr, item, comparator);
  arr.splice(idx, 0, item);
}

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
function pathToTree(path, numStemmed) {
  var root;
  var leaf;
  for (var i = numStemmed, len = path.length; i < len; i++) {
    var node = path[i];
    var currentLeaf = [node.id, node.opts, []];
    if (leaf) {
      leaf[2].push(currentLeaf);
      leaf = currentLeaf;
    } else {
      root = leaf = currentLeaf;
    }
  }
  return root;
}

// compare the IDs of two trees
function compareTree(a, b) {
  return a[0] < b[0] ? -1 : 1;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
        tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        insertSorted(tree1[2], tree2[2][i], compareTree);
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  for (var i = 0, len = tree.length; i < len; i++) {
    var branch = tree[i];
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        var elements = item.ids[2];
        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
          trees.push({
            ids: elements[j],
            diff: item.diff - 1,
            parent: item.ids,
            parentIdx: j
          });
        }
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  }

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(sortByPos$1);

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths
  var paths = rootToLeaf(tree);
  var stemmedRevs;

  var result;
  for (var i = 0, len = paths.length; i < len; i++) {
    // Then for each path, we cut off the start of the path based on the
    // `depth` to stem to, and generate a new set of flat trees
    var path = paths[i];
    var stemmed = path.ids;
    var node;
    if (stemmed.length > depth) {
      // only do the stemming work if we actually need to stem
      if (!stemmedRevs) {
        stemmedRevs = {}; // avoid allocating this object unnecessarily
      }
      var numStemmed = stemmed.length - depth;
      node = {
        pos: path.pos + numStemmed,
        ids: pathToTree(stemmed, numStemmed)
      };

      for (var s = 0; s < numStemmed; s++) {
        var rev = (path.pos + s) + '-' + stemmed[s].id;
        stemmedRevs[rev] = true;
      }
    } else { // no need to actually stem
      node = {
        pos: path.pos,
        ids: pathToTree(stemmed, 0)
      };
    }

    // Then we remerge all those flat trees together, ensuring that we dont
    // connect trees that would go beyond the depth limit
    if (result) {
      result = doMerge(result, node, true).tree;
    } else {
      result = [node];
    }
  }

  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
  if (stemmedRevs) {
    traverseRevTree(result, function (isLeaf, pos, revHash) {
      // some revisions may have been removed in a branch but not in another
      delete stemmedRevs[pos + '-' + revHash];
    });
  }

  return {
    tree: result,
    revs: stemmedRevs ? Object.keys(stemmedRevs) : []
  };
}

function merge(tree, path, depth) {
  var newTree = doMerge(tree, path);
  var stemmed = stem(newTree.tree, depth);
  return {
    tree: stemmed.tree,
    stemmedRevs: stemmed.revs,
    conflicts: newTree.conflicts
  };
}

// return true if a rev exists in the rev tree, false otherwise
function revExists(revs, rev) {
  var toVisit = revs.slice();
  var splitRev = rev.split('-');
  var targetPos = parseInt(splitRev[0], 10);
  var targetId = splitRev[1];

  var node;
  while ((node = toVisit.pop())) {
    if (node.pos === targetPos && node.ids[0] === targetId) {
      return true;
    }
    var branches = node.ids[2];
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: node.pos + 1, ids: branches[i]});
    }
  }
  return false;
}

function getTrees(node) {
  return node.ids;
}

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
function isDeleted(metadata, rev) {
  if (!rev) {
    rev = winningRev(metadata);
  }
  var id = rev.substring(rev.indexOf('-') + 1);
  var toVisit = metadata.rev_tree.map(getTrees);

  var tree;
  while ((tree = toVisit.pop())) {
    if (tree[0] === id) {
      return !!tree[1].deleted;
    }
    toVisit = toVisit.concat(tree[2]);
  }
}

function isLocalId(id) {
  return (/^_local/).test(id);
}

// returns the current leaf node for a given revision
function latest(rev, metadata) {
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, pos: pos, opts: opts});

    if (isLeaf) {
      for (var i = 0, len = history.length; i < len; i++) {
        var historyNode = history[i];
        var historyRev = historyNode.pos + '-' + historyNode.id;

        if (historyRev === rev) {
          // return the rev of this leaf
          return pos + '-' + id;
        }
      }
    }

    for (var j = 0, l = branches.length; j < l; j++) {
      toVisit.push({pos: pos + 1, ids: branches[j], history: history});
    }
  }

  /* istanbul ignore next */
  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
}

exports.collectConflicts = collectConflicts;
exports.collectLeaves = collectLeaves;
exports.compactTree = compactTree;
exports.isDeleted = isDeleted;
exports.isLocalId = isLocalId;
exports.merge = merge;
exports.revExists = revExists;
exports.rootToLeaf = rootToLeaf;
exports.traverseRevTree = traverseRevTree;
exports.winningRev = winningRev;
exports.latest = latest;

},{}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Promise = _interopDefault(require('pouchdb-promise'));
var getArguments = _interopDefault(require('argsarray'));
var pouchdbCollections = require('pouchdb-collections');
var events = require('events');
var inherits = _interopDefault(require('inherits'));
var immediate = _interopDefault(require('immediate'));
var pouchdbErrors = require('pouchdb-errors');
var v4 = _interopDefault(require('uuid/v4'));

function isBinaryObject(object) {
  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
    (typeof Blob !== 'undefined' && object instanceof Blob);
}

function cloneArrayBuffer(buff) {
  if (typeof buff.slice === 'function') {
    return buff.slice(0);
  }
  // IE10-11 slice() polyfill
  var target = new ArrayBuffer(buff.byteLength);
  var targetArray = new Uint8Array(target);
  var sourceArray = new Uint8Array(buff);
  targetArray.set(sourceArray);
  return target;
}

function cloneBinaryObject(object) {
  if (object instanceof ArrayBuffer) {
    return cloneArrayBuffer(object);
  }
  var size = object.size;
  var type = object.type;
  // Blob
  if (typeof object.slice === 'function') {
    return object.slice(0, size, type);
  }
  // PhantomJS slice() replacement
  return object.webkitSlice(0, size, type);
}

// most of this is borrowed from lodash.isPlainObject:
// https://github.com/fis-components/lodash.isplainobject/
// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(value) {
  var proto = Object.getPrototypeOf(value);
  /* istanbul ignore if */
  if (proto === null) { // not sure when this happens, but I guess it can
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

function clone(object) {
  var newObject;
  var i;
  var len;

  if (!object || typeof object !== 'object') {
    return object;
  }

  if (Array.isArray(object)) {
    newObject = [];
    for (i = 0, len = object.length; i < len; i++) {
      newObject[i] = clone(object[i]);
    }
    return newObject;
  }

  // special case: to avoid inconsistencies between IndexedDB
  // and other backends, we automatically stringify Dates
  if (object instanceof Date) {
    return object.toISOString();
  }

  if (isBinaryObject(object)) {
    return cloneBinaryObject(object);
  }

  if (!isPlainObject(object)) {
    return object; // don't clone objects like Workers
  }

  newObject = {};
  for (i in object) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(object, i)) {
      var value = clone(object[i]);
      if (typeof value !== 'undefined') {
        newObject[i] = value;
      }
    }
  }
  return newObject;
}

function once(fun) {
  var called = false;
  return getArguments(function (args) {
    /* istanbul ignore if */
    if (called) {
      // this is a smoke test and should never actually happen
      throw new Error('once called more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
}

function toPromise(func) {
  //create the function we will be returning
  return getArguments(function (args) {
    // Clone arguments
    args = clone(args);
    var self = this;
    // if the last argument is a function, assume its a callback
    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    var promise = new Promise(function (fulfill, reject) {
      var resp;
      try {
        var callback = once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    return promise;
  });
}

function logApiCall(self, name, args) {
  /* istanbul ignore if */
  if (self.constructor.listeners('debug').length) {
    var logArgs = ['api', self.name, name];
    for (var i = 0; i < args.length - 1; i++) {
      logArgs.push(args[i]);
    }
    self.constructor.emit('debug', logArgs);

    // override the callback itself to log the response
    var origCallback = args[args.length - 1];
    args[args.length - 1] = function (err, res) {
      var responseArgs = ['api', self.name, name];
      responseArgs = responseArgs.concat(
        err ? ['error', err] : ['success', res]
      );
      self.constructor.emit('debug', responseArgs);
      origCallback(err, res);
    };
  }
}

function adapterFun(name, callback) {
  return toPromise(getArguments(function (args) {
    if (this._closed) {
      return Promise.reject(new Error('database is closed'));
    }
    if (this._destroyed) {
      return Promise.reject(new Error('database is destroyed'));
    }
    var self = this;
    logApiCall(self, name, args);
    if (!this.taskqueue.isReady) {
      return new Promise(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
}

// like underscore/lodash _.pick()
function pick(obj, arr) {
  var res = {};
  for (var i = 0, len = arr.length; i < len; i++) {
    var prop = arr[i];
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  }
  return res;
}

// Most browsers throttle concurrent requests at 6, so it's silly
// to shim _bulk_get by trying to launch potentially hundreds of requests
// and then letting the majority time out. We can handle this ourselves.
var MAX_NUM_CONCURRENT_REQUESTS = 6;

function identityFunction(x) {
  return x;
}

function formatResultForOpenRevsGet(result) {
  return [{
    ok: result
  }];
}

// shim for P/CouchDB adapters that don't directly implement _bulk_get
function bulkGet(db, opts, callback) {
  var requests = opts.docs;

  // consolidate into one request per doc if possible
  var requestsById = new pouchdbCollections.Map();
  requests.forEach(function (request) {
    if (requestsById.has(request.id)) {
      requestsById.get(request.id).push(request);
    } else {
      requestsById.set(request.id, [request]);
    }
  });

  var numDocs = requestsById.size;
  var numDone = 0;
  var perDocResults = new Array(numDocs);

  function collapseResultsAndFinish() {
    var results = [];
    perDocResults.forEach(function (res) {
      res.docs.forEach(function (info) {
        results.push({
          id: res.id,
          docs: [info]
        });
      });
    });
    callback(null, {results: results});
  }

  function checkDone() {
    if (++numDone === numDocs) {
      collapseResultsAndFinish();
    }
  }

  function gotResult(docIndex, id, docs) {
    perDocResults[docIndex] = {id: id, docs: docs};
    checkDone();
  }

  var allRequests = [];
  requestsById.forEach(function (value, key) {
    allRequests.push(key);
  });

  var i = 0;

  function nextBatch() {

    if (i >= allRequests.length) {
      return;
    }

    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
    var batch = allRequests.slice(i, upTo);
    processBatch(batch, i);
    i += batch.length;
  }

  function processBatch(batch, offset) {
    batch.forEach(function (docId, j) {
      var docIdx = offset + j;
      var docRequests = requestsById.get(docId);

      // just use the first request as the "template"
      // TODO: The _bulk_get API allows for more subtle use cases than this,
      // but for now it is unlikely that there will be a mix of different
      // "atts_since" or "attachments" in the same request, since it's just
      // replicate.js that is using this for the moment.
      // Also, atts_since is aspirational, since we don't support it yet.
      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
      docOpts.open_revs = docRequests.map(function (request) {
        // rev is optional, open_revs disallowed
        return request.rev;
      });

      // remove falsey / undefined revisions
      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

      var formatResult = identityFunction;

      if (docOpts.open_revs.length === 0) {
        delete docOpts.open_revs;

        // when fetching only the "winning" leaf,
        // transform the result so it looks like an open_revs
        // request
        formatResult = formatResultForOpenRevsGet;
      }

      // globally-supplied options
      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
        if (param in opts) {
          docOpts[param] = opts[param];
        }
      });
      db.get(docId, docOpts, function (err, res) {
        var result;
        /* istanbul ignore if */
        if (err) {
          result = [{error: err}];
        } else {
          result = formatResult(res);
        }
        gotResult(docIdx, docId, result);
        nextBatch();
      });
    });
  }

  nextBatch();

}

function isChromeApp() {
  return (typeof chrome !== "undefined" &&
    typeof chrome.storage !== "undefined" &&
    typeof chrome.storage.local !== "undefined");
}

var hasLocal;

if (isChromeApp()) {
  hasLocal = false;
} else {
  try {
    localStorage.setItem('_pouch_check_localstorage', 1);
    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
  } catch (e) {
    hasLocal = false;
  }
}

function hasLocalStorage() {
  return hasLocal;
}

// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We
// avoid using process.nextTick() directly because the polyfill is very large and we don't
// need all of it (see: https://github.com/defunctzombie/node-process).
// "immediate" 3.0.8 is used by lie, and it's a smaller version of the latest "immediate"
// package, so it's the one we use.
// When we use nextTick() in our codebase, we only care about not releasing Zalgo
// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).
// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest
// (least latency) option, which is "immediate" due to use of microtasks.
// All of our nextTicks are isolated to this one function so we can easily swap out one
// implementation for another.

inherits(Changes, events.EventEmitter);

/* istanbul ignore next */
function attachBrowserEvents(self) {
  if (isChromeApp()) {
    chrome.storage.onChanged.addListener(function (e) {
      // make sure it's event addressed to us
      if (e.db_name != null) {
        //object only has oldValue, newValue members
        self.emit(e.dbName.newValue);
      }
    });
  } else if (hasLocalStorage()) {
    if (typeof addEventListener !== 'undefined') {
      addEventListener("storage", function (e) {
        self.emit(e.key);
      });
    } else { // old IE
      window.attachEvent("storage", function (e) {
        self.emit(e.key);
      });
    }
  }
}

function Changes() {
  events.EventEmitter.call(this);
  this._listeners = {};

  attachBrowserEvents(this);
}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  /* istanbul ignore if */
  if (this._listeners[id]) {
    return;
  }
  var self = this;
  var inprogress = false;
  function eventFunction() {
    /* istanbul ignore if */
    if (!self._listeners[id]) {
      return;
    }
    if (inprogress) {
      inprogress = 'waiting';
      return;
    }
    inprogress = true;
    var changesOpts = pick(opts, [
      'style', 'include_docs', 'attachments', 'conflicts', 'filter',
      'doc_ids', 'view', 'since', 'query_params', 'binary'
    ]);

    /* istanbul ignore next */
    function onError() {
      inprogress = false;
    }

    db.changes(changesOpts).on('change', function (c) {
      if (c.seq > opts.since && !opts.cancelled) {
        opts.since = c.seq;
        opts.onChange(c);
      }
    }).on('complete', function () {
      if (inprogress === 'waiting') {
        immediate(eventFunction);
      }
      inprogress = false;
    }).on('error', onError);
  }
  this._listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  /* istanbul ignore if */
  if (!(id in this._listeners)) {
    return;
  }
  events.EventEmitter.prototype.removeListener.call(this, dbName,
    this._listeners[id]);
  delete this._listeners[id];
};


/* istanbul ignore next */
Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (isChromeApp()) {
    chrome.storage.local.set({dbName: dbName});
  } else if (hasLocalStorage()) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

function guardedConsole(method) {
  /* istanbul ignore else */
  if (console !== 'undefined' && method in console) {
    var args = Array.prototype.slice.call(arguments, 1);
    console[method].apply(console, args);
  }
}

function randomNumber(min, max) {
  var maxTimeout = 600000; // Hard-coded default of 10 minutes
  min = parseInt(min, 10) || 0;
  max = parseInt(max, 10);
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
  if (max > maxTimeout) {
    min = maxTimeout >> 1; // divide by two
    max = maxTimeout;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
function explainError(status, str) {
  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
}

var assign;
{
  if (typeof Object.assign === 'function') {
    assign = Object.assign;
  } else {
    // lite Object.assign polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    assign = function (target) {
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }
}

var assign$1 = assign;

function tryFilter(filter, doc, req) {
  try {
    return !filter(doc, req);
  } catch (err) {
    var msg = 'Filter function threw: ' + err.toString();
    return pouchdbErrors.createError(pouchdbErrors.BAD_REQUEST, msg);
  }
}

function filterChange(opts) {
  var req = {};
  var hasFilter = opts.filter && typeof opts.filter === 'function';
  req.query = opts.query_params;

  return function filter(change) {
    if (!change.doc) {
      // CSG sends events on the changes feed that don't have documents,
      // this hack makes a whole lot of existing code robust.
      change.doc = {};
    }

    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

    if (typeof filterReturn === 'object') {
      return filterReturn;
    }

    if (filterReturn) {
      return false;
    }

    if (!opts.include_docs) {
      delete change.doc;
    } else if (!opts.attachments) {
      for (var att in change.doc._attachments) {
        /* istanbul ignore else */
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
}

function flatten(arrs) {
  var res = [];
  for (var i = 0, len = arrs.length; i < len; i++) {
    res = res.concat(arrs[i]);
  }
  return res;
}

// shim for Function.prototype.name,
// for browsers that don't support it like IE

/* istanbul ignore next */
function f() {}

var hasName = f.name;
var res;

// We dont run coverage in IE
/* istanbul ignore else */
if (hasName) {
  res = function (fun) {
    return fun.name;
  };
} else {
  res = function (fun) {
    return fun.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
  };
}

var res$1 = res;

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
function invalidIdError(id) {
  var err;
  if (!id) {
    err = pouchdbErrors.createError(pouchdbErrors.MISSING_ID);
  } else if (typeof id !== 'string') {
    err = pouchdbErrors.createError(pouchdbErrors.INVALID_ID);
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = pouchdbErrors.createError(pouchdbErrors.RESERVED_ID);
  }
  if (err) {
    throw err;
  }
}

function isCordova() {
  return (typeof cordova !== "undefined" ||
  typeof PhoneGap !== "undefined" ||
  typeof phonegap !== "undefined");
}

// Checks if a PouchDB object is "remote" or not. This is
// designed to opt-in to certain optimizations, such as
// avoiding checks for "dependentDbs" and other things that
// we know only apply to local databases. In general, "remote"
// should be true for the http adapter, and for third-party
// adapters with similar expensive boundaries to cross for
// every API call, such as socket-pouch and worker-pouch.
// Previously, this was handled via db.type() === 'http'
// which is now deprecated.

function isRemote(db) {
  if (typeof db._remote === 'boolean') {
    return db._remote;
  }
  /* istanbul ignore next */
  if (typeof db.type === 'function') {
    guardedConsole('warn',
      'db.type() is deprecated and will be removed in ' +
      'a future version of PouchDB');
    return db.type() === 'http';
  }
  /* istanbul ignore next */
  return false;
}

function listenerCount(ee, type) {
  return 'listenerCount' in ee ? ee.listenerCount(type) :
                                 events.EventEmitter.listenerCount(ee, type);
}

function parseDesignDocFunctionName(s) {
  if (!s) {
    return null;
  }
  var parts = s.split('/');
  if (parts.length === 2) {
    return parts;
  }
  if (parts.length === 1) {
    return [s, s];
  }
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var normalized = parseDesignDocFunctionName(s);
  return normalized ? normalized.join('/') : null;
}

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var qName ="queryKey";
var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
/* eslint maxlen: 0, no-useless-escape: 0 */
var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

function parseUri(str) {
  var m = parser.exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = keys[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[qName] = {};
  uri[keys[12]].replace(qParser, function ($0, $1, $2) {
    if ($1) {
      uri[qName][$1] = $2;
    }
  });

  return uri;
}

// Based on https://github.com/alexdavid/scope-eval v0.0.3
// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
// This is basically just a wrapper around new Function()

function scopeEval(source, scope) {
  var keys = [];
  var values = [];
  for (var key in scope) {
    if (scope.hasOwnProperty(key)) {
      keys.push(key);
      values.push(scope[key]);
    }
  }
  keys.push(source);
  return Function.apply(null, keys).apply(null, values);
}

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    db.get(docId, function (err, doc) {
      if (err) {
        /* istanbul ignore next */
        if (err.status !== 404) {
          return reject(err);
        }
        doc = {};
      }

      // the user might change the _rev, so save it for posterity
      var docRev = doc._rev;
      var newDoc = diffFun(doc);

      if (!newDoc) {
        // if the diffFun returns falsy, we short-circuit as
        // an optimization
        return fulfill({updated: false, rev: docRev});
      }

      // users aren't allowed to modify these values,
      // so reset them here
      newDoc._id = docId;
      newDoc._rev = docRev;
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc).then(function (res) {
    return {
      updated: true,
      rev: res.rev
    };
  }, function (err) {
    /* istanbul ignore next */
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc._id, diffFun);
  });
}

function rev() {
  return v4().replace(/-/g, '').toLowerCase();
}

var uuid = v4;

exports.adapterFun = adapterFun;
exports.assign = assign$1;
exports.bulkGetShim = bulkGet;
exports.changesHandler = Changes;
exports.clone = clone;
exports.defaultBackOff = defaultBackOff;
exports.explainError = explainError;
exports.filterChange = filterChange;
exports.flatten = flatten;
exports.functionName = res$1;
exports.guardedConsole = guardedConsole;
exports.hasLocalStorage = hasLocalStorage;
exports.invalidIdError = invalidIdError;
exports.isChromeApp = isChromeApp;
exports.isCordova = isCordova;
exports.isRemote = isRemote;
exports.listenerCount = listenerCount;
exports.nextTick = immediate;
exports.normalizeDdocFunctionName = normalizeDesignDocFunctionName;
exports.once = once;
exports.parseDdocFunctionName = parseDesignDocFunctionName;
exports.parseUri = parseUri;
exports.pick = pick;
exports.rev = rev;
exports.scopeEval = scopeEval;
exports.toPromise = toPromise;
exports.upsert = upsert;
exports.uuid = uuid;

},{"argsarray":1,"events":18,"immediate":23,"inherits":24,"pouchdb-collections":62,"pouchdb-errors":63,"pouchdb-promise":68,"uuid/v4":117}],68:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58,"lie":40}],69:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))
},{"_process":70}],70:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],71:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],72:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":74,"./_stream_writable":76,"_process":70,"core-util-is":6,"inherits":24}],73:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":75,"core-util-is":6,"inherits":24}],74:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"_process":70,"buffer":5,"core-util-is":6,"events":18,"inherits":24,"isarray":77,"stream":81,"string_decoder/":96}],75:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":72,"core-util-is":6,"inherits":24}],76:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":72,"_process":70,"buffer":5,"core-util-is":6,"inherits":24,"stream":81}],77:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],78:[function(require,module,exports){
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":72,"./lib/_stream_passthrough.js":73,"./lib/_stream_readable.js":74,"./lib/_stream_transform.js":75,"./lib/_stream_writable.js":76,"stream":81}],79:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":5}],80:[function(require,module,exports){
(function (factory) {
    if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals (with support for web workers)
        var glob;

        try {
            glob = window;
        } catch (e) {
            glob = self;
        }

        glob.SparkMD5 = factory();
    }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));

},{}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":18,"inherits":24,"readable-stream/duplex.js":82,"readable-stream/passthrough.js":91,"readable-stream/readable.js":92,"readable-stream/transform.js":93,"readable-stream/writable.js":94}],82:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":83}],83:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":85,"./_stream_writable":87,"core-util-is":6,"inherits":24,"process-nextick-args":69}],84:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":86,"core-util-is":6,"inherits":24}],85:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":83,"./internal/streams/BufferList":88,"./internal/streams/destroy":89,"./internal/streams/stream":90,"_process":70,"core-util-is":6,"events":18,"inherits":24,"isarray":30,"process-nextick-args":69,"safe-buffer":79,"string_decoder/":95,"util":3}],86:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":83,"core-util-is":6,"inherits":24}],87:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":83,"./internal/streams/destroy":89,"./internal/streams/stream":90,"_process":70,"core-util-is":6,"inherits":24,"process-nextick-args":69,"safe-buffer":79,"util-deprecate":111}],88:[function(require,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":79}],89:[function(require,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":69}],90:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":18}],91:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":92}],92:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":83,"./lib/_stream_passthrough.js":84,"./lib/_stream_readable.js":85,"./lib/_stream_transform.js":86,"./lib/_stream_writable.js":87}],93:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":92}],94:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":87}],95:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":79}],96:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":5}],97:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ltgt = _interopDefault(require('ltgt'));
var events = _interopDefault(require('events'));
var inherits = _interopDefault(require('inherits'));
var Codec = _interopDefault(require('level-codec'));
var ReadableStreamCore = _interopDefault(require('readable-stream'));

function isFunction(f) {
  return 'function' === typeof f;
}

function getPrefix(db) {
  if (isFunction(db.prefix)) {
    return db.prefix();
  }
  return db;
}

function clone(_obj) {
  var obj = {};
  for (var k in _obj) {
    obj[k] = _obj[k];
  }
  return obj;
}

function nut(db, precodec, codec) {
  function encodePrefix(prefix, key, opts1, opts2) {
    return precodec.encode([ prefix, codec.encodeKey(key, opts1, opts2 ) ]);
  }

  function addEncodings(op, prefix) {
    if (prefix && prefix.options) {
      op.keyEncoding =
        op.keyEncoding || prefix.options.keyEncoding;
      op.valueEncoding =
        op.valueEncoding || prefix.options.valueEncoding;
    }
    return op;
  }

  db.open(function () { /* no-op */});

  return {
    apply: function (ops, opts, cb) {
      opts = opts || {};

      var batch = [];
      var i = -1;
      var len = ops.length;

      while (++i < len) {
        var op = ops[i];
        addEncodings(op, op.prefix);
        op.prefix = getPrefix(op.prefix);
        batch.push({
          key: encodePrefix(op.prefix, op.key, opts, op),
          value: op.type !== 'del' && codec.encodeValue(op.value, opts, op),
          type: op.type
        });
      }
      db.db.batch(batch, opts, cb);
    },
    get: function (key, prefix, opts, cb) {
      opts.asBuffer = codec.valueAsBuffer(opts);
      return db.db.get(
        encodePrefix(prefix, key, opts),
        opts,
        function (err, value) {
          if (err) {
            cb(err);
          } else {
            cb(null, codec.decodeValue(value, opts));
          }
        }
      );
    },
    createDecoder: function (opts) {
      return function (key, value) {
        return {
          key: codec.decodeKey(precodec.decode(key)[1], opts),
          value: codec.decodeValue(value, opts)
        };
      };
    },
    isClosed: function isClosed() {
      return db.isClosed();
    },
    close: function close(cb) {
      return db.close(cb);
    },
    iterator: function (_opts) {
      var opts = clone(_opts || {});
      var prefix = _opts.prefix || [];

      function encodeKey(key) {
        return encodePrefix(prefix, key, opts, {});
      }

      ltgt.toLtgt(_opts, opts, encodeKey, precodec.lowerBound, precodec.upperBound);

      // if these legacy values are in the options, remove them

      opts.prefix = null;

      //************************************************
      //hard coded defaults, for now...
      //TODO: pull defaults and encoding out of levelup.
      opts.keyAsBuffer = opts.valueAsBuffer = false;
      //************************************************


      //this is vital, otherwise limit: undefined will
      //create an empty stream.
      /* istanbul ignore next */
      if ('number' !== typeof opts.limit) {
        opts.limit = -1;
      }

      opts.keyAsBuffer = precodec.buffer;
      opts.valueAsBuffer = codec.valueAsBuffer(opts);

      function wrapIterator(iterator) {
        return {
          next: function (cb) {
            return iterator.next(cb);
          },
          end: function (cb) {
            iterator.end(cb);
          }
        };
      }

      return wrapIterator(db.db.iterator(opts));
    }
  };
}

function NotFoundError() {
  Error.call(this);
}

inherits(NotFoundError, Error);

NotFoundError.prototype.name = 'NotFoundError';

var EventEmitter = events.EventEmitter;
var version = "6.5.4";

var NOT_FOUND_ERROR = new NotFoundError();

var sublevel = function (nut, prefix, createStream, options) {
  var emitter = new EventEmitter();
  emitter.sublevels = {};
  emitter.options = options;

  emitter.version = version;

  emitter.methods = {};
  prefix = prefix || [];

  function mergeOpts(opts) {
    var o = {};
    var k;
    if (options) {
      for (k in options) {
        if (typeof options[k] !== 'undefined') {
          o[k] = options[k];
        }
      }
    }
    if (opts) {
      for (k in opts) {
        if (typeof opts[k] !== 'undefined') {
          o[k] = opts[k];
        }
      }
    }
    return o;
  }

  emitter.put = function (key, value, opts, cb) {
    if ('function' === typeof opts) {
      cb = opts;
      opts = {};
    }

    nut.apply([{
      key: key, value: value,
      prefix: prefix.slice(), type: 'put'
    }], mergeOpts(opts), function (err) {
      /* istanbul ignore next */
      if (err) {
        return cb(err);
      }
      emitter.emit('put', key, value);
      cb(null);
    });
  };

  emitter.prefix = function () {
    return prefix.slice();
  };

  emitter.batch = function (ops, opts, cb) {
    if ('function' === typeof opts) {
      cb = opts;
      opts = {};
    }

    ops = ops.map(function (op) {
      return {
        key: op.key,
        value: op.value,
        prefix: op.prefix || prefix,
        keyEncoding: op.keyEncoding,    // *
        valueEncoding: op.valueEncoding,  // * (TODO: encodings on sublevel)
        type: op.type
      };
    });

    nut.apply(ops, mergeOpts(opts), function (err) {
      /* istanbul ignore next */
      if (err) {
        return cb(err);
      }
      emitter.emit('batch', ops);
      cb(null);
    });
  };

  emitter.get = function (key, opts, cb) {
    /* istanbul ignore else */
    if ('function' === typeof opts) {
      cb = opts;
      opts = {};
    }
    nut.get(key, prefix, mergeOpts(opts), function (err, value) {
      if (err) {
        cb(NOT_FOUND_ERROR);
      } else {
        cb(null, value);
      }
    });
  };

  emitter.sublevel = function (name, opts) {
    return emitter.sublevels[name] =
      emitter.sublevels[name] || sublevel(nut, prefix.concat(name), createStream, mergeOpts(opts));
  };

  emitter.readStream = emitter.createReadStream = function (opts) {
    opts = mergeOpts(opts);
    opts.prefix = prefix;
    var stream;
    var it = nut.iterator(opts);

    stream = createStream(opts, nut.createDecoder(opts));
    stream.setIterator(it);

    return stream;
  };

  emitter.close = function (cb) {
    nut.close(cb);
  };

  emitter.isOpen = nut.isOpen;
  emitter.isClosed = nut.isClosed;

  return emitter;
};

/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

// NOTE: we are fixed to readable-stream@1.0.x for now
// for pure Streams2 across Node versions
var Readable = ReadableStreamCore.Readable;

function ReadStream(options, makeData) {
  if (!(this instanceof ReadStream)) {
    return new ReadStream(options, makeData);
  }

  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });

  // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref

  this._waiting = false;
  this._options = options;
  this._makeData = makeData;
}

inherits(ReadStream, Readable);

ReadStream.prototype.setIterator = function (it) {
  this._iterator = it;
  /* istanbul ignore if */
  if (this._destroyed) {
    return it.end(function () {});
  }
  /* istanbul ignore if */
  if (this._waiting) {
    this._waiting = false;
    return this._read();
  }
  return this;
};

ReadStream.prototype._read = function read() {
  var self = this;
  /* istanbul ignore if */
  if (self._destroyed) {
    return;
  }
  /* istanbul ignore if */
  if (!self._iterator) {
    return this._waiting = true;
  }

  self._iterator.next(function (err, key, value) {
    if (err || (key === undefined && value === undefined)) {
      if (!err && !self._destroyed) {
        self.push(null);
      }
      return self._cleanup(err);
    }


    value = self._makeData(key, value);
    if (!self._destroyed) {
      self.push(value);
    }
  });
};

ReadStream.prototype._cleanup = function (err) {
  if (this._destroyed) {
    return;
  }

  this._destroyed = true;

  var self = this;
  /* istanbul ignore if */
  if (err) {
    self.emit('error', err);
  }

  /* istanbul ignore else */
  if (self._iterator) {
    self._iterator.end(function () {
      self._iterator = null;
      self.emit('close');
    });
  } else {
    self.emit('close');
  }
};

ReadStream.prototype.destroy = function () {
  this._cleanup();
};

var precodec = {
  encode: function (decodedKey) {
    return '\xff' + decodedKey[0] + '\xff' + decodedKey[1];
  },
  decode: function (encodedKeyAsBuffer) {
    var str = encodedKeyAsBuffer.toString();
    var idx = str.indexOf('\xff', 1);
    return [str.substring(1, idx), str.substring(idx + 1)];
  },
  lowerBound: '\x00',
  upperBound: '\xff'
};

var codec = new Codec();

function sublevelPouch(db) {
  return sublevel(nut(db, precodec, codec), [], ReadStream, db.options);
}

module.exports = sublevelPouch;

},{"events":18,"inherits":24,"level-codec":31,"ltgt":42,"readable-stream":78}],98:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"./_stream_readable":100,"./_stream_writable":102,"core-util-is":6,"dup":83,"inherits":24,"process-nextick-args":69}],99:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"./_stream_transform":101,"core-util-is":6,"dup":84,"inherits":24}],100:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./_stream_duplex":98,"./internal/streams/BufferList":103,"./internal/streams/destroy":104,"./internal/streams/stream":105,"_process":70,"core-util-is":6,"dup":85,"events":18,"inherits":24,"isarray":30,"process-nextick-args":69,"safe-buffer":79,"string_decoder/":108,"util":3}],101:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./_stream_duplex":98,"core-util-is":6,"dup":86,"inherits":24}],102:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"./_stream_duplex":98,"./internal/streams/destroy":104,"./internal/streams/stream":105,"_process":70,"core-util-is":6,"dup":87,"inherits":24,"process-nextick-args":69,"safe-buffer":79,"util-deprecate":111}],103:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"dup":88,"safe-buffer":79}],104:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"process-nextick-args":69}],105:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90,"events":18}],106:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":98,"./lib/_stream_passthrough.js":99,"./lib/_stream_readable.js":100,"./lib/_stream_transform.js":101,"./lib/_stream_writable.js":102,"dup":92}],107:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"./readable":106,"dup":93}],108:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"dup":95,"safe-buffer":79}],109:[function(require,module,exports){
(function (process){
var Transform = require('readable-stream/transform')
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this,require('_process'))
},{"_process":70,"readable-stream/transform":107,"util":114,"xtend":120}],110:[function(require,module,exports){
/**
 * @file Get an object's ES6 @@toStringTag.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring|19.1.3.6 Object.prototype.toString ( )}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-tag-x
 */

'use strict';

var isNull = require('lodash.isnull');
var isUndefined = require('validate.io-undefined');
var toStr = Object.prototype.toString;

/**
 * The `toStringTag` method returns "[object type]", where type is the
 * object type.
 *
 * @param {*} value - The object of which to get the object type string.
 * @returns {string} The object type string.
 * @example
 * var toStringTag = require('to-string-tag-x');
 *
 * var o = new Object();
 * toStringTag(o); // returns '[object Object]'
 */
module.exports = function toStringTag(value) {
  if (isNull(value)) {
    return '[object Null]';
  }

  if (isUndefined(value)) {
    return '[object Undefined]';
  }

  return toStr.call(value);
};

},{"lodash.isnull":41,"validate.io-undefined":118}],111:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],112:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],113:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],114:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":113,"_process":70,"inherits":112}],115:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],116:[function(require,module,exports){
(function (global){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],117:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":115,"./lib/rng":116}],118:[function(require,module,exports){
/**
*
*	VALIDATE: undefined
*
*
*	DESCRIPTION:
*		- Validates if a value is undefined.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isUndefined( value )
*	Validates if a value is undefined.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is undefined
*/
function isUndefined( value ) {
	return value === void 0;
} // end FUNCTION isUndefined()


// EXPORTS //

module.exports = isUndefined;

},{}],119:[function(require,module,exports){
'use strict';

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\t':
      case '\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\d\.\-e\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};

},{}],120:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[59])(59)
});
// INLINED END undefined
  return module.exports;
})();


(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  if (typeof GLOBAL.lively === "undefined") GLOBAL.lively = {};
  if (typeof btoa === "undefined")
    GLOBAL.btoa = function(str) { return new Buffer(str).toString('base64'); };
  if (typeof atob === "undefined")
    GLOBAL.atob = function(str) { return new Buffer(str, 'base64').toString() };
  (function() {
    this.lively = this.lively || {};
(function (exports,_PouchDB,pouchdbAdapterMem,lively_lang,lively_resources) {
'use strict';

_PouchDB = 'default' in _PouchDB ? _PouchDB['default'] : _PouchDB;
pouchdbAdapterMem = 'default' in pouchdbAdapterMem ? pouchdbAdapterMem['default'] : pouchdbAdapterMem;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj$$1) {
  return typeof obj$$1;
} : function (obj$$1) {
  return obj$$1 && typeof Symbol === "function" && obj$$1.constructor === Symbol && obj$$1 !== Symbol.prototype ? "symbol" : typeof obj$$1;
};

var jsx = function () {
  var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7;
  return function createRawReactElement(type, props, key, children) {
    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {};
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  };
}();

var asyncIterator = function (iterable) {
  if (typeof Symbol === "function") {
    if (Symbol.asyncIterator) {
      var method = iterable[Symbol.asyncIterator];
      if (method != null) return method.call(iterable);
    }

    if (Symbol.iterator) {
      return iterable[Symbol.iterator]();
    }
  }

  throw new TypeError("Object is not async iterable");
};

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();

var asyncGeneratorDelegate = function (inner, awaitWrap) {
  var iter = {},
      waiting = false;

  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }

  

  if (typeof Symbol === "function" && Symbol.iterator) {
    iter[Symbol.iterator] = function () {
      return this;
    };
  }

  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }

    return pump("next", value);
  };

  if (typeof inner.throw === "function") {
    iter.throw = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }

      return pump("throw", value);
    };
  }

  if (typeof inner.return === "function") {
    iter.return = function (value) {
      return pump("return", value);
    };
  }

  return iter;
};

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineEnumerableProperties = function (obj$$1, descs) {
  for (var key in descs) {
    var desc = descs[key];
    desc.configurable = desc.enumerable = true;
    if ("value" in desc) desc.writable = true;
    Object.defineProperty(obj$$1, key, desc);
  }

  return obj$$1;
};

var defaults = function (obj$$1, defaults) {
  var keys = Object.getOwnPropertyNames(defaults);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = Object.getOwnPropertyDescriptor(defaults, key);

    if (value && value.configurable && obj$$1[key] === undefined) {
      Object.defineProperty(obj$$1, key, value);
    }
  }

  return obj$$1;
};

var defineProperty = function (obj$$1, key, value) {
  if (key in obj$$1) {
    Object.defineProperty(obj$$1, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj$$1[key] = value;
  }

  return obj$$1;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var _instanceof = function (left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
};

var interopRequireDefault = function (obj$$1) {
  return obj$$1 && obj$$1.__esModule ? obj$$1 : {
    default: obj$$1
  };
};

var interopRequireWildcard = function (obj$$1) {
  if (obj$$1 && obj$$1.__esModule) {
    return obj$$1;
  } else {
    var newObj = {};

    if (obj$$1 != null) {
      for (var key in obj$$1) {
        if (Object.prototype.hasOwnProperty.call(obj$$1, key)) newObj[key] = obj$$1[key];
      }
    }

    newObj.default = obj$$1;
    return newObj;
  }
};

var newArrowCheck = function (innerThis, boundThis) {
  if (innerThis !== boundThis) {
    throw new TypeError("Cannot instantiate an arrow function");
  }
};

var objectDestructuringEmpty = function (obj$$1) {
  if (obj$$1 == null) throw new TypeError("Cannot destructure undefined");
};

var objectWithoutProperties = function (obj$$1, keys) {
  var target = {};

  for (var i in obj$$1) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj$$1, i)) continue;
    target[i] = obj$$1[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var selfGlobal = typeof global === "undefined" ? self : global;

var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var slicedToArrayLoose = function (arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else if (Symbol.iterator in Object(arr)) {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  } else {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
};

var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
};

var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

var temporalRef = function (val, name, undef) {
  if (val === undef) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
};

var temporalUndefined = {};

var toArray = function (arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};



var babelHelpers$1 = Object.freeze({
	jsx: jsx,
	asyncIterator: asyncIterator,
	asyncGenerator: asyncGenerator,
	asyncGeneratorDelegate: asyncGeneratorDelegate,
	asyncToGenerator: asyncToGenerator,
	classCallCheck: classCallCheck,
	createClass: createClass,
	defineEnumerableProperties: defineEnumerableProperties,
	defaults: defaults,
	defineProperty: defineProperty,
	get: get$1,
	inherits: inherits,
	interopRequireDefault: interopRequireDefault,
	interopRequireWildcard: interopRequireWildcard,
	newArrowCheck: newArrowCheck,
	objectDestructuringEmpty: objectDestructuringEmpty,
	objectWithoutProperties: objectWithoutProperties,
	possibleConstructorReturn: possibleConstructorReturn,
	selfGlobal: selfGlobal,
	set: set$1,
	slicedToArray: slicedToArray,
	slicedToArrayLoose: slicedToArrayLoose,
	taggedTemplateLiteral: taggedTemplateLiteral,
	taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,
	temporalRef: temporalRef,
	temporalUndefined: temporalUndefined,
	toArray: toArray,
	toConsumableArray: toConsumableArray,
	typeof: _typeof,
	extends: _extends,
	instanceof: _instanceof
});

/*global global,self,process,System,require*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// PouchDB setup

var GLOBAL = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

var isNode = typeof global !== "undefined" && typeof process !== "undefined";
var PouchDB = _PouchDB;
PouchDB.plugin(pouchdbAdapterMem);

function nodejsRequire(name) {
  if (!isNode) throw new Error("nodejsRequire can only be used in nodejs!");
  if (typeof System !== "undefined") return System._nodeRequire(name);
  return require("module")._load(name);
}

// nodejs_leveldbPath("test")
// nodejs_leveldbPath("file:///Users/robert/Downloads/hackernews-data")
function nodejs_leveldbPath(dbName) {
  // absolute path?
  if (dbName.startsWith("/")) return dbName;
  if (dbName.match(/[^\/]+:\/\//)) {
    if (dbName.startsWith("file:")) dbName = dbName.replace(/^file:\/\//, "");
    return dbName;
  }

  if (!isNode) throw new Error("nodejs_leveldbPath called under non-nodejs environment");
  var basePath = typeof System !== "undefined" && System.baseURL.startsWith("file://") ? System.baseURL.replace("file://", "") : GLOBAL.process.cwd();

  // are we in a typical lively.next env? Meaning serverPath points to
  // lively.next-dir/lively.server. If so, use parent dir of lively.server

  var _nodejsRequire = nodejsRequire("path"),
      join = _nodejsRequire.join,
      _nodejsRequire2 = nodejsRequire("fs"),
      mkdirSync = _nodejsRequire2.mkdirSync,
      existsSync = _nodejsRequire2.existsSync,
      readdirSync = _nodejsRequire2.readdirSync,
      readFileSync = _nodejsRequire2.readFileSync;

  if (dbName.includes("/")) return join(basePath, dbName);

  try {
    var parentPackage = readFileSync(join(basePath, "../package.json")),
        conf = JSON.parse(parentPackage);
    if (conf.name === "lively.web" || conf.name === "lively.next") {
      var _dbDir = join(basePath, "../.livelydbs");
      if (!existsSync(_dbDir)) mkdirSync(_dbDir);
      return join(_dbDir, dbName);
    }
  } catch (e) {}

  var dbDir = join(basePath, ".livelydbs");
  if (!existsSync(dbDir)) mkdirSync(dbDir);
  return join(dbDir, dbName);
}

function nodejs_attemptToLoadProperPouchDB() {
  // We ship lively.storage with a PouchDB dist version that runs everywhere.
  // This version does not support leveldb, the adapter backend that is needed in
  // nodejs for persistence storage.  Here we try to lazily switch to a PouchDB
  // required via node's require.

  if (!isNode) throw new Error("nodejs_attemptToLoadProperPouchDB called under non-nodejs environment");

  if (typeof System !== "undefined") {
    var _System$_nodeRequire = System._nodeRequire("path"),
        join = _System$_nodeRequire.join,
        storageMain = System.normalizeSync("lively.storage/index.js"),
        pouchDBMain = System.normalizeSync("pouchdb", storageMain).replace(/file:\/\//, ""),
        pouchDBNodeMain = join(pouchDBMain, "../../lib/index.js");

    try {
      PouchDB = System._nodeRequire(pouchDBNodeMain);
      PouchDB.plugin(pouchdbAdapterMem);
      return true;
    } catch (e) {
      return false;
    }
  }

  try {
    PouchDB = require("pouchdb");
    PouchDB.plugin(pouchdbAdapterMem);
    return true;
  } catch (err) {
    return false;
  }
}

// var pouch = createPouchDB("test-db"); pouch.adapter;
var createPouchDB = !isNode ? function (name, options) {
  return new PouchDB(_extends({ name: name }, options));
} : function () {
  var properLoadAttempted = false,
      nodejsCouchDBLoaded = false;
  return function createPouchDB(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!properLoadAttempted) {
      properLoadAttempted = true;
      nodejsCouchDBLoaded = nodejs_attemptToLoadProperPouchDB();
    }
    if (!options.adapter) {
      options.adapter = name.startsWith("http") ? "http" : nodejsCouchDBLoaded ? "leveldb" : "memory";
    }
    if (options.adapter == "leveldb") name = nodejs_leveldbPath(name);
    options = _extends({}, options, { name: name });
    return new PouchDB(options);
  };
}();

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// main database interface

var Database = function () {
  createClass(Database, null, [{
    key: "findDB",
    value: function findDB(name) {
      return this.databases.get(name);
    }
  }, {
    key: "ensureDB",
    value: function ensureDB(name, options) {
      var db = this.findDB(name);
      if (db) return db;
      db = new this(name, options);
      this.databases.set(name, db);
      if (!name.endsWith("lively.storage-meta")) this.createMetaEntryForDB(name, options);
      return db;
    }
  }, {
    key: "knownDBs",
    value: function knownDBs(dbName, options) {
      var metaDB = Database.ensureDB("lively.storage-meta");
      return metaDB.getAll().then(function (metaEntries) {
        return metaEntries.map(function (ea) {
          return ea._id;
        });
      });
    }
  }, {
    key: "createMetaEntryForDB",
    value: function createMetaEntryForDB(dbName, options) {
      var metaDB = Database.ensureDB("lively.storage-meta");
      metaDB.has(dbName).then(function (known) {
        return !known && metaDB.set(dbName, { created: Date.now(), options: options });
      });
    }
  }, {
    key: "knowsDB",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(dbName) {
        var db, docCount;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                db = this.ensureDB(dbName);
                _context.next = 3;
                return db.docCount();

              case 3:
                docCount = _context.sent;

                if (!(docCount > 0)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", true);

              case 6:
                _context.next = 8;
                return db.destroy();

              case 8:
                return _context.abrupt("return", false);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function knowsDB(_x2) {
        return _ref.apply(this, arguments);
      }

      return knowsDB;
    }()
  }, {
    key: "PouchDB",
    get: function get() {
      return PouchDB;
    },
    set: function set(klass) {
      PouchDB = klass;
    }
  }, {
    key: "databases",
    get: function get() {
      return this._databases || (this._databases = new Map());
    }
  }]);

  function Database(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, Database);

    this.name = name;
    this.options = options;
    this._pouchdb = null;
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // initialize / release
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  createClass(Database, [{
    key: "close",
    value: function close() {
      // close database to free mem
      if (!this._pouchdb) return;
      this._pouchdb.close();
      delete this._pouchdb;
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return !!this.pouchdb._destroyed;
    }
  }, {
    key: "destroy",
    value: function destroy(opts) {
      // completely get rid of database
      this.constructor.databases.delete(this.name);
      return this.isDestroyed() ? { ok: true } : this.pouchdb.destroy(opts);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing and updating
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "update",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(_id, updateFn, options) {
        var updateAttempt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        var _options, _options$ensure, ensure, _options$retryOnConfl, retryOnConflict, _options$maxUpdateAtt, maxUpdateAttempts, getOpts, db, lastDoc, newDoc, _ref3, id, rev;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Will try to fetch document _id and feed it to updateFn. The result value
                // (promise supported) of updateFn will be used as the next version of
                // document.  If updateFn returns a falsy value the update will be canceled.
                // options: {
                //   ensure: BOOL, // if no document exists, create one, default true
                //   retryOnConflict: BOOL, // if update conflicts retry maxUpdateAttempts
                //                          // times to update doc, default true
                //   maxUpdateAttempts: NUMBER // default 10
                // }
                // returns created document
                options = options || {};

                _options = options, _options$ensure = _options.ensure, ensure = _options$ensure === undefined ? true : _options$ensure, _options$retryOnConfl = _options.retryOnConflict, retryOnConflict = _options$retryOnConfl === undefined ? true : _options$retryOnConfl, _options$maxUpdateAtt = _options.maxUpdateAttempts, maxUpdateAttempts = _options$maxUpdateAtt === undefined ? 10 : _options$maxUpdateAtt, getOpts = { latest: true }, db = this.pouchdb, lastDoc = void 0, newDoc = void 0;

                // 1. get the old doc

                _context2.prev = 2;
                _context2.next = 5;
                return db.get(_id, getOpts);

              case 5:
                lastDoc = _context2.sent;
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);

                if (!(_context2.t0.name !== "not_found" || !ensure)) {
                  _context2.next = 12;
                  break;
                }

                throw _context2.t0;

              case 12:
                _context2.next = 14;
                return updateFn(lastDoc);

              case 14:
                newDoc = _context2.sent;

                if (!(!newDoc || (typeof newDoc === "undefined" ? "undefined" : _typeof(newDoc)) !== "object")) {
                  _context2.next = 17;
                  break;
                }

                return _context2.abrupt("return", null);

              case 17:
                // canceled!

                // ensure _id, _rev props
                if (newDoc._id !== _id) newDoc._id = _id;
                if (lastDoc && newDoc._rev !== lastDoc._rev) newDoc._rev = lastDoc._rev;

                // 3. try writing new doc
                _context2.prev = 19;
                _context2.next = 22;
                return db.put(newDoc);

              case 22:
                _ref3 = _context2.sent;
                id = _ref3.id;
                rev = _ref3.rev;
                return _context2.abrupt("return", Object.assign(newDoc, { _rev: rev }));

              case 28:
                _context2.prev = 28;
                _context2.t1 = _context2["catch"](19);

                if (!(_context2.t1.name === "conflict" && retryOnConflict && updateAttempt < maxUpdateAttempts)) {
                  _context2.next = 32;
                  break;
                }

                return _context2.abrupt("return", this.update(_id, updateFn, options, updateAttempt + 1));

              case 32:
                throw _context2.t1;

              case 33:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8], [19, 28]]);
      }));

      function update(_x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
      }

      return update;
    }()
  }, {
    key: "mixin",
    value: function () {
      var _ref4 = asyncToGenerator(regeneratorRuntime.mark(function _callee3(_id, _mixin, options) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.update(_id, function (oldDoc) {
                  return Object.assign(oldDoc || { _id: _id }, _mixin);
                }, options));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function mixin(_x8, _x9, _x10) {
        return _ref4.apply(this, arguments);
      }

      return mixin;
    }()
  }, {
    key: "set",
    value: function () {
      var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee4(id, value, options) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.update(id, function (_) {
                  return value;
                }, options));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function set$$1(_x11, _x12, _x13) {
        return _ref5.apply(this, arguments);
      }

      return set$$1;
    }()
  }, {
    key: "get",
    value: function () {
      var _ref6 = asyncToGenerator(regeneratorRuntime.mark(function _callee5(id) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                _context5.next = 3;
                return this.pouchdb.get(id, opts);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 6:
                _context5.prev = 6;
                _context5.t0 = _context5["catch"](0);

                if (!(_context5.t0.name === "not_found")) {
                  _context5.next = 10;
                  break;
                }

                return _context5.abrupt("return", undefined);

              case 10:
                throw _context5.t0;

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[0, 6]]);
      }));

      function get$$1(_x14) {
        return _ref6.apply(this, arguments);
      }

      return get$$1;
    }()
  }, {
    key: "has",
    value: function () {
      var _ref7 = asyncToGenerator(regeneratorRuntime.mark(function _callee6(id) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.get(id);

              case 2:
                return _context6.abrupt("return", !!_context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function has(_x16) {
        return _ref7.apply(this, arguments);
      }

      return has;
    }()
  }, {
    key: "add",
    value: function () {
      var _ref8 = asyncToGenerator(regeneratorRuntime.mark(function _callee7(doc) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this.pouchdb.post(doc));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function add(_x17) {
        return _ref8.apply(this, arguments);
      }

      return add;
    }()
  }, {
    key: "docList",
    value: function () {
      var _ref9 = asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var _ref10, rows, result, i, _rows$i, id, rev;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.pouchdb.allDocs(opts);

              case 2:
                _ref10 = _context8.sent;
                rows = _ref10.rows;
                result = [];

                for (i = 0; i < rows.length; i++) {
                  _rows$i = rows[i], id = _rows$i.id, rev = _rows$i.value.rev;

                  result.push({ id: id, rev: rev });
                }
                return _context8.abrupt("return", result);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function docList() {
        return _ref9.apply(this, arguments);
      }

      return docList;
    }()
  }, {
    key: "docCount",
    value: function () {
      var _ref11 = asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
        var entries;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.pouchdb.allDocs();

              case 2:
                entries = _context9.sent;
                return _context9.abrupt("return", entries.rows.length);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function docCount() {
        return _ref11.apply(this, arguments);
      }

      return docCount;
    }()
  }, {
    key: "revList",
    value: function () {
      var _ref12 = asyncToGenerator(regeneratorRuntime.mark(function _callee10(id) {
        var _ref13, _id, _ref13$_revisions, start, ids;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.pouchdb.get(id, { revs: true });

              case 2:
                _ref13 = _context10.sent;
                _id = _ref13._id;
                _ref13$_revisions = _ref13._revisions;
                start = _ref13$_revisions.start;
                ids = _ref13$_revisions.ids;
                return _context10.abrupt("return", ids.map(function (ea) {
                  return start-- + "-" + ea;
                }));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function revList(_x19) {
        return _ref12.apply(this, arguments);
      }

      return revList;
    }()
  }, {
    key: "getAllRevisions",
    value: function () {
      var _ref14 = asyncToGenerator(regeneratorRuntime.mark(function _callee11(id) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _options$skip, skip, _options$limit, limit, revs, query;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _options$skip = options.skip;
                skip = _options$skip === undefined ? 0 : _options$skip;
                _options$limit = options.limit;
                limit = _options$limit === undefined ? 0 : _options$limit;
                _context11.next = 6;
                return this.revList(id);

              case 6:
                revs = _context11.sent;

                if (skip > 0) revs = revs.slice(skip);
                if (limit > 0) revs = revs.slice(0, limit);
                query = revs.map(function (rev) {
                  return { rev: rev, id: id };
                });
                _context11.next = 12;
                return this.getDocuments(query);

              case 12:
                return _context11.abrupt("return", _context11.sent);

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getAllRevisions(_x20) {
        return _ref14.apply(this, arguments);
      }

      return getAllRevisions;
    }()
  }, {
    key: "getAll",
    value: function () {
      var _ref15 = asyncToGenerator(regeneratorRuntime.mark(function _callee12() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var _ref16, rows;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.pouchdb.allDocs(_extends({}, options, { include_docs: true }));

              case 2:
                _ref16 = _context12.sent;
                rows = _ref16.rows;
                return _context12.abrupt("return", rows.map(function (ea) {
                  return ea.doc;
                }));

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getAll() {
        return _ref15.apply(this, arguments);
      }

      return getAll;
    }()
  }, {
    key: "setDocuments",
    value: function () {
      var _ref17 = asyncToGenerator(regeneratorRuntime.mark(function _callee13(documents, opts) {
        var results, i, d, result, _ref18, id, rev;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.pouchdb.bulkDocs(documents, opts);

              case 2:
                results = _context13.sent;
                i = 0;

              case 4:
                if (!(i < results.length)) {
                  _context13.next = 16;
                  break;
                }

                d = documents[i], result = results[i];
                // if a conflict happens and document does not specify the exact revision
                // then just overwrite old doc

                if (!(!result.ok && result.name === "conflict" && !d._rev)) {
                  _context13.next = 13;
                  break;
                }

                _context13.next = 9;
                return this.set(d._id, d);

              case 9:
                _ref18 = _context13.sent;
                id = _ref18._id;
                rev = _ref18._rev;

                results[i] = { ok: true, id: id, rev: rev };

              case 13:
                i++;
                _context13.next = 4;
                break;

              case 16:
                return _context13.abrupt("return", results);

              case 17:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function setDocuments(_x23, _x24) {
        return _ref17.apply(this, arguments);
      }

      return setDocuments;
    }()
  }, {
    key: "updateDocuments",
    value: function () {
      var _ref19 = asyncToGenerator(regeneratorRuntime.mark(function _callee14(documents, conflictFn, opts) {
        var results, tryAgain, resolvedResults, i, d, result, oldDoc, resolved;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.pouchdb.bulkDocs(documents, opts);

              case 2:
                results = _context14.sent;
                tryAgain = [];
                resolvedResults = {};
                i = 0;

              case 6:
                if (!(i < results.length)) {
                  _context14.next = 18;
                  break;
                }

                d = documents[i], result = results[i];
                // if a conflict happens and document does not specify the exact revision
                // then just overwrite old doc

                resolvedResults[result._id || d._id] = result;

                if (!(!result.ok && result.name === "conflict")) {
                  _context14.next = 15;
                  break;
                }

                _context14.next = 12;
                return this.get(d._id);

              case 12:
                oldDoc = _context14.sent;
                resolved = conflictFn(oldDoc, d);

                if (resolved) {
                  if (!resolved._id) resolved._id = d._id;
                  if (!resolved._rev) resolved._rev = oldDoc._rev;
                  tryAgain.push(resolved);
                }

              case 15:
                i++;
                _context14.next = 6;
                break;

              case 18:
                if (!tryAgain.length) {
                  _context14.next = 26;
                  break;
                }

                _context14.t0 = babelHelpers$1;
                _context14.t1 = {};
                _context14.t2 = resolvedResults;
                _context14.next = 24;
                return this.updateDocuments(tryAgain, conflictFn, opts);

              case 24:
                _context14.t3 = _context14.sent;
                resolvedResults = _context14.t0.extends.call(_context14.t0, _context14.t1, _context14.t2, _context14.t3);

              case 26:
                return _context14.abrupt("return", resolvedResults);

              case 27:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function updateDocuments(_x25, _x26, _x27) {
        return _ref19.apply(this, arguments);
      }

      return updateDocuments;
    }()
  }, {
    key: "getDocuments",
    value: function () {
      var _ref20 = asyncToGenerator(regeneratorRuntime.mark(function _callee15(idsAndRevs) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _options$ignoreErrors, ignoreErrors, _ref21, results, result, i, _results$i, docs, id, j, d;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _options$ignoreErrors = options.ignoreErrors;
                ignoreErrors = _options$ignoreErrors === undefined ? true : _options$ignoreErrors;
                _context15.next = 4;
                return this.pouchdb.bulkGet({ docs: idsAndRevs });

              case 4:
                _ref21 = _context15.sent;
                results = _ref21.results;
                result = [];
                i = 0;

              case 8:
                if (!(i < results.length)) {
                  _context15.next = 23;
                  break;
                }

                _results$i = results[i], docs = _results$i.docs, id = _results$i.id;

                console.assert(docs.length === 1, "getDocuments: expected only one doc for " + id);
                j = 0;

              case 12:
                if (!(j < docs.length)) {
                  _context15.next = 20;
                  break;
                }

                d = docs[j];

                if (!(ignoreErrors && !d.ok)) {
                  _context15.next = 16;
                  break;
                }

                return _context15.abrupt("continue", 17);

              case 16:
                result.push(d.ok || d.error || d);

              case 17:
                j++;
                _context15.next = 12;
                break;

              case 20:
                i++;
                _context15.next = 8;
                break;

              case 23:
                return _context15.abrupt("return", result);

              case 24:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getDocuments(_x28) {
        return _ref20.apply(this, arguments);
      }

      return getDocuments;
    }()
  }, {
    key: "query",
    value: function query(subject, opts) {
      return this.pouchdb.query(subject, opts);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // removal
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "remove",
    value: function () {
      var _ref22 = asyncToGenerator(regeneratorRuntime.mark(function _callee16(_id, _rev, options) {
        var arg;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (!(typeof _rev !== "undefined")) {
                  _context16.next = 4;
                  break;
                }

                _context16.t0 = { _id: _id, _rev: _rev };
                _context16.next = 7;
                break;

              case 4:
                _context16.next = 6;
                return this.get(_id);

              case 6:
                _context16.t0 = _context16.sent;

              case 7:
                arg = _context16.t0;
                return _context16.abrupt("return", arg ? this.pouchdb.remove(arg) : undefined);

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function remove(_x30, _x31, _x32) {
        return _ref22.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "removeAll",
    value: function () {
      var _ref23 = asyncToGenerator(regeneratorRuntime.mark(function _callee17() {
        var db, docs;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                db = this.pouchdb;
                _context17.next = 3;
                return db.allDocs();

              case 3:
                docs = _context17.sent;
                _context17.next = 6;
                return Promise.all(docs.rows.map(function (row) {
                  return db.remove(row.id, row.value.rev);
                }));

              case 6:
                return _context17.abrupt("return", _context17.sent);

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function removeAll() {
        return _ref23.apply(this, arguments);
      }

      return removeAll;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // replication + conflicts
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "replicateTo",
    value: function replicateTo(otherDB, opts) {
      // opts: {live, retry}
      if (otherDB instanceof Database) otherDB = otherDB.pouchdb;
      return this.pouchdb.replicate.to(otherDB, opts);
    }
  }, {
    key: "replicateFrom",
    value: function replicateFrom(otherDB, opts) {
      // opts: {live, retry}
      if (otherDB instanceof Database) otherDB = otherDB.pouchdb;
      return this.pouchdb.replicate.from(otherDB, opts);
    }
  }, {
    key: "sync",
    value: function sync(otherDB, opts) {
      // opts: {live, retry}
      if (otherDB instanceof Database) otherDB = otherDB.pouchdb;
      return this.pouchdb.sync(otherDB, opts);
    }
  }, {
    key: "getConflicts",
    value: function () {
      var _ref24 = asyncToGenerator(regeneratorRuntime.mark(function _callee18(opts) {
        var _ref25, rows;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.pouchdb.query({ map: "function(doc) { if (doc._conflicts) emit(doc._id); }" }, _extends({ reduce: false, include_docs: true, conflicts: true }, opts));

              case 2:
                _ref25 = _context18.sent;
                rows = _ref25.rows;
                return _context18.abrupt("return", rows.map(function (ea) {
                  var result = { id: ea.id, rev: ea.doc._rev, doc: ea.doc };
                  if (ea.doc._conflicts) {
                    result.conflicts = ea.doc._conflicts;
                    delete ea.doc._conflicts;
                  }
                  return result;
                }));

              case 5:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getConflicts(_x33) {
        return _ref24.apply(this, arguments);
      }

      return getConflicts;
    }()
  }, {
    key: "resolveConflicts",
    value: function () {
      var _ref26 = asyncToGenerator(regeneratorRuntime.mark(function _callee19(id, resolveFn) {
        var doc, query, conflicted, resolved, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, conflictedDoc;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.pouchdb.get(id, { conflicts: true });

              case 2:
                doc = _context19.sent;
                query = doc._conflicts.map(function (rev) {
                  return { id: id, rev: rev };
                });
                _context19.next = 6;
                return this.getDocuments(query);

              case 6:
                conflicted = _context19.sent;
                resolved = doc;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context19.prev = 11;
                _iterator = conflicted[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context19.next = 28;
                  break;
                }

                conflictedDoc = _step.value;
                _context19.next = 17;
                return resolveFn(resolved, conflictedDoc);

              case 17:
                resolved = _context19.sent;

                if (resolved) {
                  _context19.next = 20;
                  break;
                }

                return _context19.abrupt("return", null);

              case 20:
                _context19.next = 22;
                return this.set(id, resolved);

              case 22:
                resolved = _context19.sent;
                _context19.next = 25;
                return this.pouchdb.remove(conflictedDoc);

              case 25:
                _iteratorNormalCompletion = true;
                _context19.next = 13;
                break;

              case 28:
                _context19.next = 34;
                break;

              case 30:
                _context19.prev = 30;
                _context19.t0 = _context19["catch"](11);
                _didIteratorError = true;
                _iteratorError = _context19.t0;

              case 34:
                _context19.prev = 34;
                _context19.prev = 35;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 37:
                _context19.prev = 37;

                if (!_didIteratorError) {
                  _context19.next = 40;
                  break;
                }

                throw _iteratorError;

              case 40:
                return _context19.finish(37);

              case 41:
                return _context19.finish(34);

              case 42:
                return _context19.abrupt("return", resolved);

              case 43:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this, [[11, 30, 34, 42], [35,, 37, 41]]);
      }));

      function resolveConflicts(_x34, _x35) {
        return _ref26.apply(this, arguments);
      }

      return resolveConflicts;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // diff
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "diffWith",
    value: function () {
      var _ref27 = asyncToGenerator(regeneratorRuntime.mark(function _callee20(otherDB) {
        var docs2, docs1, map2, map1, inLeft, inRight, changed, id, rev, rev1, _id2, _rev2, rev2;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return otherDB.docList();

              case 2:
                docs2 = _context20.sent;
                _context20.next = 5;
                return this.docList();

              case 5:
                docs1 = _context20.sent;
                map2 = docs2.reduce(function (all, ea) {
                  return Object.assign(all, defineProperty({}, ea.id, ea.rev));
                }, {});
                map1 = docs1.reduce(function (all, ea) {
                  return Object.assign(all, defineProperty({}, ea.id, ea.rev));
                }, {});
                inLeft = [];
                inRight = [];
                changed = [];

                for (id in map2) {
                  rev = map2[id];
                  rev1 = map1[id];

                  if (!rev1) inRight.push({ id: id, rev: rev });else if (rev != rev1) changed.push({ right: { id: id, rev: rev }, left: { id: id, rev: rev1 } });
                }
                for (_id2 in map1) {
                  _rev2 = map1[_id2];
                  rev2 = map2[_id2];

                  if (!rev2) inLeft.push({ id: _id2, rev: _rev2 });
                }
                return _context20.abrupt("return", { inLeft: inLeft, inRight: inRight, changed: changed });

              case 14:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function diffWith(_x36) {
        return _ref27.apply(this, arguments);
      }

      return diffWith;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // backup
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "dump",
    value: function () {
      var _ref28 = asyncToGenerator(regeneratorRuntime.mark(function _callee21() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var filterFn, alias, type, dbInfo, myName, pouchdb, name, header, docs;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                filterFn = opts.filterFn;
                alias = opts.name;
                type = opts.type;
                dbInfo = opts.dbInfo;
                myName = this.name;
                pouchdb = this.pouchdb;
                name = alias || myName;
                _context21.t0 = name;
                _context21.t1 = type || pouchdb.type();
                _context21.t2 = new Date().toJSON();
                _context21.t3 = babelHelpers$1;
                _context21.t4 = {};
                _context21.next = 14;
                return pouchdb.info();

              case 14:
                _context21.t5 = _context21.sent;
                _context21.t6 = { db_name: name };
                _context21.t7 = dbInfo;
                _context21.t8 = _context21.t3.extends.call(_context21.t3, _context21.t4, _context21.t5, _context21.t6, _context21.t7);
                header = {
                  name: _context21.t0,
                  db_type: _context21.t1,
                  start_time: _context21.t2,
                  db_info: _context21.t8
                };
                _context21.next = 21;
                return this.getAll({ attachments: true });

              case 21:
                docs = _context21.sent;

                if (typeof filterFn === "function") docs = filterFn(docs, header);
                return _context21.abrupt("return", { header: header, docs: docs });

              case 24:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function dump() {
        return _ref28.apply(this, arguments);
      }

      return dump;
    }()
  }, {
    key: "backup",
    value: function () {
      var _ref29 = asyncToGenerator(regeneratorRuntime.mark(function _callee22() {
        var backupNo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var name, backupDB;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                name = this.name + "_backup_" + backupNo, backupDB = this.constructor.ensureDB(name);
                _context22.next = 3;
                return this.replicateTo(backupDB);

              case 3:
                return _context22.abrupt("return", backupDB);

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function backup() {
        return _ref29.apply(this, arguments);
      }

      return backup;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // migration
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "migrate",
    value: function () {
      var _ref30 = asyncToGenerator(regeneratorRuntime.mark(function _callee23(migrationFn) {
        var docs, migrated, unchanged, i, doc, migratedDoc;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.getAll();

              case 2:
                docs = _context23.sent;
                migrated = [], unchanged = [];
                i = 0;

              case 5:
                if (!(i < docs.length)) {
                  _context23.next = 16;
                  break;
                }

                doc = docs[i], migratedDoc = migrationFn(doc, i);

                if (migratedDoc) {
                  _context23.next = 10;
                  break;
                }

                unchanged.push(doc);return _context23.abrupt("continue", 13);

              case 10:

                if (!migratedDoc.hasOwnProperty("_id")) migratedDoc._id = doc._id;
                if (migratedDoc.hasOwnProperty("_rev")) delete migratedDoc._rev;

                migrated.push(migratedDoc);

              case 13:
                i++;
                _context23.next = 5;
                break;

              case 16:
                _context23.next = 18;
                return this.setDocuments(migrated);

              case 18:
                return _context23.abrupt("return", { migrated: migrated.length, unchanged: unchanged.length });

              case 19:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function migrate(_x39) {
        return _ref30.apply(this, arguments);
      }

      return migrate;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // design docs
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "createDesignDocs",
    value: function createDesignDocs(specs) {
      return specs.map(this.createDesignDoc);
    }
  }, {
    key: "createDesignDoc",
    value: function createDesignDoc(_ref31) {
      var name = _ref31.name,
          mapFn = _ref31.mapFn,
          reduceFn = _ref31.reduceFn,
          filterFn = _ref31.filterFn,
          _ref31$version = _ref31.version,
          version = _ref31$version === undefined ? 1 : _ref31$version;

      var doc = { _id: '_design/' + name, version: version };
      if (filterFn) lively_lang.Path("filters." + name).set(doc, filterFn.toString(), true);
      if (mapFn) lively_lang.Path("views." + name + ".map").set(doc, mapFn.toString(), true);
      if (reduceFn) lively_lang.Path("views." + name + ".reduce").set(doc, reduceFn.toString(), true);
      return doc;
    }
  }, {
    key: "addDesignDocs",
    value: function () {
      var _ref32 = asyncToGenerator(regeneratorRuntime.mark(function _callee24(specs) {
        var _this = this;

        var queryStale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var docs, result;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                docs = this.createDesignDocs(specs);
                _context24.next = 3;
                return this.updateDocuments(docs, function (oldDoc, newDoc) {
                  if (!oldDoc.hasOwnProperty("version")) return newDoc;
                  if (newDoc.hasOwnProperty("version") && newDoc.version > oldDoc.version) return newDoc;
                  return null;
                });

              case 3:
                result = _context24.sent;

                if (!queryStale) {
                  _context24.next = 7;
                  break;
                }

                _context24.next = 7;
                return Promise.all(docs.map(function (ea) {
                  return _this.designDocDoQueryStale(ea._id);
                }));

              case 7:
                return _context24.abrupt("return", result);

              case 8:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function addDesignDocs(_x40) {
        return _ref32.apply(this, arguments);
      }

      return addDesignDocs;
    }()
  }, {
    key: "addDesignDoc",
    value: function () {
      var _ref33 = asyncToGenerator(regeneratorRuntime.mark(function _callee25(_ref34) {
        var name = _ref34.name,
            mapFn = _ref34.mapFn,
            reduceFn = _ref34.reduceFn,
            version = _ref34.version;
        var queryStale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var doc, result;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                doc = this.createDesignDoc({ name: name, mapFn: mapFn, reduceFn: reduceFn, version: version });
                _context25.next = 3;
                return this.set(doc._id, doc);

              case 3:
                result = _context25.sent;

                if (!queryStale) {
                  _context25.next = 7;
                  break;
                }

                _context25.next = 7;
                return this.designDocDoQueryStale(doc._id);

              case 7:
                return _context25.abrupt("return", result);

              case 8:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function addDesignDoc(_x42) {
        return _ref33.apply(this, arguments);
      }

      return addDesignDoc;
    }()
  }, {
    key: "removeDesignDoc",
    value: function removeDesignDoc(name) {
      return this.remove('_design/' + name);
    }
  }, {
    key: "designDocDoQueryStale",
    value: function designDocDoQueryStale(designDocId) {
      var _designDocId$split = designDocId.split("/"),
          _designDocId$split2 = slicedToArray(_designDocId$split, 2),
          _ = _designDocId$split2[0],
          name = _designDocId$split2[1];

      return this.query(name, { stale: 'update_after' });
    }
  }, {
    key: "pouchdb",
    get: function get() {
      // lazy pouch db accessor
      if (this._pouchdb) return this._pouchdb;
      var name = this.name,
          options = this.options;

      return this._pouchdb = createPouchDB(name, options);
    }
  }], [{
    key: "loadDump",
    value: function () {
      var _ref35 = asyncToGenerator(regeneratorRuntime.mark(function _callee26(dump) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var header, docs, name, db;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                header = dump.header, docs = dump.docs, name = opts.name || header.name, db = this.ensureDB(name);
                _context26.next = 3;
                return db.setDocuments(docs, { new_edits: false });

              case 3:
                return _context26.abrupt("return", db);

              case 4:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function loadDump(_x44) {
        return _ref35.apply(this, arguments);
      }

      return loadDump;
    }()
  }]);
  return Database;
}();

/*global System,process,require,fetch*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// sha1
// Author: creationix
// Repo: https://github.com/creationix/git-sha1
// License: MIT https://github.com/creationix/git-sha1/blob/b3474591e6834232df63b5cf9bb969185a54a04c/LICENSE
var sha1 = function sha1_setup() {
  function r(r) {
    if (void 0 === r) return o(!1);var e = o(!0);return e.update(r), e.digest();
  }function e() {
    var r = f.createHash("sha1");return { update: function update(e) {
        return r.update(e);
      }, digest: function digest() {
        return r.digest("hex");
      } };
  }function t(r) {
    function e(r) {
      if ("string" == typeof r) return t(r);var e = r.length;h += 8 * e;for (var n = 0; n < e; n++) {
        o(r[n]);
      }
    }function t(r) {
      var e = r.length;h += 8 * e;for (var t = 0; t < e; t++) {
        o(r.charCodeAt(t));
      }
    }function o(r) {
      a[y] |= (255 & r) << g, g ? g -= 8 : (y++, g = 24), 16 === y && u();
    }function f() {
      o(128), (y > 14 || 14 === y && g < 24) && u(), y = 14, g = 24, o(0), o(0), o(h > 0xffffffffff ? h / 1099511627776 : 0), o(h > 4294967295 ? h / 4294967296 : 0);for (var r = 24; r >= 0; r -= 8) {
        o(h >> r);
      }return i(s) + i(c) + i(v) + i(p) + i(d);
    }function u() {
      for (var r = 16; r < 80; r++) {
        var e = a[r - 3] ^ a[r - 8] ^ a[r - 14] ^ a[r - 16];a[r] = e << 1 | e >>> 31;
      }var t,
          n,
          o = s,
          f = c,
          u = v,
          i = p,
          g = d;for (r = 0; r < 80; r++) {
        r < 20 ? (t = i ^ f & (u ^ i), n = 1518500249) : r < 40 ? (t = f ^ u ^ i, n = 1859775393) : r < 60 ? (t = f & u | i & (f | u), n = 2400959708) : (t = f ^ u ^ i, n = 3395469782);var h = (o << 5 | o >>> 27) + t + g + n + (0 | a[r]);g = i, i = u, u = f << 30 | f >>> 2, f = o, o = h;
      }for (s = s + o | 0, c = c + f | 0, v = v + u | 0, p = p + i | 0, d = d + g | 0, y = 0, r = 0; r < 16; r++) {
        a[r] = 0;
      }
    }function i(r) {
      for (var e = "", t = 28; t >= 0; t -= 4) {
        e += (r >> t & 15).toString(16);
      }return e;
    }var a,
        s = 1732584193,
        c = 4023233417,
        v = 2562383102,
        p = 271733878,
        d = 3285377520,
        y = 0,
        g = 24,
        h = 0;return a = r ? n : new Uint32Array(80), { update: e, digest: f };
  }var n, o, f;return "object" == (typeof process === "undefined" ? "undefined" : _typeof(process)) && "object" == _typeof(process.versions) && process.versions.node && "renderer" !== process.__atom_type ? (f = "undefined" != typeof System ? System._nodeRequire("crypto") : require("crypto"), o = e) : (n = new Uint32Array(80), o = t), r;
}();

var hashRe = /^[0-9a-f]+$/i;
function isHash(string) {
  return typeof string === "string" && string.length === 40 && string.match(hashRe);
}
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// let db = await ObjectDB.find("test-object-db");
// db = objectDBs.get("lively.morphic/objectdb/morphicdb")
// await db.objectStats()

var objectDBs = objectDBs || new Map();

var ObjectDB = function () {
  createClass(ObjectDB, null, [{
    key: "dbList",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var metaDB;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                metaDB = Database.ensureDB("internal__objectdb-meta");
                _context.next = 3;
                return metaDB.getAll();

              case 3:
                _context.t0 = function (ea) {
                  return ea._id;
                };

                return _context.abrupt("return", _context.sent.map(_context.t0));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function dbList() {
        return _ref.apply(this, arguments);
      }

      return dbList;
    }()
  }, {
    key: "find",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(name) {
        var found, metaDB, meta;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                found = objectDBs.get(name);

                if (!found) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", found);

              case 3:
                metaDB = Database.ensureDB("internal__objectdb-meta");
                _context2.next = 6;
                return metaDB.get(name);

              case 6:
                meta = _context2.sent;

                if (meta) {
                  _context2.next = 9;
                  break;
                }

                return _context2.abrupt("return");

              case 9:
                return _context2.abrupt("return", this.named(name, meta));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function find(_x) {
        return _ref2.apply(this, arguments);
      }

      return find;
    }()
  }, {
    key: "named",
    value: function named(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var existing = objectDBs.get(name);
      if (existing) return existing;
      if (!options || !options.snapshotLocation) throw new Error("need snapshotLocation");
      if (typeof options.snapshotLocation === "string") {
        try {
          options.snapshotLocation = lively_resources.resource(options.snapshotLocation);
        } catch (err) {
          options.snapshotLocation = lively_resources.resource(System.baseURL).join(options.snapshotLocation);
        }
      }
      var db = new this(name, options);
      objectDBs.set(name, db);

      var metaDB = Database.ensureDB("internal__objectdb-meta");
      metaDB.set(name, _extends({}, options, { snapshotLocation: options.snapshotLocation.url })).catch(function (err) {
        return console.error("error writing objectdb meta:", err);
      });

      return db;
    }
  }]);

  function ObjectDB(name, options) {
    classCallCheck(this, ObjectDB);

    this.name = name;
    if (!options.snapshotLocation || !options.snapshotLocation.isResource) throw new Error("ObjectDB needs snapshotLocation!");
    this.snapshotLocation = options.snapshotLocation;
    this.__commitDB = null;
    this.__versionDB = null;
  }

  createClass(ObjectDB, [{
    key: "destroy",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
        var commitDB, versionDB, metaDB;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                commitDB = Database.findDB(this.name + "-commits");

                if (!commitDB) {
                  _context3.next = 4;
                  break;
                }

                _context3.next = 4;
                return commitDB.destroy();

              case 4:
                versionDB = Database.findDB(this.name + "-version-graph");

                if (!versionDB) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 8;
                return versionDB.destroy();

              case 8:
                objectDBs.delete(this.name);

                metaDB = Database.ensureDB("internal__objectdb-meta");
                _context3.next = 12;
                return metaDB.remove(this.name);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function destroy() {
        return _ref3.apply(this, arguments);
      }

      return destroy;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // storage

  }, {
    key: "snapshotResourceFor",
    value: function snapshotResourceFor(commit) {
      // content is sha1 hash
      var first = commit.content.slice(0, 2),
          rest = commit.content.slice(2);
      return this.snapshotLocation.join(first + "/" + rest + ".json");
    }
  }, {
    key: "snapshotObject",
    value: function () {
      var _ref4 = asyncToGenerator(regeneratorRuntime.mark(function _callee4(type, name, object, snapshotOptions, commitSpec, preview, ref, expectedPrevVersion) {
        var serializeFn, snapshot;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                snapshotOptions = snapshotOptions || {};

                serializeFn = function serializeFn(x) {
                  return x;
                };

                _context4.next = 4;
                return serializeFn(object, snapshotOptions);

              case 4:
                snapshot = _context4.sent;
                return _context4.abrupt("return", this.commit(type, name, snapshot, commitSpec, preview, ref, expectedPrevVersion));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function snapshotObject(_x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
        return _ref4.apply(this, arguments);
      }

      return snapshotObject;
    }()
  }, {
    key: "loadObject",
    value: function () {
      var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee5(type, name, loadOptions, commitIdOrCommit, ref) {
        var snapshot, deserializeFn;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                loadOptions = loadOptions || {};
                _context5.next = 3;
                return this.loadSnapshot(type, name, commitIdOrCommit, ref);

              case 3:
                snapshot = _context5.sent;

                deserializeFn = function deserializeFn(x) {
                  return x;
                };

                return _context5.abrupt("return", deserializeFn(snapshot, loadOptions));

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function loadObject(_x11, _x12, _x13, _x14, _x15) {
        return _ref5.apply(this, arguments);
      }

      return loadObject;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // data management

  }, {
    key: "has",
    value: function () {
      var _ref6 = asyncToGenerator(regeneratorRuntime.mark(function _callee6(type, name) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.objectStats(type, name);

              case 2:
                return _context6.abrupt("return", !!_context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function has(_x16, _x17) {
        return _ref6.apply(this, arguments);
      }

      return has;
    }()
  }, {
    key: "objects",
    value: function () {
      var _ref7 = asyncToGenerator(regeneratorRuntime.mark(function _callee7(optType) {
        var stats, result, type;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.objectStats(optType);

              case 2:
                stats = _context7.sent;

                if (!optType) {
                  _context7.next = 5;
                  break;
                }

                return _context7.abrupt("return", Object.keys(stats || {}));

              case 5:
                result = {};

                for (type in stats) {
                  result[type] = Object.keys(stats[type]);
                }return _context7.abrupt("return", result);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function objects(_x18) {
        return _ref7.apply(this, arguments);
      }

      return objects;
    }()
  }, {
    key: "objectStats",
    value: function () {
      var _ref8 = asyncToGenerator(regeneratorRuntime.mark(function _callee8(objectType, objectName) {
        var statsByType, commitDB, queryOpts, _ref9, rows, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref11, objectTypeAndName, _ref11$value, count, newest, oldest, _objectTypeAndName$sp, _objectTypeAndName$sp2, type, _objectName, statsOfType;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                statsByType = {};
                _context8.t0 = this.__commitDB;

                if (_context8.t0) {
                  _context8.next = 6;
                  break;
                }

                _context8.next = 5;
                return this._commitDB();

              case 5:
                _context8.t0 = _context8.sent;

              case 6:
                commitDB = _context8.t0;
                queryOpts = { reduce: true, group: true };

                if (objectType && objectName) {
                  queryOpts.key = objectType + "\0" + objectName;
                  // queryOpts.endkey = `${objectType}\u0000${objectName}`;
                } else if (objectType) {
                  // queryOpts.key = objectType;
                  queryOpts.startkey = objectType + "\0";
                  queryOpts.endkey = objectType + "\uFFF0";
                }

                _context8.prev = 9;
                _context8.next = 12;
                return commitDB.pouchdb.query("nameWithMaxMinTimestamp_index", queryOpts);

              case 12:
                _ref9 = _context8.sent;
                rows = _ref9.rows;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context8.prev = 17;

                for (_iterator = rows[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  _ref11 = _step.value;
                  objectTypeAndName = _ref11.key, _ref11$value = _ref11.value, count = _ref11$value.count, newest = _ref11$value.max, oldest = _ref11$value.min;
                  _objectTypeAndName$sp = objectTypeAndName.split("\0"), _objectTypeAndName$sp2 = slicedToArray(_objectTypeAndName$sp, 2), type = _objectTypeAndName$sp2[0], _objectName = _objectTypeAndName$sp2[1], statsOfType = statsByType[type] || (statsByType[type] = {});

                  statsOfType[_objectName] = { count: count, newest: newest, oldest: oldest };
                }
                _context8.next = 25;
                break;

              case 21:
                _context8.prev = 21;
                _context8.t1 = _context8["catch"](17);
                _didIteratorError = true;
                _iteratorError = _context8.t1;

              case 25:
                _context8.prev = 25;
                _context8.prev = 26;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 28:
                _context8.prev = 28;

                if (!_didIteratorError) {
                  _context8.next = 31;
                  break;
                }

                throw _iteratorError;

              case 31:
                return _context8.finish(28);

              case 32:
                return _context8.finish(25);

              case 33:
                _context8.next = 39;
                break;

              case 35:
                _context8.prev = 35;
                _context8.t2 = _context8["catch"](9);

                console.error(_context8.t2);
                return _context8.abrupt("return", statsByType);

              case 39:
                if (!(objectType && objectName)) {
                  _context8.next = 41;
                  break;
                }

                return _context8.abrupt("return", (statsByType[objectType] || {})[objectName]);

              case 41:
                if (!objectType) {
                  _context8.next = 43;
                  break;
                }

                return _context8.abrupt("return", statsByType[objectType]);

              case 43:
                return _context8.abrupt("return", statsByType);

              case 44:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[9, 35], [17, 21, 25, 33], [26,, 28, 32]]);
      }));

      function objectStats(_x19, _x20) {
        return _ref8.apply(this, arguments);
      }

      return objectStats;
    }()
  }, {
    key: "getCommits",
    value: function () {
      var _ref12 = asyncToGenerator(regeneratorRuntime.mark(function _callee9(type, objectName) {
        var ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "HEAD";
        var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
        var history, commitDB, commits;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._log(type, objectName, ref, limit);

              case 2:
                history = _context9.sent;

                if (history.length) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", []);

              case 5:
                _context9.t0 = this.__commitDB;

                if (_context9.t0) {
                  _context9.next = 10;
                  break;
                }

                _context9.next = 9;
                return this._commitDB();

              case 9:
                _context9.t0 = _context9.sent;

              case 10:
                commitDB = _context9.t0;
                _context9.next = 13;
                return commitDB.getDocuments(history.map(function (ea) {
                  return { id: ea };
                }));

              case 13:
                commits = _context9.sent;
                return _context9.abrupt("return", commits);

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getCommits(_x21, _x22) {
        return _ref12.apply(this, arguments);
      }

      return getCommits;
    }()
  }, {
    key: "getCommit",
    value: function () {
      var _ref13 = asyncToGenerator(regeneratorRuntime.mark(function _callee10(commitId) {
        var commitDB;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.t0 = this.__commitDB;

                if (_context10.t0) {
                  _context10.next = 5;
                  break;
                }

                _context10.next = 4;
                return this._commitDB();

              case 4:
                _context10.t0 = _context10.sent;

              case 5:
                commitDB = _context10.t0;
                return _context10.abrupt("return", commitDB.get(commitId));

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getCommit(_x25) {
        return _ref13.apply(this, arguments);
      }

      return getCommit;
    }()
  }, {
    key: "getCommitsWithIds",
    value: function () {
      var _ref14 = asyncToGenerator(regeneratorRuntime.mark(function _callee11(commitIds) {
        var commitDB;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (commitIds.length) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", []);

              case 2:
                _context11.t0 = this.__commitDB;

                if (_context11.t0) {
                  _context11.next = 7;
                  break;
                }

                _context11.next = 6;
                return this._commitDB();

              case 6:
                _context11.t0 = _context11.sent;

              case 7:
                commitDB = _context11.t0;
                return _context11.abrupt("return", commitDB.getDocuments(commitIds.map(function (id) {
                  return { id: id };
                })));

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getCommitsWithIds(_x26) {
        return _ref14.apply(this, arguments);
      }

      return getCommitsWithIds;
    }()
  }, {
    key: "getLatestCommit",
    value: function () {
      var _ref15 = asyncToGenerator(regeneratorRuntime.mark(function _callee12(type, objectName) {
        var ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "HEAD";
        var includeDeleted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var _ref16, _ref17, commitId, commitDB, commit;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._log(type, objectName, ref, 1);

              case 2:
                _ref16 = _context12.sent;
                _ref17 = slicedToArray(_ref16, 1);
                commitId = _ref17[0];

                if (commitId) {
                  _context12.next = 7;
                  break;
                }

                return _context12.abrupt("return", null);

              case 7:
                _context12.t0 = this.__commitDB;

                if (_context12.t0) {
                  _context12.next = 12;
                  break;
                }

                _context12.next = 11;
                return this._commitDB();

              case 11:
                _context12.t0 = _context12.sent;

              case 12:
                commitDB = _context12.t0;
                _context12.next = 15;
                return commitDB.get(commitId);

              case 15:
                commit = _context12.sent;

                if (!(commit && commit.deleted && !includeDeleted)) {
                  _context12.next = 18;
                  break;
                }

                return _context12.abrupt("return", null);

              case 18:
                return _context12.abrupt("return", commit);

              case 19:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getLatestCommit(_x27, _x28) {
        return _ref15.apply(this, arguments);
      }

      return getLatestCommit;
    }()
  }, {
    key: "commit",
    value: function () {
      var _ref18 = asyncToGenerator(regeneratorRuntime.mark(function _callee13(type, name, snapshot, commitSpec, preview) {
        var ref = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "HEAD";
        var expectedPrevVersion = arguments[6];

        var author, _commitSpec$descripti, description, _commitSpec$tags, tags, timestamp, _commitSpec$message, message, metadata, alternativePreview, versionDB, versionData, ancestor, ancestors, snapshotIsHash, snapshotJson, commit, res, commitDB;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                author = commitSpec.author, _commitSpec$descripti = commitSpec.description, description = _commitSpec$descripti === undefined ? "no description" : _commitSpec$descripti, _commitSpec$tags = commitSpec.tags, tags = _commitSpec$tags === undefined ? [] : _commitSpec$tags, timestamp = commitSpec.timestamp, _commitSpec$message = commitSpec.message, message = _commitSpec$message === undefined ? "" : _commitSpec$message, metadata = commitSpec.metadata, alternativePreview = commitSpec.preview;

                if (type) {
                  _context13.next = 3;
                  break;
                }

                throw new Error("object needs a type");

              case 3:
                if (name) {
                  _context13.next = 5;
                  break;
                }

                throw new Error("object needs a name");

              case 5:
                if (author) {
                  _context13.next = 7;
                  break;
                }

                throw new Error("Cannot commit " + type + "/" + name + " without user");

              case 7:
                _context13.t0 = this.__versionDB;

                if (_context13.t0) {
                  _context13.next = 12;
                  break;
                }

                _context13.next = 11;
                return this._versionDB();

              case 11:
                _context13.t0 = _context13.sent;

              case 12:
                versionDB = _context13.t0;
                _context13.next = 15;
                return this.versionGraph(type, name);

              case 15:
                versionData = _context13.sent;
                ancestor = versionData ? versionData.refs[ref] : null;
                ancestors = ancestor ? [ancestor] : [];

                if (!expectedPrevVersion) {
                  _context13.next = 23;
                  break;
                }

                if (versionData) {
                  _context13.next = 21;
                  break;
                }

                throw new Error("Trying to store \"" + type + "/" + name + "\" on top of expected version " + expectedPrevVersion + " but no version entry exists!");

              case 21:
                if (!(ancestor !== expectedPrevVersion)) {
                  _context13.next = 23;
                  break;
                }

                throw new Error("Trying to store \"" + type + "/" + name + "\" on top of expected version " + expectedPrevVersion + " but ref " + ref + " is of version " + ancestor + "!");

              case 23:

                // Snapshot object and create commit.
                snapshotIsHash = isHash(snapshot), snapshotJson = snapshotIsHash ? null : snapshot ? JSON.stringify(snapshot) : null, commit = this._createCommit(type, name, description, tags, metadata, author, timestamp, message, ancestors, snapshotIsHash ? null : snapshot, snapshotJson, preview || alternativePreview, snapshotIsHash ? snapshot : null);

                // write snapshot to resource

                if (!(snapshot && !snapshotIsHash)) {
                  _context13.next = 35;
                  break;
                }

                res = this.snapshotResourceFor(commit);
                _context13.next = 28;
                return res.parent().ensureExistance();

              case 28:
                if (!res.canDealWithJSON) {
                  _context13.next = 33;
                  break;
                }

                _context13.next = 31;
                return res.writeJson(snapshot);

              case 31:
                _context13.next = 35;
                break;

              case 33:
                _context13.next = 35;
                return res.write(snapshotJson);

              case 35:
                _context13.t1 = this.__commitDB;

                if (_context13.t1) {
                  _context13.next = 40;
                  break;
                }

                _context13.next = 39;
                return this._commitDB();

              case 39:
                _context13.t1 = _context13.sent;

              case 40:
                commitDB = _context13.t1;
                _context13.next = 43;
                return commitDB.set(commit._id, commit);

              case 43:
                commit = _context13.sent;


                // update version graph
                if (!versionData) versionData = { refs: {}, history: {} };
                versionData.refs[ref] = commit._id;
                versionData.history[commit._id] = ancestors;
                _context13.next = 49;
                return versionDB.set(type + "/" + name, versionData);

              case 49:
                return _context13.abrupt("return", commit);

              case 50:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function commit(_x31, _x32, _x33, _x34, _x35) {
        return _ref18.apply(this, arguments);
      }

      return commit;
    }()
  }, {
    key: "loadSnapshot",
    value: function () {
      var _ref19 = asyncToGenerator(regeneratorRuntime.mark(function _callee14(type, name, commitOrId) {
        var ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "HEAD";
        var commit, commitDB;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                commit = void 0;

                if (!(commitOrId && typeof commitOrId !== "string")) {
                  _context14.next = 5;
                  break;
                }

                commit = commitOrId;
                _context14.next = 20;
                break;

              case 5:
                if (!commitOrId) {
                  _context14.next = 17;
                  break;
                }

                _context14.t0 = this.__commitDB;

                if (_context14.t0) {
                  _context14.next = 11;
                  break;
                }

                _context14.next = 10;
                return this._commitDB();

              case 10:
                _context14.t0 = _context14.sent;

              case 11:
                commitDB = _context14.t0;
                _context14.next = 14;
                return commitDB.get(commitOrId);

              case 14:
                commit = _context14.sent;
                _context14.next = 20;
                break;

              case 17:
                _context14.next = 19;
                return this.getLatestCommit(type, name, ref);

              case 19:
                commit = _context14.sent;

              case 20:
                if (commit) {
                  _context14.next = 22;
                  break;
                }

                throw new Error("Cannot find commit to loadSnapshot for " + type + "/" + name + " (using " + commitOrId + ")");

              case 22:
                return _context14.abrupt("return", this.snapshotResourceFor(commit).readJson());

              case 23:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function loadSnapshot(_x37, _x38, _x39) {
        return _ref19.apply(this, arguments);
      }

      return loadSnapshot;
    }()
  }, {
    key: "revert",
    value: function () {
      var _ref20 = asyncToGenerator(regeneratorRuntime.mark(function _callee15(type, name, ref, toCommitId) {
        var versionDB, history;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.t0 = this.__versionDB;

                if (_context15.t0) {
                  _context15.next = 5;
                  break;
                }

                _context15.next = 4;
                return this._versionDB();

              case 4:
                _context15.t0 = _context15.sent;

              case 5:
                versionDB = _context15.t0;
                _context15.next = 8;
                return versionDB.get(type + "/" + name);

              case 8:
                history = _context15.sent;

                history.refs[ref || "HEAD"] = toCommitId;
                delete history.deleted;
                _context15.next = 13;
                return versionDB.set(type + "/" + name, history);

              case 13:
                return _context15.abrupt("return", history);

              case 14:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function revert(_x41, _x42, _x43, _x44) {
        return _ref20.apply(this, arguments);
      }

      return revert;
    }()
  }, {
    key: "_createCommit",
    value: function _createCommit(type, name, description, tags, metadata, author, timestamp) {
      var message = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "";
      var ancestors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
      var snapshot = arguments[9];
      var snapshotJson = arguments[10];
      var preview = arguments[11];
      var content = arguments[12];

      if (!preview && snapshot && snapshot.preview) preview = snapshot.preview;
      return this._createCommitFromSpec({
        name: name, type: type,
        timestamp: timestamp || Date.now(),
        author: {
          name: author.name,
          email: author.email,
          realm: author.realm
        },
        tags: tags, description: description, preview: preview,
        message: message,
        content: content || snapshotJson && sha1(snapshotJson) || null,
        deleted: !content && !snapshot,
        metadata: metadata, ancestors: ancestors
      }, true);
    }
  }, {
    key: "_createCommitFromSpec",
    value: function _createCommitFromSpec(commit) {
      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!commit.name) throw new Error("commit needs name");
      if (!commit.type) throw new Error("commit needs type");
      if (!commit.author) throw new Error("commit needs author");
      if (!commit.author.name) throw new Error("commit needs author.name");
      if (!commit.timestamp) commit.timestamp = Date.now();
      if (!commit.tags) commit.tags = [];

      if (!isHashed && commit.content) {
        isHashed = isHash(commit.content);
        if (!isHashed) commit.content = sha1(commit.content);
      }
      var hashObj = lively_lang.obj.dissoc(commit, ["preview"]),
          commitHash = sha1(JSON.stringify(hashObj));
      return Object.assign(commit, { _id: commitHash });
    }
  }, {
    key: "_commitDB",
    value: function () {
      var _ref21 = asyncToGenerator(regeneratorRuntime.mark(function _callee16() {
        var dbName, db;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (!this.__commitDB) {
                  _context16.next = 2;
                  break;
                }

                return _context16.abrupt("return", this.__commitDB);

              case 2:
                dbName = this.name + "-commits", db = Database.findDB(dbName);

                if (!db) {
                  _context16.next = 5;
                  break;
                }

                return _context16.abrupt("return", this.__commitDB = db);

              case 5:

                db = Database.ensureDB(dbName);

                // prepare indexes

                _context16.next = 8;
                return db.addDesignDocs(this._commitdb_indexes);

              case 8:
                return _context16.abrupt("return", this.__commitDB = db);

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _commitDB() {
        return _ref21.apply(this, arguments);
      }

      return _commitDB;
    }()
  }, {
    key: "close",
    value: function () {
      var _ref22 = asyncToGenerator(regeneratorRuntime.mark(function _callee17() {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!this.__commitDB) {
                  _context17.next = 4;
                  break;
                }

                _context17.next = 3;
                return this.__commitDB.close();

              case 3:
                this.__commitDB = null;

              case 4:
                if (!this.__versionDB) {
                  _context17.next = 8;
                  break;
                }

                _context17.next = 7;
                return this.__versionDB.close();

              case 7:
                this.__versionDB = null;

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function close() {
        return _ref22.apply(this, arguments);
      }

      return close;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // versioning

  }, {
    key: "versionGraph",
    value: function () {
      var _ref23 = asyncToGenerator(regeneratorRuntime.mark(function _callee18(type, objectName) {
        var versionDB, graph;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.t0 = this.__versionDB;

                if (_context18.t0) {
                  _context18.next = 5;
                  break;
                }

                _context18.next = 4;
                return this._versionDB();

              case 4:
                _context18.t0 = _context18.sent;

              case 5:
                versionDB = _context18.t0;
                _context18.next = 8;
                return versionDB.get(type + "/" + objectName);

              case 8:
                graph = _context18.sent;
                return _context18.abrupt("return", !graph || graph.deleted || graph._deleted ? null : graph);

              case 10:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function versionGraph(_x48, _x49) {
        return _ref23.apply(this, arguments);
      }

      return versionGraph;
    }()
  }, {
    key: "_log",
    value: function () {
      var _ref24 = asyncToGenerator(regeneratorRuntime.mark(function _callee19(type, objectName) {
        var ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "HEAD";
        var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

        var data, version, history, _ref25, _ref26;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.versionGraph(type, objectName);

              case 2:
                data = _context19.sent;

                if (!(!data || data.deleted || data._deleted)) {
                  _context19.next = 5;
                  break;
                }

                return _context19.abrupt("return", []);

              case 5:
                version = data.refs.HEAD, history = [];

              case 6:
                

                if (!history.includes(version)) {
                  _context19.next = 9;
                  break;
                }

                throw new Error("cyclic version graph???");

              case 9:
                history.push(version);
                // FIXME what about multiple ancestors?
                _ref25 = data.history[version] || [];
                _ref26 = slicedToArray(_ref25, 1);
                version = _ref26[0];

                if (!(!version || history.length >= limit)) {
                  _context19.next = 15;
                  break;
                }

                return _context19.abrupt("break", 17);

              case 15:
                _context19.next = 6;
                break;

              case 17:
                return _context19.abrupt("return", history);

              case 18:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _log(_x50, _x51) {
        return _ref24.apply(this, arguments);
      }

      return _log;
    }()
  }, {
    key: "_findTimestampedVersionsOfObjectNamed",
    value: function () {
      var _ref27 = asyncToGenerator(regeneratorRuntime.mark(function _callee20(objectName) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _options$include_docs, include_docs, _options$descending, descending, _options$startTime, startTime, _options$endTime, endTime, startkey, endkey, objectDB, _ref28, rows;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _options$include_docs = options.include_docs;
                include_docs = _options$include_docs === undefined ? true : _options$include_docs;
                _options$descending = options.descending;
                descending = _options$descending === undefined ? true : _options$descending;
                _options$startTime = options.startTime;
                startTime = _options$startTime === undefined ? "0".repeat(13) : _options$startTime;
                _options$endTime = options.endTime;
                endTime = _options$endTime === undefined ? "9".repeat(13) : _options$endTime;
                startkey = objectName + "\0" + (descending ? endTime : startTime);
                endkey = objectName + "\0" + (descending ? startTime : endTime);
                _context20.t0 = this.__commitDB;

                if (_context20.t0) {
                  _context20.next = 15;
                  break;
                }

                _context20.next = 14;
                return this._commitDB();

              case 14:
                _context20.t0 = _context20.sent;

              case 15:
                objectDB = _context20.t0;
                _context20.next = 18;
                return objectDB.pouchdb.query("nameAndTimestamp_index", _extends({}, options, {
                  descending: descending,
                  include_docs: include_docs,
                  startkey: startkey,
                  endkey: endkey
                }));

              case 18:
                _ref28 = _context20.sent;
                rows = _ref28.rows;
                return _context20.abrupt("return", include_docs ? rows.map(function (ea) {
                  return ea.doc;
                }) : rows.map(function (ea) {
                  return ea.id;
                }));

              case 21:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _findTimestampedVersionsOfObjectNamed(_x54) {
        return _ref27.apply(this, arguments);
      }

      return _findTimestampedVersionsOfObjectNamed;
    }()
  }, {
    key: "_versionDB",
    value: function () {
      var _ref29 = asyncToGenerator(regeneratorRuntime.mark(function _callee21() {
        var dbName, db;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!this.__versionDB) {
                  _context21.next = 2;
                  break;
                }

                return _context21.abrupt("return", this.__versionDB);

              case 2:
                dbName = this.name + "-version-graph", db = Database.findDB(dbName);

                if (!db) {
                  _context21.next = 5;
                  break;
                }

                return _context21.abrupt("return", this.__versionDB = db);

              case 5:
                db = Database.ensureDB(dbName);
                _context21.next = 8;
                return db.addDesignDocs(this._versiondb_indexes);

              case 8:
                return _context21.abrupt("return", this.__versionDB = db);

              case 9:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _versionDB() {
        return _ref29.apply(this, arguments);
      }

      return _versionDB;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // export

  }, {
    key: "exportToDir",
    value: function () {
      var _ref30 = asyncToGenerator(regeneratorRuntime.mark(function _callee22(exportDir, nameAndTypes) {
        var _this = this;

        var copyResources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var includeDeleted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var commitDB, versionDB, backupData, versions, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ref32, refs, history, _id, _ref33, type, name, currentExportDir, commitIds, commits, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _ref35, _ref36, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _loop, _iterator4, _step4;

        return regeneratorRuntime.wrap(function _callee22$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:

                if (typeof exportDir === "string") exportDir = lively_resources.resource(exportDir);

                _context23.t0 = this.__commitDB;

                if (_context23.t0) {
                  _context23.next = 6;
                  break;
                }

                _context23.next = 5;
                return this._commitDB();

              case 5:
                _context23.t0 = _context23.sent;

              case 6:
                commitDB = _context23.t0;
                _context23.t1 = this.__versionDB;

                if (_context23.t1) {
                  _context23.next = 12;
                  break;
                }

                _context23.next = 11;
                return this._versionDB();

              case 11:
                _context23.t1 = _context23.sent;

              case 12:
                versionDB = _context23.t1;
                backupData = [];

                if (nameAndTypes) {
                  _context23.next = 58;
                  break;
                }

                _context23.next = 17;
                return versionDB.getAll();

              case 17:
                versions = _context23.sent;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context23.prev = 21;
                _iterator2 = versions[Symbol.iterator]();

              case 23:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context23.next = 42;
                  break;
                }

                _ref32 = _step2.value;
                refs = _ref32.refs, history = _ref32.history, _id = _ref32._id;

                if (!_id.startsWith("_")) {
                  _context23.next = 28;
                  break;
                }

                return _context23.abrupt("continue", 39);

              case 28:
                _context23.next = 30;
                return this.getCommit(refs.HEAD || Object.keys(history)[0]);

              case 30:
                _ref33 = _context23.sent;
                type = _ref33.type;
                name = _ref33.name;
                currentExportDir = exportDir.join(type).join(name).asDirectory();
                commitIds = Object.keys(history);
                _context23.next = 37;
                return this.getCommitsWithIds(commitIds);

              case 37:
                commits = _context23.sent;

                backupData.push({ refs: refs, history: history, currentExportDir: currentExportDir, commits: commits, name: name, type: type });

              case 39:
                _iteratorNormalCompletion2 = true;
                _context23.next = 23;
                break;

              case 42:
                _context23.next = 48;
                break;

              case 44:
                _context23.prev = 44;
                _context23.t2 = _context23["catch"](21);
                _didIteratorError2 = true;
                _iteratorError2 = _context23.t2;

              case 48:
                _context23.prev = 48;
                _context23.prev = 49;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 51:
                _context23.prev = 51;

                if (!_didIteratorError2) {
                  _context23.next = 54;
                  break;
                }

                throw _iteratorError2;

              case 54:
                return _context23.finish(51);

              case 55:
                return _context23.finish(48);

              case 56:
                _context23.next = 94;
                break;

              case 58:
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context23.prev = 61;
                _iterator3 = nameAndTypes[Symbol.iterator]();

              case 63:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context23.next = 80;
                  break;
                }

                _ref35 = _step3.value;
                name = _ref35.name, type = _ref35.type;
                currentExportDir = exportDir.join(type).join(name).asDirectory();
                _context23.next = 69;
                return this.versionGraph(type, name);

              case 69:
                _ref36 = _context23.sent;
                refs = _ref36.refs;
                history = _ref36.history;
                commitIds = Object.keys(history);
                _context23.next = 75;
                return this.getCommitsWithIds(commitIds);

              case 75:
                commits = _context23.sent;

                backupData.push({ refs: refs, history: history, currentExportDir: currentExportDir, commits: commits, name: name, type: type });

              case 77:
                _iteratorNormalCompletion3 = true;
                _context23.next = 63;
                break;

              case 80:
                _context23.next = 86;
                break;

              case 82:
                _context23.prev = 82;
                _context23.t3 = _context23["catch"](61);
                _didIteratorError3 = true;
                _iteratorError3 = _context23.t3;

              case 86:
                _context23.prev = 86;
                _context23.prev = 87;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 89:
                _context23.prev = 89;

                if (!_didIteratorError3) {
                  _context23.next = 92;
                  break;
                }

                throw _iteratorError3;

              case 92:
                return _context23.finish(89);

              case 93:
                return _context23.finish(86);

              case 94:
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context23.prev = 97;
                _loop = regeneratorRuntime.mark(function _loop() {
                  var _ref37, refs, history, currentExportDir, commits, name, type, resourcesForCopy, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _ref39, from, to;

                  return regeneratorRuntime.wrap(function _loop$(_context22) {
                    while (1) {
                      switch (_context22.prev = _context22.next) {
                        case 0:
                          _ref37 = _step4.value;
                          refs = _ref37.refs, history = _ref37.history, currentExportDir = _ref37.currentExportDir, commits = _ref37.commits, name = _ref37.name, type = _ref37.type;

                          if (!includeDeleted) commits = commits.filter(function (ea) {
                            return !ea.deleted;
                          });

                          resourcesForCopy = copyResources ? commits.map(function (commit) {
                            if (commit.deleted || commit._deleted || !commit.content) return null;
                            delete commit._rev;
                            var from = _this.snapshotResourceFor(commit),
                                to = currentExportDir.join(from.parent().name() + "/" + from.name());
                            return { from: from, to: to };
                          }).filter(Boolean) : [];


                          if (!copyResources) commits.forEach(function (commit) {
                            delete commit._rev;
                          });
                          _context22.next = 7;
                          return currentExportDir.ensureExistance();

                        case 7:
                          _context22.next = 9;
                          return currentExportDir.join("index.json").writeJson({ name: name, type: type });

                        case 9:
                          _context22.next = 11;
                          return currentExportDir.join("commits.json").writeJson(commits);

                        case 11:
                          _context22.next = 13;
                          return currentExportDir.join("history.json").writeJson({ refs: refs, history: history });

                        case 13:
                          _iteratorNormalCompletion5 = true;
                          _didIteratorError5 = false;
                          _iteratorError5 = undefined;
                          _context22.prev = 16;
                          _iterator5 = resourcesForCopy[Symbol.iterator]();

                        case 18:
                          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                            _context22.next = 26;
                            break;
                          }

                          _ref39 = _step5.value;
                          from = _ref39.from, to = _ref39.to;
                          _context22.next = 23;
                          return from.copyTo(to);

                        case 23:
                          _iteratorNormalCompletion5 = true;
                          _context22.next = 18;
                          break;

                        case 26:
                          _context22.next = 32;
                          break;

                        case 28:
                          _context22.prev = 28;
                          _context22.t0 = _context22["catch"](16);
                          _didIteratorError5 = true;
                          _iteratorError5 = _context22.t0;

                        case 32:
                          _context22.prev = 32;
                          _context22.prev = 33;

                          if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                          }

                        case 35:
                          _context22.prev = 35;

                          if (!_didIteratorError5) {
                            _context22.next = 38;
                            break;
                          }

                          throw _iteratorError5;

                        case 38:
                          return _context22.finish(35);

                        case 39:
                          return _context22.finish(32);

                        case 40:
                        case "end":
                          return _context22.stop();
                      }
                    }
                  }, _loop, _this, [[16, 28, 32, 40], [33,, 35, 39]]);
                });
                _iterator4 = backupData[Symbol.iterator]();

              case 100:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                  _context23.next = 105;
                  break;
                }

                return _context23.delegateYield(_loop(), "t4", 102);

              case 102:
                _iteratorNormalCompletion4 = true;
                _context23.next = 100;
                break;

              case 105:
                _context23.next = 111;
                break;

              case 107:
                _context23.prev = 107;
                _context23.t5 = _context23["catch"](97);
                _didIteratorError4 = true;
                _iteratorError4 = _context23.t5;

              case 111:
                _context23.prev = 111;
                _context23.prev = 112;

                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }

              case 114:
                _context23.prev = 114;

                if (!_didIteratorError4) {
                  _context23.next = 117;
                  break;
                }

                throw _iteratorError4;

              case 117:
                return _context23.finish(114);

              case 118:
                return _context23.finish(111);

              case 119:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee22, this, [[21, 44, 48, 56], [49,, 51, 55], [61, 82, 86, 94], [87,, 89, 93], [97, 107, 111, 119], [112,, 114, 118]]);
      }));

      function exportToDir(_x56, _x57) {
        return _ref30.apply(this, arguments);
      }

      return exportToDir;
    }()
  }, {
    key: "exportToSpecs",
    value: function () {
      var _ref40 = asyncToGenerator(regeneratorRuntime.mark(function _callee23(nameAndTypes) {
        var includeDeleted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var specs, stats, type, name, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, _ref42, _name, _type, _ref43, refs, history, commitIds, commits;

        return regeneratorRuntime.wrap(function _callee23$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                // note: only version data, no snapshots!
                specs = [];

                if (nameAndTypes) {
                  _context24.next = 10;
                  break;
                }

                // = everything
                nameAndTypes = [];
                _context24.next = 5;
                return this.objectStats();

              case 5:
                _context24.t0 = _context24.sent;

                if (_context24.t0) {
                  _context24.next = 8;
                  break;
                }

                _context24.t0 = {};

              case 8:
                stats = _context24.t0;

                for (type in stats) {
                  for (name in stats[type]) {
                    nameAndTypes.push({ type: type, name: name });
                  }
                }

              case 10:
                _iteratorNormalCompletion6 = true;
                _didIteratorError6 = false;
                _iteratorError6 = undefined;
                _context24.prev = 13;
                _iterator6 = nameAndTypes[Symbol.iterator]();

              case 15:
                if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                  _context24.next = 33;
                  break;
                }

                _ref42 = _step6.value;
                _name = _ref42.name, _type = _ref42.type;
                _context24.next = 20;
                return this.versionGraph(_type, _name);

              case 20:
                _ref43 = _context24.sent;
                refs = _ref43.refs;
                history = _ref43.history;
                commitIds = Object.keys(history);
                _context24.next = 26;
                return this.getCommitsWithIds(commitIds);

              case 26:
                commits = _context24.sent;

                if (!includeDeleted) commits = commits.filter(function (ea) {
                  return !ea.deleted;
                });
                commits.forEach(function (commit) {
                  delete commit._rev;
                });
                specs.push({ type: _type, name: _name, commits: commits, history: { refs: refs, history: history } });

              case 30:
                _iteratorNormalCompletion6 = true;
                _context24.next = 15;
                break;

              case 33:
                _context24.next = 39;
                break;

              case 35:
                _context24.prev = 35;
                _context24.t1 = _context24["catch"](13);
                _didIteratorError6 = true;
                _iteratorError6 = _context24.t1;

              case 39:
                _context24.prev = 39;
                _context24.prev = 40;

                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }

              case 42:
                _context24.prev = 42;

                if (!_didIteratorError6) {
                  _context24.next = 45;
                  break;
                }

                throw _iteratorError6;

              case 45:
                return _context24.finish(42);

              case 46:
                return _context24.finish(39);

              case 47:
                return _context24.abrupt("return", specs);

              case 48:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee23, this, [[13, 35, 39, 47], [40,, 42, 46]]);
      }));

      function exportToSpecs(_x60) {
        return _ref40.apply(this, arguments);
      }

      return exportToSpecs;
    }()
  }, {
    key: "importFromDir",
    value: function () {
      var _ref44 = asyncToGenerator(regeneratorRuntime.mark(function _callee25(importDir) {
        var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

        var findImportDataIn = function () {
          var _ref45 = asyncToGenerator(regeneratorRuntime.mark(function _callee24(dir) {
            var _ref46, _ref47, _ref47$, type, name, commits, history, snapshotDirs;

            return regeneratorRuntime.wrap(function _callee24$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    _context25.next = 2;
                    return Promise.all([dir.join("index.json").readJson(), dir.join("commits.json").readJson(), dir.join("history.json").readJson()]);

                  case 2:
                    _ref46 = _context25.sent;
                    _ref47 = slicedToArray(_ref46, 3);
                    _ref47$ = _ref47[0];
                    type = _ref47$.type;
                    name = _ref47$.name;
                    commits = _ref47[1];
                    history = _ref47[2];

                    if (!copyResources) {
                      _context25.next = 15;
                      break;
                    }

                    _context25.next = 12;
                    return dir.dirList(1, { exclude: function exclude(ea) {
                        return !ea.isDirectory();
                      } });

                  case 12:
                    _context25.t0 = _context25.sent;
                    _context25.next = 16;
                    break;

                  case 15:
                    _context25.t0 = [];

                  case 16:
                    snapshotDirs = _context25.t0;
                    return _context25.abrupt("return", { dir: dir, type: type, name: name, commits: commits, history: history, snapshotDirs: snapshotDirs });

                  case 18:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee24, this);
          }));

          return function findImportDataIn(_x65) {
            return _ref45.apply(this, arguments);
          };
        }();

        var copyResources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var indexes, dirs, snapshotLocation, importSpecs, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, dir;

        return regeneratorRuntime.wrap(function _callee25$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return importDir.dirList(3, { exclude: function exclude(ea) {
                    return !ea.isDirectory() && ea.name() !== "index.json";
                  } });

              case 2:
                indexes = _context26.sent;


                indexes = indexes.filter(function (ea) {
                  return ea.name() === "index.json";
                }); // FIXME!
                dirs = indexes.map(function (ea) {
                  return ea.parent();
                });
                snapshotLocation = this.snapshotLocation, importSpecs = [];

                // 2. retrieve import data

                _iteratorNormalCompletion7 = true;
                _didIteratorError7 = false;
                _iteratorError7 = undefined;
                _context26.prev = 9;
                _iterator7 = dirs[Symbol.iterator]();

              case 11:
                if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
                  _context26.next = 21;
                  break;
                }

                dir = _step7.value;
                _context26.t0 = importSpecs;
                _context26.next = 16;
                return findImportDataIn(dir);

              case 16:
                _context26.t1 = _context26.sent;

                _context26.t0.push.call(_context26.t0, _context26.t1);

              case 18:
                _iteratorNormalCompletion7 = true;
                _context26.next = 11;
                break;

              case 21:
                _context26.next = 27;
                break;

              case 23:
                _context26.prev = 23;
                _context26.t2 = _context26["catch"](9);
                _didIteratorError7 = true;
                _iteratorError7 = _context26.t2;

              case 27:
                _context26.prev = 27;
                _context26.prev = 28;

                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }

              case 30:
                _context26.prev = 30;

                if (!_didIteratorError7) {
                  _context26.next = 33;
                  break;
                }

                throw _iteratorError7;

              case 33:
                return _context26.finish(30);

              case 34:
                return _context26.finish(27);

              case 35:
                return _context26.abrupt("return", this.importFromSpecs(importSpecs, overwrite, copyResources));

              case 36:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee25, this, [[9, 23, 27, 35], [28,, 30, 34]]);
      }));

      function importFromDir(_x62) {
        return _ref44.apply(this, arguments);
      }

      return importFromDir;
    }()
  }, {
    key: "importFromSpecs",
    value: function () {
      var _ref48 = asyncToGenerator(regeneratorRuntime.mark(function _callee26(specs) {
        var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var copyResources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var versionDB, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, _ref50, type, name, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, spec;

        return regeneratorRuntime.wrap(function _callee26$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (overwrite) {
                  _context27.next = 36;
                  break;
                }

                _context27.t0 = this.__versionDB;

                if (_context27.t0) {
                  _context27.next = 6;
                  break;
                }

                _context27.next = 5;
                return this._versionDB();

              case 5:
                _context27.t0 = _context27.sent;

              case 6:
                versionDB = _context27.t0;
                _iteratorNormalCompletion8 = true;
                _didIteratorError8 = false;
                _iteratorError8 = undefined;
                _context27.prev = 10;
                _iterator8 = specs[Symbol.iterator]();

              case 12:
                if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                  _context27.next = 22;
                  break;
                }

                _ref50 = _step8.value;
                type = _ref50.type, name = _ref50.name;
                _context27.next = 17;
                return versionDB.get(type + "/" + name);

              case 17:
                if (!_context27.sent) {
                  _context27.next = 19;
                  break;
                }

                throw new Error("Import failed: object " + type + "/" + name + " already exists and overwrite is not allowed");

              case 19:
                _iteratorNormalCompletion8 = true;
                _context27.next = 12;
                break;

              case 22:
                _context27.next = 28;
                break;

              case 24:
                _context27.prev = 24;
                _context27.t1 = _context27["catch"](10);
                _didIteratorError8 = true;
                _iteratorError8 = _context27.t1;

              case 28:
                _context27.prev = 28;
                _context27.prev = 29;

                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                  _iterator8.return();
                }

              case 31:
                _context27.prev = 31;

                if (!_didIteratorError8) {
                  _context27.next = 34;
                  break;
                }

                throw _iteratorError8;

              case 34:
                return _context27.finish(31);

              case 35:
                return _context27.finish(28);

              case 36:
                _iteratorNormalCompletion9 = true;
                _didIteratorError9 = false;
                _iteratorError9 = undefined;
                _context27.prev = 39;
                _iterator9 = specs[Symbol.iterator]();

              case 41:
                if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
                  _context27.next = 48;
                  break;
                }

                spec = _step9.value;
                _context27.next = 45;
                return this.importFromSpec(spec, true, copyResources);

              case 45:
                _iteratorNormalCompletion9 = true;
                _context27.next = 41;
                break;

              case 48:
                _context27.next = 54;
                break;

              case 50:
                _context27.prev = 50;
                _context27.t2 = _context27["catch"](39);
                _didIteratorError9 = true;
                _iteratorError9 = _context27.t2;

              case 54:
                _context27.prev = 54;
                _context27.prev = 55;

                if (!_iteratorNormalCompletion9 && _iterator9.return) {
                  _iterator9.return();
                }

              case 57:
                _context27.prev = 57;

                if (!_didIteratorError9) {
                  _context27.next = 60;
                  break;
                }

                throw _iteratorError9;

              case 60:
                return _context27.finish(57);

              case 61:
                return _context27.finish(54);

              case 62:
                return _context27.abrupt("return", specs);

              case 63:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee26, this, [[10, 24, 28, 36], [29,, 31, 35], [39, 50, 54, 62], [55,, 57, 61]]);
      }));

      function importFromSpecs(_x66) {
        return _ref48.apply(this, arguments);
      }

      return importFromSpecs;
    }()
  }, {
    key: "importFromSpec",
    value: function () {
      var _ref51 = asyncToGenerator(regeneratorRuntime.mark(function _callee27(spec) {
        var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var copyResources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var versionDB, commitDB, snapshotLocation, type, name, commits, history, snapshotDirs;
        return regeneratorRuntime.wrap(function _callee27$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = this.__versionDB;

                if (_context28.t0) {
                  _context28.next = 5;
                  break;
                }

                _context28.next = 4;
                return this._versionDB();

              case 4:
                _context28.t0 = _context28.sent;

              case 5:
                versionDB = _context28.t0;
                _context28.t1 = this.__commitDB;

                if (_context28.t1) {
                  _context28.next = 11;
                  break;
                }

                _context28.next = 10;
                return this._commitDB();

              case 10:
                _context28.t1 = _context28.sent;

              case 11:
                commitDB = _context28.t1;
                snapshotLocation = this.snapshotLocation;
                type = spec.type;
                name = spec.name;
                commits = spec.commits;
                history = spec.history;
                snapshotDirs = spec.snapshotDirs;
                _context28.t2 = !overwrite;

                if (!_context28.t2) {
                  _context28.next = 23;
                  break;
                }

                _context28.next = 22;
                return versionDB.get(type + "/" + name);

              case 22:
                _context28.t2 = _context28.sent;

              case 23:
                if (!_context28.t2) {
                  _context28.next = 25;
                  break;
                }

                throw new Error("Import failed: object " + type + "/" + name + " already exists and overwrite is not allowed");

              case 25:
                _context28.next = 27;
                return Promise.all([commitDB.setDocuments(commits), versionDB.set(type + "/" + name, history)].concat(toConsumableArray(snapshotDirs && copyResources ? snapshotDirs.map(function (ea) {
                  return ea.copyTo(snapshotLocation.join(ea.name()).asDirectory());
                }) : [])));

              case 27:
                return _context28.abrupt("return", spec);

              case 28:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee27, this);
      }));

      function importFromSpec(_x69) {
        return _ref51.apply(this, arguments);
      }

      return importFromSpec;
    }()
  }, {
    key: "importFromResource",
    value: function () {
      var _ref52 = asyncToGenerator(regeneratorRuntime.mark(function _callee28(type, name, resource$$1, commitSpec) {
        var purgeHistory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var snap;
        return regeneratorRuntime.wrap(function _callee28$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return resource$$1.readJson();

              case 2:
                snap = _context29.sent;
                _context29.t0 = purgeHistory;

                if (!_context29.t0) {
                  _context29.next = 8;
                  break;
                }

                _context29.next = 7;
                return this.has(type, name);

              case 7:
                _context29.t0 = _context29.sent;

              case 8:
                if (!_context29.t0) {
                  _context29.next = 11;
                  break;
                }

                _context29.next = 11;
                return this.delete(type, name, false);

              case 11:
                return _context29.abrupt("return", this.commit(type, name, snap, commitSpec));

              case 12:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee28, this);
      }));

      function importFromResource(_x72, _x73, _x74, _x75) {
        return _ref52.apply(this, arguments);
      }

      return importFromResource;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // synchronization / replication

  }, {
    key: "replicateTo",
    value: function replicateTo(remoteCommitDB, remoteVersionDB, toSnapshotLocation, options) {
      return new Synchronization(this, remoteCommitDB, remoteVersionDB, toSnapshotLocation, _extends({ method: "replicateTo" }, options)).start();
    }
  }, {
    key: "replicateFrom",
    value: function replicateFrom(remoteCommitDB, remoteVersionDB, toSnapshotLocation, options) {
      return new Synchronization(this, remoteCommitDB, remoteVersionDB, toSnapshotLocation, _extends({ method: "replicateFrom" }, options)).start();
    }
  }, {
    key: "sync",
    value: function sync(remoteCommitDB, remoteVersionDB, toSnapshotLocation, options) {
      return new Synchronization(this, remoteCommitDB, remoteVersionDB, toSnapshotLocation, _extends({ method: "sync" }, options)).start();
    }
  }, {
    key: "getConflicts",
    value: function () {
      var _ref53 = asyncToGenerator(regeneratorRuntime.mark(function _callee31(includeDocs, only) {
        var getConflicts = function () {
          var _ref54 = asyncToGenerator(regeneratorRuntime.mark(function _callee30(db, kind) {
            var _this2 = this;

            var conflicts;
            return regeneratorRuntime.wrap(function _callee30$(_context31) {
              while (1) {
                switch (_context31.prev = _context31.next) {
                  case 0:
                    _context31.next = 2;
                    return db.getConflicts({ include_docs: true });

                  case 2:
                    conflicts = _context31.sent;
                    _context31.next = 5;
                    return Promise.all(conflicts.map(function () {
                      var _ref55 = asyncToGenerator(regeneratorRuntime.mark(function _callee29(ea) {
                        var id, rev, conflicts, doc, query;
                        return regeneratorRuntime.wrap(function _callee29$(_context30) {
                          while (1) {
                            switch (_context30.prev = _context30.next) {
                              case 0:
                                id = ea.id, rev = ea.rev, conflicts = ea.conflicts, doc = ea.doc;

                                if (!(only && only[kind] && !only[kind][id])) {
                                  _context30.next = 3;
                                  break;
                                }

                                return _context30.abrupt("return", null);

                              case 3:
                                if (!includeDocs) {
                                  _context30.next = 8;
                                  break;
                                }

                                query = conflicts.map(function (rev) {
                                  return { id: id, rev: rev };
                                });
                                _context30.next = 7;
                                return db.getDocuments(query);

                              case 7:
                                conflicts = _context30.sent;

                              case 8:
                                if (!includeDocs) doc = null;else lively_lang.obj.dissoc(doc, ["_conflicts"]);
                                return _context30.abrupt("return", { id: id, rev: rev, conflicts: conflicts, kind: kind, doc: doc });

                              case 10:
                              case "end":
                                return _context30.stop();
                            }
                          }
                        }, _callee29, _this2);
                      }));

                      return function (_x81) {
                        return _ref55.apply(this, arguments);
                      };
                    }()));

                  case 5:
                    _context31.t0 = Boolean;
                    return _context31.abrupt("return", _context31.sent.filter(_context31.t0));

                  case 7:
                  case "end":
                    return _context31.stop();
                }
              }
            }, _callee30, this);
          }));

          return function getConflicts(_x79, _x80) {
            return _ref54.apply(this, arguments);
          };
        }();

        var commitDB, versionDB;
        return regeneratorRuntime.wrap(function _callee31$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.t0 = this.__commitDB;

                if (_context32.t0) {
                  _context32.next = 5;
                  break;
                }

                _context32.next = 4;
                return this._commitDB();

              case 4:
                _context32.t0 = _context32.sent;

              case 5:
                commitDB = _context32.t0;
                _context32.t1 = this.__versionDB;

                if (_context32.t1) {
                  _context32.next = 11;
                  break;
                }

                _context32.next = 10;
                return this._versionDB();

              case 10:
                _context32.t1 = _context32.sent;

              case 11:
                versionDB = _context32.t1;
                _context32.next = 14;
                return getConflicts(versionDB, "versions");

              case 14:
                _context32.t2 = _context32.sent;
                _context32.next = 17;
                return getConflicts(commitDB, "commits");

              case 17:
                _context32.next = 19;
                return _context32.sent;

              case 19:
                _context32.t3 = _context32.sent;
                return _context32.abrupt("return", {
                  versionConflicts: _context32.t2,
                  commitConflicts: _context32.t3
                });

              case 21:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee31, this);
      }));

      function getConflicts(_x77, _x78) {
        return _ref53.apply(this, arguments);
      }

      return getConflicts;
    }()
  }, {
    key: "resolveConflict",
    value: function () {
      var _ref56 = asyncToGenerator(regeneratorRuntime.mark(function _callee32(arg) {
        var resolved, del, kind, id, db;
        return regeneratorRuntime.wrap(function _callee32$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                // {resolved, delete: del, kind, id}
                resolved = arg.resolved, del = arg.delete, kind = arg.kind, id = arg.id, db = void 0;

                if (!(kind === "versions")) {
                  _context33.next = 10;
                  break;
                }

                _context33.t0 = this.__versionDB;

                if (_context33.t0) {
                  _context33.next = 7;
                  break;
                }

                _context33.next = 6;
                return this._versionDB();

              case 6:
                _context33.t0 = _context33.sent;

              case 7:
                db = _context33.t0;
                _context33.next = 20;
                break;

              case 10:
                if (!(kind === "commits")) {
                  _context33.next = 19;
                  break;
                }

                _context33.t1 = this.__commitDB;

                if (_context33.t1) {
                  _context33.next = 16;
                  break;
                }

                _context33.next = 15;
                return this._commitDB();

              case 15:
                _context33.t1 = _context33.sent;

              case 16:
                db = _context33.t1;
                _context33.next = 20;
                break;

              case 19:
                throw new Error("Unknown conflict kind: " + kind);

              case 20:
                _context33.next = 22;
                return db.set(id, resolved);

              case 22:
                _context33.next = 24;
                return Promise.all(del.map(function (rev) {
                  return db.pouchdb.remove(id, rev);
                }));

              case 24:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee32, this);
      }));

      function resolveConflict(_x82) {
        return _ref56.apply(this, arguments);
      }

      return resolveConflict;
    }()
  }, {
    key: "getDiff",
    value: function () {
      var _ref57 = asyncToGenerator(regeneratorRuntime.mark(function _callee36(remoteCommitDBOrName, remoteVersionDB) {
        var _this3 = this;

        var remoteCommitDB, localCommitDB, localVersionDB, commitDiff, versionDiff, local, remote, changed, localCommits, remoteCommits, changedCommits, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, ea, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, _ea, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, _ea2, localCommitTypeAndNames, remoteCommitTypeAndNames, changedCommitTypeAndNames;

        return regeneratorRuntime.wrap(function _callee36$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                remoteCommitDB = remoteCommitDBOrName;

                if (typeof remoteCommitDBOrName === "string") {
                  remoteCommitDB = Database.ensureDB(remoteCommitDBOrName + "-commits");
                  remoteVersionDB = Database.ensureDB(remoteCommitDBOrName + "-version-graph");
                }

                _context37.t0 = this.__commitDB;

                if (_context37.t0) {
                  _context37.next = 7;
                  break;
                }

                _context37.next = 6;
                return this._commitDB();

              case 6:
                _context37.t0 = _context37.sent;

              case 7:
                localCommitDB = _context37.t0;
                _context37.t1 = this.__versionDB;

                if (_context37.t1) {
                  _context37.next = 13;
                  break;
                }

                _context37.next = 12;
                return this._versionDB();

              case 12:
                _context37.t1 = _context37.sent;

              case 13:
                localVersionDB = _context37.t1;
                _context37.next = 16;
                return localCommitDB.diffWith(remoteCommitDB);

              case 16:
                commitDiff = _context37.sent;
                _context37.next = 19;
                return localVersionDB.diffWith(remoteVersionDB);

              case 19:
                versionDiff = _context37.sent;
                _context37.next = 22;
                return Promise.all(versionDiff.inLeft.map(function () {
                  var _ref58 = asyncToGenerator(regeneratorRuntime.mark(function _callee33(ea) {
                    return regeneratorRuntime.wrap(function _callee33$(_context34) {
                      while (1) {
                        switch (_context34.prev = _context34.next) {
                          case 0:
                            _context34.t0 = ea.id;
                            _context34.next = 3;
                            return localVersionDB.get(ea.id);

                          case 3:
                            _context34.t1 = _context34.sent;
                            return _context34.abrupt("return", {
                              id: _context34.t0,
                              doc: _context34.t1
                            });

                          case 5:
                          case "end":
                            return _context34.stop();
                        }
                      }
                    }, _callee33, _this3);
                  }));

                  return function (_x85) {
                    return _ref58.apply(this, arguments);
                  };
                }()));

              case 22:
                local = _context37.sent;
                _context37.next = 25;
                return Promise.all(versionDiff.inRight.map(function () {
                  var _ref59 = asyncToGenerator(regeneratorRuntime.mark(function _callee34(ea) {
                    return regeneratorRuntime.wrap(function _callee34$(_context35) {
                      while (1) {
                        switch (_context35.prev = _context35.next) {
                          case 0:
                            _context35.t0 = ea.id;
                            _context35.next = 3;
                            return remoteVersionDB.get(ea.id);

                          case 3:
                            _context35.t1 = _context35.sent;
                            return _context35.abrupt("return", {
                              id: _context35.t0,
                              doc: _context35.t1
                            });

                          case 5:
                          case "end":
                            return _context35.stop();
                        }
                      }
                    }, _callee34, _this3);
                  }));

                  return function (_x86) {
                    return _ref59.apply(this, arguments);
                  };
                }()));

              case 25:
                remote = _context37.sent;
                _context37.next = 28;
                return Promise.all(versionDiff.changed.map(function () {
                  var _ref60 = asyncToGenerator(regeneratorRuntime.mark(function _callee35(ea) {
                    return regeneratorRuntime.wrap(function _callee35$(_context36) {
                      while (1) {
                        switch (_context36.prev = _context36.next) {
                          case 0:
                            _context36.t0 = babelHelpers$1;
                            _context36.t1 = {};
                            _context36.t2 = ea.left;
                            _context36.next = 5;
                            return localVersionDB.get(ea.left.id);

                          case 5:
                            _context36.t3 = _context36.sent;
                            _context36.next = 8;
                            return remoteVersionDB.get(ea.right.id);

                          case 8:
                            _context36.t4 = _context36.sent;
                            _context36.t5 = {
                              docA: _context36.t3,
                              docB: _context36.t4
                            };
                            return _context36.abrupt("return", _context36.t0.extends.call(_context36.t0, _context36.t1, _context36.t2, _context36.t5));

                          case 11:
                          case "end":
                            return _context36.stop();
                        }
                      }
                    }, _callee35, _this3);
                  }));

                  return function (_x87) {
                    return _ref60.apply(this, arguments);
                  };
                }()));

              case 28:
                changed = _context37.sent;
                localCommits = [];
                remoteCommits = [];
                changedCommits = [];
                _iteratorNormalCompletion10 = true;
                _didIteratorError10 = false;
                _iteratorError10 = undefined;
                _context37.prev = 35;
                _iterator10 = commitDiff.inLeft[Symbol.iterator]();

              case 37:
                if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                  _context37.next = 47;
                  break;
                }

                ea = _step10.value;
                _context37.t2 = localCommits;
                _context37.next = 42;
                return localCommitDB.get(ea.id);

              case 42:
                _context37.t3 = _context37.sent;

                _context37.t2.push.call(_context37.t2, _context37.t3);

              case 44:
                _iteratorNormalCompletion10 = true;
                _context37.next = 37;
                break;

              case 47:
                _context37.next = 53;
                break;

              case 49:
                _context37.prev = 49;
                _context37.t4 = _context37["catch"](35);
                _didIteratorError10 = true;
                _iteratorError10 = _context37.t4;

              case 53:
                _context37.prev = 53;
                _context37.prev = 54;

                if (!_iteratorNormalCompletion10 && _iterator10.return) {
                  _iterator10.return();
                }

              case 56:
                _context37.prev = 56;

                if (!_didIteratorError10) {
                  _context37.next = 59;
                  break;
                }

                throw _iteratorError10;

              case 59:
                return _context37.finish(56);

              case 60:
                return _context37.finish(53);

              case 61:
                _iteratorNormalCompletion11 = true;
                _didIteratorError11 = false;
                _iteratorError11 = undefined;
                _context37.prev = 64;
                _iterator11 = commitDiff.inRight[Symbol.iterator]();

              case 66:
                if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
                  _context37.next = 76;
                  break;
                }

                _ea = _step11.value;
                _context37.t5 = remoteCommits;
                _context37.next = 71;
                return remoteCommitDB.get(_ea.id);

              case 71:
                _context37.t6 = _context37.sent;

                _context37.t5.push.call(_context37.t5, _context37.t6);

              case 73:
                _iteratorNormalCompletion11 = true;
                _context37.next = 66;
                break;

              case 76:
                _context37.next = 82;
                break;

              case 78:
                _context37.prev = 78;
                _context37.t7 = _context37["catch"](64);
                _didIteratorError11 = true;
                _iteratorError11 = _context37.t7;

              case 82:
                _context37.prev = 82;
                _context37.prev = 83;

                if (!_iteratorNormalCompletion11 && _iterator11.return) {
                  _iterator11.return();
                }

              case 85:
                _context37.prev = 85;

                if (!_didIteratorError11) {
                  _context37.next = 88;
                  break;
                }

                throw _iteratorError11;

              case 88:
                return _context37.finish(85);

              case 89:
                return _context37.finish(82);

              case 90:
                _iteratorNormalCompletion12 = true;
                _didIteratorError12 = false;
                _iteratorError12 = undefined;
                _context37.prev = 93;
                _iterator12 = commitDiff.changed[Symbol.iterator]();

              case 95:
                if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                  _context37.next = 110;
                  break;
                }

                _ea2 = _step12.value;
                _context37.t8 = changedCommits;
                _context37.next = 100;
                return localCommitDB.get(_ea2.left.id);

              case 100:
                _context37.t9 = _context37.sent;

                _context37.t8.push.call(_context37.t8, _context37.t9);

                _context37.t10 = changedCommits;
                _context37.next = 105;
                return remoteCommitDB.get(_ea2.right.id);

              case 105:
                _context37.t11 = _context37.sent;

                _context37.t10.push.call(_context37.t10, _context37.t11);

              case 107:
                _iteratorNormalCompletion12 = true;
                _context37.next = 95;
                break;

              case 110:
                _context37.next = 116;
                break;

              case 112:
                _context37.prev = 112;
                _context37.t12 = _context37["catch"](93);
                _didIteratorError12 = true;
                _iteratorError12 = _context37.t12;

              case 116:
                _context37.prev = 116;
                _context37.prev = 117;

                if (!_iteratorNormalCompletion12 && _iterator12.return) {
                  _iterator12.return();
                }

              case 119:
                _context37.prev = 119;

                if (!_didIteratorError12) {
                  _context37.next = 122;
                  break;
                }

                throw _iteratorError12;

              case 122:
                return _context37.finish(119);

              case 123:
                return _context37.finish(116);

              case 124:
                localCommitTypeAndNames = localCommits.map(function (ea) {
                  return lively_lang.obj.select(ea, ["_id", "name", "type"]);
                }), remoteCommitTypeAndNames = remoteCommits.map(function (ea) {
                  return lively_lang.obj.select(ea, ["_id", "name", "type"]);
                }), changedCommitTypeAndNames = changedCommits.map(function (ea) {
                  return lively_lang.obj.select(ea, ["_id", "name", "type"]);
                });
                return _context37.abrupt("return", {
                  changed: changed, remote: remote, local: local,
                  changedCommitTypeAndNames: changedCommitTypeAndNames,
                  remoteCommitTypeAndNames: remoteCommitTypeAndNames,
                  localCommitTypeAndNames: localCommitTypeAndNames
                });

              case 126:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee36, this, [[35, 49, 53, 61], [54,, 56, 60], [64, 78, 82, 90], [83,, 85, 89], [93, 112, 116, 124], [117,, 119, 123]]);
      }));

      function getDiff(_x83, _x84) {
        return _ref57.apply(this, arguments);
      }

      return getDiff;
    }()

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // deletion

  }, {
    key: "delete",
    value: function () {
      var _ref61 = asyncToGenerator(regeneratorRuntime.mark(function _callee37(type, name) {
        var dryRun = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        var resources, commitDeletions, objectDB, opts, _ref62, rows, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, _ref65, commit, versionDB, _ref64, _id, _rev, deletedHist;

        return regeneratorRuntime.wrap(function _callee37$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                resources = [], commitDeletions = [];

                // 1. meta data to delete

                _context38.t0 = this.__commitDB;

                if (_context38.t0) {
                  _context38.next = 6;
                  break;
                }

                _context38.next = 5;
                return this._commitDB();

              case 5:
                _context38.t0 = _context38.sent;

              case 6:
                objectDB = _context38.t0;
                opts = {
                  include_docs: true,
                  startkey: type + "\0" + name + "\0",
                  endkey: type + "\0" + name + "\uFFFF"
                };
                _context38.next = 10;
                return objectDB.query("nameAndTimestamp_index", opts);

              case 10:
                _ref62 = _context38.sent;
                rows = _ref62.rows;
                _iteratorNormalCompletion13 = true;
                _didIteratorError13 = false;
                _iteratorError13 = undefined;
                _context38.prev = 15;


                for (_iterator13 = rows[Symbol.iterator](); !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                  _ref65 = _step13.value;
                  commit = _ref65.doc;

                  // 2. resources to delete
                  if (!commit.deleted && !commit._deleted && commit.content) resources.push(this.snapshotResourceFor(commit));
                  commitDeletions.push(_extends({}, commit, { _deleted: true }));
                }

                // 3. history to delete
                _context38.next = 23;
                break;

              case 19:
                _context38.prev = 19;
                _context38.t1 = _context38["catch"](15);
                _didIteratorError13 = true;
                _iteratorError13 = _context38.t1;

              case 23:
                _context38.prev = 23;
                _context38.prev = 24;

                if (!_iteratorNormalCompletion13 && _iterator13.return) {
                  _iterator13.return();
                }

              case 26:
                _context38.prev = 26;

                if (!_didIteratorError13) {
                  _context38.next = 29;
                  break;
                }

                throw _iteratorError13;

              case 29:
                return _context38.finish(26);

              case 30:
                return _context38.finish(23);

              case 31:
                _context38.t2 = this.__versionDB;

                if (_context38.t2) {
                  _context38.next = 36;
                  break;
                }

                _context38.next = 35;
                return this._versionDB();

              case 35:
                _context38.t2 = _context38.sent;

              case 36:
                versionDB = _context38.t2;
                _context38.next = 39;
                return versionDB.get(type + "/" + name);

              case 39:
                _ref64 = _context38.sent;
                _id = _ref64._id;
                _rev = _ref64._rev;
                deletedHist = { _id: _id, _rev: _rev, _deleted: true };

                if (dryRun) {
                  _context38.next = 49;
                  break;
                }

                _context38.next = 46;
                return objectDB.setDocuments(commitDeletions);

              case 46:
                _context38.next = 48;
                return versionDB.setDocuments([deletedHist]);

              case 48:
                Promise.all(resources.map(function (ea) {
                  return ea.remove();
                }));

              case 49:
                return _context38.abrupt("return", {
                  commits: commitDeletions,
                  history: deletedHist,
                  resources: resources
                });

              case 50:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee37, this, [[15, 19, 23, 31], [24,, 26, 30]]);
      }));

      function _delete(_x88, _x89) {
        return _ref61.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "deleteCommit",
    value: function () {
      var _ref66 = asyncToGenerator(regeneratorRuntime.mark(function _callee38(commitOrId) {
        var dryRun = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "HEAD";

        var commit, commitDB, versionDB, objectDB, _commit, name, type, _id, resources, commitDeletions, hist, _ref67, _ref68, ancestor;

        return regeneratorRuntime.wrap(function _callee38$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                commit = void 0;

                if (!(commitOrId && typeof commitOrId !== "string")) {
                  _context39.next = 5;
                  break;
                }

                commit = commitOrId;
                _context39.next = 15;
                break;

              case 5:
                if (!commitOrId) {
                  _context39.next = 15;
                  break;
                }

                _context39.t0 = this.__commitDB;

                if (_context39.t0) {
                  _context39.next = 11;
                  break;
                }

                _context39.next = 10;
                return this._commitDB();

              case 10:
                _context39.t0 = _context39.sent;

              case 11:
                commitDB = _context39.t0;
                _context39.next = 14;
                return commitDB.get(commitOrId);

              case 14:
                commit = _context39.sent;

              case 15:
                if (commit) {
                  _context39.next = 17;
                  break;
                }

                throw new Error("commit needed!");

              case 17:
                _context39.t1 = this.__versionDB;

                if (_context39.t1) {
                  _context39.next = 22;
                  break;
                }

                _context39.next = 21;
                return this._versionDB();

              case 21:
                _context39.t1 = _context39.sent;

              case 22:
                versionDB = _context39.t1;
                _context39.t2 = this.__commitDB;

                if (_context39.t2) {
                  _context39.next = 28;
                  break;
                }

                _context39.next = 27;
                return this._commitDB();

              case 27:
                _context39.t2 = _context39.sent;

              case 28:
                objectDB = _context39.t2;
                _commit = commit;
                name = _commit.name;
                type = _commit.type;
                _id = _commit._id;
                resources = commit.deleted || commit._deleted || !commit.content ? [] : [this.snapshotResourceFor(commit)];
                commitDeletions = [_extends({}, commit, { _deleted: true })];
                _context39.next = 37;
                return versionDB.get(type + "/" + name);

              case 37:
                hist = _context39.sent;

                if (hist) {
                  _context39.next = 40;
                  break;
                }

                throw new Error("No history for " + type + "/" + name + "@" + commit._id);

              case 40:
                if (hist.refs[ref]) {
                  _context39.next = 42;
                  break;
                }

                throw new Error("Cannot delete commit " + type + "/" + name + "@" + commit._id + " b/c it is not where ref " + ref + " is pointing!");

              case 42:
                _ref67 = hist.history[commit._id] || [], _ref68 = slicedToArray(_ref67, 1), ancestor = _ref68[0];

                if (!(!ancestor && Object.keys(hist.history).length <= 1)) {
                  _context39.next = 47;
                  break;
                }

                hist._deleted = true;
                _context39.next = 53;
                break;

              case 47:
                if (ancestor) {
                  _context39.next = 51;
                  break;
                }

                throw new Error("Cannot delete commit " + type + "/" + name + "@" + commit._id + " b/c it has no ancestor but there are still other commits!");

              case 51:
                delete hist.history[commit._id];
                hist.refs[ref] = ancestor;

              case 53:
                if (dryRun) {
                  _context39.next = 60;
                  break;
                }

                _context39.next = 56;
                return versionDB.set(type + "/" + name, hist);

              case 56:
                _context39.next = 58;
                return objectDB.setDocuments(commitDeletions);

              case 58:
                _context39.next = 60;
                return Promise.all(resources.map(function (ea) {
                  return ea.remove();
                }));

              case 60:
                return _context39.abrupt("return", {
                  commits: commitDeletions,
                  history: hist,
                  resources: resources
                });

              case 61:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee38, this);
      }));

      function deleteCommit(_x91) {
        return _ref66.apply(this, arguments);
      }

      return deleteCommit;
    }()
  }, {
    key: "_commitdb_indexes",
    get: function get() {

      return [{
        name: 'name_index',
        version: 4,
        mapFn: "function (doc) { emit(doc.type + \"\0\" + doc.name); }"
      }, {
        name: 'nameAndTimestamp_index',
        version: 3,
        mapFn: "function (doc) { emit(doc.type + \"\0\" + doc.name + \"\0\" + doc.timestamp + \"\0\" + doc._id); }"
      }, {
        name: 'nameWithMaxMinTimestamp_index',
        version: 3,
        mapFn: "function(doc) { emit(doc.type + \"\0\" + doc.name, doc.timestamp); }",
        reduceFn: "_stats"
      }, {
        name: 'nameTypeFilter',
        version: 7,
        filterFn: "function(doc, req) {\n          if (doc._id[0] === \"_\" || !req || !req.query) return true;\n          if (req.query.onlyIds) return !!req.query.onlyIds[doc._id];\n          if (req.query.onlyTypesAndNames)\n            return !!req.query.onlyTypesAndNames[doc.type + \"/\" + doc.name];\n          return true;\n        }"
      }];
    }
  }, {
    key: "_versiondb_indexes",
    get: function get() {
      return [{
        name: 'nameTypeFilter',
        version: 3,
        filterFn: "function(doc, req) {\n          if (doc._id[0] === \"_\" || !req || !req.query) return true;\n          if (req.query.onlyIds) return !!req.query.onlyIds[doc._id];\n          if (req.query.onlyTypesAndNames) return !!req.query.onlyTypesAndNames[doc._id];\n          return true;\n        }"
      }];
    }
  }]);
  return ObjectDB;
}();

var Synchronization = function () {
  function Synchronization(fromObjectDB, remoteCommitDB, remoteVersionDB, remoteLocation) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    classCallCheck(this, Synchronization);

    // replicationFilter: {onlyIds: {STRING: BOOL}, onlyTypesAndNames: {[type+"\u0000"+name]: BOOL}}
    this.options = _extends({
      debug: false, live: false, method: "sync",
      replicationFilter: undefined
    }, options);
    this.state = "not started";
    this.method = "";
    this.fromObjectDB = fromObjectDB;
    this.remoteCommitDB = remoteCommitDB;
    this.remoteVersionDB = remoteVersionDB;
    this.remoteLocation = remoteLocation;
    this.deferred = lively_lang.promise.deferred();
    this.conflicts = [];
    this.changes = [];
    this.errors = [];
  }

  createClass(Synchronization, [{
    key: "whenPaused",
    value: function whenPaused() {
      var _this4 = this;

      return Promise.resolve().then(function () {
        return lively_lang.promise.waitFor(function () {
          return _this4.isPaused || _this4.isComplete;
        });
      }).then(function () {
        return _this4;
      });
    }
  }, {
    key: "waitForIt",
    value: function waitForIt() {
      return this.deferred.promise;
    }
  }, {
    key: "start",
    value: function start() {
      if (!this.isSynchonizing) this._startReplicationAndCopy().catch(function (err) {
        return console.error("Error starting synchronization: ", err);
      });
      return this;
    }
  }, {
    key: "_startReplicationAndCopy",
    value: function () {
      var _ref69 = asyncToGenerator(regeneratorRuntime.mark(function _callee40() {
        var _this5 = this;

        var fromObjectDB, remoteCommitDB, remoteVersionDB, remoteLocation, _options, debug, _options$live, live, _options$retry, retry, method, replicationFilter, versionDB, commitDB, _commitdb_indexes, _versiondb_indexes, fromSnapshotLocation, versionChangeListener, commitChangeListener, commitNameTypeFilter, versionNameTypeFilter, opts, commitOpts, versionOpts, commitReplication, versionReplication, snapshotReplication, commitReplicationState, versionReplicationState, updateState, tryToResolve, snapshotPathFor;

        return regeneratorRuntime.wrap(function _callee40$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                snapshotPathFor = function snapshotPathFor(commit) {
                  // content is sha1 hash
                  if (!commit.content) return null;
                  var first = commit.content.slice(0, 2),
                      rest = commit.content.slice(2);
                  return first + "/" + rest + ".json";
                };

                tryToResolve = function tryToResolve(sync, errors) {
                  if (!errors.length && (commitReplicationState !== "complete" || versionReplicationState !== "complete" || !snapshotReplication.isComplete())) return;
                  versionChangeListener.cancel();
                  var err = void 0;
                  if (errors.length) {
                    sync.state = "complete";
                    sync.errors = errors;
                    commitReplication.cancel();
                    versionReplication.cancel();
                    err = new Error("Synchronization error:\n  " + errors.join("\n  "));
                    err.errors = errors;
                    console.log(sync + " errored");
                  } else {
                    console.log(sync + " completed");
                  }
                  if (err) sync.deferred.reject(err);else sync.deferred.resolve(sync);
                };

                updateState = function updateState(sync) {
                  if (versionReplicationState === "paused" && commitReplicationState === "paused" && snapshotReplication.copyCalls <= 0 && snapshotReplication.copyCallsWaiting <= 0) return sync.state = "paused";
                  if (versionReplicationState === "complete" && commitReplicationState === "complete" && snapshotReplication.isComplete()) return sync.state = "complete";
                  return sync.state = "running";
                };

                fromObjectDB = this.fromObjectDB;
                remoteCommitDB = this.remoteCommitDB;
                remoteVersionDB = this.remoteVersionDB;
                remoteLocation = this.remoteLocation;
                _options = this.options;
                debug = _options.debug;
                _options$live = _options.live;
                live = _options$live === undefined ? false : _options$live;
                _options$retry = _options.retry;
                retry = _options$retry === undefined ? false : _options$retry;
                method = _options.method;
                replicationFilter = _options.replicationFilter;
                _context41.t0 = fromObjectDB.__versionDB;

                if (_context41.t0) {
                  _context41.next = 20;
                  break;
                }

                _context41.next = 19;
                return fromObjectDB._versionDB();

              case 19:
                _context41.t0 = _context41.sent;

              case 20:
                versionDB = _context41.t0;
                _context41.t1 = fromObjectDB.__commitDB;

                if (_context41.t1) {
                  _context41.next = 26;
                  break;
                }

                _context41.next = 25;
                return fromObjectDB._commitDB();

              case 25:
                _context41.t1 = _context41.sent;

              case 26:
                commitDB = _context41.t1;
                _commitdb_indexes = fromObjectDB._commitdb_indexes;
                _versiondb_indexes = fromObjectDB._versiondb_indexes;
                fromSnapshotLocation = fromObjectDB.snapshotLocation;
                versionChangeListener = void 0;
                commitChangeListener = void 0;


                this.method = method;

                commitNameTypeFilter = _commitdb_indexes.find(function (ea) {
                  return ea.name === 'nameTypeFilter';
                }), versionNameTypeFilter = _versiondb_indexes.find(function (ea) {
                  return ea.name === 'nameTypeFilter';
                });


                console.log("adding commitNameTypeFilter");
                _context41.next = 37;
                return remoteCommitDB.addDesignDoc(commitNameTypeFilter);

              case 37:

                console.log("adding versionNameTypeFilter");
                _context41.next = 40;
                return remoteVersionDB.addDesignDoc(versionNameTypeFilter);

              case 40:
                opts = {
                  live: live, retry: retry
                  // conflicts: true,
                }, commitOpts = _extends({}, opts), versionOpts = _extends({}, opts);


                if (replicationFilter) {
                  // opts.filter = 'nameTypeFilter/nameTypeFilter';
                  commitOpts.filter = eval("(" + commitNameTypeFilter.filterFn + ")");
                  commitOpts.query_params = replicationFilter;
                  versionOpts.filter = eval("(" + versionNameTypeFilter.filterFn + ")");
                  versionOpts.query_params = replicationFilter;
                }

                commitReplication = commitDB[method](remoteCommitDB, commitOpts), versionReplication = versionDB[method](remoteVersionDB, versionOpts), snapshotReplication = {
                  copyCalls: 0,
                  copyCallsWaiting: 0,
                  nFilesToCopy: 0,
                  nFilesCopied: 0,
                  stopped: false,
                  isComplete: function isComplete() {
                    return this.stopped || this.copyCalls <= 0 && this.copyCallsWaiting <= 0;
                  }
                }, commitReplicationState = "not started", versionReplicationState = "not started";


                this.versionReplication = versionReplication;
                this.commitReplication = commitReplication;
                this.snapshotReplication = snapshotReplication;

                commitChangeListener = remoteCommitDB.pouchdb.changes({
                  include_docs: true, live: true, conflicts: true });
                versionChangeListener = remoteVersionDB.pouchdb.changes({
                  include_docs: true, live: true, conflicts: true });

                commitChangeListener.on("change", function (change) {
                  var id = change.id,
                      changes = change.changes,
                      conflicts = change.doc._conflicts;

                  debug && console.log("commit changes " + id + ":", changes, conflicts);
                  if (!conflicts) return;
                  console.log("commit conflict " + id + ":", changes, conflicts);
                  _this5.conflicts.push({ db: "commits", id: id, changes: changes, conflicts: conflicts });
                });

                versionChangeListener.on("change", function (change) {
                  var id = change.id,
                      changes = change.changes,
                      conflicts = change.doc._conflicts;

                  debug && console.log("version changes " + id + ":", changes, conflicts);
                  if (!conflicts) return;
                  console.log("version conflict " + id + ":", changes, conflicts);
                  _this5.conflicts.push({ db: "versions", id: id, changes: changes, conflicts: conflicts });
                });

                commitReplication.on("change", function () {
                  var _ref70 = asyncToGenerator(regeneratorRuntime.mark(function _callee39(change) {
                    var _change, direction, _change$change, ok, commits, errors, error, toCopy, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, commit, contentResource;

                    return regeneratorRuntime.wrap(function _callee39$(_context40) {
                      while (1) {
                        switch (_context40.prev = _context40.next) {
                          case 0:
                            if (method === "replicateTo") change = { direction: "push", change: change };else if (method === "replicateFrom") change = { direction: "pull", change: change };

                            _change = change, direction = _change.direction, _change$change = _change.change, ok = _change$change.ok, commits = _change$change.docs, errors = _change$change.errors;

                            console.log(_this5 + " " + (direction === "push" ? "send" : "received") + " " + commits.length + " commits");

                            _context40.prev = 3;
                            toCopy = [];
                            _iteratorNormalCompletion14 = true;
                            _didIteratorError14 = false;
                            _iteratorError14 = undefined;
                            _context40.prev = 8;
                            _iterator14 = commits[Symbol.iterator]();

                          case 10:
                            if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
                              _context40.next = 20;
                              break;
                            }

                            commit = _step14.value;

                            if (!commit._id.startsWith("_")) {
                              _context40.next = 14;
                              break;
                            }

                            return _context40.abrupt("continue", 17);

                          case 14:
                            _this5.changes.push({ direction: direction, kind: "commits", id: commit._id, type: commit.type, name: commit.name });
                            contentResource = snapshotPathFor(commit);

                            contentResource && toCopy.push(contentResource);

                          case 17:
                            _iteratorNormalCompletion14 = true;
                            _context40.next = 10;
                            break;

                          case 20:
                            _context40.next = 26;
                            break;

                          case 22:
                            _context40.prev = 22;
                            _context40.t0 = _context40["catch"](8);
                            _didIteratorError14 = true;
                            _iteratorError14 = _context40.t0;

                          case 26:
                            _context40.prev = 26;
                            _context40.prev = 27;

                            if (!_iteratorNormalCompletion14 && _iterator14.return) {
                              _iterator14.return();
                            }

                          case 29:
                            _context40.prev = 29;

                            if (!_didIteratorError14) {
                              _context40.next = 32;
                              break;
                            }

                            throw _iteratorError14;

                          case 32:
                            return _context40.finish(29);

                          case 33:
                            return _context40.finish(26);

                          case 34:

                            snapshotReplication.nFilesToCopy += toCopy.length;

                            if (!(snapshotReplication.copyCalls > 0)) {
                              _context40.next = 40;
                              break;
                            }

                            snapshotReplication.copyCallsWaiting++;
                            _context40.next = 39;
                            return lively_lang.promise.waitFor(function () {
                              return snapshotReplication.copyCalls <= 0;
                            });

                          case 39:
                            snapshotReplication.copyCallsWaiting--;

                          case 40:

                            snapshotReplication.copyCalls++;updateState(_this5);

                            console.log(_this5 + " copying " + toCopy.length + " snapshots...");

                            _context40.next = 45;
                            return lively_lang.promise.parallel(toCopy.map(function (path) {
                              return function () {
                                var fromResource = (direction === "push" ? fromSnapshotLocation : remoteLocation).join(path),
                                    toResource = (direction === "push" ? remoteLocation : fromSnapshotLocation).join(path);

                                if (snapshotReplication.stopped) {
                                  console.warn(_this5 + " Stopping copying resources b/c synchronization ended (" + snapshotReplication.copyCalls + ", " + fromResource.url + " => " + toResource.url + ")");
                                  return Promise.resolve();
                                }

                                return toResource.exists().then(function (toExists) {
                                  if (toExists) {
                                    debug && console.log("Skip copying to " + toResource.url + ", already exist");
                                    return Promise.resolve();
                                  }

                                  return fromResource.exists().then(function (fromExists) {
                                    if (!fromExists) {
                                      console.warn("Skip copying " + fromResource.url + ", does not exist");
                                      return Promise.resolve();
                                    }
                                    debug && console.log(_this5 + " Copying " + fromResource.url + " => " + toResource.url);
                                    return tryCopy(0).then(function (result) {
                                      snapshotReplication.nFilesCopied++;
                                      if (!snapshotReplication.stopped && snapshotReplication.nFilesCopied % 10 === 0) console.log(_this5 + " copied " + snapshotReplication.nFilesCopied + " of " + snapshotReplication.nFilesToCopy + " snapshots");
                                      return result;
                                    });
                                  });

                                  function tryCopy() {
                                    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                                    return fromResource.copyTo(toResource).catch(function (err) {
                                      if (n >= 5) throw err;
                                      return tryCopy(n + 1);
                                    });
                                  }
                                });
                              };
                            }), 5);

                          case 45:
                            console.log(_this5 + " sending files done");
                            _context40.next = 53;
                            break;

                          case 48:
                            _context40.prev = 48;
                            _context40.t1 = _context40["catch"](3);

                            console.error("error in commitReplication onChange", _context40.t1);
                            error = _context40.t1;
                            throw _context40.t1;

                          case 53:
                            _context40.prev = 53;

                            snapshotReplication.copyCalls--;
                            updateState(_this5);
                            tryToResolve(_this5, error ? [error] : []);
                            return _context40.finish(53);

                          case 58:
                          case "end":
                            return _context40.stop();
                        }
                      }
                    }, _callee39, _this5, [[3, 48, 53, 58], [8, 22, 26, 34], [27,, 29, 33]]);
                  }));

                  return function (_x95) {
                    return _ref70.apply(this, arguments);
                  };
                }()).on('paused', function () {
                  commitReplicationState = "paused";
                  updateState(_this5);
                  debug && console.log(_this5 + " commit replication paused");
                }).on('active', function () {
                  commitReplicationState = "active";
                  updateState(_this5);
                  debug && console.log(_this5 + " commit replication active");
                }).on('error', function (err) {
                  commitReplicationState = "complete";updateState(_this5);
                  console.error(_this5 + " commit replication error", err);
                  tryToResolve(_this5, [err]);
                }).on('complete', function (info) {
                  commitReplicationState = "complete";updateState(_this5);
                  var errors = method === "sync" ? info.push.errors.concat(info.pull.errors) : info.errors;
                  tryToResolve(_this5, errors);
                });

                versionReplication.on("change", function (change) {
                  if (method === "replicateTo") change = { direction: "push", change: change };else if (method === "replicateFrom") change = { direction: "pull", change: change };
                  var _change2 = change,
                      direction = _change2.direction,
                      _change2$change = _change2.change,
                      ok = _change2$change.ok,
                      docs = _change2$change.docs,
                      errors = _change2$change.errors;


                  debug && console.log(_this5 + " " + (direction === "push" ? "send" : "received") + " " + docs.length + " histories");

                  docs.forEach(function (doc) {
                    if (doc._id.startsWith("_")) return;
                    _this5.changes.push({ direction: direction, kind: "versions", id: doc._id });
                  });

                  // versionChanges.push(change);
                }).on('paused', function () {
                  versionReplicationState = "paused";
                  updateState(_this5);
                  debug && console.log(_this5 + " version replication paused");
                }).on('active', function (x) {
                  versionReplicationState = "active";
                  updateState(_this5);
                  debug && console.log(_this5 + " version replication active", x);
                }).on('error', function (err) {
                  versionReplicationState = "complete";updateState(_this5);
                  console.error(_this5 + " version replication error", err);
                  tryToResolve(_this5, [err]);
                }).on('complete', function (info) {
                  versionReplicationState = "complete";updateState(_this5);
                  var errors = method === "sync" ? info.push.errors.concat(info.pull.errors) : info.errors;
                  tryToResolve(_this5, errors);
                });

                this.state = "running";

                return _context41.abrupt("return", this);

              case 54:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee40, this);
      }));

      function _startReplicationAndCopy() {
        return _ref69.apply(this, arguments);
      }

      return _startReplicationAndCopy;
    }()
  }, {
    key: "safeStop",
    value: function () {
      var _ref71 = asyncToGenerator(regeneratorRuntime.mark(function _callee41() {
        return regeneratorRuntime.wrap(function _callee41$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                if (!(this.state === "not started" || !this.isSynchonizing)) {
                  _context42.next = 2;
                  break;
                }

                return _context42.abrupt("return", this);

              case 2:
                _context42.next = 4;
                return this.whenPaused();

              case 4:
                return _context42.abrupt("return", this.stop());

              case 5:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee41, this);
      }));

      function safeStop() {
        return _ref71.apply(this, arguments);
      }

      return safeStop;
    }()
  }, {
    key: "stop",
    value: function stop() {
      if (this.state === "not started" || !this.isSynchonizing) return this;
      this.commitReplication.cancel();
      this.versionReplication.cancel();
      this.snapshotReplication.stopped = true;
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      var method = this.method,
          state = this.state,
          name = this.fromObjectDB.name,
          dir = method === "sync" ? "<=>" : method === "replicateTo" ? "=>" : method === "replicateFrom" ? "<=" : "??";

      return "Synchronization(" + state + ": " + name + " " + dir + ")";
    }
  }, {
    key: "isSynchonizing",
    get: function get() {
      return this.isPaused || this.isRunning;
    }
  }, {
    key: "isComplete",
    get: function get() {
      return this.state === "complete";
    }
  }, {
    key: "isRunning",
    get: function get() {
      return this.state === "running";
    }
  }, {
    key: "isPaused",
    get: function get() {
      return this.state === "paused";
    }
  }, {
    key: "changesByTypeAndName",
    get: function get() {
      var changesByTypeAndName = { push: {}, pull: {} };
      this.changes.forEach(function (ea) {
        var dir = ea.direction,
            id = ea.id,
            kind = ea.kind;

        if (id[0] === "_") return;
        var byTypeAndName = void 0;
        if (kind === "versions") {
          byTypeAndName = changesByTypeAndName[dir][id] || (changesByTypeAndName[dir][id] = []);
        } else if (kind === "commits") {
          var typeAndName = ea.type + "/" + ea.name;
          byTypeAndName = changesByTypeAndName[dir][typeAndName] || (changesByTypeAndName[dir][typeAndName] = []);
        }
        byTypeAndName.push(ea);
      });
      return changesByTypeAndName;
    }
  }]);
  return Synchronization;
}();

function checkArg(name, value, spec) {
  if (typeof value === "undefined" && typeof spec === "string" && !spec.includes("undefined")) throw new Error("parameter " + name + " is undefined");
  if (value === null && typeof spec === "string" && !spec.includes("null")) throw new Error("parameter " + name + " is null");

  if (typeof spec === "string") {
    var actualType = typeof value === "undefined" ? "undefined" : _typeof(value),
        actualClass = value ? value.constructor.name : "",
        types = spec.split("|"),
        matches = types.some(function (t) {
      return actualType === t || actualClass === t;
    });
    if (!matches) throw new Error("parameter \"" + name + "\" expected to be of type " + spec + " but is " + (actualClass || actualType));
  }

  if (typeof spec === "function") {
    var result = spec(value);
    if (result && result.error) throw new Error("check of parameter \"" + name + "\" failed: " + result.error);
  }
}

function checkArgs(args, specs, testFn) {
  for (var key in specs) {
    checkArg(key, args[key], specs[key]);
  }if (typeof testFn === "function") {
    var result = testFn(args);
    if (result && result.error) throw new Error(result.error);
  }
  return args;
}

var ObjectDBInterface = {
  describe: function describe(method) {
    var _this6 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee42() {
      var src, parsed, entities, methodNameAndParametersAndDescription;
      return regeneratorRuntime.wrap(function _callee42$(_context43) {
        while (1) {
          switch (_context43.prev = _context43.next) {
            case 0:
              methodNameAndParametersAndDescription = function methodNameAndParametersAndDescription(methodSpecs, name) {
                var methodSpec = methodSpecs.find(function (ea) {
                  return ea.name === name;
                }),
                    body = methodSpec.node.value.body,
                    stmts = body.body || [],
                    comment = (body.comments || []).find(function (ea) {
                  return ea.end < stmts[0].start;
                }),
                    doc = { name: name, parameters: [], sideEffect: false, returns: null, description: "" };

                if (comment && comment.text.trim()) {
                  var text = lively.lang.string.changeIndent(comment.text, " ", 0),
                      commentLines = text.split("\n");
                  var _iteratorNormalCompletion15 = true;
                  var _didIteratorError15 = false;
                  var _iteratorError15 = undefined;

                  try {
                    for (var _iterator15 = commentLines[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                      var line = _step15.value;

                      if (line.startsWith("ignore-in-doc")) {
                        doc.description = "";break;
                      }
                      if (line.startsWith("side effect:")) {
                        doc.sideEffect = JSON.parse(line.split(":")[1]);
                        continue;
                      }
                      if (line.startsWith("returns:")) {
                        doc.returns = line.split(":")[1].trim();
                        continue;
                      }
                      doc.description += line + "\n";
                    }
                  } catch (err) {
                    _didIteratorError15 = true;
                    _iteratorError15 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion15 && _iterator15.return) {
                        _iterator15.return();
                      }
                    } finally {
                      if (_didIteratorError15) {
                        throw _iteratorError15;
                      }
                    }
                  }
                }

                var _iteratorNormalCompletion16 = true;
                var _didIteratorError16 = false;
                var _iteratorError16 = undefined;

                try {
                  for (var _iterator16 = stmts[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                    var stmt = _step16.value;

                    if ("checkArgs" !== lively.lang.Path("declarations.0.init.callee.name").get(stmt)) continue;
                    var props = lively.lang.Path("declarations.0.id.properties").get(stmt);
                    if (props) {
                      doc.parameters = props.map(function (ea) {
                        return ea.key.name;
                      });
                    }
                  }
                } catch (err) {
                  _didIteratorError16 = true;
                  _iteratorError16 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion16 && _iterator16.return) {
                      _iterator16.return();
                    }
                  } finally {
                    if (_didIteratorError16) {
                      throw _iteratorError16;
                    }
                  }
                }

                return doc;
              };

              _context43.prev = 1;

              if (_this6._methodSpecs) {
                _context43.next = 9;
                break;
              }

              _context43.next = 5;
              return lively.modules.module("lively.storage/objectdb.js").source();

            case 5:
              src = _context43.sent;
              parsed = lively.ast.parse(src, { withComments: true });
              entities = lively.ast.categorizer.findDecls(parsed);

              _this6._methodSpecs = entities.filter(function (ea) {
                return ea.parent && ea.parent.name === "ObjectDBInterface";
              });

            case 9:
              return _context43.abrupt("return", method ? methodNameAndParametersAndDescription(_this6._methodSpecs, method) : _this6._methodSpecs.map(function (ea) {
                return methodNameAndParametersAndDescription(_this6._methodSpecs, ea.name);
              }).filter(Boolean));

            case 12:
              _context43.prev = 12;
              _context43.t0 = _context43["catch"](1);
              return _context43.abrupt("return", "Error in describe " + _context43.t0);

            case 15:
            case "end":
              return _context43.stop();
          }
        }
      }, _callee42, _this6, [[1, 12]]);
    }))();
  },
  ensureDB: function ensureDB(args) {
    var _this7 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee43() {
      var _checkArgs, dbName, snapshotLocation, db;

      return regeneratorRuntime.wrap(function _callee43$(_context44) {
        while (1) {
          switch (_context44.prev = _context44.next) {
            case 0:
              _checkArgs = checkArgs(args, {
                db: "string",
                snapshotLocation: "string|Resource"
              });
              dbName = _checkArgs.db;
              snapshotLocation = _checkArgs.snapshotLocation;
              _context44.next = 5;
              return ObjectDB.find(dbName);

            case 5:
              db = _context44.sent;

              if (!db) {
                _context44.next = 8;
                break;
              }

              return _context44.abrupt("return", false);

            case 8:
              ObjectDB.named(dbName, { snapshotLocation: snapshotLocation });
              return _context44.abrupt("return", true);

            case 10:
            case "end":
              return _context44.stop();
          }
        }
      }, _callee43, _this7);
    }))();
  },
  destroyDB: function destroyDB(args) {
    var _this8 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee44() {
      var _checkArgs2, dbName, db;

      return regeneratorRuntime.wrap(function _callee44$(_context45) {
        while (1) {
          switch (_context45.prev = _context45.next) {
            case 0:
              _checkArgs2 = checkArgs(args, { db: "string" });
              dbName = _checkArgs2.db;
              _context45.next = 4;
              return ObjectDB.find(dbName);

            case 4:
              db = _context45.sent;

              if (db) {
                _context45.next = 7;
                break;
              }

              return _context45.abrupt("return", false);

            case 7:
              _context45.next = 9;
              return db.destroy();

            case 9:
              return _context45.abrupt("return", true);

            case 10:
            case "end":
              return _context45.stop();
          }
        }
      }, _callee44, _this8);
    }))();
  },
  fetchCommits: function fetchCommits(args) {
    var _this9 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee45() {
      var _checkArgs3, dbName, ref, type, typesAndNames, knownCommitIds, includeDeleted, filterFn, db, commitDB, versionDB, versionQueryOpts, refsByTypeAndName, keys, _iteratorNormalCompletion17, _didIteratorError17, _iteratorError17, _iterator17, _step17, _ref73, _type2, name, _ref74, versions, commitIds, _iteratorNormalCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step18, version, _id, refs, commitId, commits, fn, filteredCommits;

      return regeneratorRuntime.wrap(function _callee45$(_context46) {
        while (1) {
          switch (_context46.prev = _context46.next) {
            case 0:
              _checkArgs3 = checkArgs(args, {
                db: "string",
                ref: "string|undefined",
                type: "string|undefined",
                typesAndNames: "Array|undefined",
                knownCommitIds: "object|undefined",
                includeDeleted: "boolean|undefined",
                filterFn: "string|undefined"
              });
              dbName = _checkArgs3.db;
              ref = _checkArgs3.ref;
              type = _checkArgs3.type;
              typesAndNames = _checkArgs3.typesAndNames;
              knownCommitIds = _checkArgs3.knownCommitIds;
              includeDeleted = _checkArgs3.includeDeleted;
              filterFn = _checkArgs3.filterFn;
              _context46.next = 10;
              return ObjectDB.find(dbName);

            case 10:
              db = _context46.sent;

              if (!ref) ref = "HEAD";

              if (db) {
                _context46.next = 14;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 14:
              _context46.t0 = db.__commitDB;

              if (_context46.t0) {
                _context46.next = 19;
                break;
              }

              _context46.next = 18;
              return db._commitDB();

            case 18:
              _context46.t0 = _context46.sent;

            case 19:
              commitDB = _context46.t0;
              _context46.t1 = db.__versionDB;

              if (_context46.t1) {
                _context46.next = 25;
                break;
              }

              _context46.next = 24;
              return db._versionDB();

            case 24:
              _context46.t1 = _context46.sent;

            case 25:
              versionDB = _context46.t1;
              versionQueryOpts = {}, refsByTypeAndName = {};

              if (!typesAndNames) {
                _context46.next = 50;
                break;
              }

              keys = versionQueryOpts.keys = [];
              _iteratorNormalCompletion17 = true;
              _didIteratorError17 = false;
              _iteratorError17 = undefined;
              _context46.prev = 32;

              for (_iterator17 = typesAndNames[Symbol.iterator](); !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                _ref73 = _step17.value;
                _type2 = _ref73.type, name = _ref73.name, _ref74 = _ref73.ref;

                keys.push(_type2 + "/" + name);
                if (_ref74) refsByTypeAndName[_type2 + "/" + name] = _ref74;
              }

              _context46.next = 40;
              break;

            case 36:
              _context46.prev = 36;
              _context46.t2 = _context46["catch"](32);
              _didIteratorError17 = true;
              _iteratorError17 = _context46.t2;

            case 40:
              _context46.prev = 40;
              _context46.prev = 41;

              if (!_iteratorNormalCompletion17 && _iterator17.return) {
                _iterator17.return();
              }

            case 43:
              _context46.prev = 43;

              if (!_didIteratorError17) {
                _context46.next = 46;
                break;
              }

              throw _iteratorError17;

            case 46:
              return _context46.finish(43);

            case 47:
              return _context46.finish(40);

            case 48:
              _context46.next = 51;
              break;

            case 50:
              if (type) {
                versionQueryOpts.startkey = type + "/\0\"";
                versionQueryOpts.endkey = type + "/\uFFFF\"";
              }

            case 51:
              _context46.next = 53;
              return versionDB.getAll(versionQueryOpts);

            case 53:
              versions = _context46.sent;
              commitIds = [];
              _iteratorNormalCompletion18 = true;
              _didIteratorError18 = false;
              _iteratorError18 = undefined;
              _context46.prev = 58;
              _iterator18 = versions[Symbol.iterator]();

            case 60:
              if (_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done) {
                _context46.next = 73;
                break;
              }

              version = _step18.value;

              if (!(version.deleted || version._deleted)) {
                _context46.next = 64;
                break;
              }

              return _context46.abrupt("continue", 70);

            case 64:
              _id = version._id, refs = version.refs;

              if (!_id.startsWith("_")) {
                _context46.next = 67;
                break;
              }

              return _context46.abrupt("continue", 70);

            case 67:
              ref = refsByTypeAndName[_id] || ref;
              commitId = refs[ref];

              if (commitId && !knownCommitIds || !knownCommitIds.hasOwnProperty(commitId)) commitIds.push(commitId);

            case 70:
              _iteratorNormalCompletion18 = true;
              _context46.next = 60;
              break;

            case 73:
              _context46.next = 79;
              break;

            case 75:
              _context46.prev = 75;
              _context46.t3 = _context46["catch"](58);
              _didIteratorError18 = true;
              _iteratorError18 = _context46.t3;

            case 79:
              _context46.prev = 79;
              _context46.prev = 80;

              if (!_iteratorNormalCompletion18 && _iterator18.return) {
                _iterator18.return();
              }

            case 82:
              _context46.prev = 82;

              if (!_didIteratorError18) {
                _context46.next = 85;
                break;
              }

              throw _iteratorError18;

            case 85:
              return _context46.finish(82);

            case 86:
              return _context46.finish(79);

            case 87:
              _context46.next = 89;
              return db.getCommitsWithIds(commitIds);

            case 89:
              commits = _context46.sent;

              if (!includeDeleted) commits = commits.filter(function (ea) {
                return !ea.deleted;
              });

              if (!filterFn) {
                _context46.next = 107;
                break;
              }

              _context46.prev = 92;
              fn = eval("(" + filterFn + ")");

              if (!(typeof fn !== "function")) {
                _context46.next = 96;
                break;
              }

              throw new Error(filterFn + " does not eval to a function!");

            case 96:
              filteredCommits = commits.filter(fn);

              if (Array.isArray(filteredCommits)) {
                _context46.next = 101;
                break;
              }

              throw new Error(filterFn + " does not return an array!");

            case 101:
              commits = filteredCommits;

            case 102:
              _context46.next = 107;
              break;

            case 104:
              _context46.prev = 104;
              _context46.t4 = _context46["catch"](92);

              console.error("fetchCommits filterFn failed:", _context46.t4);

            case 107:
              return _context46.abrupt("return", commits);

            case 108:
            case "end":
              return _context46.stop();
          }
        }
      }, _callee45, _this9, [[32, 36, 40, 48], [41,, 43, 47], [58, 75, 79, 87], [80,, 82, 86], [92, 104]]);
    }))();
  },
  fetchVersionGraph: function fetchVersionGraph(args) {
    var _this10 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee46() {
      var _checkArgs4, dbName, type, name, db, _ref75, refs, history;

      return regeneratorRuntime.wrap(function _callee46$(_context47) {
        while (1) {
          switch (_context47.prev = _context47.next) {
            case 0:
              _checkArgs4 = checkArgs(args, {
                db: "string",
                type: "string",
                name: "string"
              });
              dbName = _checkArgs4.db;
              type = _checkArgs4.type;
              name = _checkArgs4.name;
              _context47.next = 6;
              return ObjectDB.find(dbName);

            case 6:
              db = _context47.sent;

              if (db) {
                _context47.next = 9;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 9:
              _context47.next = 11;
              return db.versionGraph(type, name);

            case 11:
              _ref75 = _context47.sent;
              refs = _ref75.refs;
              history = _ref75.history;
              return _context47.abrupt("return", { refs: refs, history: history });

            case 15:
            case "end":
              return _context47.stop();
          }
        }
      }, _callee46, _this10);
    }))();
  },
  exists: function exists(args) {
    var _this11 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee47() {
      var _checkArgs5, dbName, type, name, ref, db, hist, commit;

      return regeneratorRuntime.wrap(function _callee47$(_context48) {
        while (1) {
          switch (_context48.prev = _context48.next) {
            case 0:
              _checkArgs5 = checkArgs(args, {
                db: "string",
                type: "string",
                name: "string",
                ref: "string|undefined"
              });
              dbName = _checkArgs5.db;
              type = _checkArgs5.type;
              name = _checkArgs5.name;
              ref = _checkArgs5.ref;
              _context48.next = 7;
              return ObjectDB.find(dbName);

            case 7:
              db = _context48.sent;
              _context48.next = 10;
              return db.versionGraph(type, name);

            case 10:
              hist = _context48.sent;

              if (hist) {
                _context48.next = 13;
                break;
              }

              return _context48.abrupt("return", { exists: false, commitId: undefined });

            case 13:
              ref = ref || "HEAD";
              commit = hist.refs[ref];

              if (commit) {
                _context48.next = 17;
                break;
              }

              return _context48.abrupt("return", { exists: false, commitId: undefined });

            case 17:
              return _context48.abrupt("return", { exists: true, commitId: commit });

            case 18:
            case "end":
              return _context48.stop();
          }
        }
      }, _callee47, _this11);
    }))();
  },
  fetchLog: function fetchLog(args) {
    var _this12 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee48() {
      var _checkArgs6, dbName, type, name, ref, commit, limit, includeCommits, knownCommitIds, db, defaultRef, startCommitId, realCommit, versionGraph, refs, history, currentCommit, result, ancestors, _ancestors;

      return regeneratorRuntime.wrap(function _callee48$(_context49) {
        while (1) {
          switch (_context49.prev = _context49.next) {
            case 0:
              _checkArgs6 = checkArgs(args, {
                db: "string",
                type: "string|undefined",
                name: "string|undefined",
                ref: "string|undefined",
                commit: "string|undefined",
                limit: "number|undefined",
                includeCommits: "boolean|undefined",
                knownCommitIds: "object|undefined"
              }, function (args) {
                return args.type && args.name || args.commit ? null : { error: "Eiter .type + .name or .commit needed!" };
              });
              dbName = _checkArgs6.db;
              type = _checkArgs6.type;
              name = _checkArgs6.name;
              ref = _checkArgs6.ref;
              commit = _checkArgs6.commit;
              limit = _checkArgs6.limit;
              includeCommits = _checkArgs6.includeCommits;
              knownCommitIds = _checkArgs6.knownCommitIds;
              _context49.next = 11;
              return ObjectDB.find(dbName);

            case 11:
              db = _context49.sent;
              defaultRef = ref || "HEAD";

              if (db) {
                _context49.next = 15;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 15:

              if (!limit) limit = Infinity;
              if (!commit && !ref) ref = defaultRef;

              startCommitId = void 0;

              if (!commit) {
                _context49.next = 28;
                break;
              }

              startCommitId = commit;

              if (!(!type || !name)) {
                _context49.next = 28;
                break;
              }

              _context49.next = 23;
              return db.getCommit(commit);

            case 23:
              realCommit = _context49.sent;

              if (realCommit) {
                _context49.next = 26;
                break;
              }

              throw new Error("fetchLog: specified commit " + commit + " but no commit with this id is in the database!");

            case 26:
              type = realCommit.type;
              name = realCommit.name;

            case 28:
              _context49.next = 30;
              return db.versionGraph(type, name);

            case 30:
              versionGraph = _context49.sent;

              if (versionGraph) {
                _context49.next = 33;
                break;
              }

              throw new Error("Unknown object " + type + "/" + name);

            case 33:
              refs = versionGraph.refs, history = versionGraph.history;

              if (!startCommitId) startCommitId = refs[ref];

              currentCommit = startCommitId, result = [];

            case 36:
              if (!(result.length < limit && !result.includes(currentCommit))) {
                _context49.next = 45;
                break;
              }

              result.push(currentCommit);
              ancestors = history[currentCommit];

              if (!(!ancestors || !ancestors.length)) {
                _context49.next = 41;
                break;
              }

              return _context49.abrupt("break", 45);

            case 41:
              _ancestors = slicedToArray(ancestors, 1);
              currentCommit = _ancestors[0];
              _context49.next = 36;
              break;

            case 45:
              if (!includeCommits) {
                _context49.next = 50;
                break;
              }

              if (knownCommitIds) result = result.filter(function (id) {
                return !knownCommitIds.hasOwnProperty(id);
              });
              _context49.next = 49;
              return db.getCommitsWithIds(result);

            case 49:
              result = _context49.sent;

            case 50:
              return _context49.abrupt("return", result);

            case 51:
            case "end":
              return _context49.stop();
          }
        }
      }, _callee48, _this12);
    }))();
  },
  fetchSnapshot: function fetchSnapshot(args) {
    var _this13 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee49() {
      var _checkArgs7, dbName, type, name, ref, commitId, db, defaultRef, versionGraph, commit;

      return regeneratorRuntime.wrap(function _callee49$(_context50) {
        while (1) {
          switch (_context50.prev = _context50.next) {
            case 0:
              _checkArgs7 = checkArgs(args, {
                db: "string",
                type: "string|undefined",
                name: "string|undefined",
                ref: "string|undefined",
                commit: "string|undefined"
              }, function (args) {
                return args.type && args.name || args.commit ? null : { error: "Eiter .type + .name or .commit needed!" };
              });
              dbName = _checkArgs7.db;
              type = _checkArgs7.type;
              name = _checkArgs7.name;
              ref = _checkArgs7.ref;
              commitId = _checkArgs7.commit;
              _context50.next = 8;
              return ObjectDB.find(dbName);

            case 8:
              db = _context50.sent;
              defaultRef = "HEAD";


              ref = ref || defaultRef;

              if (db) {
                _context50.next = 13;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 13:
              if (commitId) {
                _context50.next = 22;
                break;
              }

              _context50.next = 16;
              return db.versionGraph(type, name);

            case 16:
              versionGraph = _context50.sent;

              if (versionGraph) {
                _context50.next = 19;
                break;
              }

              throw new Error("Unknown object " + type + "/" + name);

            case 19:
              commitId = versionGraph.refs[ref];

              if (commitId) {
                _context50.next = 22;
                break;
              }

              throw new Error("Cannot find commit for ref " + ref + " of " + type + "/" + name);

            case 22:
              _context50.next = 24;
              return db.getCommit(commitId);

            case 24:
              commit = _context50.sent;

              if (commit) {
                _context50.next = 27;
                break;
              }

              throw new Error("Cannot find commit " + commitId);

            case 27:
              return _context50.abrupt("return", db.loadSnapshot(undefined, undefined, commit));

            case 28:
            case "end":
              return _context50.stop();
          }
        }
      }, _callee49, _this13);
    }))();
  },
  revert: function revert(args) {
    var _this14 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee50() {
      var _checkArgs8, dbName, type, name, ref, toCommitId, db;

      return regeneratorRuntime.wrap(function _callee50$(_context51) {
        while (1) {
          switch (_context51.prev = _context51.next) {
            case 0:
              _checkArgs8 = checkArgs(args, {
                db: "string",
                type: "string", name: "string",
                ref: "string|undefined",
                toCommitId: "string"
              });
              dbName = _checkArgs8.db;
              type = _checkArgs8.type;
              name = _checkArgs8.name;
              ref = _checkArgs8.ref;
              toCommitId = _checkArgs8.toCommitId;
              _context51.next = 8;
              return ObjectDB.find(dbName);

            case 8:
              db = _context51.sent;


              if (!ref) ref = "HEAD";
              return _context51.abrupt("return", db.revert(type, name, ref, toCommitId));

            case 11:
            case "end":
              return _context51.stop();
          }
        }
      }, _callee50, _this14);
    }))();
  },
  commit: function commit(args) {
    var _this15 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee51() {
      var _checkArgs9, dbName, type, name, ref, expectedParentCommit, commitSpec, snapshot, preview, db;

      return regeneratorRuntime.wrap(function _callee51$(_context52) {
        while (1) {
          switch (_context52.prev = _context52.next) {
            case 0:
              _checkArgs9 = checkArgs(args, {
                db: "string",
                type: "string", name: "string",
                ref: "string|undefined",
                snapshot: "object|string|undefined",
                preview: "string|undefined",
                commitSpec: "object",
                expectedParentCommit: "string|undefined"
              });
              dbName = _checkArgs9.db;
              type = _checkArgs9.type;
              name = _checkArgs9.name;
              ref = _checkArgs9.ref;
              expectedParentCommit = _checkArgs9.expectedParentCommit;
              commitSpec = _checkArgs9.commitSpec;
              snapshot = _checkArgs9.snapshot;
              preview = _checkArgs9.preview;
              _context52.next = 11;
              return ObjectDB.find(dbName);

            case 11:
              db = _context52.sent;


              if (!ref) ref = "HEAD";
              return _context52.abrupt("return", db.commit(type, name, snapshot, commitSpec, preview, ref, expectedParentCommit));

            case 14:
            case "end":
              return _context52.stop();
          }
        }
      }, _callee51, _this15);
    }))();
  },
  exportToSpecs: function exportToSpecs(args) {
    var _this16 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee52() {
      var _checkArgs10, dbName, nameAndTypes, db;

      return regeneratorRuntime.wrap(function _callee52$(_context53) {
        while (1) {
          switch (_context53.prev = _context53.next) {
            case 0:
              _checkArgs10 = checkArgs(args, {
                db: "string",
                nameAndTypes: "Array|undefined",
                includeDeleted: "boolean|undefined"
              });
              dbName = _checkArgs10.db;
              nameAndTypes = _checkArgs10.nameAndTypes;
              _context53.next = 5;
              return ObjectDB.find(dbName);

            case 5:
              db = _context53.sent;

              if (db) {
                _context53.next = 8;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 8:
              return _context53.abrupt("return", db.exportToSpecs(nameAndTypes));

            case 9:
            case "end":
              return _context53.stop();
          }
        }
      }, _callee52, _this16);
    }))();
  },
  exportToDir: function exportToDir(args) {
    var _this17 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee53() {
      var _checkArgs11, dbName, url, nameAndTypes, copyResources, includeDeleted, db, exportDir;

      return regeneratorRuntime.wrap(function _callee53$(_context54) {
        while (1) {
          switch (_context54.prev = _context54.next) {
            case 0:
              _checkArgs11 = checkArgs(args, {
                db: "string",
                url: "string",
                nameAndTypes: "Array|undefined",
                copyResources: "boolean|undefined",
                includeDeleted: "boolean|undefined"
              });
              dbName = _checkArgs11.db;
              url = _checkArgs11.url;
              nameAndTypes = _checkArgs11.nameAndTypes;
              copyResources = _checkArgs11.copyResources;
              includeDeleted = _checkArgs11.includeDeleted;
              _context54.next = 8;
              return ObjectDB.find(dbName);

            case 8:
              db = _context54.sent;
              exportDir = void 0;

              if (db) {
                _context54.next = 12;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 12:
              try {
                exportDir = lively_resources.resource(url);
              } catch (err) {
                exportDir = lively_resources.resource(System.baseURL).join(url);
              }
              return _context54.abrupt("return", db.exportToDir(exportDir, nameAndTypes, copyResources, includeDeleted));

            case 14:
            case "end":
              return _context54.stop();
          }
        }
      }, _callee53, _this17);
    }))();
  },
  importFromDir: function importFromDir(args) {
    var _this18 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee54() {
      var _checkArgs12, dbName, url, overwrite, copyResources, db, importDir;

      return regeneratorRuntime.wrap(function _callee54$(_context55) {
        while (1) {
          switch (_context55.prev = _context55.next) {
            case 0:
              _checkArgs12 = checkArgs(args, {
                db: "string", url: "string",
                overwrite: "boolean|undefined",
                copyResources: "boolean|undefined"
              });
              dbName = _checkArgs12.db;
              url = _checkArgs12.url;
              overwrite = _checkArgs12.overwrite;
              copyResources = _checkArgs12.copyResources;
              _context55.next = 7;
              return ObjectDB.find(dbName);

            case 7:
              db = _context55.sent;
              importDir = void 0;

              if (db) {
                _context55.next = 11;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 11:
              try {
                importDir = lively_resources.resource(url);
              } catch (err) {
                importDir = lively_resources.resource(System.baseURL).join(url);
              }
              return _context55.abrupt("return", db.importFromDir(importDir, overwrite, copyResources));

            case 13:
            case "end":
              return _context55.stop();
          }
        }
      }, _callee54, _this18);
    }))();
  },
  importFromSpecs: function importFromSpecs(args) {
    var _this19 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee55() {
      var _checkArgs13, dbName, specs, overwrite, copyResources, db;

      return regeneratorRuntime.wrap(function _callee55$(_context56) {
        while (1) {
          switch (_context56.prev = _context56.next) {
            case 0:
              _checkArgs13 = checkArgs(args, {
                db: "string",
                specs: "object",
                overwrite: "boolean|undefined",
                copyResources: "boolean|undefined"
              });
              dbName = _checkArgs13.db;
              specs = _checkArgs13.specs;
              overwrite = _checkArgs13.overwrite;
              copyResources = _checkArgs13.copyResources;
              _context56.next = 7;
              return ObjectDB.find(dbName);

            case 7:
              db = _context56.sent;

              if (db) {
                _context56.next = 10;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 10:
              return _context56.abrupt("return", db.importFromSpecs(specs, overwrite, copyResources));

            case 11:
            case "end":
              return _context56.stop();
          }
        }
      }, _callee55, _this19);
    }))();
  },
  importFromResource: function importFromResource(args) {
    var _this20 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee56() {
      var _checkArgs14, dbName, type, name, url, commitSpec, purgeHistory, db, res;

      return regeneratorRuntime.wrap(function _callee56$(_context57) {
        while (1) {
          switch (_context57.prev = _context57.next) {
            case 0:
              _checkArgs14 = checkArgs(args, {
                db: "string",
                type: "string", name: "string",
                url: "string",
                commitSpec: "object",
                purgeHistory: "boolean|undefined"
              });
              dbName = _checkArgs14.db;
              type = _checkArgs14.type;
              name = _checkArgs14.name;
              url = _checkArgs14.url;
              commitSpec = _checkArgs14.commitSpec;
              purgeHistory = _checkArgs14.purgeHistory;
              _context57.next = 9;
              return ObjectDB.find(dbName);

            case 9:
              db = _context57.sent;
              res = void 0;

              if (db) {
                _context57.next = 13;
                break;
              }

              throw new Error("db " + dbName + " does not exist");

            case 13:
              try {
                res = lively_resources.resource(url);
              } catch (err) {
                res = lively_resources.resource(System.baseURL).join(url);
              }
              return _context57.abrupt("return", db.importFromResource(type, name, res, commitSpec, purgeHistory));

            case 15:
            case "end":
              return _context57.stop();
          }
        }
      }, _callee56, _this20);
    }))();
  },
  delete: function _delete(args) {
    var _this21 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee57() {
      var _checkArgs15, dbName, type, name, dryRun, db;

      return regeneratorRuntime.wrap(function _callee57$(_context58) {
        while (1) {
          switch (_context58.prev = _context58.next) {
            case 0:
              _checkArgs15 = checkArgs(args, {
                db: "string", type: "string", name: "string",
                dryRun: "boolean|undefined"
              });
              dbName = _checkArgs15.db;
              type = _checkArgs15.type;
              name = _checkArgs15.name;
              dryRun = _checkArgs15.dryRun;
              _context58.next = 7;
              return ObjectDB.find(dbName);

            case 7:
              db = _context58.sent;
              return _context58.abrupt("return", db.delete(type, name, typeof dryRun === "undefined" || dryRun));

            case 9:
            case "end":
              return _context58.stop();
          }
        }
      }, _callee57, _this21);
    }))();
  },
  deleteCommit: function deleteCommit(args) {
    var _this22 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee58() {
      var _checkArgs16, dbName, commit, dryRun, db;

      return regeneratorRuntime.wrap(function _callee58$(_context59) {
        while (1) {
          switch (_context59.prev = _context59.next) {
            case 0:
              _checkArgs16 = checkArgs(args, {
                db: "string", commit: "string",
                dryRun: "boolean|undefined"
              });
              dbName = _checkArgs16.db;
              commit = _checkArgs16.commit;
              dryRun = _checkArgs16.dryRun;
              _context59.next = 6;
              return ObjectDB.find(dbName);

            case 6:
              db = _context59.sent;
              return _context59.abrupt("return", db.deleteCommit(commit, typeof dryRun === "undefined" || dryRun));

            case 8:
            case "end":
              return _context59.stop();
          }
        }
      }, _callee58, _this22);
    }))();
  },
  fetchConflicts: function fetchConflicts(args) {
    var _this23 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee59() {
      var _checkArgs17, dbName, includeDocs, only, db;

      return regeneratorRuntime.wrap(function _callee59$(_context60) {
        while (1) {
          switch (_context60.prev = _context60.next) {
            case 0:
              _checkArgs17 = checkArgs(args, {
                db: "string",
                includeDocs: "boolean|undefined",
                only: "object|undefined"
              });
              dbName = _checkArgs17.db;
              includeDocs = _checkArgs17.includeDocs;
              only = _checkArgs17.only;
              _context60.next = 6;
              return ObjectDB.find(dbName);

            case 6:
              db = _context60.sent;
              return _context60.abrupt("return", db.getConflicts(includeDocs, only));

            case 8:
            case "end":
              return _context60.stop();
          }
        }
      }, _callee59, _this23);
    }))();
  },
  resolveConflict: function resolveConflict(args) {
    var _this24 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee60() {
      var _checkArgs18, dbName, resolved, del, kind, id, db;

      return regeneratorRuntime.wrap(function _callee60$(_context61) {
        while (1) {
          switch (_context61.prev = _context61.next) {
            case 0:
              _checkArgs18 = checkArgs(args, {
                db: "string",
                id: "string",
                kind: "string",
                delete: "Array",
                resolved: "object"
              });
              dbName = _checkArgs18.db;
              resolved = _checkArgs18.resolved;
              del = _checkArgs18.delete;
              kind = _checkArgs18.kind;
              id = _checkArgs18.id;
              _context61.next = 8;
              return ObjectDB.find(dbName);

            case 8:
              db = _context61.sent;
              return _context61.abrupt("return", db.resolveConflict({ resolved: resolved, delete: del, kind: kind, id: id }));

            case 10:
            case "end":
              return _context61.stop();
          }
        }
      }, _callee60, _this24);
    }))();
  },
  fetchDiff: function fetchDiff(args) {
    var _this25 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee61() {
      var _checkArgs19, dbName, otherDB, db;

      return regeneratorRuntime.wrap(function _callee61$(_context62) {
        while (1) {
          switch (_context62.prev = _context62.next) {
            case 0:
              _checkArgs19 = checkArgs(args, {
                db: "string",
                otherDB: "string"
              });
              dbName = _checkArgs19.db;
              otherDB = _checkArgs19.otherDB;
              _context62.next = 5;
              return ObjectDB.find(dbName);

            case 5:
              db = _context62.sent;
              return _context62.abrupt("return", db.getDiff(otherDB));

            case 7:
            case "end":
              return _context62.stop();
          }
        }
      }, _callee61, _this25);
    }))();
  },
  synchronize: function synchronize(args) {
    var _this26 = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee62() {
      var _checkArgs20, dbName, otherDB, otherDBSnapshotLocation, onlyTypesAndNames, method, db, db1, db2, remoteCommitDB, remoteVersionDB, toSnapshotLocation, opts, rep;

      return regeneratorRuntime.wrap(function _callee62$(_context63) {
        while (1) {
          switch (_context63.prev = _context63.next) {
            case 0:
              _checkArgs20 = checkArgs(args, {
                db: "string",
                otherDB: "string",
                otherDBSnapshotLocation: "string|undefined",
                onlyTypesAndNames: "object|undefined",
                method: "string|undefined"
              });
              dbName = _checkArgs20.db;
              otherDB = _checkArgs20.otherDB;
              otherDBSnapshotLocation = _checkArgs20.otherDBSnapshotLocation;
              onlyTypesAndNames = _checkArgs20.onlyTypesAndNames;
              method = _checkArgs20.method;
              _context63.next = 8;
              return ObjectDB.find(dbName);

            case 8:
              db = _context63.sent;


              if (!otherDBSnapshotLocation) otherDBSnapshotLocation = otherDB.replace(/\/$/, "") + "/" + "snapshots";
              if (!method) method = "replicateTo";

              _context63.next = 13;
              return ObjectDB.find(dbName);

            case 13:
              db1 = _context63.sent;
              _context63.next = 16;
              return ObjectDB.named(otherDB, { snapshotLocation: otherDBSnapshotLocation });

            case 16:
              db2 = _context63.sent;
              _context63.next = 19;
              return db2._commitDB();

            case 19:
              remoteCommitDB = _context63.sent;
              _context63.next = 22;
              return db2._versionDB();

            case 22:
              remoteVersionDB = _context63.sent;
              toSnapshotLocation = db2.snapshotLocation;
              opts = {
                replicationFilter: onlyTypesAndNames ? { onlyTypesAndNames: onlyTypesAndNames } : undefined,
                retry: true, live: true
              };
              rep = db1[method](remoteCommitDB, remoteVersionDB, toSnapshotLocation, opts);
              _context63.next = 28;
              return rep.whenPaused();

            case 28:
              _context63.next = 30;
              return rep.safeStop();

            case 30:
              _context63.next = 32;
              return rep.waitForIt();

            case 32:
              return _context63.abrupt("return", lively_lang.obj.select(rep, ["state", "method", "conflicts", "errors", "changesByTypeAndName"]));

            case 33:
            case "end":
              return _context63.stop();
          }
        }
      }, _callee62, _this26);
    }))();
  }
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


// let httpDB = new ObjectDBHTTPInterface()
// await httpDB.exportToSpecs({db: "test-object-db"})

var ObjectDBHTTPInterface = function () {
  function ObjectDBHTTPInterface() {
    var serverURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.location.origin + "/objectdb/";
    classCallCheck(this, ObjectDBHTTPInterface);

    this.serverURL = serverURL;
  }

  createClass(ObjectDBHTTPInterface, [{
    key: "_processResponse",
    value: function () {
      var _ref76 = asyncToGenerator(regeneratorRuntime.mark(function _callee63(res) {
        var contentType, answer, json;
        return regeneratorRuntime.wrap(function _callee63$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                contentType = res.headers.get("content-type");
                _context64.next = 3;
                return res.text();

              case 3:
                answer = _context64.sent;
                json = void 0;

                if (contentType === "application/json") {
                  try {
                    json = JSON.parse(answer);
                  } catch (err) {}
                }

                if (!(!res.ok || json && json.error)) {
                  _context64.next = 8;
                  break;
                }

                throw new Error(json && json.error || answer || res.statusText);

              case 8:
                return _context64.abrupt("return", json || answer);

              case 9:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee63, this);
      }));

      function _processResponse(_x98) {
        return _ref76.apply(this, arguments);
      }

      return _processResponse;
    }()
  }, {
    key: "_GET",
    value: function () {
      var _ref77 = asyncToGenerator(regeneratorRuntime.mark(function _callee64(action) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var query, url;
        return regeneratorRuntime.wrap(function _callee64$(_context65) {
          while (1) {
            switch (_context65.prev = _context65.next) {
              case 0:
                query = Object.keys(opts).map(function (key) {
                  var val = opts[key];
                  if ((typeof val === "undefined" ? "undefined" : _typeof(val)) === "object") val = JSON.stringify(val);
                  return key + "=" + encodeURIComponent(val);
                }).join("&"), url = this.serverURL + action + "?" + query;
                _context65.t0 = this;
                _context65.next = 4;
                return fetch(url);

              case 4:
                _context65.t1 = _context65.sent;
                return _context65.abrupt("return", _context65.t0._processResponse.call(_context65.t0, _context65.t1));

              case 6:
              case "end":
                return _context65.stop();
            }
          }
        }, _callee64, this);
      }));

      function _GET(_x99) {
        return _ref77.apply(this, arguments);
      }

      return _GET;
    }()
  }, {
    key: "_POST",
    value: function () {
      var _ref78 = asyncToGenerator(regeneratorRuntime.mark(function _callee65(action) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var url;
        return regeneratorRuntime.wrap(function _callee65$(_context66) {
          while (1) {
            switch (_context66.prev = _context66.next) {
              case 0:
                url = this.serverURL + action;
                _context66.t0 = this;
                _context66.next = 4;
                return fetch(url, {
                  method: "POST", body: JSON.stringify(opts),
                  headers: { "content-type": "application/json" }
                });

              case 4:
                _context66.t1 = _context66.sent;
                return _context66.abrupt("return", _context66.t0._processResponse.call(_context66.t0, _context66.t1));

              case 6:
              case "end":
                return _context66.stop();
            }
          }
        }, _callee65, this);
      }));

      function _POST(_x101) {
        return _ref78.apply(this, arguments);
      }

      return _POST;
    }()
  }, {
    key: "describe",
    value: function () {
      var _ref79 = asyncToGenerator(regeneratorRuntime.mark(function _callee66(args) {
        return regeneratorRuntime.wrap(function _callee66$(_context67) {
          while (1) {
            switch (_context67.prev = _context67.next) {
              case 0:
                return _context67.abrupt("return", this._GET("describe", args));

              case 1:
              case "end":
                return _context67.stop();
            }
          }
        }, _callee66, this);
      }));

      function describe(_x103) {
        return _ref79.apply(this, arguments);
      }

      return describe;
    }()
  }, {
    key: "ensureDB",
    value: function () {
      var _ref80 = asyncToGenerator(regeneratorRuntime.mark(function _callee67(args) {
        return regeneratorRuntime.wrap(function _callee67$(_context68) {
          while (1) {
            switch (_context68.prev = _context68.next) {
              case 0:
                return _context68.abrupt("return", this._POST("ensureDB", args));

              case 1:
              case "end":
                return _context68.stop();
            }
          }
        }, _callee67, this);
      }));

      function ensureDB(_x104) {
        return _ref80.apply(this, arguments);
      }

      return ensureDB;
    }()
  }, {
    key: "destroyDB",
    value: function () {
      var _ref81 = asyncToGenerator(regeneratorRuntime.mark(function _callee68(args) {
        return regeneratorRuntime.wrap(function _callee68$(_context69) {
          while (1) {
            switch (_context69.prev = _context69.next) {
              case 0:
                return _context69.abrupt("return", this._POST("destroyDB", args));

              case 1:
              case "end":
                return _context69.stop();
            }
          }
        }, _callee68, this);
      }));

      function destroyDB(_x105) {
        return _ref81.apply(this, arguments);
      }

      return destroyDB;
    }()
  }, {
    key: "fetchCommits",
    value: function () {
      var _ref82 = asyncToGenerator(regeneratorRuntime.mark(function _callee69(args) {
        return regeneratorRuntime.wrap(function _callee69$(_context70) {
          while (1) {
            switch (_context70.prev = _context70.next) {
              case 0:
                return _context70.abrupt("return", this._GET("fetchCommits", args));

              case 1:
              case "end":
                return _context70.stop();
            }
          }
        }, _callee69, this);
      }));

      function fetchCommits(_x106) {
        return _ref82.apply(this, arguments);
      }

      return fetchCommits;
    }()
  }, {
    key: "fetchVersionGraph",
    value: function () {
      var _ref83 = asyncToGenerator(regeneratorRuntime.mark(function _callee70(args) {
        return regeneratorRuntime.wrap(function _callee70$(_context71) {
          while (1) {
            switch (_context71.prev = _context71.next) {
              case 0:
                return _context71.abrupt("return", this._GET("fetchVersionGraph", args));

              case 1:
              case "end":
                return _context71.stop();
            }
          }
        }, _callee70, this);
      }));

      function fetchVersionGraph(_x107) {
        return _ref83.apply(this, arguments);
      }

      return fetchVersionGraph;
    }()
  }, {
    key: "exists",
    value: function () {
      var _ref84 = asyncToGenerator(regeneratorRuntime.mark(function _callee71(args) {
        return regeneratorRuntime.wrap(function _callee71$(_context72) {
          while (1) {
            switch (_context72.prev = _context72.next) {
              case 0:
                return _context72.abrupt("return", this._GET("exists", args));

              case 1:
              case "end":
                return _context72.stop();
            }
          }
        }, _callee71, this);
      }));

      function exists(_x108) {
        return _ref84.apply(this, arguments);
      }

      return exists;
    }()
  }, {
    key: "fetchLog",
    value: function () {
      var _ref85 = asyncToGenerator(regeneratorRuntime.mark(function _callee72(args) {
        return regeneratorRuntime.wrap(function _callee72$(_context73) {
          while (1) {
            switch (_context73.prev = _context73.next) {
              case 0:
                return _context73.abrupt("return", this._GET("fetchLog", args));

              case 1:
              case "end":
                return _context73.stop();
            }
          }
        }, _callee72, this);
      }));

      function fetchLog(_x109) {
        return _ref85.apply(this, arguments);
      }

      return fetchLog;
    }()
  }, {
    key: "fetchSnapshot",
    value: function () {
      var _ref86 = asyncToGenerator(regeneratorRuntime.mark(function _callee73(args) {
        return regeneratorRuntime.wrap(function _callee73$(_context74) {
          while (1) {
            switch (_context74.prev = _context74.next) {
              case 0:
                return _context74.abrupt("return", this._GET("fetchSnapshot", args));

              case 1:
              case "end":
                return _context74.stop();
            }
          }
        }, _callee73, this);
      }));

      function fetchSnapshot(_x110) {
        return _ref86.apply(this, arguments);
      }

      return fetchSnapshot;
    }()
  }, {
    key: "revert",
    value: function () {
      var _ref87 = asyncToGenerator(regeneratorRuntime.mark(function _callee74(args) {
        return regeneratorRuntime.wrap(function _callee74$(_context75) {
          while (1) {
            switch (_context75.prev = _context75.next) {
              case 0:
                return _context75.abrupt("return", this._POST("revert", args));

              case 1:
              case "end":
                return _context75.stop();
            }
          }
        }, _callee74, this);
      }));

      function revert(_x111) {
        return _ref87.apply(this, arguments);
      }

      return revert;
    }()
  }, {
    key: "commit",
    value: function () {
      var _ref88 = asyncToGenerator(regeneratorRuntime.mark(function _callee75(args) {
        return regeneratorRuntime.wrap(function _callee75$(_context76) {
          while (1) {
            switch (_context76.prev = _context76.next) {
              case 0:
                return _context76.abrupt("return", this._POST("commit", args));

              case 1:
              case "end":
                return _context76.stop();
            }
          }
        }, _callee75, this);
      }));

      function commit(_x112) {
        return _ref88.apply(this, arguments);
      }

      return commit;
    }()
  }, {
    key: "exportToSpecs",
    value: function () {
      var _ref89 = asyncToGenerator(regeneratorRuntime.mark(function _callee76(args) {
        return regeneratorRuntime.wrap(function _callee76$(_context77) {
          while (1) {
            switch (_context77.prev = _context77.next) {
              case 0:
                return _context77.abrupt("return", this._GET("exportToSpecs", args));

              case 1:
              case "end":
                return _context77.stop();
            }
          }
        }, _callee76, this);
      }));

      function exportToSpecs(_x113) {
        return _ref89.apply(this, arguments);
      }

      return exportToSpecs;
    }()
  }, {
    key: "exportToDir",
    value: function () {
      var _ref90 = asyncToGenerator(regeneratorRuntime.mark(function _callee77(args) {
        return regeneratorRuntime.wrap(function _callee77$(_context78) {
          while (1) {
            switch (_context78.prev = _context78.next) {
              case 0:
                return _context78.abrupt("return", this._POST("exportToDir", args));

              case 1:
              case "end":
                return _context78.stop();
            }
          }
        }, _callee77, this);
      }));

      function exportToDir(_x114) {
        return _ref90.apply(this, arguments);
      }

      return exportToDir;
    }()
  }, {
    key: "importFromDir",
    value: function () {
      var _ref91 = asyncToGenerator(regeneratorRuntime.mark(function _callee78(args) {
        return regeneratorRuntime.wrap(function _callee78$(_context79) {
          while (1) {
            switch (_context79.prev = _context79.next) {
              case 0:
                return _context79.abrupt("return", this._POST("importFromDir", args));

              case 1:
              case "end":
                return _context79.stop();
            }
          }
        }, _callee78, this);
      }));

      function importFromDir(_x115) {
        return _ref91.apply(this, arguments);
      }

      return importFromDir;
    }()
  }, {
    key: "importFromSpecs",
    value: function () {
      var _ref92 = asyncToGenerator(regeneratorRuntime.mark(function _callee79(args) {
        return regeneratorRuntime.wrap(function _callee79$(_context80) {
          while (1) {
            switch (_context80.prev = _context80.next) {
              case 0:
                return _context80.abrupt("return", this._POST("importFromSpecs", args));

              case 1:
              case "end":
                return _context80.stop();
            }
          }
        }, _callee79, this);
      }));

      function importFromSpecs(_x116) {
        return _ref92.apply(this, arguments);
      }

      return importFromSpecs;
    }()
  }, {
    key: "importFromResource",
    value: function () {
      var _ref93 = asyncToGenerator(regeneratorRuntime.mark(function _callee80(args) {
        return regeneratorRuntime.wrap(function _callee80$(_context81) {
          while (1) {
            switch (_context81.prev = _context81.next) {
              case 0:
                return _context81.abrupt("return", this._POST("importFromResource", args));

              case 1:
              case "end":
                return _context81.stop();
            }
          }
        }, _callee80, this);
      }));

      function importFromResource(_x117) {
        return _ref93.apply(this, arguments);
      }

      return importFromResource;
    }()
  }, {
    key: "delete",
    value: function () {
      var _ref94 = asyncToGenerator(regeneratorRuntime.mark(function _callee81(args) {
        return regeneratorRuntime.wrap(function _callee81$(_context82) {
          while (1) {
            switch (_context82.prev = _context82.next) {
              case 0:
                return _context82.abrupt("return", this._POST("delete", args));

              case 1:
              case "end":
                return _context82.stop();
            }
          }
        }, _callee81, this);
      }));

      function _delete(_x118) {
        return _ref94.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "deleteCommit",
    value: function () {
      var _ref95 = asyncToGenerator(regeneratorRuntime.mark(function _callee82(args) {
        return regeneratorRuntime.wrap(function _callee82$(_context83) {
          while (1) {
            switch (_context83.prev = _context83.next) {
              case 0:
                return _context83.abrupt("return", this._POST("deleteCommit", args));

              case 1:
              case "end":
                return _context83.stop();
            }
          }
        }, _callee82, this);
      }));

      function deleteCommit(_x119) {
        return _ref95.apply(this, arguments);
      }

      return deleteCommit;
    }()
  }, {
    key: "fetchConflicts",
    value: function () {
      var _ref96 = asyncToGenerator(regeneratorRuntime.mark(function _callee83(args) {
        return regeneratorRuntime.wrap(function _callee83$(_context84) {
          while (1) {
            switch (_context84.prev = _context84.next) {
              case 0:
                return _context84.abrupt("return", this._GET("fetchConflicts", args));

              case 1:
              case "end":
                return _context84.stop();
            }
          }
        }, _callee83, this);
      }));

      function fetchConflicts(_x120) {
        return _ref96.apply(this, arguments);
      }

      return fetchConflicts;
    }()
  }, {
    key: "resolveConflict",
    value: function () {
      var _ref97 = asyncToGenerator(regeneratorRuntime.mark(function _callee84(args) {
        return regeneratorRuntime.wrap(function _callee84$(_context85) {
          while (1) {
            switch (_context85.prev = _context85.next) {
              case 0:
                return _context85.abrupt("return", this._POST("resolveConflict", args));

              case 1:
              case "end":
                return _context85.stop();
            }
          }
        }, _callee84, this);
      }));

      function resolveConflict(_x121) {
        return _ref97.apply(this, arguments);
      }

      return resolveConflict;
    }()
  }, {
    key: "fetchDiff",
    value: function () {
      var _ref98 = asyncToGenerator(regeneratorRuntime.mark(function _callee85(args) {
        return regeneratorRuntime.wrap(function _callee85$(_context86) {
          while (1) {
            switch (_context86.prev = _context86.next) {
              case 0:
                return _context86.abrupt("return", this._GET("fetchDiff", args));

              case 1:
              case "end":
                return _context86.stop();
            }
          }
        }, _callee85, this);
      }));

      function fetchDiff(_x122) {
        return _ref98.apply(this, arguments);
      }

      return fetchDiff;
    }()
  }, {
    key: "synchronize",
    value: function () {
      var _ref99 = asyncToGenerator(regeneratorRuntime.mark(function _callee86(args) {
        return regeneratorRuntime.wrap(function _callee86$(_context87) {
          while (1) {
            switch (_context87.prev = _context87.next) {
              case 0:
                return _context87.abrupt("return", this._POST("synchronize", args));

              case 1:
              case "end":
                return _context87.stop();
            }
          }
        }, _callee86, this);
      }));

      function synchronize(_x123) {
        return _ref99.apply(this, arguments);
      }

      return synchronize;
    }()
  }]);
  return ObjectDBHTTPInterface;
}();

var debug = false;
var slashRe = /\//g;

function applyExclude(resource$$1, exclude) {
  if (!exclude) return true;
  if (typeof exclude === "string") return !resource$$1.url.includes(exclude);
  if (typeof exclude === "function") return !exclude(resource$$1);
  if (exclude instanceof RegExp) return !exclude.test(resource$$1.url);
  return true;
}

// await StorageDatabase.databases.get("lively.storage-worlds").destroy()
var StorageDatabase = function (_Database) {
  inherits(StorageDatabase, _Database);

  function StorageDatabase() {
    classCallCheck(this, StorageDatabase);
    return possibleConstructorReturn(this, (StorageDatabase.__proto__ || Object.getPrototypeOf(StorageDatabase)).apply(this, arguments));
  }

  createClass(StorageDatabase, null, [{
    key: "ensureDB",
    value: function ensureDB(name, options) {
      return get$1(StorageDatabase.__proto__ || Object.getPrototypeOf(StorageDatabase), "ensureDB", this).call(this, "lively.storage-" + name, options);
    }
  }]);
  return StorageDatabase;
}(Database);

var LivelyStorageResource = function (_Resource) {
  inherits(LivelyStorageResource, _Resource);

  function LivelyStorageResource() {
    classCallCheck(this, LivelyStorageResource);
    return possibleConstructorReturn(this, (LivelyStorageResource.__proto__ || Object.getPrototypeOf(LivelyStorageResource)).apply(this, arguments));
  }

  createClass(LivelyStorageResource, [{
    key: "read",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var file, content;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                debug && console.log("[" + this + "] read");
                _context.next = 3;
                return this.db.get(this.pathWithoutQuery());

              case 3:
                file = _context.sent;
                content = file && file.content;
                return _context.abrupt("return", !content ? "" : typeof content === "string" ? content : JSON.stringify(content));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _ref.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readJson",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        var content;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.read();

              case 2:
                content = _context2.sent;
                return _context2.abrupt("return", typeof content === "string" ? JSON.parse(content) : content);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readJson() {
        return _ref2.apply(this, arguments);
      }

      return readJson;
    }()
  }, {
    key: "write",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee3(content) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                debug && console.log("[" + this + "] write");
                if (!content) content = "";

                if (!this.isDirectory()) {
                  _context3.next = 4;
                  break;
                }

                throw new Error("Cannot write into a directory! (" + this.url + ")");

              case 4:
                _context3.next = 6;
                return this.db.update(this.pathWithoutQuery(), function (spec) {
                  if (spec && spec.isDirectory) throw new Error(_this3.url + " already exists and is a directory (cannot write into it!)");
                  var t = Date.now();
                  if (!spec) {
                    return {
                      etag: undefined,
                      type: undefined,
                      contentType: undefined,
                      user: undefined,
                      group: undefined,
                      mode: undefined,
                      lastModified: t,
                      created: t,
                      size: typeof content === "string" ? content.length : 0,
                      content: content
                    };
                  }

                  return _extends({}, spec, {
                    lastModified: t,
                    size: content.length,
                    content: content
                  });
                });

              case 6:
                return _context3.abrupt("return", this);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function write(_x) {
        return _ref3.apply(this, arguments);
      }

      return write;
    }()
  }, {
    key: "writeJson",
    value: function writeJson(obj$$1) {
      return this.write(obj$$1);
    }
  }, {
    key: "mkdir",
    value: function () {
      var _ref4 = asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
        var spec, t;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                debug && console.log("[" + this + "] mkdir");

                if (this.isDirectory()) {
                  _context4.next = 3;
                  break;
                }

                throw new Error("Cannot mkdir a file! (" + this.url + ")");

              case 3:
                _context4.next = 5;
                return this.db.get(this.pathWithoutQuery());

              case 5:
                spec = _context4.sent;

                if (!spec) {
                  _context4.next = 10;
                  break;
                }

                if (spec.isDirectory) {
                  _context4.next = 9;
                  break;
                }

                throw new Error(this.url + " already exists and is a file (cannot mkdir it!)");

              case 9:
                return _context4.abrupt("return", this);

              case 10:
                t = Date.now();
                _context4.next = 13;
                return this.db.set(this.pathWithoutQuery(), {
                  etag: undefined,
                  type: undefined,
                  contentType: undefined,
                  user: undefined,
                  group: undefined,
                  mode: undefined,
                  lastModified: t,
                  created: t,
                  isDirectory: true
                });

              case 13:
                return _context4.abrupt("return", this);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function mkdir() {
        return _ref4.apply(this, arguments);
      }

      return mkdir;
    }()
  }, {
    key: "exists",
    value: function () {
      var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                debug && console.log("[" + this + "] exists");
                _context5.t0 = this.isRoot();

                if (_context5.t0) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return this.db.get(this.pathWithoutQuery());

              case 5:
                _context5.t0 = !!_context5.sent;

              case 6:
                return _context5.abrupt("return", _context5.t0);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function exists() {
        return _ref5.apply(this, arguments);
      }

      return exists;
    }()
  }, {
    key: "remove",
    value: function () {
      var _ref6 = asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
        var thisPath, db, matching;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                debug && console.log("[" + this + "] remove");
                thisPath = this.pathWithoutQuery();
                db = this.db;
                _context6.next = 5;
                return db.docList({ startkey: thisPath, endkey: thisPath + "\uFFFF" });

              case 5:
                matching = _context6.sent;
                _context6.next = 8;
                return db.setDocuments(matching.map(function (_ref7) {
                  var _id = _ref7.id,
                      _rev = _ref7.rev;
                  return { _id: _id, _rev: _rev, _deleted: true };
                }));

              case 8:
                return _context6.abrupt("return", this);

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function remove() {
        return _ref6.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "readProperties",
    value: function readProperties() {
      debug && console.log("[" + this + "] readProperties");
      return this.db.get(this.pathWithoutQuery());
    }
  }, {
    key: "dirList",
    value: function () {
      var _ref8 = asyncToGenerator(regeneratorRuntime.mark(function _callee7() {
        var _this4 = this;

        var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var exclude, prefix, children, docs, i, doc, path, isDirectory, trailing, childDepth, _ret, child, propNames, props, _i;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                debug && console.log("[" + this + "] dirList");

                if (this.isDirectory()) {
                  _context7.next = 3;
                  break;
                }

                return _context7.abrupt("return", this.asDirectory().dirList(depth, opts));

              case 3:
                exclude = opts.exclude;
                prefix = this.pathWithoutQuery();
                children = [];
                _context7.next = 8;
                return this.db.getAll({ startkey: prefix, endkey: prefix + "\uFFFF" });

              case 8:
                docs = _context7.sent;


                if (depth === "infinity") depth = Infinity;

                i = 0;

              case 11:
                if (!(i < docs.length)) {
                  _context7.next = 29;
                  break;
                }

                doc = docs[i], path = doc._id, isDirectory = doc.isDirectory;

                if (!(!path.startsWith(prefix) || prefix === path)) {
                  _context7.next = 15;
                  break;
                }

                return _context7.abrupt("continue", 26);

              case 15:
                trailing = path.slice(prefix.length), childDepth = trailing.includes("/") ? trailing.match(slashRe).length + 1 : 1;

                if (!(childDepth > depth)) {
                  _context7.next = 20;
                  break;
                }

                _ret = function () {
                  // add the dirs pointing to child
                  var dirToChild = _this4.join(trailing.split("/").slice(0, depth).join("/") + "/");
                  if (!children.some(function (ea) {
                    return ea.equals(dirToChild);
                  })) children.push(dirToChild);
                  return "continue";
                }();

                if (!(_ret === "continue")) {
                  _context7.next = 20;
                  break;
                }

                return _context7.abrupt("continue", 26);

              case 20:
                child = this.join(trailing);

                if (!(exclude && !applyExclude(child, exclude))) {
                  _context7.next = 23;
                  break;
                }

                return _context7.abrupt("continue", 26);

              case 23:
                children.push(child);
                propNames = ["created", "lastModified", "mode", "group", "user", "contentType", "type", "etag", "size"], props = {};

                for (_i = 0; _i < propNames.length; _i++) {
                  child[propNames[_i]] = doc[propNames[_i]];
                }

              case 26:
                i++;
                _context7.next = 11;
                break;

              case 29:
                return _context7.abrupt("return", children);

              case 30:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function dirList() {
        return _ref8.apply(this, arguments);
      }

      return dirList;
    }()
  }, {
    key: "canDealWithJSON",
    get: function get() {
      return true;
    }
  }, {
    key: "db",
    get: function get() {
      return this._db || (this._db = StorageDatabase.ensureDB(this.host()));
    }
  }]);
  return LivelyStorageResource;
}(lively_resources.Resource);

var resourceExtension = {
  name: "lively.storage",
  matches: function matches(url) {
    return url.startsWith("lively.storage:");
  },
  resourceClass: LivelyStorageResource

  // will install resource extension:
};lively_resources.registerExtension(resourceExtension);

// to trigger resource extension

exports.Database = Database;
exports.ObjectDB = ObjectDB;
exports.ObjectDBInterface = ObjectDBInterface;
exports.ObjectDBHTTPInterface = ObjectDBHTTPInterface;

}((this.lively.storage = this.lively.storage || {}),PouchDB,pouchdbAdapterMem,lively.lang,lively.resources));

  }).call(GLOBAL);
  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.storage;
})();


})();
